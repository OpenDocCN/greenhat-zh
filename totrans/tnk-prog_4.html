<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Solving Problems with Pointers and Dynamic Memory"><div class="titlepage"><div><div><h1 class="title"><a id="solving_problems_with_pointers_and_dynam"/>Chapter 4. Solving Problems with Pointers and Dynamic Memory</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id4"/><div class="mediaobject"><a id="I_mediaobject4_d1e5164"/><img src="httpatomoreillycomsourcenostarchimages1273151.png.jpg" alt="image with no caption"/></div></div><p>In this chapter, we’ll learn to solve problems using pointers and dynamic memory, which will allow us to write flexible programs that can accommodate data sizes that are unknown until the program runs. Pointers and dynamic memory allocation are “hard-core” programming. When you can write programs that grab blocks of memory on the fly, link them into useful structures, and clean up everything at the end so there is no residue, you’re not just someone who can do a little coding—you’re a programmer.</p><p>Because pointers are tricky, and because many popular languages, such as Java, appear to forgo the use of pointers, some fledgling programmers will convince themselves that they can skip this subject entirely. This is a mistake. Pointers and indirect memory access will always be used in advanced programming, even though they may be hidden by the mechanisms of a high-level language. Therefore, to truly think like a programmer, you have to be able to think your way through pointers and pointer-based problems.</p><p>Before we get down to solving pointer problems, though, we’re going to carefully examine all aspects of how pointers work, both on the surface and behind the scenes. This study provides two benefits. First, this knowledge will allow us to make the most effective use of pointers. Second, by dispelling the mysteries of pointers, we can employ them with confidence.<a id="IDX-CHP-4-0001" class="indexterm"/><a id="IDX-CHP-4-0002" class="indexterm"/><a id="IDX-CHP-4-0003" class="indexterm"/><a id="IDX-CHP-4-0004" class="indexterm"/><a id="IDX-CHP-4-0005" class="indexterm"/><a id="IDX-CHP-4-0006" class="indexterm"/><a id="IDX-CHP-4-0007" class="indexterm"/><a id="IDX-CHP-4-0008" class="indexterm"/></p><div class="sect1" title="Review of Pointer Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="review_of_pointer_fundamentals"/>Review of Pointer Fundamentals</h1></div></div></div><p>As with topics covered in previous chapters, you should have had some exposure to basic pointer use, but to make sure we’re on the same page, here’s a quick review.</p><p>Pointers in C++ are indicated with an asterisk (<code class="literal">*</code>). Depending on the context, the asterisk indicates either that a pointer is being declared or that we mean the pointed-to memory, not the pointer itself. To declare a pointer, we place the asterisk between the type name and the identifier:</p><a id="I_programlisting4_d1e5219"/><pre class="programlisting">int * intPointer;</pre><p>This declares the variable <code class="literal">intPointer</code> as a pointer to an <code class="literal">int</code>. Note that the asterisk binds with the identifier, not the type. In the following, <code class="literal">variable1</code> is a pointer to an <code class="literal">int</code>, but <code class="literal">variable2</code> is just an <code class="literal">int</code>:</p><a id="I_programlisting4_d1e5242"/><pre class="programlisting">int * variable1, variable2;</pre><p>An ampersand in front of a variable acts as the <span class="emphasis"><em>address-of</em></span> operator. So we could assign the address of <code class="literal">variable2</code> to <code class="literal">variable1</code> with:</p><a id="I_programlisting4_d1e5255"/><pre class="programlisting">variable1 = &amp;variable2;</pre><p>We can also assign the value of one pointer variable to another directly:</p><a id="I_programlisting4_d1e5259"/><pre class="programlisting">intPointer = variable1;</pre><p>Perhaps most importantly, we can allocate memory during runtime that can be accessed only through a pointer. This is accomplished with the <code class="literal">new</code> operator:</p><a id="I_programlisting4_d1e5267"/><pre class="programlisting">double * doublePointer = new double;</pre><p>Accessing the memory at the other end of the pointer is known as <span class="emphasis"><em>dereferencing</em></span> and is accomplished with an asterisk to the left of a pointer identifier. Again, this is the same placement we would use for a pointer declaration. The context makes the meaning different. Here’s an example:<a id="IDX-CHP-4-0009" class="indexterm"/><a id="IDX-CHP-4-0010" class="indexterm"/></p><a id="I_programlisting4_d1e5282"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> *doublePointer = 35.4;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> double localDouble = *doublePointer;</pre><p>We assign a value to the double allocated by the previous code <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5297"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> before copying the value from this memory location to the variable <code class="literal">localDouble</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5306"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>.<a id="IDX-CHP-4-0011" class="indexterm"/><a id="IDX-CHP-4-0012" class="indexterm"/></p><p>To deallocate memory allocated with <code class="literal">new</code>, once we no longer need it, we use the keyword <code class="literal">delete</code>:</p><a id="I_programlisting4_d1e5330"/><pre class="programlisting">delete doublePointer;</pre><p>The mechanics of this process are described in detail in <a class="xref" href="ch04.html#memory_matters" title="Memory Matters">Memory Matters</a> in <a class="xref" href="ch04.html#memory_matters" title="Memory Matters">Memory Matters</a>.</p></div><div class="sect1" title="Benefits of Pointers"><div class="titlepage"><div><div><h1 class="title"><a id="benefits_of_pointers"/>Benefits of Pointers</h1></div></div></div><p>Pointers give us abilities not available with static memory allocation and also provide new opportunities for efficient use of memory. The three main benefits of using pointers are:<a id="IDX-CHP-4-0013" class="indexterm"/><a id="IDX-CHP-4-0014" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Runtime-sized data structures<a id="IDX-CHP-4-0015" class="indexterm"/></p></li><li class="listitem"><p>Resizable data structures<a id="IDX-CHP-4-0016" class="indexterm"/></p></li><li class="listitem"><p>Memory sharing</p></li></ul></div><p>Let’s take a look at each of these in a bit more detail.</p><div class="sect2" title="Runtime-Sized Data Structures"><div class="titlepage"><div><div><h2 class="title"><a id="runtime-sized_data_structures"/>Runtime-Sized Data Structures</h2></div></div></div><p>By using pointers, we can make an array with a size determined at runtime, rather than having to choose the size before building our application. This saves us from having to choose between potentially running out of space in the array and making the array as large as could possibly be needed, thereby wasting much of the array space in the average case. We first saw runtime data sizing in <a class="xref" href="ch03.html#deciding_when_to_use_arrays" title="Deciding When to Use Arrays">Deciding When to Use Arrays</a> in <a class="xref" href="ch03.html#deciding_when_to_use_arrays" title="Deciding When to Use Arrays">Deciding When to Use Arrays</a>. We’ll use this concept later in this chapter, in <a class="xref" href="ch04.html#variable-length_strings" title="Variable-Length Strings">Variable-Length Strings</a> in <a class="xref" href="ch04.html#solving_pointer_problems" title="Solving Pointer Problems">Solving Pointer Problems</a>.</p></div><div class="sect2" title="Resizable Data Structures"><div class="titlepage"><div><div><h2 class="title"><a id="resizable_data_structures"/>Resizable Data Structures</h2></div></div></div><p>We can also make pointer-based data structures that grow or shrink during runtime as needed. The most basic resizable data structure is the linked list, which you may have already seen. Although the data in the structure can be accessed only in sequential order, the linked list always has just as many places for data as it has data itself, with no wasted space. Other, more elaborate pointer-based data structures, as you will see later, have orderings and “shapes” that can reflect the relationship of the underlying data better than an array can. Because of this, even though an array offers full random-access that no pointer-based structure offers, the <span class="emphasis"><em>retrieval</em></span> operation (where we find the element in the structure that best meets a certain criterion) can be much faster with a pointer-based structure. We’ll use this benefit later in this chapter to create a data structure for student records that grows as needed.</p></div><div class="sect2" title="Memory Sharing"><div class="titlepage"><div><div><h2 class="title"><a id="memory_sharing"/>Memory Sharing</h2></div></div></div><p>Pointers can improve program efficiency by allowing memory blocks to be shared. For example, when we call a function, we can pass a pointer to a block of memory instead of passing a copy of the block using <span class="emphasis"><em>reference parameters</em></span>. You’ve most likely seen these before; they are parameters in which an ampersand (&amp;) appears between the type and the name in the formal parameter list:<a id="IDX-CHP-4-0017" class="indexterm"/><a id="IDX-CHP-4-0018" class="indexterm"/><a id="IDX-CHP-4-0019" class="indexterm"/><a id="IDX-CHP-4-0020" class="indexterm"/><a id="IDX-CHP-4-0021" class="indexterm"/><a id="IDX-CHP-4-0022" class="indexterm"/></p><a id="I_programlisting4_d1e5424"/><pre class="programlisting">void refParamFunction (int <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>&amp; x) {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>x = 10;
}

int number = 5;
refParamFunction(<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>number);
cout &lt;&lt; <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>number &lt;&lt; "\n";</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The spaces shown before and after the ampersand symbol are not required—I just include them here for aesthetic reasons. In other developers’ code, you may see <code class="literal">int&amp; x</code>, <code class="literal">int &amp;x</code>, or perhaps even <code class="literal">int&amp;x</code>.</p></div><p>In this code, the formal parameter <code class="literal">x</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5467"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> is not a copy of the argument <code class="literal">number</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5476"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>; rather, it is a reference to the memory where <code class="literal">number</code> is stored. Therefore, when <code class="literal">x</code> is changed <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5489"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, the memory space for <code class="literal">number</code> is changed, and the output at the end of the code snippet is <code class="literal">10</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5501"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. Reference parameters can be used as a mechanism to send values out of a function, as shown in this example. More broadly, reference parameters allow the called function and the calling function to share the same memory, thus lowering overhead. If a variable being passed as a parameter occupies a kilobyte of memory, passing the variable as a reference means copying a 32- or 64-bit pointer instead of the kilobyte. We can signal that we are using a reference parameter for performance, not its output, by using the <code class="literal">const</code> keyword:</p><a id="I_programlisting4_d1e5510"/><pre class="programlisting">int anotherFunction(const int &amp; x);</pre><p>By prefixing the word <code class="literal">const</code> in the declaration of the reference parameter <code class="literal">x</code>, <code class="literal">anotherFunction</code> will receive a reference to the argument passed in the call but will be unable to modify the value in that argument, just like any other <code class="literal">const</code> parameter.</p><p>In general, we can use pointers in this way to allow different parts of a program, or different data structures within the program, to have access to the same data without the overhead of copying.</p></div></div><div class="sect1" title="When to Use Pointers"><div class="titlepage"><div><div><h1 class="title"><a id="when_to_use_pointers"/>When to Use Pointers</h1></div></div></div><p>As we discussed with arrays, pointers have potential drawbacks and should be used only when appropriate. How do we know when pointer use is appropriate? Having just listed the benefits of pointers, we can say that pointers should be used only when we require one or more of their benefits. If your program needs a structure to hold an aggregate of data, but you can’t accurately estimate how much data ahead of runtime; if you need a structure that can grow and shrink during execution; or if you have large objects or other blocks of data being passed around your program, pointers may be the way to go. In the absence of any of these situations, though, you should be wary of pointers and dynamic memory allocation.<a id="IDX-CHP-4-0023" class="indexterm"/><a id="IDX-CHP-4-0024" class="indexterm"/><a id="IDX-CHP-4-0025" class="indexterm"/><a id="IDX-CHP-4-0026" class="indexterm"/><a id="IDX-CHP-4-0027" class="indexterm"/><a id="IDX-CHP-4-0028" class="indexterm"/><a id="IDX-CHP-4-0029" class="indexterm"/><a id="IDX-CHP-4-0030" class="indexterm"/></p><p>Given pointers’ notorious reputation as one of the most difficult C++ features, you might think that no programmer would ever try to use a pointer when it isn’t necessary. I have been surprised many times, however, to find otherwise. Sometimes programmers simply trick themselves into thinking a pointer is required. Suppose you are making a call to a function written by someone else, from a library or application programming interface, perhaps, with the following prototype:</p><a id="I_programlisting4_d1e5565"/><pre class="programlisting">void compute(int input, int* output);</pre><p>We might imagine that this function is written in C, not C++, and that is why it uses a pointer rather than a reference (<code class="literal">&amp;</code>) to make an “outgoing” parameter. In calling this function, a programmer might carelessly do something like this:</p><a id="I_programlisting4_d1e5572"/><pre class="programlisting">int num1 = 10;
int* num2 = new int;
compute(num1, num2);</pre><p>This code is inefficient in space because it creates a pointer where none is needed. Instead of the space for two integers, it uses the space for two integers and a pointer. The code is also inefficient in time because the unnecessary memory allocation takes time (as explained in the next section). Lastly, the programmer now has to remember to <code class="literal">delete</code> the allocated memory. All of this could’ve been avoided by using the other aspect of the <code class="literal">&amp;</code> operator, which allows you to get the address of a statically allocated variable, like this:</p><a id="I_programlisting4_d1e5582"/><pre class="programlisting">int num1 = 10;
int num2;
compute(num1, &amp;num2);</pre><p>Strictly speaking, we’re still using a pointer in the second version, but we’re using it implicitly, without a pointer variable or dynamic memory allocation.</p></div><div class="sect1" title="Memory Matters"><div class="titlepage"><div><div><h1 class="title"><a id="memory_matters"/>Memory Matters</h1></div></div></div><p>To understand how dynamic memory allocation gives us runtime sizing and memory sharing, we have to understand a little bit about how memory allocation works in general. This is one of the areas where I think it benefits new programmers to learn C++. All programmers must eventually understand how memory systems work in a modern computer, and C++ forces you to face this issue head-on. Other languages hide enough of the dirty details of memory systems that new programmers convince themselves that these details are of no concern, which is simply not the case. Rather, the details are of no concern so long as everything is working. As soon as there is a problem, however, ignorance of the underlying memory models creates an insurmountable obstacle between the programmer and the solution.<a id="IDX-CHP-4-0031" class="indexterm"/></p><div class="sect2" title="The Stack and the Heap"><div class="titlepage"><div><div><h2 class="title"><a id="the_stack_and_the_heap"/>The Stack and the Heap</h2></div></div></div><p>C++ allocates memory in two places: the <span class="emphasis"><em>stack</em></span> and the <span class="emphasis"><em>heap</em></span>. As the names imply, the stack is organized and neat, and the heap is disjointed and messy. The name <span class="emphasis"><em>stack</em></span> is especially descriptive because it helps you visualize the contiguous nature of the memory allocation. Think of a stack of crates, as in <a class="xref" href="ch04.html#a_stack_of_crates_and_a_stack_of_functio" title="Figure 4-1. A stack of crates and a stack of function calls">Figure 4-1</a> (a). When you have a crate to store, you place it on the top of the stack. To remove a particular crate from the stack, you have to first remove all the crates that are on top of it. In practical programming terms, this means that once you have allocated a block of memory (a crate) on the stack, there’s no way to resize it because at any time you may have other memory blocks immediately following it (other crates on top of it).<a id="IDX-CHP-4-0032" class="indexterm"/><a id="IDX-CHP-4-0033" class="indexterm"/><a id="IDX-CHP-4-0034" class="indexterm"/></p><p>In C++, you might explicitly create your own stack for use in a particular algorithm, but regardless, there is one stack your program will always be using, known as the program’s <span class="emphasis"><em>runtime stack</em></span>. Every time a function is called (and this includes the <code class="literal">main</code> function), a block of memory is allocated on the top of the runtime stack. This block of memory is called an <span class="emphasis"><em>activation record</em></span>. A full discussion of its contents is beyond the scope of this text, but for your understanding as a problem-solver, the main content of the activation record is the storage space for variables. Memory for all the local variables, including the function’s parameters, is allocated within the activation record. Let’s take a look at an example:<a id="IDX-CHP-4-0035" class="indexterm"/><a id="IDX-CHP-4-0036" class="indexterm"/><a id="IDX-CHP-4-0037" class="indexterm"/><a id="IDX-CHP-4-0038" class="indexterm"/></p><a id="I_programlisting4_d1e5651"/><pre class="programlisting">int functionB(int inputValue) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>return inputValue - 10;
}
int functionA(int num) {
    int localVariable = functionB(num * 10);
    return localVariable;
}
int main()
{
    int x = 12;
    int y = functionA(x);
    return 0;
}</pre><p>In this code, the <code class="literal">main</code> function calls <code class="literal">functionA</code>, which in turn calls <code class="literal">functionB</code>. <a class="xref" href="ch04.html#a_stack_of_crates_and_a_stack_of_functio" title="Figure 4-1. A stack of crates and a stack of function calls">Figure 4-1</a> (b) shows a simplified version of how the runtime stack would be arranged at the point right before we execute the return statement of <code class="literal">functionB</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5676"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. The activation records for all three functions would be arranged in a stack of contiguous memory, with the <code class="literal">main</code> function at the bottom of the stack. (Just to make things extra confusing, it’s possible that the stack begins at the highest possible point in memory and is built downward to lower memory addresses rather than upward to higher memory addresses. You do yourself no harm, though, by ignoring the possibility.) Logically, the <code class="literal">main</code> function activation record is on the bottom of the stack, with the <code class="literal">functionA</code> activation record on top of it and the <code class="literal">functionB</code> activation record on top of <code class="literal">functionA</code>. Neither of the lower two activation records can be removed before <code class="literal">functionB</code>’s activation record is removed.</p><div class="figure"><a id="a_stack_of_crates_and_a_stack_of_functio"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e5704"/><img src="httpatomoreillycomsourcenostarchimages1273207.png.jpg" alt="A stack of crates and a stack of function calls"/></div></div><p class="title">Figure 4-1. A stack of crates and a stack of function calls</p></div><p>While a stack is highly organized, a heap, by contrast, has little organization. Suppose you’re storing things in crates again, but these crates are fragile and you can’t stack them on top of each other. You’ve got a big, initially empty room to store the crates, and you can put them anywhere you want on the floor. The crates are heavy, however, so once you put one down, you’d rather just leave it where it is until you’re ready to take it out of the room. This system has advantages and disadvantages compared to the stack. On the one hand, this storage system is flexible and allows you to get to the contents of any crate at any time. On the other hand, the room is going to quickly become a mess. If the crates are all different sizes, it’s going to be especially difficult to make use of all of the available space on the floor. You’ll end up with a lot of gaps between crates that are too small to fill with another crate. Because the crates can’t be easily moved, removing several crates just creates several hard-to-fill gaps rather than providing the wide-open storage of our original empty floor. In practical programming terms, our heap is like the floor of that room. A block of memory is a contiguous series of addresses; thus, over the lifetime of a program with many memory allocations and deallocations, we’ll end up with lots of gaps between the remaining allocated memory blocks. This problem is known as <span class="emphasis"><em>memory fragmentation</em></span>.<a id="IDX-CHP-4-0039" class="indexterm"/><a id="IDX-CHP-4-0040" class="indexterm"/><a id="IDX-CHP-4-0041" class="indexterm"/><a id="IDX-CHP-4-0042" class="indexterm"/></p><p>Every program has its own heap, from which memory is dynamically allocated. In C++, this usually means an invocation of the <code class="literal">new</code> keyword, but you will also see calls to the old C functions for memory allocation, such as <code class="literal">malloc</code>. Each call to <code class="literal">new</code> (or <code class="literal">malloc</code>) sets aside a chunk of memory in the heap and returns a pointer to the chunk, while each call to <code class="literal">delete</code> (or <code class="literal">free</code> if the memory was allocated with <code class="literal">malloc</code>) returns the chunk to the pool of available heap memory. Because of fragmentation, not all of the memory in the pool is equally useful. If our program begins by allocating variables A, B, and C in heap memory, we might expect those blocks to be contiguous. If we deallocate B, the gap it leaves behind can be filled only by another request that is of B’s size or smaller, until either A or C is also deallocated.<a id="IDX-CHP-4-0043" class="indexterm"/><a id="IDX-CHP-4-0044" class="indexterm"/><a id="IDX-CHP-4-0045" class="indexterm"/><a id="IDX-CHP-4-0046" class="indexterm"/><a id="IDX-CHP-4-0047" class="indexterm"/></p><p><a class="xref" href="ch04.html#a_fragmented_floor_comma_a_crate_that_ca" title="Figure 4-2. A fragmented floor, a crate that cannot be placed, and fragmented memory">Figure 4-2</a> clarifies the situation. In part (a), we see the floor of our room littered with crates. At one point the room was probably well organized, but over time, the arrangement became haphazard. Now there is a small crate (b) that cannot fit in any open space on the floor, even though the overall unused floor area greatly exceeds the footprint of the crate. In part (c), we represent a small heap. The dashed-line squares are the smallest (indivisible) chunks of memory, which might be a single byte, a memory word, or something larger, depending on the heap manager. The shaded areas represent allocations of contiguous memory; for clarity, one allocation has some of its chunks numbered. As with the fragmented floor, the fragmented heap has the unallocated memory chunks separated, which reduces their usability. There are a total of 85 unused chunks of memory, but the largest contiguous range of unused memory, as indicated by the arrow, is only 17 chunks long. In other words, if each chunk were a byte, this heap could not fulfill any request from an invocation of <code class="literal">new</code> for more than 17 bytes, even though the heap has 85 bytes free.</p><div class="figure"><a id="a_fragmented_floor_comma_a_crate_that_ca"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e5788"/><img src="httpatomoreillycomsourcenostarchimages1273209.png.jpg" alt="A fragmented floor, a crate that cannot be placed, and fragmented memory"/></div></div><p class="title">Figure 4-2. A fragmented floor, a crate that cannot be placed, and fragmented memory</p></div></div><div class="sect2" title="Memory Size"><div class="titlepage"><div><div><h2 class="title"><a id="memory_size"/>Memory Size</h2></div></div></div><p>The first practical issue with memory is limiting its use to what is necessary. Modern computer systems have so much memory that it’s easy to think of it as an infinite resource, but in fact each program has a limited amount of memory. Also, programs need to use memory efficiently to avoid overall system slowdown. In a multitasking operating system (which means just about every modern operating system), every byte of memory wasted by one program pushes the system as a whole toward the point where the set of currently running programs doesn’t have enough memory to run. At that point, the operating system constantly swaps out chunks of one program for another and thus grinds to a crawl. This condition is known as <span class="emphasis"><em>thrashing</em></span>.<a id="IDX-CHP-4-0048" class="indexterm"/><a id="IDX-CHP-4-0049" class="indexterm"/><a id="IDX-CHP-4-0050" class="indexterm"/><a id="IDX-CHP-4-0051" class="indexterm"/></p><p>Note that, beyond the desire to keep the overall program memory footprint as small as possible, the stack and the heap have maximum sizes. To prove this, let’s allocate memory from the heap a kilobyte at a time, until something blows up:<a id="IDX-CHP-4-0052" class="indexterm"/><a id="IDX-CHP-4-0053" class="indexterm"/><a id="IDX-CHP-4-0054" class="indexterm"/><a id="IDX-CHP-4-0055" class="indexterm"/></p><a id="I_programlisting4_d1e5839"/><pre class="programlisting">const int intsPerKilobyte = 1024 / sizeof(int);
while (true) {
    int *oneKilobyteArray = new int[intsPerKilobyte];
}</pre><p>Let me emphasize that this is horrible code written purely to demonstrate a point. If you try this code out on your system, you should save all of your work first, just to be safe. What should happen is that the program halts and your operating system complains that the code generated but did not handle a <code class="literal">bad_alloc</code> exception. This exception is thrown by <code class="literal">new</code> when no block of unallocated memory in the heap is large enough to fulfill the request. Running out of heap memory is called a <span class="emphasis"><em>heap overflow</em></span>. On some systems, a heap overflow can be common, while on other systems, a program will cause thrashing long before it produces a <code class="literal">bad_alloc</code> (on my system, the <code class="literal">new</code> call didn’t fail until I had allocated two gigabytes in previous calls).<a id="IDX-CHP-4-0056" class="indexterm"/><a id="IDX-CHP-4-0057" class="indexterm"/><a id="IDX-CHP-4-0058" class="indexterm"/></p><p>A similar situation exists with the runtime stack. Each function call allocates space on the stack, and there is some fixed overhead for each activation record, even for a function with no parameters or local variables. The easiest way to demonstrate this is with a runaway recursive function:<a id="IDX-CHP-4-0059" class="indexterm"/></p><a id="I_programlisting4_d1e5877"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int count = 0;
  void stackOverflow() {
     <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>count++;
     <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>stackOverflow();
  }
  int main()
  {
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>stackOverflow();
     return 0;
  }</pre><p>This code has a global variable <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5904"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which in most cases is bad style, but here I need a value that persists throughout all of the recursive calls. As this variable is declared outside of the function, no memory is allocated for it in the function’s activation record, nor are there any other local variables or parameters. All the function does is increment <code class="literal">count</code> and make a recursive call <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5913"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Recursion is discussed extensively in <a class="xref" href="ch06.html" title="Chapter 6. Solving Problems with Recursion">Chapter 6</a> but is used here simply to make the chain of function calls as long as possible. The activation record of a function remains on the stack until that function ends. So when the first call is made to <code class="literal">stackOverflow</code> from <code class="literal">main</code>, an activation record is placed on the runtime stack that cannot be removed until that first function call ends. This will never happen because the function makes a second call to <code class="literal">stackOverflow</code>, placing another activation record on the stack, which then makes a third call, and so on. These activation records stack up until the stack runs out of room. On my system, <code class="literal">count</code> is around 4,900 when the program bombs. My development environment, Visual Studio, defaults to a 1MB stack allocation, which means that each of these function calls, even without any local variables or parameters, creates an activation record of over 200 bytes.<a id="IDX-CHP-4-0060" class="indexterm"/><a id="IDX-CHP-4-0061" class="indexterm"/><a id="IDX-CHP-4-0062" class="indexterm"/><a id="IDX-CHP-4-0063" class="indexterm"/></p></div><div class="sect2" title="Lifetime"><div class="titlepage"><div><div><h2 class="title"><a id="lifetime"/>Lifetime</h2></div></div></div><p>The <span class="emphasis"><em>lifetime</em></span> of a variable is the time span between allocation and deallocation. With a stack-based variable, meaning either a local variable or a parameter, the lifetime is handled implicitly. The variable is allocated when the function is called and deallocated when the function ends. With a heap-based variable, meaning a variable dynamically allocated using <code class="literal">new</code>, the lifetime is in our hands. Managing the lifetime of dynamically allocated variables is the bane of every C++ programmer. The most obvious issue is the dreaded <span class="emphasis"><em>memory leak</em></span>, a situation in which memory is allocated from the heap but never deallocated and not referenced by any pointer. Here’s a simple example:<a id="IDX-CHP-4-0064" class="indexterm"/><a id="IDX-CHP-4-0065" class="indexterm"/></p><a id="I_programlisting4_d1e5972"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int *intPtr = new int;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> intPtr = NULL;</pre><p>In this code, we declare a pointer to an integer <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5987"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, initializing it by allocating an integer from the heap. Then in the second line, we set our integer pointer to <code class="literal">NULL</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5996"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> (which is simply an alias for the number zero). The integer we allocated with <code class="literal">new</code> still exists, however. It sits, lonely and forlorn, in its place in the heap, awaiting a deallocation that can never come. We cannot deallocate the integer because to deallocate a block of memory, we use <code class="literal">delete</code> followed by a pointer to the block, and we no longer have a pointer to the block. If we tried to follow the code above with <code class="literal">delete intPtr</code>, we would get an error because <code class="literal">intPtr</code> is zero.</p><p>Sometimes, instead of memory that never gets deallocated, we have the opposite problem, attempting to deallocate the same memory twice, which produces a runtime error. This might seem like an easy problem to avoid: Just don’t call <code class="literal">delete</code> twice on the same variable. What makes this situation tricky is that we may have multiple variables pointing to the same memory. If multiple variables point to the same memory and we call <code class="literal">delete</code> on any of those variables, we have effectively deallocated the memory for all of the variables. If we don’t explicitly clear the variables to <code class="literal">NULL</code>, they will be known as <span class="emphasis"><em>dangling references</em></span>, and calling <code class="literal">delete</code> on any of them will produce a runtime error.<a id="IDX-CHP-4-0066" class="indexterm"/><a id="IDX-CHP-4-0067" class="indexterm"/></p></div></div><div class="sect1" title="Solving Pointer Problems"><div class="titlepage"><div><div><h1 class="title"><a id="solving_pointer_problems"/>Solving Pointer Problems</h1></div></div></div><p>By this point, you’re probably ready for some problems, so let’s look at a couple and see how we can use pointers and dynamic memory allocation to solve them. First we’ll work with some dynamically allocated arrays, which will demonstrate how to keep track of heap memory through all of our manipulations. Then we’ll get our feet wet with a truly dynamic structure.<a id="IDX-CHP-4-0068" class="indexterm"/><a id="IDX-CHP-4-0069" class="indexterm"/><a id="IDX-CHP-4-0070" class="indexterm"/></p><div class="sect2" title="Variable-Length Strings"><div class="titlepage"><div><div><h2 class="title"><a id="variable-length_strings"/>Variable-Length Strings</h2></div></div></div><p>In this first problem, we’re going to create functions to manipulate strings. Here, we’re using the term in its most general sense: a sequence of characters, regardless of how those characters are stored. Suppose we need to support three functions on our string type.<a id="IDX-CHP-4-0071" class="indexterm"/></p><div class="sidebar"><a id="problem_colon_variable-length_string_man"/><p class="title">Problem: Variable-length string manipulation</p><p>Write heap-based implementations for three required string functions:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>append</code></strong></span></dt><dd><p>This function takes a string and a character and appends the character to the end of the string.</p></dd><dt><span class="term"><strong class="userinput"><code>concatenate</code></strong></span></dt><dd><p>This function takes two strings and appends the characters of the second string onto the first.</p></dd><dt><span class="term"><strong class="userinput"><code>characterAt</code></strong></span></dt><dd><p>This function takes a string and a number and returns the character at that position in the string (with the first character in the string numbered zero).</p></dd></dl></div><p>Write the code with the assumption that <code class="literal">characterAt</code> will be called frequently, while the other two functions will be called relatively seldom. The relative efficiency of the operations should reflect the calling frequency.</p></div><p>In this case, we want to choose a representation for our string that allows for a fast <code class="literal">characterAt</code> function, which means we need a fast way to locate a particular character. As you probably recall from the previous chapter, this is what an array does best: random access. So let’s solve this problem using arrays of <code class="literal">char</code>. The <code class="literal">append</code> and <code class="literal">concatenate</code> functions change the size of the string, which means we run into all the array problems we discussed earlier. Because there’s no built-in limitation to the size of the string in this problem, we can’t pick a large initial size for our arrays and hope for the best. Instead, we’ll need to resize our arrays during runtime.</p><p>To start off, let’s create a <code class="literal">typedef</code> for our string type. We know we’re going to be dynamically creating our arrays, so we need to make our string type a pointer to <code class="literal">char</code>.</p><a id="I_programlisting4_d1e6121"/><pre class="programlisting">typedef char * arrayString;</pre><p>With that in place, let’s start on the functions. Using the principle of starting with what we already know how to do, we can quickly write the <code class="literal">characterAt</code> function.<a id="IDX-CHP-4-0072" class="indexterm"/><a id="IDX-CHP-4-0073" class="indexterm"/><a id="IDX-CHP-4-0074" class="indexterm"/><a id="IDX-CHP-4-0075" class="indexterm"/></p><a id="I_programlisting4_d1e6144"/><pre class="programlisting">char characterAt(arrayString s, int position) {
    <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>return s[position];
}</pre><p>Recall from <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a> that if a pointer is assigned the address of an array, we can access elements in the array using normal array notation <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6156"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Note, however, that bad things can happen if <code class="literal">position</code> is not actually a valid element number for the array <code class="literal">s</code>, and this code places the responsibility of validating the second parameter on the caller. We’ll consider alternatives to this situation in the exercises. For now, let’s move onto the <code class="literal">append</code> function. We can imagine what this function will do generally, but to get the specifics right, we should consider an example. This is a technique I call <span class="emphasis"><em>solving by sample case</em></span>.<a id="IDX-CHP-4-0076" class="indexterm"/><a id="IDX-CHP-4-0077" class="indexterm"/></p><p>Start with a nontrivial sample input for the function or program. Write down all the details of that input along with all the details of the output. Then when you write your code, you’ll be writing for the general case while also double-checking how each step transforms your sample to make sure that you reach the desired output state. This technique is especially helpful when dealing with pointers and dynamically allocated memory, because so much of what happens in the program is outside of direct view. Following through a case on paper forces you to track all the changing values in memory—not just those directly represented by variables but also those in the heap.</p><p>Suppose we start with the string <code class="literal">test</code>, which is to say we have an array of characters in the heap with <code class="literal">t</code>, <code class="literal">e</code>, <code class="literal">s</code>, and <code class="literal">t</code>, in that order, and we want to <code class="literal">append</code>, using our function, an exclamation point. <a class="xref" href="ch04.html#proposed_lbeforer_open_parenthesis_a_clo" title="Figure 4-3. Proposed “before” (a) and “after” (b) states for append function">Figure 4-3</a> shows the state of memory before (a) and after (b) this operation. In these diagrams, anything to the left of the dashed vertical line is stack memory (local variables or parameters) and anything to the right is heap memory, dynamically allocated using <code class="literal">new</code>.</p><div class="figure"><a id="proposed_lbeforer_open_parenthesis_a_clo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e6218"/><img src="httpatomoreillycomsourcenostarchimages1273211.png" alt="Proposed “before” (a) and “after” (b) states for append function"/></div></div><p class="title">Figure 4-3. Proposed “before” (a) and “after” (b) states for <code class="literal">append</code> function</p></div><p>Looking at this figure, right away I’m seeing a potential issue for our function. Based on our implementation approach for the strings, the function is going to create a new array that is one element larger than the original array and copy all the characters from the first array to the second. But how are we to know how large the first array is? From the previous chapter, we know that we have to track the size of our arrays ourselves. So something is missing.</p><p>If we’ve had experience working with strings in the standard C/C++ library, we will already know the missing ingredient, but if we don’t, we can quickly reason it out. Remember that one of our problem-solving techniques is <span class="emphasis"><em>looking for analogies</em></span>. Perhaps we should think about other problems in which the length of something was unknown. Back in <a class="xref" href="ch02.html" title="Chapter 2. Pure Puzzles">Chapter 2</a>, we processed identification codes with an arbitrary number of digits for the “Luhn Checksum Validation” problem. In that problem, we didn’t know how many digits the user would enter. In the end, we wrote a <code class="literal">while</code> loop that continued until the last character read was the end-of-line.<a id="IDX-CHP-4-0078" class="indexterm"/><a id="IDX-CHP-4-0079" class="indexterm"/><a id="IDX-CHP-4-0080" class="indexterm"/></p><p>Unfortunately, there is no end-of-line character waiting for us at the end of our arrays. But what if we <span class="emphasis"><em>put</em></span> an end-of-line character in the last element of all our string arrays? Then we could discover the length of our arrays the same way we discovered how many digits were in the identification codes. The only downside to this approach is that we could no longer use the end-of-line character in our strings, except as the string terminator. That’s not necessarily a huge restriction, depending on how the strings will be used, but for maximum flexibility, it would be best to choose a value that cannot be confused with any character anyone might actually want to use. Therefore, we’ll use a zero to terminate our arrays because a zero represents a null character in ASCII and other character code systems. This is exactly the method used by the standard C/C++ library.<a id="IDX-CHP-4-0081" class="indexterm"/><a id="IDX-CHP-4-0082" class="indexterm"/></p><p>With that issue cleared up, let’s get more specific about what <code class="literal">append</code> will do with our sample data. We know our function is going to have two parameters, the first being an <code class="literal">arrayString</code>, a pointer to an array of characters in the heap, and the second being the <code class="literal">char</code> to be appended. To keep things straight, let’s go ahead and write the outline of the <code class="literal">append</code> function and the code to test it.</p><a id="I_programlisting4_d1e6275"/><pre class="programlisting">void append(<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>arrayString&amp; s, char c) {
}
void appendTester() {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>arrayString a = new char[5];
    <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>a[0] = 't'; a[1] = 'e'; a[2] = 's'; a[3] = 't'; a[4] =  0;
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>append(a, '!');
    <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>cout &lt;&lt; a &lt;&lt; "\n";
}</pre><p>The <code class="literal">appendTester</code> function allocates our string in the heap <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6312"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Note that the size of the array is five, which is necessary so that we can assign all four letters of the word <code class="literal">test</code> along with our terminating null character <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6321"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Then we call <code class="literal">append</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6331"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>, which at this point is just an empty shell. When I wrote the shell, I realized that the <code class="literal">arrayString</code> parameter had to be a reference (<code class="literal">&amp;</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6343"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> because the function is going to create a new array in the heap. That’s the whole point, after all, of using dynamic memory here: to create a new array whenever the string is resized. Therefore, the value that the variable <code class="literal">a</code> has when passed to <code class="literal">append</code> is not the same value it should have when the function is through, because it needs to point to a new array. Note that because our arrays use the null-character termination expected by the standard libraries, we can send the array referenced by the pointer <code class="literal">a</code> directly to the output stream to check the value <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6359"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>.</p><p><a class="xref" href="ch04.html#updated_and_elaborated_memory_states_bef" title="Figure 4-4. Updated and elaborated memory states before (a) and after (b) the append function">Figure 4-4</a> shows our new understanding of what the function will do with our test case. The array terminators are in place, shown as <code class="literal">NULL</code> for clarity. In the after (b) state, it’s clear that <code class="literal">s</code> is pointing at a new allocation of memory. The previous array is now in a shaded box; in these diagrams, I’m using shaded boxes to indicate memory that has been deallocated. Including the allocated memory in our diagrams helps remind us to actually perform the deallocation.<a id="IDX-CHP-4-0083" class="indexterm"/><a id="IDX-CHP-4-0084" class="indexterm"/><a id="IDX-CHP-4-0085" class="indexterm"/></p><div class="figure"><a id="updated_and_elaborated_memory_states_bef"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e6391"/><img src="httpatomoreillycomsourcenostarchimages1273213.png.jpg" alt="Updated and elaborated memory states before (a) and after (b) the append function"/></div></div><p class="title">Figure 4-4. Updated and elaborated memory states before (a) and after (b) the <code class="literal">append</code> function</p></div><p>With everything properly visualized, we can write this function:</p><a id="I_programlisting4_d1e6398"/><pre class="programlisting">void append(arrayString&amp; s, char c) {
    int oldLength = 0;
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>while (s[oldLength] != 0) {
        oldLength++;
    }
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>arrayString newS = new char[oldLength + 2];
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>for (int i = 0; i &lt; oldLength; i++) {
        newS[i] = s[i];
    }
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>newS[oldLength] = c;
  <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>newS[oldLength + 1] = 0;
  <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>delete[] s;
  <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>s = newS;
}</pre><p>There’s a lot going on in this code, so let’s check it out piece by piece. At the beginning of the function, we have a loop to locate the null character that terminates our array <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6446"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. When the loop completes, <code class="literal">oldLength</code> will be the number of legitimate characters in the array (that is, not including the terminating null character). We allocate the new array from the heap with a size of <code class="literal">oldLength + 2</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6458"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. This is one of those details that is tricky to keep straight if you’re figuring it all out in your head but easy to get right if you have a diagram. Following the code through our example in <a class="xref" href="ch04.html#showing_the_relationship_of_a_local_vari" title="Figure 4-5. Showing the relationship of a local variable, parameters, and allocated memory before and after the append function">Figure 4-5</a>, we see that <code class="literal">oldLength</code> would be four in this case. We know that <code class="literal">oldLength</code> would be four because test has four characters and that the new array in part (b) requires six characters because we need space for the appended character and the null terminator.<a id="IDX-CHP-4-0086" class="indexterm"/><a id="IDX-CHP-4-0087" class="indexterm"/><a id="IDX-CHP-4-0088" class="indexterm"/></p><p>With the new array allocated, we copy all of the legitimate characters from the old array to the new <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6486"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, and we then assign the appended character <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6492"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> and the null character terminator <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6498"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span> to their appropriate locations in the new array. Again, our diagram helps us keep things straight. To make things even clearer, <a class="xref" href="ch04.html#showing_the_relationship_of_a_local_vari" title="Figure 4-5. Showing the relationship of a local variable, parameters, and allocated memory before and after the append function">Figure 4-5</a> shows how the value of <code class="literal">oldLength</code> was computed and what position that value would indicate in the new array. With that visual reminder, it’s easy to get the subscripts correct in those two assignment statements.</p><div class="figure"><a id="showing_the_relationship_of_a_local_vari"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e6515"/><img src="httpatomoreillycomsourcenostarchimages1273215.png.jpg" alt="Showing the relationship of a local variable, parameters, and allocated memory before and after the append function"/></div></div><p class="title">Figure 4-5. Showing the relationship of a local variable, parameters, and allocated memory before and after the <code class="literal">append</code> function</p></div><p>The last three lines in the <code class="literal">append</code> function are all about that shaded box in part (b) of the figure. To avoid a memory leak, we have to deallocate the array in the heap that our parameter <code class="literal">s</code> originally pointed to <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6528"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>. Finally, we leave our function with <code class="literal">s</code> pointing to the new, longer array <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6537"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. Unfortunately, one of the reasons memory leaks are so common in C++ programming is that until the total amount of memory leaks is large, the program and overall system will display no ill effects. Thus, the leaks can go totally unnoticed by programmers during testing. As programmers, therefore, we must be diligent and always consider the lifetime of our heap memory allocations. Every time you use the keyword <code class="literal">new</code>, think about where and when the corresponding <code class="literal">delete</code> will occur.<a id="IDX-CHP-4-0089" class="indexterm"/></p><p>Notice how everything in this function follows directly from our diagrams. Tricky programming becomes so much less tricky with good diagrams, and I wish more new programmers would take the time to draw before they code. This goes back to our most fundamental problem-solving principle: Always have a plan. A well-drawn diagram for a problem example is like having a mapped-out route to your destination before starting on a long vacation drive. It’s a little bit of extra effort at the start to potentially avoid much more effort and frustration at the end.<a id="IDX-CHP-4-0090" class="indexterm"/><a id="IDX-CHP-4-0091" class="indexterm"/><a id="IDX-CHP-4-0092" class="indexterm"/></p><div class="sidebar"><a id="creating_diagrams"/><p class="title">CREATING DIAGRAMS</p><p>All you need to draw a diagram is a pencil and paper. If you’ve got the time, though, I would recommend using a drawing program. There are drawing tools with templates specifically for programming problems, but any general vector-based drawing program will get you started (the term vector here means the program works with lines and curves and isn’t a paintbox program like Photoshop). I made the original illustrations for this book using a program called Inkscape, which is freely available. Creating the diagrams on your computer allows you to keep them organized in the same place where you store the code that the diagrams illustrate. The diagrams are also likely to be neater and therefore more easily understood if you come back to them after an absence. Finally, it’s easy to copy and modify a computer-created diagram, as I did when I created <a class="xref" href="ch04.html#showing_the_relationship_of_a_local_vari" title="Figure 4-5. Showing the relationship of a local variable, parameters, and allocated memory before and after the append function">Figure 4-5</a> from <a class="xref" href="ch04.html#updated_and_elaborated_memory_states_bef" title="Figure 4-4. Updated and elaborated memory states before (a) and after (b) the append function">Figure 4-4</a>, and if you want to make some quick temporary notations, you can always print out a copy to doodle on.<a id="IDX-CHP-4-0093" class="indexterm"/></p></div><p>Getting back to our <code class="literal">append</code> function, the code looks solid, but remember that we based this code on a particular sample case. Thus, we shouldn’t get cocky and assume that the code will work for all valid cases. In particular, we need to check for special cases. In programming, a <span class="emphasis"><em>special case</em></span> is a situation in which valid data will cause the normal flow of code to produce erroneous results.<a id="IDX-CHP-4-0094" class="indexterm"/><a id="IDX-CHP-4-0095" class="indexterm"/></p><p>Note that this problem is distinct from that of bad data, such as out-of-range data. In the code for this book, we’ve made the assumption of good input data for programs and individual functions. For example, if the program is expecting a series of integers separated by commas, we’ve assumed that’s what the program is getting, not extraneous characters, nonnumbers, and so on. Such an assumption is necessary to keep code length reasonable and to avoid repeating the same data-checking code over and over. In the real world, however, we should take reasonable precautions against bad input. This is known as robustness. A <span class="emphasis"><em>robust</em></span> program performs well even with bad input. For example, such a program could display an error message to the user instead of crashing.</p><div class="sect3" title="Checking for Special Cases"><div class="titlepage"><div><div><h3 class="title"><a id="checking_for_special_cases"/>Checking for Special Cases</h3></div></div></div><p>Let’s look at <code class="literal">append</code> again, checking for special cases—in other words, making sure we don’t have any oddball situations among the possible good input values. The most common culprits for special cases are at the extremes, such as the smallest or largest possible input. With <code class="literal">append</code>, there’s no maximum size for our string array, but there is a minimum size. If the string has no legitimate characters, it would actually correspond to an array of one character (the one character being the null terminating character). As before, let’s make a diagram to keep things straight. Suppose we appended the exclamation point to a null string, as shown in <a class="xref" href="ch04.html#testing_the_smallest_case_for_the_append" title="Figure 4-6. Testing the smallest case for the append function">Figure 4-6</a>.<a id="IDX-CHP-4-0096" class="indexterm"/></p><div class="figure"><a id="testing_the_smallest_case_for_the_append"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e6627"/><img src="httpatomoreillycomsourcenostarchimages1273217.png.jpg" alt="Testing the smallest case for the append function"/></div></div><p class="title">Figure 4-6. Testing the smallest case for the <code class="literal">append</code> function</p></div><p>When we look at the diagram, this doesn’t appear to be a special case, but we should run the case through our function to check. Let’s add the -following to our <code class="literal">appendTester</code> code:<a id="IDX-CHP-4-0097" class="indexterm"/><a id="IDX-CHP-4-0098" class="indexterm"/><a id="IDX-CHP-4-0099" class="indexterm"/><a id="IDX-CHP-4-0100" class="indexterm"/><a id="IDX-CHP-4-0101" class="indexterm"/></p><a id="I_programlisting4_d1e6660"/><pre class="programlisting">arrayString b = new char[1];
b[0] = 0;
append(b, '!');
cout &lt;&lt; b &lt;&lt; "\n";</pre><p>That works, too. Now that we’re reasonably sure that the <code class="literal">append</code> function is correct, do we like it? The code seemed straightforward, and I’m not getting any “bad smells,” but it does seem a little long for a simple operation. As I think ahead to the <code class="literal">concatenate</code> function, it occurs to me that, like <code class="literal">append</code>, the <code class="literal">concatenate</code> function will need to determine the length of a string array—or maybe the lengths of two string arrays. Because both operations will need a loop that finds the null character that terminates the string, we could put that code in its own function, which is then called from <code class="literal">append</code> and <code class="literal">concatenate</code> as needed. Let’s go ahead and do that and modify <code class="literal">append</code> accordingly.<a id="IDX-CHP-4-0102" class="indexterm"/></p><a id="I_programlisting4_d1e6689"/><pre class="programlisting">int length(arrayString s) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>int count = 0;
    while (s[count] != 0) {
        count++;
    }
    return count;
}
void append(arrayString&amp; s, char c) {
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>int oldLength = length(s);
    arrayString newS = new char[oldLength + 2];
    for (int i = 0; i &lt; oldLength; i++) {
        newS[i] = s[i];
    }
    newS[oldLength] = c;
    newS[oldLength + 1] = 0;
    delete[] s;
    s = newS;
}</pre><p>The code in the <code class="literal">length</code> function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6708"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> is essentially the same code that previously began the <code class="literal">append</code> function. In the <code class="literal">append</code> function itself, we’ve replaced that code with a call to <code class="literal">length</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6724"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. The <code class="literal">length</code> function is what’s known as a <span class="emphasis"><em>helper function</em></span>, a function that encapsulates an operation common to several other functions. Besides reducing the length of our code, the elimination of redundant code means our code is more reliable and easier to modify. It also helps our problem solving because helper functions divide our code into smaller chunks, making it easier for us to recognize opportunities for code reuse.<a id="IDX-CHP-4-0103" class="indexterm"/><a id="IDX-CHP-4-0104" class="indexterm"/><a id="IDX-CHP-4-0105" class="indexterm"/><a id="IDX-CHP-4-0106" class="indexterm"/><a id="IDX-CHP-4-0107" class="indexterm"/><a id="IDX-CHP-4-0108" class="indexterm"/><a id="IDX-CHP-4-0109" class="indexterm"/></p></div><div class="sect3" title="Copying Dynamically Allocated Strings"><div class="titlepage"><div><div><h3 class="title"><a id="copying_dynamically_allocated_strings"/>Copying Dynamically Allocated Strings</h3></div></div></div><p>Now it’s time to tackle that <code class="literal">concatenate</code> function. We’ll take the same approach we did with <code class="literal">append</code>. First, we’ll write an empty shell version of the function to get the parameters and their types straight in our heads. Then, we’ll make a diagram of a test case, and finally, we’ll write code to match our diagram. Here is the shell of the function, along with additional testing code:</p><a id="I_programlisting4_d1e6779"/><pre class="programlisting">void concatenate(<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>arrayString&amp; s1, <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>arrayString s2) {
}
void concatenateTester() {
    arrayString a = new char[5];
    a[0] = 't'; a[1] = 'e'; a[2] = 's'; a[3] = 't'; a[4] =  0;
    arrayString b = new char[4];
    b[0] = 'b'; b[1] = 'e'; b[2] = 'd'; b[3] = 0;
    concatenate(a, b);
}</pre><p>Remember that the description of this function says that the characters in the second string (the second parameter) are appended to the end of the first string. Therefore, the first parameter to <code class="literal">concatenate</code> will be a reference parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6798"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, for the same reason as the first parameter of <code class="literal">append</code>. The second parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6807"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, though, should not be changed by the function, so it will be a value parameter. Now for our sample case: We’re concatenating the strings <code class="literal">test</code> and <code class="literal">bed</code>. The before-and-after diagram is shown in <a class="xref" href="ch04.html#showing_the_lbeforer_open_parenthesis_a" title="Figure 4-7. Showing the “before” (a) and “after” (b) states for the concatenate method">Figure 4-7</a>.</p><p>The details of the diagram should be familiar from the <code class="literal">append</code> function. Here, for <code class="literal">concatenate</code>, we start with two dynamically allocated arrays in the heap, pointed to by our two parameters, <code class="literal">s1</code> and <code class="literal">s2</code>. When the function is complete, <code class="literal">s1</code> will point to a new array in the heap that’s nine characters long. The array that <code class="literal">s1</code> previously pointed to has been deallocated; <code class="literal">s2</code> and its array are unchanged. While it might seem pointless to include <code class="literal">s2</code> and the <code class="literal">bed</code> array on our diagram, when trying to avoid coding errors, keeping track of what doesn’t change is as important as keeping track of what does. I’ve also numbered the elements of the old and new arrays, as that came in handy with the <code class="literal">append</code> function. Everything is in place now, so let’s write this function.</p><div class="figure"><a id="showing_the_lbeforer_open_parenthesis_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e6861"/><img src="httpatomoreillycomsourcenostarchimages1273219.png.jpg" alt="Showing the “before” (a) and “after” (b) states for the concatenate method"/></div></div><p class="title">Figure 4-7. Showing the “before” (a) and “after” (b) states for the <code class="literal">concatenate</code> method</p></div><a id="I_programlisting4_d1e6866"/><pre class="programlisting">void concatenate(arrayString&amp; s1, arrayString s2) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>int s1_OldLength = length(s1);
    int s2_Length = length(s2);
    int s1_NewLength = s1_OldLength + s2_Length;
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>arrayString newS = new char[s1_NewLength + 1];
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>for(int i = 0; i &lt; s1_OldLength; i++) {
        newS[i] = s1[i];
    }
    for(int i = 0; i &lt; s2_Length; i++) {
        newS[<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>s1_OldLength + i] = s2[i];
    }
  <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>newS[s1_NewLength] = 0;
  <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>delete[] s1;
  <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>s1 = newS;
}</pre><p>First, we determine the lengths of both of the strings we’re concatenating <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6913"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, and then we sum those values to get the length the concatenated string will have when we are done. Remember that all of these lengths are for the number of legitimate characters, not including the null terminator. Thus, when we create the array in the heap to store the new string <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6919"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, we allocate one more than the combined length to have a space for the terminator. Then we copy the characters from the two original strings to the new string <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6925"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. The first loop is straightforward, but notice the computation of the subscript in the second loop <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6931"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. We’re copying from the beginning of <code class="literal">s2</code> into the middle of <code class="literal">newS</code>; this is yet another example of translating from one range of values to another range of values, which we’ve been doing in this text since <a class="xref" href="ch02.html" title="Chapter 2. Pure Puzzles">Chapter 2</a>. By looking at the element numbers on my diagram, I’m able to see what variables I need to put together to compute the right destination subscript. The remainder of the function puts the null terminator in place at the end of the new string <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6946"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. As with <code class="literal">append</code>, we deallocate the original heap memory pointed to by our first parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6955"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span> and repoint the first parameter at the newly allocated string <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6961"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>.<a id="IDX-CHP-4-0110" class="indexterm"/><a id="IDX-CHP-4-0111" class="indexterm"/></p><p>This code appears to work, but as before, we want to make sure that we haven’t inadvertently made a function that succeeds for our test case but not all cases. The most likely trouble cases would be when either or both of the parameters are zero-length strings (just the null terminator). We should check these cases explicitly before moving on. Note that when you are checking for correctness in code that uses pointers, you should take care to look at the pointers themselves and not just the values in the heap that they reference. Here is one test case:<a id="IDX-CHP-4-0112" class="indexterm"/></p><a id="I_programlisting4_d1e6983"/><pre class="programlisting">arrayString a = new char[5];
  a[0] = 't'; a[1] = 'e'; a[2] = 's'; a[3] = 't'; a[4] =  0;
  arrayString c = new char[1];
  c[0] = 0;
  concatenate(c, a);
  cout &lt;&lt; a &lt;&lt; "\n" &lt;&lt; c &lt;&lt; "\n";
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> cout &lt;&lt; (void *) a &lt;&lt; "\n" &lt;&lt; (void *) c &lt;&lt; "\n";</pre><p>I wanted to be sure that the call to <code class="literal">concatenate</code> results in <code class="literal">a</code> and <code class="literal">c</code> both pointing to the string <code class="literal">test</code>—that is, that they point to arrays with identical values. Equally important, though, is that they point to <span class="emphasis"><em>different</em></span> strings, as shown in <a class="xref" href="ch04.html#concatenate_should_result_in_two_distinc" title="Figure 4-8. concatenate should result in two distinct strings (a), not two cross-linked pointers (b).">Figure 4-8</a> (a). I check this in the second output statement by changing the types of the variables to <code class="literal">void *</code>, which forces the output stream to display the raw value of the pointers <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7014"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. If the pointers themselves had the same value, then we would say that the pointers had become <span class="emphasis"><em>cross-linked</em></span>, as shown in <a class="xref" href="ch04.html#concatenate_should_result_in_two_distinc" title="Figure 4-8. concatenate should result in two distinct strings (a), not two cross-linked pointers (b).">Figure 4-8</a> (b). When pointers have unknowingly become cross-linked, subtle problems occur because changing the contents of one variable in the heap mysteriously changes another variable—really the same variable, but in a large program, that can be hard to see. Also, remember that if two pointers are cross-linked, when one of them is deallocated via <code class="literal">delete</code>, the remaining pointer becomes a dangling reference. Therefore, we have to be diligent when we review our code and always check potential cross-linking.<a id="IDX-CHP-4-0113" class="indexterm"/><a id="IDX-CHP-4-0114" class="indexterm"/><a id="IDX-CHP-4-0115" class="indexterm"/><a id="IDX-CHP-4-0116" class="indexterm"/></p><div class="figure"><a id="concatenate_should_result_in_two_distinc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7051"/><img src="httpatomoreillycomsourcenostarchimages1273221.png.jpg" alt="concatenate should result in two distinct strings (a), not two cross-linked pointers (b)."/></div></div><p class="title">Figure 4-8. <code class="literal">concatenate</code> should result in two distinct strings (a), not two cross-linked pointers (b).</p></div><p>With all three functions implemented—<code class="literal">characterAt</code>, <code class="literal">append</code>, and -<code class="literal">concatenate</code>—we’ve completed the problem.</p></div></div><div class="sect2" title="Linked Lists"><div class="titlepage"><div><div><h2 class="title"><a id="linked_lists"/>Linked Lists</h2></div></div></div><p>Now we’re going to try something trickier. The pointer manipulations will be more complicated, but we’ll keep everything straight now that we know how to crank out the diagrams.<a id="IDX-CHP-4-0117" class="indexterm"/><a id="IDX-CHP-4-0118" class="indexterm"/><a id="IDX-CHP-4-0119" class="indexterm"/><a id="IDX-CHP-4-0120" class="indexterm"/><a id="IDX-CHP-4-0121" class="indexterm"/><a id="IDX-CHP-4-0122" class="indexterm"/></p><div class="sidebar"><a id="problem_colon_tracking_an_unknown_quanti"/><p class="title">Problem: Tracking an unknown quantity of student records</p><p>In this problem, you will write functions to store and manipulate a collection of student records. A student record contains a student number and a grade, both integers. The following functions are to be implemented:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>addRecord</code></strong></span></dt><dd><p>This function takes a pointer to a collection of student records (a student number and a grade), and it adds a new record with this data to the collection.</p></dd><dt><span class="term"><strong class="userinput"><code>averageRecord</code></strong></span></dt><dd><p>This function takes a pointer to a collection of student records and returns the simple average of student grades in the collection as a <code class="literal">double</code>.</p></dd></dl></div><p>The collection can be of any size. The <code class="literal">addRecord</code> operation is expected to be called frequently, so it must be implemented efficiently.</p></div><p>A number of approaches would meet the specifications, but we’re going to choose a method that helps us practice our pointer-based problem-solving techniques: linked lists. You may have already seen a linked list before, but if not, know that the introduction of linked lists represents a kind of sea change from what we have discussed so far in this text. A good problem-solver could have developed any of the previous solutions given enough time and careful thought. Most programmers, however, wouldn’t come up with the linked list concept without help. Once you see it and master the basics, though, other linked structures will come to mind, and then you are off and running. A linked list is truly a dynamic structure. Our string arrays were stored in dynamically allocated memory, but once created, they were static structures, never getting any larger or smaller, just being replaced. A linked list, in contrast, grows piece by piece over time like a daisy chain.<a id="IDX-CHP-4-0123" class="indexterm"/></p><div class="sect3" title="Building a List of Nodes"><div class="titlepage"><div><div><h3 class="title"><a id="building_a_list_of_nodes"/>Building a List of Nodes</h3></div></div></div><p>Let’s construct a sample linked list of student records. To make a linked list, you need a <code class="literal">struct</code> that contains a pointer to the same <code class="literal">struct</code>, in addition to whatever data you want to store in the collection represented by the linked list. For our problem, the <code class="literal">struct</code> will contain a student number and grade.</p><a id="I_programlisting4_d1e7147"/><pre class="programlisting">struct <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>listNode {
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>int studentNum;
      int grade;
    <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>listNode * next;
  };
<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/> typedef listNode * studentCollection;</pre><p>The name of our <code class="literal">struct</code> is <code class="literal">listNode</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7181"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. A <code class="literal">struct</code> used to create a linked list is always referred to as a <span class="emphasis"><em>node</em></span>. Presumably the name is an analogy to the botanical term, meaning a point on a stem from which a new branch grows. The node contains the student number <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7194"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> and grade that make up the real “payload” of the node. The node also contains a pointer to the very type of <code class="literal">struct</code> we are defining <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7203"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. The first time most programmers see this, it looks confusing and perhaps even a syntactical impossibility: How can we define a structure in terms of itself? But this is legal, and the meaning will become clear shortly. Note that the self-referring pointer in a node is typically given a name like <span class="emphasis"><em>next</em></span>, <span class="emphasis"><em>nextPtr</em></span>, or the like. Lastly, this code declares a <code class="literal">typedef</code> for a pointer to our node type <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7219"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. This will help the readability of our functions. Now let’s build our sample linked list using these types:<a id="IDX-CHP-4-0124" class="indexterm"/><a id="IDX-CHP-4-0125" class="indexterm"/><a id="IDX-CHP-4-0126" class="indexterm"/></p><a id="I_programlisting4_d1e7236"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> studentCollection sc;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> listNode * node1 = new listNode;
<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/> node1-&gt;studentNum = 1001; node1-&gt;grade = 78;
  listNode * node2 = new listNode;
  node2-&gt;studentNum = 1012; node2-&gt;grade = 93;
  listNode * node3 = new listNode;
<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/> node3-&gt;studentNum = 1076; node3-&gt;grade = 85;
<img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/> sc = node1;
<img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/> node1-&gt;next = node2;
<img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/> node2-&gt;next = node3;
<img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/> node3-&gt;next = NULL;
<img src="httpatomoreillycomsourcenostarchimages1273225.png" alt=""/> node1 = node2 = node3 = NULL;</pre><p>We begin by declaring a <code class="literal">studentCollection</code>, <code class="literal">sc</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7300"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which will eventually become the name for our linked list. Then we declare <code class="literal">node1</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7309"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, a pointer to a <code class="literal">listNode</code>. Again, <code class="literal">studentCollection</code> is synonymous with <code class="literal">node *</code>, but for readability I’m using the <code class="literal">studentCollection</code> type only for variables that will refer to the whole list structure. After declaring <code class="literal">node1</code> and pointing it to a newly allocated <code class="literal">listNode</code> in the heap <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7335"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, we assign values to the <code class="literal">studentNum</code> and <code class="literal">grade</code> fields in that node <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7347"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. At this point, the <code class="literal">next</code> field is unassigned. This is not a book on syntax, but if you haven’t seen the <code class="literal">-&gt;</code> notation before, it’s used to indicate the field of a pointed-to <code class="literal">struct</code> (or <code class="literal">class</code>). So <code class="literal">node1-&gt;studentNum</code> means “the <code class="literal">studentNum</code> field in the <code class="literal">struct</code> pointed to by <code class="literal">node1</code>” and is equivalent to <code class="literal">(*node1).studentNum</code>. We then repeat the same process for <code class="literal">node2</code> and <code class="literal">node3</code>. After assigning the field values to the last node, the state of memory is as shown in <a class="xref" href="ch04.html#halfway_through_building_a_sample_linked" title="Figure 4-9. Halfway through building a sample linked list">Figure 4-9</a>. In these diagrams, we’ll use the divided-box notation we previously used for arrays to show the node <code class="literal">struct</code>.</p><div class="figure"><a id="halfway_through_building_a_sample_linked"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7396"/><img src="httpatomoreillycomsourcenostarchimages1273227.png.jpg" alt="Halfway through building a sample linked list"/></div></div><p class="title">Figure 4-9. Halfway through building a sample linked list</p></div><p>Now that we have all of our nodes, we can string them together to form a linked list. That’s what the rest of the previous code listing does. First, we point our <code class="literal">studentCollection</code> variable to the first node <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7406"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>, then we point the next field of the first node to the second node <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7412"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>, and then we point the next field of the second node to the third node <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7418"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. In the next step, we assign <code class="literal">NULL</code> (again, this is just a synonym for zero) to the next field of the third node <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7428"/><img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/></span>. We do this for the same reason we put a null character at the end of our arrays in the previous problem: to terminate the structure. Just as we needed a special character to show us the end of the array, we need a zero in the next field of the last node in our linked list so that we know it <span class="emphasis"><em>is</em></span> the last node. Finally, to clean things up and avoid potential cross-linking problems, we assign <code class="literal">NULL</code> to each of the individual node pointers <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7440"/><img src="httpatomoreillycomsourcenostarchimages1273225.png" alt=""/></span>. The resulting state of memory is shown in <a class="xref" href="ch04.html#the_completed_sample_linked_list" title="Figure 4-10. The completed sample linked list">Figure 4-10</a>.<a id="IDX-CHP-4-0127" class="indexterm"/><a id="IDX-CHP-4-0128" class="indexterm"/><a id="IDX-CHP-4-0129" class="indexterm"/><a id="IDX-CHP-4-0130" class="indexterm"/><a id="IDX-CHP-4-0131" class="indexterm"/></p><div class="figure"><a id="the_completed_sample_linked_list"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7473"/><img src="httpatomoreillycomsourcenostarchimages1273229.png" alt="The completed sample linked list"/></div></div><p class="title">Figure 4-10. The completed sample linked list</p></div><p>With this visual in front of us, it’s clear why the structure is called a linked list: Each node in the list is linked to the next. You’ll often see linked lists drawn linearly, but I actually prefer the scattered-in-memory look of this diagram because it emphasizes that these nodes have no relationship to each other besides the links; each of them could be anywhere inside the heap. Make sure you trace through the code until you are confident you agree with the diagram.</p><p>Notice that, in the concluding state, only one stack-based pointer remains in use, our <code class="literal">studentCollection</code> variable <code class="literal">sc</code>, which points to the first node. A pointer external to the list (that is, not the <code class="literal">next</code> field of a node in the list) that points to the first node in a linked list is known as a <span class="emphasis"><em>head pointer</em></span>. On a symbolic level, this variable represents the list as a whole, but of course it directly references only the first node. To get to the second node, we have to go through the first, and to get to the third node, we have to go through the first two, and so on. This means that linked lists offer only sequential access, as opposed to the random access provided by arrays. Sequential access is the weakness of linked-list structures. The strength of linked-list structures, as previously alluded to, is our ability to grow or shrink the size of the structure by adding or removing nodes, without having to create an entirely new structure and copy the data over, as we’ve done with arrays.<a id="IDX-CHP-4-0132" class="indexterm"/><a id="IDX-CHP-4-0133" class="indexterm"/><a id="IDX-CHP-4-0134" class="indexterm"/><a id="IDX-CHP-4-0135" class="indexterm"/></p></div><div class="sect3" title="Adding Nodes to a List"><div class="titlepage"><div><div><h3 class="title"><a id="adding_nodes_to_a_list"/>Adding Nodes to a List</h3></div></div></div><p>Now let’s implement the <code class="literal">addRecord</code> function. This function is going to create a new node and connect it into an existing linked list. We’ll use the same techniques we used in the previous problem. First up: a function shell and a sample call. For testing, we’ll add code to the previous listing, so <code class="literal">sc</code> already exists as the head pointer to the list of three nodes.<a id="IDX-CHP-4-0136" class="indexterm"/></p><a id="I_programlisting4_d1e7527"/><pre class="programlisting">void addRecord(studentCollection&amp; sc, int stuNum, int gr) {
  }
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> addRecord(sc, 1274, 91);</pre><p>Again, the <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7537"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> call would come at the end of the previous listing. With the function shell outlining the parameters, we can diagram the “before” state of this call, as shown in <a class="xref" href="ch04.html#the_lbeforer_state_for_the_addrecord_fun" title="Figure 4-11. The “before” state for the addRecord function">Figure 4-11</a>.</p><div class="figure"><a id="the_lbeforer_state_for_the_addrecord_fun"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7551"/><img src="httpatomoreillycomsourcenostarchimages1273231.png.jpg" alt="The “before” state for the addRecord function"/></div></div><p class="title">Figure 4-11. The “before” state for the <code class="literal">addRecord</code> function</p></div><p>Regarding the “after” state, though, we have a choice. We can guess that we’re going to create a new node in the heap and copy the values from the parameters <code class="literal">stuNum</code> and <code class="literal">gr</code> into the <code class="literal">studentNum</code> and <code class="literal">grade</code> fields of the new node. The question is where this node is going to go, logically, in our linked list. The most obvious choice would be at the end; there’s a <code class="literal">NULL</code> value in a <code class="literal">next</code> field just asking to be pointed to a new node. That would correspond to <a class="xref" href="ch04.html#proposed_lafterr_state_for_addrecord_fun" title="Figure 4-12. Proposed “after” state for addRecord function">Figure 4-12</a>.</p><div class="figure"><a id="proposed_lafterr_state_for_addrecord_fun"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7585"/><img src="httpatomoreillycomsourcenostarchimages1273233.png.jpg" alt="Proposed “after” state for addRecord function"/></div></div><p class="title">Figure 4-12. Proposed “after” state for <code class="literal">addRecord</code> function</p></div><p>But if we can assume that the order of the records doesn’t matter (that we don’t need to keep the records in the same order they were added to the collection), then this is the wrong choice. To see why, consider a collection, not of three student records, but of 3,000. To reach the last record in our linked list in order to modify its <code class="literal">next</code> field would require traveling through all 3,000 nodes. That’s unacceptably inefficient because we can get the new node into the list without traveling through <span class="emphasis"><em>any</em></span> of the existing nodes.</p><p><a class="xref" href="ch04.html#acceptable_lafterr_state_for_addrecord_f" title="Figure 4-13. Acceptable “after” state for addRecord function. The dashed arrow indicates the previous value of the pointer stored in sc.">Figure 4-13</a> shows how. After the new node is created, it is linked into the list at the <span class="emphasis"><em>beginning</em></span>, not at the end. In the “after” state, our head pointer <code class="literal">sc</code> points to the new node, while the <code class="literal">next</code> field of the new node points to what was previously the first node in the list, the one with student number 1001. Note that while we assign a value to that <code class="literal">next</code> field of the new node, the only existing pointer that changes is <code class="literal">sc</code>, and none of the values in the existing nodes are altered or even inspected. Working from our diagram, here’s the code:</p><a id="I_programlisting4_d1e7616"/><pre class="programlisting">void addRecord(studentCollection&amp; sc, int stuNum, int gr) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>listNode * newNode = new listNode;
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>newNode-&gt;studentNum = stuNum;
    newNode-&gt;grade = gr;
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>newNode-&gt;next = sc;
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>sc = newNode;
}</pre><div class="figure"><a id="acceptable_lafterr_state_for_addrecord_f"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7651"/><img src="httpatomoreillycomsourcenostarchimages1273235.png.jpg" alt="Acceptable “after” state for addRecord function. The dashed arrow indicates the previous value of the pointer stored in sc."/></div></div><p class="title">Figure 4-13. Acceptable “after” state for <code class="literal">addRecord</code> function. The dashed arrow indicates the previous value of the pointer stored in <code class="literal">sc</code>.</p></div><p>Again, let me emphasize that translating a diagram and that code is a lot easier than trying to keep things straight in your head. The code comes directly from the illustration. We create a new node <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7659"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and assign the student number and grade from the parameters <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7665"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Then we link the new node into the list, first by pointing the <code class="literal">next</code> field of the new node to the former first node (by assigning it the value of <code class="literal">sc</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7677"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> and then by pointing <code class="literal">sc</code> itself at the new node <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7687"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. Note that the last two steps have to happen in that order; we need to use the original value of <code class="literal">sc</code> before we change it. Also note that because we change <code class="literal">sc</code>, it must be a reference parameter.</p><p>As always, when we build code from a sample case, we have to check potential special cases. Here, that means checking to see that the function works with an empty list. With our string arrays, an empty string was still a valid pointer because we still had an array to point to, an array with just the null terminating character. Here, though, the number of nodes is the same as the number of records, and an empty list would be a <code class="literal">NULL</code> head pointer. Will our code still hold up if we try to insert our sample data when the incoming head pointer is <code class="literal">NULL</code>? <a class="xref" href="ch04.html#the_lbeforer_and_lafterr_states_for_the" title="Figure 4-14. The “before” and “after” states for the smallest addRecord case">Figure 4-14</a> shows the “before” state and the desired “after” state.</p><p>Walking this example through our code, we see that it handles this case fine. The new node is created just as before. Because <code class="literal">sc</code> is <code class="literal">NULL</code> in the “before” state, when <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7717"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> this value is copied into the <code class="literal">next</code> field of our new node, that’s exactly what we want, and our one-node list is properly terminated. Note that if we had continued with the other implementation idea—adding the new node at the end of the linked list rather than at the beginning—an initially empty list <span class="emphasis"><em>would</em></span> be a special case because it would then be the only case in which <code class="literal">sc</code> is modified.<a id="IDX-CHP-4-0137" class="indexterm"/><a id="IDX-CHP-4-0138" class="indexterm"/></p><div class="figure"><a id="the_lbeforer_and_lafterr_states_for_the"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e7747"/><img src="httpatomoreillycomsourcenostarchimages1273237.png.jpg" alt="The “before” and “after” states for the smallest addRecord case"/></div></div><p class="title">Figure 4-14. The “before” and “after” states for the smallest <code class="literal">addRecord</code> case</p></div></div><div class="sect3" title="List Traversal"><div class="titlepage"><div><div><h3 class="title"><a id="list_traversal"/>List Traversal</h3></div></div></div><p>Now it’s time to figure out the <code class="literal">averageRecord</code> function. As before, we’ll start with a shell and a diagram. Here’s the function shell and sample call. Assume the sample call <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7760"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> occurs after the creation of our original sample list, as shown in <a class="xref" href="ch04.html#the_completed_sample_linked_list" title="Figure 4-10. The completed sample linked list">Figure 4-10</a>.</p><a id="I_programlisting4_d1e7768"/><pre class="programlisting">double averageRecord(studentCollection sc) {
  }
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int avg = averageRecord(sc);</pre><p>As you can see, I’ve chosen to compute the average as an <code class="literal">int</code>, as we did with arrays in the previous chapter. Depending on the problem, however, it might be better to compute it as a floating point value. Now we need a diagram, but we pretty much already have a “before” state with <a class="xref" href="ch04.html#halfway_through_building_a_sample_linked" title="Figure 4-9. Halfway through building a sample linked list">Figure 4-9</a>. We don’t need a diagram for the “after” state because this function isn’t going to change our dynamic structure, just report on it. We just need to know the expected result, which in this case is about 85.3333.</p><p>So how do we actually compute the average? From our experience computing the average of all values in an array, we know the general concept. We need to add up every value in the collection and then divide that sum by the number of values. With our array averaging code, we inspected every value using a <code class="literal">for</code> loop from 0 to one less than the size of the array, using the loop counter as the array subscript. We can’t use a <code class="literal">for</code> loop here because we don’t know ahead of time how many numbers are in the linked list; we have to keep going until we reach the <code class="literal">NULL</code> value in a node’s <code class="literal">next</code> field indicating list termination. This suggests a <code class="literal">while</code> loop, something like what we used earlier in this chapter to process our arrays of unknown length. Running through a linked list like this, from beginning to terminus, is known as a <span class="emphasis"><em>list traversal</em></span>. This is one of the basic operations on a linked list. Let’s put the traversal idea to work to solve this problem:</p><a id="I_programlisting4_d1e7804"/><pre class="programlisting">double averageRecord(studentCollection sc) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>int count = 0;
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>double sum = 0;
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>listNode * loopPtr = sc;
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>while (loopPtr != NULL) {
        <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>sum += loopPtr-&gt;grade;
        <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>count++;
        <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>loopPtr = loopPtr-&gt;next;
    }
  <img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/>double average = sum / count;
    return average;
}</pre><p>We start by declaring a variable <code class="literal">count</code> to store the number of nodes we encounter in the list <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7860"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>; this will also be the number of values in the collection, which we’ll use to compute the average. Next we declare a variable <code class="literal">sum</code> to store the running total of grade values in the list <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7869"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Then we declare a <code class="literal">listNode *</code> called <code class="literal">loopPtr</code>, which we’ll use to traverse the list <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7882"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. This is the equivalent of our integer loop variable in an array-processing <code class="literal">for</code> loop; it keeps track of where we are in the linked list, not with the position number but by storing a pointer to the node we are processing currently.</p><p>At this point, the traversal itself begins. The traversal loop continues until our loop-tracking pointer reaches our terminating <code class="literal">NULL</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7896"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. Inside the loop, we add the value of the <code class="literal">grade</code> field in the currently referenced node to <code class="literal">sum</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7908"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. We increment the <code class="literal">count</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7918"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>, and then we assign the <code class="literal">next</code> field of the current node to our loop-tracking pointer <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7927"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. This has the effect of moving our traversal one node ahead. This is the tricky part of the code, so let’s make sure we have this straight. In <a class="xref" href="ch04.html#how_the_local_variable_loopptr_changes_d" title="Figure 4-15. How the local variable loopPtr changes during loop iterations in the averageRecord function">Figure 4-15</a>, I’m showing how the node variable changes over time. The letters (a) through (d) mark different points during the execution of the code on our sample data, showing different points during the lifetime of <code class="literal">loopPtr</code> and the locations from which <code class="literal">loopPtr</code>’s value has been obtained. Point (a) is just as the loop begins; <code class="literal">loopPtr</code> has just been initialized with the value of <code class="literal">sc</code>. Therefore, <code class="literal">loopPtr</code> points to the first node in the list, just as <code class="literal">sc</code> does. During the first iteration of the loop, then, the first node’s grade value of <code class="literal">78</code> is added to <code class="literal">sum</code>. The first node’s next value is copied to <code class="literal">loopPtr</code> so that now <code class="literal">loopPtr</code> points to the second node of the list; this is point (b). During the second iteration, we add <code class="literal">93</code> to <code class="literal">sum</code> and copy the <code class="literal">next</code> field of the second node to <code class="literal">loopPtr</code>; this is point (c). Finally, during the third and last iteration of the loop, we add <code class="literal">85</code> to <code class="literal">sum</code> and assign the <code class="literal">NULL</code> of the <code class="literal">next</code> field in the third node to <code class="literal">loopPtr</code>; this is point (d). When we reach the top of the <code class="literal">while</code> loop again, the loop ends because <code class="literal">loopPtr</code> is <code class="literal">NULL</code>. Because we incremented <code class="literal">count</code> each time we iterated, <code class="literal">count</code> is three.</p><div class="figure"><a id="how_the_local_variable_loopptr_changes_d"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e8020"/><img src="httpatomoreillycomsourcenostarchimages1273239.png.jpg" alt="How the local variable loopPtr changes during loop iterations in the averageRecord function"/></div></div><p class="title">Figure 4-15. How the local variable <code class="literal">loopPtr</code> changes during loop iterations in the <code class="literal">averageRecord</code> function</p></div><p>Once the loop is all done, we just divide the sum by the count and return the result <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8027"/><img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/></span>.<a id="IDX-CHP-4-0139" class="indexterm"/><a id="IDX-CHP-4-0140" class="indexterm"/></p><p>The code works on our sample case, but as always, we need to check for potential special cases. Again, with lists, the most obvious special case is an empty list. What happens with our code if <code class="literal">sc</code> is <code class="literal">NULL</code> when the function begins?</p><p>Guess what? The code blows up. (I had to make one of these special cases turn out badly; otherwise, you wouldn’t take me seriously.) There’s nothing wrong with the loop for the processing of the linked list itself. If <code class="literal">sc</code> is <code class="literal">NULL</code>, then <code class="literal">loopPtr</code> is initialized to <code class="literal">NULL</code>, the loop ends as soon as it begins, and <code class="literal">sum</code> is left at zero, which seems reasonable enough. The problem is when we perform the division to compute the average <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8068"/><img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/></span>, <code class="literal">count</code> is also zero, which means we are dividing by zero and which will result in either a program crash or a garbage result. To handle this special case, we could check <code class="literal">count</code> against zero at the end of the function, but why not handle the situation up front and check <code class="literal">sc</code>? Let’s add the following as the new first line in our <code class="literal">averageRecord</code> function:</p><a id="I_programlisting4_d1e8086"/><pre class="programlisting">if (sc == NULL) return 0;</pre><p>As this example shows, handling special cases is usually pretty simple. We just have to make sure we take the time to identify them.</p></div></div></div><div class="sect1" title="Conclusion and Next Steps"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion_and_next_steps"/>Conclusion and Next Steps</h1></div></div></div><p>This chapter has just scratched the surface of problem solving using pointers and dynamic memory. You’ll see pointers and heap allocations throughout the rest of this text. For example, object-oriented programming techniques, which we’ll discuss in <a class="xref" href="ch05.html" title="Chapter 5. Solving Problems with Classes">Chapter 5</a>, are especially helpful when dealing with pointers. They allow us to encapsulate pointers in such a way that we don’t have to worry about memory leaks, dangling pointers, or any of the other common pointer pitfalls.</p><p>Even though there is much more to learn about problem solving in this area, you’ll be able to develop your skills with pointer-based structures of increasing complexity if you follow the basic ideas in this chapter: First, apply the general rules of problem solving. Then, apply specific rules for pointers, and use a diagram or similar tool to visualize each solution before you start coding.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id4"/>Exercises</h1></div></div></div><p>I’m not kidding about doing the exercises. You’re not just reading the chapters and moving on, are you?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Design your own: Take a problem that you already know how to solve using an array but that is limited by the size of the array. Rewrite the code to remove that limitation using a dynamically allocated array.</p></li><li class="listitem"><p>For our dynamically allocated strings, create a function <code class="literal">substring</code> that takes three parameters: an <code class="literal">arrayString</code>, a starting position integer, and an integer length of characters. The function returns a pointer to a new dynamically allocated string array. This string array contains the characters in the original string, starting at the specified position for the specified length. The original string is unaffected by the operation. So if the original string was <code class="literal">abcdefg</code>, the position was 3, and the length was 4, then the new string would contain <code class="literal">cdef</code>.</p></li><li class="listitem"><p>For our dynamically allocated strings, create a function <code class="literal">replaceString</code> that takes three parameters, each of type <code class="literal">arrayString</code>: <code class="literal">source</code>, <code class="literal">target</code>, and <code class="literal">replaceText</code>. The function replaces every occurrence of <code class="literal">target</code> in <code class="literal">source</code> with <code class="literal">replaceText</code>. For example, if <code class="literal">source</code> points to an array containing <code class="literal">abcdabee</code>, <code class="literal">target</code> points to <code class="literal">ab</code>, and <code class="literal">replaceText</code> points to <code class="literal">xyz</code>, then when the function ends, <code class="literal">source</code> should point to an array containing <code class="literal">xyzcdxyzee</code>.</p></li><li class="listitem"><p>Change the implementation of our strings such that <code class="literal">location[0]</code> in the array stores the size of the array (and therefore <code class="literal">location[1]</code> stores the first actual character in the string), rather than using a null-character terminator. Implement each of the three functions, <code class="literal">append</code>, <code class="literal">concatenate</code>, and <code class="literal">charactertAt</code>, taking advantage of the stored size information whenever possible. Because we’ll no longer be using the null-termination convention expected by the standard output stream, you’ll need to write your own <code class="literal">output</code> function that loops through its string parameter, displaying the characters.</p></li><li class="listitem"><p>Write a function <code class="literal">removeRecord</code> that takes a pointer to a <code class="literal">studentCollection</code> and a student number and that removes the record with that student number from the collection.</p></li><li class="listitem"><p>Let’s create an implementation for strings that uses a linked list of characters instead of dynamically allocated arrays. So we’ll have a linked list where the data payload is a single char; this will allow strings to grow without having to re-create the entire string. We’ll start by implementing the <code class="literal">append</code> and <code class="literal">characterAt</code> functions.</p></li><li class="listitem"><p>Following up on the previous exercise, implement the <code class="literal">concatenate</code> function. Note that if we make a call <code class="literal">concatenate(s1, s2)</code>, where both parameters are pointers to the first nodes of their respective linked lists, the function should create a copy of each of the nodes in <code class="literal">s2</code> and append them to the end of <code class="literal">s1</code>. That is, the function should not simply point the <code class="literal">next</code> field of the last node in <code class="literal">s1</code>’s list to the first node of <code class="literal">s2</code>’s list.</p></li><li class="listitem"><p>Add a function to the linked-list string implementation called <code class="literal">removeChars</code> to remove a section of characters from a string based on the position and length. For example, <code class="literal">removeChars(s1, 5, 3)</code> would remove the three characters starting at the fifth character in the string. Make sure the removed nodes are properly deallocated.</p></li><li class="listitem"><p>Imagine a linked list where instead of the node storing a character, the node stores a digit: an <code class="literal">int</code> in the range 0–9. We could represent positive numbers of any size using such a linked list; the number 149, for example, would be a linked list in which the first node stores a 1, the second a 4, and the third and last a 9. Write a function <code class="literal">intToList</code> that takes an integer value and produces a linked list of this sort. Hint: You may find it easier to build the linked list backward, so if the value were 149, you would create the 9 node first.</p></li><li class="listitem"><p>For the digit list of the previous exercise, write a function that takes two such lists and produces a new list representing their sum.</p></li></ol></div></div></div></body></html>