["```\n  #!/usr/bin/env ruby\n  # dos2unix.rb\n  # converts line feeds from DOS (or old-style Mac) to Unix format\n❶ ARGV.each do |filename|\n    contents_file = File.open(filename, 'r')\n❷   contents = contents_file.read()\n    contents_file.close()\n❸   contents.gsub!(/\\r\\n?/, \"\\n\")    *Regular Expressions*\n    replace_file = File.new(filename, 'w+')\n❹   replace_file.puts(contents)\n    replace_file.close()\n  end\n```", "```\ncontents.gsub!(/\\r\\n?/, \"\\n\")\n```", "```\nirb(main):001:0> letters = 'abcde'\n=> \"abcde\"\nirb(main):002:0> letters =~ /a/\n=> 0\nirb(main):003:0> letters =~ /b/\n=> 1\nirb(main):004:0> letters =~ /e/\n=> 4\nirb(main):005:0> letters =~ /x/\n=> nil\n```", "```\nirb(main):006:0> letters =~ /aa?/\n=> 0\nirb(main):007:0> letters =~ /ax?/\n=> 0\n```", "```\nirb(main):008:0> letters =~ /ab?/\n=> 0\nirb(main):009:0> letters =~ /bc?/\n=> 1\nirb(main):010:0> letters =~ /b?/\n=> 0\n```", "```\nirb(main):011:0> letters =~ //\n=> 0\n```", "```\nirb(main):012:0> letters.gsub(/a/, 'x')    *The **`gsub`**  Method*\n=> \"xbcde\"\nirb(main):013:0> letters.gsub(/ab?/, 'x')\n=> \"xcde\"\nirb(main):014:0> letters.gsub(/ac?/, 'x')\n=> \"xbcde\"\n```", "```\nirb(main):015:0> letters\n=> \"abcde\"\nirb(main):016:0> letters.gsub!(/ac?/, 'x')\n=> \"xbcde\"\nirb(main):017:0> letters\n=> \"xbcde\"\n```", "```\n irb(main):001:0> foo = 'abcd'\n=> \"abcd\"\nirb(main):002:0> foo.gsub(/a/, 'b')\n=> \"bbcd\"\nirb(main):003:0> foo.gsub!(/a/, 'b')\n=> \"bbcd\"\nirb(main):004:0> foo.gsub(/a/, 'b')\n=> \"bbcd\"\nirb(main):005:0> foo.gsub!(/a/, 'b')\n=> nil\n```", "```\nI am a DOS file.^MI am a DOS file.\n```", "```\nI am a DOS file.\nI am a DOS file.\n```", "```\ncontents.gsub!(/(\\r|\\n)/, \"\\r\\n\")\n```", "```\ncontents.gsub!(/\\r?\\n/, \"\\r\")\n```", "```\nruby -pi -e 'gsub(/\\r\\n?/, \"\\n\")' some_file\n```", "```\n  #!/usr/bin/env ruby\n  # line_num.rb\n\n❶ def get_lines(filename)\n    return File.open(filename, 'r').readlines\n  end\n\n❷ def get_format(lines)\n    return \"%0#{lines.size.to_s.size}d\"    ***`sprintf`** Formats*\n  end\n\n❸ def get_output(lines)\n    format = get_format(lines)\n❹   output = ''    *The **`each_with_index`** and **`sprintf`** Methods*\n❺   lines.each_with_index do |line,i|\n❻     output += \"#{sprintf(format, i+1)}: #{line}\"\n    end\n    return output\n  end\n\n  print get_output(get_lines(ARGV[0]))\n```", "```\nirb(main):001:0> def get_format(lines)\nirb(main):002:1> return \"%0#{lines.size.to_s.size}d\"\nirb(main):003:1> end\n=> nil\nirb(main):004:0> has10items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):005:0> get_format(has10items)\n=> \"%02d\"\nirb(main):006:0> has100items = has10items * 10     *Multiplying Arrays*\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4,\n5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,\n1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6,\n7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):007:0> get_format(has100items)\n=> \"%03d\"\n```", "```\nirb(main):008:0> has10items * 1\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):009:0> (has10items * 1) == has10items\n=> true\n```", "```\n$ ruby -w line_num.rb line_num.rb\n01: #!/usr/bin/env ruby\n02: # line_num.rb\n03:\n04: def get_lines(filename)\n05:   return File.open(filename, 'r').readlines\n06: end\n07:\n08: def get_format(lines)\n09:   return \"%0#{lines.size.to_s.size}d\"\n10: end\n11:\n12: def get_output(lines)\n13:   format = get_format(lines)\n14:   output = ''\n15:   lines.each_with_index do |line,i|\n16:     output += \"#{sprintf(format, i+1)}: #{line}\"\n17:   end\n18:   return output\n19: end\n20:\n21: print get_output(get_lines(ARGV[0]))\n```", "```\n  #!/usr/bin/env ruby\n  # softwrap.rb\n\n  =begin rdoc\n  \"Softwrap\" a filename argument, preserving \"\\n\\n\"\n  between paragraphs but compressing \"\\n\" and other\n  whitespace within each paragraph into a single space.\n  =end\n❶ def softwrap(filename)\n❷   File.open(filename, 'r').readlines.inject('') do |output,line|    *The **`inject`** Method*\n❸     output += softwrap_line(line)\n❽   end.gsub(/\\t+/, ' ').gsub(/ +/, ' ')\n  end # softwrap\n\n  =begin rdoc\n  Return \"\\n\\n\" if the <b>String</b> argument has no length after being\n  chomped (signifying that it was a blank line separating paragraphs),\n  otherwise return the chomped line with a trailing space for padding.\n  =end\n❹ def softwrap_line(line)\n❺   return \"\\n\\n\" if line == \"\\n\"\n❻   return line.chomp + ' '\n  end # softwrap_line\n\n❼ puts softwrap(ARGV[0])\n```", "```\nirb(main):001:0> nums = [1, 2, 3, 4]\n=> [1, 2, 3, 4]\nirb(main):002:0> nums.inject(0) { |sum,number| sum += number }\n=> 10\nirb(main):003:0> nums.inject(0) { |product,number| product *= number }\n=> 0\nirb(main):004:0> nums.inject(1) { |product,number| product *= number }\n=> 24\n```", "```\nirb(main):001:0> s = 'abcde'    *The **`+`** sign in Regular Expressions*\n=> \"abcde\"\nirb(main):002:0> s.gsub(/ab+/, 'ba')\n=> \"bacde\"\nirb(main):003:0> s.gsub(/abb+/, 'ba')\n=> \"abcde\"\nirb(main):004:0> s.gsub(/abb?/, 'ba')\n=> \"bacde\"\n```", "```\n$ ruby -w softwrap.rb softwrap.rb\n#!/usr/bin/env ruby # softwrap.rb\n\n=begin rdoc \"Softwrap\" a filename argument, preserving \"\\n\\n\" between\nparagraphs but compressing \"\\n\" and other whitespace within each paragraph\ninto a single space. =end def softwrap(filename) File.open(filename,\n'r').readlines.inject('') do |output,line| output += softwrap_line(line)\nend.gsub(/\\t+/, ' ').gsub(/ +/, ' ') end # softwrap\n\n=begin rdoc Return \"\\n\\n\" if the <b>String</b> argument has no length after\nbeing chomped (signifying that it was a blank line separating paragraphs),\notherwise return the chomped line with a trailing space for padding. =end def\nsoftwrap_line(line) return \"\\n\\n\" if line == \"\\n\" return line.chomp + ' ' end\n# softwrap_line\n\nputs softwrap(ARGV[0])\n```", "```\n  #!/usr/bin/env ruby\n  # word_count.rb\n\n  class String\n\n❶   def num_matches(thing_to_match)\n      return self.split(thing_to_match).size - 1\n    end # num_matches\n\n  end # String\n\n❷ BAR_LENGTH   = 20\n\n  # to match these calculations with the output of some word processors\n❸ FUDGE_FACTOR = 0.82\n\n❹ def word_count(files)\n    output = ''\n    total_word_count = 0\n❺   files.each do |filename|\n      file_word_count = word_count_for_file(filename)\n      output += \"#{filename} has #{file_word_count} words.\\n\"\n      total_word_count += file_word_count\n    end # each file\n❻   return output +\n      '-' * BAR_LENGTH + \"\\n\" +    *Multiplying Strings*\n      \"Total word count = #{total_word_count}\" +\n      \" (#{(total_word_count * FUDGE_FACTOR)})\"\n  end # word_count\n\n❼ def word_count_for_file(filename)\n    f = File.new(filename, 'r')\n    contents = f.read()\n    f.close()\n    spaces = contents.num_matches(' ')\n    breaks = contents.num_matches(\"\\n\")\n    false_doubles = contents.num_matches(\" \\n\")\n    double_spaces = contents.num_matches('  ')\n    hyphens = contents.num_matches('-')\n    false_doubles += double_spaces + hyphens\n    words = spaces + breaks - false_doubles + 1\n    return words\n  end # word_count_for_file\n\n  puts word_count(ARGV)\n```", "```\n$ ruby -w word_count.rb word_count.rb\nword_count.rb has 132 words.\n--------------------\nTotal word count = 132 (108.24)\n```", "```\n  #!/usr/bin/env ruby\n  #most_common_words.rb\n\n  class Array\n\n❶   def count_of(item)\n❷     grep(item).size    *The **`grep`** Method*\n❸     #inject(0) { |count,each_item| item == each_item ? count+1 : count }\n    end\n\n  end\n\n❹   def most_common_words(input, limit=25)\n      freq = Hash.new()\n      sample = input.downcase.split(/\\W/)\n      sample.uniq.each do |word|\n❺       freq[word] = sample.count_of(word) unless word == ''\n      end\n❻     words = freq.keys.sort_by do |word|\n        freq[word]\n      end.reverse.map do |word|    *The **`map`** Method*\n❼       \"#{word} #{freq[word]}\"\n      end\n❽     return words[0, limit]\n    end\n\n❾ puts most_common_words(readlines.to_s).join(\"\\n\")\n```", "```\nirb(main):001:0> digit_range = 0..9    *Ranges*\n=> 0..9\nirb(main):002:0> digit_range.class\n=> Range\nirb(main):003:0> digits = digit_range.to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):004:0> digits.map { |num| num + 1 }\n=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nirb(main):005:0> digits.map { |num| num + 10 }\n=> [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\nirb(main):006:0> digits.map { |num| num * 2 }\n=> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\nirb(main):007:0> digits.map { |num| num ** 2 }\n=> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nirb(main):008:0> digits\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):009:0> digits.map! { |num| num ** 2 }\n=> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nirb(main):010:0> digits\n=> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```", "```\n$ ruby most_common_words.rb most_common_words.rb\nword 9\nend 6\nfreq 5\ndo 3\nsample 3\nmost_common_words 3\ncount 3\nitem 3\n0 2\ncount_of 2\nwords 2\ninput 2\ndef 2\nlimit 2\neach_item 2\nsplit 1\nunless 1\n1 1\ndowncase 1\nmap 1\nrb 1\narray 1\nruby 1\nusr 1\neach 1\n```", "```\ndup.delete_if { |i| i != item }.size || 0\n```", "```\n  #!/usr/bin/env ruby\n  # rotate.rb\n\n  class String\n\n❶   def rotate(char)\n❷     return nil unless self.match(char)\n❸     return self if (self[0] == char[0])\n❹     chars = self.split(//)\n      return ([chars.pop] + chars).join('').rotate(char)    *Recursion*\n    end\n\n❻   def rotate!(char)\n      replace(rotate(char))\n    end\n\n  end\n```", "```\n$ irb -r rotate.rb\nirb(main):001:0> 'I am a String.'.rotate('a')\n=> \"a String.I am \"\nirb(main):002:0> 'I am a String.'.rotate('S')\n=> \"String.I am a \"\n```"]