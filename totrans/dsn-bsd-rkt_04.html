<html><head></head><body><div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="kernel_object_hooking"/>Chapter 4. KERNEL OBJECT HOOKING</h1></div></div></div><p>In the previous chapter we covered subverting the FreeBSD kernel using simple data-state changes. The discussion centered around modifying the data contained within the kernel queue data structures. In addition to record keeping, many of these structures are also directly involved in control flow, as they maintain a limited number of entry points into the kernel. Consequently, these can be hooked, too, just like the entry points discussed in <a class="xref" href="ch02.html" title="Chapter 2. HOOKING">Chapter 2</a>. This technique is referred to as <span class="emphasis"><em>Kernel Object Hooking (KOH)</em></span>. To demonstrate it, let's hook a character device.<a id="IDX-CHP-4-0254" class="indexterm"/><a id="IDX-CHP-4-0255" class="indexterm"/></p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="hooking_a_character_device"/>Hooking a Character Device</h1></div></div></div><p>Recall from <a class="xref" href="ch01.html" title="Chapter 1. LOADABLE KERNEL MODULES">Chapter 1</a> that a character device is defined by its entries in a character device switch table.<sup>[<a id="CHP-4-FN-1" href="#ftn.CHP-4-FN-1" class="footnote">1</a>]</sup> As such, by modifying these entries, you can modify the behavior of a character device. Before demonstrating this "attack," however, some background information on character device management is necessary.<a id="IDX-CHP-4-0257" class="indexterm"/><a id="IDX-CHP-4-0256" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_cdevp_list_tail_queue_and_cdev_priv_structures"/>The cdevp_list Tail Queue and cdev_priv Structures</h2></div></div></div><p>In FreeBSD all active character devices are maintained on a private, doubly-linked tail queue named <code class="literal">cdevp_list</code>, which is defined in the file /sys/fs/devfs/devfs_devs.c as follows:<a id="IDX-CHP-4-0258" class="indexterm"/><a id="IDX-CHP-4-0259" class="indexterm"/><a id="IDX-CHP-4-0260" class="indexterm"/><a id="IDX-CHP-4-0261" class="indexterm"/><a id="IDX-CHP-4-0262" class="indexterm"/><a id="IDX-CHP-4-0263" class="indexterm"/></p><a id="I_programlisting4_d1e4642"/><pre class="programlisting">
static TAILQ_HEAD(,❶ucdev_priv) cdevp_list =
    TAILQ_HEAD_INITIALIZER(cdevp_list);
</pre><p>As you can see, <code class="literal">cdevp_list</code> is composed of ❶ <code class="literal">cdev_priv</code> structures. The definition for <code class="literal">struct cdev_priv</code> can be found in the <code class="literal">&lt;fs/devfs/devfs_int.h&gt;</code> header. Here are the fields in <code class="literal">struct cdev_priv</code> that you'll need to understand in order to hook a character device:<a id="IDX-CHP-4-0264" class="indexterm"/><a id="IDX-CHP-4-0265" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>TAILQ_ENTRY(cdev_priv) cdp_list;</code></strong></span></dt><dd><p>This field contains the linkage pointers that are associated with the <code class="literal">cdev_priv</code> structure, which is stored on <code class="literal">cdevp_lst</code>. This field is referenced during insertion, removal, and traversal of <code class="literal">cdevp_list.</code></p></dd><dt><span class="term"><strong class="userinput"><code>struct cdev cdp_c;</code></strong></span></dt><dd><p>This structure maintains the context of the character device. The definition for <code class="literal">struct cdev</code> can be found in the <code class="literal">&lt;sys/conf.h&gt;</code> header. The fields in <code class="literal">struct cdev</code> relevant to our discussion are as follows:</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>char *si_name;</code></strong></span></dt><dd><p>This field contains the name of the character device.</p></dd><dt><span class="term"><strong class="userinput"><code>struct cdevsw *si_devsw;</code></strong></span></dt><dd><p>This field points to the character device's switch table.</p></dd></dl></div></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_devmtx_mutex"/>The devmtx Mutex</h2></div></div></div><p>The following excerpt from <code class="literal">&lt;fs/devfs/devfs_int.h&gt;</code> lists the resource access control associated with <code class="literal">cdevp_list</code></p><a id="I_programlisting4_d1e4728"/><pre class="programlisting">
extern struct mtx devmtx;
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id5"/>Example</h2></div></div></div><p>As you might have guessed, in order to modify a character device's switch table, you simply have to go through <code class="literal">cdevp_list</code>. Listing 4-1 offers an example. This code traverses <code class="literal">cdevp_list</code>, looking for <code class="literal">cd_example</code>;<sup>[<a id="CHP-4-FN-2" href="#ftn.CHP-4-FN-2" class="footnote">2</a>]</sup> if it finds it, <code class="literal">cd_example</code>'s read entry point is replaced with a simple call hook.</p><a id="I_programlisting4_d1e4758"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/mutex.h&gt;

#include &lt;fs/devfs/devfs_int.h&gt;

extern TAILQ_HEAD(,cdev_priv) cdevp_list;

d_read_t        read_hook;
d_read_t        *read;

/* read entry point hook. */
int
read_hook(struct cdev *dev, struct uio *uio, int ioflag)
{

           uprintf("You ever dance with the devil in the pale moonlight?\n");


           ❶return((*read)(dev, uio, ioflag));

}

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{

        int error = 0;
        struct cdev_priv *cdp;

        switch (cmd) {
        case MOD_LOAD:
                mtx_lock(&amp;devmtx);

                /* Replace cd_example's read entry point with read_hook
                TAILQ_FOREACH(cdp, &amp;cdevp_list, cdp_list) {
                      if (strcmp(cdp-&gt;cdp_c.si_name, "cd_example") == 0) {
                              ❷read = cdp-&gt;cdp_c.si_devsw-&gt;d_read;
                              ❸cdp-&gt;cdp_c.si_devsw-&gt;d_read = read_hook;
                              break;

                    }

                 }


               mtx_unlock(&amp;devmtx);
               break;

           case MOD_UNLOAD:
                   mtx_lock(&amp;devmtx);

                   /* Change everything back to normal. */

                TAILQ_FOREACH(cdp, &amp;cdevp_list, cdp_list) {

                        if (strcmp(cdp-&gt;cdp_c.si_name, "cd_example") == 0) {

                                ❹cdp-&gt;cdp_c.si_devsw-&gt;d_read = read;
                                break;
                        }

                }


               mtx_unlock(&amp;devmtx);
               break;


         default:

                error = EOPNOTSUPP;
                break;
        }

        return(error);

     }


     static moduledata_t cd_example_hook_mod = {
             "cd_example_hook",      /* module name */
              load,                   /* event handler */
              NULL                    /* extra data */

};

DECLARE_MODULE(cd_example_hook, cd_example_hook_mod, SI_SUB_DRIVERS,
      SI_ORDER_MIDDLE);
</pre><p><span class="emphasis"><em>Listing 4.1: cd_example_hook.c</em></span></p><p>Notice that prior to ❸ replacing <code class="literal">cd_example</code>'s read entry point, I ❷ saved the memory address of the original entry. This allows you to ❶ call and ❹ restore the original function without having to include its definition in your code.</p><p>Here are the results of interacting with <code class="literal">cd_example</code> after loading the above module:</p><a id="I_programlisting4_d1e4773"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./cd_example_hook.ko</code></strong>
$ <strong class="userinput"><code>sudo ./interface Tell\ me\ something,\ my\ friend.</code></strong>
Wrote "Tell me something, my friend." to device /dev/cd_example
You ever dance with the devil in the pale moonlight?
Read "Tell me something, my friend." from device /dev/cd_example
</pre></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-1" href="#CHP-4-FN-1" class="para">1</a>] </sup><sup>1</sup> For the definition of a character device switch table, see <a class="xref" href="ch01s06.html#the_cdevsw_structure" title="The cdevsw Structure">The cdevsw Structure</a></p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FN-2" href="#CHP-4-FN-2" class="para">2</a>] </sup><sup>2</sup> <code class="literal">cd_example</code> is the character device developed in <a class="xref" href="ch01s06.html#example-id1" title="Example">Example</a>.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="concluding_remarks-id4"/>Concluding Remarks</h1></div></div></div><p>As you can see, KOH is more or less like DKOM, except that it uses call hooks instead of data-state changes. As such, there is really nothing "new" presented in this chapter (which is why it's so short).</p></div></body></html>