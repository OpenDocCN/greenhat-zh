- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Do you struggle to write programs, even though you think you understand programming
    languages? Are you able to read through a chapter in a programming book, nodding
    your head the whole way, but unable to apply what you’ve read to your own programs?
    Are you able to comprehend a program example you’ve read online, even to the point
    where you could explain to someone else what each line of the code is doing, yet
    you feel your brain seize up when faced with a programming task and a blank screen
    in your text editor?
  prefs: []
  type: TYPE_NORMAL
- en: You’re not alone. I have taught programming for over 15 years, and most of my
    students would have fit this description at some point in their instruction. We
    will call the missing skill *problem solving*, the ability to take a given problem
    description and write an original program to solve it. Not all programming requires
    extensive problem solving. If you’re just making minor modifications to an existing
    program, debugging, or adding testing code, the programming may be so mechanical
    in nature that your creativity is never tested. But all programs require problem
    solving at some point, and all good programmers can solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: Problem solving is hard. It’s true that a few people make it look easy—the “naturals,”
    the programming world’s equivalent of a gifted athlete, like Michael Jordan. For
    these select few, high-level ideas are effortlessly translated into source code.
    To make a Java metaphor, it’s as if their brains execute Java natively, while
    the rest of us have to run a virtual machine, interpreting as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Not being a natural isn’t fatal to becoming a programmer—if it were, the world
    would have few programmers. Yet I’ve seen too many worthy learners struggle too
    long in frustration. In the worst cases, they give up programming entirely, convinced
    that they can never be programmers, that the only good programmers are those born
    with an innate gift.
  prefs: []
  type: TYPE_NORMAL
- en: Why is learning to solve programming problems so hard?
  prefs: []
  type: TYPE_NORMAL
- en: In part, it’s because problem solving is a different activity from learning
    programming syntax and therefore uses a different set of mental “muscles.” Learning
    programming syntax, reading programs, memorizing elements of an application programming
    interface—these are mostly analytical “left brain” activities. Writing an original
    program using previously learned tools and skills is a creative “right brain”
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you need to remove a branch that has fallen into one of the rain gutters
    on your house, but your ladder isn’t quite long enough for you to reach the branch.
    You head into your garage and look for something, or a combination of things,
    that will enable you to remove the branch from the gutter. Is there some way to
    extend the ladder? Is there something you can hold at the top of the ladder to
    grab or dislodge the branch? Maybe you could just get on the roof from another
    place and get the branch from above. That’s problem solving, and it’s a creative
    activity. Believe it or not, when you design an original program, your mental
    process is quite similar to that of the person figuring out how to remove the
    branch from the gutter and quite different from that of a person debugging an
    existing `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming books, though, focus their attention on syntax and semantics.
    Learning the syntax and semantics of a programming language is essential, but
    it’s only the first step in learning how to program in that language. In essence,
    most programming books for beginners teach how to read a program, not how to write
    one. Books that do focus on writing are often effectively “cookbooks” in that
    they teach specific “recipes” for use in particular situations. Such books can
    be quite valuable as time savers, but not as a path toward learning to write original
    code. Think about cookbooks in the original sense. Although great cooks own cookbooks,
    no one who relies upon cookbooks can be a great cook. A great cook understands
    ingredients, preparation methods, and cooking methods and knows how they can be
    combined to make great meals. All a great cook needs to produce a tasty meal is
    a fully stocked kitchen. In the same way, a great programmer understands language
    syntax, application frameworks, algorithms, and software engineering principles
    and knows how they can be combined to make great programs. Give a great programmer
    a list of specifications, turn him loose with a fully stocked programming environment,
    and great things will happen.
  prefs: []
  type: TYPE_NORMAL
- en: In general, current programming education doesn’t offer much guidance in the
    area of problem solving. Instead, it’s assumed that if programmers are given access
    to all of the tools of programming and requested to write enough programs, eventually
    they will learn to write such programs and write them well. There is truth in
    this, but “eventually” can be a long time. The journey from initiation to enlightenment
    can be filled with frustration, and too many who start the journey never reach
    the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of learning by trial and error, you can learn problem solving in a
    systematic way. That’s what this book is all about. You can learn techniques to
    organize your thoughts, procedures to discover solutions, and strategies to apply
    to certain classes of problems. By studying these approaches, you can unlock your
    creativity. Make no mistake: Programming, and especially problem solving, is a
    creative activity. Creativity is mysterious, and no one can say exactly how the
    creative mind functions. Yet, if we can learn music composition, take advice on
    creative writing, or be shown how to paint, then we can learn to creatively solve
    programming problems, too. This book isn’t going to tell you precisely what to
    do; it’s going to help you develop your latent problem-solving abilities so that
    you will know what you should do. This book is about helping you become the programmer
    you are meant to be.'
  prefs: []
  type: TYPE_NORMAL
- en: My goal is for you and every other reader of this book to learn to systematically
    approach every programming task and to have the confidence that you will ultimately
    solve a given problem. When you complete this book, I want you to *think like
    a programmer* and to *believe that you are a programmer*.
  prefs: []
  type: TYPE_NORMAL
- en: About This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having explained the necessity of this book, I need to make a few comments about
    what this book is and what it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book assumes you are already familiar with the basic syntax and semantics
    of the C++ language and that you have begun writing programs. Most of the chapters
    will expect you to know specific C++ fundamentals; these chapters will begin with
    a review of those fundamentals. If you are still absorbing language basics, don’t
    worry. There are plenty of great books on C++ syntax, and you can learn problem
    solving in parallel to learning syntax. Just make sure you have studied the relevant
    syntax before attempting to tackle a chapter’s problems.
  prefs: []
  type: TYPE_NORMAL
- en: Chosen Topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topics covered in this book represent areas in which I have most often seen
    new programmers struggle. They also present a broad cross-section of different
    areas in early and intermediate programming.
  prefs: []
  type: TYPE_NORMAL
- en: I should emphasize, however, that this is not a “cookbook” of algorithms or
    patterns for solving specific problems. Although later chapters discuss how to
    employ well-known algorithms or patterns, you should not use this book as a “crib
    sheet” to get you past particular problems or focus on just the chapters that
    directly relate to your current struggles. Instead, I would work through the entire
    book, skipping material only if you lack the prerequisites needed to follow the
    discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A quick note here about the programming style employed in this book: This book
    is not about high-performance programming or running the most compact, efficient
    code. The style I have chosen for the source code examples is intended to be readable
    above all other considerations. In some cases, I take multiple steps to accomplish
    something that could be done in one step, just so the principle I’m trying to
    demonstrate is made clear.'
  prefs: []
  type: TYPE_NORMAL
- en: Some aspects of programming style will be covered in this book—but larger issues,
    like what should or should not be included in a class, not small issues, like
    how code should be indented. As a developing programmer, you will of course want
    to employ a consistent, readable style in all of the work you do.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The book includes a number of programming exercises. This is not a textbook,
    and you won’t find answers to any of the exercises in the back. The exercises
    provide opportunities for you to apply the concepts described in the chapters.
    Whether you choose to try any of the exercises is, of course, up to you, but it
    is essential that you put these concepts into practice. Simply reading through
    the book will accomplish nothing. Remember that this book is not going to tell
    you exactly what to do in each situation. In applying the techniques shown in
    this book, you will develop your own ability to discover what to do. Furthermore,
    growing your confidence, another primary goal of this book, requires success.
    In fact, that’s a good way to know when you have worked through enough exercises
    in a given problem area: when you are confident that you can tackle other problems
    in the area. Lastly, programming exercises should be *fun*. While there may be
    moments where you’d rather be doing something else, working out a programming
    problem should be a rewarding challenge.'
  prefs: []
  type: TYPE_NORMAL
- en: You should think of this book as an obstacle course for your brain. Obstacle
    courses build strength, stamina, and agility and give the trainer confidence.
    By reading through the chapters and applying the concepts to as many exercises
    as you can, you’re going to build confidence and develop problem-solving skills
    that can be used in any programming situation. In the future, when you are faced
    with a difficult problem, you’ll know whether you should try going over, under,
    or through it.
  prefs: []
  type: TYPE_NORMAL
- en: Why C++?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The programming examples in this text are coded using C++. Having said that,
    this book is about solving problems with programs, not specifically about C++.
    You won’t find many tips and tricks specific to C++ here, and the general concepts
    taught throughout this book can be employed in any programming language. Nevertheless,
    you can’t discuss programming without discussing programs, and a specific language
    had to be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: C++ was selected for a number of reasons. First, it’s popular in a variety of
    problem areas. Second, because of its origins in the strictly procedural C language,
    C++ code can be written using both the procedural and object-oriented paradigms.
    Object-oriented programming is so common now that it could not be omitted from
    a discussion on problem solving, but many fundamental problem-solving concepts
    can be discussed in strictly procedural programming terms, and doing so simplifies
    both the code and the discussion. Third, as a low-level language with high-level
    libraries, C++ allows us to discuss both levels of programming. The best programmers
    can “hand-wire” solutions when required and make use of high-level libraries and
    application programming interfaces to reduce development time. Lastly, and partly
    as a function of the other reasons listed, C++ is a great choice because once
    you have learned to solve problems in C++, you have learned to solve problems
    in any programming language. Many programmers have discovered how the skills learned
    in one language easily apply to other languages, but this is especially true for
    C++ because of its cross-paradigm approach and, frankly, because of its difficulty.
    C++ is the real deal—it’s programming without training wheels. This is daunting
    at first, but once you start succeeding in C++, you’ll know that you’re not going
    to be someone who can do a little coding—you’re going to be a programmer.
  prefs: []
  type: TYPE_NORMAL
