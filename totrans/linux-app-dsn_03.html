<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page19"/><img src="../images/43-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter3"/><a href="toc.html#chapter3">USING RUN-TIME ACCESS</a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">This chapter gives you a practical introduction to developing Linux appliances with the RTA library. Consider this your “Hello, world!” example. In this chapter, we’ll discuss the following:</p>&#13;
<p class="bul">• RTA appliance architecture</p>&#13;
<p class="bul">• RTA daemon architecture</p>&#13;
<p class="bul">• Telling RTA about your columns and tables</p>&#13;
<p class="bul">• Building your first RTA program</p>&#13;
<p class="bul">• A little SQL</p>&#13;
<p class="bul">• An introduction to RTA’s built-in tables</p>&#13;
<p class="bul">• The RTA table editor</p>&#13;
<p class="secl"><a id="chapter3.1"/><a href="toc.html#chapter3.1"><b>RTA Appliance Architecture</b></a></p>&#13;
<p class="noindent">You may recall from the last chapter that there were several reasons to put a well-defined protocol between the UI programs and the daemon. A protocol offers reduced complexity in both the UI and the daemon, gives access to the daemon while it is running, lets you work on and test the UIs and daemon independently, and helps improve security. The important requirements for the protocol are that the protocol’s data model matches your view of the data, that you don’t have to define or write the protocol yourself, and that the protocol will be available for most UI programming languages.</p>&#13;
<p class="indent"><a id="page20"/>The data model we use in this book is that of a database. Because we view our arrays of structures as tables of data, the UI programs (or <i>clients</i>) see the data in the daemon as data in a database. While the UI programs think they are dealing with a PostgreSQL database, they are, in fact, talking to the daemon. This arrangement results in an appliance architecture similar to that shown in Figure 3-1, in which a framebuffer UI uses the PostgreSQL C language binding in libpq.so; the web UI uses the PostgreSQL PHP binding in pgsql.so; and the test and debug UI uses the command line program psql.</p>&#13;
<p class="imgc"><img src="../images/44-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 3-1: A sample appliance using RTA</i></p>&#13;
<p class="indent">After connecting to the daemon over a Unix or TCP socket, the UIs shown in Figure 3-1 can display the configuration, status, and statistics available in the daemon. The librtadb.so library presents the daemon’s data as if it were coming from a PostgreSQL database. This figure shows the PostgreSQL client-side binding that we use in this book, but many more language bindings are available including Java, Python, Tcl, Perl, and Microsoft C++.</p>&#13;
<p class="indent">Figure 3-1 offers a global view of the appliance. Now let’s look at how RTA works inside the daemon.</p>&#13;
<p class="secl"><a id="chapter3.2"/><a href="toc.html#chapter3.2"><b>RTA Daemon Architecture</b></a></p>&#13;
<p class="noindent">Adding RTA to your daemon is fairly straightforward, since it usually involves using only two routines from the library. The first routine, rta_add_table(), makes one of your daemon’s tables visible to the clients. The second routine, dbcommand(), handles the protocol and SQL commands from the clients. Figure 3-2 illustrates a daemon offering RTA access to two UI-visible tables.</p>&#13;
<p class="imgc"><a id="page21"/><img src="../images/45-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 3-2: A daemon using RTA</i></p>&#13;
<p class="indent">The dbcommand() routine does not communicate directly with the client. Your program must create a listening TCP or Unix socket and must be able to accept and manage connections from the UI or other clients. Once a connection is established, all data from the connection should be passed to RTA with a call to dbcommand(). The dbcommand() routine parses the SQL command in the request from the client; if the request is valid, it executes the SQL command and returns a buffer with any data to be sent back to the client.</p>&#13;
<p class="indent">RTA would be of limited usefulness if all it could do was read and write values in your tables. Its real power lies in its ability to call a routine when ever a UI reads or writes a value into one of your tables. These read and write <i>callbacks</i> are similar to traditional database triggers. Callbacks are tied to the column definition and are specified separately for reads and writes. (We describe callbacks in the more detail in the next section.)</p>&#13;
<p class="secl"><a id="chapter3.3"/><a href="toc.html#chapter3.3"><b>Telling RTA About Your Columns and Tables</b></a></p>&#13;
<p class="noindent">A table is an array or linked list of data structures. Each member of your data structure is considered to be a column in a table, and each instance of the data structure is considered to be a row. From this point on, when you see the term <i>column</i>, think <i>member of my data structure</i>. In order to make a table visible to clients, you need to describe the table in a way that RTA can understand. This means describing the table as a whole and then describing each column in the table.</p>&#13;
<p class="indent">A TBLDEF structure describes the table as a whole; it contains a pointer to an array of column definitions with a COLDEF structure to define each column in your data table. At first you may find the process of creating COLDEFs and TBLDEFs painstaking and tedious, but once you have a little experience, you’ll find it simple and mechanical.</p>&#13;
<p class="secs"><a id="chapter3.4"/><a href="toc.html#chapter3.4"><b><i>Columns</i></b></a></p>&#13;
<p class="noindent"><a id="page22"/>One big advantage of RTA is that you don’t need to marshal the data into and out of the protocol. RTA uses your data as it already exists in your program. Of course, you have to describe your data so that RTA can access it intelligently. A table is made up of columns, and we need to describe each column in the table. This is the purpose of RTA’s COLDEF data structure.</p>&#13;
<p class="indent">You can also have members in your data structure that are not defined by a COLDEF. Such hidden columns might include information that you do not want to be visible to the UIs, or binary data that would have no meaning if it was displayed to the user.</p>&#13;
<p class="indent">A COLDEF contains nine pieces of information about each of your structure’s members.</p>&#13;
<p class="imgl"><img src="../images/46-1.jpg" alt=""/></p>&#13;
<p class="sec"><b>table</b></p>&#13;
<p class="bl">The table field specifies the name of the table as seen from the UI programs.</p>&#13;
<p class="sec"><b>name</b></p>&#13;
<p class="bl">The name field specifies the name of the column. Use this name when selecting or updating this column.</p>&#13;
<p class="sec"><b>type</b></p>&#13;
<p class="bl">The type of the column is used for syntax checking and for SQL SELECT output formatting. The currently defined types include:</p>&#13;
<p class="imgl"><img src="../images/46-2.jpg" alt=""/></p>&#13;
<p class="seca"><b>length</b></p>&#13;
<p class="bl"><a id="page23"/>RTA uses the native compiler data types in order to match the data types you use in your structures. The length member is ignored for integers, longs, floats, and their associated pointer types, but it has meaning for strings and pointers to strings, both of which should report the number of bytes in the string (including the terminating null).</p>&#13;
<p class="seca"><b>offset</b></p>&#13;
<p class="bl">The offset is the number of bytes from the start of the data structure to the structure member being described. For example, a table using a data structure with an int, a 20-character string, and a long would have the offset to the long set to 24 (assuming it was a 4-byte int).</p>&#13;
<p class="indent">Computing the offset of a structure member is painstaking and error prone. The gcc compiler suite provides the offsetof() macro to automatically compute the offset of the structure member.</p>&#13;
<p class="seca"><b>flags</b></p>&#13;
<p class="bl">A column has two binary attributes that are specified by the flags member. The first attribute specifies whether the column can be overwritten or if it is read-only. Statistics are often marked as read-only. An error is generated if a column marked as read-only is the subject in an UPDATE statement. The #define for this attribute is RTA_READONLY.</p>&#13;
<p class="bli">The second attribute specifies whether or not values written to this column should be saved in a configuration file associated with the table. Values that should persist from one invocation of the program to the next should be marked with the #define RTA_DISKSAVE attribute.</p>&#13;
<p class="bli">The flags field is the bitwise OR of RTA_DISKSAVE and RTA_READONLY.</p>&#13;
<p class="seca"><b>readcb()</b></p>&#13;
<p class="bl">If defined, the <i>read callback</i> routine, readcb(), is called every time the column’s value is used. This is handy for values that take lots of CPU cycles to compute but that are used infrequently. A read callback is invoked each time the column is referenced—if your SQL statement uses the column name twice, the read callback is called twice.</p>&#13;
<p class="bli">The read callback is passed five parameters: the table name, the column name, the text of the SQL request, a pointer to the row affected, and the zero-indexed row number. A function prototype for a read callback is shown below.</p>&#13;
<p class="ex">int readcb(char *tbl, char *col, char *sql, void *pr, int rowid);</p>&#13;
<p class="bli">A read callback returns zero on success and an error code if an error occurred in the callback. (See Appendix A for a list of the error codes and more details on callbacks.) Check the return value in your clients in order to enhance reliability and security.</p>&#13;
<p class="seca"><a id="page24"/><b>writecb()</b></p>&#13;
<p class="bl"><i>Write callbacks</i> can be the real engine driving your application. If defined, the write callback, writecb(), is called after all columns in an UPDATE have been changed. Consider the following SQL command:</p>&#13;
<p class="ex">UPDATE ifcfg SET addr="192.168.1.1", mask = "255.255.255.0";</p>&#13;
<p class="bli">If there is a write callback on addr, it will be called after both addr and mask have been updated. RTA does the write callback after all the fields have updated in order to help maintain consistency.</p>&#13;
<p class="bli">Write callbacks are passed six parameters: the table name, the column name, the text of the UPDATE statement, a pointer to the row affected, the zero-indexed row number, and a pointer to a copy of the row before any changes were made. (This last parameter is useful when you want to know both the old and new values for the row.) The copy of the old row is in dynamically allocated memory, which is freed after the write callback returns. A function prototype for a write callback is shown below.</p>&#13;
<p class="ex">int writecb(char *tbl, char *col, char *sql, void *pr, int rowid, void *poldrow);</p>&#13;
<p class="bli">The write callback returns zero on success and nonzero on failure. On failure, the row is restored to its initial value and an SQL error, TRIGGERED ACTION EXCEPTION, is returned to the client. Write callbacks allow you to enforce consistency and can provide security checks for your system.</p>&#13;
<p class="seca"><b>help</b></p>&#13;
<p class="bl">Your help text for the column should include a description of how the column is used, any limits or constraints on the column, and the side effects caused by any read or write callbacks. (Give yourself and your fellow developers meaningful help text for your columns to make it easier to maintain and troubleshoot your code.)</p>&#13;
<p class="secs"><a id="chapter3.5"/><a href="toc.html#chapter3.5"><i><b>Tables</b></i></a></p>&#13;
<p class="noindent">You tell RTA about each of your tables with a call to the RTA routine rta_add_table(). The single parameter to rta_add_table() is a pointer to a TBLDEF structure that describes the table.</p>&#13;
<p class="indent">The TBLDEF structure uses 10 pieces of information to describe your table. The most critical of these are the name of the table, the start address of the array of structures, the width of each structure (that is, the width of each row), the number of rows, and a pointer to an array of COLDEF structures that describe the columns in the table. Most of the fields in the TBLDEF structure should be self-explanatory.</p>&#13;
<p class="imgl"><img src="../images/48-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page25"/><img src="../images/49-1.jpg" alt=""/></p>&#13;
<p class="seca"><b>savefile</b></p>&#13;
<p class="bl">The need to save configuration data from one boot of the appliance to the next is so common that the authors of RTA included the ability to automatically save table data in a file when the data is updated. There is one file per table, and the name of the file is specified in the TBLDEF structure as the savefile string. You can mark the columns to save by adding the RTA_DISKSAVE flag to the column definition.</p>&#13;
<p class="bli">The save file contains a list of UPDATE statements, one for each row in the table. The save file is read from the disk and applied to the table when you initialize the table with the rta_add_table() call. The combination of RTA_DISKSAVE on a column and a savefile for the table eliminates the need to parse XML or INI files to get initial or saved configuration values. Of course, you can use XML or INI if you prefer to—just set the savefile pointer to a null.</p>&#13;
<p class="seca"><b>iterator</b></p>&#13;
<p class="bl">An <i>iterator</i> is a subroutine in your code that steps through a linked list or other arrangement of the rows in your table. The iterator lets you treat a linked list, a B-tree, or just about any other scheme for organizing data as if the data was in a table.</p>&#13;
<p class="bli">The iterator function is called with three parameters: a pointer to the current row, the void pointer it_info from the TBLDEF, and the zero-indexed row number. The function returns a pointer to the next row. When RTA asks for the first row, the current row pointer is NULL, and the desired row index is zero. The function should return a NULL when RTA asks for the row after the last row in the list. If an iterator is defined, the address and nrows members in the TBLDEF are ignored. Here is its function prototype.</p>&#13;
<p class="ex">void iterator(void *cur_row, void *it_info, int rowid);</p>&#13;
<p class="bli">There is one caveat when using iterator functions: Loading a save file may fail if you have not already allocated all the links in the linked list. (Remember, the save file is a list of UPDATE statements and expects the rows to already exist.) Fortunately, there is a simple way around this problem. Always keep one unused row available, and when that row is written by an UPDATE statement, have a write callback allocate another row so that you can stay one step ahead of the UPDATEs. The logmuxd program presented in Chapter 7 uses this technique.</p>&#13;
<p class="secl"><a id="chapter3.6"/><a href="toc.html#chapter3.6"><b>Building Your First RTA Program</b></a></p>&#13;
<p class="noindent"><a id="page26"/>Now we’ll look at how to use RTA to expose a table inside a running program. The five basic steps for doing so are:</p>&#13;
<ol>&#13;
<li>Defining the problem.</li>&#13;
<li>Reviewing the code.</li>&#13;
<li>Installing RTA.</li>&#13;
<li>Building and linking.</li>&#13;
<li>Testing.</li>&#13;
</ol>&#13;
<p class="secs"><a id="chapter3.7"/><a href="toc.html#chapter3.7"><i><b>Defining the Problem</b></i></a></p>&#13;
<p class="noindent">We want to expose the UI program to an array of structures that contain a user-editable string and two integers. One of the integers, <i>zalarm</i>, is set by the user. The other, <i>zcount</i>, is incremented on each transition of zalarm from one to zero or from zero to one. We print a message to the console each time a transition occurs. The string, <i>zname</i>, is considered a configuration value and is saved in a disk file whenever it is updated. Since zcount is a statistic, we mark it as read-only. This sample problem is a precursor to the actual Laddie appliance application presented in Chapter 5. The code presented below is also available in the file myapp.c on this book’s companion CD.</p>&#13;
<p class="secs"><a id="chapter3.8"/><a href="toc.html#chapter3.8"><i><b>Reviewing the Code</b></i></a></p>&#13;
<p class="noindent">This code walk-through should give you an idea of what to expect in RTA-enabled programs.</p>&#13;
<p class="secls"><b>Includes, Defines, and Memory Allocation</b></p>&#13;
<p class="noindent">First, we’ll look at the code:</p>&#13;
<p class="imgl"><img src="../images/50-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page27"/><img src="../images/51-1.jpg" alt=""/></p>&#13;
<p class="indent">The transitions of zalarm are detected in a write callback. Here, <img src="../images/1.jpg" alt=""/> is the forward reference for it.</p>&#13;
<p class="indent">We need to allocate buffers for the text of the SQL command from the client and for the response returned to the client. At <img src="../images/2.jpg" alt=""/> we are using 500 and 5,000 bytes, respectively. These values are chosen to hold the largest possible SQL statement we expect to use and the largest possible result we expect to get back.</p>&#13;
<p class="indent">The structure definition at <img src="../images/3.jpg" alt=""/> is the heart of the application’s data. Each instance of this data structure looks like a row in a database to the various UIs and clients.</p>&#13;
<p class="indent">We see at <img src="../images/4.jpg" alt=""/> that our table has five rows in it.</p>&#13;
<p class="secls"><b>Column Definitions</b></p>&#13;
<p class="noindent">Here is the array of COLDEFs that define the columns in our table. The information in the COLDEFs is derived from the data structure we want to make visible and from our problem statement.</p>&#13;
<p class="imgl"><img src="../images/51-2.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page28"/>Note <img src="../images/1.jpg" alt=""/> the definition of the zedgedetect write callback in the COLDEF above. We do the transition detection of zalarm in this callback.</p>&#13;
<p class="imgl"><img src="../images/52-1.jpg" alt=""/></p>&#13;
<p class="secls"><b>Table Defin it ion</b></p>&#13;
<p class="noindent">In the TBLDEF we give the name of the table, its start address, the size of each row, the number of rows, a pointer to the table of COLDEFs for this table, and the number of columns in the table. The save file, /tmp/zsave.sql, will be used to save the RTA_DISKSAVE columns, which, in this case, is only the name column.</p>&#13;
<p class="imgl"><img src="../images/52-2.jpg" alt=""/></p>&#13;
<p class="secls"><b>main() Routine</b></p>&#13;
<p class="noindent">This is pretty standard code. We allocate our socket structures and other local variables, then we initialize the table values and use rta_add_table() to tell RTA about our table.</p>&#13;
<p class="imgl"><img src="../images/52-3.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page29"/><img src="../images/53-1.jpg" alt=""/></p>&#13;
<p class="secls"><b>Setting Up a Listening Socket</b></p>&#13;
<p class="noindent">Remember that each UI program treats our application as if it were a PostgreSQL database, and we have to accept either Unix or TCP connections from these clients. Therefore, as the final piece of initialization, we set up the socket to listen for incoming client connections. Our program is listening on TCP port 8888, so we need to tell our PostgreSQL clients to use this port.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>The following code has some serious shortcomings (i.e., blocking I/O, ignoring error conditions, and making optimistic assumptions about socket I/O). Our goal, however, is to make the code understandable by keeping it as short as possible.</i></p>&#13;
<p class="imgl"><img src="../images/53-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page30"/><img src="../images/54-1.jpg" alt=""/></p>&#13;
<p class="indent">The <img src="../images/1.jpg" alt=""/> read() call above uses blocking I/O. In a real application we would want to accept the connection and use a select() or poll() to multiplex for us. However, in this example we are trying keep the line count low.</p>&#13;
<p class="secls"><b>dbcommand() Call</b></p>&#13;
<p class="noindent">The following call is where the real work of RTA occurs. We pass the SQL command read from the client into the RTA library which parses it, verifies it, executes it, and fills outbuf with the result. We switch on the result of the dbcommand() call to see if we should send the result back to the client or close the connections. Under normal circumstances, the PostgreSQL client will do an orderly close and the dbcommand() call will return RTA_CLOSE.</p>&#13;
<p class="imgl"><img src="../images/54-2.jpg" alt=""/></p>&#13;
<p class="secls"><b>Write Callback</b></p>&#13;
<p class="noindent">Here is the subroutine that is called after a UI/client program has set the zalarm column. A typical SQL command for this update would be UPDATE ztable SET zalarm = 0.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>When first learning to use callbacks, you might want to add a print statement to the callback to display the table, column, input SQL, and row number.</i></p>&#13;
<p class="imgl"><img src="../images/54-3.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page31"/><img src="../images/55-1.jpg" alt=""/></p>&#13;
<p class="indent">A transition is detected by comparing the old value of zalarm with the new value. Both old and new values of the row are passed into the routine as parameters. We always return success in this example.</p>&#13;
<p class="exi">return(0); /* always succeeds */ }</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>As a reminder, if the write callback returns a nonzero value, the row affected is restored to its old value and the client program receives an error result from the SQL command that it sent.</i></p>&#13;
<p class="secs"><a id="chapter3.9"/><a href="toc.html#chapter3.9"><i><b>Installing RTA</b></i></a></p>&#13;
<p class="noindent">You can find a copy of the RTA package on this book’s companion CD and on the RTA project website (<a href="http://librta.org">http://librta.org</a>). Check the website for the latest version. The SQL parser in RTA is written using yacc and lex, so your development system will need to have both installed if you build RTA from its source code.</p>&#13;
<p class="indent">The default installation of RTA puts the .a and .so libraries into the /usr/local/lib directory. If you do not want to use /usr/local/lib, you can edit the makefile before performing the install.</p>&#13;
<p class="indent">Once you have downloaded the RTA package, extract the files and build the library. The sample code below shows you how.</p>&#13;
<p class="imgl"><img src="../images/55-2.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter3.10"/><a href="toc.html#chapter3.10"><i><b>Building and Linking</b></i></a></p>&#13;
<p class="noindent"><a id="page32"/>Now create a test directory under rta-X.Y.Z and copy myapp.c to it. Next, build the application with this command:</p>&#13;
<p class="ex"># gcc myapp.c -o myapp -L/usr/local/lib -lrtadb</p>&#13;
<p class="indent">To compile and run the application, we tell the system where to find the RTA libraries at runtime. You can edit /etc/ld.so.conf and run ldconf ig or export the LD_LIBRARY_PATH environment variable. If the compile succeeded, you should be able to run the application with these commands:</p>&#13;
<p class="ex"># export LD_LIBRARY_PATH=/usr/local/lib<br/># ./myapp</p>&#13;
<p class="indent">That’s it! Your sample application should be up and running and ready to respond to PostgreSQL requests.</p>&#13;
<p class="secs"><a id="chapter3.11"/><a href="toc.html#chapter3.11"><i><b>Testing</b></i></a></p>&#13;
<p class="noindent">In this section we assume you have installed PostgreSQL from your Linux distribution or from the version included on this book’s companion CD, and that the psql command is somewhere on your path. If all has gone well, you should now have an application running which pretends to be a PostgreSQL database server. Instead of a database, however, our sample application is offering up its internal table for use by various PostgreSQL clients. The client we will be using first is the command line tool, psql.</p>&#13;
<p class="indent">Assuming everything is in order, open another terminal window and start psql, specifying the host and port of the database server as follows. (Remember that we told our application to listen on port 8888.)</p>&#13;
<p class="ex"># psql -h localhost -p 8888</p>&#13;
<p class="indent">PostgreSQL should respond with something like this:</p>&#13;
<p class="imgl"><img src="../images/56-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page33"/><img src="../images/57-1.jpg" alt=""/></p>&#13;
<p class="indent">If your SQL command did not display the above table, you need to debug the RTA installation. The most common problem is a version mismatch in the PostgreSQL protocol between the client and RTA. The psql client may give a warning, but it is fairly forgiving of using a newer client with an older server. This may be the case if you are using the very latest psql client.</p>&#13;
<p class="indent">Check the RTA website to see if your version of RTA is compatible with your version of PostgreSQL. If there is a mismatch, update either RTA or PostgreSQL. This book’s companion CD contains versions of the RTA and PostgreSQL libraries that are known to be compatible. You can also do a netstat -natp to verify that the application is really listening on port 8888.</p>&#13;
<p class="indent">Before dropping into the tutorial on SQL, let’s try a couple of commands just to see how the application responds.</p>&#13;
<p class="ex"># UPDATE ztable SET zalarm = 1;<br/>UPDATE 5<br/>#</p>&#13;
<p class="indent">This should cause a <i>transition</i> message to be printed on the console where you started myapp. (Note that psql responds with the number of rows changed, and because we did not specify which row to change, all five rows were updated.)</p>&#13;
<p class="indent">Now issue the same command a second time.</p>&#13;
<p class="ex"># UPDATE ztable SET zalarm = 1;<br/>UPDATE 5<br/>#</p>&#13;
<p class="indent">There should be no message printed to the console, since this time there was no transition.</p>&#13;
<p class="indent">Setting zalarm back to zero should cause a transition, and the count of transitions should now be 2.</p>&#13;
<p class="imgl"><a id="page34"/><img src="../images/58-1.jpg" alt=""/></p>&#13;
<p class="indent">When you first started ./myapp, the saved table configuration file, /tmp/zsave.sql, did not exist. Create it by doing an update on a column that is marked as RTA_DISKSAVE.</p>&#13;
<p class="ex"># UPDATE ztable SET zname = "row name";<br/>UPDATE 5<br/>#</p>&#13;
<p class="indent">You can verify the above by doing a cat on /tmp/zsave.sql. You should see the following:</p>&#13;
<p class="ex">UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 0<br/>UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 1<br/>UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 2<br/>UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 3<br/>UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 4</p>&#13;
<p class="indent">To conclude this section on RTA, let’s generate some errors and look at the corresponding error messages.</p>&#13;
<p class="ex"># UPDATE ztable SET zcount = 0;<br/>ERROR: Can not update read-only column 'zcount'<br/># UPDATE ztable SET zname = "abcdefghijklmnopqrstuvwxyz";<br/>ERROR: String too long for 'zname'<br/>#</p>&#13;
<p class="secl"><a id="chapter3.12"/><a href="toc.html#chapter3.12"><b>A Little SQL</b></a></p>&#13;
<p class="noindent">Structured Query Language is a standard way to manipulate data in a database. RTA uses only two SQL commands: SELECT, to get data from a table, and UPDATE, to write data to a table. The RTA syntax for SELECT and UPDATE is a limited subset of the standard SQL syntax, with one minor extension.</p>&#13;
<p class="secs"><a id="chapter3.13"/><a href="toc.html#chapter3.13"><i><b>SELECT</b></i></a></p>&#13;
<p class="noindent"><a id="page35"/>The SELECT statement reads values out of a table. The syntax for the RTA SELECT statement is:</p>&#13;
<p class="ex">SELECT column_list FROM table [where_clause] [limit_clause]</p>&#13;
<p class="indent">The column_list is a comma-separated list of column names or a single asterisk (*) to retrieve all columns. The variable table is the name of the table you wish to examine. The where_clause specifies which rows to return, and the limit_clause tells how many rows to return. Here are some simple examples.</p>&#13;
<p class="ex">SELECT * FROM ztable<br/>select * from ztable<br/>SELECT zcount, zname FROM ztable</p>&#13;
<p class="indent">You can specify the columns in any order, and you can ask for the same column more than once.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>The SQL parser recognizes the SQL reserved words in both upper- and lowercase letters. We use uppercase in our examples to make the reserved words more visible.</i></p>&#13;
<p class="indent">Also, SQL does not require a semicolon at the end of the line, but the psql command line tool does.</p>&#13;
<p class="secs"><a id="chapter3.14"/><a href="toc.html#chapter3.14"><i><b>UPDATE</b></i></a></p>&#13;
<p class="noindent">The UPDATE statement writes values into a table. The syntax for the RTA UPDATE statement is:</p>&#13;
<p class="ex">UPDATE table SET update_list [where_clause] [limit_clause]</p>&#13;
<p class="indent">The update_list is a comma-separated list of value assignments in the following format:</p>&#13;
<p class="ex">column_name = value[, column_name = value...]</p>&#13;
<p class="indent">In the example above, value is a literal value. Let’s look at some more examples.</p>&#13;
<p class="ex">UPDATE ztable SET zalarm = 44<br/>UPDATE ztable SET zalarm = 0, zname = Terminator<br/>UPDATE ztable SET zalarm = <i>1,</i> zname = "Mr. Terminator"</p>&#13;
<p class="indent">Strings with spaces must be enclosed in either single or double quotes. One kind of quote can be enclosed in the other kind of quote.</p>&#13;
<p class="ex">UPDATE ztable SET zname = "Baker's Pride"<br/>UPDATE ztable SET zname = 'Just say "no"'</p>&#13;
<p class="secs"><a id="chapter3.15"/><a href="toc.html#chapter3.15"><i><b>WHERE</b></i></a></p>&#13;
<p class="noindent"><a id="page36"/>A WHERE clause specifies which rows to select or update, based on the data in the rows. WHERE might be the single biggest reason to use SQL. The form of the WHERE clause is:</p>&#13;
<p class="ex">col_name rel_op value [AND col_name rel_op value ...]</p>&#13;
<p class="indent">The supported comparison operators are equality, inequality, greater than, less than, greater than or equal to, and less than or equal to. Only logical AND is available to link column comparisons, and value must refer to a literal value. For example:</p>&#13;
<p class="ex">SELECT * FROM ztable WHERE zalarm != 0<br/>UPDATE ztable SET zalarm = 1 WHERE zname = "Front Door"</p>&#13;
<p class="secs"><a id="chapter3.16"/><a href="toc.html#chapter3.16"><i><b>LIMIT</b></i></a></p>&#13;
<p class="noindent">The LIMIT clause can limit the number of rows selected to limit rows, and can specify that the first OFFSET rows be ignored. The form of the LIMIT clause is:</p>&#13;
<p class="ex">[LIMIT limit [OFFSET offset]]</p>&#13;
<p class="indent">Normal SQL does not support the idea of “give me only the third row,” but this functionality is important if you’re trying to manage an embedded application. The LIMIT and OFFSET clauses let you specify exactly how many rows should be returned and how many candidate rows to ignore before starting the read or write. If there is a WHERE clause, the offset and limit apply only to the rows that match the WHERE conditions. For example:</p>&#13;
<p class="ex">UPDATE ztable SET zname = "Front Door" LIMIT 2<br/>UPDATE ztable SET zname = "Back Door" LIMIT 3 OFFSET 2<br/>UPDATE ztable SET zalarm = 1 LIMIT 2 OFFSET 1<br/>SELECT zname FROM ztable LIMIT 4<br/>UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2<br/>SELECT * FROM ztable WHERE zalarm = 1 LIMIT 1</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>A great way to step through a table one row at a time is to set LIMIT to 1 and increment OFFSET from 0 up to one less than the number of rows.</i></p>&#13;
<p class="indent1">You may remember that we said that we stored RTA_DISKSAVE columns in the save file given in the table definition, and that we wanted to store the configuration as SQL commands so that we could run it through the SQL parser. You can see a good example of the LIMIT clause and of save files by looking at /tmp/zsave.sql.</p>&#13;
<p class="ex"># cat /tmp/zsave.sql<br/>UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 0<br/>UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 1<br/>UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2<br/>UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 3<br/>UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 4</p>&#13;
<p class="indent"><a id="page37"/>Real SQL purists reading this are probably pounding the table with their shoe and shouting, “Where’s ORDER_BY and INSERT and DELETE . . . and . . . and . . . ?” They are not there. Remember, RTA is <i>not</i> a database—it is an interface. We only need SELECT and UPDATE.</p>&#13;
<p class="secl"><a id="chapter3.17"/><a href="toc.html#chapter3.17"><b>Introduction to RTA’s Built-in Tables</b></a></p>&#13;
<p class="noindent">The RTA library has several built-in tables. Appendix A has the full details, so we will introduce them here. The first table has only one row.</p>&#13;
<p class="secs"><a id="chapter3.18"/><a href="toc.html#chapter3.18"><i><b>rta_dbg</b></i></a></p>&#13;
<p class="noindent">The rta_dbg table lets you control how and what is logged. You can turn on tracing of all SQL by setting trace to 1, and you can direct log messages to neither, syslog, stderr, or both by setting target to 0, 1, 2, or 3, respectively. You can also specify the priority, facility, and ident values for syslog(). From psql we get:</p>&#13;
<p class="imgl"><img src="../images/61-1.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter3.19"/><a href="toc.html#chapter3.19"><i><b>rta_stat</b></i></a></p>&#13;
<p class="noindent">The rta_stat table holds statistics related to the calls into RTA. It contains counts of the different types of errors, how many connections have been opened into RTA, and the number of SELECTs and UPDATEs.</p>&#13;
<p class="imgl"><img src="../images/61-2.jpg" alt=""/></p>&#13;
<p class="secs"><a id="chapter3.20"/><a href="toc.html#chapter3.20"><i><b>rta_tables</b></i></a></p>&#13;
<p class="noindent"><a id="page38"/>The rta _tables metatable is a collection of table definition structures. In order to add a table into RTA, you had to fill in a data structure with a description of your table. The collection of table definition structures is itself a table in RTA. This is one of the RTA metatables.</p>&#13;
<p class="imgl"><img src="../images/62-1.jpg" alt=""/></p>&#13;
<p class="indent">The two RTA metatables have zero in the address field because they are actually an array of pointers, so they use an iterator function. All of the columns in the metatables are marked read-only, since all of the values are set from the rta_add_table() call.</p>&#13;
<p class="secs"><a id="chapter3.21"/><a href="toc.html#chapter3.21"><i><b>rta_columns</b></i></a></p>&#13;
<p class="noindent">The rta_columns metatable is a collection of column definitions. All of the column definitions from all of the tables are collected into the rta_columns table. (The table actually holds pointers to the COLDEF structures.) We can see what columns are in a table using the metatables and a WHERE clause.</p>&#13;
<p class="imgl"><img src="../images/62-2.jpg" alt=""/></p>&#13;
<p class="indent">What do you suppose we would get if we combined the RTA metatables with PHP? Read on.</p>&#13;
<p class="secl"><a id="chapter3.22"/><a href="toc.html#chapter3.22"><b>The RTA Table Editor</b></a></p>&#13;
<p class="noindent">The RTA package has a web/PHP-based utility called a <i>table editor</i> that reads the RTA metatables and lets you view and edit any table in the system. Figure 3-3 shows the screen that lets you choose which table to view or edit. The screenshots in Figures 3-3, 3-4, and 3-5 were taken from our development system while we were working on the myapp.c application. You can see a similar screen by booting this book’s companion CD and using the browser on another PC to view <a href="http://192.168.1.11/rta/rta_tables.php?port=8885">http://192.168.1.11/rta/rta_tables.php?port=8885</a>.</p>&#13;
<p class="imgc"><a id="page39"/><img src="../images/63-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 3-3: The RTA Table Editor</i></p>&#13;
<p class="indent">Selecting a table from the top screen opens a web page with the contents of the selected table. Figure 3-4 shows a display of the example program’s ztable.</p>&#13;
<p class="imgc"><img src="../images/63-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 3-4: A sample table display</i></p>&#13;
<p class="indent">You can select a row to edit from the table display. Figure 3-5 shows the view after selecting row number 3.</p>&#13;
<p class="imgc"><a id="page40"/><img src="../images/64-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 3-5: A sample row edit screen</i></p>&#13;
<p class="indent">The RTA table editor has one HTML file and four PHP files that can be put on any PHP-enabled webserver. In fact, the webserver does not even need to run on the same machine as the application.</p>&#13;
<p class="indent">The HTML file contains a list of the RTA port numbers in use. You will have a different port number for each RTA-enabled application that you run. On our development machine, we have an HTML table with port numbers and RTA application names that looks like this:</p>&#13;
<p class="imgl"><img src="../images/64-2.jpg" alt=""/></p>&#13;
<p class="secl"><a id="chapter3.23"/><a href="toc.html#chapter3.23"><b>Summary</b></a></p>&#13;
<p class="noindent"><a id="page41"/>This chapter has presented the details of how to build your application using RTA so that several different types of UI programs can manage it. You’ve seen that you need to tell RTA about the data structures you want to make visible by describing them with TBLDEFs and COLDEFs.</p>&#13;
<p class="indent">While all this may seem a little overwhelming at first, stick with it. After just a little practice, you’ll find that writing TBLDEFs and COLDEFs is straightforward and mostly mechanical. The extra effort to add RTA to your daemon is more than compensated by having run-time access to configuration, status, and statistics.</p>&#13;
<p class="imgc"><a id="page42"/><img src="../images/66-1.jpg" alt=""/></p>&#13;
</div>&#13;
</body></html>