["```\n#include <sys/bus.h>\n#include <machine/bus.h>\n\nu_int8_t\nbus_read_1(struct resource *r, bus_size_t offset);\n\nu_int16_t\nbus_read_2(struct resource *r, bus_size_t offset);\n\nu_int32_t\nbus_read_4(struct resource *r, bus_size_t offset);\n\nu_int64_t\nbus_read_8(struct resource *r, bus_size_t offset);\n\nvoid\nbus_read_multi_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_read_multi_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_read_multi_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_read_multi_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n```", "```\n#include <sys/bus.h>\n#include <machine/bus.h>\n\nvoid\nbus_write_1(struct resource *r, bus_size_t offset,\n    u_int8_t value);\n\nvoid\nbus_write_2(struct resource *r, bus_size_t offset,\n    u_int16_t value);\n\nvoid\nbus_write_4(struct resource *r, bus_size_t offset,\n    u_int32_t value);\n\nvoid\nbus_write_8(struct resource *r, bus_size_t offset,\n    u_int64_t value);\n\nvoid\nbus_write_multi_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_write_multi_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_write_multi_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_write_multi_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n\nvoid\nbus_set_multi_1(struct resource *r, bus_size_t offset,\n    u_int8_t value, bus_size_t count);\n\nvoid\nbus_set_multi_2(struct resource *r, bus_size_t offset,\n    u_int16_t value, bus_size_t count);\n\nvoid\nbus_set_multi_4(struct resource *r, bus_size_t offset,\n    u_int32_t value, bus_size_t count);\n\nvoid\nbus_set_multi_8(struct resource *r, bus_size_t offset,\n    u_int64_t value, bus_size_t count);\n\nvoid\nbus_set_region_1(struct resource *r, bus_size_t offset,\n    u_int8_t value, bus_size_t count);\n\nvoid\nbus_set_region_2(struct resource *r, bus_size_t offset,\n    u_int16_t value, bus_size_t count);\n\nvoid\nbus_set_region_4(struct resource *r, bus_size_t offset,\n    u_int32_t value, bus_size_t count);\n\nvoid\nbus_set_region_8(struct resource *r, bus_size_t offset,\n    u_int64_t value, bus_size_t count);\n```", "```\n#include <sys/bus.h>\n#include <machine/bus.h>\n\nu_int8_t\nbus_read_stream_1(struct resource *r, bus_size_t offset);\n\nu_int16_t\nbus_read_stream_2(struct resource *r, bus_size_t offset);\n\nu_int32_t\nbus_read_stream_4(struct resource *r, bus_size_t offset);\n\nu_int64_t\nbus_read_stream_8(struct resource *r, bus_size_t offset);\n\nvoid\nbus_read_multi_stream_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_read_multi_stream_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_read_multi_stream_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_read_multi_stream_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_stream_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_stream_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_stream_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_read_region_stream_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n\nvoid\nbus_write_stream_1(struct resource *r, bus_size_t offset,\n    u_int8_t value);\n\nvoid\nbus_write_stream_2(struct resource *r, bus_size_t offset,\n    u_int16_t value);\n\nvoid\nbus_write_stream_4(struct resource *r, bus_size_t offset,\n    u_int32_t value);\n\nvoid\nbus_write_stream_8(struct resource *r, bus_size_t offset,\n    u_int64_t value);\n\nvoid\nbus_write_multi_stream_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_write_multi_stream_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_write_multi_stream_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_write_multi_stream_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_stream_1(struct resource *r, bus_size_t offset,\n    u_int8_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_stream_2(struct resource *r, bus_size_t offset,\n    u_int16_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_stream_4(struct resource *r, bus_size_t offset,\n    u_int32_t *datap, bus_size_t count);\n\nvoid\nbus_write_region_stream_8(struct resource *r, bus_size_t offset,\n    u_int64_t *datap, bus_size_t count);\n\nvoid\nbus_set_multi_stream_1(struct resource *r, bus_size_t offset,\n    u_int8_t value, bus_size_t count);\n\nvoid\nbus_set_multi_stream_2(struct resource *r, bus_size_t offset,\n    u_int16_t value, bus_size_t count);\n\nvoid\nbus_set_multi_stream_4(struct resource *r, bus_size_t offset,\n    u_int32_t value, bus_size_t count);\n\nvoid\nbus_set_multi_stream_8(struct resource *r, bus_size_t offset,\n    u_int64_t value, bus_size_t count);\n\nvoid\nbus_set_region_stream_1(struct resource *r, bus_size_t offset,\n    u_int8_t value, bus_size_t count);\n\nvoid\nbus_set_region_stream_2(struct resource *r, bus_size_t offset,\n    u_int16_t value, bus_size_t count);\n\nvoid\nbus_set_region_stream_4(struct resource *r, bus_size_t offset,\n    u_int32_t value, bus_size_t count);\n\nvoid\nbus_set_region_stream_8(struct resource *r, bus_size_t offset,\n    u_int64_t value, bus_size_t count);\n```", "```\n#include <sys/bus.h>\n#include <machine/bus.h>\n\nvoid\nbus_barrier(struct resource *r, bus_size_t offset, bus_size_t length,\n    int flags);\n```", "```\nbus_write_1(r, 0, data0);\nbus_barrier(r, 0, 1, BUS_SPACE_BARRIER_WRITE);\nbus_write_1(r, 0, data1);\nbus_barrier(r, 0, 2, BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);\ndata2 = bus_read_1(r, 1);\nbus_barrier(r, 1, 1, BUS_SPACE_BARRIER_READ);\ndata3 = bus_read_1(r, 1);\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/bus.h>\n  #include <sys/conf.h>\n  #include <sys/uio.h>\n  #include <sys/lock.h>\n  #include <sys/mutex.h>\n\n  #include <machine/bus.h>\n  #include <sys/rman.h>\n  #include <machine/resource.h>\n\n #define LED_IO_ADDR             0x404c\n #define LED_NUM                 2\n\n  struct led_softc {\n          int                     sc_io_rid;\n          struct resource        *sc_io_resource;\n          struct cdev            *sc_cdev0;\n          struct cdev            *sc_cdev1;\n          u_int32_t               sc_open_mask;\n          u_int32_t               sc_read_mask;\n          struct mtx              sc_mutex;\n  };\n\n  static devclass_t led_devclass;\n\n  static d_open_t                 led_open;\n  static d_close_t                led_close;\n  static d_read_t                 led_read;\n  static d_write_t                led_write;\n\n  static struct cdevsw led_cdevsw = {\n          .d_version =            D_VERSION,\n          .d_open =               led_open,\n          .d_close =              led_close,\n          .d_read =               led_read,\n          .d_write =              led_write,\n          .d_name =               \"led\"\n  };\n\n  static int\n  led_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n  {\n          int led = dev2unit(dev) & 0xff;\n          struct led_softc *sc = dev->si_drv1;\n\n          if (led >= LED_NUM)\n                  return (ENXIO);\n\n          mtx_lock(&sc->sc_mutex);\n          if (sc->sc_open_mask & (1 << led)) {\n                  mtx_unlock(&sc->sc_mutex);\n                  return (EBUSY);\n          }\n          sc->sc_open_mask |= 1 << led;\n          sc->sc_read_mask |= 1 << led;\n          mtx_unlock(&sc->sc_mutex);\n\n          return (0);\n  }\n\n  static int\n  led_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n  {\n          int led = dev2unit(dev) & 0xff;\n          struct led_softc *sc = dev->si_drv1;\n\n          if (led >= LED_NUM)\n                  return (ENXIO);\n\n          mtx_lock(&sc->sc_mutex);\n          sc->sc_open_mask &= ˜(1 << led);\n          mtx_unlock(&sc->sc_mutex);\n\n          return (0);\n  }\n\n  static int\n  led_read(struct cdev *dev, struct uio *uio, int ioflag)\n  {\n          int led = dev2unit(dev) & 0xff;\n          struct led_softc *sc = dev->si_drv1;\n          u_int8_t ch;\n          int error;\n\n          if (led >= LED_NUM)\n                  return (ENXIO);\n\n          mtx_lock(&sc->sc_mutex);\n          /* No error EOF condition. */\n          if (!(sc->sc_read_mask & (1 << led))) {\n                  mtx_unlock(&sc->sc_mutex);\n                  return (0);\n          }\n          sc->sc_read_mask &= ˜(1 << led);\n          mtx_unlock(&sc->sc_mutex);\n\n          ch = bus_read_1(sc->sc_io_resource, 0);\n          if (ch & (1 << led))\n                  ch = '1';\n          else\n                  ch = '0';\n\n          error = uiomove(&ch, 1, uio);\n          return (error);\n  }\n\n  static int\n  led_write(struct cdev *dev, struct uio *uio, int ioflag)\n  {\n          int led = dev2unit(dev) & 0xff;\n          struct led_softc *sc = dev->si_drv1;\n          u_int8_t ch;\n          u_int8_t old;\n          int error;\n\n          if (led >= LED_NUM)\n                  return (ENXIO);\n\n          error = uiomove(&ch, 1, uio);\n          if (error)\n                  return (error);\n\n          old = bus_read_1(sc->sc_io_resource, 0);\n          if (ch & 1)\n                  old |= (1 << led);\n          else\n                  old &= ˜(1 << led);\n\n          bus_write_1(sc->sc_io_resource, 0, old);\n\n          return (error);\n  }\n\n  static void\n  led_identify(driver_t *driver, device_t parent)\n  {\n          device_t child;\n\n          child = device_find_child(parent, \"led\", −1);\n          if (!child) {\n                  child = BUS_ADD_CHILD(parent, 0, \"led\", −1);\n                  bus_set_resource(child, SYS_RES_IOPORT, 0, LED_IO_ADDR, 1);\n          }\n  }\n\n  static int\n  led_probe(device_t dev)\n  {\n          if (!bus_get_resource_start(dev, SYS_RES_IOPORT, 0))\n                  return (ENXIO);\n\n          device_set_desc(dev, \"I/O Port Example\");\n          return (BUS_PROBE_SPECIFIC);\n  }\n\n  static int\n  led_attach(device_t dev)\n  {\n          struct led_softc *sc = device_get_softc(dev);\n\n          sc->sc_io_rid = 0;\n          sc->sc_io_resource = bus_alloc_resource_any(dev, SYS_RES_IOPORT,\n              &sc->sc_io_rid, RF_ACTIVE);\n          if (!sc->sc_io_resource) {\n                  device_printf(dev, \"unable to allocate resource\\n\");\n                  return (ENXIO);\n          }\n\n          sc->sc_open_mask = 0;\n          sc->sc_read_mask = 0;\n          mtx_init(&sc->sc_mutex, \"led\", NULL, MTX_DEF);\n\n          sc->sc_cdev0 = make_dev(&led_cdevsw, 0, UID_ROOT, GID_WHEEL, 0644,\n              \"led0\");\n          sc->sc_cdev1 = make_dev(&led_cdevsw, 1, UID_ROOT, GID_WHEEL, 0644,\n              \"led1\");\n          sc->sc_cdev0->si_drv1 = sc;\n          sc->sc_cdev1->si_drv1 = sc;\n\n          return (0);\n  }\n\n  static int\n  led_detach(device_t dev)\n  {\n          struct led_softc *sc = device_get_softc(dev);\n\n          destroy_dev(sc->sc_cdev0);\n          destroy_dev(sc->sc_cdev1);\n\n          mtx_destroy(&sc->sc_mutex);\n\n          bus_release_resource(dev, SYS_RES_IOPORT, sc->sc_io_rid,\n              sc->sc_io_resource);\n\n          return (0);\n  }\n\n  static device_method_t led_methods[] = {\n          /* Device interface. */\n          DEVMETHOD(device_identify,      led_identify),\n          DEVMETHOD(device_probe,         led_probe),\n          DEVMETHOD(device_attach,        led_attach),\n          DEVMETHOD(device_detach,        led_detach),\n          { 0, 0 }\n  };\n\n  static driver_t led_driver = {\n          \"led\",\n          led_methods,\n          sizeof(struct led_softc)\n  };\n\n  DRIVER_MODULE(led, isa, led_driver, led_devclass, 0, 0);\n```", "```\nstatic void\nled_identify(driver_t *driver, device_t parent)\n{\n        device_t child;\n\n        child = device_find_child(parent, \"led\", −1);\n        if (!child) {\n                child = BUS_ADD_CHILD(parent, 0, \"led\", −1);\n              bus_set_resource(child, SYS_RES_IOPORT, 0, LED_IO_ADDR, 1);\n        }\n}\n```", "```\nstatic int\nled_probe(device_t dev)\n{\n        if (!bus_get_resource_start(dev, SYS_RES_IOPORT, 0))\n                return (ENXIO);\n\n        device_set_desc(dev, \"I/O Port Example\");\n        return (BUS_PROBE_SPECIFIC);\n}\n```", "```\nstatic int\nled_attach(device_t dev)\n{\n        struct led_softc *sc = device_get_softc(dev);\n\n        sc->sc_io_rid = 0;\n        sc->sc_io_resource = bus_alloc_resource_any(dev, SYS_RES_IOPORT,\n            &sc->sc_io_rid, RF_ACTIVE);\n        if (!sc->sc_io_resource) {\n                device_printf(dev, \"unable to allocate resource\\n\");\n              return (ENXIO);\n        }\n\n      sc->sc_open_mask = 0;\n      sc->sc_read_mask = 0;\n        mtx_init(&sc->sc_mutex, \"led\", NULL, MTX_DEF);\n\n        sc->sc_cdev0 = make_dev(&led_cdevsw, 0, UID_ROOT, GID_WHEEL, 0644,\n            \"led0\");\n        sc->sc_cdev1 = make_dev(&led_cdevsw, 1, UID_ROOT, GID_WHEEL, 0644,\n            \"led1\");\n        sc->sc_cdev0->si_drv1 = sc;\n        sc->sc_cdev1->si_drv1 = sc;\n\n        return (0);\n}\n```", "```\nstatic int\nled_detach(device_t dev)\n{\n        struct led_softc *sc = device_get_softc(dev);\n\n      destroy_dev(sc->sc_cdev0);\n      destroy_dev(sc->sc_cdev1);\n\n      mtx_destroy(&sc->sc_mutex);\n\n      bus_release_resource(dev, SYS_RES_IOPORT, sc->sc_io_rid,\n            sc->sc_io_resource);\n\n        return (0);\n}\n```", "```\nstatic int\nled_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n{\n      int led = dev2unit(dev) & 0xff;\n        struct led_softc *sc = dev->si_drv1;\n\n      if (led >= LED_NUM)\n                return (ENXIO);\n\n        mtx_lock(&sc->sc_mutex);\n      if (sc->sc_open_mask & (1 << led)) {\n                mtx_unlock(&sc->sc_mutex);\n                return (EBUSY);\n        }\n      sc->sc_open_mask |= 1 << led;\n      sc->sc_read_mask |= 1 << led;\n        mtx_unlock(&sc->sc_mutex);\n\n        return (0);\n}\n```", "```\nstatic int\nled_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n{\n        int led = dev2unit(dev) & 0xff;\n        struct led_softc *sc = dev->si_drv1;\n\n        if (led >= LED_NUM)\n                return (ENXIO);\n\n        mtx_lock(&sc->sc_mutex);\n      sc->sc_open_mask &= ˜(1 << led);\n        mtx_unlock(&sc->sc_mutex);\n\n        return (0);\n}\n```", "```\nstatic int\nled_read(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int led = dev2unit(dev) & 0xff;\n        struct led_softc *sc = dev->si_drv1;\n        u_int8_t ch;\n        int error;\n\n        if (led >= LED_NUM)\n                return (ENXIO);\n\n        mtx_lock(&sc->sc_mutex);\n        /* No error EOF condition. */\n      if (!(sc->sc_read_mask & (1 << led))) {\n                mtx_unlock(&sc->sc_mutex);\n              return (0);\n        }\n        sc->sc_read_mask &= ˜(1 << led);\n        mtx_unlock(&sc->sc_mutex);\n\n      ch = bus_read_1(sc->sc_io_resource, 0);\n      if (ch & (1 << led))\n                ch = '1';\n        else\n                ch = '0';\n\n        error = uiomove(&ch, 1, uio);\n        return (error);\n}\n```", "```\nstatic int\nled_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        int led = dev2unit(dev) & 0xff;\n        struct led_softc *sc = dev->si_drv1;\n        u_int8_t ch;\n        u_int8_t old;\n        int error;\n\n        if (led >= LED_NUM)\n                return (ENXIO);\n\n        error = uiomove(&ch, 1, uio);\n        if (error)\n                return (error);\n\n      old = bus_read_1(sc->sc_io_resource, 0);\n      if (ch & 1)\n              old |= (1 << led);\n        else\n              old &= ˜(1 << led);\n\n      bus_write_1(sc->sc_io_resource, 0, old);\n\n        return (error);\n}\n```"]