<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Thread Synchronization"><div class="titlepage"><div><div><h1 class="title"><a id="thread_synchronization"/>Chapter 4. Thread Synchronization</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id4"/><div class="mediaobject"><a id="I_mediaobject4_d1e5835"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>This chapter deals with the problem of data and state corruption caused by concurrent threads. When multiple threads executing on different CPUs simultaneously modify the same data structure, that structure can be corrupted. Similarly, when a thread gets interrupted and another thread manipulates the data that the first thread was manipulating, that data can be corrupted (Baldwin, 2002).</p><p>Fortunately, FreeBSD provides a set of synchronization primitives to deal with these issues. Before I describe what synchronization primitives do, you’ll need an in-depth understanding of the abovementioned concurrency issues, also known as synchronization problems. To that end, let’s analyze a few.</p><div class="sect1" title="A Simple Synchronization Problem"><div class="titlepage"><div><div><h1 class="title"><a id="a_simple_synchronization_problem"/>A Simple Synchronization Problem</h1></div></div></div><p>Consider the following scenario in which two threads increment the same global variable. On <span class="emphasis"><em>i386</em></span>, this operation might utilize the following processor instructions:<a class="indexterm" id="IDX-CHP-4-0001"/><a class="indexterm" id="IDX-CHP-4-0002"/><a class="indexterm" id="IDX-CHP-4-0003"/></p><a id="I_programlisting4_d1e5863"/><pre class="programlisting">movl   count,%eax       # Move the value of count into a register (eax).
addl   $0x1,%eax        # Add 1 to the value in the register.
movl   %eax,count       # Move the value of the register into count.</pre><p>Imagine that <code class="literal">count</code> is currently <code class="literal">0</code> and that the first thread manages to load the current value of <code class="literal">count</code> into <code class="literal">%eax</code> (that is, it completes the first instruction) just before the second thread preempts it. As part of the thread switch, FreeBSD saves the value of <code class="literal">%eax</code>, which is <code class="literal">0</code>, into the outgoing thread’s context. Now, suppose that the second thread manages to complete all three instructions, thereby incrementing count from <code class="literal">0</code> to <code class="literal">1</code>. If the first thread preempts the second thread, FreeBSD will restore its thread context, which includes setting <code class="literal">%eax</code> to <code class="literal">0</code>. The first thread, which resumes execution at the second instruction, will now proceed to add <code class="literal">1</code> to <code class="literal">%eax</code> and then store the result in <code class="literal">count</code>. At this point, count equals <code class="literal">1</code> when it should equal <code class="literal">2</code>. Thus, because of a synchronization problem, we lost an update. This can also occur when the two threads are executing concurrently but just slightly out of step (that is, one thread begins executing the first instruction when the other thread begins executing the second instruction).</p></div></div>
<div class="sect1" title="A More Complex Synchronization Problem"><div class="titlepage"><div><div><h1 class="title"><a id="a_more_complex_synchronization_problem"/>A More Complex Synchronization Problem</h1></div></div></div><p><a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a> is a complete character driver that lets you manipulate a doubly linked list through its <code class="literal">d_ioctl</code> function. You can add or remove an item from the list, determine whether an item is on the list, or print every item on the list. <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a> also contains some synchronization problems.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Take a quick look at this code and try to identify the synchronization problems.</p></div><div class="example"><a id="race.c"/><p class="title">Example 4-1. race.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/conf.h&gt;
  #include &lt;sys/uio.h&gt;
  #include &lt;sys/malloc.h&gt;
  #include &lt;sys/ioccom.h&gt;
  #include &lt;sys/queue.h&gt;
  #include "race_ioctl.h"

  MALLOC_DEFINE(M_RACE, "race", "race object");

  struct race_softc {
         <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>LIST_ENTRY(race_softc) list;
         <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>int unit;
  };

  static <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>LIST_HEAD(, race_softc) race_list =
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>LIST_HEAD_INITIALIZER(&amp;race_list);

  static struct race_softc *      race_new(void);
  static struct race_softc *      race_find(int unit);
  static void                     race_destroy(struct race_softc *sc);
  static d_ioctl_t                race_ioctl;

<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/> static struct cdevsw race_cdevsw = {
          .d_version =    D_VERSION,
          .d_ioctl =      race_ioctl,
          .d_name =     <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>RACE_NAME
  };

  static struct cdev *race_dev;

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/> race_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
      struct thread *td)
  {
          struct race_softc *sc;
          int error = 0;

          switch (cmd) {
          case RACE_IOC_ATTACH:
                  sc = race_new();
                  *(int *)data = sc-&gt;unit;
                  break;
          case RACE_IOC_DETACH:
                  sc = race_find(*(int *)data);
                  if (sc == NULL)
                          return (ENOENT);
                  race_destroy(sc);
                  break;
          case RACE_IOC_QUERY:
                  sc = race_find(*(int *)data);
                  if (sc == NULL)
                          return (ENOENT);
                  break;
          case RACE_IOC_LIST:
                  uprintf("  UNIT\n");
                  LIST_FOREACH(sc, &amp;race_list, list)
                          uprintf("  %d\n", sc-&gt;unit);
                  break;
          default:
                  error = ENOTTY;
                  break;
          }

          return (error);
  }

  static struct race_softc *
  race_new(void)
  {
          struct race_softc *sc;
          int unit, max = −1;

          LIST_FOREACH(sc, &amp;race_list, list) {
                  if (sc-&gt;unit &gt; max)
                          max = sc-&gt;unit;
          }
          unit = max + 1;

          sc = (struct race_softc *)malloc(sizeof(struct race_softc), M_RACE,
              M_WAITOK | M_ZERO);
          sc-&gt;unit = unit;
          LIST_INSERT_HEAD(&amp;race_list, sc, list);

          return (sc);
  }

  static struct race_softc *
  race_find(int unit)
  {
          struct race_softc *sc;

          LIST_FOREACH(sc, &amp;race_list, list) {
                  if (sc-&gt;unit == unit)
                          break;
          }

          return (sc);
  }

  static void
  race_destroy(struct race_softc *sc)
  {
          LIST_REMOVE(sc, list);
          free(sc, M_RACE);
  }

  static int
  race_modevent(module_t mod __unused, int event, void *arg __unused)
  {
          int error = 0;

          switch (event) {
          case MOD_LOAD:
                  race_dev = make_dev(&amp;race_cdevsw, 0, UID_ROOT, GID_WHEEL,
                      0600, RACE_NAME);
                  uprintf("Race driver loaded.\n");
                  break;
          case MOD_UNLOAD:
                  destroy_dev(race_dev);
                  uprintf("Race driver unloaded.\n");
                  break;
          case MOD_QUIESCE:
                  if (!LIST_EMPTY(&amp;race_list))
                          error = EBUSY;
                  break;
          default:
                  error = EOPNOTSUPP;
                  break;
          }

          return (error);
  }

  DEV_MODULE(race, race_modevent, NULL);</pre></div></div><p>Before I identify <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>’s synchronization problems, let’s walk through it. <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a> begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5982"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> defining and <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e5988"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> initializing a doubly linked list of <code class="literal">race_softc</code> structures named <code class="literal">race_list</code>. Each <code class="literal">race_softc</code> structure contains a (unique) <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6004"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> unit number and a <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6010"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> structure that maintains a pointer to the previous and next <code class="literal">race_softc</code> structure in <code class="literal">race_list</code>.<a class="indexterm" id="IDX-CHP-4-0004"/><a class="indexterm" id="IDX-CHP-4-0005"/><a class="indexterm" id="IDX-CHP-4-0006"/><a class="indexterm" id="IDX-CHP-4-0007"/></p><p>Next, <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>’s <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6039"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> character device switch table is defined. The constant <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6045"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">RACE_NAME</code> is defined in the <code class="literal">race_ioctl.h</code> header as follows:</p><a id="I_programlisting4_d1e6057"/><pre class="programlisting">#define RACE_NAME               "race"</pre><p>Note how <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>’s character device switch table doesn’t define <code class="literal">d_open</code> and <code class="literal">d_close</code>. Recall, from <a class="xref" href="ch01.html" title="Chapter 1. Building and Running Modules">Chapter 1</a>, that if a <code class="literal">d_foo</code> function is undefined the corresponding operation is unsupported. However,<code class="literal">d_open</code> and <code class="literal">d_close</code> are unique; when they’re undefined the kernel will automatically define them as follows:</p><a id="I_programlisting4_d1e6081"/><pre class="programlisting">int
nullop(void)
{

        return (0);
}</pre><p>This ensures that every registered character device can be opened and closed.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Drivers commonly forgo defining a <code class="literal">d_open</code> and <code class="literal">d_close</code> function when they don’t need to prepare their devices for I/O—like <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>.</p></div><p>Next, <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>’s <code class="literal">d_ioctl</code> function, named <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6104"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">race_ioctl</code>, is defined. This function is like the <code class="literal">main</code> function for <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>. It uses three helper functions to do its work:<a class="indexterm" id="IDX-CHP-4-0008"/><a class="indexterm" id="IDX-CHP-4-0009"/><a class="indexterm" id="IDX-CHP-4-0010"/><a class="indexterm" id="IDX-CHP-4-0011"/><a class="indexterm" id="IDX-CHP-4-0012"/><a class="indexterm" id="IDX-CHP-4-0013"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">race_new</code></p></li><li class="listitem"><p><code class="literal">race_find</code></p></li><li class="listitem"><p><code class="literal">race_destroy</code></p></li></ul></div><p>Before I describe <code class="literal">race_ioctl</code>, I’ll describe these functions first.</p><div class="sect2" title="race_new Function"><div class="titlepage"><div><div><h2 class="title"><a id="race_underscore_new_function"/>race_new Function</h2></div></div></div><p>The <code class="literal">race_new</code> function creates a new <code class="literal">race_softc</code> structure, which is then inserted at the head of <code class="literal">race_list</code>. Here is the function definition for <code class="literal">race_new</code> (again):</p><a id="I_programlisting4_d1e6180"/><pre class="programlisting">static struct race_softc *
race_new(void)
{
        struct race_softc *sc;
        int unit, max = −1;

       <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>LIST_FOREACH(sc, &amp;race_list, list) {
                if (sc-&gt;unit &gt; max)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>max = sc-&gt;unit;
        }
        unit = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>max + 1;

        sc = (struct race_softc *)<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>malloc(sizeof(struct race_softc), M_RACE,
            M_WAITOK | M_ZERO);
        sc-&gt;unit = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>unit;
       <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>LIST_INSERT_HEAD(&amp;race_list, sc, list);

       <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>return (sc);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6227"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> iterates through <code class="literal">race_list</code> looking for the largest unit number, which it stores in <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6236"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">max.</code> Next, <code class="literal">unit</code> is set to <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6249"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">max</code> plus one. Then <code class="literal">race_new</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6261"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> allocates memory for a new <code class="literal">race_softc</code> structure, assigns it the unit number <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6270"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">unit</code>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6280"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> inserts it at the head of <code class="literal">race_list</code>. Lastly, <code class="literal">race_new</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6292"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> returns a pointer to the new <code class="literal">race_softc</code> structure.</p></div><div class="sect2" title="race_find Function"><div class="titlepage"><div><div><h2 class="title"><a id="race_underscore_find_function"/>race_find Function</h2></div></div></div><p>The <code class="literal">race_find</code> function takes a unit number and finds the associated <code class="literal">race_softc</code> structure on <code class="literal">race_list</code>.</p><a id="I_programlisting4_d1e6315"/><pre class="programlisting">static struct race_softc *
race_find(int unit)
{
        struct race_softc *sc;

        LIST_FOREACH(sc, &amp;race_list, list) {
                if (sc-&gt;unit == unit)
                        break;
        }

        return (sc);
}</pre><p>If <code class="literal">race_find</code> is successful, a pointer to the <code class="literal">race_softc</code> structure is returned; otherwise, <code class="literal">NULL</code> is returned.<a class="indexterm" id="IDX-CHP-4-0014"/><a class="indexterm" id="IDX-CHP-4-0015"/><a class="indexterm" id="IDX-CHP-4-0016"/><a class="indexterm" id="IDX-CHP-4-0017"/><a class="indexterm" id="IDX-CHP-4-0018"/></p></div><div class="sect2" title="race_destroy Function"><div class="titlepage"><div><div><h2 class="title"><a id="race_underscore_destroy_function"/>race_destroy Function</h2></div></div></div><p>The <code class="literal">race_destroy</code> function destroys a <code class="literal">race_softc</code> structure on <code class="literal">race_list</code>. Here is its function definition (again):</p><a id="I_programlisting4_d1e6366"/><pre class="programlisting">static void
race_destroy(<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct race_softc *sc)
{
       <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>LIST_REMOVE(sc, list);
       <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>free(sc, M_RACE);
}</pre><p>This function takes a <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6388"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> pointer to a <code class="literal">race_softc</code> structure and <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6397"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> removes that structure from <code class="literal">race_list</code>. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6406"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> frees the allocated memory for that structure.</p></div><div class="sect2" title="race_ioctl Function"><div class="titlepage"><div><div><h2 class="title"><a id="race_underscore_ioctl_function"/>race_ioctl Function</h2></div></div></div><p>Before I walk through <code class="literal">race_ioctl</code>, an explanation of its ioctl commands, which are defined in <code class="literal">race_ioctl.h</code>, is needed.</p><a id="I_programlisting4_d1e6423"/><pre class="programlisting">#define RACE_IOC_ATTACH         _IOR('R', 0, int)
#define RACE_IOC_DETACH         _IOW('R', 1, int)
#define RACE_IOC_QUERY          _IOW('R', 2, int)
#define RACE_IOC_LIST           _IO('R', 3)</pre><p>As you can see, three of <code class="literal">race_ioctl</code>’s ioctl commands transfer an integer value. As you’ll see, this integer value is a unit number.</p><p>Here is the function definition for <code class="literal">race_ioctl</code> (again):</p><a id="I_programlisting4_d1e6435"/><pre class="programlisting">static int
race_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
    struct thread *td)
{
        struct race_softc *sc;
        int error = 0;

        switch (cmd) {
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>case RACE_IOC_ATTACH:
                sc = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>race_new();
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>*(int *)data = sc-&gt;unit;
                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>case RACE_IOC_DETACH:
                sc = race_find(*(int *)data);
                if (sc == NULL)
                        return (ENOENT);
                race_destroy(sc);
                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>case RACE_IOC_QUERY:
                sc = race_find(*(int *)data);
                if (sc == NULL)
                        return (ENOENT);
                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>case RACE_IOC_LIST:
                uprintf("  UNIT\n");
                LIST_FOREACH(sc, &amp;race_list, list)
                        uprintf("  %d\n", sc-&gt;unit);
                break;
        default:
                error = ENOTTY;
                break;
        }

        return (error);
}</pre><p>This function can perform one of four ioctl-based operations. The first, <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6476"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">RACE_IOC_ATTACH</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6485"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> creates a new <code class="literal">race_softc</code> structure, which is then inserted at the head of <code class="literal">race_list</code>. Afterward, the unit number of the new <code class="literal">race_softc</code> structure is <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6501"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> returned.<a class="indexterm" id="IDX-CHP-4-0019"/><a class="indexterm" id="IDX-CHP-4-0020"/><a class="indexterm" id="IDX-CHP-4-0021"/><a class="indexterm" id="IDX-CHP-4-0022"/><a class="indexterm" id="IDX-CHP-4-0023"/><a class="indexterm" id="IDX-CHP-4-0024"/></p><p>The second operation, <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6531"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">RACE_IOC_DETACH</code>, removes a user-specified <code class="literal">race_softc</code> structure from <code class="literal">race_list</code>.</p><p>The third operation, <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6548"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">RACE_IOC_QUERY</code>, determines whether a user-specified <code class="literal">race_softc</code> structure is on <code class="literal">race_list</code>.</p><p>Lastly, the fourth operation, <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6565"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">RACE_IOC_LIST</code>, prints the unit number of every <code class="literal">race_softc</code> structure on <code class="literal">race_list</code>.</p></div><div class="sect2" title="race_modevent Function"><div class="titlepage"><div><div><h2 class="title"><a id="race_underscore_modevent_function"/>race_modevent Function</h2></div></div></div><p>The <code class="literal">race_modevent</code> function is the module event handler for <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>. Here is its function definition (again):</p><a id="I_programlisting4_d1e6590"/><pre class="programlisting">static int
race_modevent(module_t mod __unused, int event, void *arg __unused)
{
        int error = 0;

        switch (event) {
        case MOD_LOAD:
                race_dev = make_dev(&amp;race_cdevsw, 0, UID_ROOT, GID_WHEEL,
                    0600, RACE_NAME);
                uprintf("Race driver loaded.\n");
                break;
        case MOD_UNLOAD:
                destroy_dev(race_dev);
                uprintf("Race driver unloaded.\n");
                break;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>case MOD_QUIESCE:
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (!LIST_EMPTY(&amp;race_list))
                        error = EBUSY;
                break;
        default:
                error = EOPNOTSUPP;
                break;
        }

        return (error);
}</pre><p>As you can see, this function includes a new case: <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6606"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">MOD_QUIESCE</code>.<a class="indexterm" id="IDX-CHP-4-0025"/><a class="indexterm" id="IDX-CHP-4-0026"/><a class="indexterm" id="IDX-CHP-4-0027"/><a class="indexterm" id="IDX-CHP-4-0028"/><a class="indexterm" id="IDX-CHP-4-0029"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because <code class="literal">MOD_LOAD</code> and <code class="literal">MOD_UNLOAD</code> are extremely rudimentary and because you’ve seen similar code elsewhere, I’ll omit discussing them.</p></div><p>When one issues the <code class="literal">kldunload(8)</code> command, <code class="literal">MOD_QUIESCE</code> is run before <code class="literal">MOD_UNLOAD</code>. If <code class="literal">MOD_QUIESCE</code> returns an error, <code class="literal">MOD_UNLOAD</code> does not get executed. In other words, <code class="literal">MOD_QUIESCE</code> verifies that it is safe to unload your module.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">kldunload -f</code> command ignores every error returned by <code class="literal">MOD_QUIESCE</code>. So you can always unload a module, but it may not be the best idea.</p></div><p>Here, <code class="literal">MOD_QUIESCE</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e6680"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> guarantees that <code class="literal">race_list</code> is empty (before <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a> is unloaded). This is done to prevent memory leaks from any potentially unclaimed <code class="literal">race_softc</code> structures.</p></div><div class="sect2" title="The Root of the Problem"><div class="titlepage"><div><div><h2 class="title"><a id="the_root_of_the_problem"/>The Root of the Problem</h2></div></div></div><p>Now that we’ve walked through <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>, let’s run it and see if we can identify its synchronization problems.</p><p><a class="xref" href="ch04s02.html#race_underscore_config.c" title="Example 4-2. race_config.c">Example 4-2</a> presents a command-line utility designed to invoke the <code class="literal">race_ioctl</code> function in <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>:</p><div class="example"><a id="race_underscore_config.c"/><p class="title">Example 4-2. race_config.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/types.h&gt;
#include &lt;sys/ioctl.h&gt;

#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include "../race/race_ioctl.h"

static enum {UNSET, ATTACH, DETACH, QUERY, LIST} action = UNSET;


/*
 * The usage statement: race_config -a | -d unit | -q unit | -l
 */

static void
usage()
{
        /*
         * Arguments for this program are "either-or." For example,
         * 'race_config -a' or 'race_config -d unit' are valid; however,
         * 'race_config -a -d unit' is invalid.
         */

        fprintf(stderr, "usage: race_config -a | -d unit | -q unit | -l\n");
        exit(1);
}


/*
 * This program manages the doubly linked list found in /dev/race. It
 * allows you to add or remove an item, query the existence of an item,
 * or print every item on the list.
 */

int
main(int argc, char *argv[])
{
        int ch, fd, i, unit;
        char *p;

        /*
         * Parse the command line argument list to determine
         * the correct course of action.
         *
         *    -a:      add an item.
         *    -d unit: detach an item.
         *    -q unit: query the existence of an item.
         *    -l:      list every item.
         */

        while ((ch = getopt(argc, argv, "ad:q:l")) != −1)
                switch (ch) {
                case 'a':
                        if (action != UNSET)
                                usage();
                        action = ATTACH;
                        break;
                case 'd':
                        if (action != UNSET)
                                usage();
                        action = DETACH;
                        unit = (int)strtol(optarg, &amp;p, 10);
                        if (*p)
                                errx(1, "illegal unit -- %s", optarg);
                        break;
                case 'q':
                        if (action != UNSET)
                                usage();
                        action = QUERY;
                        unit = (int)strtol(optarg, &amp;p, 10);
                        if (*p)
                                errx(1, "illegal unit -- %s", optarg);
                        break;
                case 'l':
                        if (action != UNSET)
                                usage();
                        action = LIST;
                        break;
                default:
                        usage();
                }

        /*
         * Perform the chosen action.
         */

        if (action == ATTACH) {
                fd = open("/dev/" RACE_NAME, O_RDWR);
                if (fd &lt; 0)
                        err(1, "open(/dev/%s)", RACE_NAME);

                i = ioctl(fd, RACE_IOC_ATTACH, &amp;unit);
                if (i &lt; 0)
                        err(1, "ioctl(/dev/%s)", RACE_NAME);
                printf("unit: %d\n", unit);

                close (fd);
        } else if (action == DETACH) {
                fd = open("/dev/" RACE_NAME, O_RDWR);
                if (fd &lt; 0)
                        err(1, "open(/dev/%s)", RACE_NAME);

                i = ioctl(fd, RACE_IOC_DETACH, &amp;unit);
                if (i &lt; 0)
                        err(1, "ioctl(/dev/%s)", RACE_NAME);

                close (fd);
        } else if (action == QUERY) {
                fd = open("/dev/" RACE_NAME, O_RDWR);
                if (fd &lt; 0)
                        err(1, "open(/dev/%s)", RACE_NAME);

                i = ioctl(fd, RACE_IOC_QUERY, &amp;unit);
                if (i &lt; 0)
                        err(1, "ioctl(/dev/%s)", RACE_NAME);

                close (fd);
        } else if (action == LIST) {
                fd = open("/dev/" RACE_NAME, O_RDWR);
                if (fd &lt; 0)
                        err(1, "open(/dev/%s)", RACE_NAME);

                i = ioctl(fd, RACE_IOC_LIST, NULL);
                if (i &lt; 0)
                        err(1, "ioctl(/dev/%s)", RACE_NAME);

                close (fd);
        } else
                usage();

        return (0);
}</pre></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><a class="xref" href="ch04s02.html#race_underscore_config.c" title="Example 4-2. race_config.c">Example 4-2</a> is a bog-standard command-line utility. As such, I won’t cover its program structure.<a class="indexterm" id="IDX-CHP-4-0030"/></p></div><p>The following shows an example execution of <a class="xref" href="ch04s02.html#race_underscore_config.c" title="Example 4-2. race_config.c">Example 4-2</a>:</p><a id="I_programlisting4_d1e6725"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./race.ko</code></strong>
Race driver loaded.
$ <strong class="userinput"><code>sudo ./race_config -a &amp; sudo ./race_config -a &amp;</code></strong>
[1] 2378
[2] 2379
$ unit: 0
unit: 0</pre><p>Above, two threads simultaneously add a <code class="literal">race_softc</code> structure to <code class="literal">race_list</code>, which results in two <code class="literal">race_softc</code> structures with the “unique” unit number <code class="literal">0</code>—this is a problem, yes?</p><p>Here’s another example:</p><a id="I_programlisting4_d1e6749"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./race.ko</code></strong>
Race driver loaded.
$ <strong class="userinput"><code>sudo ./race_config -a &amp; sudo kldunload race.ko &amp;</code></strong>
[1] 2648
[2] 2649
$ unit: 0
Race driver unloaded.

[1]-  Done                    sudo ./race_config -a
[2]+  Done                    sudo kldunload race.ko
$ <strong class="userinput"><code>dmesg | tail -n 1</code></strong>
Warning: memory type race leaked memory on destroy (1 allocations, 16 bytes
leaked).</pre><p>Above, one thread adds a <code class="literal">race_softc</code> structure to <code class="literal">race_list</code> while another thread unloads <span class="emphasis"><em>race.ko</em></span>, which causes a memory leak. Recall that <code class="literal">MOD_QUIESCE</code> is supposed to prevent this, but it didn’t. Why?</p><p>The problem, in both examples, is a race condition. <span class="emphasis"><em>Race conditions</em></span> are errors caused by a sequence of events. In the first example, both threads check <code class="literal">race_list</code> simultaneously, discover that it is empty, and assign <code class="literal">0</code> as the unit number. In the second example, <code class="literal">MOD_QUIESCE</code> returns error-free, a <code class="literal">race_softc</code> structure is then added to <code class="literal">race_list</code>, and finally <code class="literal">MOD_UNLOAD</code> completes.<a class="indexterm" id="IDX-CHP-4-0031"/><a class="indexterm" id="IDX-CHP-4-0032"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>One characteristic of race conditions is that they’re hard to reproduce. Ergo, the results were doctored in the preceding examples. That is, I caused the threads to context switch at specific points to achieve the desired outcome. Under normal conditions, it would have taken literally millions of attempts before those race conditions would occur, and I didn’t want to spend that much time.</p></div></div></div>
<div class="sect1" title="Preventing Race Conditions"><div class="titlepage"><div><div><h1 class="title"><a id="preventing_race_conditions"/>Preventing Race Conditions</h1></div></div></div><p>Race conditions are prevented using locks. <span class="emphasis"><em>Locks</em></span>, also known as <span class="emphasis"><em>synchronization primitives</em></span>, are used to serialize the execution of two or more threads. For example, the race conditions in <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>, which are caused by concurrent access to <code class="literal">race_list</code>, can be prevented by using a lock to serialize access to <code class="literal">race_list</code>. Before a thread can access <code class="literal">race_list</code>, it must first a cquire the foo lock. Only one thread can hold foo at a time. If a thread cannot acquire <code class="literal">foo</code>, it cannot access <code class="literal">race_list</code> and must wait for the current owner to relinquish <code class="literal">foo</code>. This protocol guarantees that at any moment in time only one thread can access <code class="literal">race_list</code>, which eliminates <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>’s race conditions.<a class="indexterm" id="IDX-CHP-4-0033"/><a class="indexterm" id="IDX-CHP-4-0034"/><a class="indexterm" id="IDX-CHP-4-0035"/><a class="indexterm" id="IDX-CHP-4-0036"/></p><p>There are several different types of locks in FreeBSD, each having its own characteristics (for example, some locks can be held by more than one thread). The remainder of this chapter describes the different types of locks available in FreeBSD and how to use them.</p></div>
<div class="sect1" title="Mutexes"><div class="titlepage"><div><div><h1 class="title"><a id="mutexes"/>Mutexes</h1></div></div></div><p><span class="emphasis"><em>Mutex locks (mutexes)</em></span> ensure that at any moment in time, only one thread can access a shared object. Mutex is an amalgamation of mutual and exclusion.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">foo</code> lock described in the previous section was a mutex lock.</p></div><p>FreeBSD provides two types of mutex locks: spin mutexes and sleep mutexes.<a class="indexterm" id="IDX-CHP-4-0037"/><a class="indexterm" id="IDX-CHP-4-0038"/><a class="indexterm" id="IDX-CHP-4-0039"/></p><div class="sect2" title="Spin Mutexes"><div class="titlepage"><div><div><h2 class="title"><a id="spin_mutexes"/>Spin Mutexes</h2></div></div></div><p><span class="emphasis"><em>Spin mutexes</em></span> are simple spin locks. If a thread attempts to acquire a spin lock that is being held by another thread, it will “spin” and wait for the lock to be released. <span class="emphasis"><em>Spin</em></span>, in this case, means to loop infinitely on the CPU. This spinning can result in deadlock if a thread that is holding a spin lock is interrupted or if it context switches, and all subsequent threads attempt to acquire that lock. Consequently, while holding a spin mutex all interrupts are blocked on the local processor and a context switch cannot be performed.</p><p>Spin mutexes should be held only for short periods of time and should be used only to protect objects related to nonpreemptive interrupts and low-level scheduling code (McKusick and Neville-Neil, 2005). Ordinarily, you’ll never use spin mutexes.<a class="indexterm" id="IDX-CHP-4-0040"/><a class="indexterm" id="IDX-CHP-4-0041"/><a class="indexterm" id="IDX-CHP-4-0042"/><a class="indexterm" id="IDX-CHP-4-0043"/><a class="indexterm" id="IDX-CHP-4-0044"/><a class="indexterm" id="IDX-CHP-4-0045"/></p></div><div class="sect2" title="Sleep Mutexes"><div class="titlepage"><div><div><h2 class="title"><a id="sleep_mutexes"/>Sleep Mutexes</h2></div></div></div><p><span class="emphasis"><em>Sleep mutexes</em></span> are the most commonly used lock. If a thread attempts to acquire a sleep mutex that is being held by another thread, it will context switch (that is, sleep) and wait for the mutex to be released. Because of this behavior, sleep mutexes are not susceptible to the deadlock described above.<a class="indexterm" id="IDX-CHP-4-0046"/><a class="indexterm" id="IDX-CHP-4-0047"/><a class="indexterm" id="IDX-CHP-4-0048"/></p><p>Sleep mutexes support priority propagation. When a thread sleeps on a sleep mutex and its priority is higher than the sleep mutex’s current owner, the current owner will inherit the priority of this thread (Baldwin, 2002). This characteristic prevents a lower priority thread from blocking a higher priority thread.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Sleeping (for example, calling a <code class="literal">*sleep</code> function, which is discussed in <a class="xref" href="ch05.html" title="Chapter 5. Delaying Execution">Chapter 5</a>) while holding a mutex is never safe and must be avoided; otherwise, there are numerous assertions that will fail and the kernel will panic (McKusick and Neville-Neil, 2005).<a class="indexterm" id="IDX-CHP-4-0049"/></p></div></div></div>
<div class="sect1" title="Mutex Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="mutex_management_routines"/>Mutex Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following seven functions for working with mutexes:</p><a id="I_programlisting4_d1e6972"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/mutex.h&gt;

void
mtx_init(struct mtx <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>mutex, const char <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>name, const char <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>type,
    int <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>opts);

void
mtx_lock(struct mtx <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>mutex);

void
mtx_lock_spin(struct mtx <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>mutex);

int
mtx_trylock(struct mtx <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>mutex);

void
mtx_unlock(struct mtx mutex);

void
mtx_unlock_spin(struct mtx <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>mutex);

void
mtx_destroy(struct mtx <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>*mutex);</pre><p>The <code class="literal">mtx_init</code> function initializes the mutex <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7034"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">mutex</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7043"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">name</code> argument is used during debugging to identify <code class="literal">mutex</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7056"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">type</code> argument is used during lock-order verification by <code class="literal">witness(4)</code>. If <code class="literal">type</code> is <code class="literal">NULL</code>, <code class="literal">name</code> is used instead.<a class="indexterm" id="IDX-CHP-4-0050"/><a class="indexterm" id="IDX-CHP-4-0051"/><a class="indexterm" id="IDX-CHP-4-0052"/><a class="indexterm" id="IDX-CHP-4-0053"/><a class="indexterm" id="IDX-CHP-4-0054"/><a class="indexterm" id="IDX-CHP-4-0055"/><a class="indexterm" id="IDX-CHP-4-0056"/><a class="indexterm" id="IDX-CHP-4-0057"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>You’ll typically pass <code class="literal">NULL</code> as <code class="literal">type</code>.</p></div><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7113"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">opts</code> argument modifies <code class="literal">mtx_init</code>’s behavior. Valid values for <code class="literal">opts</code> are shown in <a class="xref" href="ch04s05.html#mtx_underscore_init_symbolic_constants" title="Table 4-1. mtx_init Symbolic Constants">Table 4-1</a>.</p><div class="table"><a id="mtx_underscore_init_symbolic_constants"/><p class="title">Table 4-1. mtx_init Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="mtx_init Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">MTX_DEF</code></p></td><td style="text-align: left" valign="top"><p>Initializes <code class="literal">mutex</code> as a sleep mutex; this bit or <code class="literal">MTX_SPIN</code> must be present</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MTX_SPIN</code></p></td><td style="text-align: left" valign="top"><p>Initializes <code class="literal">mutex</code> as a spin mutex; this bit or <code class="literal">MTX_DEF</code> must be present</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MTX_RECURSE</code></p></td><td style="text-align: left" valign="top"><p>Specifies that <code class="literal">mutex</code> is a recursive lock; more on recursive locks later</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MTX_QUIET</code></p></td><td style="text-align: left" valign="top"><p>Instructs the system to <span class="emphasis"><em>not</em></span> log the operations done on this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MTX_NOWITNESS</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">witness(4)</code> to ignore this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MTX_DUPOK</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">witness(4)</code> to ignore duplicates of this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">MTX_NOPROFILE</code></p></td><td style="text-align: left" valign="top"><p>Instructs the system to <span class="emphasis"><em>not</em></span> profile this lock</p></td></tr></tbody></table></div></div><p>Threads acquire sleep mutexes by calling <code class="literal">mtx_lock</code>. If another thread is currently holding <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7233"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">mutex</code>, the caller will sleep until <code class="literal">mutex</code> is available.</p><p>Threads acquire spin mutexes by calling <code class="literal">mtx_lock_spin</code>. If another thread is currently holding <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7250"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">mutex</code>, the caller will spin until <code class="literal">mutex</code> is available. Note that all interrupts are blocked on the local processor during the spin, and they remain disabled following the acquisition of <code class="literal">mutex</code>.</p><p>A thread can recursively acquire <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7267"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">mutex</code> (with no ill effects) if <code class="literal">MTX_RECURSE</code> was passed to <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7279"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">opts</code>. A recursive lock is useful if it’ll be acquired at two or more levels. For example:</p><a id="I_programlisting4_d1e7288"/><pre class="programlisting">static void
foo()
{
...
        mtx_lock(&amp;mutex);
...
        foo();
...
        mtx_unlock(&amp;mutex);
...
}</pre><p>By using a recursive lock, lower levels don’t need to check if <code class="literal">mutex</code> has been acquired by a higher level. They can simply acquire and release mutex as needed (McKusick and Neville-Neil, 2005).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>I would avoid recursive mutexes. You’ll learn why in <a class="xref" href="ch04s14.html#avoid_recursing_on_exclusive_locks" title="Avoid Recursing on Exclusive Locks">Avoid Recursing on Exclusive Locks</a> in <a class="xref" href="ch02.html#memory_management_routines" title="Memory Management Routines">Memory Management Routines</a><a class="indexterm" id="IDX-CHP-4-0058"/><a class="indexterm" id="IDX-CHP-4-0059"/><a class="indexterm" id="IDX-CHP-4-0060"/></p></div><p>The <code class="literal">mtx_trylock</code> function is identical to <code class="literal">mtx_lock</code> except that if another thread is currently holding <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7319"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">mutex</code>, it returns <code class="literal">0</code> (that is, the caller does not sleep).</p><p>Threads release sleep mutexes by calling <code class="literal">mtx_unlock</code>. Note that recursive locks “remember” the number of times they’ve been acquired. Consequently, each successful lock acquisition must have a corresponding lock release.</p><p>Threads release spin mutexes by calling <code class="literal">mtx_unlock_spin</code>. The <code class="literal">mtx_unlock_spin</code> function also restores the interrupt state to what it was before <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7344"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">mutex</code> was acquired.</p><p>The <code class="literal">mtx_destroy</code> function destroys the mutex <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7358"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">mutex</code>. Note that <code class="literal">mutex</code> can be held when it is destroyed. However, mutex cannot be held recursively orhave other threads waiting for it when it is destroyed or else the kernel will panic (McKusick and Neville-Neil, 2005).</p></div>
<div class="sect1" title="Implementing Mutexes"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_mutexes"/>Implementing Mutexes</h1></div></div></div><p><a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a> is a revision of <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a> that uses a mutex to serialize access to <code class="literal">race_list</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To save space, the functions <code class="literal">race_ioctl</code>, <code class="literal">race_new</code>, <code class="literal">race_find</code>, and <code class="literal">race_destroy</code> aren’t listed here, as they haven’t been changed.</p></div><div class="example"><a id="race_underscore_mtx.c"/><p class="title">Example 4-3. race_mtx.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/conf.h&gt;
  #include &lt;sys/uio.h&gt;
  #include &lt;sys/malloc.h&gt;
  #include &lt;sys/ioccom.h&gt;
  #include &lt;sys/queue.h&gt;
  #include &lt;sys/lock.h&gt;
  #include &lt;sys/mutex.h&gt;
  #include "race_ioctl.h"

  MALLOC_DEFINE(M_RACE, "race", "race object");

  struct race_softc {
          LIST_ENTRY(race_softc) list;
          int unit;
  };

  static LIST_HEAD(, race_softc) race_list = LIST_HEAD_INITIALIZER(&amp;race_list);
<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> static struct mtx race_mtx;

  static struct race_softc *      race_new(void);
  static struct race_softc *      race_find(int unit);
  static void                     race_destroy(struct race_softc *sc);
  static d_ioctl_t                race_ioctl_mtx;
  static d_ioctl_t                race_ioctl;

  static struct cdevsw race_cdevsw = {
          .d_version =    D_VERSION,
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>.d_ioctl =      race_ioctl_mtx,
          .d_name =       RACE_NAME
  };

  static struct cdev *race_dev;

  static int
<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/> race_ioctl_mtx(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
      struct thread *td)
  {
          int error;

        <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>mtx_lock(&amp;race_mtx);
          error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>race_ioctl(dev, cmd, data, fflag, td);
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>mtx_unlock(&amp;race_mtx);

          return (error);
  }

  static int
  race_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
      struct thread *td)
  {
  ...
  }

  static struct race_softc *
  race_new(void)
  {
  ...
  }

  static struct race_softc *
  race_find(int unit)
  {
  ...
  }

  static void
  race_destroy(struct race_softc *sc)
  {
  ...
  }

  static int
  race_modevent(module_t mod __unused, int event, void *arg __unused)
  {
          int error = 0;
          struct race_softc *sc, *sc_temp;

          switch (event) {
          case MOD_LOAD:
                  mtx_init(&amp;race_mtx, "race config lock", NULL, <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>MTX_DEF);
                  race_dev = make_dev(&amp;race_cdevsw, 0, UID_ROOT, GID_WHEEL,
                      0600, RACE_NAME);
                  uprintf("Race driver loaded.\n");
                  break;
          case MOD_UNLOAD:
                  destroy_dev(race_dev);
                  mtx_lock(&amp;race_mtx);
                  if (!LIST_EMPTY(&amp;race_list)) {
                          LIST_FOREACH_SAFE(sc, &amp;race_list, list, sc_temp) {
                                  LIST_REMOVE(sc, list);
                                  free(sc, M_RACE);
                          }
                  }

                  mtx_unlock(&amp;race_mtx);
                  mtx_destroy(&amp;race_mtx);
                  uprintf("Race driver unloaded.\n");
                  break;
          case MOD_QUIESCE:
                  mtx_lock(&amp;race_mtx);
                  if (!LIST_EMPTY(&amp;race_list))
                          error = EBUSY;
                  mtx_unlock(&amp;race_mtx);
                  break;
          default:
                  error = EOPNOTSUPP;
                  break;
          }

          return (error);
  }

  DEV_MODULE(race, race_modevent, NULL);</pre></div></div><p>This driver <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7446"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> declares a mutex named <code class="literal">race_mtx</code>, which gets initialized as a <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7455"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> sleep mutex in the module event handler.<a class="indexterm" id="IDX-CHP-4-0061"/><a class="indexterm" id="IDX-CHP-4-0062"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>As you’ll see, a mutex is not the ideal solution for <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>. However, for now, I just want to cover how to use mutexes.</p></div><p>In <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a>, the main source of concurrent access to <code class="literal">race_list</code> is the <code class="literal">race_ioctl</code> function. This should be obvious, because <code class="literal">race_ioctl</code> manages <code class="literal">race_list</code>.</p><p><a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a> remedies the race conditions caused by <code class="literal">race_ioctl by</code> serializing its execution via the <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7494"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">race_ioctl_mtx</code> function. <code class="literal">race_ioctl_mtx</code> is defined as the <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7506"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">d_ioctl</code> function. It begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7516"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> acquiring <code class="literal">race_mtx</code>. Then <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7525"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">race_ioctl</code> is called and subsequently <code class="literal">race_mtx</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7538"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> released.</p><p>As you can see, it takes just three lines (or one mutex) to serialize the execution of <code class="literal">race_ioctl</code>.<a class="indexterm" id="IDX-CHP-4-0063"/><a class="indexterm" id="IDX-CHP-4-0064"/><a class="indexterm" id="IDX-CHP-4-0065"/></p><div class="sect2" title="race_modevent Function"><div class="titlepage"><div><div><h2 class="title"><a id="race_underscore_modevent_function-id1"/>race_modevent Function</h2></div></div></div><p>The <code class="literal">race_modevent</code> function is the module event handler for <a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a>. Here is its function definition (again):</p><a id="I_programlisting4_d1e7574"/><pre class="programlisting">static int
race_modevent(module_t mod __unused, int event, void *arg __unused)
{
        int error = 0;
        struct race_softc *sc, *sc_temp;

        switch (event) {
        case MOD_LOAD:
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>mtx_init(&amp;race_mtx, "race config lock", NULL, <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>MTX_DEF);
                race_dev = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>make_dev(&amp;race_cdevsw, 0, UID_ROOT, GID_WHEEL,
                    0600, RACE_NAME);
                uprintf("Race driver loaded.\n");
                break;
        case MOD_UNLOAD:
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>destroy_dev(race_dev);
                mtx_lock(&amp;race_mtx);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>if (!LIST_EMPTY(&amp;race_list)) {
                        LIST_FOREACH_SAFE(sc, &amp;race_list, list, sc_temp) {
                                LIST_REMOVE(sc, list);
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>free(sc, M_RACE);
                        }
                }
                mtx_unlock(&amp;race_mtx);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>mtx_destroy(&amp;race_mtx);
                uprintf("Race driver unloaded.\n");
                break;
        case MOD_QUIESCE:
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>mtx_lock(&amp;race_mtx);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>if (!LIST_EMPTY(&amp;race_list))
                        error = EBUSY;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>mtx_unlock(&amp;race_mtx);
                break;
        default:
                error = EOPNOTSUPP;
                break;
        }

        return (error);
}</pre><p>On module load, this function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7639"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> initializes <code class="literal">race_mtx</code> as a <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7648"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> sleep mutex. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7654"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> creates <a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a>’s device node: <code class="literal">race</code>.</p><p>On <code class="literal">MOD_QUIESCE</code>, this function <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7671"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> acquires <code class="literal">race_mtx</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7680"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> confirms that <code class="literal">race_list</code> is empty, and then <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7690"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> releases <code class="literal">race_mtx</code>.</p><p>On module unload, this function first calls <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7701"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">destroy_dev</code> to destroy the <code class="literal">race</code> device node.<a class="indexterm" id="IDX-CHP-4-0066"/><a class="indexterm" id="IDX-CHP-4-0067"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">destroy_dev</code> function does not return until every <code class="literal">d_foo</code> function currently executing completes. Consequently, one should not hold a lock while calling <code class="literal">destroy_dev</code>; otherwise, you could deadlock your driver or panic your system.</p></div><p>Next, <code class="literal">race_modevent</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7736"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> confirms that <code class="literal">race_list</code> is still empty. See, after the execution of <code class="literal">MOD_QUIESCE</code>, a <code class="literal">race_softc</code> structure could have been added to <code class="literal">race_list</code>. So, <code class="literal">race_list</code> is checked again and every <code class="literal">race_softc</code> structure found is <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7761"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> released. Once this is done, <code class="literal">race_mtx</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7770"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> destroyed.</p><p>As you can see, every time <code class="literal">race_list</code> was accessed, <code class="literal">mtx_lock(&amp;race_mtx)</code> was called first. This was necessary in order to serialize access to <code class="literal">race_list</code> throughout <a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a>.</p></div><div class="sect2" title="Don’t Panic"><div class="titlepage"><div><div><h2 class="title"><a id="donat_panic-id3"/>Don’t Panic</h2></div></div></div><p>Now that we’ve examined <a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a>, let’s give it a try:</p><a id="I_programlisting4_d1e7796"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./race_mtx.ko</code></strong>
Race driver loaded.
$ <strong class="userinput"><code>sudo ./race_config -a &amp; sudo ./race_config -a &amp;</code></strong>
[1] 923
[2] 924
$ unit: 0
unit: 1

...

$ <strong class="userinput"><code>sudo kldload ./race_mtx.ko</code></strong>
Race driver loaded.
$ <strong class="userinput"><code>sudo ./race_config -a &amp; sudo kldunload race_mtx.ko &amp;</code></strong>
[1] 933
[2] 934
$ Race driver unloaded.
race_config: open(/dev/race): No such file or directory

[1]-  Exit 1                  sudo ./race_config -a
[2]+  Done                    sudo kldunload race_mtx.ko</pre><p>Unsurprisingly, it works. Yet using a mutex has introduced a new problem. See, the function definition for <code class="literal">race_new</code> contains this line:</p><a id="I_programlisting4_d1e7815"/><pre class="programlisting">sc = (struct race_softc *)malloc(sizeof(struct race_softc), M_RACE,
           <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>M_WAITOK | M_ZERO);</pre><p>Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7825"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">M_WAITOK</code> means that it’s okay to sleep. But it’s <span class="emphasis"><em>never</em></span> okay to sleep while holding a mutex. Recall that sleeping while holding a mutex causes the kernel to panic.</p><p>There are two solutions to this problem: First, change <code class="literal">M_WAITOK</code> to <code class="literal">M_NOWAIT</code>. Second, use a lock that can be held while sleeping. As the first solution changes the functionality of <a class="xref" href="ch04s02.html#race.c" title="Example 4-1. race.c">Example 4-1</a> (that is, currently, <code class="literal">race_new</code> never fails), let’s go with the second.<a class="indexterm" id="IDX-CHP-4-0068"/><a class="indexterm" id="IDX-CHP-4-0069"/><a class="indexterm" id="IDX-CHP-4-0070"/><a class="indexterm" id="IDX-CHP-4-0071"/><a class="indexterm" id="IDX-CHP-4-0072"/><a class="indexterm" id="IDX-CHP-4-0073"/></p></div></div>
<div class="sect1" title="Shared/Exclusive Locks"><div class="titlepage"><div><div><h1 class="title"><a id="shared_solidus_exclusive_locks"/>Shared/Exclusive Locks</h1></div></div></div><p><span class="emphasis"><em>Shared/exclusive locks (sx locks)</em></span> are locks that threads can hold while asleep. As the name implies, multiple threads can have a <span class="emphasis"><em>shared hold</em></span> on an sx lock, but only one thread can have an <span class="emphasis"><em>exclusive hold</em></span> on an sx lock. When a thread has an exclusive hold on an sx lock, other threads cannot have a shared hold on that lock.</p><p>sx locks do not support priority propagation and are inefficient compared to mutexes. The main reason for using sx locks is that threads can sleep while holding one.</p></div>
<div class="sect1" title="Shared/Exclusive Lock Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="shared_solidus_exclusive_lock_management"/>Shared/Exclusive Lock Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following 14 functions for working with sx locks:</p><a id="I_programlisting4_d1e7898"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/sx.h&gt;

void
sx_init(struct sx <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>sx, const char <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>description);

void
sx_init_flags(struct sx sx, const char description, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>opts);

void
sx_slock(struct sx sx);

void
sx_xlock(struct sx sx);

int
sx_slock_sig(struct sx sx);

int
sx_xlock_sig(struct sx sx);

int
sx_try_slock(struct sx sx);

int
sx_try_xlock(struct sx sx);

void
sx_sunlock(struct sx sx);

void
sx_xunlock(struct sx sx);

void
sx_unlock(struct sx sx);

int
sx_try_upgrade(struct sx sx);

void
sx_downgrade(struct sx sx);

void
sx_destroy(struct sx <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>sx);</pre><p>The <code class="literal">sx_init</code> function initializes the sx lock <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7929"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">sx</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7938"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">description</code> argument is used during debugging to identify <code class="literal">sx</code>.<a class="indexterm" id="IDX-CHP-4-0074"/><a class="indexterm" id="IDX-CHP-4-0075"/><a class="indexterm" id="IDX-CHP-4-0076"/><a class="indexterm" id="IDX-CHP-4-0077"/><a class="indexterm" id="IDX-CHP-4-0078"/><a class="indexterm" id="IDX-CHP-4-0079"/><a class="indexterm" id="IDX-CHP-4-0080"/><a class="indexterm" id="IDX-CHP-4-0081"/><a class="indexterm" id="IDX-CHP-4-0082"/><a class="indexterm" id="IDX-CHP-4-0083"/><a class="indexterm" id="IDX-CHP-4-0084"/></p><p>The <code class="literal">sx_init_flags</code> function is an alternative to <code class="literal">sx_init</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e7993"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> opts argument modifies <code class="literal">sx_init_flags</code>’s behavior. Valid values for <code class="literal">opts</code> are shown in <a class="xref" href="ch04s08.html#sx_underscore_init_underscore_flags_symb" title="Table 4-2. sx_init_flags Symbolic Constants">Table 4-2</a>.</p><div class="table"><a id="sx_underscore_init_underscore_flags_symb"/><p class="title">Table 4-2. sx_init_flags Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="sx_init_flags Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">SX_NOADAPTIVE</code></p></td><td style="text-align: left" valign="top"><p>If this bit is passed and the kernel is compiled without options <code class="literal">NO_ADAPTIVE_SX</code>, then threads holding <code class="literal">sx</code> will spin instead of sleeping.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SX_RECURSE</code></p></td><td style="text-align: left" valign="top"><p>Specifies that <code class="literal">sx</code> is a recursive lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SX_QUIET</code></p></td><td style="text-align: left" valign="top"><p>Instructs the system to <span class="emphasis"><em>not</em></span> log the operations done on this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SX_NOWITNESS</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">witness(4)</code> to ignore this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SX_DUPOK</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">witness(4)</code> to ignore duplicates of this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">SX_NOPROFILE</code></p></td><td style="text-align: left" valign="top"><p>Instructs the system to <span class="emphasis"><em>not</em></span> profile this lock</p></td></tr></tbody></table></div></div><p>Threads acquire a shared hold on <code class="literal">sx</code> by calling <code class="literal">sx_slock</code>. If another thread currently has an exclusive hold on <code class="literal">sx</code>, the caller will sleep until <code class="literal">sx</code> is available.</p><p>Threads acquire an exclusive hold on <code class="literal">sx</code> by calling <code class="literal">sx_xlock</code>. If any threads currently have a shared or exclusive hold on <code class="literal">sx</code>, the caller will sleep until <code class="literal">sx</code> is available.</p><p>The <code class="literal">sx_slock_sig</code> and <code class="literal">sx_xlock_sig</code> functions are identical to <code class="literal">sx_slock</code> and <code class="literal">sx_xlock</code> except that when the caller sleeps it can be woken up by signals. If this occurs, a nonzero value is returned.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Normally, threads sleeping on locks cannot be woken up early.</p></div><p>The <code class="literal">sx_try_slock</code> and <code class="literal">sx_try_xlock</code> functions are identical to <code class="literal">sx_slock</code> and <code class="literal">sx_xlock</code> except that if <code class="literal">sx</code> cannot be acquired, they return <code class="literal">0</code> (that is, the caller does not sleep).</p><p>Threads release a shared hold on <code class="literal">sx</code> by calling <code class="literal">sx_sunlock</code>, and they release an exclusive hold by calling <code class="literal">sx_xunlock</code>.</p><p>The <code class="literal">sx_unlock</code> function is a front end to <code class="literal">sx_sunlock</code> and <code class="literal">sx_xunlock</code>. This function is used when the hold state on <code class="literal">sx</code> is unknown.<a class="indexterm" id="IDX-CHP-4-0085"/><a class="indexterm" id="IDX-CHP-4-0086"/><a class="indexterm" id="IDX-CHP-4-0087"/><a class="indexterm" id="IDX-CHP-4-0088"/></p><p>Threads can upgrade a shared hold to an exclusive hold by calling <code class="literal">sx_try_upgrade</code>. If the hold cannot be immediately upgraded, 0 is returned. Threads can downgrade an exclusive hold to a shared hold by calling <code class="literal">sx_downgrade</code>.</p><p>The <code class="literal">sx_destroy</code> function destroys the sx lock <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8216"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">sx</code>. Note that <code class="literal">sx</code> cannot be held when it is destroyed.</p></div>
<div class="sect1" title="Implementing Shared/Exclusive Locks"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_shared_solidus_exclusive_lo"/>Implementing Shared/Exclusive Locks</h1></div></div></div><p><a class="xref" href="ch04s09.html#race_underscore_sx.c" title="Example 4-4. race_sx.c">Example 4-4</a> is a revision of <a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a> that uses an sx lock instead of a mutex.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To save space, the functions <code class="literal">race_ioctl</code>, <code class="literal">race_new</code>, <code class="literal">race_find</code>, and <code class="literal">race_destroy</code> aren’t listed here, as they haven’t been changed.</p></div><div class="example"><a id="race_underscore_sx.c"/><p class="title">Example 4-4. race_sx.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/conf.h&gt;
  #include &lt;sys/uio.h&gt;
  #include &lt;sys/malloc.h&gt;
  #include &lt;sys/ioccom.h&gt;
  #include &lt;sys/queue.h&gt;
  #include &lt;sys/lock.h&gt;
<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> #include &lt;sys/sx.h&gt;
  #include "race_ioctl.h"

  MALLOC_DEFINE(M_RACE, "race", "race object");

  struct race_softc {
          LIST_ENTRY(race_softc) list;
          int unit;
  };

  static LIST_HEAD(, race_softc) race_list = LIST_HEAD_INITIALIZER(&amp;race_list);
<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/> static struct sx race_sx;

  static struct race_softc *      race_new(void);
  static struct race_softc *      race_find(int unit);
  static void                     race_destroy(struct race_softc *sc);
  static d_ioctl_t                race_ioctl_sx;
  static d_ioctl_t                race_ioctl;

  static struct cdevsw race_cdevsw = {
          .d_version =    D_VERSION,
          .d_ioctl =      race_ioctl_sx,
          .d_name =       RACE_NAME
  };

    static struct cdev *race_dev;

  static int
  race_ioctl_sx(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
      struct thread *td)
  {
          int error;

        <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sx_xlock(&amp;race_sx);
          error = race_ioctl(dev, cmd, data, fflag, td);
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>sx_xunlock(&amp;race_sx);

          return (error);
  }

  static int
  race_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
      struct thread *td)
  {
  ...
  }

  static struct race_softc *
  race_new(void)
  {
  ...
  }

  static struct race_softc *
  race_find(int unit)
  {
  ...
  }

  static void
  race_destroy(struct race_softc *sc)
  {
  ...
  }

  static int
  race_modevent(module_t mod __unused, int event, void *arg __unused)
  {
          int error = 0;
          struct race_softc *sc, *sc_temp;

          switch (event) {
          case MOD_LOAD:
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>sx_init(&amp;race_sx, "race config lock");
                  race_dev = make_dev(&amp;race_cdevsw, 0, UID_ROOT, GID_WHEEL,
                      0600, RACE_NAME);
                  uprintf("Race driver loaded.\n");
                  break;
            case MOD_UNLOAD:
                  destroy_dev(race_dev);
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>sx_xlock(&amp;race_sx);
                  if (!LIST_EMPTY(&amp;race_list)) {
                          LIST_FOREACH_SAFE(sc, &amp;race_list, list, sc_temp) {
                                  LIST_REMOVE(sc, list);
                                  free(sc, M_RACE);
                          }
                  }

                <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>sx_xunlock(&amp;race_sx);
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>sx_destroy(&amp;race_sx);
                  uprintf("Race driver unloaded.\n");
                  break;
          case MOD_QUIESCE:
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>sx_xlock(&amp;race_sx);
                  if (!LIST_EMPTY(&amp;race_list))
                          error = EBUSY;
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>sx_xunlock(&amp;race_sx);
                  break;
          default:
                  error = EOPNOTSUPP;
                  break;
          }

          return (error);
  }

  DEV_MODULE(race, race_modevent, NULL);</pre></div></div><p><a class="xref" href="ch04s09.html#race_underscore_sx.c" title="Example 4-4. race_sx.c">Example 4-4</a> is identical to <a class="xref" href="ch04s06.html#race_underscore_mtx.c" title="Example 4-3. race_mtx.c">Example 4-3</a> except that every mutex management function has been replaced by its sx lock equivalent.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The numbered balls in <a class="xref" href="ch04s09.html#race_underscore_sx.c" title="Example 4-4. race_sx.c">Example 4-4</a> highlight the differences.</p></div><p>Here are the results from interacting with <a class="xref" href="ch04s09.html#race_underscore_sx.c" title="Example 4-4. race_sx.c">Example 4-4</a>:</p><a id="I_programlisting4_d1e8331"/><pre class="programlisting">$ <strong class="userinput"><code>sudo kldload ./race_sx.ko</code></strong>
Race driver loaded.
$ <strong class="userinput"><code>sudo ./race_config -a &amp; sudo ./race_config -a &amp;</code></strong>
[1] 800
[2] 801
$ unit: 0
unit: 1

...

$ <strong class="userinput"><code>sudo kldload ./race_sx.ko</code></strong>
Race driver loaded.
$ <strong class="userinput"><code>sudo ./race_config -a &amp; sudo kldunload race_sx.ko &amp;</code></strong>
[1] 811
[2] 812
$ unit: 0
kldunload: can't unload file: Device busy

[1]-  Done                    sudo ./race_config -a
[2]+  Exit 1                  sudo kldunload race_sx.ko</pre><p>Naturally, everything works, and no new problems were introduced.<a class="indexterm" id="IDX-CHP-4-0089"/><a class="indexterm" id="IDX-CHP-4-0090"/><a class="indexterm" id="IDX-CHP-4-0091"/><a class="indexterm" id="IDX-CHP-4-0092"/><a class="indexterm" id="IDX-CHP-4-0093"/></p></div>
<div class="sect1" title="Reader/Writer Locks"><div class="titlepage"><div><div><h1 class="title"><a id="reader_solidus_writer_locks"/>Reader/Writer Locks</h1></div></div></div><p><span class="emphasis"><em>Reader/writer locks (rw locks)</em></span> are basically mutexes with sx lock semantics. Like sx locks, threads can hold rw locks as a <span class="emphasis"><em>reader</em></span>, which is identical to a shared hold, or as a <span class="emphasis"><em>writer</em></span>, which is identical to an exclusive hold. Like mutexes, rw locks support priority propagation and threads cannot hold them while sleeping (or the kernel will panic).</p><p>rw locks are used when you need to protect an object that is mostly going to be read from instead of written to.</p></div>
<div class="sect1" title="Reader/Writer Lock Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="reader_solidus_writer_lock_management_ro"/>Reader/Writer Lock Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following 11 functions for working with rw locks:</p><a id="I_programlisting4_d1e8386"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/rwlock.h&gt;

void
rw_init(struct rwlock <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*rw, const char <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*name);

void
rw_init_flags(struct rwlock *rw, const char *name, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>opts);

void
rw_rlock(struct rwlock *rw);

void
rw_wlock(struct rwlock *rw);

int
rw_try_rlock(struct rwlock *rw);

int
rw_try_wlock(struct rwlock *rw);

void
rw_runlock(struct rwlock *rw);

void
rw_wunlock(struct rwlock *rw);

int
rw_try_upgrade(struct rwlock *rw);

void
rw_downgrade(struct rwlock *rw);

void
rw_destroy(struct rwlock <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>*rw);</pre><p>The <code class="literal">rw_init</code> function initializes the rw lock <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8417"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">rw</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8426"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">name</code> argument is used during debugging to identify <code class="literal">rw</code>.<a class="indexterm" id="IDX-CHP-4-0094"/><a class="indexterm" id="IDX-CHP-4-0095"/><a class="indexterm" id="IDX-CHP-4-0096"/><a class="indexterm" id="IDX-CHP-4-0097"/><a class="indexterm" id="IDX-CHP-4-0098"/><a class="indexterm" id="IDX-CHP-4-0099"/><a class="indexterm" id="IDX-CHP-4-0100"/></p><p>The <code class="literal">rw_init_flags</code> function is an alternative to <code class="literal">rw_init</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8468"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">opts</code> argument modifies <code class="literal">rw_init_flags</code>’s behavior. Valid values for <code class="literal">opts</code> are shown in <a class="xref" href="ch04s11.html#rw_underscore_init_underscore_flags_symb" title="Table 4-3. rw_init_flags Symbolic Constants">Table 4-3</a>.</p><div class="table"><a id="rw_underscore_init_underscore_flags_symb"/><p class="title">Table 4-3. rw_init_flags Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="rw_init_flags Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">RW_RECURSE</code></p></td><td style="text-align: left" valign="top"><p>Specifies that <code class="literal">rw</code> is a recursive lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RW_QUIET</code></p></td><td style="text-align: left" valign="top"><p>Instructs the system to <span class="emphasis"><em>not</em></span> log the operations done on this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RW_NOWITNESS</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">witness(4)</code> to ignore this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RW_DUPOK</code></p></td><td style="text-align: left" valign="top"><p>Causes <code class="literal">witness(4)</code> to ignore duplicates of this lock</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">RW_NOPROFILE</code></p></td><td style="text-align: left" valign="top"><p>Instructs the system to <span class="emphasis"><em>not</em></span> profile this lock</p></td></tr></tbody></table></div></div><p>Threads acquire a shared hold on <code class="literal">rw</code> by calling <code class="literal">rw_rlock</code>. If another thread currently has an exclusive hold on <code class="literal">rw</code>, the caller will sleep until <code class="literal">rw</code> is available.</p><p>Threads acquire an exclusive hold on <code class="literal">rw</code> by calling <code class="literal">rw_wlock</code>. If any threads currently have a shared or exclusive hold on <code class="literal">rw</code>, the caller will sleep until <code class="literal">rw</code> is available.</p><p>The <code class="literal">rw_try_rlock</code> and <code class="literal">rw_try_wlock</code> functions are identical to <code class="literal">rw_rlock</code> and <code class="literal">rw_wlock</code> except that if <code class="literal">rw</code> cannot be acquired, they return <code class="literal">0</code> (that is, the caller does not sleep).</p><p>Threads release a shared hold on <code class="literal">rw</code> by calling <code class="literal">rw_runlock</code>, and they release an exclusive hold by calling <code class="literal">rw_wunlock</code>.</p><p>Threads can upgrade a shared hold to an exclusive hold by calling <code class="literal">rw_try_upgrade</code>. If the hold cannot be immediately upgraded, <code class="literal">0</code> is returned. Threads can downgrade an exclusive hold to a shared hold by calling <code class="literal">rw_downgrade</code>.</p><p>The <code class="literal">rw_destroy</code> function destroys the <code class="literal">rw</code> lock <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8636"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">rw</code>. Note that <code class="literal">rw</code> cannot be held when it is destroyed.</p><p>At this point, you should be comfortable with locks—there’s really nothing to them. So, I’m going to omit discussing an example that uses rw locks.</p></div>
<div class="sect1" title="Condition Variables"><div class="titlepage"><div><div><h1 class="title"><a id="condition_variables"/>Condition Variables</h1></div></div></div><p><span class="emphasis"><em>Condition variables</em></span> synchronize the execution of two or more threads based upon the value of an object. In contrast, locks synchronize threads by controlling their access to objects.<a class="indexterm" id="IDX-CHP-4-0101"/></p><p>Condition variables are used in conjunction with locks to “block” threads until a condition is true. It works like this: A thread first acquires the <code class="literal">foo</code> lock. Then it examines the condition. If the condition is false, it sleeps on the <code class="literal">bar</code> condition variable. While asleep on <code class="literal">bar</code>, threads relinquish <code class="literal">foo</code>. A thread that causes the condition to be true wakes up the threads sleeping on bar. Threads woken up in this manner reacquire <code class="literal">foo</code> before proceeding.<a class="indexterm" id="IDX-CHP-4-0102"/><a class="indexterm" id="IDX-CHP-4-0103"/></p></div>
<div class="sect1" title="Condition Variable Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="condition_variable_management_routines"/>Condition Variable Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following 11 functions for working with condition variables:</p><a id="I_programlisting4_d1e8691"/><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/condvar.h&gt;

void
cv_init(struct cv <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*cvp, const char <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*d);

const char *
cv_wmesg(struct cv <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>*cvp);

void
cv_wait(struct cv <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>*cvp, <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>lock);

void
cv_wait_unlock(struct cv <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>*cvp, <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>lock);

int
cv_wait_sig(struct cv *cvp, lock);

int
cv_timedwait(struct cv *cvp, lock, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>timo);

int
cv_timedwait_sig(struct cv *cvp, lock, int timo);

void
cv_signal(struct cv *cvp);

void
cv_broadcast(struct cv *cvp);

void
cv_broadcastpri(struct cv *cvp, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>pri);

void
cv_destroy(struct cv <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>*cvp);</pre><p>The <code class="literal">cv_init</code> function initializes the condition variable <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8759"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">cvp</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8768"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">d</code> argument describes <code class="literal">cvp</code>.<a class="indexterm" id="IDX-CHP-4-0104"/><a class="indexterm" id="IDX-CHP-4-0105"/><a class="indexterm" id="IDX-CHP-4-0106"/><a class="indexterm" id="IDX-CHP-4-0107"/><a class="indexterm" id="IDX-CHP-4-0108"/><a class="indexterm" id="IDX-CHP-4-0109"/><a class="indexterm" id="IDX-CHP-4-0110"/><a class="indexterm" id="IDX-CHP-4-0111"/><a class="indexterm" id="IDX-CHP-4-0112"/><a class="indexterm" id="IDX-CHP-4-0113"/><a class="indexterm" id="IDX-CHP-4-0114"/></p><p>The <code class="literal">cv_wmesg</code> function gets the <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8826"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> description of <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8832"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">cvp</code>. This function is primarily used in error reporting.</p><p>Threads sleep on <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8843"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">cvp</code> by calling <code class="literal">cv_wait</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8855"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">lock</code> argument demands a sleep mutex, sx <code class="literal">lock</code>, or <code class="literal">rw</code> lock. Threads must hold lock before calling <code class="literal">cv_wait</code>. Threads must not sleep on <code class="literal">cvp</code> with <code class="literal">lock</code> held recursively.</p><p>The <code class="literal">cv_wait_unlock</code> function is a variant of <code class="literal">cv_wait</code>. When threads wake up from sleeping on <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8888"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">cvp</code>, they forgo reacquiring <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8897"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">lock</code>.</p><p>The <code class="literal">cv_wait_sig</code> function is identical to <code class="literal">cv_wait</code> except that when the caller is asleep it can be woken up by signals. If this occurs, the error code <code class="literal">EINTR</code> or <code class="literal">ERESTART</code> is returned.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Normally, threads sleeping on condition variables cannot be woken up early.</p></div><p>The <code class="literal">cv_timedwait</code> function is identical to <code class="literal">cv_wait</code> except that the caller sleeps at most <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8932"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">timo</code> / <code class="literal">hz</code> seconds. If the sleep times out, the error code <code class="literal">EWOULDBLOCK</code> is returned.</p><p>The <code class="literal">cv_timedwait_sig</code> function is like <code class="literal">cv_wait_sig</code> and <code class="literal">cv_timedwait</code>. The caller can be woken up by signals and sleeps at most <code class="literal">timo</code> / <code class="literal">hz</code> seconds.</p><p>Threads wake up one thread sleeping on <code class="literal">cvp</code> by calling <code class="literal">cv_signal</code>, and they wake up every thread sleeping on <code class="literal">cvp</code> by calling <code class="literal">cv_broadcast</code>.</p><p>The <code class="literal">cv_broadcastpri</code> function is identical to <code class="literal">cv_broadcast</code> except that all threads woken up have their priority raised to <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e8988"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">pri</code>. Threads with a priority higher than <code class="literal">pri</code> do not have their priority lowered.</p><p>The <code class="literal">cv_destroy</code> function destroys the condition variable <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e9005"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">cvp</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We’ll walk through an example that uses condition variables in <a class="xref" href="ch05.html" title="Chapter 5. Delaying Execution">Chapter 5</a>.</p></div></div>
<div class="sect1" title="General Guidelines"><div class="titlepage"><div><div><h1 class="title"><a id="general_guidelines"/>General Guidelines</h1></div></div></div><p>Here are some general guidelines for lock usage. Note that these aren’t hard-and-fast rules, just things to keep in mind.</p><div class="sect2" title="Avoid Recursing on Exclusive Locks"><div class="titlepage"><div><div><h2 class="title"><a id="avoid_recursing_on_exclusive_locks"/>Avoid Recursing on Exclusive Locks</h2></div></div></div><p>When an exclusive hold or lock is acquired, the holder usually assumes that it has exclusive access to the objects the lock protects. Unfortunately, recursive locks can break this assumption in some cases. As an example, suppose function <code class="literal">F1</code> uses a recursive lock <code class="literal">L</code> to protect object O. If function <code class="literal">F2</code> acquires <code class="literal">L</code>, modifies <code class="literal">O</code>, leaving it in an inconsistent state, and then calls <code class="literal">F1</code>, <code class="literal">F1</code> will recursively acquire <code class="literal">L</code> and falsely assume that <code class="literal">O</code> is in a consistent state.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-1" id="CHP-4-FN-1">7</a>]</sup></p><p>One solution to this problem is to use a nonrecursive lock and to rewrite <code class="literal">F1</code> so that it does not acquire <code class="literal">L</code>. Instead, <code class="literal">L</code> must be acquired before calling <code class="literal">F1</code>.</p></div><div class="sect2" title="Avoid Holding Exclusive Locks for Long Periods of Time"><div class="titlepage"><div><div><h2 class="title"><a id="avoid_holding_exclusive_locks_for_long_p"/>Avoid Holding Exclusive Locks for Long Periods of Time</h2></div></div></div><p>Exclusive locks reduce concurrency and should be released as soon as possible. Note that it is better to hold a lock for a short period of time when it is not needed than to release the lock only to reacquire it (Baldwin, 2002). This is because the operations to acquire and release a lock are relatively expensive.<a class="indexterm" id="IDX-CHP-4-0115"/><a class="indexterm" id="IDX-CHP-4-0116"/><a class="indexterm" id="IDX-CHP-4-0117"/><a class="indexterm" id="IDX-CHP-4-0118"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-1" id="ftn.CHP-4-FN-1">7</a>] </sup>This paragraph is adapted from <code class="literal">Locking in the Multithreaded FreeBSD Kernel by John H</code>. Baldwin (2002)</p></div></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id3"/>Conclusion</h1></div></div></div><p>This chapter dealt with the problem of data and state corruption caused by concurrent threads. In short, whenever an object is accessible by multiple threads, its access must be managed.</p></div></body></html>