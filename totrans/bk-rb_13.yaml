- en: Chapter 13. Files and IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ruby provides classes dedicated to handling input and output (IO). Chief among
    these is a class called, unsurprisingly, IO. The IO class lets you open and close
    IO *streams* (sequences of bytes) and read and write data to and from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assuming you have a file called *textfile.txt*, containing some
    lines of text, this is how you might open the file and display each line on the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '*io_test.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here `foreach` is a class method of IO, so you don’t need to create a new IO
    object to use it; instead, you just specify the filename as an argument. The `foreach`
    method takes a block into which each line that is read from the file is passed
    as an argument. You don’t have to open the file for reading and close it when
    you’ve finished (as you might expect from your experience with other languages)
    because Ruby’s `IO.foreach` method does this for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'IO has a number of other useful methods. For example, you could use the `readlines`
    method to read the file contents into an array for further processing. Here is
    a simple example that once again prints the lines to screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The File class is a subclass of IO, and the previous examples could be rewritten
    using the File class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*file_test.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Opening and Closing Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although some standard methods open and close files automatically, often when
    processing the contents of a file, you will need to open and close the file explicitly.
    You can open a file using either the `new` or `open` method. You must pass two
    arguments to one of those methods—the filename and the file “mode”—and it returns
    a new File object. The File modes may be either integers that are defined by operating
    system-specific constants or strings. The mode generally indicates whether the
    file is be opened for reading (`"r"`), writing (`"w"`), or reading and writing
    (`"rw"`). [Table 13-1](ch13.html#file_mode_strings "Table 13-1. File Mode Strings")
    shows the list of available string modes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-1. File Mode Strings
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"r"` | Read-only, starts at beginning of file (default mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `"r+"` | Read-write, starts at beginning of file |'
  prefs: []
  type: TYPE_TB
- en: '| `"w"` | Write-only, truncates existing file to zero length or creates a new
    file for writing |'
  prefs: []
  type: TYPE_TB
- en: '| `"w+"` | Read-write, truncates existing file to zero length or creates a
    new file for reading and writing |'
  prefs: []
  type: TYPE_TB
- en: '| `"a"` | Write-only, starts at end of file if file exists; otherwise, creates
    a new file for writing |'
  prefs: []
  type: TYPE_TB
- en: '| `"a+"` | Read-write, starts at end of file if file exists; otherwise, creates
    a new file for reading and writing |'
  prefs: []
  type: TYPE_TB
- en: '| `"b"` | (DOS/Windows only) Binary file mode (may appear with any of the key
    letters listed earlier) |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s look at an actual example of opening, processing, and closing files.
    In *open_close.rb*, I first open a file, *myfile.txt*, for writing (`"w"`). When
    a file is opened for writing, a new file will be created if it doesn’t already
    exist. I use `puts()` to write six strings to the file, one string on each of
    six lines. Finally, I close the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Closing a file not only releases the *file handle* (the pointer to the file
    data) but also “flushes” any data from memory to ensure that it is all saved into
    the file on disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having written text into a file, let’s see how to open that file and read the
    data back in. This time I’ll read in the data one character at a time up to the
    end of the file (`eof`). As I do so, I’ll keep a count of the characters that
    have been read. I’ll also keep a count of the lines, which will be incremented
    whenever I read in a linefeed character (given by ASCII code 10). For the sake
    of clarity, I’ll add a string to the end of each line that’s been read, displaying
    its line number. I’ll display the characters plus my line-end strings on the screen,
    and when everything has been read from the file, I’ll close it and display the
    statistics that I’ve calculated. Here is the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*open_close.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code is written for Ruby 1.9 and won’t run in Ruby 1.8\. See the following
    section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: When manipulating files in this way, it is the programmer’s responsibility to
    ensure that the file is closed after data is written to or read from it. Failing
    to close a file may result in unpredictable side effects. For example, try commenting
    out the first `f.close` (on the third line in the previous code) to see for yourself!
    You’ll find that when the program subsequently tries to read back the contents
    of the file, no data is found, and a count of zero lines and characters is returned!
  prefs: []
  type: TYPE_NORMAL
- en: Characters and Compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *open_close.rb* program is written for Ruby 1.9 and cannot be run in Ruby
    1.8\. This is because when a single character is returned by Ruby 1.8, it is treated
    as an integer ASCII value, whereas in Ruby 1.9 it is treated as a one-character
    string. So, when `getc()` returns the character, `c`, Ruby 1.8 is able to test
    its ASCII value ( `c == 10` ), whereas Ruby 1.9 must either test it as a string
    ( `c == "\n"` ) or convert the character to an integer using the `ord` method:
    `( c.ord == 10 )`. The `ord` method does not exist in Ruby 1.8.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general principle, if you want to write programs that work in different
    versions of Ruby, you may code around incompatibility issues by testing the value
    of the `RUBY_VERSION` constant. This constant returns a string giving a version
    number such as 1.9.2\. You could simply convert the string to a floating-point
    number using the `to_f` method and then take different actions if the value is
    greater than 1.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could analyze the string to determine the minor and major
    version numbers. Here, for example, is a very simple method that indexes into
    the `RUBY_VERSION` string to obtain the first character as the major version (
    1 or 2) and the second character as the minor version (for example, 8 or 9). It
    returns `true` if the Ruby version is 1.9 or higher and false otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '*open_close2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this test in your code to deal with compatibility issues. Here
    the `ord` method is applied to the character, `c`, only if the Ruby version is
    1.9 or greater:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use the File class to manipulate files and directories on disk.
    Before attempting to perform some operation on a file, you must naturally make
    sure that the file exists. It might, after all, have been renamed or deleted after
    the program started—or the user may have incorrectly entered a file or directory
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the existence of a file using the `File.exist?` method. This
    is one of several testing methods that are provided to the File class by the `FileTest`
    module. As far as the `File.exist?` method is concerned, a directory counts as
    a file, so you could use the following code to test for the presence of a *C:\*
    drive (note that you must use double file separator `"\\"` characters in strings,
    because a single `"\"` will be treated as an escape character):'
  prefs: []
  type: TYPE_NORMAL
- en: '*file_ops.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to distinguish between a directory and a data file, use the `directory?`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Copying Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s put the File class to some practical use by writing a simple file backup
    program. When you run *copy_files.rb*, you will be asked to choose a directory
    to copy from (the source directory) and another directory to copy to (the target
    directory). Assuming both directories exist, the program will then copy all the
    files from the source directory to the target directory. If the target directory
    does not exist, it will ask you whether you would like to create it, in which
    case you should enter *Y* to accept. I’ve supplied a source directory for you;
    just enter the name *srcdir* when prompted. When asked for a target directory,
    enter *targetdir* in order to create a subdirectory of that name beneath the current
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program initializes the variable `sourcedir` with the path of the source
    directory, and it initializes `targetdir` with the name of the target directory.
    This is the code that does the file copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '*copy_files.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here I’ve used the `foreach` method of the Dir class, which passes into a block
    the filename, `f`, of each file in the specified directory. I’ll have more to
    say about the Dir class shortly. The code constructs a qualified path to the file,
    `filepath`, by appending the filename to the directory name given by the `sourcedir`
    variable. I only want to copy data files but not directories, so I test that `filepath`
    is a file and not a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I don’t want this program to copy over files that already exist, so it first
    checks to see whether a file with the name `f` already exists in the target directory,
    `targetdir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, assuming all the specified conditions are met, the source file, `filepath`,
    is copied to `targetdir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `cp` is a file-copy method found in the `FileUtils` module. This module
    also contains a number of other useful file-handling routines such as `mv(source,
    target)` to move a file from `source` to `target`, `rm( files )` to delete one
    or more files listed in the `files` parameter, and `mkdir` to create a directory
    as I have done when creating `targetdir` in the current program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Directory Inquiries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My backup program deals with just one directory level at a time, which is why
    it tests to see that a file, `f`, is not a directory before attempting to copy
    it. There are many times, however, when you may want to traverse the subdirectories.
    For an example of this, let’s write a program that calculates the sizes of all
    the subdirectories beneath a specified root directory. This might be useful if,
    for example, you wanted to locate the biggest files and directories in order to
    free up disk space by archiving or deleting them.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through subdirectories creates an interesting programming problem.
    When you begin searching for the presence of subdirectories, you have no idea
    whether you will find one, none, or many. Moreover, any subdirectory you find
    may contain yet another level of subdirectories, each of which may contain other
    subdirectories and so on through many possible levels.
  prefs: []
  type: TYPE_NORMAL
- en: A Discursion into Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program needs to be able to navigate down the entire subdirectory tree
    to any number of levels. To be able to do this, you have to use *recursion*. Put
    simply, a recursive method is one that calls itself. If you aren’t familiar with
    recursive programming, see [Digging Deeper](ch13s07.html#digging_deeper-id12 "Digging
    Deeper") in [Digging Deeper](ch13s07.html#digging_deeper-id12 "Digging Deeper").
  prefs: []
  type: TYPE_NORMAL
- en: 'In the program *file_info.rb*, the `processfiles` method is recursive:'
  prefs: []
  type: TYPE_NORMAL
- en: '*file_info.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that when the method is first called, toward the bottom of the
    source code, it is passed the name of a directory in the variable `dirname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve already assigned the parent of the current directory, given by two dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you are running this program in its original location (that is, the location
    to which it is extracted from this book’s source code archive), this will reference
    the directory containing the subdirectories of all the sample code files. Alternatively,
    you could assign the name of some directory on your hard disk to the variable,
    `dirname`. If you do this, don’t specify a directory containing huge numbers of
    files and directories (on Windows, *C:\Program Files* would not be a good choice,
    and *C:\* would be even worse!) because the program would then take quite some
    time to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the code in the `processfiles` method. Once again,
    I use `Dir.foreach` to find all the files in the current directory and pass each
    file, `f`, one at a time, to be handled by the code in a block between curly brackets.
    If `f` is a directory and is not the current one (`''.''`) or its parent directory
    (`''..''`), then I pass the full path of the directory back to the `processfiles`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If `f` is not a directory but just an ordinary data file, I find its size in
    bytes with `File.size` and assign this to the variable `filesize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As each successive file, `f`, is processed by the block of code, its size is
    calculated, and this value is added to the variable `totalbytes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once every file in the current directory has been passed into the block, `totalbytes`
    will be equal to the total size of all the files in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: However, I need to calculate the bytes in all the subdirectories too. Because
    the method is recursive, this is done automatically. Remember that when the code
    between curly brackets in the `processfiles` method determines that the current
    file, `f`, is a directory, it passes this directory name back to *itself*—the
    `processfiles` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine that you first call `processfiles` with the *C:\test* directory.
    At some point, the variable `f` is assigned the name of one of its subdirectories,
    say, *C:\test\dir_a*. Now this subdirectory is passed back to `processfiles`.
    No further directories are found in *C:\test\dir_a*, so `processfiles` simply
    calculates the sizes of all the files in this subdirectory. When it finishes calculating
    these files, the `processfiles` method comes to an end and returns the number
    of bytes in the current directory, `totalbytes`, to whichever bit of code called
    the method in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it was this bit of code inside the `processfiles` method that
    recursively called the `processfiles` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, when `processfiles` finishes processing the files in the subdirectory, *C:\test\dir_a*,
    it returns the total size of all the files found there, and this is assigned to
    the `bytes_in_dir` variable. The `processfiles` method now carries on where it
    left off (that is, it continues from the point at which it called itself to deal
    with the subdirectory) by processing the files in the original directory, *C:\test*.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how many levels of subdirectories this method encounters, the fact
    that it calls itself whenever it finds a directory ensures that it automatically
    travels down every directory pathway it finds, calculating the total bytes in
    each.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final thing to note is that the values assigned to variables declared inside
    the `processfiles` method will change back to their “previous” values as each
    level of recursion completes. So, the `totalbytes` variable will first contain
    the size of *C:\test\test_a\test_b*, then of *C:\test\test_a*, and finally of
    *C:\test*. To keep a running total of the combined sizes of all the directories,
    you need to assign values to a variable declared *outside* the method. Here I
    use the global variable `$dirsize` for this purpose, adding to it the value of
    `totalbytes` calculated for each subdirectory processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Incidentally, although a byte may be a convenient unit of measurement for very
    small files, it is generally better to describe larger files in kilobyte sizes
    and very large files or directories in megabytes. To change bytes to kilobytes
    or to change kilobytes to megabytes, you need to divide by 1,024\. To change bytes
    to megabytes, divide by 1,048,576\. The last line of code in my program does these
    calculations and displays the results in a formatted string using Ruby’s `printf`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that I have embedded the formatting placeholder `"%0.02fMB"` in the
    first string, and I have added a second string following a comma: `"#{$dirsize/1048576.0}"`.
    The second string calculates the directory size in megabytes, and this value is
    then substituted for the placeholder in the first string. The placeholder’s formatting
    option `"%0.02f"` ensures that the megabyte value is shown as a floating-point
    number, `"f"`, with two decimal places, `"0.02"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by Size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently this program prints the file and directory names and their sizes in
    alphabetical order. But I am more interested in their *relative* sizes. It would,
    therefore, be more useful if the files were sorted by size rather than by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to sort the files, you need some way of storing a complete list
    of all file sizes. One obvious way of doing this would be to add the file sizes
    to an array. In *file_info2.rb*, I create an empty array, `$files`, and each time
    a file is processed, I append its size to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '*file_info2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I can then sort the file sizes to display low to high values or (by sorting
    and then reversing the array) to display from high to low values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The only trouble with this is that I now end up with an array of file sizes
    without the associated filenames. A better solution would be to use a Hash instead
    of an Array. I’ve done this in *file_info3.rb*. First, I create two empty Hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*file_info3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the `processfiles` method encounters a directory, it adds a new entry
    to the `$dirs` Hash using the full directory path, `mypath`, as the key and using
    the directory size, `dsize`, as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Key-value pairs are similarly added to the `$files` hash. When the entire structure
    of subdirectories and files has been processed by recursive calls to the `processfiles`
    method, the `$dirs` hash variable will contain key-value pairs of directory names
    and sizes, and the `$files` hash will contain key-value pairs of file names and
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains now is for these hashes to be sorted and displayed. The standard
    `sort` method for a Hash sorts the keys, not the values. I want to sort the values
    (sizes), not the keys (names). To do this, I have defined a custom sort method
    (refer to [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes") and [Chapter 5](ch05.html
    "Chapter 5. Loops and Iterators") for guidance on defining custom comparisons
    using `<=>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `sort` method converts the `$files` Hash into nested arrays of `[key,value]`
    pairs and passes two of these, `a` and `b`, into the block between curly brackets.
    The second item (at index `[1]`) of each `[key,value]` pair provides the value.
    The sorting itself is done on the value using Ruby’s `<=>` comparison method.
    The end result is that this program now displays first a list of files in ascending
    order (by size) and then a similarly sorted list of directories. This is an example
    of its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is an important programming technique that can, however, be quite
    difficult to understand. Here I will explain recursion one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion Made Simple
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve never used recursion before, the recursive “directory-walking” methods
    in this chapter may need a little explanation. To clarify how recursion works,
    let’s look at a much simpler example. Load the *recursion.rb* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '*recursion.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This contains the recursive method, `addup`, whose sole purpose in life is to
    count from 1 to 3\. The `addup` method receives an integer value as an incoming
    argument, `aNum`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also global variable, `$outercount`, which lives “outside” the `addup`
    method. Whenever the `addup` method executes, 1 is added to `aNum`, and 1 is also
    added to `$outercount`. Then, just so long as `$outercount` is less than 3, the
    code inside the `addup` method calls the same method (`addup`) all over again,
    passing to it the new value of `aNum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s follow what happens. The process is started off by calling `addup` with
    the value 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addup` method adds 1 to both `aNum` and `$outercount`, so both variables
    now have the value 1\. The test (`$outercount < 3`) evaluates to true, so `aNum`
    is passed as an argument to `addup`. Once again, 1 is added to both variables,
    so `aNum` is now 2, and `$outercount` is also 2\. Now `aNum` is once more passed
    to `addup`. Yet again 1 is added to both variables, giving each the value 3\.
    This time, however, the test condition fails since `$outercount` is no longer
    less than 3\. So, the code that calls `addup` is skipped, and you arrive at the
    last line in the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out the values of `aNum` and `$outercount`, which, as you expect,
    are both 3\. Having arrived at the end of this method, the “flow of control” moves
    back to the line of code immediately following the code that originally called
    the method. Here, the line of code that called the `addup` method happens to be
    inside the method itself. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And the first executable line that follows this is (once again) the final line
    of the method that prints out the values of the two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, you have gone back to an earlier “point of execution”—the point at which
    you recursively called the `addup` method. At that time, the value of `aNum` was
    2, and that is its value *now*. If this seems confusing, just try to think what
    would have happened if `aNum` had been 2 and then you called some other, unrelated
    method. On returning from that other method, `aNum` would, of course, still have
    had the value 2\. That’s all that’s happened here. The only difference is that
    this method happened to call *itself* rather than some other method.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the method exits, and control returns to the next executable line
    following the code that called the method, and `aNum`’s value has taken another
    step back into its own history—it now has the value 1\. The `$outercount` variable,
    however, lives *outside* the method and is unaffected by recursion, so it is still
    3.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have access to a visual debugger, this entire process will become much
    clearer: You can place a breakpoint on line 9 (`if $outercount < 3 then`), add
    `aNum` and `$outercount` to the Watch window, and repeatedly step into the code
    after you hit the breakpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860162.png)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot shows the recursion program being debugged visually in the IDE
    Ruby In Steel. I can step through the source code, use the call stack to keep
    track of the current “level” of recursion (how many times the addup method has
    been called), and use the Watch window to monitor the current values of the variables.
  prefs: []
  type: TYPE_NORMAL
