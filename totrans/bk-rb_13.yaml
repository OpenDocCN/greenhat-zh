- en: Chapter 13. Files and IO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。文件和IO
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: Ruby provides classes dedicated to handling input and output (IO). Chief among
    these is a class called, unsurprisingly, IO. The IO class lets you open and close
    IO *streams* (sequences of bytes) and read and write data to and from them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby提供了专门用于处理输入和输出的类（IO）。其中最重要的是一个名为IO的类。IO类允许你打开和关闭IO流（字节的序列），并从它们读取和写入数据。
- en: 'For example, assuming you have a file called *textfile.txt*, containing some
    lines of text, this is how you might open the file and display each line on the
    screen:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为*textfile.txt*的文件，其中包含一些文本行，这是你打开文件并在屏幕上显示每一行的方法：
- en: '*io_test.rb*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*io_test.rb*'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here `foreach` is a class method of IO, so you don’t need to create a new IO
    object to use it; instead, you just specify the filename as an argument. The `foreach`
    method takes a block into which each line that is read from the file is passed
    as an argument. You don’t have to open the file for reading and close it when
    you’ve finished (as you might expect from your experience with other languages)
    because Ruby’s `IO.foreach` method does this for you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`foreach`是IO的一个类方法，因此你不需要创建一个新的IO对象来使用它；相反，你只需指定文件名作为参数。`foreach`方法接受一个块，其中每个从文件中读取的行作为参数传递。当你完成读取后，你不需要打开文件进行读取并关闭它（正如你可能从其他语言的经验中预期的那样），因为Ruby的`IO.foreach`方法会为你完成这些操作。
- en: 'IO has a number of other useful methods. For example, you could use the `readlines`
    method to read the file contents into an array for further processing. Here is
    a simple example that once again prints the lines to screen:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: IO类有其他一些有用的方法。例如，你可以使用`readlines`方法将文件内容读取到数组中，以便进行进一步处理。以下是一个简单的示例，它再次将行打印到屏幕上：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The File class is a subclass of IO, and the previous examples could be rewritten
    using the File class:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: File类是IO的子类，前面的示例可以使用File类重写：
- en: '*file_test.rb*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*file_test.rb*'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Opening and Closing Files
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开和关闭文件
- en: Although some standard methods open and close files automatically, often when
    processing the contents of a file, you will need to open and close the file explicitly.
    You can open a file using either the `new` or `open` method. You must pass two
    arguments to one of those methods—the filename and the file “mode”—and it returns
    a new File object. The File modes may be either integers that are defined by operating
    system-specific constants or strings. The mode generally indicates whether the
    file is be opened for reading (`"r"`), writing (`"w"`), or reading and writing
    (`"rw"`). [Table 13-1](ch13.html#file_mode_strings "Table 13-1. File Mode Strings")
    shows the list of available string modes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些标准方法可以自动打开和关闭文件，但在处理文件内容时，通常需要显式地打开和关闭文件。你可以使用`new`或`open`方法打开一个文件。你必须向这些方法之一传递两个参数——文件名和文件“模式”，它将返回一个新的File对象。文件模式可以是操作系统特定的常量定义的整数，也可以是字符串。模式通常表示文件是用于读取（`"r"`）、写入（`"w"`）还是读写（`"rw"`）[表13-1](ch13.html#file_mode_strings
    "表13-1. 文件模式字符串")显示了可用的字符串模式列表。
- en: Table 13-1. File Mode Strings
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1. 文件模式字符串
- en: '| Mode | Meaning |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"r"` | Read-only, starts at beginning of file (default mode) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `"r"` | 只读，从文件开头开始（默认模式）|'
- en: '| `"r+"` | Read-write, starts at beginning of file |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `"r+"` | 读写，从文件开头开始|'
- en: '| `"w"` | Write-only, truncates existing file to zero length or creates a new
    file for writing |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `"w"` | 只写，截断现有文件到零长度或创建一个新文件用于写入|'
- en: '| `"w+"` | Read-write, truncates existing file to zero length or creates a
    new file for reading and writing |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `"w+"` | 读写，截断现有文件到零长度或创建一个新文件用于读写|'
- en: '| `"a"` | Write-only, starts at end of file if file exists; otherwise, creates
    a new file for writing |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `"a"` | 只写，如果文件存在，从文件末尾开始；否则，创建一个新文件用于写入|'
- en: '| `"a+"` | Read-write, starts at end of file if file exists; otherwise, creates
    a new file for reading and writing |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `"a+"` | 读写，如果文件存在，从文件末尾开始；否则，创建一个新文件用于读写|'
- en: '| `"b"` | (DOS/Windows only) Binary file mode (may appear with any of the key
    letters listed earlier) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `"b"` | （仅限DOS/Windows）二进制文件模式（可以与前面列出的任何关键字一起出现）|'
- en: 'Let’s look at an actual example of opening, processing, and closing files.
    In *open_close.rb*, I first open a file, *myfile.txt*, for writing (`"w"`). When
    a file is opened for writing, a new file will be created if it doesn’t already
    exist. I use `puts()` to write six strings to the file, one string on each of
    six lines. Finally, I close the file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个打开、处理和关闭文件的实际示例。在 *open_close.rb* 中，我首先以写入模式（`"w"`）打开一个文件，*myfile.txt*。当一个文件以写入模式打开时，如果它不存在，将会创建一个新文件。我使用
    `puts()` 将六个字符串写入文件，每个字符串占一行。最后，我关闭文件：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Closing a file not only releases the *file handle* (the pointer to the file
    data) but also “flushes” any data from memory to ensure that it is all saved into
    the file on disk.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件不仅释放了*文件句柄*（指向文件数据的指针），还将任何数据从内存中“刷新”出来，以确保所有数据都保存到磁盘上的文件中。
- en: 'Having written text into a file, let’s see how to open that file and read the
    data back in. This time I’ll read in the data one character at a time up to the
    end of the file (`eof`). As I do so, I’ll keep a count of the characters that
    have been read. I’ll also keep a count of the lines, which will be incremented
    whenever I read in a linefeed character (given by ASCII code 10). For the sake
    of clarity, I’ll add a string to the end of each line that’s been read, displaying
    its line number. I’ll display the characters plus my line-end strings on the screen,
    and when everything has been read from the file, I’ll close it and display the
    statistics that I’ve calculated. Here is the complete code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本写入文件后，让我们看看如何打开该文件并读取数据。这次我将逐个字符读取数据，直到文件末尾（`eof`）。在这个过程中，我会记录已读取的字符数。我还会记录行数，每当读取到换行符（ASCII
    码 10）时，行数会增加。为了清晰起见，我会在每行读取的末尾添加一个字符串，显示其行号。我将在屏幕上显示字符以及我的行结束字符串，当从文件中读取完所有内容后，我将关闭文件并显示我计算出的统计数据。以下是完整的代码：
- en: '*open_close.rb*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*open_close.rb*'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code is written for Ruby 1.9 and won’t run in Ruby 1.8\. See the following
    section for more details.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码是为 Ruby 1.9 编写的，不能在 Ruby 1.8 中运行。有关更多详细信息，请参阅以下部分。
- en: When manipulating files in this way, it is the programmer’s responsibility to
    ensure that the file is closed after data is written to or read from it. Failing
    to close a file may result in unpredictable side effects. For example, try commenting
    out the first `f.close` (on the third line in the previous code) to see for yourself!
    You’ll find that when the program subsequently tries to read back the contents
    of the file, no data is found, and a count of zero lines and characters is returned!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式操作文件时，程序员有责任确保在向文件写入或从中读取数据后关闭文件。未能关闭文件可能会导致不可预测的副作用。例如，尝试注释掉前面的第一个 `f.close`（在上一段代码的第三行）看看会发生什么！你会发现当程序随后尝试读取文件内容时，找不到数据，并且返回零行和字符数！
- en: Characters and Compatibility
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符和兼容性
- en: 'The *open_close.rb* program is written for Ruby 1.9 and cannot be run in Ruby
    1.8\. This is because when a single character is returned by Ruby 1.8, it is treated
    as an integer ASCII value, whereas in Ruby 1.9 it is treated as a one-character
    string. So, when `getc()` returns the character, `c`, Ruby 1.8 is able to test
    its ASCII value ( `c == 10` ), whereas Ruby 1.9 must either test it as a string
    ( `c == "\n"` ) or convert the character to an integer using the `ord` method:
    `( c.ord == 10 )`. The `ord` method does not exist in Ruby 1.8.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*open_close.rb* 程序是为 Ruby 1.9 编写的，不能在 Ruby 1.8 中运行。这是因为当 Ruby 1.8 返回单个字符时，它被视为一个整数
    ASCII 值，而在 Ruby 1.9 中，它被视为一个单字符字符串。因此，当 `getc()` 返回字符 `c` 时，Ruby 1.8 能够测试其 ASCII
    值（`c == 10`），而 Ruby 1.9 必须将其作为字符串测试（`c == "\n"`）或使用 `ord` 方法将字符转换为整数：（`c.ord ==
    10`）。`ord` 方法在 Ruby 1.8 中不存在。'
- en: 'As a general principle, if you want to write programs that work in different
    versions of Ruby, you may code around incompatibility issues by testing the value
    of the `RUBY_VERSION` constant. This constant returns a string giving a version
    number such as 1.9.2\. You could simply convert the string to a floating-point
    number using the `to_f` method and then take different actions if the value is
    greater than 1.8:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条基本原则，如果你想编写能在不同版本的 Ruby 中运行的程序，你可以通过测试 `RUBY_VERSION` 常量的值来绕过不兼容性问题。这个常量返回一个表示版本号的字符串，例如
    1.9.2。你可以简单地使用 `to_f` 方法将字符串转换为浮点数，然后根据值是否大于 1.8 来采取不同的行动：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, you could analyze the string to determine the minor and major
    version numbers. Here, for example, is a very simple method that indexes into
    the `RUBY_VERSION` string to obtain the first character as the major version (
    1 or 2) and the second character as the minor version (for example, 8 or 9). It
    returns `true` if the Ruby version is 1.9 or higher and false otherwise:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以分析字符串以确定次要和主要版本号。例如，这里有一个非常简单的方法，它通过索引到`RUBY_VERSION`字符串来获取第一个字符作为主要版本（1或2）和第二个字符作为次要版本（例如，8或9）。如果Ruby版本是1.9或更高，则返回`true`，否则返回`false`：
- en: '*open_close2.rb*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`*open_close2.rb*`'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can use this test in your code to deal with compatibility issues. Here
    the `ord` method is applied to the character, `c`, only if the Ruby version is
    1.9 or greater:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的代码中使用这个测试来处理兼容性问题。在这里，`ord`方法仅当Ruby版本为1.9或更高时才应用于字符`c`：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Files and Directories
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和目录
- en: You can also use the File class to manipulate files and directories on disk.
    Before attempting to perform some operation on a file, you must naturally make
    sure that the file exists. It might, after all, have been renamed or deleted after
    the program started—or the user may have incorrectly entered a file or directory
    name.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`File`类来操作磁盘上的文件和目录。在尝试对文件执行某些操作之前，你必须确保文件存在。毕竟，文件可能在程序开始后已被重命名或删除——或者用户可能错误地输入了文件或目录名称。
- en: 'You can verify the existence of a file using the `File.exist?` method. This
    is one of several testing methods that are provided to the File class by the `FileTest`
    module. As far as the `File.exist?` method is concerned, a directory counts as
    a file, so you could use the following code to test for the presence of a *C:\*
    drive (note that you must use double file separator `"\\"` characters in strings,
    because a single `"\"` will be treated as an escape character):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`File.exist?`方法来验证文件的存在。这是`FileTest`模块提供给`File`类的一些测试方法之一。就`File.exist?`方法而言，目录被视为文件，因此你可以使用以下代码来测试`*C:\*`驱动器的存在（注意，在字符串中必须使用双文件分隔符`"\\"`字符，因为单个`"\"`将被视为转义字符）：
- en: '*file_ops.rb*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`*file_ops.rb*`'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want to distinguish between a directory and a data file, use the `directory?`
    method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要区分目录和数据文件，可以使用`directory?`方法：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Copying Files
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制文件
- en: Let’s put the File class to some practical use by writing a simple file backup
    program. When you run *copy_files.rb*, you will be asked to choose a directory
    to copy from (the source directory) and another directory to copy to (the target
    directory). Assuming both directories exist, the program will then copy all the
    files from the source directory to the target directory. If the target directory
    does not exist, it will ask you whether you would like to create it, in which
    case you should enter *Y* to accept. I’ve supplied a source directory for you;
    just enter the name *srcdir* when prompted. When asked for a target directory,
    enter *targetdir* in order to create a subdirectory of that name beneath the current
    directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个简单的文件备份程序来让`File`类发挥实际作用。当你运行`*copy_files.rb*`时，系统会要求你选择一个要复制的目录（源目录）以及另一个要复制的目录（目标目录）。假设这两个目录都存在，程序随后会将源目录中的所有文件复制到目标目录。如果目标目录不存在，程序会询问你是否希望创建它，在这种情况下你应该输入`*Y*`来接受。我已经为你提供了一个源目录；当提示时，只需输入名称`*srcdir*`。当询问目标目录时，输入`*targetdir*`以在当前目录下创建一个同名子目录。
- en: 'The program initializes the variable `sourcedir` with the path of the source
    directory, and it initializes `targetdir` with the name of the target directory.
    This is the code that does the file copying:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用源目录的路径初始化变量`sourcedir`，并使用目标目录的名称初始化`targetdir`。这是执行文件复制的代码：
- en: '*copy_files.rb*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`*copy_files.rb*`'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here I’ve used the `foreach` method of the Dir class, which passes into a block
    the filename, `f`, of each file in the specified directory. I’ll have more to
    say about the Dir class shortly. The code constructs a qualified path to the file,
    `filepath`, by appending the filename to the directory name given by the `sourcedir`
    variable. I only want to copy data files but not directories, so I test that `filepath`
    is a file and not a directory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了`Dir`类的`foreach`方法，它将指定目录中每个文件的文件名`f`传递给一个块。我将在稍后详细介绍`Dir`类。代码通过将文件名附加到由`sourcedir`变量给出的目录名称来构造文件的合格路径`filepath`。我只想要复制数据文件，而不是目录，所以我测试`filepath`是否是文件而不是目录：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I don’t want this program to copy over files that already exist, so it first
    checks to see whether a file with the name `f` already exists in the target directory,
    `targetdir`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我不希望这个程序复制已经存在的文件，因此它首先检查目标目录`targetdir`中是否已经存在名为`f`的文件：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, assuming all the specified conditions are met, the source file, `filepath`,
    is copied to `targetdir`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设所有指定的条件都满足，源文件`filepath`将被复制到`targetdir`：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here `cp` is a file-copy method found in the `FileUtils` module. This module
    also contains a number of other useful file-handling routines such as `mv(source,
    target)` to move a file from `source` to `target`, `rm( files )` to delete one
    or more files listed in the `files` parameter, and `mkdir` to create a directory
    as I have done when creating `targetdir` in the current program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cp`是`FileUtils`模块中找到的一个文件复制方法。此模块还包含许多其他有用的文件处理例程，例如`mv(source, target)`将文件从`source`移动到`target`，`rm(files)`删除`files`参数中列出的一个或多个文件，以及`mkdir`创建目录，就像我在当前程序中创建`targetdir`时做的那样：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Directory Inquiries
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录查询
- en: My backup program deals with just one directory level at a time, which is why
    it tests to see that a file, `f`, is not a directory before attempting to copy
    it. There are many times, however, when you may want to traverse the subdirectories.
    For an example of this, let’s write a program that calculates the sizes of all
    the subdirectories beneath a specified root directory. This might be useful if,
    for example, you wanted to locate the biggest files and directories in order to
    free up disk space by archiving or deleting them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我的备份程序一次只处理一个目录级别，这就是为什么它在尝试复制文件`f`之前会检查它不是一个目录。然而，有很多时候你可能想要遍历子目录。作为一个例子，让我们编写一个程序，计算指定根目录下所有子目录的大小。如果你想要定位最大的文件和目录，以便通过存档或删除它们来释放磁盘空间，这可能很有用。
- en: Navigating through subdirectories creates an interesting programming problem.
    When you begin searching for the presence of subdirectories, you have no idea
    whether you will find one, none, or many. Moreover, any subdirectory you find
    may contain yet another level of subdirectories, each of which may contain other
    subdirectories and so on through many possible levels.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在子目录中导航创建了一个有趣的编程问题。当你开始搜索子目录的存在时，你不知道你会找到多少个，一个也没有，或者很多。此外，你找到的任何子目录可能还包含另一个级别的子目录，每个子目录可能还包含其他子目录，以此类推，可能有很多层级。
- en: A Discursion into Recursion
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对递归的探讨
- en: This program needs to be able to navigate down the entire subdirectory tree
    to any number of levels. To be able to do this, you have to use *recursion*. Put
    simply, a recursive method is one that calls itself. If you aren’t familiar with
    recursive programming, see [Digging Deeper](ch13s07.html#digging_deeper-id12 "Digging
    Deeper") in [Digging Deeper](ch13s07.html#digging_deeper-id12 "Digging Deeper").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序需要能够导航到整个子目录树中的任何数量的层级。为了能够做到这一点，你必须使用*递归*。简单来说，递归方法是一种调用自身的方法。如果你不熟悉递归编程，请参阅[深入挖掘](ch13s07.html#digging_deeper-id12
    "深入挖掘")中的[深入挖掘](ch13s07.html#digging_deeper-id12 "深入挖掘")。
- en: 'In the program *file_info.rb*, the `processfiles` method is recursive:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序*file_info.rb*中，`processfiles`方法是递归的：
- en: '*file_info.rb*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*file_info.rb*'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will see that when the method is first called, toward the bottom of the
    source code, it is passed the name of a directory in the variable `dirname`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，当方法首次被调用时，在源代码的底部，它通过变量`dirname`传递了目录的名称：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I’ve already assigned the parent of the current directory, given by two dots:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经分配了当前目录的父目录，由两个点表示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you are running this program in its original location (that is, the location
    to which it is extracted from this book’s source code archive), this will reference
    the directory containing the subdirectories of all the sample code files. Alternatively,
    you could assign the name of some directory on your hard disk to the variable,
    `dirname`. If you do this, don’t specify a directory containing huge numbers of
    files and directories (on Windows, *C:\Program Files* would not be a good choice,
    and *C:\* would be even worse!) because the program would then take quite some
    time to execute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个程序的原位置（即从本书的源代码存档中提取的位置）运行此程序，这将引用包含所有示例代码文件子目录的目录。或者，你也可以将硬盘上某个目录的名称分配给变量`dirname`。如果你这样做，不要指定包含大量文件和目录的目录（在Windows上，*C:\Program
    Files*不是一个好选择，而*C:\*会更糟！）因为程序执行将花费相当长的时间。
- en: 'Let’s take a closer look at the code in the `processfiles` method. Once again,
    I use `Dir.foreach` to find all the files in the current directory and pass each
    file, `f`, one at a time, to be handled by the code in a block between curly brackets.
    If `f` is a directory and is not the current one (`''.''`) or its parent directory
    (`''..''`), then I pass the full path of the directory back to the `processfiles`
    method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `processfiles` 方法中的代码。再次使用 `Dir.foreach` 来找到当前目录中的所有文件，并将每个文件 `f`
    逐个传递给花括号之间的代码块进行处理。如果 `f` 是一个目录并且不是当前目录 (`'.'`) 或其父目录 (`'..'`)，那么我将目录的完整路径传递回
    `processfiles` 方法：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If `f` is not a directory but just an ordinary data file, I find its size in
    bytes with `File.size` and assign this to the variable `filesize`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `f` 不是一个目录而是一个普通的数据文件，我会用 `File.size` 来找到它的字节数，并将这个值赋给变量 `filesize`：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As each successive file, `f`, is processed by the block of code, its size is
    calculated, and this value is added to the variable `totalbytes`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个连续的文件 `f` 被代码块处理，其大小被计算，并将这个值添加到变量 `totalbytes`：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once every file in the current directory has been passed into the block, `totalbytes`
    will be equal to the total size of all the files in the directory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前目录中的所有文件都已传递到块中时，`totalbytes` 将等于目录中所有文件的总大小。
- en: However, I need to calculate the bytes in all the subdirectories too. Because
    the method is recursive, this is done automatically. Remember that when the code
    between curly brackets in the `processfiles` method determines that the current
    file, `f`, is a directory, it passes this directory name back to *itself*—the
    `processfiles` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我还需要计算所有子目录中的字节数。因为方法是递归的，所以这会自动完成。记住，当 `processfiles` 方法中的花括号之间的代码确定当前文件
    `f` 是一个目录时，它会将这个目录名传递回 *自身*——即 `processfiles` 方法。
- en: 'Let’s imagine that you first call `processfiles` with the *C:\test* directory.
    At some point, the variable `f` is assigned the name of one of its subdirectories,
    say, *C:\test\dir_a*. Now this subdirectory is passed back to `processfiles`.
    No further directories are found in *C:\test\dir_a*, so `processfiles` simply
    calculates the sizes of all the files in this subdirectory. When it finishes calculating
    these files, the `processfiles` method comes to an end and returns the number
    of bytes in the current directory, `totalbytes`, to whichever bit of code called
    the method in the first place:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你首先用 *C:\test* 目录调用 `processfiles`。在某个时刻，变量 `f` 被分配了其子目录之一的名称，比如说，*C:\test\dir_a*。现在这个子目录被传递回
    `processfiles`。在 *C:\test\dir_a* 中没有找到更多的目录，所以 `processfiles` 只计算这个子目录中所有文件的大小。当它完成这些文件的计算后，`processfiles`
    方法结束并返回当前目录 `totalbytes` 中的字节数，这是最初调用该方法的代码部分：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, it was this bit of code inside the `processfiles` method that
    recursively called the `processfiles` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这是 `processfiles` 方法内部递归调用 `processfiles` 方法的代码：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, when `processfiles` finishes processing the files in the subdirectory, *C:\test\dir_a*,
    it returns the total size of all the files found there, and this is assigned to
    the `bytes_in_dir` variable. The `processfiles` method now carries on where it
    left off (that is, it continues from the point at which it called itself to deal
    with the subdirectory) by processing the files in the original directory, *C:\test*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当 `processfiles` 完成处理子目录 `C:\test\dir_a` 中的文件时，它返回那里找到的所有文件的总大小，并将这个值赋给 `bytes_in_dir`
    变量。`processfiles` 方法现在继续从它离开的地方（即，从它调用自身来处理子目录的点）处理原始目录 `C:\test` 中的文件。
- en: No matter how many levels of subdirectories this method encounters, the fact
    that it calls itself whenever it finds a directory ensures that it automatically
    travels down every directory pathway it finds, calculating the total bytes in
    each.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这个方法遇到多少层子目录，它每次找到目录时都调用自身的事实确保了它自动遍历它找到的每个目录路径，计算每个目录的总字节数。
- en: 'One final thing to note is that the values assigned to variables declared inside
    the `processfiles` method will change back to their “previous” values as each
    level of recursion completes. So, the `totalbytes` variable will first contain
    the size of *C:\test\test_a\test_b*, then of *C:\test\test_a*, and finally of
    *C:\test*. To keep a running total of the combined sizes of all the directories,
    you need to assign values to a variable declared *outside* the method. Here I
    use the global variable `$dirsize` for this purpose, adding to it the value of
    `totalbytes` calculated for each subdirectory processed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，分配给在 `processfiles` 方法内部声明的变量的值，在每次递归级别完成时将恢复到它们的“之前”值。因此，`totalbytes`
    变量最初将包含 *C:\test\test_a\test_b* 的大小，然后是 *C:\test\test_a* 的大小，最后是 *C:\test* 的大小。为了保持所有目录组合大小的累计总和，你需要将值分配给在方法外声明的变量。在这里，我使用全局变量
    `$dirsize` 来实现这个目的，为每个处理的子目录添加 `totalbytes` 的值：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Incidentally, although a byte may be a convenient unit of measurement for very
    small files, it is generally better to describe larger files in kilobyte sizes
    and very large files or directories in megabytes. To change bytes to kilobytes
    or to change kilobytes to megabytes, you need to divide by 1,024\. To change bytes
    to megabytes, divide by 1,048,576\. The last line of code in my program does these
    calculations and displays the results in a formatted string using Ruby’s `printf`
    method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，尽管字节可能是一个方便的测量单位，用于非常小的文件，但通常最好用千字节来描述较大的文件，用兆字节来描述非常大的文件或目录。要将字节转换为千字节或千字节转换为兆字节，需要除以
    1,024。要将字节转换为兆字节，需要除以 1,048,576。我程序中的最后一行代码执行这些计算，并使用 Ruby 的 `printf` 方法以格式化的字符串显示结果：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice that I have embedded the formatting placeholder `"%0.02fMB"` in the
    first string, and I have added a second string following a comma: `"#{$dirsize/1048576.0}"`.
    The second string calculates the directory size in megabytes, and this value is
    then substituted for the placeholder in the first string. The placeholder’s formatting
    option `"%0.02f"` ensures that the megabyte value is shown as a floating-point
    number, `"f"`, with two decimal places, `"0.02"`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在第一个字符串中嵌入了格式化占位符 `"%0.02fMB"`，并且添加了一个逗号后的第二个字符串：`"#{$dirsize/1048576.0}"`。第二个字符串计算目录大小以兆字节为单位，然后这个值被替换为第一个字符串中的占位符。占位符的格式化选项
    `"%0.02f"` 确保兆字节值以带有两位小数的浮点数 `"f"` 显示。
- en: Sorting by Size
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按大小排序
- en: Currently this program prints the file and directory names and their sizes in
    alphabetical order. But I am more interested in their *relative* sizes. It would,
    therefore, be more useful if the files were sorted by size rather than by name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个程序按字母顺序打印文件和目录的名称及其大小。但我更感兴趣的是它们的 *相对* 大小。因此，如果文件按大小而不是按名称排序，将更有用。
- en: 'To be able to sort the files, you need some way of storing a complete list
    of all file sizes. One obvious way of doing this would be to add the file sizes
    to an array. In *file_info2.rb*, I create an empty array, `$files`, and each time
    a file is processed, I append its size to the array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够对文件进行排序，你需要一种方式来存储所有文件大小的完整列表。一个明显的方法是将文件大小添加到一个数组中。在 *file_info2.rb* 中，我创建了一个空数组
    `$files`，每次处理一个文件时，我都会将其大小追加到数组中：
- en: '*file_info2.rb*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*file_info2.rb*'
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I can then sort the file sizes to display low to high values or (by sorting
    and then reversing the array) to display from high to low values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以对文件大小进行排序，以显示从低到高的值，或者（通过排序然后反转数组）以显示从高到低的值：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The only trouble with this is that I now end up with an array of file sizes
    without the associated filenames. A better solution would be to use a Hash instead
    of an Array. I’ve done this in *file_info3.rb*. First, I create two empty Hashes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的唯一麻烦是，我现在得到了一个没有关联文件名的文件大小数组。一个更好的解决方案是使用哈希而不是数组。我在 *file_info3.rb* 中实现了这一点。首先，我创建了两个空哈希：
- en: '*file_info3.rb*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*file_info3.rb*'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, when the `processfiles` method encounters a directory, it adds a new entry
    to the `$dirs` Hash using the full directory path, `mypath`, as the key and using
    the directory size, `dsize`, as the value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 `processfiles` 方法遇到目录时，它会使用完整的目录路径 `mypath` 作为键，使用目录大小 `dsize` 作为值，在 `$dirs`
    哈希中添加一个新的条目：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Key-value pairs are similarly added to the `$files` hash. When the entire structure
    of subdirectories and files has been processed by recursive calls to the `processfiles`
    method, the `$dirs` hash variable will contain key-value pairs of directory names
    and sizes, and the `$files` hash will contain key-value pairs of file names and
    sizes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，键值对被添加到 `$files` 哈希中。当子目录和文件的整个结构通过递归调用 `processfiles` 方法处理后，`$dirs` 哈希变量将包含目录名称和大小之间的键值对，而
    `$files` 哈希将包含文件名称和大小之间的键值对。
- en: 'All that remains now is for these hashes to be sorted and displayed. The standard
    `sort` method for a Hash sorts the keys, not the values. I want to sort the values
    (sizes), not the keys (names). To do this, I have defined a custom sort method
    (refer to [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes") and [Chapter 5](ch05.html
    "Chapter 5. Loops and Iterators") for guidance on defining custom comparisons
    using `<=>`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是对这些哈希进行排序并显示。对于哈希的标准 `sort` 方法是按照键排序，而不是值。我想按值（大小）排序，而不是按键（名称）。为此，我定义了一个自定义排序方法（参考[第
    4 章](ch04.html "第 4 章。数组与哈希")和[第 5 章](ch05.html "第 5 章。循环与迭代")，了解如何使用 `<=>` 定义自定义比较）：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here the `sort` method converts the `$files` Hash into nested arrays of `[key,value]`
    pairs and passes two of these, `a` and `b`, into the block between curly brackets.
    The second item (at index `[1]`) of each `[key,value]` pair provides the value.
    The sorting itself is done on the value using Ruby’s `<=>` comparison method.
    The end result is that this program now displays first a list of files in ascending
    order (by size) and then a similarly sorted list of directories. This is an example
    of its output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sort` 方法将 `$files` 哈希转换为嵌套的 `[key,value]` 对数组，并将其中两个，`a` 和 `b`，传递到花括号之间的块中。每个
    `[key,value]` 对的第二个项目（索引 `[1]`）提供了值。排序本身是通过 Ruby 的 `<=>` 比较方法在值上进行的。最终结果是，这个程序现在首先显示一个按大小升序排列的文件列表，然后是一个类似排序的目录列表。这是其输出的一个示例：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Digging Deeper
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Recursion is an important programming technique that can, however, be quite
    difficult to understand. Here I will explain recursion one step at a time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种重要的编程技术，然而，它可能相当难以理解。在这里，我将一步一步地解释递归。
- en: Recursion Made Simple
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 简化递归
- en: 'If you’ve never used recursion before, the recursive “directory-walking” methods
    in this chapter may need a little explanation. To clarify how recursion works,
    let’s look at a much simpler example. Load the *recursion.rb* program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未使用过递归，本章中递归的“目录遍历”方法可能需要一些解释。为了阐明递归是如何工作的，让我们看看一个更简单的例子。加载 *recursion.rb*
    程序：
- en: '*recursion.rb*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*recursion.rb*'
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This contains the recursive method, `addup`, whose sole purpose in life is to
    count from 1 to 3\. The `addup` method receives an integer value as an incoming
    argument, `aNum`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了一个递归方法 `addup`，它一生的唯一目的就是从 1 数到 3。`addup` 方法接收一个整数作为输入参数，`aNum`。
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There is also global variable, `$outercount`, which lives “outside” the `addup`
    method. Whenever the `addup` method executes, 1 is added to `aNum`, and 1 is also
    added to `$outercount`. Then, just so long as `$outercount` is less than 3, the
    code inside the `addup` method calls the same method (`addup`) all over again,
    passing to it the new value of `aNum`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个全局变量 `$outercount`，它“存在于”`addup` 方法之外。每当 `addup` 方法执行时，`aNum` 增加 1，`$outercount`
    也增加 1。只要 `$outercount` 小于 3，`addup` 方法内部的代码就会再次调用相同的方法（`addup`），并将新的 `aNum` 值传递给它：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s follow what happens. The process is started off by calling `addup` with
    the value 0:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随这个过程。这个过程是从调用 `addup` 并传递值 0 开始的：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `addup` method adds 1 to both `aNum` and `$outercount`, so both variables
    now have the value 1\. The test (`$outercount < 3`) evaluates to true, so `aNum`
    is passed as an argument to `addup`. Once again, 1 is added to both variables,
    so `aNum` is now 2, and `$outercount` is also 2\. Now `aNum` is once more passed
    to `addup`. Yet again 1 is added to both variables, giving each the value 3\.
    This time, however, the test condition fails since `$outercount` is no longer
    less than 3\. So, the code that calls `addup` is skipped, and you arrive at the
    last line in the method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`addup` 方法将 1 添加到 `aNum` 和 `$outercount`，因此这两个变量现在都有值 1。测试（`$outercount < 3`）评估为真，所以
    `aNum` 作为参数传递给 `addup`。再次，两个变量都增加了 1，所以 `aNum` 现在是 2，而 `$outercount` 也是 2。现在再次将
    `aNum` 传递给 `addup`。再次将 1 添加到两个变量中，使每个变量都变为 3。然而，这次测试条件失败，因为 `$outercount` 不再小于
    3。因此，调用 `addup` 的代码被跳过，你到达了方法中的最后一行：'
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This prints out the values of `aNum` and `$outercount`, which, as you expect,
    are both 3\. Having arrived at the end of this method, the “flow of control” moves
    back to the line of code immediately following the code that originally called
    the method. Here, the line of code that called the `addup` method happens to be
    inside the method itself. Here it is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出`aNum`和`$outercount`的值，正如你所预期的那样，这两个值都是3。到达这个方法的末尾后，“控制流”会返回到最初调用该方法的代码之后的下一行。在这里，调用`addup`方法的代码恰好位于方法内部。这里是它：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And the first executable line that follows this is (once again) the final line
    of the method that prints out the values of the two variables:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的第一个可执行行（再次）是方法的最后一行，它打印出两个变量的值：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, you have gone back to an earlier “point of execution”—the point at which
    you recursively called the `addup` method. At that time, the value of `aNum` was
    2, and that is its value *now*. If this seems confusing, just try to think what
    would have happened if `aNum` had been 2 and then you called some other, unrelated
    method. On returning from that other method, `aNum` would, of course, still have
    had the value 2\. That’s all that’s happened here. The only difference is that
    this method happened to call *itself* rather than some other method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你回到了一个更早的“执行点”——你递归调用`addup`方法的那一刻。当时，`aNum`的值是2，现在它仍然是这个值。如果这看起来很困惑，只需尝试想象如果`aNum`的值是2，然后你调用其他一些无关的方法会发生什么。从那个其他方法返回时，`aNum`当然仍然会有2的值。这就是这里发生的一切。唯一的区别是，这个方法恰好调用的是它自己而不是其他方法。
- en: Once again, the method exits, and control returns to the next executable line
    following the code that called the method, and `aNum`’s value has taken another
    step back into its own history—it now has the value 1\. The `$outercount` variable,
    however, lives *outside* the method and is unaffected by recursion, so it is still
    3.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，方法执行结束，控制权返回到调用该方法的代码之后的下一个可执行行，`aNum`的值又向前迈出一步回到其历史中——现在它的值是1。然而，`$outercount`变量是存在于方法之外的，并且不受递归的影响，所以它仍然是3。
- en: 'If you have access to a visual debugger, this entire process will become much
    clearer: You can place a breakpoint on line 9 (`if $outercount < 3 then`), add
    `aNum` and `$outercount` to the Watch window, and repeatedly step into the code
    after you hit the breakpoint.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够访问一个可视化的调试器，整个过程将变得更加清晰：你可以在第9行（`if $outercount < 3 then`）设置一个断点，将`aNum`和`$outercount`添加到监视窗口中，并在触碰到断点后反复进入代码。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860162.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860162.png)'
- en: This screenshot shows the recursion program being debugged visually in the IDE
    Ruby In Steel. I can step through the source code, use the call stack to keep
    track of the current “level” of recursion (how many times the addup method has
    been called), and use the Watch window to monitor the current values of the variables.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了在IDE Ruby In Steel中可视化的递归程序调试。我可以逐行通过源代码，使用调用栈来跟踪当前的“递归级别”（`addup`方法被调用的次数），并使用监视窗口来监控变量的当前值。
