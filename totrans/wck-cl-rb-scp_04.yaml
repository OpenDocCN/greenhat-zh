- en: Chapter 4. PICTURE UTILITIES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![PICTURE UTILITIES](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Photography is a wonderful hobby. It happens to be one of mine, and since I'm
    a techie, I have a monster Digital Single-Lens Reflex (DSLR) camera. I take tons
    of pictures with it and enjoy the digital editing involved afterward. But I have
    found that I take many more pictures with my digital camera than I did with my
    traditional film camera. The scripts in this chapter help me manage the daunting
    task of editing, converting, and resizing my vast photo collection. To edit 500
    pictures one at a time would take days, but with a few tweaks to these scripts,
    that time is cut down to mere minutes. Break out your photos and let's start editing!
  prefs: []
  type: TYPE_NORMAL
- en: Mass Editing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mass Editing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: massEdit.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All right, I mentioned that I like to take pictures. I mean, I *really* like
    to take pictures, and I have gigabytes of photographs to prove it. If I needed
    to manipulate all of them in some way, such as renaming, performing that action
    on each picture individually would be very time consuming. This script will take
    a group of pictures and rename them numerically to something more manageable than
    *DSC_0127.JPEG*; work that would have taken a week now takes just minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) unless ARGV[0]      puts "\n\n\nYou need to specify
    a filename:  massEdit.rb <filename>\n\n\n"      exit  end  ![](../Images/00003.jpg) name
    = ARGV[0]  x=0  ![](../Images/00004.jpg)  Dir[''*.[Jj][Pp]*[Gg]''].each do |pic|
    ![](../Images/00005.jpg)      new_name = "#{name}_#{"%.2d" % x+=1}#{File.extname(pic)}"
         puts "Renaming #{pic} ---> #{new_name}" ![](../Images/00006.jpg)     File.rename(pic,
    new_name)  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume you have a directory full of pictures from a Jamaican vacation.
    Presumably you''d want to rename the photos from *DSC_0*XXX.*jpeg* to *Jamaica*XX.*jpeg*.
    Make sure the script is in the directory that contains the pictures you want to
    rename and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '``Renaming *`DSC_0001.jpeg ---> Jamaica01.jpeg`* Renaming *`DSC_0002.jpeg --->
    Jamaica02.jpeg`* Renaming *`DSC_0003.jpeg ---> Jamaica03.jpeg`* Renaming *`DSC_0004.jpeg
    ---> Jamaica04.jpeg`* Renaming *`DSC_0005.jpeg ---> Jamaica05.jpeg`* Renaming
    *`DSC_0006.jpeg ---> Jamaica06.jpeg`* Renaming *`DSC_0007.jpeg ---> Jamaica07.jpeg`*
    Renaming *`DSC_0008.jpeg ---> Jamaica08.jpeg`* [...]``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Renaming files has to be one of the most common headaches I've dealt with throughout
    my digital photography career. This script is a really big aspirin to relieve
    the pain. The script starts by using the standard usage/error message to clue
    the user in on the proper command-line arguments ![](../Images/00002.jpg). The
    script expects you to assign a generic name for all the pictures. For the purposes
    of this example, I renamed several pictures from a trip to Jamaica, so it only
    made sense to make the generic name *Jamaica*. Now that `name` is set to the generic
    picture name *Jamaica*, the variable `x` is initialized to represent the trailing
    numbers on each photograph ![](../Images/00003.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: I decided to use the `Dir::glob` method (in the form of the shortcut `Dir::[]`)
    in this script ![](../Images/00004.jpg). The importance of `Dir::glob` can be
    seen in the expression I used to hunt for each photograph in the directory. I
    always put groups of pictures in the same folder, and running this script in that
    folder will capture every picture. In English, `*.[Jj][Pp]*[Gg]` is saying that
    every file ending in a variation of *JPEG* should be manipulated. If you don't
    believe me, create four pictures with the extensions *jpg, jpeg, JPG*, and *JPEG*.
    The `Dir::glob` will get them all, and that is great for flexibility! The `Dir::glob`
    returns an array, so the `each` method is used to iterate through each discovered
    picture. The hard part was finding all the pictures; all that's left now is to
    rename them.
  prefs: []
  type: TYPE_NORMAL
- en: I used a simple convention when renaming the pictures. The new filename is constructed
    from the object returned by the `File.extname` method, `name`, an underscore,
    and then a numeric value ![](../Images/00005.jpg). The `File.extname` method may
    not be obvious in its function; it simply grabs the file extension of the picture
    being renamed.
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself, "Why did he bother adding that crazy `x` incrementing
    piece ![](../Images/00005.jpg)"? Good question. Some operating systems aren't
    intelligent enough to know that *Jamaica10.jpeg* is the tenth photo in a series
    of pictures and not the second. So, I have succumbed to the operating systems'
    will and made the picture names have two numbers to ensure sequential display.
    If you are going to be renaming more than 99 photos, you'll want to change the
    `%.2d` to `%.3d`, which adds a third placeholder, for the hundreds place.
  prefs: []
  type: TYPE_NORMAL
- en: After the name has been set and saved to the `new_name` variable, the script
    prints out the old filename and the new filename as a courtesy to the user. To
    execute the rename, the `File.rename` method is used with the original filename
    as the first parameter and the new filename as the second parameter ![](../Images/00006.jpg).
    That's all there is to mass file renaming!
  prefs: []
  type: TYPE_NORMAL
- en: Image Information Extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image Information Extraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: imageInfo.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a wealth of information about a digital picture stored within the file
    itself. Some of the picture's data, such as colors, resolution, exposure, and
    flash settings, can be useful as you learn your craft. This script will help you
    pull the data out of your pictures for further analysis, giving insight into your
    best (and worst) shots.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''exifr''  include EXIFR  ![](../Images/00003.jpg) unless
    ARGV[0] and File.exists?(ARGV[0])      puts "\n\n\nYou need to specify a filename:
     ruby imageInfo.rb <filename>"      exit  end   ![](../Images/00004.jpg) info
    = JPEG.new(ARGV[0])  ![](../Images/00005.jpg) File.open("info_#{File.basename(ARGV[0])}.txt",
    "w") do |output| ![](../Images/00006.jpg)     output.puts info.exif.to_hash.map{
    |k,v| "#{k}: #{v}"}  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script takes an image file as input and returns a detailed text file that
    lists all of the available information stored within the image. In this example,
    I used a Nikon D50 DSLR camera image. Type the following to run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Image Description: Make:                       NIKON CORPORATION Model:  
                       NIKON D50 Orientation:                EXIFR::TIFF::TopLeftOrientation
    X Resolution:               300 Y Resolution:               300 Resolution unit:
               2 Software:                   Ver.1.00 Date & Time:                Sat
    Jun 02 13:40:26 +0400 2007 YCB cr positioning:         2 sensing_method:      
          2 color_space:                1 metering_mode:              5 x_resolution:
                  300 white_balance:              0 f_number:                   9
    saturation:                 0 pixel_x_dimension:          3008 light_source:  
                0 date_time_original:         Wed Sep 12 05:52:34 -0400 2007 y_resolution:
                  300 resolution_unit:            2 digital_zoom_ratio:         1
    subsec_time:                70 exposure_program:           0 ycb_cr_positioning:
            2 sharpness:                  0 pixel_y_dimension:          2000 flash:
                         0 date_time_digitized:        Wed Sep 12 05:52:34 -0400 2007
    make:                       NIKON CORPORATION focal_length_in_35mm_film:  82 subsec_time_original:
          70 exposure_bias_value:        0 focal_length:               55 model:  
                       NIKON D50 software:                   Ver.1.00 scene_capture_type:
            0 subsec_time_digitized:      70 max_aperture_value:         5 subject_distance_range:
        0 custom_rendered:            0 compressed_bits_per_pixel:  4 date_time:  
                   Wed Sep 12 05:52:34 -0400 2007 gain_control:               0 exposure_mode:
                 0 exposure_time:              1/320`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How about that for information hidden in a digital photograph? The information
    isn't really hidden; it's placed in an image according to the *Exchangeable Image
    File Format (EXIF)*. In addition to the information listed above, geographic information
    can also be included in the EXIF section of the image file if the camera has GPS
    capabilities. Every camera writes to its images differently, so check your camera
    for the specifics.
  prefs: []
  type: TYPE_NORMAL
- en: This script relies on the exifr library to retrieve the important data in the
    image, so the library is required ![](../Images/00002.jpg). This script also contains
    an `include` statement that prevents us from having to type `EXIFR` in front of
    every `exifr` method call. Next is the command-line argument verification ![](../Images/00003.jpg).
    The `unless` statement verifies that a file was included at the command line and
    that it is actually a file. Command-line arguments make script execution a bit
    more streamlined, which is why you see them used so frequently throughout this
    book. If a command-line argument is provided and the file exists, then the script
    creates a new `JPEG` object called `info` ![](../Images/00004.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is an exercise in writing to a file, which you may recall from
    previous chapters. I've condensed the code section to a few lines. Instead of
    initializing a new `File` object, saving it to a variable, then directing output
    to the variable, I just pass the `File` object as part of the code block ![](../Images/00005.jpg).
    Because of the differences with each camera's EXIF output, not all of the available
    fields will be used. For example, if your camera does not support the GPS feature,
    then all of those fields will be blank. I chose to use the `to_hash` function
    in conjunction with `map` to convert the EXIF output to something easily readable
    ![](../Images/00006.jpg). In the results, the empty fields are removed because
    `nil` attributes don't concern us. You can modify the output to display the fields,
    but I omit them here for brevity's sake.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are comfortable with the data in the EXIF section of your images, you
    can tweak this script to output only what is necessary. Many professional photographers
    are interested in viewing specific aspects of the camera configuration for a given
    photograph. This script is a tool that is entirely customizable. Take a look at
    the options and see what uses you might come up with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Thumbnail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Thumbnail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: thumbnail.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thumbnails are useful for displaying multiple images at the same time, especially
    on the Web. A perfect example is the ability to quickly view 25 photographs in
    a photo gallery without having to click *next* or wait for each large image to
    load. With lots of pictures to view, thumbnails can make browsing a much more
    relaxing and enjoyable experience. I find myself getting frustrated with websites
    that post each picture as big as possible so you end up with a huge stack of pictures
    that you have to scroll through. This script is the first step in making a web
    photo gallery. If you have the need for sample images for web design or smaller
    image sizes for faster transfers, then this script is for you.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''RMagick'' ![](../Images/00003.jpg) include
    Magick ![](../Images/00004.jpg) Dir[''*.[Jj][Pp]*[Gg]''].each do |pic| ![](../Images/00005.jpg)  
      image = Image.read(pic)[0] ![](../Images/00006.jpg)     next if pic =~ /^th_/
         puts "Scaling down by 10% --- #{pic}" ![](../Images/00007.jpg)     thumbnail
    = image.scale(0.10)      if File.exists?("th_#{pic}")          puts "Could not
    write file, thumbnail already exists."          next      end ![](../Images/00008.jpg)  
      thumbnail.write "th_#{pic}"  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run this script from the same directory as the images are located by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby thumbnail.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The result will be new images that are 10 percent of the original size called:'
  prefs: []
  type: TYPE_NORMAL
- en: '`th_DSC_0001.JPG th_DSC_0002.JPG th_DSC_0003.JPG th_DSC_0004.JPG th_DSC_0005.JPG`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script is relatively small owing to the RMagick library and ImageMagick's
    power. Most of the work happens in the background—as it should! This is the first
    script that uses RMagick's methods, so I will take a moment to explain what RMagick
    is all about.
  prefs: []
  type: TYPE_NORMAL
- en: RMagick is the Ruby way to interface with ImageMagick. You're probably thinking,
    "What's ImageMagick?" ImageMagick is a free, open source suite of tools used to
    manipulate images. Now that we have the "Magick" straight, you must have the ImageMagick
    suite installed on your machine ([http://www.imagemagick.org/](http://www.imagemagick.org/)),
    and you must also have the Ruby gem RMagick installed. Now we can get to the good
    stuff.
  prefs: []
  type: TYPE_NORMAL
- en: With RMagick, you will find numerous methods to manipulate image files. For
    instance, when creating thumbnails, there are several choices, such as `resize`,
    `scale`, and `thumbnail`. But don't worry about that until you get the hang of
    RMagick.
  prefs: []
  type: TYPE_NORMAL
- en: This script begins by requiring RMagick ![](../Images/00002.jpg). ImageMagick
    isn't required because RMagick handles all of the interactions. The next line
    includes Magick, which prevents the script from specifically calling each Magick
    method ![](../Images/00003.jpg). Instead of `Magick::Image.read()`, I can simply
    type `Image.read()`. Again, by using an `include`, you save space and typing.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the directory scan ![](../Images/00004.jpg). Learn this line if you
    plan on doing much directory searching while writing scripts. The line tells Ruby
    to find every file within the current directory that matches some filename with
    a variation of the JPEG extension. Next, the block starts to manipulate every
    JPEG image that is found.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of any image manipulation with RMagick is reading the image into
    an RMagick object ![](../Images/00005.jpg). Next, we need to ensure we aren't
    making a thumbnail out of a thumbnail. If the filename matches the regular expression
    (i.e., begins with *th*_), then it is skipped and the next image will be processed
    ![](../Images/00006.jpg). The script outputs the result by scaling the picture
    down to 10 percent of the original size ![](../Images/00007.jpg). We use the method
    `scale` and 0.10 to signify 10 percent and save all of the manipulations to a
    variable appropriately named `thumbnail`. The last step is to output the file
    with the new filename. As always, we look before we write, and if no other files
    with the new name exist, the thumbnail is written to the directory ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some variations to this script are saving the thumbnails into a separate folder
    or running through subdirectories searching for images. One of my colleagues even
    made an addition to label images based on the color heuristics. I'll leave these
    to your amusement.
  prefs: []
  type: TYPE_NORMAL
- en: Resize a Picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resize a Picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: resizePhoto.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Digital SLR cameras provide tremendous resolution, but that makes for very large
    files. Many times I have found myself wanting to use a picture in a website or
    email and am forced to fire up the GIMP to shrink the pictures to a more manageable
    size. This script will tear through shrinking a picture to whatever size you want.
    We already covered how to rip through files to generate thumbnails in a previous
    script (see "#24 Creating a Thumbnail" on [Creating a Thumbnail](../Text/dummy_split_170.html#filepos355400)).
    This script is similar, but instead of shrinking everything to 10 percent, we'll
    set the final dimensions in the code—a nice feature if you're embedding images
    into the frame of a website.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''RMagick''  include Magick  ![](../Images/00003.jpg) unless
    ARGV[0]      puts "\n\n\nYou need to specify a filename:  resizePhoto.rb <filename>\n\n\n"
         exit  end  ![](../Images/00004.jpg) img = Image.read(ARGV[0]).first  width
    = nil  height = nil  ![](../Images/00005.jpg) img.change_geometry!(''400x400'')
    do |cols, rows, img| ![](../Images/00006.jpg)      img.resize!(cols, rows)   
      width = cols      height = rows  end   file_name = "#{width}x#{height}_#{ARGV[0]}"   if
    File.exists?(file_name)      puts "File already exists.  Unable to write file."
         exit  end  ![](../Images/00007.jpg) img.write(file_name)`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most of the picture utility scripts, this takes an image as a command-line
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The result will be a new image created called:'
  prefs: []
  type: TYPE_NORMAL
- en: '``*`400x267_DSC_0001.JPG`*``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using two methods from the RMagick bag of tricks, this script resizes an image
    while maintaining the aspect ratio. First we `require` RMagick and `include Magick`
    ![](../Images/00002.jpg). Just to make sure the user is playing by our rules,
    we run his input through the verification line. If command-line arguments aren't
    supplied, he needs to be educated on how to run the script ![](../Images/00003.jpg).
    To begin the image manipulation, a new `Image` object is initialized, creatively
    called `img` ![](../Images/00004.jpg). `height` and `width` are initialized, too,
    and will be used later for file naming specifics.
  prefs: []
  type: TYPE_NORMAL
- en: The first method, and the one which maintains the aspect ratio, is `change_geometry`
    ![](../Images/00005.jpg). I used the exclamation point variation to directly manipulate
    the image. In plain English, line ![](../Images/00005.jpg) says "the image must
    be smaller than 400 by 400" and whatever measurement exceeds the limits first
    will determine the other measurement. So, for an original image of 3,008 by 2,000
    and a limit of 400 by 400, the width measurement is the larger of the width and
    height. To preserve the aspect ratio, the image will be 400 by 267\. Of course,
    you could manually calculate the values to insert into the resize method, but
    that doesn't allow for much flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Once `change_geometry!` has determined the correct aspect ratio, `resize!` is
    called upon to execute the new measurements ![](../Images/00006.jpg) (again, the
    exclamation point signifies direct image manipulation). Two other variables, `width`
    and `length`, store the measurements for use when naming the file. The new image
    name will be the width by the length, all prepended to the original filename ![](../Images/00007.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script is straightforward, but some interesting tweaks are possible; you
    could make the dimensions a command-line argument or choose from a few preset
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Watermark to Pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a Watermark to Pictures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: watermark.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to receive credit for your pictures while sharing them on the Internet,
    watermarks are a nice tool (see [Figure 4-1](#filepos374986)). Watermarks help
    ensure you remain the owner of your digital property. If there is a standard watermark
    you use, this script can incorporate it—big or small.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cover image with watermark](../Images/00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. Cover image with watermark
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''RMagick''  include Magick   unless ARGV[0]
    and File.exists?(ARGV[0])      puts "\n\n\nYou need to specify a filename:  watermark.rb
    <filename>\n\n\n"      exit  end   img = Image.read(ARGV[0]).first ![](../Images/00003.jpg) watermark
    = Image.new(600, 50)  ![](../Images/00004.jpg) watermark_text = Draw.new ![](../Images/00005.jpg) watermark_text.annotate(watermark,
    0,0,0,0, "No Starch Press") do ![](../Images/00006.jpg)     watermark_text.gravity
    = CenterGravity      self.pointsize = 50      self.font_family = "Arial"     
    self.font_weight = BoldWeight      self.stroke = "none"  end  ![](../Images/00007.jpg) watermark.rotate!(45)
    ![](../Images/00008.jpg) watermark = watermark.shade(true, 310, 30) ![](../Images/00009.jpg) img.composite!(watermark,
    SouthWestGravity, HardLightCompositeOp)  watermark.rotate!(-90)  img.composite!(watermark,
    NorthWestGravity, HardLightCompositeOp)  watermark.rotate!(90)  img.composite!(watermark,
    NorthEastGravity, HardLightCompositeOp)  watermark.rotate!(-90)  img.composite!(watermark,
    SouthEastGravity, HardLightCompositeOp)      if File.exists?("wm_#{ARGV[0]}")
         puts "Image already exists.  Unable to write file."      exit  end   puts
    "Writing wm_#{ARGV[0]}" ![](../Images/00011.jpg) img.write("wm_#{ARGV[0]}")`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the script with the image to be watermarked as the command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The result will be a new image with *No Starch Press* in every corner. The
    image is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '``*`wm_DSC_0001.JPG`*``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Watermarking has become the norm for rights holders in the age of ubiquitous
    copying. This script really flexes the RMagick muscles, so I'll spend a bit more
    time explaining exactly what is going on. The first two instructions are the same
    as in the previous RMagick script, save the usage line ![](../Images/00002.jpg).
    To begin editing the image and creating the watermark, the script reads the photograph
    into an `Image` object called `img`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is designing the watermark that will be placed in our photograph.
    A new image measuring 600 by 50 pixels is created and called `watermark` ![](../Images/00003.jpg).
    This image isn't anything as of yet, but it will be after we follow a few more
    instructions. If you already have an image you want to use for watermarking, this
    is the area in which you'd want to put it. Since we want the words *No Starch
    Press* on the picture, the script will create them from scratch. A new `Draw`
    object is created which will hold our wicked cool text ![](../Images/00004.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: After the `Draw` and `Image` objects have been created, the `annotate` method
    is called on the `Draw` object ![](../Images/00005.jpg). The arguments passed
    to this method are the image which will be annotated, width of the rectangle,
    height of the rectangle, x-axis offset of the text, y-axis offset of the text,
    and, finally, the text to use. I specified zeros for the width and height to let
    the method know to use the entire 600-by-50-pixel rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `annotate` method, the text is styled and centered. In this script,
    I've centered the text and made the font Arial, bold weight, and size 50 points
    ![](../Images/00006.jpg). Play around with these variables to customize the text
    to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The watermark has now been created as flat text. The next section will include
    placing the watermark image on the original photograph. You can literally put
    the watermark anywhere in the photograph that you think is appropriate. Caution:
    Try to disrupt the digital content as little as possible. In this example, the
    first watermark placement is on the lower-left corner of the photograph.'
  prefs: []
  type: TYPE_NORMAL
- en: I wanted the watermark to be angled so that when all four watermarks are set,
    the picture looks framed. To achieve the proper angles, I used the `.rotate!`
    method, which manipulates the image ![](../Images/00007.jpg). The exclamation
    point reminds the user that the rotation will be "in place," or saved to the same
    variable permanently.
  prefs: []
  type: TYPE_NORMAL
- en: To make the watermark stand out, I used the shade method, which adds a cool
    3D effect ![](../Images/00008.jpg). Essentially, these arguments make the image
    appear to be embossed and transparent. The first argument turns the shade attribute
    on, and the last two arguments specify the angle and height for the apparent light
    source. RMagick's website ([http://rmagick.rubyforge.org/](http://rmagick.rubyforge.org/))
    has a great explanation of the different shades.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the watermarks, the `composite` method is used to blend the original
    photo and watermark images together ![](../Images/00009.jpg). The `composite`
    method is given the watermark image, the type of *gravity* (or where on the image
    the watermark will be placed), and also the `composite operator` to use. For a
    complete listing of `CompositeOperator` options, visit [http://www.imagemagick.org/RMagick/doc/constants.html#CompositeOperator/](http://www.imagemagick.org/RMagick/doc/constants.html#CompositeOperator/).
    The final step is to ensure that a file with the same name doesn't already exist
    and then write the file ![](../Images/00011.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Convert to Black and White
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convert to Black and White
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: bwPhoto.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today most computer monitors are compared by how many colors they can display.
    Television screens can display almost 100 percent of all the colors a human eye
    can perceive. Yet, with all the colors in the world, black-and-white photography
    still captures beauty like nothing else. This script is awesome.
  prefs: []
  type: TYPE_NORMAL
- en: A year ago, I had some of my orchid photographs on display in an art gallery
    in Alexandria, Virginia. One of the photographs was of a very ugly blossom, a
    sort of cream with muddled brown spots. It wasn't the vibrant fuchsia nor the
    angelic white most commonly associated with orchids. However, when the flower
    was converted to black and white, it showed itself to be a rare beauty. Now it's
    one of my personal favorites. This just goes to show the power of black-and-white
    photography.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''RMagick''  include Magick   unless ARGV[0]      puts "\n\n\nYou
    need to specify a filename:  bwPhoto.rb <filename>\n\n\n"      exit  end   new_img
    = "bw_#{ARGV[0]}" ![](../Images/00002.jpg) img = Image.read(ARGV[0]).first  ![](../Images/00003.jpg) img
    = img.quantize(256, GRAYColorspace)   if File.exists?(new_img)      puts "Could
    not write file. Image name already exists."      exit  end  ![](../Images/00004.jpg) img.write(new_img)`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most of the picture utility scripts, this one takes an image as a command-line
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The result will be a new image called:'
  prefs: []
  type: TYPE_NORMAL
- en: '``*`bw_DSC_0001.JPG`*``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elegance of this script really impresses me every time I look at it. In
    essentially three lines of Ruby code, the script can completely transform a picture.
    (You could condense the script to one line, but I'll let you figure out how to
    do that.) By now, you should be getting used to the user input validation of command-line
    arguments. The main body begins by reading in the image that will be converted
    to black and white ![](../Images/00002.jpg). Next, the image is *quantized*, which
    means that the colors within the image are analyzed and a subset is used to represent
    the picture ![](../Images/00003.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The `GRAYColorspace` is used as the second argument to convert the color image
    from red-green-blue (RGB) to grayscale. The first argument of `quantize` tells
    RMagick how many colors you want to use during the sampling. For a purely black-and-white
    photo, the first argument would be two. After the quantize method finishes execution,
    `img` will contain the black-and-white image ![](../Images/00004.jpg). Naturally,
    we want to save the image by using the `write` method. The file will be prepended
    with `bw_` to signify a black-and-white image.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Photo Gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Photo Gallery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: createGallery.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Electronic photo galleries provide a perfect forum for sharing pictures with
    friends and family. Stacks of full-size photos aren't very inviting, nor do they
    stand up by themselves. A nice gallery is needed to present them in the proper
    way. This is a quick photo gallery script with a clean, simple style. The gallery
    can be modified and personalized as much as you like. You can get fancy, but for
    this example, I'll keep it as simple as possible. Familiarity with HTML is helpful
    but not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''RMagick''  require ''ftools''  include
    Magick  ![](../Images/00003.jpg) photos_row = 4  table_border = 1  html_rows =
    1  ![](../Images/00004.jpg) File.makedirs("gallery/thumbs", "gallery/resize")
    ![](../Images/00005.jpg) output = File.new("gallery/index.html","w+b")  html =
    <<EOF  <html>      <head>          <title>My Photos</title>      </head>     
    <body bgcolor="#d0d0d0">          <h1>Welcome To My Photo Gallery</h1>       
      <table border=#{table_border}>  EOF  output.puts html  ![](../Images/00006.jpg) Dir[''*.[Jj][Pp]*[Gg]''].each
    do |pic| ![](../Images/00007.jpg)      thumb = Image.read(pic)[0]       thumb.change_geometry!(''150x150'')
    do |cols, rows, img|           thumb.resize!(cols, rows)       end       if File.exists?("gallery/thumbs/th_#{pic}")
              puts "Could not write file. Thumbnail already exists."       else   
           thumb.write "gallery/thumbs/th_#{pic}"       end  ![](../Images/00008.jpg)  
       resize = Image.read(pic)[0]        resize.change_geometry!(''800x600'') do
    |cols, rows, img|          resize.resize!(cols, rows)       end       if File.exists?("gallery/resize/resize_#{pic}")
             puts "Could not write file. Resized image already exists."       else
             resize.write("gallery/resize/resize_#{pic}")       end  ![](../Images/00009.jpg)  
       if html_rows % photos_row == 1           output.puts "\n<tr>"       end  ![](../Images/00011.jpg) output.puts
    <<EOF          <td><a href="resize/resize_#{pic}/" title="#{pic}"  target="_blank"><img
    src="thumbs/th_#{pic}" alt="#{pic}"/></a></td>  EOF       if html_rows % photos_row
    == 0          output.puts "</tr>"      end      html_rows+=1  end   unless html_rows
    % photos_row == 1      output.puts "</tr>"  end  ![](../Images/00012.jpg) output.puts
    "</body>\n</html>"  output.puts "<!-- Courtesy of No Starch Press: Wicked Cool
    Ruby Scripts -->"  output.close`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the code, simply run the script from the image directory in which you
    want the photo gallery created.
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby createGallery.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The result is a self-contained photo gallery in the same directory as the pictures
    ([Figure 4-2](../Text/dummy_split_201.html#filepos400625)). Navigate to the *gallery*
    directory and open *index.html*. There will be two subdirectories containing the
    thumbnail and resized images: *thumbs* and *resize*.'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two libraries are required in this script ![](../Images/00002.jpg). RMagick
    is required for the image manipulation, and ftools is required because the script
    will create three directories. Magick is included so each RMagick method doesn't
    have to be called with an explicit (or fully qualified) receiver. Next, the three
    variables are initialized that will determine the final HTML output ![](../Images/00003.jpg).
    Two of these variables will format the web page output, and the third variable
    is a counter. The script is set up to display four images per row, but you can
    simply change the variable `photo_row` to any number you prefer. The same options
    go for the `table_border`, which specifies how thick the HTML table border will
    be.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo gallery made by Ruby](../Images/00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. Photo gallery made by Ruby
  prefs: []
  type: TYPE_NORMAL
- en: The directory structure the photo gallery uses includes a main folder called
    *gallery* with a separate directory for the thumbnail images and resized images.
    To set up this directory structure, `File.makedirs` is called ![](../Images/00004.jpg).
    Each argument within the method will create a directory. Additionally, if the
    directory is buried within several directories, the method will create the parent
    directories. So, for *gallery/thumbs*, I don't need to separately specify the
    folder *gallery* since the method creates the directory *gallery* while making
    *thumbs*.
  prefs: []
  type: TYPE_NORMAL
- en: The main result of this script will be a web page. We'll call the web page *index.html*
    so a web server will know it is the main photo gallery page. Because *index.html*
    doesn't exist, we must create it using the `File.new` method. The file will be
    created in our new *gallery* directory ![](../Images/00005.jpg). The next block
    of code is called a *here-doc*, and it lets me write text as I would in a normal
    text editor. I don't have to worry about escaping quotes or adding `\n` for line
    breaks—the here-doc preserves it all. The here-doc in this script contains the
    beginnings of the HTML output with several tags. The first few pieces create the
    web page title, and the last two lines create the bold title and start our table.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the directories have been put in place and the web page has been created,
    it''s time to start adding some photos. To do this, we need to scan the directory
    for any JPEG images. If you''re going to be adding other types of images, you''ll
    need to change this line accordingly ![](../Images/00006.jpg). The main directory
    traversal block is broken down into three distinct sections: thumbnail creation,
    resizing the original image, and adding the appropriate HTML code to our web page.'
  prefs: []
  type: TYPE_NORMAL
- en: To create thumbnails, I used a different function than in the previous thumbnail
    script (see "#24 Creating a Thumbnail" on [Creating a Thumbnail](../Text/dummy_split_170.html#filepos355400)).
    The reason I used a different method was to ensure uniformity within the web page.
    I wanted the thumbnails to all be the same size since it looks better. First,
    a new Image object is created, called `thumb` ![](../Images/00007.jpg). Then `thumb`
    is passed into the aspect ratio preserving `change_geometry!` method. Thumbnails
    are typically around 150 by 150 pixels, so that is the limit set as the `change_geometry!`
    argument. After the `thumb` image had been resized, it was written into the *thumbs*
    directory with a `th_` prepended to the image name.
  prefs: []
  type: TYPE_NORMAL
- en: A similar manipulation of the image was done to resize it ![](../Images/00008.jpg).
    Instead of limiting the image to 150 by 150 pixels, a larger scale of 800 by 600
    pixels was used. The full-scale size can be as big as the screen resolution of
    your viewers. In my experience with website visitors, most have a resolution of
    1,280 by 1,024, but there are some who choose a smaller 800-by-600 resolution.
    You'll need to keep that in mind when deciding on an appropriate image resolution
    for your purposes. When creating the thumbnails and resizing the image, we never
    want to overwrite an existing file. So, an error message is displayed stating
    the image name that could not be created because that image name already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the images have been created, the script turns its attention back to
    the HTML file. This script uses a table to organize the images. With a bit of
    math trickery and some precise calculations, that table is symmetrical ![](../Images/00009.jpg).
    The `%`, or *modulo*, operator returns the remainder of a division operation.
    If there is a remainder of 1, the script knows a new row should be started. The
    script uses that same modulo operator, now looking for a remainder of 0, to calculate
    whether a row should be closed. No matter what number `$photos_row` contains,
    a table matching the specifications will be created. In between each row are columns
    signified by `<td>` and `</td>`: This is where each image is inserted. Again,
    using a here-doc on line ![](../Images/00011.jpg), the HTML text tells the web
    page to insert a new column entry, a hyperlink to the larger image that opens
    in a new window, a title, and, lastly, the image thumbnail. This process is done
    for each image.'
  prefs: []
  type: TYPE_NORMAL
- en: Once all the images have been manipulated and added to the web page, the script
    checks to see if a row needs to be closed and then outputs some final HTML comments
    to tidy up the web page ![](../Images/00012.jpg). The HTML file is then closed.
  prefs: []
  type: TYPE_NORMAL
- en: You can test the image gallery by going to the gallery folder and clicking the
    *index.html* file you just created. Building a photo gallery doesn't get much
    easier than that!
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take some time to play around with the embedded HTML code and make the photo
    gallery your own! There are endless possibilities with tables, colors, fonts,
    and so on. If you come up with a wicked cool photo gallery, feel free to send
    it to me.
  prefs: []
  type: TYPE_NORMAL
