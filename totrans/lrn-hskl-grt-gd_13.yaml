- en: Chapter 13. A Fistful of Monads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。一打monad
- en: When we first talked about functors in [Chapter 7](ch07.html "Chapter 7. Making
    Our Own Types and Type Classes"), you saw that they are a useful concept for values
    that can be mapped over. Then, in [Chapter 11](ch11.html "Chapter 11. Applicative
    Functors"), we took that concept one step further with applicative functors, which
    allow us to view values of certain data types as values with contexts and use
    normal functions on those values while preserving the meaning of those contexts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第7章](ch07.html "第7章。创建自己的类型和类型类")中首次讨论functor时，你看到了它们对于可以映射的值是一个有用的概念。然后，在第11章[第11章。应用functor](ch11.html
    "第11章。应用functor")中，我们通过应用functor进一步发展了这个概念，它允许我们将某些数据类型的值视为带有上下文的值，并在这些值上使用正常函数，同时保留这些上下文的意义。
- en: In this chapter, you’ll learn about *monads*, which are just beefed-up applicative
    functors, much like applicative functors are beefed-up functors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习关于*monad*的内容，它们只是增强的应用functor，就像应用functor是增强的functor一样。
- en: Upgrading Our Applicative Functors
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级我们的应用functor
- en: 'When we started off with functors, you saw that it’s possible to map functions
    over various data types using the `Functor` type class. The introduction to functors
    had us asking the question, “When we have a function of type `a -> b` and some
    data type `f a`, how do we map that function over the data type to end up with
    `f b`?” You saw how to map something over a `Maybe a`, a list `[a]`, an `IO a`,
    and so on. You even saw how to map a function `a -> b` over other functions of
    type `r -> a` to get functions of type `r -> b`. To answer the question of how
    to map a function over some data type, all we needed to do was look at the type
    of `fmap`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用functor时，你看到了使用`Functor`类型类在各个数据类型上映射函数是可能的。functor的介绍让我们提出了这样的问题：“当我们有一个类型为`a
    -> b`的函数和一些数据类型`f a`时，我们如何将这个函数映射到数据类型上，最终得到`f b`？”你看到了如何将函数映射到`Maybe a`、列表`[a]`、`IO
    a`等上。你甚至看到了如何将函数`a -> b`映射到其他类型为`r -> a`的函数上，以得到类型为`r -> b`的函数。为了回答如何将函数映射到某些数据类型的问题，我们只需要查看`fmap`的类型：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802674.png.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802674.png.jpg)'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And then we just needed to make it work for our data type by writing the appropriate
    `Functor` instance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需要通过编写适当的`Functor`实例来使它适用于我们的数据类型。
- en: 'Then you saw a possible improvement of functors and had a few more questions.
    What if that function `a -> b` is already wrapped inside a functor value? Say
    we have `Just (*3)`—how do we apply that to `Just 5`? What if we don’t want to
    apply it to `Just 5`, but to a `Nothing` instead? Or if we have `[(*2),(+4)]`,
    how do we apply that to `[1,2,3]`? How could that even work? For this, the `Applicative`
    type class was introduced:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你看到了functor可能的改进，并提出了更多问题。如果函数`a -> b`已经包裹在一个functor值中，那会怎样？比如说我们有`Just (*3)`——我们如何将其应用于`Just
    5`？如果我们不想将其应用于`Just 5`，而是应用于`Nothing`呢？或者如果我们有`[(*2),(+4)]`，我们如何将其应用于`[1,2,3]`？这怎么可能呢？为此，引入了`Applicative`类型类：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You also saw that you can take a normal value and wrap it inside a data type.
    For instance, we can take a `1` and wrap it so that it becomes a `Just 1`. Or
    we can make it into a `[1]`. It could even become an I/O action that does nothing
    and just yields `1`. The function that does this is called `pure`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了，你可以将一个普通值包裹在数据类型中。例如，我们可以取一个`1`并把它包裹成`Just 1`。或者我们可以把它变成`[1]`。它甚至可以成为一个什么也不做，只是产生`1`的I/O操作。执行这个操作的函数被称为`pure`。
- en: 'An applicative value can be seen as a value with an added context—a *fancy*
    value, to put it in technical terms. For instance, the character `''a''` is just
    a normal character, whereas `Just ''a''` has some added context. Instead of a
    `Char`, we have a `Maybe Char`, which tells us that its value might be a character,
    but it could also be an absence of a character. The `Applicative` type class allows
    us to use normal functions on these values with context, and that context is preserved.
    Observe an example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用值可以看作是添加了上下文的值——用技术术语来说，就是一个*花哨*的值。例如，字符`'a'`只是一个普通字符，而`Just 'a'`则有一些额外的上下文。我们不是有一个`Char`，而是一个`Maybe
    Char`，这告诉我们它的值可能是一个字符，但也可能是一个字符的缺失。`Applicative`类型类允许我们使用带有上下文的正常函数对这些值进行操作，并且这个上下文被保留。观察一个例子：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So now that we treat them as applicative values, `Maybe a` values represent
    computations that might have failed, `[a]` values represent computations that
    have several results (nondeterministic computations), `IO a` values represent
    values that have side effects, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们将它们视为应用值，`Maybe a`的值代表可能失败的计算，`[a]`的值代表有多个结果（非确定性计算）的计算，`IO a`的值代表有副作用的价值，等等。
- en: 'Monads are a natural extension of applicative functors, and they provide a
    solution to the following problem: If we have a value with a context, `m a`, how
    do we apply to it a function that takes a normal `a` and returns a value with
    a context? In other words, how do we apply a function of type `a -> m b` to a
    value of type `m a`? Essentially, we want this function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是应用函子的自然扩展，并且它们为以下问题提供了一个解决方案：如果我们有一个带有上下文的价值`m a`，我们如何应用一个接受正常`a`并返回带有上下文的价值的函数？换句话说，我们如何将类型为`a
    -> m b`的函数应用到类型为`m a`的价值上？本质上，我们想要这个函数：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we have a fancy value and a function that takes a normal value but returns
    a fancy value, how do we feed that fancy value into the function? This is the
    main concern when dealing with monads. We write `m a` instead of `f a`, because
    the `m` stands for `Monad`, but monads are just applicative functors that support
    `>>=`. The `>>=` function is called *bind*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个复杂的价值和一个接受正常值但返回复杂值的函数，我们如何将这个复杂的价值喂给函数？这是处理单子时的主要关注点。我们写`m a`而不是`f a`，因为`m`代表`Monad`，但单子只是支持`>>=`的应用函子。`>>=`函数被称为*绑定*。
- en: When we have a normal value `a` and a normal function `a -> b`, it’s really
    easy to feed the value to the function—we just apply the function to the value
    normally, and that’s it. But when we’re dealing with values that come with certain
    contexts, it takes a bit of thinking to see how these fancy values are fed to
    functions and how to take into account their behavior. But you’ll see that it’s
    as easy as one, two, three.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个正常的值`a`和一个正常的函数`a -> b`时，将值喂给函数是非常容易的——我们只需正常地将函数应用到值上，就是这样。但是当我们处理带有特定上下文的价值时，需要一些思考才能看到这些复杂的价值是如何喂给函数的，以及如何考虑它们的行为。但你会看到，这就像一、二、三那么简单。
- en: Getting Your Feet Wet with Maybe
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过`Maybe`入门
- en: Now that you have a vague idea of what monads are about, let’s make that idea
    a little more concrete. Much to no one’s surprise, `Maybe` is a monad. Here, we’ll
    explore it a bit more to see how it works in this role.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对单子的概念有了模糊的了解，让我们使这个想法更加具体。不出所料，`Maybe`是一个单子。在这里，我们将更深入地探讨它在这个角色中的工作方式。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you understand applicative functors at this point. (We discussed them
    in [Chapter 11](ch11.html "Chapter 11. Applicative Functors").) You should have
    a feel for how the various `Applicative` instances work and what kinds of computations
    they represent. To understand monads, you’ll be taking your existing applicative
    functor knowledge and upgrading it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你现在理解了应用函子（我们在[第11章](ch11.html "第11章。应用函子")中讨论了它们）。你应该对各种`Applicative`实例的工作方式和它们所代表的计算类型有所感觉。为了理解单子，你将把现有的应用函子知识提升到更高层次。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802676.png.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802676.png.jpg)'
- en: A value of type `Maybe a` represents a value of type `a`, but with the context
    of possible failure attached. A value of `Just "dharma"` means that the string
    `"dharma"` is there. A value of `Nothing` represents its absence, or if you look
    at the string as the result of a computation, it means that the computation has
    failed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`Maybe a`的值代表类型为`a`的值，但带有可能失败上下文。`Just "dharma"`的值意味着字符串`"dharma"`存在。`Nothing`的值代表其不存在，或者如果你把字符串看作是计算的结果，它意味着计算失败了。
- en: When we looked at `Maybe` as a functor, we saw that if we want to `fmap` a function
    over it, the function is mapped over what’s inside if that’s a `Just` value. Otherwise,
    the `Nothing` is kept, because there’s nothing to map it over!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们把`Maybe`作为一个函子来考虑时，我们看到了，如果我们想要在它上面`fmap`一个函数，如果里面是`Just`值，函数会被映射到其内部。否则，会保留`Nothing`，因为没有东西可以映射！
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As an applicative functor, `Maybe` functions similarly. However, with applicative
    functors, the function itself is in a context, along with the value to which it’s
    being applied. `Maybe` is an applicative functor in such a way that when we use
    `<*>` to apply a function inside a `Maybe` to a value that’s inside a `Maybe`,
    they both must be `Just` values for the result to be a `Just` value; otherwise,
    the result is `Nothing`. This makes sense. If you’re missing either the function
    or the thing you’re applying it to, you can’t make something up out of thin air,
    so you need to propagate the failure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用函子，`Maybe`函数的行为类似。然而，在应用函子中，函数本身处于一个上下文中，以及它被应用到的值。`Maybe`作为一个应用函子，当我们使用`<*>`将一个`Maybe`内的函数应用于另一个`Maybe`内的值时，它们都必须是`Just`值，结果才是一个`Just`值；否则，结果是`Nothing`。这很有道理。如果你缺少函数或你要应用它的东西，你不能凭空创造出来，所以你需要传播失败。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the applicative style to have normal functions act on `Maybe` values works
    in a similar way. All the values must be `Just` values; otherwise, it’s all for
    `Nothing`!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用风格让普通函数作用于`Maybe`值的方式与此类似。所有值都必须是`Just`值；否则，结果都是`Nothing`！
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And now, let’s think about how we would use `>>=` with `Maybe`. `>>=` takes
    a monadic value and a function that takes a normal value. It returns a monadic
    value and manages to apply that function to the monadic value. How does it do
    that if the function takes a normal value? Well, it must take into account the
    context of that monadic value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们思考一下如何使用`>>=`与`Maybe`结合。`>>=`接受一个单子值和一个接受正常值的函数。它返回一个单子值，并成功地将该函数应用于单子值。如果函数接受正常值，它是如何做到这一点的呢？嗯，它必须考虑到那个单子值的上下文。
- en: 'In this case, `>>=` would take a `Maybe a` value and a function of type `a
    -> Maybe b`, and somehow apply the function to the `Maybe a`. To figure out how
    it does that, we can use the understanding that we have from `Maybe` being an
    applicative functor. Let’s say that we have a function `\x -> Just (x+1)`. It
    takes a number, adds `1` to it, and wraps it in a `Just`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`>>=`将接受一个`Maybe a`值和一个类型为`a -> Maybe b`的函数，并以某种方式将函数应用于`Maybe a`。为了弄清楚它是如何做到这一点的，我们可以使用我们对`Maybe`作为一个应用函子的理解。让我们假设我们有一个函数`\x
    -> Just (x+1)`。它接受一个数字，将其加1，并用`Just`包装起来：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we feed it `1`, it evaluates to `Just 2`. If we give it the number `100`,
    the result is `Just 101`. It seems very straightforward. But how do we feed a
    `Maybe` value to this function? If we think about how `Maybe` acts as an applicative
    functor, answering this is pretty easy. We feed it a `Just` value, take what’s
    inside the `Just`, and apply the function to it. If we give it a `Nothing`, then
    we’re left with a function but `Nothing` to apply it to. In that case, let’s just
    do what we did before and say that the result is `Nothing`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给它`1`，它评估为`Just 2`。如果我们给它数字`100`，结果是`Just 101`。这似乎非常直接。但我们如何将`Maybe`值喂给这个函数呢？如果我们考虑`Maybe`作为应用函子的行为，回答这个问题就很简单了。我们给它一个`Just`值，取`Just`里面的东西，并将函数应用于它。如果我们给它一个`Nothing`，那么我们只剩下一个函数，但没有东西可以应用它。在这种情况下，我们就像之前做的那样，说结果是`Nothing`。
- en: 'Instead of calling it `>>=`, let’s call it `applyMaybe` for now. It takes a
    `Maybe a` and a function that returns a `Maybe b`, and manages to apply that function
    to the `Maybe a`. Here it is in code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不叫它`>>=`，而是叫它`applyMaybe`。它接受一个`Maybe a`和一个返回`Maybe b`的函数，并成功地将该函数应用于`Maybe
    a`。下面是相应的代码：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let’s play with it. We’ll use it as an infix function so that the `Maybe`
    value is on the left side and the function is on the right:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来玩玩这个。我们将将其用作中缀函数，这样`Maybe`值就在左边，函数在右边：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, when we used `applyMaybe` with a `Just` value and a function,
    the function was simply applied to the value inside the `Just`. When we tried
    to use it with a `Nothing`, the whole result was `Nothing`. What about if the
    function returns a `Nothing`? Let’s see:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们使用`applyMaybe`与一个`Just`值和一个函数时，函数简单地应用于`Just`内的值。当我们尝试使用它与`Nothing`时，整个结果都是`Nothing`。那么如果函数返回`Nothing`呢？让我们看看：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The results are just what we expected. If the monadic value on the left is a
    `Nothing`, the whole thing is `Nothing`. And if the function on the right returns
    a `Nothing`, the result is `Nothing` again. This is similar to when we used `Maybe`
    as an applicative and we got a `Nothing` result if there was a `Nothing` somewhere
    in the mix.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正如我们所预期的。如果左边的单子值是`Nothing`，整个结果就是`Nothing`。如果右边的函数返回`Nothing`，结果又是`Nothing`。这和我们使用`Maybe`作为应用时得到的结果类似，如果在混合中存在`Nothing`。
- en: It looks like we’ve figured out how to take a fancy value, feed it to a function
    that takes a normal value, and return a fancy one. We did this by keeping in mind
    that a `Maybe` value represents a computation that might have failed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: You might be asking yourself, “How is this useful?” It may seem like applicative
    functors are stronger than monads, since applicative functors allow us to take
    a normal function and make it operate on values with contexts. In this chapter,
    you’ll see that monads, as an upgrade of applicative functors, can also do that.
    In fact, they can do some other cool stuff that applicative functors can’t do.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We’ll come back to `Maybe` in a minute, but first, let’s check out the type
    class that belongs to monads.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The Monad Type Class
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like functors have the `Functor` type class, and applicative functors
    have the `Applicative` type class, monads come with their own type class: `Monad`!
    (Wow, who would have thought?)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line says `class Monad m where`. But wait, didn’t I say that monads
    are just beefed-up applicative functors? Shouldn’t there be a class constraint
    in there along the lines of `class (Applicative m) = > Monad m where`, so that
    a type must be an applicative functor before it can be made a monad? Well, there
    should, but when Haskell was made, it hadn’t occurred to people that applicative
    functors were a good fit for Haskell. But rest assured, every monad is an applicative
    functor, even if the `Monad` class declaration doesn’t say so.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802678.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: The first function that the `Monad` type class defines is `return`. It’s the
    same as `pure` from the `Applicative` type class. So, even though it has a different
    name, you’re already acquainted with it. `return`’s type is `(Monad m) => a ->
    m a`. It takes a value and puts it in a minimal default context that still holds
    that value. In other words, `return` takes something and wraps it in a monad.
    We already used `return` when handling I/O in [Chapter 8](ch08.html "Chapter 8. Input
    and Output"). We used it to take a value and make a bogus I/O action that does
    nothing but yield that value. For `Maybe`, it takes a value and wraps it in a
    `Just`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just a reminder: `return` is nothing like the `return` that’s in most other
    languages. It doesn’t end function execution. It just takes a normal value and
    puts it in a context.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The next function is `>>=`, or bind. It’s like function application, but instead
    of taking a normal value and feeding it to a normal function, it takes a monadic
    value (that is, a value with a context) and feeds it to a function that takes
    a normal value but returns a monadic value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802680.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Next up, we have `>>=`. We won’t pay too much attention to it for now because
    it comes with a default implementation, and it’s rarely implemented when making
    `Monad` instances. We’ll take a closer look at it in [Banana on a Wire](ch13s04.html#banana_on_a_wire
    "Banana on a Wire") in [Banana on a Wire](ch13s04.html#banana_on_a_wire "Banana
    on a Wire").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`>>=`。我们现在不会过多关注它，因为它有一个默认实现，并且当创建`Monad`实例时很少实现。我们将在[Banana on a Wire](ch13s04.html#banana_on_a_wire
    "Banana on a Wire")中更详细地探讨它。
- en: The final function of the `Monad` type class is `fail`. We never use it explicitly
    in our code. Instead, it’s used by Haskell to enable failure in a special syntactic
    construct for monads that you’ll meet later. We don’t need to concern ourselves
    with `fail` too much for now.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monad`类型类的最后一个函数是`fail`。我们在代码中从不显式使用它。相反，Haskell使用它来在后面你将遇到的特殊语法结构中启用失败。现在我们不需要过多关注`fail`。'
- en: Now that you know what the `Monad` type class looks like, let’s take a look
    at how `Maybe` is an instance of `Monad`!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了`Monad`类型类的样子，让我们看看`Maybe`是如何成为`Monad`的一个实例的！
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`return` is the same as `pure`, so that one is a no-brainer. We do what we
    did in the `Applicative` type class and wrap it in a `Just`. The `>>=` function
    is the same as our `applyMaybe`. When feeding the `Maybe a` to our function, we
    keep in mind the context and return a `Nothing` if the value on the left is `Nothing`
    Again, if there’s no value, then there’s no way to apply our function to it. If
    it’s a `Just`, we take what’s inside and apply `f` to it.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`与`pure`相同，所以这一点是显而易见的。我们做了与`Applicative`类型类中相同的事情，将其包裹在`Just`中。`>>=`函数与我们的`applyMaybe`相同。当我们向函数传递`Maybe
    a`时，我们牢记上下文，如果左边的值是`Nothing`，则返回`Nothing`。再次，如果没有值，那么就没有办法将我们的函数应用于它。如果是`Just`，我们就取出里面的值并对其应用`f`。'
- en: 'We can play around with `Maybe` as a monad:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以围绕`Maybe`作为`monad`进行一些实验：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There’s nothing new or exciting on the first line, since we already used `pure`
    with `Maybe`, and we know that `return` is just `pure` with a different name.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行没有什么新奇的，因为我们已经使用过`pure`与`Maybe`，而且我们知道`return`只是以不同名称的`pure`。
- en: The next two lines showcase `>>=` a bit more. Notice how when we fed `Just 9`
    to the function `\x -> return (x*10)`, the `x` took on the value `9` inside the
    function. It seems as though we were able to extract the value from a `Maybe`
    without pattern matching. And we still didn’t lose the context of our `Maybe`
    value, because when it’s `Nothing`, the result of using `>>=` will be `Nothing`
    as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行展示了`>>=`的使用。注意当我们将`Just 9`传递给函数`\x -> return (x*10)`时，函数内的`x`取值为`9`。这好像我们能够从`Maybe`中提取值而不需要模式匹配。而且我们也没有丢失`Maybe`值的上下文，因为当它是`Nothing`时，使用`>>=`的结果也将是`Nothing`。
- en: Walk the Line
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Walk the Line
- en: Now that you know how to feed a `Maybe a` value to a function of type `a ->
    Maybe b` while taking into account the context of possible failure, let’s see
    how we can use `>>=` repeatedly to handle computations of several `Maybe a` values.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在考虑可能失败的情况下，将一个`Maybe a`值传递给一个类型为`a -> Maybe b`的函数，让我们看看我们如何可以重复使用`>>=`来处理多个`Maybe
    a`值的计算。
- en: 'Pierre has decided to take a break from his job at the fish farm and try tightrope
    walking. He is not that bad at it, but he does have one problem: Birds keep landing
    on his balancing pole! They come and take a short rest, chat with their avian
    friends, and then take off in search of breadcrumbs. This wouldn’t bother him
    so much if the number of birds on the left side of the pole were always equal
    to the number of birds on the right side. But sometimes, all the birds decide
    that they like one side better. They throw him off balance, which results in an
    embarrassing tumble for Pierre (he is using a safety net).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 皮埃尔决定从他在鱼场的工作中休息一下，尝试走钢丝。他在这方面并不差，但他有一个问题：鸟儿总是落在他的平衡杆上！它们来短暂休息，与它们的鸟类朋友聊天，然后去找面包屑。如果杆子两边的鸟儿数量总是相等，这不会让他太烦恼。但有时，所有的鸟儿都决定他们更喜欢一边。它们把他弄失衡，结果皮埃尔（他使用了安全网）尴尬地摔倒了。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802682.png.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802682.png.jpg)'
- en: Let’s say that Pierre keeps his balance if the number of birds on the left side
    of the pole and on the right side of the pole is within three. So if there’s one
    bird on the right side and four birds on the left side, he is okay. But if a fifth
    bird lands on the left side, he loses his balance and takes a dive.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设皮埃尔保持平衡的条件是杆子两侧的鸟的数量都在三个以内。所以如果右边有一只鸟，左边有四只鸟，他就没问题。但如果第五只鸟降落在左边，他就失去了平衡，然后就会跌落。
- en: We’re going to simulate birds landing on and flying away from the pole and see
    if Pierre is still at it after a certain number of bird arrivals and departures.
    For instance, we want to see what happens to Pierre if first one bird arrives
    on the left side, then four birds occupy the right side, and then the bird that
    was on the left side decides to fly away.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟鸟在杆子上降落和飞走，并查看在经过一定数量的鸟的到达和离开后，皮埃尔是否还在那里。例如，我们想看看如果首先有一只鸟降落在左边，然后四只鸟占据了右边，最后左边的那只鸟决定飞走，会发生什么。
- en: Code, Code, Code
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码，代码，代码
- en: 'We can represent the pole with a simple pair of integers. The first component
    will signify the number of birds on the left side and the second component the
    number of birds on the right side:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一对简单的整数来表示杆子。第一个组成部分将表示左边的鸟的数量，第二个组成部分表示右边的鸟的数量：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we made a type synonym for `Int`, called `Birds`, because we’re using
    integers to represent how many birds there are. And then we made a type synonym
    `(Birds, Birds)` and called it `Pole` (not to be confused with a person of Polish
    descent).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为 `Int` 创建了一个类型同义词，称为 `Birds`，因为我们正在使用整数来表示鸟的数量。然后我们创建了一个类型同义词 `(Birds,
    Birds)` 并将其称为 `Pole`（不要与波兰血统的人混淆）。
- en: Now, how about adding functions that take a number of birds and land them on
    one side of the pole or the other?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来考虑添加一些函数，这些函数可以将一定数量的鸟降落在杆子的这一侧或那一侧。
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s try them out:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To make birds fly away, we just had a negative number of birds land on one
    side. Because landing a bird on the `Pole` returns a `Pole`, we can chain applications
    of `landLeft` and `landRight`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要让鸟飞走，我们只需让一侧降落的鸟的数量为负数。因为将鸟降落在 `Pole` 上会返回一个 `Pole`，所以我们可以链式调用 `landLeft` 和
    `landRight`：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we apply the function `landLeft 1` to `(0, 0)` we get `(1, 0)`. Then we
    land a bird on the right side, resulting in `(1, 1)`. Finally, two birds land
    on the left side, resulting in `(3, 1)`. We apply a function to something by first
    writing the function and then writing its parameter, but here it would be better
    if the pole went first and then the landing function. Suppose we make a function
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将函数 `landLeft 1` 应用到 `(0, 0)` 上时，我们得到 `(1, 0)`。然后我们在右边降一只鸟，结果变为 `(1, 1)`。最后，左边降两只鸟，结果变为
    `(3, 1)`。我们通过先写函数再写其参数的方式来应用函数到某个东西上，但在这里，如果杆子先写，然后是降落函数会更好。假设我们创建一个这样的函数：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can apply functions by first writing the parameter and then the function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过先写参数再写函数的方式来应用函数：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By using this form, we can repeatedly land birds on the pole in a more readable
    manner:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种形式，我们可以以更可读的方式反复在杆子上降落鸟：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pretty cool! This version is equivalent to the one before where we repeatedly
    landed birds on the pole, but it looks neater. Here, it’s more obvious that we
    start off with `(0, 0)` and then land one bird on the left, then one on the right,
    and finally, two on the left.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 真是酷！这个版本与我们之前反复将鸟降落在杆子上的版本等效，但看起来更整洁。在这里，我们一开始从 `(0, 0)` 开始，然后左降一只鸟，右降一只，最后左降两只。
- en: I'll Fly Away
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我要飞走了
- en: So far so good, but what happens if ten birds land on one side?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但如果一侧降落了十只鸟会怎样？
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Ten birds on the left side and only three on the right? That’s sure to send
    poor Pierre falling through the air! This is pretty obvious here, but what if
    we had a sequence of landings like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 左边有十只鸟，右边只有三只？这肯定会让可怜的皮埃尔从空中跌落！这里很明显，但如果有一系列的降落像这样：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It might seem as if everything is okay, but if you follow the steps here, you’ll
    see that at one time there are four birds on the right side and no birds on the
    left! To fix this, we need to take another look at our `landLeft` and `landRight`
    functions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切似乎都正常，但如果你按照这里的步骤来，你会看到在某个时刻右边有四只鸟，左边没有鸟！为了解决这个问题，我们需要重新审视我们的 `landLeft`
    和 `landRight` 函数。
- en: 'We want the `landLeft` and `landRight` functions to be able to fail. We want
    them to return a new pole if the balance is okay but fail if the birds land in
    a lopsided manner. And what better way to add a context of failure to value than
    by using `Maybe`! Let’s rework these functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of returning a `Pole`, these functions now return a `Maybe Pole`. They
    still take the number of birds and the old pole as before, but then they check
    if landing that many birds on the pole would throw Pierre off balance. We use
    guards to check if the difference between the number of birds on the new pole
    is less than `4`. If it is, we wrap the new pole in a `Just` and return that.
    If it isn’t, we return a `Nothing`, indicating failure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give these babies a go:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we land birds without throwing Pierre off balance, we get a new pole wrapped
    in a `Just`. But when many more birds end up on one side of the pole, we get a
    `Nothing`. This is cool, but we seem to have lost the ability to repeatedly land
    birds on the pole. We can’t do `landLeft 1 (landRight 1 (0, 0))` anymore, because
    when we apply `landRight 1` to `(0, 0)`, we don’t get a `Pole`, but a `Maybe Pole`.
    `landLeft 1` takes a `Pole`, rather than a `Maybe Pole`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a way of taking a `Maybe Pole` and feeding it to a function that takes
    a `Pole` and returns a `Maybe Pole`. Luckily, we have `>>=`, which does just that
    for `Maybe`. Let’s give it a go:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Remember that `landLeft 2` has a type of `Pole -> Maybe Pole`. We couldn’t
    just feed it the `Maybe Pole` that is the result of `landRight 1 (0, 0)`, so we
    use `>>=` to take that value with a context and give it to `landLeft 2`. `>>=`
    does indeed allow us to treat the `Maybe` value as a value with context. If we
    feed a `Nothing` into `landLeft 2`, the result is `Nothing`, and the failure is
    propagated:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this, we can now chain landings that may fail, because `>>=` allows us
    to feed a monadic value to a function that takes a normal one. Here’s a sequence
    of bird landings:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At the beginning, we used `return` to take a pole and wrap it in a `Just`. We
    could have just applied `landRight 2` to `(0, 0)`—it would have been the same—but
    this way, we can be more consistent by using `>>=` for every function. `Just (0,
    0)` is fed to `landRight 2`, resulting in `Just (0, 2)`. This, in turn, gets fed
    to `landLeft 2`, resulting in `Just (2, 2)`, and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Remember the following example from before we introduced failure into Pierre’s
    routine?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It didn’t simulate his interaction with birds very well. In the middle, his
    balance was off, but the result didn’t reflect that. Let’s fix that now by using
    monadic application (`>>=`) instead of normal application:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final result represents failure, which is what we expected. Let’s see how
    this result was obtained:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`return` puts `(0, 0)` into a default context, making it a `Just (0, 0)`.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Just (0, 0) >>= landLeft 1` happens. Since the `Just (0, 0)` is a `Just` value,
    `landLeft 1` gets applied to `(0, 0)`, resulting in a `Just (1, 0)`, because the
    birds are still relatively balanced.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Just (1, 0) >>= landRight 4` takes place, and the result is `Just (1, 4)`,
    as the balance of the birds is still intact, although just barely.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Just (1, 4)` gets fed to `landLeft (-1)`. This means that `landLeft (-1) (1,
    4)` takes place. Now because of how `landLeft` works, this results in a `Nothing`,
    because the resulting pole is off balance.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a `Nothing`, it gets fed to `landRight (-2)`, but because it’s
    a `Nothing`, the result is automatically `Nothing`, as we have nothing to apply
    `landRight (-2)` to.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We couldn’t have achieved this by just using `Maybe` as an applicative. If you
    try it, you’ll get stuck, because applicative functors don’t allow for the applicative
    values to interact with each other very much. They can, at best, be used as parameters
    to a function by using the applicative style.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The applicative operators will fetch their results and feed them to the function
    in a manner appropriate for each applicative, and then put the final applicative
    value together, but there isn’t that much interaction going on between them. Here,
    however, each step relies on the previous one’s result. On every landing, the
    possible result from the previous one is examined and the pole is checked for
    balance. This determines whether the landing will succeed or fail.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Banana on a Wire
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s devise a function that ignores the current number of birds on the
    balancing pole and just makes Pierre slip and fall. We’ll call it `banana`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802684.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can chain this function together with our bird landings. It will always cause
    our walker to fall, because it ignores whatever is passed to it and always returns
    a failure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The value `Just (1, 0)` gets fed to `banana`, but it produces a `Nothing`, which
    causes everything to result in a `Nothing`. How unfortunate!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of making functions that ignore their input and just return a predetermined
    monadic value, we can use the `>>` function. Here’s its default implementation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Normally, passing some value to a function that ignores its parameter and always
    returns some predetermined value always results in that predetermined value. With
    monads, however, their context and meaning must be considered as well. Here’s
    how `>>` acts with `Maybe`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we replace `>>` with `>>= \_ ->`, it’s easy to see what’s happening.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace our `banana` function in the chain with a `>>` and then a `Nothing`
    for guaranteed and obvious failure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What would this look like if we hadn’t made the clever choice of treating `Maybe`
    values as values with a failure context and feeding them to functions? Here’s
    how a series of bird landings would look:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We land a bird on the left, and then we examine the possibility of failure and
    the possibility of success. In the case of failure, we return a `Nothing`. In
    the case of success, we land birds on the right and then do the same thing all
    over again. Converting this monstrosity into a neat chain of monadic applications
    with `>>=` is a classic example of how the `Maybe` monad saves a lot of time when
    you need to successively do computations that are based on computations that might
    have failed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在左边着陆一只鸟，然后检查失败的可能性和成功的可能性。在失败的情况下，我们返回一个 `Nothing`。在成功的情况下，我们在右边着陆鸟，然后再次做同样的事情。将这个怪物转换成一个整洁的单调应用链
    `>>=` 是一个经典的例子，说明了 `Maybe` 单调在需要连续进行基于可能失败的计算的运算时可以节省大量时间。
- en: Notice how the `Maybe` implementation of `>>=` features exactly this logic of
    seeing if a value is `Nothing` and acting on that knowledge. If the value is `Nothing`,
    it returns a `Nothing` immediately. If the value is not `Nothing`, it goes forward
    with what’s inside the `Just`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Maybe` 实现 `>>=` 中的逻辑，它正是通过查看值是否为 `Nothing` 并根据这一知识采取行动。如果值是 `Nothing`，它将立即返回一个
    `Nothing`。如果值不是 `Nothing`，它将使用 `Just` 内部的值继续前进。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802686.png.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802686.png.jpg)'
- en: In this section, we looked at how some functions work better when the values
    that they return support failure. By turning those values into `Maybe` values
    and replacing normal function application with `>>=`, we got a mechanism for handling
    failure pretty much for free. This is because `>>=` is supposed to preserve the
    context of the value to which it applies functions. In this case, the context
    was that our values were values with failure. So, when we applied functions to
    such values, the possibility of failure was always taken into account.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了当函数返回的值支持失败时，一些函数的工作效果会更好。通过将这些值转换为 `Maybe` 值，并用 `>>=` 替换正常函数应用，我们得到了一种几乎免费处理失败的方法。这是因为
    `>>=` 应该保留它所应用函数的上下文。在这种情况下，上下文是我们的值是有失败的值。因此，当我们对这些值应用函数时，总是考虑到失败的可能性。
- en: do Notation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do 语法
- en: 'Monads in Haskell are so useful that they got their own special syntax, called
    `do` notation. You already encountered `do` notation in [Chapter 8](ch08.html
    "Chapter 8. Input and Output"), when we used it for gluing together several I/O
    actions into one. Well, as it turns out, `do` notation isn’t just for `IO` but
    can be used for any monad. Its principle is still the same: gluing together monadic
    values in sequence.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 中的 Monads 非常有用，以至于它们拥有自己的特殊语法，称为 `do` 语法。你已经在 [第 8 章](ch08.html "第 8
    章。输入和输出") 中遇到了 `do` 语法，当时我们用它来将几个 I/O 操作粘合在一起。实际上，`do` 语法不仅限于 `IO`，它可以用于任何单调。它的原则仍然是相同的：按顺序粘合单调值。
- en: 'Consider this familiar example of monadic application:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个熟悉的单调应用例子：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Been there, done that. Feeding a monadic value to a function that returns one—no
    big deal. Notice how when we do this, `x` becomes `3` inside the lambda. Once
    we’re inside that lambda, it’s just a normal value rather than a monadic value.
    Now, what if we had another `>>=` inside that function? Check this out:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 已经历过，做过。给一个返回一个值的函数传递一个单调值——没什么大不了的。注意当我们这样做时，`x` 在 lambda 内部变成了 `3`。一旦我们进入那个
    lambda，它就只是一个普通值，而不是单调值。那么，如果我们在这个函数内部有另一个 `>>=` 呢？看看这个例子：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Ah, a nested use of `>>=`! In the outermost lambda, we feed `Just "!"` to the
    lambda `\y -> Just (show x ++ y)`. Inside this lambda, the `y` becomes `"!"`.
    `x` is still `3`, because we got it from the outer lambda. All this sort of reminds
    me of the following expression:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，嵌套使用 `>>=`！在外层 lambda 中，我们将 `Just "!"` 传递给 lambda `\y -> Just (show x ++ y)`。在这个
    lambda 内部，`y` 变成了 `"!"`。`x` 仍然是 `3`，因为我们是从外层 lambda 中获取它的。这一切都让我想起了以下表达式：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The main difference here is that the values in our `>>=` example are monadic.
    They are values with a failure context. We can replace any of them with a failure:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于我们 `>>=` 例子中的值是单调的。它们是有失败上下文的值。我们可以用失败来替换其中的任何一个：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the first line, feeding a `Nothing` to a function naturally results in a
    `Nothing`. In the second line, we feed `Just 3` to a function, and the `x` becomes
    `3`. But then we feed a `Nothing` to the inner lambda, and the result of that
    is `Nothing`, which causes the outer lambda to produce `Nothing` as well. So this
    is sort of like assigning values to variables in `let` expressions, except that
    the values in question are monadic values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，自然地将`Nothing`提供给一个函数会导致一个`Nothing`。在第二行，我们向一个函数提供`Just 3`，这时`x`变成了`3`。但是然后我们向内部lambda提供一个`Nothing`，其结果是`Nothing`，这导致外部lambda也产生`Nothing`。所以这有点像在`let`表达式中给变量赋值，只是所涉及的值是单子值。
- en: 'To further illustrate this point, let’s write this in a script and have each
    `Maybe` value take up its own line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们把这个写在一个脚本中，并让每个`Maybe`值占据它自己的行：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To save us from writing all these annoying lambdas, Haskell gives us `do` notation.
    It allows us to write the previous piece of code like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们免于编写所有这些讨厌的lambda函数，Haskell给了我们`do`表示法。它允许我们像这样编写之前的代码：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802688.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802688.png.jpg)'
- en: It would seem as though we’ve gained the ability to temporarily extract things
    from `Maybe` values without needing to check if the `Maybe` values are `Just`
    values or `Nothing` values at every step. How cool! If any of the values that
    we try to extract from are `Nothing`, the whole `do` expression will result in
    a `Nothing`. We’re yanking out their (possibly existing) values and letting `>>=`
    worry about the context that comes with those values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们获得了从`Maybe`值中临时提取东西的能力，而无需在每一步检查`Maybe`值是`Just`值还是`Nothing`值。多么酷啊！如果我们尝试提取的任何值是`Nothing`，整个`do`表达式将导致一个`Nothing`。我们正在拉出它们的（可能存在的）值，让`>>=`来处理这些值带来的上下文。
- en: '`do` expressions are just different syntax for chaining monadic values.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`表达式只是连接单子值的不同语法。'
- en: Do As I Do
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如我所做
- en: In a `do` expression, every line that isn’t a `let` line is a monadic value.
    To inspect its result, we use `<-`. If we have a `Maybe String` and we bind it
    to a variable with `<-`, that variable will be a `String`, just as when we used
    `>>=` to feed monadic values to lambdas.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`do`表达式中，每一行如果不是`let`行，就是一个单子值。为了检查其结果，我们使用`<-`。如果我们有一个`Maybe String`并将其绑定到一个变量上，那么这个变量将是一个`String`，就像我们使用`>>=`向lambda函数提供单子值时一样。
- en: 'The last monadic value in a `do` expression—like `Just (show x ++ y)` here—can’t
    be used with `<-` to bind its result, because that wouldn’t make sense if we translated
    the `do` expression back to a chain of `>>=` applications. Rather, its result
    is the result of the whole glued-up monadic value, taking into account the possible
    failure of any of the previous ones. For instance, examine the following line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`do`表达式中，最后一个单子值——就像这里的`Just (show x ++ y)`——不能使用`<-`来绑定其结果，因为如果我们把`do`表达式转换回一系列`>>=`应用的链，那就没有意义了。相反，它的结果是整个粘合的单子值的结果，考虑到之前任何一个可能的失败。例如，检查以下行：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Because the left parameter of `>>=` is a `Just` value, the lambda is applied
    to `9`, and the result is a `Just True`. We can rewrite this in `do` notation,
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`>>=`的左参数是一个`Just`值，所以lambda函数被应用于`9`，结果是`Just True`。我们可以用`do`表示法重写这个，如下所示：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Comparing these two versions, it’s easy to see why the result of the whole monadic
    value is the result of the last monadic value in the `do` expression with all
    the previous ones chained into it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两个版本，很容易看出整个单子值的结果是`do`表达式中最后一个单子值的结果，所有前面的单子值都连接到它里面。
- en: Pierre Returns
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 皮埃尔归来
- en: 'Our tightrope walker’s routine can also be expressed with `do` notation. `landLeft`
    and `landRight` take a number of birds and a pole and produce a pole wrapped in
    a `Just`. The exception is when the tightrope walker slips, in which case a `Nothing`
    is produced. We used `>>=` to chain successive steps because each one relied on
    the previous one, and each one had an added context of possible failure. Here
    are two birds landing on the left side, then two birds landing on the right, and
    then one bird landing on the left:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们走钢丝演员的表演也可以用`do`表示法来表示。`landLeft`和`landRight`接受一些鸟和一根杆，并产生一个用`Just`包裹的杆。例外的情况是当走钢丝演员滑倒时，这时会产生一个`Nothing`。我们使用`>>=`来连接连续的步骤，因为每一步都依赖于前一步，并且每一步都有一个可能的失败上下文。这里有两只鸟落在左边，然后两只鸟落在右边，最后一只鸟落在左边：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s see if he succeeds:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看他是否成功：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: He does!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 他做到了！
- en: When we were doing these routines by explicitly writing `>>=`, we usually said
    something like `return (0, 0) >>= landLeft 2`, because `landLeft 2` is a function
    that returns a `Maybe` value. However, with `do` expressions, each line must feature
    a monadic value. So we explicitly pass the previous `Pole` to the `landLeft landRight`
    functions. If we examined the variables to which we bound our `Maybe` values,
    `start` would be `(0, 0)`, `first` would be `(2, 0)` and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过显式编写 `>>=` 来执行这些常规操作时，我们通常会说出类似于 `return (0, 0) >>= landLeft 2` 的话，因为 `landLeft
    2` 是一个返回 `Maybe` 值的函数。然而，使用 `do` 表达式时，每一行都必须包含一个单调值。因此，我们显式地将之前的 `Pole` 传递给 `landLeft
    landRight` 函数。如果我们检查我们绑定的 `Maybe` 值的变量，`start` 将是 `(0, 0)`，`first` 将是 `(2, 0)`
    等等。
- en: Because `do` expressions are written line by line, they may look like imperative
    code to some people. But they’re just sequential, as each value in each line relies
    on the result of the previous ones, along with their contexts (in this case, whether
    they succeeded or failed).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `do` 表达式是逐行编写的，它们可能看起来像命令式代码，但它们只是顺序的，因为每一行中的每个值都依赖于前一个值的結果，以及它们的上下文（在这种情况下，它们是成功还是失败）。
- en: 'Again, let’s take a look at what this piece of code would look like if we hadn’t
    used the monadic aspects of `Maybe`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们看看如果我们没有使用 `Maybe` 的单调特性，这段代码会是什么样子：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See how in the case of success, the tuple inside `Just (0, 0)` becomes `start`,
    the result of `landLeft 2 start` becomes `first`, and so on?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在成功的情况下，`Just (0, 0)` 中的元组变成了 `start`，`landLeft 2 start` 的结果变成了 `first`，以此类推？
- en: 'If we want to throw Pierre a banana peel in `do` notation, we can do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 `do` 表示法中给 Pierre 抛一个香蕉皮，我们可以这样做：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When we write a line in `do` notation without binding the monadic value with
    `<-`, it’s just like putting `>>` after the monadic value whose result we want
    to ignore. We sequence the monadic value but we ignore its result, because we
    don’t care what it is. Plus, it’s prettier than writing its equivalent form of
    `_ <- Nothing`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `do` 表示法中写一行代码而没有使用 `<-` 来绑定单调值时，它就像在想要忽略结果的单调值后面加上 `>>` 一样。我们按顺序排列单调值，但忽略其结果，因为我们不关心它是什么。此外，这比写其等价形式
    `_ <- Nothing` 更美观。
- en: When to use `do` notation and when to explicitly use `>>=` is up to you. I think
    this example lends itself to explicitly writing `>>=`, because each step relies
    specifically on the result of the previous one. With `do` notation, we need to
    specifically write on which pole the birds are landing, but every time we just
    use the pole that was the result of the previous landing. But still, it gave us
    some insight into `do` notation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用 `do` 表示法，何时显式使用 `>>=` 取决于你。我认为这个例子适合显式编写 `>>=`，因为每个步骤都具体依赖于前一个步骤的结果。使用
    `do` 表示法，我们需要特别指出鸟儿落在哪个极点上，但每次我们只是使用前一次着陆的结果。但即便如此，它还是给了我们一些关于 `do` 表示法的见解。
- en: Pattern Matching and Failure
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配与失败
- en: 'In `do` notation, when we bind monadic values to names, we can utilize pattern
    matching, just as in `let` expressions and function parameters. Here’s an example
    of pattern matching in a `do` expression:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `do` 表示法中，当我们将单调值绑定到名称时，我们可以利用模式匹配，就像在 `let` 表达式和函数参数中一样。以下是一个 `do` 表达式中的模式匹配示例：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We use pattern matching to get the first character of the string `"hello"`,
    and then we present it as the result. So `justH` evaluates to `Just 'h'`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模式匹配来获取字符串 `"hello"` 的第一个字符，并将其作为结果展示。因此 `justH` 的值是 `Just 'h'`。
- en: What if this pattern matching were to fail? When matching on a pattern in a
    function fails, the next pattern is matched. If the matching falls through all
    the patterns for a given function, an error is thrown, and the program crashes.
    On the other hand, failed pattern matching in `let` expressions results in an
    error being produced immediately, because the mechanism of falling through patterns
    isn’t present in `let` expressions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个模式匹配失败了怎么办？当在函数中对一个模式进行匹配失败时，会尝试下一个模式。如果匹配在给定函数的所有模式上都失败了，则会抛出一个错误，程序崩溃。另一方面，`let`
    表达式中的失败模式匹配会立即产生错误，因为 `let` 表达式中不存在模式下降的机制。
- en: 'When pattern matching fails in a `do` expression, the `fail` function (part
    of the `Monad` type class) enables it to result in a failure in the context of
    the current monad, instead of making the program crash. Here’s its default implementation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `do` 表达式中的模式匹配失败时，`fail` 函数（`Monad` 类型类的一部分）允许它在当前单调的上下文中导致失败，而不是使程序崩溃。以下是它的默认实现：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So, by default, it does make the program crash. But monads that incorporate
    a context of possible failure (like `Maybe`) usually implement it on their own.
    For `Maybe`, it’s implemented like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，默认情况下，它确实会导致程序崩溃。但是，结合可能失败上下文（如`Maybe`）的单子通常会在它们自己的实现中处理它。对于`Maybe`，它的实现如下：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It ignores the error message and makes a `Nothing`. So when pattern matching
    fails in a `Maybe` value that’s written in `do` notation, the whole value results
    in a `Nothing`. This is preferable to having your program crash. Here’s a `do`
    expression with a pattern match that’s bound to fail:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它忽略了错误消息并创建了一个`Nothing`。因此，当在`do`记法中编写的`Maybe`值中的模式匹配失败时，整个值的结果将是`Nothing`。这比程序崩溃要好。下面是一个带有必败模式匹配的`do`表达式：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The pattern matching fails, so the effect is the same as if the whole line
    with the pattern were replaced with a `Nothing`. Let’s try this out:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配失败，因此效果等同于将带有模式的整个行替换为`Nothing`。让我们试一试：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The failed pattern matching has caused a failure within the context of our monad
    instead of causing a program-wide failure, which is pretty neat.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的模式匹配在我们的单子上下文中引起了一个失败，而不是引起程序范围的失败，这相当不错。
- en: The List Monad
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表单子
- en: So far, you’ve seen how `Maybe` values can be viewed as values with a failure
    context, and how we can incorporate failure handling into our code by using `>>=`
    to feed them to functions. In this section, we’re going to take a look at how
    to use the monadic aspects of lists to bring nondeterminism into our code in a
    clear and readable manner.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了`Maybe`值可以被视为具有失败上下文的值，以及我们如何通过使用`>>=`将它们馈送到函数中来将失败处理纳入我们的代码。在本节中，我们将探讨如何使用列表的单子特性以清晰和可读的方式将非确定性引入我们的代码。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802690.png.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802690.png.jpg)'
- en: In [Chapter 11](ch11.html "Chapter 11. Applicative Functors"), we talked about
    how lists represent nondeterministic values when they’re used as applicatives.
    A value like `5` is deterministic—it has only one result, and we know exactly
    what it is. On the other hand, a value like `[3,8,9]` contains several results,
    so we can view it as one value that is actually many values at the same time.
    Using lists as applicative functors showcases this nondeterminism nicely.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.html "第11章。应用函子")中，我们讨论了当列表作为应用函子使用时如何表示非确定性值。像`5`这样的值是确定的——它只有一个结果，我们确切地知道它是什么。另一方面，像`[3,8,9]`这样的值包含多个结果，因此我们可以将其视为一个同时包含多个值的单一值。使用列表作为应用函子很好地展示了这种非确定性。
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: All the possible combinations of multiplying elements from the left list with
    elements from the right list are included in the resulting list. When dealing
    with nondeterminism, there are many choices that we can make, so we just try all
    of them. This means the result is a nondeterministic value as well, but it has
    many more results.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结果列表包括从左侧列表中乘以右侧列表中元素的所有的可能组合。在处理非确定性时，我们可以做出许多选择，所以我们只是尝试所有这些。这意味着结果也是一个不确定性值，但它有更多的结果。
- en: 'This context of nondeterminism translates to monads very nicely. Here’s what
    the `Monad` instance for lists looks like:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非确定性上下文很好地转化为单子。下面是列表的`Monad`实例看起来像什么：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you know, `return` does the same thing as `pure`, and you’re already familiar
    with `return` for lists. `return` takes a value and puts it in a minimal default
    context that still yields that value. In other words, `return` makes a list that
    has only that one value as its result. This is useful when we want to just wrap
    a normal value into a list so that it can interact with nondeterministic values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`return`与`pure`做同样的事情，你已经熟悉了列表中的`return`。`return`接受一个值并将其放入一个最小的默认上下文中，该上下文仍然产生该值。换句话说，`return`创建一个只有一个值作为结果的列表。当我们只想将一个普通值包装到列表中以便它可以与不确定性值交互时，这很有用。
- en: '`>>=` is about taking a value with a context (a monadic value) and feeding
    it to a function that takes a normal value and returns one that has context. If
    that function just produced a normal value instead of one with a context, `>>=`
    wouldn’t be so useful—after one use, the context would be lost.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>=`是关于取一个具有上下文（一个单子值）的值并将其馈送到一个接受普通值并返回具有上下文的值的函数。如果该函数只是产生一个普通值而不是一个具有上下文的值，`>>=`就不会那么有用——使用一次后，上下文就会丢失。'
- en: 'Let’s try feeding a nondeterministic value to a function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将一个不确定性值馈送到一个函数：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When we used `>>=` with `Maybe`, the monadic value was fed into the function
    while taking care of possible failures. Here, it takes care of non-determinism
    for us.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `>>=` 与 `Maybe` 时，单子值被传递给函数，同时处理可能的失败。这里，它为我们处理了非确定性。
- en: '`[3,4,5]` is a nondeterministic value, and we feed it into a function that
    returns a nondeterministic value as well. The result is also nondeterministic,
    and it features all the possible results of taking elements from the list `[3,4,5]`
    and passing them to the function `\x -> [x,-x]`. This function takes a number
    and produces two results: one negated and one that’s unchanged. So when we use
    `>>=` to feed this list to the function, every number is negated and also kept
    unchanged. The `x` from the lambda takes on every value from the list that’s fed
    to it.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`[3,4,5]` 是一个非确定性值，我们将其输入到一个返回非确定性值的函数中。结果是也是非确定性的，它包含了从列表 `[3,4,5]` 中取元素并传递给函数
    `\x -> [x,-x]` 的所有可能结果。这个函数接受一个数字并产生两个结果：一个取反和一个保持不变。所以当我们使用 `>>=` 将这个列表传递给函数时，每个数字都被取反并且保持不变。Lambda
    中的 `x` 取代了传递给它的列表中的每个值。'
- en: 'To see how this is achieved, we can just follow the implementation. First,
    we start with the list `[3,4,5]`. Then we map the lambda over it and get the following
    result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何实现的，我们可以直接查看实现过程。首先，我们从列表 `[3,4,5]` 开始。然后我们将 lambda 函数映射到它上面，得到以下结果：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The lambda is applied to every element, and we get a list of lists. Finally,
    we just flatten the list, and voilà, we’ve applied a nondeterministic function
    to a nondeterministic value!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数应用于每个元素，我们得到一个列表的列表。最后，我们只需将列表展平，voilà，我们就对一个非确定性值应用了一个非确定性函数！
- en: 'Nondeterminism also includes support for failure. The empty list `[]` is pretty
    much the equivalent of `Nothing`, because it signifies the absence of a result.
    That’s why failing is just defined as the empty list. The error message gets thrown
    away. Let’s play around with lists that fail:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性还包括对失败的支持。空列表 `[]` 几乎等同于 `Nothing`，因为它表示没有结果。这就是为什么失败被定义为空列表。错误信息被丢弃。让我们来玩一些会失败的列表：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the first line, an empty list is fed into the lambda. Because the list has
    no elements, there are none to be passed to the function, so the result is an
    empty list. This is similar to feeding `Nothing` to a function. In the second
    line, each element is passed to the function, but the element is ignored and the
    function just returns an empty list. Because the function fails for every element
    that goes in it, the result is a failure.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，一个空列表被传递给 lambda。因为列表没有元素，所以没有元素可以传递给函数，所以结果是空列表。这类似于将 `Nothing` 传递给函数。在第二行，每个元素都传递给函数，但元素被忽略，函数只返回一个空列表。因为函数对进入它的每个元素都失败了，所以结果是失败。
- en: 'Just as with `Maybe` values, we can chain several lists with `>>=`, propagating
    the nondeterminism:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与 `Maybe` 值一样，我们可以使用 `>>=` 连接多个列表，传播非确定性：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802692.png.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802692.png.jpg)'
- en: The numbers from the list `[1,2]` are bound to `n`, and the characters from
    the list `['a','b']` are bound to `ch`. Then we do `return (n, ch)` (or `[(n,
    ch)]`), which means taking a pair of `(n, ch)` and putting it in a default minimal
    context. In this case, it’s making the smallest possible list that still presents
    `(n, ch)` as the result and features as little nondeterminism as possible. Its
    effect on the context is minimal. We’re saying, “For every element in `[1,2]`,
    go over every element in `['a','b']` and produce a tuple of one element from each
    list.”
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 `[1,2]` 中的数字绑定到 `n`，列表 `['a','b']` 中的字符绑定到 `ch`。然后我们执行 `return (n, ch)`（或
    `[(n, ch)]`），这意味着取一个 `(n, ch)` 对并将其放入默认的最小上下文中。在这种情况下，它创建了一个最小的列表，仍然将 `(n, ch)`
    作为结果呈现，并且尽可能减少非确定性。它对上下文的影响是最小的。我们说的是，“对于 `[1,2]` 中的每个元素，遍历 `['a','b']` 中的每个元素，并生成一个来自每个列表的一个元素的元组。”
- en: Generally speaking, because `return` takes a value and wraps it in a minimal
    context, it doesn’t have any extra effect (like failing in `Maybe` or resulting
    in more nondeterminism for lists), but it does present something as its result.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，因为 `return` 接收一个值并将其包裹在最小上下文中，它没有额外的效果（比如在 `Maybe` 中失败或在列表中产生更多非确定性），但它确实呈现了某种结果。
- en: 'When you have nondeterministic values interacting, you can view their computation
    as a tree where every possible result in a list represents a separate branch.
    Here’s the previous expression rewritten in `do` notation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当非确定性值相互作用时，你可以将它们的计算视为一棵树，其中列表中的每一个可能结果代表一个单独的分支。以下是之前表达式用 `do` 语法重写的样子：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This makes it a bit more obvious that `n` takes on every value from `[1,2]`
    and `ch` takes on every value from `['a','b']`. Just as with `Maybe`, we’re extracting
    the elements from the monadic values and treating them like normal values, and
    `>>=` takes care of the context for us. The context in this case is nondeterminism.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `n` 从 `[1,2]` 中获取每一个值，`ch` 从 `['a','b']` 中获取每一个值这一点更加明显。就像 `Maybe` 一样，我们正在从单子值中提取元素，并将它们当作普通值处理，而
    `>>=` 则为我们处理上下文。在这个情况下，上下文是非确定性。
- en: do Notation and List Comprehensions
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do 语法和列表推导
- en: 'Using lists with `do` notation might remind you of something you’ve seen before.
    For instance, check out the following piece of code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `do` 语法与列表可能会让你想起之前看到过的东西。例如，检查以下代码片段：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Yes, list comprehensions! In our `do` notation example, `n` became every result
    from `[1,2]`. For every such result, `ch` was assigned a result from `['a','b']`,
    and then the final line put `(n, ch)` into a default context (a singleton list)
    to present it as the result without introducing any additional nondeterminism.
    In this list comprehension, the same thing happened, but we didn’t need to write
    `return` at the end to present `(n, ch)` as the result, because the output part
    of a list comprehension did that for us.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，列表推导！在我们的 `do` 语法示例中，`n` 变成了 `[1,2]` 中的每一个结果。对于每一个这样的结果，`ch` 被分配了 `['a','b']`
    中的一个结果，然后最后一行将 `(n, ch)` 放入一个默认上下文（一个单元素列表）中，以不引入任何额外的非确定性来呈现它。在这个列表推导中，发生了同样的事情，但我们不需要在最后写
    `return` 来呈现 `(n, ch)` 作为结果，因为列表推导的输出部分已经为我们做了这件事。
- en: In fact, list comprehensions are just syntactic sugar for using lists as monads.
    In the end, list comprehensions and lists in `do` notation translate to using
    `>>=` to do computations that feature nondeterminism.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，列表推导只是使用列表作为单子的语法糖。最终，列表推导和 `do` 语法中的列表都转换为使用 `>>=` 来执行具有非确定性的计算。
- en: MonadPlus and the guard Function
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MonadPlus 和 guard 函数
- en: 'List comprehensions allow us to filter our output. For instance, we can filter
    a list of numbers to search only for numbers whose digits contain a `7`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导允许我们过滤输出。例如，我们可以过滤一个数字列表，只搜索包含数字 `7` 的数字：
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We apply `show` to `x` to turn our number into a string, and then we check if
    the character `'7'` is part of that string.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `show` 应用到 `x` 上，将我们的数字转换为字符串，然后检查字符 `'7'` 是否是那个字符串的一部分。
- en: To see how filtering in list comprehensions translates to the list monad, we
    need to check out the `guard` function and the `MonadPlus` type class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解列表推导中的过滤是如何转换为列表单子的，我们需要查看 `guard` 函数和 `MonadPlus` 类型类。
- en: 'The `MonadPlus` type class is for monads that can also act as monoids. Here
    is its definition:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonadPlus` 类型类是为那些也可以作为单子使用的单子设计的。以下是它的定义：'
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`mzero` is synonymous with `mempty` from the `Monoid` type class, and `mplus`
    corresponds to `mappend`. Because lists are monoids as well as monads, they can
    be made an instance of this type class:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`mzero` 与 `Monoid` 类型类的 `mempty` 同义，而 `mplus` 对应于 `mappend`。因为列表既是单子也是单子，所以它们可以成为这个类型类的一个实例：'
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For lists, `mzero` represents a nondeterministic computation that has no results
    at all—a failed computation. `mplus` joins two nondeterministic values into one.
    The `guard` function is defined like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表，`mzero` 表示一个没有任何结果的非确定性计算——一个失败的计算。`mplus` 将两个非确定性值合并为一个。`guard` 函数的定义如下：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`guard` takes a Boolean value. If that value is `True`, guard takes a `()`
    and puts it in a minimal default context that still succeeds. If the Boolean value
    is `False`, guard makes a failed monadic value. Here it is in action:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard` 接收一个布尔值。如果该值为 `True`，`guard` 接收一个 `()` 并将其放入一个最小的默认上下文中，该上下文仍然成功。如果布尔值为
    `False`，`guard` 会创建一个失败的单子值。下面是它的实际应用：'
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This looks interesting, but how is it useful? In the list monad, we use it
    to filter out nondeterministic computations:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很有趣，但它有什么用呢？在列表单子中，我们用它来过滤非确定性计算：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The result here is the same as the result of our previous list comprehension.
    How does `guard` achieve this? Let’s first see how `guard` functions in conjunction
    with `>>`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里得到的结果与之前列表推导的结果相同。`guard` 是如何实现这一点的呢？让我们先看看 `guard` 与 `>>` 的结合使用：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If `guard` succeeds, the result contained within it is an empty tuple. So then
    we use `>>` to ignore that empty tuple and present something else as the result.
    However, if `guard` fails, then so will the `return` later on, because feeding
    an empty list to a function with `>>=` always results in an empty list. `guard`
    basically says, “If this Boolean is `False`, then produce a failure right here.
    Otherwise, make a successful value that has a dummy result of `()` inside it.”
    All this does is to allow the computation to continue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`guard`成功，则其内部包含的结果是一个空元组。所以然后我们使用`>>`来忽略那个空元组，并呈现其他内容作为结果。然而，如果`guard`失败，那么稍后的`return`也会失败，因为将空列表传递给使用`>>=`的函数总是会导致空列表。`guard`基本上说，“如果这个布尔值是`False`，那么在这里产生一个失败。否则，创建一个具有空结果`()`的成功值。”所有这些只是允许计算继续。
- en: 'Here’s the previous example rewritten in `do` notation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一个例子用`do`表示法重写的样子：
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Had we forgotten to present `x` as the final result by using `return`, the
    resulting list would just be a list of empty tuples. Here’s this again in the
    form of a list comprehension:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记使用`return`将`x`作为最终结果呈现，那么结果列表将只是一个空元组的列表。这是以列表推导式的形式再次呈现：
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: So filtering in list comprehensions is the same as using `guard`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在列表推导式中进行过滤与使用`guard`相同。
- en: A Knight's Quest
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 骑士的冒险
- en: Here’s a problem that really lends itself to being solved with nondeterminism.
    Say we have a chessboard and only one knight piece on it. We want to find out
    if the knight can reach a certain position in three moves. We’ll just use a pair
    of numbers to represent the knight’s position on the chessboard. The first number
    will determine the column he is in, and the second number will determine the row.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常适合用非确定性方法解决的问题。假设我们有一个棋盘，上面只有一个骑士棋子。我们想知道这个骑士是否能在三步之内到达某个特定位置。我们只需用一对数字来表示骑士在棋盘上的位置。第一个数字将决定他所在的列，第二个数字将决定他所在的行。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802694.png.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802694.png.jpg)'
- en: 'Let’s make a type synonym for the knight’s current position on the chessboard:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为骑士在棋盘上的当前位置创建一个类型同义词：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now suppose that the knight starts at `(6, 2)`. Can he get to `(6, 1)` in exactly
    three moves? What’s the best move to make next from his current position? I know—how
    about all of them! We have nondeterminism at our disposal, so instead of picking
    one move, let’s pick all of them at once. Here is a function that takes the knight’s
    position and returns all of his next moves:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设骑士从`(6, 2)`开始。他能否在正好三步内到达`(6, 1)`？从当前位置下一步的最佳移动是什么？我知道——为什么不选择所有这些！我们有非确定性可用，所以不是选择一个移动，而是一次性选择所有这些。这是一个函数，它接受骑士的位置并返回所有可能的下一步移动：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The knight can always take one step horizontally or vertically and two steps
    horizontally or vertically, but his movement must be both horizontal and vertical.
    `(c', r')` takes on every value from the list of movements and then `guard` makes
    sure that the new move, `(c', r')`, is still on the board. If it’s not, it produces
    an empty list, which causes a failure and `return (c', r')` isn’t carried out
    for that position.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士可以始终水平或垂直移动一步，也可以水平或垂直移动两步，但他的移动必须是水平和垂直的结合。`(c', r')`取自移动列表中的每个值，然后`guard`确保新的移动`(c',
    r')`仍然在棋盘上。如果不是，它将产生一个空列表，这会导致失败，并且对于该位置不会执行`return (c', r')`。
- en: 'This function can also be written without the use of lists as monads. Here
    is how to write it using `filter`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数也可以不使用列表作为单子来编写。这是使用`filter`编写它的方法：
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Both of these versions do the same thing, so pick the one that looks nicer
    to you. Let’s give it a whirl:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本做的是同一件事，所以选择一个看起来更舒服的。让我们试试看：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Works like a charm! We take one position, and we just carry out all the possible
    moves at once, so to speak.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 工作得非常出色！我们取一个位置，然后一次性执行所有可能的移动，可以说是这样。
- en: 'So now that we have a nondeterministic next position, we just use `>>=` to
    feed it to `moveKnight`. Here’s a function that takes a position and returns all
    the positions that you can reach from it in three moves:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有了非确定性的下一个位置，我们只需使用`>>=`将其传递给`moveKnight`。这是一个函数，它接受一个位置，并返回从该位置出发三步内可以到达的所有位置：
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you pass it `(6, 2)`, the resulting list is quite big. This is because if
    there are several ways to reach some position in three moves, the move crops up
    in the list several times.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传入`(6, 2)`，生成的列表会相当大。这是因为如果用三步到达某个位置有几种方式，那么这个位置会在列表中出现多次。
- en: 'Here’s the preceding code without `do` notation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码没有使用`do`表示法的样子。
- en: '[PRE75]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Using `>>=` once gives us all possible moves from the start. When we use `>>=`
    the second time, for every possible first move, every possible next move is computed,
    and the same goes for the last move.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`>>=`一次给我们提供了从起点开始的所有可能的移动。当我们第二次使用`>>=`时，对于每一种可能的第一步移动，都会计算出每一种可能的下一步移动，最后一步也是如此。
- en: Putting a value in a default context by applying `return` to it and then feeding
    it to a function with `>>=` is the same as just normally applying the function
    to that value, but we did it here anyway for style.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`return`应用于值并将其放入默认上下文中，然后通过`>>=`将其传递给函数，与直接将函数应用于该值是相同的，但我们在这里这样做是为了风格。
- en: 'Now, let’s make a function that takes two positions and tells us if you can
    get from one to the other in exactly three steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数，它接受两个位置并告诉我们是否可以在恰好三步内从一个位置移动到另一个位置：
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We generate all the possible positions in three steps, and then we see if the
    position we’re looking for is among them. Here’s how to check if we can get from
    `(6, 2)` to `(6, 1)` in three moves:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过三个步骤生成所有可能的位置，然后我们看看我们正在寻找的位置是否在其中。以下是如何检查在三次移动内能否从`(6, 2)`移动到`(6, 1)`的示例：
- en: '[PRE77]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Yes! How about from `(6, 2)` to `(7, 3)`?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！那么从`(6, 2)`到`(7, 3)`呢？
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: No! As an exercise, you can change this function so that when you can reach
    one position from the other, it tells you which move to take. In [Chapter 14](ch14.html
    "Chapter 14. For a Few Monads More"), you’ll see how to modify this function so
    that we also pass it the number of moves to take, instead of that number being
    hardcoded as it is now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 不！作为一个练习，你可以修改这个函数，以便当你可以从一个位置到达另一个位置时，它告诉你应该采取哪种移动。在[第14章](ch14.html "第14章。更多单子")中，你会看到如何修改这个函数，以便我们也可以传递要采取的移动次数，而不是像现在这样硬编码这个数字。
- en: Monad Laws
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子法则
- en: Just like functors and applicative functors, monads come with a few laws that
    all monad instances must abide by. Just because something is made an instance
    of the `Monad` type class doesn’t mean that it’s actually a monad. For a type
    to truly be a monad, the monad laws must hold for that type. These laws allow
    us to make reasonable assumptions about the type and its behavior.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函子和应用函子一样，单子附带了一些所有单子实例都必须遵守的法则。仅仅因为某物被制作成`Monad`类型类的实例，并不意味着它实际上是一个单子。为了一个类型真正成为单子，该类型的单子法则必须成立。这些法则允许我们对类型及其行为做出合理的假设。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802696.png.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802696.png.jpg)'
- en: Haskell allows any type to be an instance of any type class as long as the types
    check out. It can’t check if the monad laws hold for a type though, so if we’re
    making a new instance of the `Monad` type class, we need to be reasonably sure
    that all is well with the monad laws for that type. We can rely on the types that
    come with the standard library to satisfy the laws, but when we go about making
    our own monads, we need to manually check whether the laws hold. But don’t worry,
    they’re not complicated.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 允许任何类型都可以成为任何类型类的实例，只要类型检查通过。但是，它无法检查类型是否满足单子法则，因此如果我们正在创建`Monad`类型类的新的实例，我们需要合理地确信该类型的单子法则一切正常。我们可以依赖标准库中提供的类型来满足这些法则，但当我们着手创建自己的单子时，我们需要手动检查这些法则是否成立。但别担心，它们并不复杂。
- en: Left Identity
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 左恒等性
- en: The first monad law states that if we take a value, put it in a default context
    with `return`, and then feed it to a function by using `>>=`, that’s the same
    as just taking the value and applying the function to it. To put it formally,
    `return x >>= f` is the same damn thing as `f x`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单子法则指出，如果我们取一个值，将其放入与`return`相关的默认上下文中，然后通过使用`>>=`将其传递给一个函数，那么这和仅仅取这个值并对其应用函数是相同的。用正式的说法，`return
    x >>= f`和`f x`是同一件该死的事情。
- en: If you look at monadic values as values with a context, and `return` as taking
    a value and putting it in a default minimal context that still presents that value
    as the function’s result, this law makes sense. If that context is really minimal,
    feeding this monadic value to a function shouldn’t be much different than just
    applying the function to the normal value—and indeed, it isn’t different at all.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将单子值视为具有上下文的值，将`return`视为将值放入一个默认的最小上下文中，该上下文仍然将值作为函数的结果呈现，那么这个法则是有意义的。如果这个上下文真的很小，将这个单子值传递给函数不应该与直接应用函数到正常值有很大不同——实际上，它确实没有不同。
- en: 'For the `Maybe` monad, `return` is defined as `Just`. The `Maybe` monad is
    all about possible failure, and if we have a value that we want to put in such
    a context, treating it as a successful computation makes sense, because we know
    what the value is. Here are some examples of `return` usage with `Maybe`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For the list monad, `return` puts something in a singleton list. The `>>=`
    implementation for lists goes over all the values in the list and applies the
    function to them. However, since there’s only one value in a singleton list, it’s
    the same as applying the function to that value:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You’ve learned that for `IO`, using `return` makes an I/O action that has no
    side effects but just presents a value as its result. So it makes sense that this
    law holds for `IO` as well.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Right Identity
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second law states that if we have a monadic value and we use `>>=` to feed
    it to `return`, the result is our original monadic value. Formally, `m >>= return`
    is no different than just `m`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: This law might be a bit less obvious than the first one. Let’s take a look at
    why it should hold. When we feed monadic values to functions by using `>>=`, those
    functions take normal values and return monadic ones. `return` is also one such
    function, if you consider its type.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`return` puts a value in a minimal context that still presents that value as
    its result. This means that, for instance, for `Maybe`, it doesn’t introduce any
    failure; for lists, it doesn’t introduce any extra nondeterminism.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test run for a few monads:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In this list example, the implementation for `>>=` is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: So when we feed `[1,2,3,4]` to `return`, first `return` gets mapped over `[1,2,3,
    4]`, resulting in `[[1],[2],[3],[4]]`. Then this is concatenated, and we have
    our original list.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Left identity and right identity are basically laws that describe how `return`
    should behave. It’s an important function for making normal values into monadic
    ones, and it wouldn’t be good if the monadic value that it produced had any more
    than the minimal context needed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final monad law says that when we have a chain of monadic function applications
    with `>>=`, it shouldn’t matter how they’re nested. Formally written, doing `(m
    >>= f) >>= g` is just like doing `m >>= (\x -> f x >>= g)`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Hmmm, now what’s going on here? We have one monadic value, `m`, and two monadic
    functions, `f` and `g`. When we’re using `(m >>= f) >>= g`, we’re feeding `m`
    to `f`, which results in a monadic value. Then we feed that monadic value to `g`.
    In the expression `m >>= (\x -> f x >>= g)`, we take a monadic value and we give
    it to a function that feeds the result of `f x` to `g`. It’s not easy to see how
    those two are equal, so let’s take a look at an example that makes this equality
    a bit clearer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember when we had our tightrope walker, Pierre, walk a rope while birds
    landed on his balancing pole? To simulate birds landing on his balancing pole,
    we made a chain of several functions that might produce failure:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We started with `Just (0, 0)` and then bound that value to the next monadic
    function, `landRight 2`. The result of that was another monadic value, which got
    bound to the next monadic function, and so on. If we were to explicitly parenthesize
    this, we would write the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Just (0, 0)`开始，然后将该值绑定到下一个单子函数`landRight 2`。这个结果又是一个单子值，然后被绑定到下一个单子函数，以此类推。如果我们显式地添加括号，我们会写成以下这样：
- en: '[PRE84]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'But we can also write the routine like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以这样写程序：
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`return (0, 0)` is the same as `Just (0, 0)`, and when we feed it to the lambda,
    the `x` becomes `(0, 0)`. `landRight` takes a number of birds and a pole (a tuple
    of numbers), and that’s what it gets passed. This results in a `Just (0, 2)`,
    and when we feed this to the next lambda, `y` is `(0, 2)`. This goes on until
    the final bird landing produces a `Just (2, 4)`, which is indeed the result of
    the whole expression.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`return (0, 0)`与`Just (0, 0)`相同，当我们将其喂给lambda函数时，`x`变为`(0, 0)`。`landRight`接受一些鸟和一根杆（一个数字元组），这就是它接收到的。这导致了一个`Just
    (0, 2)`，然后我们将其喂给下一个lambda函数，此时`y`是`(0, 2)`。这个过程一直持续到最后的鸟着陆，产生一个`Just (2, 4)`，这正是整个表达式的结果。'
- en: 'So it doesn’t matter how you nest feeding values to monadic functions. What
    matters is their meaning. Let’s consider another way to look at this law. Suppose
    we compose two functions named `f` and `g`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你如何嵌套向单子函数传递值并不重要。重要的是它们的含义。让我们考虑另一种看待这条法则的方式。假设我们组合两个名为`f`和`g`的函数：
- en: '[PRE86]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If the type of `g` is `a -> b` and the type of `f` is `b -> c`, we arrange them
    into a new function that has a type of `a -> c`, so that its parameter is passed
    between those functions. Now what if those two functions were monadic? What if
    the values they returned were monadic values? If we had a function of type `a
    -> m b`, we couldn’t just pass its result to a function of type `b -> m c`, because
    that function accepts a normal `b`, not a monadic one. We could, however, use
    `>>=` to make that happen.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`g`的类型是`a -> b`，而`f`的类型是`b -> c`，我们将它们排列成一个新函数，该函数的类型是`a -> c`，这样它的参数就可以在那些函数之间传递。现在，如果这两个函数都是单子呢？如果它们返回的值是单子值呢？如果我们有一个类型为`a
    -> m b`的函数，我们不能直接将其结果传递给一个类型为`b -> m c`的函数，因为这个函数接受一个普通的`b`，而不是单子。然而，我们可以使用`>>=`来实现这一点。
- en: '[PRE87]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'So now we can compose two monadic functions:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以组合两个单子函数：
- en: '[PRE88]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Okay, that’s cool. But what does that have to do with the associativity law?
    Well, when we look at the law as a law of compositions, it states that `f <=<
    (g <=< h)` should be the same as `(f <=< g) <=< h`. This is just another way of
    saying that for monads, the nesting of operations shouldn’t matter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很酷。但这与结合律有什么关系呢？嗯，当我们把这条法则看作是组合的法则时，它表明`f <=< (g <=< h)`应该与`(f <=< g) <=<
    h`相同。这只是另一种说法，即对于单子来说，操作的嵌套不应该很重要。
- en: If we translate the first two laws to use `<=<`, then the left identity law
    states that for every monadic function `f`, `f <=< return` is the same as writing
    just `f`. The right identity law says that `return <=< f` is also no different
    from `f`. This is similar to how if `f` is a normal function, `(f . g) . h` is
    the same as `f . (g . h)`, `f . id` is always the same as `f`, and `id . f` is
    also just `f`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前两条法则翻译成使用`<=<`，那么左单位法则表明对于每个单子函数`f`，`f <=< return`与简单地写`f`相同。右单位法则说`return
    <=< f`也与`f`没有区别。这与如果`f`是一个普通函数，`(f . g) . h`与`f . (g . h)`相同，`f . id`始终与`f`相同，以及`id
    . f`也只是`f`类似。
- en: In this chapter, we took a look at the basics of monads and learned how the
    `Maybe` monad and the list monad work. In the next chapter, we’ll explore a whole
    bunch of other cool monads, and we’ll also make our own.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了单子的基础知识，并学习了`Maybe`单子和列表单子是如何工作的。在下一章，我们将探索许多其他酷炫的单子，我们还将自己创建一些。
