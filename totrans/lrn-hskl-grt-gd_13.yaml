- en: Chapter 13. A Fistful of Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we first talked about functors in [Chapter 7](ch07.html "Chapter 7. Making
    Our Own Types and Type Classes"), you saw that they are a useful concept for values
    that can be mapped over. Then, in [Chapter 11](ch11.html "Chapter 11. Applicative
    Functors"), we took that concept one step further with applicative functors, which
    allow us to view values of certain data types as values with contexts and use
    normal functions on those values while preserving the meaning of those contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about *monads*, which are just beefed-up applicative
    functors, much like applicative functors are beefed-up functors.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading Our Applicative Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we started off with functors, you saw that it’s possible to map functions
    over various data types using the `Functor` type class. The introduction to functors
    had us asking the question, “When we have a function of type `a -> b` and some
    data type `f a`, how do we map that function over the data type to end up with
    `f b`?” You saw how to map something over a `Maybe a`, a list `[a]`, an `IO a`,
    and so on. You even saw how to map a function `a -> b` over other functions of
    type `r -> a` to get functions of type `r -> b`. To answer the question of how
    to map a function over some data type, all we needed to do was look at the type
    of `fmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802674.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And then we just needed to make it work for our data type by writing the appropriate
    `Functor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you saw a possible improvement of functors and had a few more questions.
    What if that function `a -> b` is already wrapped inside a functor value? Say
    we have `Just (*3)`—how do we apply that to `Just 5`? What if we don’t want to
    apply it to `Just 5`, but to a `Nothing` instead? Or if we have `[(*2),(+4)]`,
    how do we apply that to `[1,2,3]`? How could that even work? For this, the `Applicative`
    type class was introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You also saw that you can take a normal value and wrap it inside a data type.
    For instance, we can take a `1` and wrap it so that it becomes a `Just 1`. Or
    we can make it into a `[1]`. It could even become an I/O action that does nothing
    and just yields `1`. The function that does this is called `pure`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An applicative value can be seen as a value with an added context—a *fancy*
    value, to put it in technical terms. For instance, the character `''a''` is just
    a normal character, whereas `Just ''a''` has some added context. Instead of a
    `Char`, we have a `Maybe Char`, which tells us that its value might be a character,
    but it could also be an absence of a character. The `Applicative` type class allows
    us to use normal functions on these values with context, and that context is preserved.
    Observe an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So now that we treat them as applicative values, `Maybe a` values represent
    computations that might have failed, `[a]` values represent computations that
    have several results (nondeterministic computations), `IO a` values represent
    values that have side effects, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Monads are a natural extension of applicative functors, and they provide a
    solution to the following problem: If we have a value with a context, `m a`, how
    do we apply to it a function that takes a normal `a` and returns a value with
    a context? In other words, how do we apply a function of type `a -> m b` to a
    value of type `m a`? Essentially, we want this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we have a fancy value and a function that takes a normal value but returns
    a fancy value, how do we feed that fancy value into the function? This is the
    main concern when dealing with monads. We write `m a` instead of `f a`, because
    the `m` stands for `Monad`, but monads are just applicative functors that support
    `>>=`. The `>>=` function is called *bind*.
  prefs: []
  type: TYPE_NORMAL
- en: When we have a normal value `a` and a normal function `a -> b`, it’s really
    easy to feed the value to the function—we just apply the function to the value
    normally, and that’s it. But when we’re dealing with values that come with certain
    contexts, it takes a bit of thinking to see how these fancy values are fed to
    functions and how to take into account their behavior. But you’ll see that it’s
    as easy as one, two, three.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Your Feet Wet with Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a vague idea of what monads are about, let’s make that idea
    a little more concrete. Much to no one’s surprise, `Maybe` is a monad. Here, we’ll
    explore it a bit more to see how it works in this role.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you understand applicative functors at this point. (We discussed them
    in [Chapter 11](ch11.html "Chapter 11. Applicative Functors").) You should have
    a feel for how the various `Applicative` instances work and what kinds of computations
    they represent. To understand monads, you’ll be taking your existing applicative
    functor knowledge and upgrading it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802676.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A value of type `Maybe a` represents a value of type `a`, but with the context
    of possible failure attached. A value of `Just "dharma"` means that the string
    `"dharma"` is there. A value of `Nothing` represents its absence, or if you look
    at the string as the result of a computation, it means that the computation has
    failed.
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at `Maybe` as a functor, we saw that if we want to `fmap` a function
    over it, the function is mapped over what’s inside if that’s a `Just` value. Otherwise,
    the `Nothing` is kept, because there’s nothing to map it over!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As an applicative functor, `Maybe` functions similarly. However, with applicative
    functors, the function itself is in a context, along with the value to which it’s
    being applied. `Maybe` is an applicative functor in such a way that when we use
    `<*>` to apply a function inside a `Maybe` to a value that’s inside a `Maybe`,
    they both must be `Just` values for the result to be a `Just` value; otherwise,
    the result is `Nothing`. This makes sense. If you’re missing either the function
    or the thing you’re applying it to, you can’t make something up out of thin air,
    so you need to propagate the failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the applicative style to have normal functions act on `Maybe` values works
    in a similar way. All the values must be `Just` values; otherwise, it’s all for
    `Nothing`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And now, let’s think about how we would use `>>=` with `Maybe`. `>>=` takes
    a monadic value and a function that takes a normal value. It returns a monadic
    value and manages to apply that function to the monadic value. How does it do
    that if the function takes a normal value? Well, it must take into account the
    context of that monadic value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, `>>=` would take a `Maybe a` value and a function of type `a
    -> Maybe b`, and somehow apply the function to the `Maybe a`. To figure out how
    it does that, we can use the understanding that we have from `Maybe` being an
    applicative functor. Let’s say that we have a function `\x -> Just (x+1)`. It
    takes a number, adds `1` to it, and wraps it in a `Just`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we feed it `1`, it evaluates to `Just 2`. If we give it the number `100`,
    the result is `Just 101`. It seems very straightforward. But how do we feed a
    `Maybe` value to this function? If we think about how `Maybe` acts as an applicative
    functor, answering this is pretty easy. We feed it a `Just` value, take what’s
    inside the `Just`, and apply the function to it. If we give it a `Nothing`, then
    we’re left with a function but `Nothing` to apply it to. In that case, let’s just
    do what we did before and say that the result is `Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of calling it `>>=`, let’s call it `applyMaybe` for now. It takes a
    `Maybe a` and a function that returns a `Maybe b`, and manages to apply that function
    to the `Maybe a`. Here it is in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s play with it. We’ll use it as an infix function so that the `Maybe`
    value is on the left side and the function is on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, when we used `applyMaybe` with a `Just` value and a function,
    the function was simply applied to the value inside the `Just`. When we tried
    to use it with a `Nothing`, the whole result was `Nothing`. What about if the
    function returns a `Nothing`? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The results are just what we expected. If the monadic value on the left is a
    `Nothing`, the whole thing is `Nothing`. And if the function on the right returns
    a `Nothing`, the result is `Nothing` again. This is similar to when we used `Maybe`
    as an applicative and we got a `Nothing` result if there was a `Nothing` somewhere
    in the mix.
  prefs: []
  type: TYPE_NORMAL
- en: It looks like we’ve figured out how to take a fancy value, feed it to a function
    that takes a normal value, and return a fancy one. We did this by keeping in mind
    that a `Maybe` value represents a computation that might have failed.
  prefs: []
  type: TYPE_NORMAL
- en: You might be asking yourself, “How is this useful?” It may seem like applicative
    functors are stronger than monads, since applicative functors allow us to take
    a normal function and make it operate on values with contexts. In this chapter,
    you’ll see that monads, as an upgrade of applicative functors, can also do that.
    In fact, they can do some other cool stuff that applicative functors can’t do.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll come back to `Maybe` in a minute, but first, let’s check out the type
    class that belongs to monads.
  prefs: []
  type: TYPE_NORMAL
- en: The Monad Type Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like functors have the `Functor` type class, and applicative functors
    have the `Applicative` type class, monads come with their own type class: `Monad`!
    (Wow, who would have thought?)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line says `class Monad m where`. But wait, didn’t I say that monads
    are just beefed-up applicative functors? Shouldn’t there be a class constraint
    in there along the lines of `class (Applicative m) = > Monad m where`, so that
    a type must be an applicative functor before it can be made a monad? Well, there
    should, but when Haskell was made, it hadn’t occurred to people that applicative
    functors were a good fit for Haskell. But rest assured, every monad is an applicative
    functor, even if the `Monad` class declaration doesn’t say so.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802678.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first function that the `Monad` type class defines is `return`. It’s the
    same as `pure` from the `Applicative` type class. So, even though it has a different
    name, you’re already acquainted with it. `return`’s type is `(Monad m) => a ->
    m a`. It takes a value and puts it in a minimal default context that still holds
    that value. In other words, `return` takes something and wraps it in a monad.
    We already used `return` when handling I/O in [Chapter 8](ch08.html "Chapter 8. Input
    and Output"). We used it to take a value and make a bogus I/O action that does
    nothing but yield that value. For `Maybe`, it takes a value and wraps it in a
    `Just`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just a reminder: `return` is nothing like the `return` that’s in most other
    languages. It doesn’t end function execution. It just takes a normal value and
    puts it in a context.'
  prefs: []
  type: TYPE_NORMAL
- en: The next function is `>>=`, or bind. It’s like function application, but instead
    of taking a normal value and feeding it to a normal function, it takes a monadic
    value (that is, a value with a context) and feeds it to a function that takes
    a normal value but returns a monadic value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802680.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next up, we have `>>=`. We won’t pay too much attention to it for now because
    it comes with a default implementation, and it’s rarely implemented when making
    `Monad` instances. We’ll take a closer look at it in [Banana on a Wire](ch13s04.html#banana_on_a_wire
    "Banana on a Wire") in [Banana on a Wire](ch13s04.html#banana_on_a_wire "Banana
    on a Wire").
  prefs: []
  type: TYPE_NORMAL
- en: The final function of the `Monad` type class is `fail`. We never use it explicitly
    in our code. Instead, it’s used by Haskell to enable failure in a special syntactic
    construct for monads that you’ll meet later. We don’t need to concern ourselves
    with `fail` too much for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what the `Monad` type class looks like, let’s take a look
    at how `Maybe` is an instance of `Monad`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`return` is the same as `pure`, so that one is a no-brainer. We do what we
    did in the `Applicative` type class and wrap it in a `Just`. The `>>=` function
    is the same as our `applyMaybe`. When feeding the `Maybe a` to our function, we
    keep in mind the context and return a `Nothing` if the value on the left is `Nothing`
    Again, if there’s no value, then there’s no way to apply our function to it. If
    it’s a `Just`, we take what’s inside and apply `f` to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can play around with `Maybe` as a monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing new or exciting on the first line, since we already used `pure`
    with `Maybe`, and we know that `return` is just `pure` with a different name.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines showcase `>>=` a bit more. Notice how when we fed `Just 9`
    to the function `\x -> return (x*10)`, the `x` took on the value `9` inside the
    function. It seems as though we were able to extract the value from a `Maybe`
    without pattern matching. And we still didn’t lose the context of our `Maybe`
    value, because when it’s `Nothing`, the result of using `>>=` will be `Nothing`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Walk the Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to feed a `Maybe a` value to a function of type `a ->
    Maybe b` while taking into account the context of possible failure, let’s see
    how we can use `>>=` repeatedly to handle computations of several `Maybe a` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pierre has decided to take a break from his job at the fish farm and try tightrope
    walking. He is not that bad at it, but he does have one problem: Birds keep landing
    on his balancing pole! They come and take a short rest, chat with their avian
    friends, and then take off in search of breadcrumbs. This wouldn’t bother him
    so much if the number of birds on the left side of the pole were always equal
    to the number of birds on the right side. But sometimes, all the birds decide
    that they like one side better. They throw him off balance, which results in an
    embarrassing tumble for Pierre (he is using a safety net).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802682.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s say that Pierre keeps his balance if the number of birds on the left side
    of the pole and on the right side of the pole is within three. So if there’s one
    bird on the right side and four birds on the left side, he is okay. But if a fifth
    bird lands on the left side, he loses his balance and takes a dive.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to simulate birds landing on and flying away from the pole and see
    if Pierre is still at it after a certain number of bird arrivals and departures.
    For instance, we want to see what happens to Pierre if first one bird arrives
    on the left side, then four birds occupy the right side, and then the bird that
    was on the left side decides to fly away.
  prefs: []
  type: TYPE_NORMAL
- en: Code, Code, Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can represent the pole with a simple pair of integers. The first component
    will signify the number of birds on the left side and the second component the
    number of birds on the right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we made a type synonym for `Int`, called `Birds`, because we’re using
    integers to represent how many birds there are. And then we made a type synonym
    `(Birds, Birds)` and called it `Pole` (not to be confused with a person of Polish
    descent).
  prefs: []
  type: TYPE_NORMAL
- en: Now, how about adding functions that take a number of birds and land them on
    one side of the pole or the other?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To make birds fly away, we just had a negative number of birds land on one
    side. Because landing a bird on the `Pole` returns a `Pole`, we can chain applications
    of `landLeft` and `landRight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply the function `landLeft 1` to `(0, 0)` we get `(1, 0)`. Then we
    land a bird on the right side, resulting in `(1, 1)`. Finally, two birds land
    on the left side, resulting in `(3, 1)`. We apply a function to something by first
    writing the function and then writing its parameter, but here it would be better
    if the pole went first and then the landing function. Suppose we make a function
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply functions by first writing the parameter and then the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this form, we can repeatedly land birds on the pole in a more readable
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Pretty cool! This version is equivalent to the one before where we repeatedly
    landed birds on the pole, but it looks neater. Here, it’s more obvious that we
    start off with `(0, 0)` and then land one bird on the left, then one on the right,
    and finally, two on the left.
  prefs: []
  type: TYPE_NORMAL
- en: I'll Fly Away
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far so good, but what happens if ten birds land on one side?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Ten birds on the left side and only three on the right? That’s sure to send
    poor Pierre falling through the air! This is pretty obvious here, but what if
    we had a sequence of landings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It might seem as if everything is okay, but if you follow the steps here, you’ll
    see that at one time there are four birds on the right side and no birds on the
    left! To fix this, we need to take another look at our `landLeft` and `landRight`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the `landLeft` and `landRight` functions to be able to fail. We want
    them to return a new pole if the balance is okay but fail if the birds land in
    a lopsided manner. And what better way to add a context of failure to value than
    by using `Maybe`! Let’s rework these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Instead of returning a `Pole`, these functions now return a `Maybe Pole`. They
    still take the number of birds and the old pole as before, but then they check
    if landing that many birds on the pole would throw Pierre off balance. We use
    guards to check if the difference between the number of birds on the new pole
    is less than `4`. If it is, we wrap the new pole in a `Just` and return that.
    If it isn’t, we return a `Nothing`, indicating failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give these babies a go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When we land birds without throwing Pierre off balance, we get a new pole wrapped
    in a `Just`. But when many more birds end up on one side of the pole, we get a
    `Nothing`. This is cool, but we seem to have lost the ability to repeatedly land
    birds on the pole. We can’t do `landLeft 1 (landRight 1 (0, 0))` anymore, because
    when we apply `landRight 1` to `(0, 0)`, we don’t get a `Pole`, but a `Maybe Pole`.
    `landLeft 1` takes a `Pole`, rather than a `Maybe Pole`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a way of taking a `Maybe Pole` and feeding it to a function that takes
    a `Pole` and returns a `Maybe Pole`. Luckily, we have `>>=`, which does just that
    for `Maybe`. Let’s give it a go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `landLeft 2` has a type of `Pole -> Maybe Pole`. We couldn’t
    just feed it the `Maybe Pole` that is the result of `landRight 1 (0, 0)`, so we
    use `>>=` to take that value with a context and give it to `landLeft 2`. `>>=`
    does indeed allow us to treat the `Maybe` value as a value with context. If we
    feed a `Nothing` into `landLeft 2`, the result is `Nothing`, and the failure is
    propagated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can now chain landings that may fail, because `>>=` allows us
    to feed a monadic value to a function that takes a normal one. Here’s a sequence
    of bird landings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, we used `return` to take a pole and wrap it in a `Just`. We
    could have just applied `landRight 2` to `(0, 0)`—it would have been the same—but
    this way, we can be more consistent by using `>>=` for every function. `Just (0,
    0)` is fed to `landRight 2`, resulting in `Just (0, 2)`. This, in turn, gets fed
    to `landLeft 2`, resulting in `Just (2, 2)`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the following example from before we introduced failure into Pierre’s
    routine?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It didn’t simulate his interaction with birds very well. In the middle, his
    balance was off, but the result didn’t reflect that. Let’s fix that now by using
    monadic application (`>>=`) instead of normal application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result represents failure, which is what we expected. Let’s see how
    this result was obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '`return` puts `(0, 0)` into a default context, making it a `Just (0, 0)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Just (0, 0) >>= landLeft 1` happens. Since the `Just (0, 0)` is a `Just` value,
    `landLeft 1` gets applied to `(0, 0)`, resulting in a `Just (1, 0)`, because the
    birds are still relatively balanced.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Just (1, 0) >>= landRight 4` takes place, and the result is `Just (1, 4)`,
    as the balance of the birds is still intact, although just barely.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Just (1, 4)` gets fed to `landLeft (-1)`. This means that `landLeft (-1) (1,
    4)` takes place. Now because of how `landLeft` works, this results in a `Nothing`,
    because the resulting pole is off balance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a `Nothing`, it gets fed to `landRight (-2)`, but because it’s
    a `Nothing`, the result is automatically `Nothing`, as we have nothing to apply
    `landRight (-2)` to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We couldn’t have achieved this by just using `Maybe` as an applicative. If you
    try it, you’ll get stuck, because applicative functors don’t allow for the applicative
    values to interact with each other very much. They can, at best, be used as parameters
    to a function by using the applicative style.
  prefs: []
  type: TYPE_NORMAL
- en: The applicative operators will fetch their results and feed them to the function
    in a manner appropriate for each applicative, and then put the final applicative
    value together, but there isn’t that much interaction going on between them. Here,
    however, each step relies on the previous one’s result. On every landing, the
    possible result from the previous one is examined and the pole is checked for
    balance. This determines whether the landing will succeed or fail.
  prefs: []
  type: TYPE_NORMAL
- en: Banana on a Wire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s devise a function that ignores the current number of birds on the
    balancing pole and just makes Pierre slip and fall. We’ll call it `banana`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802684.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can chain this function together with our bird landings. It will always cause
    our walker to fall, because it ignores whatever is passed to it and always returns
    a failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The value `Just (1, 0)` gets fed to `banana`, but it produces a `Nothing`, which
    causes everything to result in a `Nothing`. How unfortunate!
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of making functions that ignore their input and just return a predetermined
    monadic value, we can use the `>>` function. Here’s its default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, passing some value to a function that ignores its parameter and always
    returns some predetermined value always results in that predetermined value. With
    monads, however, their context and meaning must be considered as well. Here’s
    how `>>` acts with `Maybe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If we replace `>>` with `>>= \_ ->`, it’s easy to see what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace our `banana` function in the chain with a `>>` and then a `Nothing`
    for guaranteed and obvious failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What would this look like if we hadn’t made the clever choice of treating `Maybe`
    values as values with a failure context and feeding them to functions? Here’s
    how a series of bird landings would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We land a bird on the left, and then we examine the possibility of failure and
    the possibility of success. In the case of failure, we return a `Nothing`. In
    the case of success, we land birds on the right and then do the same thing all
    over again. Converting this monstrosity into a neat chain of monadic applications
    with `>>=` is a classic example of how the `Maybe` monad saves a lot of time when
    you need to successively do computations that are based on computations that might
    have failed.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the `Maybe` implementation of `>>=` features exactly this logic of
    seeing if a value is `Nothing` and acting on that knowledge. If the value is `Nothing`,
    it returns a `Nothing` immediately. If the value is not `Nothing`, it goes forward
    with what’s inside the `Just`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802686.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we looked at how some functions work better when the values
    that they return support failure. By turning those values into `Maybe` values
    and replacing normal function application with `>>=`, we got a mechanism for handling
    failure pretty much for free. This is because `>>=` is supposed to preserve the
    context of the value to which it applies functions. In this case, the context
    was that our values were values with failure. So, when we applied functions to
    such values, the possibility of failure was always taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: do Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Monads in Haskell are so useful that they got their own special syntax, called
    `do` notation. You already encountered `do` notation in [Chapter 8](ch08.html
    "Chapter 8. Input and Output"), when we used it for gluing together several I/O
    actions into one. Well, as it turns out, `do` notation isn’t just for `IO` but
    can be used for any monad. Its principle is still the same: gluing together monadic
    values in sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this familiar example of monadic application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Been there, done that. Feeding a monadic value to a function that returns one—no
    big deal. Notice how when we do this, `x` becomes `3` inside the lambda. Once
    we’re inside that lambda, it’s just a normal value rather than a monadic value.
    Now, what if we had another `>>=` inside that function? Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah, a nested use of `>>=`! In the outermost lambda, we feed `Just "!"` to the
    lambda `\y -> Just (show x ++ y)`. Inside this lambda, the `y` becomes `"!"`.
    `x` is still `3`, because we got it from the outer lambda. All this sort of reminds
    me of the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference here is that the values in our `>>=` example are monadic.
    They are values with a failure context. We can replace any of them with a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, feeding a `Nothing` to a function naturally results in a
    `Nothing`. In the second line, we feed `Just 3` to a function, and the `x` becomes
    `3`. But then we feed a `Nothing` to the inner lambda, and the result of that
    is `Nothing`, which causes the outer lambda to produce `Nothing` as well. So this
    is sort of like assigning values to variables in `let` expressions, except that
    the values in question are monadic values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate this point, let’s write this in a script and have each
    `Maybe` value take up its own line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To save us from writing all these annoying lambdas, Haskell gives us `do` notation.
    It allows us to write the previous piece of code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802688.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It would seem as though we’ve gained the ability to temporarily extract things
    from `Maybe` values without needing to check if the `Maybe` values are `Just`
    values or `Nothing` values at every step. How cool! If any of the values that
    we try to extract from are `Nothing`, the whole `do` expression will result in
    a `Nothing`. We’re yanking out their (possibly existing) values and letting `>>=`
    worry about the context that comes with those values.
  prefs: []
  type: TYPE_NORMAL
- en: '`do` expressions are just different syntax for chaining monadic values.'
  prefs: []
  type: TYPE_NORMAL
- en: Do As I Do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a `do` expression, every line that isn’t a `let` line is a monadic value.
    To inspect its result, we use `<-`. If we have a `Maybe String` and we bind it
    to a variable with `<-`, that variable will be a `String`, just as when we used
    `>>=` to feed monadic values to lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last monadic value in a `do` expression—like `Just (show x ++ y)` here—can’t
    be used with `<-` to bind its result, because that wouldn’t make sense if we translated
    the `do` expression back to a chain of `>>=` applications. Rather, its result
    is the result of the whole glued-up monadic value, taking into account the possible
    failure of any of the previous ones. For instance, examine the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the left parameter of `>>=` is a `Just` value, the lambda is applied
    to `9`, and the result is a `Just True`. We can rewrite this in `do` notation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Comparing these two versions, it’s easy to see why the result of the whole monadic
    value is the result of the last monadic value in the `do` expression with all
    the previous ones chained into it.
  prefs: []
  type: TYPE_NORMAL
- en: Pierre Returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our tightrope walker’s routine can also be expressed with `do` notation. `landLeft`
    and `landRight` take a number of birds and a pole and produce a pole wrapped in
    a `Just`. The exception is when the tightrope walker slips, in which case a `Nothing`
    is produced. We used `>>=` to chain successive steps because each one relied on
    the previous one, and each one had an added context of possible failure. Here
    are two birds landing on the left side, then two birds landing on the right, and
    then one bird landing on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see if he succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: He does!
  prefs: []
  type: TYPE_NORMAL
- en: When we were doing these routines by explicitly writing `>>=`, we usually said
    something like `return (0, 0) >>= landLeft 2`, because `landLeft 2` is a function
    that returns a `Maybe` value. However, with `do` expressions, each line must feature
    a monadic value. So we explicitly pass the previous `Pole` to the `landLeft landRight`
    functions. If we examined the variables to which we bound our `Maybe` values,
    `start` would be `(0, 0)`, `first` would be `(2, 0)` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Because `do` expressions are written line by line, they may look like imperative
    code to some people. But they’re just sequential, as each value in each line relies
    on the result of the previous ones, along with their contexts (in this case, whether
    they succeeded or failed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let’s take a look at what this piece of code would look like if we hadn’t
    used the monadic aspects of `Maybe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See how in the case of success, the tuple inside `Just (0, 0)` becomes `start`,
    the result of `landLeft 2 start` becomes `first`, and so on?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to throw Pierre a banana peel in `do` notation, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When we write a line in `do` notation without binding the monadic value with
    `<-`, it’s just like putting `>>` after the monadic value whose result we want
    to ignore. We sequence the monadic value but we ignore its result, because we
    don’t care what it is. Plus, it’s prettier than writing its equivalent form of
    `_ <- Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: When to use `do` notation and when to explicitly use `>>=` is up to you. I think
    this example lends itself to explicitly writing `>>=`, because each step relies
    specifically on the result of the previous one. With `do` notation, we need to
    specifically write on which pole the birds are landing, but every time we just
    use the pole that was the result of the previous landing. But still, it gave us
    some insight into `do` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern Matching and Failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `do` notation, when we bind monadic values to names, we can utilize pattern
    matching, just as in `let` expressions and function parameters. Here’s an example
    of pattern matching in a `do` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We use pattern matching to get the first character of the string `"hello"`,
    and then we present it as the result. So `justH` evaluates to `Just 'h'`.
  prefs: []
  type: TYPE_NORMAL
- en: What if this pattern matching were to fail? When matching on a pattern in a
    function fails, the next pattern is matched. If the matching falls through all
    the patterns for a given function, an error is thrown, and the program crashes.
    On the other hand, failed pattern matching in `let` expressions results in an
    error being produced immediately, because the mechanism of falling through patterns
    isn’t present in `let` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When pattern matching fails in a `do` expression, the `fail` function (part
    of the `Monad` type class) enables it to result in a failure in the context of
    the current monad, instead of making the program crash. Here’s its default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'So, by default, it does make the program crash. But monads that incorporate
    a context of possible failure (like `Maybe`) usually implement it on their own.
    For `Maybe`, it’s implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It ignores the error message and makes a `Nothing`. So when pattern matching
    fails in a `Maybe` value that’s written in `do` notation, the whole value results
    in a `Nothing`. This is preferable to having your program crash. Here’s a `do`
    expression with a pattern match that’s bound to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern matching fails, so the effect is the same as if the whole line
    with the pattern were replaced with a `Nothing`. Let’s try this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The failed pattern matching has caused a failure within the context of our monad
    instead of causing a program-wide failure, which is pretty neat.
  prefs: []
  type: TYPE_NORMAL
- en: The List Monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve seen how `Maybe` values can be viewed as values with a failure
    context, and how we can incorporate failure handling into our code by using `>>=`
    to feed them to functions. In this section, we’re going to take a look at how
    to use the monadic aspects of lists to bring nondeterminism into our code in a
    clear and readable manner.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802690.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 11](ch11.html "Chapter 11. Applicative Functors"), we talked about
    how lists represent nondeterministic values when they’re used as applicatives.
    A value like `5` is deterministic—it has only one result, and we know exactly
    what it is. On the other hand, a value like `[3,8,9]` contains several results,
    so we can view it as one value that is actually many values at the same time.
    Using lists as applicative functors showcases this nondeterminism nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: All the possible combinations of multiplying elements from the left list with
    elements from the right list are included in the resulting list. When dealing
    with nondeterminism, there are many choices that we can make, so we just try all
    of them. This means the result is a nondeterministic value as well, but it has
    many more results.
  prefs: []
  type: TYPE_NORMAL
- en: 'This context of nondeterminism translates to monads very nicely. Here’s what
    the `Monad` instance for lists looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you know, `return` does the same thing as `pure`, and you’re already familiar
    with `return` for lists. `return` takes a value and puts it in a minimal default
    context that still yields that value. In other words, `return` makes a list that
    has only that one value as its result. This is useful when we want to just wrap
    a normal value into a list so that it can interact with nondeterministic values.
  prefs: []
  type: TYPE_NORMAL
- en: '`>>=` is about taking a value with a context (a monadic value) and feeding
    it to a function that takes a normal value and returns one that has context. If
    that function just produced a normal value instead of one with a context, `>>=`
    wouldn’t be so useful—after one use, the context would be lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try feeding a nondeterministic value to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When we used `>>=` with `Maybe`, the monadic value was fed into the function
    while taking care of possible failures. Here, it takes care of non-determinism
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`[3,4,5]` is a nondeterministic value, and we feed it into a function that
    returns a nondeterministic value as well. The result is also nondeterministic,
    and it features all the possible results of taking elements from the list `[3,4,5]`
    and passing them to the function `\x -> [x,-x]`. This function takes a number
    and produces two results: one negated and one that’s unchanged. So when we use
    `>>=` to feed this list to the function, every number is negated and also kept
    unchanged. The `x` from the lambda takes on every value from the list that’s fed
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this is achieved, we can just follow the implementation. First,
    we start with the list `[3,4,5]`. Then we map the lambda over it and get the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The lambda is applied to every element, and we get a list of lists. Finally,
    we just flatten the list, and voilà, we’ve applied a nondeterministic function
    to a nondeterministic value!
  prefs: []
  type: TYPE_NORMAL
- en: 'Nondeterminism also includes support for failure. The empty list `[]` is pretty
    much the equivalent of `Nothing`, because it signifies the absence of a result.
    That’s why failing is just defined as the empty list. The error message gets thrown
    away. Let’s play around with lists that fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, an empty list is fed into the lambda. Because the list has
    no elements, there are none to be passed to the function, so the result is an
    empty list. This is similar to feeding `Nothing` to a function. In the second
    line, each element is passed to the function, but the element is ignored and the
    function just returns an empty list. Because the function fails for every element
    that goes in it, the result is a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with `Maybe` values, we can chain several lists with `>>=`, propagating
    the nondeterminism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802692.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The numbers from the list `[1,2]` are bound to `n`, and the characters from
    the list `['a','b']` are bound to `ch`. Then we do `return (n, ch)` (or `[(n,
    ch)]`), which means taking a pair of `(n, ch)` and putting it in a default minimal
    context. In this case, it’s making the smallest possible list that still presents
    `(n, ch)` as the result and features as little nondeterminism as possible. Its
    effect on the context is minimal. We’re saying, “For every element in `[1,2]`,
    go over every element in `['a','b']` and produce a tuple of one element from each
    list.”
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, because `return` takes a value and wraps it in a minimal
    context, it doesn’t have any extra effect (like failing in `Maybe` or resulting
    in more nondeterminism for lists), but it does present something as its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have nondeterministic values interacting, you can view their computation
    as a tree where every possible result in a list represents a separate branch.
    Here’s the previous expression rewritten in `do` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This makes it a bit more obvious that `n` takes on every value from `[1,2]`
    and `ch` takes on every value from `['a','b']`. Just as with `Maybe`, we’re extracting
    the elements from the monadic values and treating them like normal values, and
    `>>=` takes care of the context for us. The context in this case is nondeterminism.
  prefs: []
  type: TYPE_NORMAL
- en: do Notation and List Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using lists with `do` notation might remind you of something you’ve seen before.
    For instance, check out the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Yes, list comprehensions! In our `do` notation example, `n` became every result
    from `[1,2]`. For every such result, `ch` was assigned a result from `['a','b']`,
    and then the final line put `(n, ch)` into a default context (a singleton list)
    to present it as the result without introducing any additional nondeterminism.
    In this list comprehension, the same thing happened, but we didn’t need to write
    `return` at the end to present `(n, ch)` as the result, because the output part
    of a list comprehension did that for us.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, list comprehensions are just syntactic sugar for using lists as monads.
    In the end, list comprehensions and lists in `do` notation translate to using
    `>>=` to do computations that feature nondeterminism.
  prefs: []
  type: TYPE_NORMAL
- en: MonadPlus and the guard Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'List comprehensions allow us to filter our output. For instance, we can filter
    a list of numbers to search only for numbers whose digits contain a `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We apply `show` to `x` to turn our number into a string, and then we check if
    the character `'7'` is part of that string.
  prefs: []
  type: TYPE_NORMAL
- en: To see how filtering in list comprehensions translates to the list monad, we
    need to check out the `guard` function and the `MonadPlus` type class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MonadPlus` type class is for monads that can also act as monoids. Here
    is its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`mzero` is synonymous with `mempty` from the `Monoid` type class, and `mplus`
    corresponds to `mappend`. Because lists are monoids as well as monads, they can
    be made an instance of this type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'For lists, `mzero` represents a nondeterministic computation that has no results
    at all—a failed computation. `mplus` joins two nondeterministic values into one.
    The `guard` function is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`guard` takes a Boolean value. If that value is `True`, guard takes a `()`
    and puts it in a minimal default context that still succeeds. If the Boolean value
    is `False`, guard makes a failed monadic value. Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks interesting, but how is it useful? In the list monad, we use it
    to filter out nondeterministic computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result here is the same as the result of our previous list comprehension.
    How does `guard` achieve this? Let’s first see how `guard` functions in conjunction
    with `>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If `guard` succeeds, the result contained within it is an empty tuple. So then
    we use `>>` to ignore that empty tuple and present something else as the result.
    However, if `guard` fails, then so will the `return` later on, because feeding
    an empty list to a function with `>>=` always results in an empty list. `guard`
    basically says, “If this Boolean is `False`, then produce a failure right here.
    Otherwise, make a successful value that has a dummy result of `()` inside it.”
    All this does is to allow the computation to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the previous example rewritten in `do` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Had we forgotten to present `x` as the final result by using `return`, the
    resulting list would just be a list of empty tuples. Here’s this again in the
    form of a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: So filtering in list comprehensions is the same as using `guard`.
  prefs: []
  type: TYPE_NORMAL
- en: A Knight's Quest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a problem that really lends itself to being solved with nondeterminism.
    Say we have a chessboard and only one knight piece on it. We want to find out
    if the knight can reach a certain position in three moves. We’ll just use a pair
    of numbers to represent the knight’s position on the chessboard. The first number
    will determine the column he is in, and the second number will determine the row.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802694.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s make a type synonym for the knight’s current position on the chessboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose that the knight starts at `(6, 2)`. Can he get to `(6, 1)` in exactly
    three moves? What’s the best move to make next from his current position? I know—how
    about all of them! We have nondeterminism at our disposal, so instead of picking
    one move, let’s pick all of them at once. Here is a function that takes the knight’s
    position and returns all of his next moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The knight can always take one step horizontally or vertically and two steps
    horizontally or vertically, but his movement must be both horizontal and vertical.
    `(c', r')` takes on every value from the list of movements and then `guard` makes
    sure that the new move, `(c', r')`, is still on the board. If it’s not, it produces
    an empty list, which causes a failure and `return (c', r')` isn’t carried out
    for that position.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can also be written without the use of lists as monads. Here
    is how to write it using `filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these versions do the same thing, so pick the one that looks nicer
    to you. Let’s give it a whirl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Works like a charm! We take one position, and we just carry out all the possible
    moves at once, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that we have a nondeterministic next position, we just use `>>=` to
    feed it to `moveKnight`. Here’s a function that takes a position and returns all
    the positions that you can reach from it in three moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If you pass it `(6, 2)`, the resulting list is quite big. This is because if
    there are several ways to reach some position in three moves, the move crops up
    in the list several times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the preceding code without `do` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Using `>>=` once gives us all possible moves from the start. When we use `>>=`
    the second time, for every possible first move, every possible next move is computed,
    and the same goes for the last move.
  prefs: []
  type: TYPE_NORMAL
- en: Putting a value in a default context by applying `return` to it and then feeding
    it to a function with `>>=` is the same as just normally applying the function
    to that value, but we did it here anyway for style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make a function that takes two positions and tells us if you can
    get from one to the other in exactly three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We generate all the possible positions in three steps, and then we see if the
    position we’re looking for is among them. Here’s how to check if we can get from
    `(6, 2)` to `(6, 1)` in three moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Yes! How about from `(6, 2)` to `(7, 3)`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: No! As an exercise, you can change this function so that when you can reach
    one position from the other, it tells you which move to take. In [Chapter 14](ch14.html
    "Chapter 14. For a Few Monads More"), you’ll see how to modify this function so
    that we also pass it the number of moves to take, instead of that number being
    hardcoded as it is now.
  prefs: []
  type: TYPE_NORMAL
- en: Monad Laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like functors and applicative functors, monads come with a few laws that
    all monad instances must abide by. Just because something is made an instance
    of the `Monad` type class doesn’t mean that it’s actually a monad. For a type
    to truly be a monad, the monad laws must hold for that type. These laws allow
    us to make reasonable assumptions about the type and its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802696.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Haskell allows any type to be an instance of any type class as long as the types
    check out. It can’t check if the monad laws hold for a type though, so if we’re
    making a new instance of the `Monad` type class, we need to be reasonably sure
    that all is well with the monad laws for that type. We can rely on the types that
    come with the standard library to satisfy the laws, but when we go about making
    our own monads, we need to manually check whether the laws hold. But don’t worry,
    they’re not complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Left Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first monad law states that if we take a value, put it in a default context
    with `return`, and then feed it to a function by using `>>=`, that’s the same
    as just taking the value and applying the function to it. To put it formally,
    `return x >>= f` is the same damn thing as `f x`.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at monadic values as values with a context, and `return` as taking
    a value and putting it in a default minimal context that still presents that value
    as the function’s result, this law makes sense. If that context is really minimal,
    feeding this monadic value to a function shouldn’t be much different than just
    applying the function to the normal value—and indeed, it isn’t different at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Maybe` monad, `return` is defined as `Just`. The `Maybe` monad is
    all about possible failure, and if we have a value that we want to put in such
    a context, treating it as a successful computation makes sense, because we know
    what the value is. Here are some examples of `return` usage with `Maybe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'For the list monad, `return` puts something in a singleton list. The `>>=`
    implementation for lists goes over all the values in the list and applies the
    function to them. However, since there’s only one value in a singleton list, it’s
    the same as applying the function to that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You’ve learned that for `IO`, using `return` makes an I/O action that has no
    side effects but just presents a value as its result. So it makes sense that this
    law holds for `IO` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Right Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second law states that if we have a monadic value and we use `>>=` to feed
    it to `return`, the result is our original monadic value. Formally, `m >>= return`
    is no different than just `m`.
  prefs: []
  type: TYPE_NORMAL
- en: This law might be a bit less obvious than the first one. Let’s take a look at
    why it should hold. When we feed monadic values to functions by using `>>=`, those
    functions take normal values and return monadic ones. `return` is also one such
    function, if you consider its type.
  prefs: []
  type: TYPE_NORMAL
- en: '`return` puts a value in a minimal context that still presents that value as
    its result. This means that, for instance, for `Maybe`, it doesn’t introduce any
    failure; for lists, it doesn’t introduce any extra nondeterminism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test run for a few monads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In this list example, the implementation for `>>=` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: So when we feed `[1,2,3,4]` to `return`, first `return` gets mapped over `[1,2,3,
    4]`, resulting in `[[1],[2],[3],[4]]`. Then this is concatenated, and we have
    our original list.
  prefs: []
  type: TYPE_NORMAL
- en: Left identity and right identity are basically laws that describe how `return`
    should behave. It’s an important function for making normal values into monadic
    ones, and it wouldn’t be good if the monadic value that it produced had any more
    than the minimal context needed.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final monad law says that when we have a chain of monadic function applications
    with `>>=`, it shouldn’t matter how they’re nested. Formally written, doing `(m
    >>= f) >>= g` is just like doing `m >>= (\x -> f x >>= g)`.
  prefs: []
  type: TYPE_NORMAL
- en: Hmmm, now what’s going on here? We have one monadic value, `m`, and two monadic
    functions, `f` and `g`. When we’re using `(m >>= f) >>= g`, we’re feeding `m`
    to `f`, which results in a monadic value. Then we feed that monadic value to `g`.
    In the expression `m >>= (\x -> f x >>= g)`, we take a monadic value and we give
    it to a function that feeds the result of `f x` to `g`. It’s not easy to see how
    those two are equal, so let’s take a look at an example that makes this equality
    a bit clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember when we had our tightrope walker, Pierre, walk a rope while birds
    landed on his balancing pole? To simulate birds landing on his balancing pole,
    we made a chain of several functions that might produce failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We started with `Just (0, 0)` and then bound that value to the next monadic
    function, `landRight 2`. The result of that was another monadic value, which got
    bound to the next monadic function, and so on. If we were to explicitly parenthesize
    this, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also write the routine like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`return (0, 0)` is the same as `Just (0, 0)`, and when we feed it to the lambda,
    the `x` becomes `(0, 0)`. `landRight` takes a number of birds and a pole (a tuple
    of numbers), and that’s what it gets passed. This results in a `Just (0, 2)`,
    and when we feed this to the next lambda, `y` is `(0, 2)`. This goes on until
    the final bird landing produces a `Just (2, 4)`, which is indeed the result of
    the whole expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So it doesn’t matter how you nest feeding values to monadic functions. What
    matters is their meaning. Let’s consider another way to look at this law. Suppose
    we compose two functions named `f` and `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If the type of `g` is `a -> b` and the type of `f` is `b -> c`, we arrange them
    into a new function that has a type of `a -> c`, so that its parameter is passed
    between those functions. Now what if those two functions were monadic? What if
    the values they returned were monadic values? If we had a function of type `a
    -> m b`, we couldn’t just pass its result to a function of type `b -> m c`, because
    that function accepts a normal `b`, not a monadic one. We could, however, use
    `>>=` to make that happen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we can compose two monadic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that’s cool. But what does that have to do with the associativity law?
    Well, when we look at the law as a law of compositions, it states that `f <=<
    (g <=< h)` should be the same as `(f <=< g) <=< h`. This is just another way of
    saying that for monads, the nesting of operations shouldn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: If we translate the first two laws to use `<=<`, then the left identity law
    states that for every monadic function `f`, `f <=< return` is the same as writing
    just `f`. The right identity law says that `return <=< f` is also no different
    from `f`. This is similar to how if `f` is a normal function, `(f . g) . h` is
    the same as `f . (g . h)`, `f . id` is always the same as `f`, and `id . f` is
    also just `f`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we took a look at the basics of monads and learned how the
    `Maybe` monad and the list monad work. In the next chapter, we’ll explore a whole
    bunch of other cool monads, and we’ll also make our own.
  prefs: []
  type: TYPE_NORMAL
