- en: Chapter 10. Blocks, Procs, and Lambdas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：代码块、Proc和Lambdas
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: When programmers talk about blocks, they often mean some arbitrary “chunks”
    of code. In Ruby, however, a block is special. It is a unit of code that works
    somewhat like a method but, unlike a method, it has no name.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论代码块时，他们通常指的是一些任意的“代码块”。然而，在Ruby中，代码块是特殊的。它是一个类似于方法的代码单元，但与方法不同，它没有名字。
- en: Blocks are very important in Ruby, but they can be difficult to understand.
    In addition, there are some important differences in the behavior of blocks in
    Ruby 1.8 and Ruby 1.9\. If you fail to appreciate those differences, your programs
    may behave in unexpected ways when run in different versions of Ruby. This chapter
    looks at blocks in great detail. Not only does it explain how they work and why
    they are special, but it also provides guidance on ensuring that they continue
    to work consistently no matter which version of Ruby you happen to be using.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块在Ruby中非常重要，但它们可能难以理解。此外，Ruby 1.8和Ruby 1.9中代码块的行为存在一些重要差异。如果你没有意识到这些差异，你的程序在运行不同版本的Ruby时可能会以意想不到的方式运行。本章详细探讨了代码块。它不仅解释了它们是如何工作的以及为什么它们是特殊的，而且还提供了确保它们在无论使用哪个版本的Ruby时都能保持一致性的指导。
- en: What Is a Block?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是代码块？
- en: 'Consider this code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '*1blocks.rb*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*1blocks.rb*'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It’s probably pretty obvious that this code is intended to execute three times.
    What may be less obvious is the value that `i` will have on each successive turn
    through the loop. In fact, the values of `i` in this case will be 0, 1, and 2\.
    The following is an alternative form of the previous code. This time, the block
    is delimited by curly brackets rather than by `do` and `end`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这段代码的目的是执行三次。可能不那么明显的是`i`在每次循环迭代中的值。实际上，在这种情况下`i`的值将是0、1和2。以下是之前代码的另一种形式。这次，代码块是通过花括号而不是`do`和`end`界定的。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: According to the Ruby documentation, `times` is a method of Integer (let’s call
    the Integer `int`), which iterates a block “`int` times, passing in values from
    0 to `int` −1.” So here, the code within the block is run three times. The first
    time it is run, the variable `i` is given the value 0; each subsequent time, `i`
    is incremented by 1 until the final value, 2 (that is, `int`−1), is reached.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Ruby文档，`times`是Integer（让我们称它为`int`）的一个方法，它会对一个代码块进行“`int`次迭代，传递从0到`int`−1的值”。所以在这里，代码块内的代码运行了三次。第一次运行时，变量`i`被赋予值0；每次后续运行，`i`都会增加1，直到达到最终值2（即`int`−1）。
- en: The two code examples shown earlier are functionally identical. A block can
    be enclosed either by curly brackets or by the `do` and `end` keywords, and the
    programmer can use either syntax according to personal preference.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的两个代码示例在功能上是相同的。代码块可以被花括号或`do`和`end`关键字包围，程序员可以根据个人喜好使用任一语法。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some Ruby programmers like to delimit blocks with curly brackets when the entire
    code of the block fits onto a single line and with `do..end` when the block spans
    multiple lines. My personal prejudice is to be consistent, irrespective of code
    layout, so I generally use curly brackets when delimiting blocks. Usually your
    choice of delimiters makes no difference to the behavior of the code—but see [Precedence
    Rules](ch10s13.html "Precedence Rules") in [Precedence Rules](ch10s13.html "Precedence
    Rules").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Ruby程序员喜欢在代码块的全部代码都放在一行时使用花括号来界定代码块，而当代码块跨越多行时使用`do..end`。我个人的偏见是保持一致性，无论代码布局如何，所以我通常在界定代码块时使用花括号。通常，你选择的界定符对代码的行为没有影响——但请参阅[优先级规则](ch10s13.html
    "优先级规则")中的[优先级规则](ch10s13.html "优先级规则")。
- en: If you are familiar with a C-like language such as C# or Java, you may, perhaps,
    assume that Ruby’s curly brackets can be used, as in those languages, simply to
    group together arbitrary “blocks” of code—for example, a block of code to be executed
    when a condition evaluates to true. This is not the case. In Ruby, a block is
    a special construct that can be used only in very specific circumstances.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉类似于C#或Java的C语言，你可能会认为Ruby的花括号可以像那些语言一样使用，仅仅是为了将任意的“代码块”组合在一起——例如，当条件评估为真时要执行的代码块。但这并不是情况。在Ruby中，代码块是一个只能在非常特定情况下使用的特殊结构。
- en: Line Breaks Are Significant
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 换行符很重要
- en: You must place the opening block delimiter on the same line as the method with
    which it is associated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将代码块的开头界定符放在与其关联的方法所在的同一行上。
- en: 'For example, these are okay:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是可以的：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But these contain syntax errors:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些包含语法错误：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Nameless Functions
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无命名函数
- en: 'A Ruby block may be regarded as a sort of nameless function or method, and
    its most frequent use is to provide a means of iterating over items from a list
    or range of values. If you have never come across nameless functions, this may
    sound like gobbledygook. With luck, by the end of this chapter, things will have
    become a little clearer. Let’s look back at the simple example given earlier.
    I said a block is like a nameless function. Take this block as an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby代码块可以被视为一种无命名函数或方法，它最频繁的使用是提供一种遍历列表或值范围中项的手段。如果你从未遇到过无命名函数，这可能会听起来像是胡言乱语。幸运的是，到本章结束时，事情可能会变得稍微清晰一些。让我们回顾一下前面给出的简单例子。我说代码块就像一个无命名函数。以下是一个例子：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If that were written as a normal Ruby method, it would look something like
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其写成正常的Ruby方法，它看起来可能像这样：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To call that method three times and pass values from 0 to 2, you might write
    this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用该方法三次并传递从0到2的值，你可以这样写：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you create a nameless method (that is, a block), variables declared between
    upright bars such as `|i|` can be treated like the arguments to a named method.
    I will refer to these variables as *block parameters*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个无命名方法（即代码块）时，在竖线之间声明的变量，如`|i|`，可以像命名方法的参数一样处理。我将把这些变量称为*代码块参数*。
- en: 'Look again at my earlier example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看我之前的例子：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `times` method of an integer passes values to a block from 0 to the specified
    integer value minus 1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的`times`方法将值从0传递到指定的整数值减1。
- en: 'So, this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'is very much like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常像这样：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The chief difference is that the second example has to call a named method to
    process the value of `i`, whereas the first example uses the nameless method (the
    code between curly brackets) to process `i`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于第二个例子必须调用一个命名方法来处理`i`的值，而第一个例子使用无命名方法（花括号之间的代码）来处理`i`。
- en: Look Familiar?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看起来熟悉吗？
- en: 'Now that you know what a block is, you may notice that you’ve seen them before.
    Many times. For example, you previously used `do..end` blocks to iterate over
    ranges like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了代码块是什么，你可能注意到你以前见过它们。很多次。例如，你之前使用`do..end`代码块来遍历像这样的一系列值：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You have also used `do..end` blocks to iterate over arrays (see *for_each2.rb*
    in [for Loops](ch05.html#for_loops "for Loops")):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还使用`do..end`代码块来遍历数组（参见[for Loops](ch05.html#for_loops "for Loops")中的*for_each2.rb*）：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And you have executed a block repeatedly by passing it to the `loop` method
    (see *3loops.rb* in [loop](ch05s07.html "loop")):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将代码块传递给`loop`方法（参见[loop](ch05s07.html "loop")中的*3loops.rb*）来重复执行一个代码块：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous `loop` example is notable for two things: It has no list of items
    (such as an array or a range of values) to iterate over, and it is pretty darn
    ugly. These two features are not entirely unrelated! The `loop` method is part
    of the Kernel class, which is “automatically” available to your programs. Because
    it has no “end value,” it will execute the block forever unless you explicitly
    break out of it using the `break` keyword. Usually there are more elegant ways
    to perform this kind of iteration—by iterating over a sequence of values with
    a finite range.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`loop`例子有两个显著特点：它没有要遍历的项目列表（如数组或值范围），而且相当丑陋。这两个特点并非完全无关！`loop`方法属于Kernel类，它“自动”对程序可用。因为它没有“结束值”，所以它会无限期地执行代码块，除非你使用`break`关键字显式地从中退出。通常有更优雅的方式来执行这种迭代——通过遍历有限范围的值序列。
- en: Blocks and Arrays
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码块和数组
- en: Blocks are commonly used to iterate over arrays. The Array class, consequently,
    provides a number of methods to which blocks are passed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块通常用于遍历数组。因此，Array类提供了一些方法，可以将代码块传递给这些方法。
- en: 'One useful method is called `collect`; this passes each element of the array
    to a block and creates a new array to contain each of the values returned by the
    block. Here, for example, a block is passed to each of the integers in an array
    (each integer is assigned to the variable `x`); the block doubles its value and
    returns it. The `collect` method creates a new array containing each of the returned
    integers in sequence:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的方法是`collect`；它将数组的每个元素传递给一个代码块，并创建一个新的数组来包含代码块返回的每个值。例如，这里，一个代码块被传递给数组中的每个整数（每个整数被分配给变量`x`）；代码块将其值加倍并返回。`collect`方法创建一个新的数组，按顺序包含返回的每个整数：
- en: '*2blocks.rb*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*2blocks.rb*'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous example assigns this array to `b3`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子将这个数组赋值给`b3`：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next example, the block returns a version of the original strings in
    which each initial letter is capitalized:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，块返回一个版本的原字符串，其中每个首字母都被大写：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, `b4` is now as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`b4` 现在如下所示：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `each` method of the Array class may look rather similar to `collect`;
    it too passes each array element in turn to be processed by the block. However,
    unlike `collect`, the `each` method does not create a new array to contain the
    returned values:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类的 `each` 方法可能看起来与 `collect` 方法相当相似；它同样逐个将数组元素传递给块进行处理。然而，与 `collect` 方法不同，`each`
    方法不会创建一个新的数组来包含返回的值：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This time, `b5` is unchanged:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`b5` 没有改变：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Recall, however, that some methods—notably those ending with an exclamation
    mark (`!`)—actually alter the original objects rather than yielding new values.
    If you wanted to use the `each` method to capitalize the strings in the original
    array, you could use the `capitalize!` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，某些方法——特别是以感叹号 (`!`) 结尾的方法——实际上会改变原始对象而不是产生新的值。如果你想使用 `each` 方法来大写字符串中的原始数组，你可以使用
    `capitalize!` 方法：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, `b6` is now as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`b6` 现在如下所示：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With a bit of thought, you could also use a block to iterate over the characters
    in a string. First, you need to split off each character from a string. This can
    be done using the `split` method of the String class like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些思考，你也可以使用块来遍历字符串中的字符。首先，你需要从字符串中分割出每个字符。这可以通过使用字符串类的 `split` 方法来完成，如下所示：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `split` method divides a string into substrings based on a delimiter and
    returns an array of these substrings. Here `//` is a regular expression that defines
    a zero-length string; this has the effect of returning a single character, so
    you end up creating an array of all the characters in the string. You can now
    iterate over this array of characters, returning a `capitalized` version of each:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`split` 方法根据分隔符将字符串分割成子字符串，并返回这些子字符串的数组。在这里，`//` 是一个正则表达式，它定义了一个零长度的字符串；这会产生返回单个字符的效果，因此你最终会创建一个包含字符串中所有字符的数组。你现在可以遍历这个字符数组，返回每个字符的大写版本：'
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At each iteration, a capitalized character is appended to `newstr`, and the
    following is displayed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，一个首字母大写的字符被添加到 `newstr` 中，然后显示以下内容：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because you are using the `capitalize` method here (with no terminating `!`
    character), the characters in the array `a` remain as they began, all lowercase,
    since the `capitalize` method does not alter the receiver object (here the receiver
    objects are the characters passed into the block).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在这里使用了 `capitalize` 方法（没有终止的 `!` 字符），数组 `a` 中的字符保持不变，全部为小写，因为 `capitalize`
    方法不会改变接收对象（在这里，接收对象是传递到块中的字符）。
- en: Be aware, however, that this code would not work if you were to use the `capitalize!`
    method to modify the original characters. This is because `capitalize!` returns
    `nil` when no changes are made, so when the space character is encountered, `nil`
    would be returned, and your attempt to append (`<<`) a `nil` value to the string
    `newstr` would fail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，如果你使用 `capitalize!` 方法来修改原始字符，这段代码将无法工作。这是因为当没有变化时，`capitalize!` 返回 `nil`，所以当遇到空格字符时，将返回
    `nil`，并且尝试将 `nil` 值追加到字符串 `newstr` 中将失败。
- en: 'You could also capitalize a string using the `each_byte` method. This iterates
    through the string characters, passing each byte to the block. These bytes take
    the form of ASCII codes. So, “hello world” would be passed in the form of these
    numeric values: `104 101 108 108 111 32 119 111 114 108 100`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `each_byte` 方法来大写字符串。这个方法遍历字符串中的字符，将每个字节传递给块。这些字节以ASCII码的形式出现。所以，“hello
    world”将以这些数值的形式传递：`104 101 108 108 111 32 119 111 114 108 100`。
- en: 'Obviously, you can’t capitalize an integer, so you need to convert each ASCII
    value to a character. The `chr` method of String does this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不能对整数进行大写，因此你需要将每个ASCII值转换为字符。字符串的 `chr` 方法可以做到这一点：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Procs and Lambdas
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和Lambda
- en: 'In the examples up to now, blocks have been used in cahoots with methods. This
    has been a requirement since nameless blocks cannot have an independent existence
    in Ruby. You cannot, for example, create a stand-alone block like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的示例中，块与方法一起使用。这自从无名的块在Ruby中不能独立存在以来一直是必需的。例如，你不能创建一个独立的块，如下所示：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is one of the exceptions to the rule that “everything in Ruby is an object.”
    A block clearly is not an object. Every object is created from a class, and you
    can find an object’s class by calling its `class` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“Ruby 中的一切都是对象”这一规则的一个例外。块显然不是对象。每个对象都是由一个类创建的，你可以通过调用其 `class` 方法来找到对象所属的类。
- en: 'Do this with a hash, for example, and the class name “Hash” will be displayed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用哈希来做这件事，将显示类名“Hash”：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Try this with a block, however, and you will only get an error message:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试使用块，你将只会得到一个错误信息：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Block or Hash?
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块或哈希？
- en: 'Ruby uses curly brackets to delimit both blocks and hashes. So, how can you
    (and Ruby) tell which is which? The answer, basically, is that it’s a hash when
    it *looks* like a hash, and otherwise it’s a block. A hash looks like a hash when
    curly brackets contain key-value pairs:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用花括号来界定块和哈希。那么，你（以及 Ruby）如何区分它们呢？答案基本上是，当它看起来像哈希时，它就是一个哈希，否则它就是一个块。哈希看起来像哈希，当花括号中包含键值对时：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'or when they are empty:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者当它们为空时：
- en: '*block_or_hash.rb*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*block_or_hash.rb*'
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, if you omit the parentheses, there is an ambiguity. Is this an empty
    hash, or is it a block associated with the `puts` method?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你省略了括号，这里就有歧义。这是一个空哈希，还是一个与 `puts` 方法关联的块？
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Frankly, I have to admit I don’t know the answer to that question, and I can’t
    get Ruby to tell me. Ruby accepts this as valid syntax but does not, in fact,
    display anything when the code executes. So, how about this?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，我必须承认我不知道这个问题的答案，我也无法让 Ruby 告诉我。Ruby 接受这作为有效的语法，但实际上在代码执行时并不会显示任何内容。那么，这个怎么样？
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once again, this prints nothing at all in Ruby 1.9, but in Ruby 1.8 it displays
    `nil` (not, you will notice, the actual *class* of `nil`, which is NilClass, but
    `nil` itself). If you find all this confusing (as I do!), just remember that this
    can all be clarified by the judicious use of parentheses:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在 Ruby 1.9 中，这什么也不打印，但在 Ruby 1.8 中，它会显示 `nil`（请注意，这不是 `nil` 的实际 *类*，`nil`
    的实际类是 NilClass，而是 `nil` 本身）。如果你觉得这一切都很混乱（就像我一样！），只需记住，这可以通过恰当地使用括号来澄清：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Creating Objects from Blocks
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从块创建对象
- en: 'Although blocks may not be objects by default, they can be “turned into” objects.
    There are three ways of creating objects from blocks and assigning them to variables—here’s
    how:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然块默认可能不是对象，但它们可以被“转换”为对象。有三种从块创建对象并将其赋值给变量的方法——下面是如何做的：
- en: '*proc_create.rb*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*proc_create.rb*'
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In each of the three cases, you will end up creating an instance of the Proc
    class—which is the Ruby “object wrapper” for a block.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情况下，你最终都会创建 Proc 类的一个实例——这是 Ruby 对块的“对象包装器”。
- en: 'Let’s take a look at a simple example of creating and using a Proc object.
    First, you can create an object calling `Proc.new` and passing to it a block as
    an argument:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建和使用 Proc 对象的一个简单例子。首先，你可以通过调用 `Proc.new` 并传递一个块作为参数来创建一个对象：
- en: '*3blocks.rb*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*3blocks.rb*'
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Second, you can execute the code in the block to which `a` refers using the
    Proc class’s `call` method with one or more arguments (matching the block parameters)
    to be passed into the block; in the previous code, you could pass an integer such
    as 100, and this would be assigned to the block variable `x`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以使用 Proc 类的 `call` 方法执行 `a` 所指的块中的代码，通过传递一个或多个参数（匹配块参数）到块中；在前面的代码中，你可以传递一个整数，例如
    100，这将分配给块变量 `x`：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, you can also create a Proc object by calling the `lambda` or `proc`
    methods, which are supplied by the Kernel class. The name `lambda` is taken from
    the Scheme (Lisp) language and is a term used to describe an anonymous method,
    or *closure*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以通过调用 Kernel 类提供的 `lambda` 或 `proc` 方法来创建 Proc 对象。名称 `lambda` 来自于 Scheme（Lisp）语言，是描述匿名方法或
    *闭包* 的术语。
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is a slightly more complicated example that iterates over an array of
    strings, capitalizing each string in turn. The array of capitalized strings is
    then assigned to the `d1` variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个稍微复杂一点的例子，它遍历一个字符串数组，逐个将每个字符串转换为大写。然后，将转换为大写的字符串数组赋值给 `d1` 变量：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There is one important difference between creating a Proc object using `Proc.new`
    and creating a Proc object using a `lambda` method—`Proc.new` does not check that
    the number of arguments passed to the block matches the number of block parameters.
    `lambda` does. The behavior of the `proc` method is different in Ruby 1.8 and
    1.9\. In Ruby 1.8, `proc` is equivalent to `lambda`—it checks the number of arguments.
    In Ruby 1.9, `proc` is equivalent to `Proc.new`—it does *not* check the number
    of arguments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Proc.new` 创建 Proc 对象和使用 `lambda` 方法创建 Proc 对象之间存在一个重要的区别——`Proc.new` 不会检查传递给块的参数数量是否与块参数的数量匹配。`lambda`
    会检查。在 Ruby 1.8 和 1.9 中，`proc` 方法的行为不同。在 Ruby 1.8 中，`proc` 等同于 `lambda`——它会检查参数数量。在
    Ruby 1.9 中，`proc` 等同于 `Proc.new`——它不会检查参数数量：
- en: '*proc_lamba.rb*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*proc_lamba.rb*'
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What Is a Closure?
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是闭包？
- en: 'A *closure* is a function that has the ability to store (that is, to “enclose”)
    values of local variables within the scope in which the block was created (think
    of this as the block’s “native scope”). Ruby’s blocks are closures. To understand
    this, look at this example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *闭包* 是一个能够存储（即，“封装”）在创建块的作用域内局部变量值的函数（想想看，这就是块的原生作用域）。Ruby 的块是闭包。为了理解这一点，请看这个例子：
- en: '*block_closure.rb*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*block_closure.rb*'
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the value of the local variable `x` is “hello world” within the scope
    of `ablock`. Inside `aMethod`, however, a local variable named `x` has the value
    “goodbye.” In spite of that, when `ablock` is passed to `aMethod` and called within
    the scope of `aMethod`, it prints “hello world” (that is, the value of `x` within
    the block’s native scope) rather than “goodbye,” which is the value of `x` within
    the scope of `aMethod`. The previous code, therefore, only ever prints “hello
    world.”
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，局部变量 `x` 在 `ablock` 的作用域内的值是 “hello world”。然而，在 `aMethod` 中，一个名为 `x` 的局部变量具有值
    “goodbye”。尽管如此，当 `ablock` 被传递给 `aMethod` 并在 `aMethod` 的作用域内调用时，它打印出 “hello world”（即块原生作用域内的
    `x` 的值），而不是 “goodbye”，这是 `aMethod` 作用域内 `x` 的值。因此，之前的代码始终只打印出 “hello world”。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See [Digging Deeper](ch10s14.html#digging_deeper-id9 "Digging Deeper") in [Digging
    Deeper](ch10s14.html#digging_deeper-id9 "Digging Deeper") for more on closures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有关闭包的更多信息，请参阅 [深入挖掘](ch10s14.html#digging_deeper-id9 "深入挖掘")。
- en: yield
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: yield
- en: 'Let’s see a few more blocks in use. The *4blocks.rb* program introduces something
    new, namely, a way of executing a nameless block when it is passed to a method.
    This is done using the keyword `yield`. In the first example, I define this simple
    method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多块的使用。*4blocks.rb* 程序引入了新的内容，即，当块被传递给方法时执行一个无名称块的方法。这是通过使用关键字 `yield`
    来实现的。在第一个例子中，我定义了这个简单的方法：
- en: '*4blocks.rb*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*4blocks.rb*'
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It doesn’t really have any code of its own. Instead, it expects to receive
    a block, and the `yield` keyword causes the block to execute. This is how I pass
    a block to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上并没有自己的代码。相反，它期望接收一个块，`yield` 关键字导致块执行。这就是我向它传递块的方式：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice that this time the block is not passed as a named argument. It would
    be an error to try to pass the block between parentheses, like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次块不是作为命名参数传递的。尝试将块放在括号之间传递，像这样，将会是一个错误：
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Instead, you simply put the block right next to the method to which you are
    passing it, just as you did in the first example in this chapter. That method
    receives the block without having to declare a named parameter for it, and it
    calls the block with `yield`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你只需将块放在你传递给它的方法旁边，就像你在本章的第一个例子中所做的那样。该方法接收块，而无需为它声明命名参数，并且使用 `yield` 调用块。
- en: 'Here is a slightly more useful example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个稍微有用一点的例子：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here the `caps` method receives one argument, `anarg`, and passes this argument
    to a nameless block, which is then executed by `yield`. When I call the `caps`
    method, I pass it a string argument (`"a lowercase string"`) using the normal
    parameter-passing syntax. The nameless block is passed *after the end* of the
    parameter list.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`caps` 方法接收一个参数 `anarg`，并将此参数传递给一个无名称块，然后通过 `yield` 执行该块。当我调用 `caps` 方法时，我使用正常的参数传递语法传递一个字符串参数（`"a
    lowercase string"`）。无名称块在参数列表的 *之后* 传递。
- en: 'When the `caps` method calls `yield( anarg )`, then the string argument is
    passed into the block; it is assigned to the block variable `x`. This capitalizes
    it and displays it with `puts( s )`, which shows that the initial letter has been
    capitalized: “A lowercase string.”'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `caps` 方法调用 `yield( anarg )` 时，字符串参数被传递到块中；它被分配给块变量 `x`。然后将其转换为大写，并通过 `puts(
    s )` 显示出来，这表明首字母已被大写：“一个小写字符串。”
- en: Blocks Within Blocks
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块中的块
- en: 'You’ve already seen how to use a block to iterate over an array. In the next
    example (also in *4blocks.rb*), I use one block to iterate over an array of strings,
    assigning each string in turn to the block variable `s`. A second block is then
    passed to the `caps` method in order to capitalize the string:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用块来遍历数组。在下一个示例（也在 *4blocks.rb* 中），我使用一个块来遍历一个字符串数组，依次将每个字符串赋值给块变量 `s`。然后，另一个块被传递给
    `caps` 方法以将字符串转换为大写：
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This results in the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Passing Named Proc Arguments
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递命名 Proc 参数
- en: Up to now, you have passed blocks to procedures either anonymously (in which
    case the block is executed with the `yield` keyword) or in the form of a named
    argument, in which case it is executed using the `call` method. There is another
    way to pass a block. When the last argument in a method’s list of parameters is
    preceded by an ampersand (`&`), it is considered to be a Proc object. This gives
    you the option of passing an anonymous block to a procedure using the same syntax
    as when passing a block to an iterator, and yet the procedure itself can receive
    the block as a named argument. Load *5blocks.rb* to see some examples of this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经以匿名（在这种情况下，块将使用 `yield` 关键字执行）或命名参数（在这种情况下，它将使用 `call` 方法执行）的形式将块传递给过程。还有另一种传递块的方法。当一个方法参数列表中的最后一个参数前面有一个
    ampersand (`&`) 时，它被视为一个 Proc 对象。这让你可以选择使用与传递给迭代器的块相同的语法将匿名块传递给过程，同时过程本身可以将块作为命名参数接收。加载
    *5blocks.rb* 来查看一些示例。
- en: 'First, here is a reminder of the two ways you’ve already seen of passing blocks.
    This method has three parameters, `a`, `b`, and `c`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个提醒，你已经看到了两种传递块的方法。这种方法有三个参数，`a`、`b` 和 `c`：
- en: '*5blocks.rb*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*5blocks.rb*'
- en: '[PRE46]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You call this method with three named arguments (which here happen to be blocks
    but could, in principle, be anything) plus an unnamed block:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用三个命名参数（在这里恰好是块，但原则上可以是任何东西）加上一个未命名的块来调用此方法：
- en: '[PRE47]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `abc` method executes the named block arguments using the `call` method
    and the unnamed block using the `yield` keyword. The results are shown in the
    `#=>` comments here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc` 方法使用 `call` 方法执行命名块参数，并使用 `yield` 关键字执行未命名的块。结果在这里的 `#=>` 注释中显示：'
- en: '[PRE48]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The next method, `abc2`, takes a single argument, `&d`. The ampersand here
    is significant because it indicates that the `&d` parameter is a block. Instead
    of using the `yield` keyword, the `abc2` method is able to execute the block using
    the name of the argument (without the ampersand):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法 `abc2` 只接受一个参数，`&d`。这里的 ampersand 很重要，因为它表明 `&d` 参数是一个块。`abc2` 方法能够使用参数的名称（不带
    ampersand）来执行块，而不是使用 `yield` 关键字：
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So, a block argument with an ampersand is called in the same way as one without
    an ampersand. However, there is a difference in the way the object matching that
    argument is passed to the method. To match an ampersand-argument, an unnamed block
    is passed by appending it to the method name:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，带 ampersand 的块参数的调用方式与不带 ampersand 的块参数相同。然而，在将匹配该参数的对象传递给方法的方式上存在差异。为了匹配
    ampersand 参数，通过将其附加到方法名称来传递一个未命名的块：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can think of ampersand-arguments as type-checked block parameters. Unlike
    normal arguments (without an ampersand), the argument cannot match any type; it
    can match only a block. You cannot pass some other sort of object to `abc2`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 ampersand 参数视为类型检查的块参数。与没有 ampersand 的正常参数不同，该参数不能匹配任何类型；它只能匹配一个块。你不能向
    `abc2` 传递其他类型的对象：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `abc3` method is essentially the same as the `abc` method except it specifies
    a fourth formal block-typed argument (`&d`):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc3` 方法本质上与 `abc` 方法相同，只是它指定了一个第四个形式块类型参数（`&d`）：'
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The arguments `a`, `b`, and `c` are called, while the argument `&d` may be
    either called or yielded, as you prefer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `a`、`b` 和 `c` 被调用，而参数 `&d` 可以根据你的喜好调用或传递：
- en: '[PRE53]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This means the calling code must pass to this method three formal arguments
    plus a block, which may be nameless:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着调用代码必须向此方法传递三个形式参数加上一个块，该块可能没有名字：
- en: '[PRE54]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The previous method call would result in this output (bearing in mind that
    the final block argument is executed twice since it is both called and yielded):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个方法调用会产生以下输出（请注意，最后一个块参数执行了两次，因为它既被调用又被传递）：
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also use a preceding ampersand in order to pass a named block to a
    method when the receiving method has no matching named argument, like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用前面的 ampersand 来将一个命名块传递给一个没有匹配命名参数的方法，如下所示：
- en: '[PRE56]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'An ampersand block variable such as `&myproc` in the previous code may be passed
    to a method even if that method does not declare a matching variable in its argument
    list. This gives you the choice of passing either an unnamed block or a Proc object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，即使方法没有在其参数列表中声明匹配的变量，也可以将类似于 `&myproc` 的块变量传递给方法。这给了你选择传递未命名的块或 Proc
    对象的机会：
- en: '[PRE57]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Be careful, however! Notice in one of the previous examples, I have used block
    parameters (`|a,b,c|`) with the same names as the three local variables to which
    I previously assigned Proc objects: `a`, `b`, `c`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意！在先前的例子中，我使用了与之前分配给 Proc 对象的三个局部变量同名（`a`、`b`、`c`）的块参数：`|a,b,c|`：
- en: '[PRE58]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In principle, block parameters should be visible only within the block itself.
    However, it turns out that assignment to block parameters has profoundly different
    effects in Ruby 1.8 and Ruby 1.9\. Let’s look first at Ruby 1.8\. Here, assignment
    to block parameters can initialize the values of any local variables with the
    same name within the block’s native scope (see [What Is a Closure?](ch10s09.html
    "What Is a Closure?") in [What Is a Closure?](ch10s09.html "What Is a Closure?")).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，块参数只应在块内部可见。然而，实际上在 Ruby 1.8 和 Ruby 1.9 中对块参数的赋值有截然不同的影响。让我们首先看看 Ruby 1.8。在这里，对块参数的赋值可以初始化块本生作用域（即程序的主作用域）中具有相同名称的任何局部变量的值（参见
    [什么是闭包？](ch10s09.html "什么是闭包？") 在 [什么是闭包？](ch10s09.html "什么是闭包？") 中）。
- en: 'Even though the variables in the `xyz` method are named `x`, `y`, and `z`,
    it turns out that the integer assignments in that method are actually made to
    the variables `a`, `b`, and `c` when this block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `xyz` 方法中的变量命名为 `x`、`y` 和 `z`，但实际上在该方法中的整数赋值是针对变量 `a`、`b` 和 `c` 进行的，当这个块：
- en: '[PRE59]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'is passed the values of `x`, `y`, and `z`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 被传递了 `x`、`y` 和 `z` 的值：
- en: '[PRE60]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As a consequence, the Proc variables `a`, `b`, and `c` within the block’s native
    scope (the main scope of my program) are initialized with the integer values of
    the block variables `x`, `y`, and `z` once the code in the block has been run.
    So, `a`, `b`, and `c`, which began as Proc objects, end up as integers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，块本生作用域内的 Proc 变量 `a`、`b` 和 `c` 会在块中的代码运行后初始化为块变量 `x`、`y` 和 `z` 的整数值。因此，`a`、`b`
    和 `c`，最初是 Proc 对象，最终成为整数。
- en: 'In Ruby 1.9, on the contrary, the variables inside the block are sealed off
    from the variables declared outside the block. So, the values of the `xyz` method’s
    `x`, `y`, and `z` variables are not assigned to the block’s `a`, `b`, and `c`
    parameters. That means once the block has executed, the values of the `a`, `b`,
    and `c` variables declared outside that method are unaffected: They began as Proc
    objects, and they end up as Proc objects.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在 Ruby 1.9 中，块内部的变量与块外声明的变量隔离开来。因此，`xyz` 方法中的 `x`、`y` 和 `z` 变量的值不会被分配给块的
    `a`、`b` 和 `c` 参数。这意味着一旦块执行完毕，块外声明的 `a`、`b` 和 `c` 变量的值不受影响：它们最初是 Proc 对象，最终仍然是
    Proc 对象。
- en: 'Now let’s suppose you execute the following code, remembering that `a`, `b`,
    and `c` are Proc objects at the outset:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你执行以下代码，记住 `a`、`b` 和 `c` 在开始时是 Proc 对象：
- en: '[PRE61]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In Ruby 1.8, the `puts` statement shown earlier displays the end values of
    `a`, `b`, and `c`, showing that they have been initialized with the integer values
    that were passed into the block when it was yielded (`yield( x, y, z )`) in the
    `xyz` method. As a consequence, they are now integers:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.8 中，前面展示的 `puts` 语句显示了 `a`、`b` 和 `c` 的最终值，表明它们已经被初始化为在 `xyz` 方法中传递到块中的整数值（当它被
    `yield( x, y, z )` 调用时）。因此，它们现在是整数：
- en: '[PRE62]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'But in Ruby 1.9, `a`, `b`, and `c` are not initialized by the block parameters
    and remain, as they began, as Proc objects:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Ruby 1.9 中，`a`、`b` 和 `c` 并不是由块参数初始化的，它们保持最初的状态，作为 Proc 对象：
- en: '[PRE63]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This behavior can be difficult to understand, but it is worth taking the time
    to do so. The use of blocks is commonplace in Ruby, and it is important to know
    how the execution of a block may (or may not) affect the values of variables declared
    outside the block. To clarify this, try the simple program in *6blocks.rb*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可能难以理解，但花时间理解它是值得的。在 Ruby 中，块的使用很常见，了解块的执行可能（或可能不）如何影响块外声明的变量值是很重要的。为了澄清这一点，尝试在
    *6blocks.rb* 中的简单程序：
- en: '*6blocks.rb*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*6blocks.rb*'
- en: '[PRE64]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here `a` is a string within the scope of the main program. A different variable
    with the same name, `a`, is declared in the block, which is passed to `foo` and
    yielded. When it is yielded, an integer value, 100, is passed into the block,
    causing the block’s parameter, `a`, to be initialized to 100\. The question is,
    does the initialization of the block argument, `a`, also initialize the string
    variable, `a`, in the main scope? And the answer is, *yes* in Ruby 1.8 but *no*
    in Ruby 1.9.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a` 是主程序范围内的一个字符串。在块中声明了另一个具有相同名称的变量 `a`，该块被传递给 `foo` 并产生。当它被产生时，一个整数值 100
    被传递到块中，导致块的参数 `a` 被初始化为 100。问题是，块参数 `a` 的初始化是否也会初始化主作用域中的字符串变量 `a`？答案是，在 Ruby
    1.8 中是 *是的*，但在 Ruby 1.9 中是 *不是*。
- en: 'Ruby 1.8 displays this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.8 显示如下：
- en: '[PRE65]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Ruby 1.9 displays this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 显示如下：
- en: '[PRE66]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you want to make sure that block parameters do not alter the values of variables
    declared outside the block, no matter which version of Ruby you use, just ensure
    that the block parameter names do not duplicate names used elsewhere. In the current
    program, you can do this simply by changing the name of the block argument to
    ensure that it is unique to the block:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保无论使用哪个版本的 Ruby，块参数都不会改变块外声明的变量的值，只需确保块参数的名称不与别处使用的名称重复。在当前程序中，你可以通过简单地更改块参数的名称来确保它是块独有的：
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This time, when the program is run, Ruby 1.8 and Ruby 1.9 both produce the
    same results:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当程序运行时，Ruby 1.8 和 Ruby 1.9 都产生了相同的结果：
- en: '[PRE68]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is an example of one of the pitfalls into which it is all too easy to fall
    in Ruby. As a general rule, when variables share the same scope (for example,
    a block declared within the scope of the main program here), it is best to make
    their names unique in order to avoid any unforeseen side effects. For more on
    scoping, see [Digging Deeper](ch10s14.html#digging_deeper-id9 "Digging Deeper")
    in [Digging Deeper](ch10s14.html#digging_deeper-id9 "Digging Deeper").
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Ruby 中很容易陷入的一个陷阱的例子。一般来说，当变量共享相同的范围（例如，在这里主程序范围内的一个块）时，最好使它们的名称唯一，以避免任何未预见的副作用。有关作用域的更多信息，请参阅
    [深入挖掘](ch10s14.html#digging_deeper-id9 "深入挖掘")。
- en: Precedence Rules
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先级规则
- en: 'Blocks within curly brackets have stronger precedence than blocks within `do`
    and `end`. Let’s see what that means in practice. Consider these two examples:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号内的块比 `do` 和 `end` 内的块有更强的优先级。让我们看看这在实践中意味着什么。考虑以下两个例子：
- en: '[PRE69]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, `foo` and `bar` are both methods, and the code between curly brackets
    and `do` and `end` are blocks. So, to which of the two methods is each of these
    blocks passed? It turns out that the `do..end` block would be passed to the leftmost
    method, `foo`, whereas the block in curly brackets would be sent to the rightmost
    method, `bar`. This is because curly brackets are said to have higher precedence
    than `do` and `end`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`foo` 和 `bar` 都是方法，花括号和 `do` 与 `end` 之间的代码是块。那么，这些块中的每一个会被传递给哪个方法？结果是，`do..end`
    块会被传递给最左边的 `foo` 方法，而花括号中的块会被传递给最右边的 `bar` 方法。这是因为据说花括号比 `do` 和 `end` 有更高的优先级。
- en: 'Consider this program:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个程序：
- en: '*precedence.rb*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*precedence.rb*'
- en: '[PRE70]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here the `do..end` block has lower precedence, and the method `foo` is given
    priority. This means both `bar` and the `do..end` block are passed to `foo`. Thus,
    these two expressions are equivalent:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`do..end` 块的优先级较低，`foo` 方法被赋予优先权。这意味着 `bar` 和 `do..end` 块都被传递给 `foo`。因此，这两个表达式是等价的：
- en: '[PRE71]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A curly bracket block, on the other hand, has stronger precedence, so it tries
    to execute immediately and is passed to the first possible receiver method (`bar`).
    The result (that is, the value returned by `bar`) is then passed as an argument
    to `foo`, but this time, `foo` does not receive the block itself. Thus, the two
    following expressions are equivalent:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，花括号块有更强的优先级，因此它会立即尝试执行，并传递给第一个可能的方法接收器（`bar`）。结果（即 `bar` 返回的值）然后作为参数传递给
    `foo`，但这次 `foo` 并没有接收到块本身。因此，以下两个表达式是等价的：
- en: '[PRE72]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you are confused by all this, take comfort in that you are not alone! The
    potential ambiguities result from the fact that, in Ruby, the parentheses around
    argument lists are optional. As you can see from the alternative versions I gave
    earlier, the ambiguities disappear when you use parentheses.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此感到困惑，请放心，你不是唯一一个！这些潜在的歧义源于 Ruby 中参数列表周围的括号是可选的。正如你从我在前面给出的替代版本中看到的那样，当你使用括号时，歧义就会消失。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method can test whether it has received a block using the `block_given?` method.
    You can find examples of this in the *precedence.rb* program.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以使用 `block_given?` 方法来测试它是否接收到了一个块。你可以在 *precedence.rb* 程序中找到这个的例子。
- en: Blocks as Iterators
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块作为迭代器
- en: 'As mentioned earlier, one of the primary uses of blocks in Ruby is to provide
    iterators to which a range or list of items can be passed. Many standard classes
    such as Integer and Array have methods that can supply items over which a block
    can iterate. For example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ruby 中块的主要用途之一是提供迭代器，可以将范围或项目列表传递给这些迭代器。许多标准类，如 Integer 和 Array，都有可以提供块可以迭代的项的方法。例如：
- en: '[PRE73]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can, of course, create your own iterator methods to provide a series of
    values to a block. In the *iterate1.rb* program, I have defined a simple `timesRepeat`
    method that executes a block a specified number of times. This is similar to the
    `times` method of the Integer class except it begins at index 1 rather than at
    index 0 (here the variable `i` is displayed in order to demonstrate this):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以创建自己的迭代器方法来向块提供一系列值。在 *iterate1.rb* 程序中，我定义了一个简单的 `timesRepeat` 方法，它执行一个指定次数的块。这与
    Integer 类的 `times` 方法类似，但它从索引 1 开始而不是从索引 0 开始（这里变量 `i` 被显示出来以演示这一点）：
- en: '*iterate1.rb*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*iterate1.rb*'
- en: '[PRE74]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is an example of how this method might be called:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何调用这个方法的例子：
- en: '[PRE75]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This displays the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示以下内容：
- en: '[PRE76]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'I’ve also created a `timesRepeat2` method to iterate over an array:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我还创建了一个 `timesRepeat2` 方法来迭代数组：
- en: '[PRE77]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This could be called in this manner:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式调用：
- en: '[PRE78]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This displays the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示以下内容：
- en: '[PRE79]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Of course, it would be better (truer to the spirit of object orientation) if
    an object itself contained its own iterator method. I’ve implemented this in the
    next example. Here I have created MyArray, a subclass of Array:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果对象本身包含自己的迭代器方法会更好（更符合面向对象的精神）。我在下一个例子中实现了这个功能。在这里，我创建了 MyArray，它是 Array
    的一个子类：
- en: '[PRE80]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It is initialized with an array when a new MyArray object is created:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的 MyArray 对象时，它使用数组进行初始化：
- en: '[PRE81]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It relies upon its own `each` method (an object refers to itself as `self`),
    which is provided by its ancestor, Array, to iterate over the items in the array,
    and it uses the `times` method of Integer to do this a certain number of times.
    This is the complete class definition:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它依赖于自己的 `each` 方法（一个对象将自己称为 `self`），这是由其祖先 Array 提供的，用于遍历数组中的项，并且它使用 Integer
    的 `times` 方法来完成这个操作一定次数。这是完整的类定义：
- en: '*iterate2.rb*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*iterate2.rb*'
- en: '[PRE82]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Notice that, because I have used two iterators (`aNum.times` and `self.each`),
    the `timesRepeat` method comprises two nested blocks. This is an example of how
    you might use this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为我使用了两个迭代器（`aNum.times` 和 `self.each`），所以 `timesRepeat` 方法包含两个嵌套的块。这是一个你可以如何使用它的例子：
- en: '[PRE83]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This would output the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE84]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In *iterate3.rb*, I have set myself the problem of defining an iterator for
    an array containing an arbitrary number of subarrays, in which each subarray has
    the same number of items. In other words, it will be like a table or matrix with
    a fixed number of rows and a fixed number of columns. Here, for example, is a
    multidimensional array with three “rows” (subarrays) and four “columns” (items):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *iterate3.rb* 中，我给自己设定了定义一个包含任意数量子数组的迭代器的任务，其中每个子数组具有相同数量的项。换句话说，它将像一个具有固定行数和固定列数的表格或矩阵。例如，这是一个具有三个“行”（子数组）和四个“列”（项）的多维数组：
- en: '*iterate3.rb*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*iterate3.rb*'
- en: '[PRE85]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'I’ve tried three alternative versions of this. The first version suffers from
    the limitation of only working with a predefined number (here 2 at indexes [0]
    and [1]) of “rows” so it won’t display the symbols in the third row:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试了三种不同的版本。第一个版本受到限制，只能与预定义的数字（这里索引 [0] 和 [1] 上的 2）的“行”一起工作，因此它不会显示第三行的符号：
- en: '[PRE86]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The second version gets around this limitation by iterating over each element
    (or “row”) of `multiarr` and then iterating along each item in that row by obtaining
    the row length and using the Integer’s `times` method with that value. As a result,
    it displays the data from all three rows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本通过遍历 `multiarr` 的每个元素（或“行”），然后通过获取行长度并使用 Integer 的 `times` 方法来迭代该行中的每个项来解决这个问题。因此，它显示了所有三行的数据：
- en: '[PRE87]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The third version reverses these operations: The outer block iterates along
    the length of row 0, and the inner block obtains the item at index `i` in each
    row. Once again, this displays the data from all three rows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个版本反转了这些操作：外层块沿着行 0 的长度迭代，内层块获取每行的索引 `i` 处的项。再次显示所有三行的数据：
- en: '[PRE88]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: However, although versions 2 and 3 work in a similar way, you will find that
    they iterate through the items in a different order. Version 2 iterates through
    each complete row one at a time. Version 3 iterates down the items in each column.
    Run the program to verify that. You could try creating your own subclass of Array
    and adding iterator methods like this—one method to iterate through the rows in
    sequence and one to iterate through the columns.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管版本 2 和 3 以类似的方式工作，你会发现它们遍历项目的方式不同。版本 2 逐行遍历每一行。版本 3 遍历每一列的项目。运行程序以验证这一点。你可以尝试创建自己的
    Array 子类，并添加像这样的迭代器方法——一个方法按顺序遍历行，另一个方法遍历列。
- en: Digging Deeper
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Here we look at important differences between block scoping in Ruby 1.8 and
    1.9 and also learn about returning blocks from methods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们来看看 Ruby 1.8 和 1.9 中块作用域的重要差异，并了解从方法中返回块。
- en: Returning Blocks from Methods
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从方法中返回块
- en: 'Earlier, I explained that blocks in Ruby may act as closures. A closure may
    be said to enclose the “environment” in which it is declared. Or, to put it another
    way, it carries the values of local variables from its original scope into a different
    scope. The example I gave previously showed how the block named `ablock` captures
    the value of the local variable `x`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我解释了 Ruby 中的块可以作为闭包。闭包可以说封装了它声明的“环境”。或者，换句话说，它携带了局部变量的值从其原始作用域到不同的作用域。我之前给出的例子展示了名为
    `ablock` 的块是如何捕获局部变量 `x` 的值的：
- en: '*block_closure.rb*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*block_closure.rb*'
- en: '[PRE89]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It is then able to “carry” that variable into a different scope. Here, for
    example, `ablock` is passed to `aMethod`. When `ablock` is called inside that
    method, it runs the code `puts( x )`. This displays “hello world” and not “goodbye”:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它能够“携带”这个变量到不同的作用域。例如，`ablock` 被传递给 `aMethod`。当 `ablock` 在那个方法中被调用时，它运行 `puts(
    x )` 这段代码。这显示了“hello world”，而不是“goodbye”：
- en: '[PRE90]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this particular example, this behavior may seem like a curiosity of no great
    interest. In fact, block/closures can be used more creatively.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，这种行为可能看起来像是一个不引人注目的好奇。实际上，块/闭包可以被更有创意地使用。
- en: For example, instead of creating a block and sending it to a method, you could
    create a block *inside a method* and return that block to the calling code. If
    the method in which the block is created happens to take an argument, the block
    could be initialized with that argument.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不必创建一个块并将其发送到方法，你可以在方法内部创建一个块，并将其返回给调用代码。如果创建块的方 法恰好接受一个参数，那么块可以用那个参数初始化。
- en: 'This gives you a simple way of creating multiple blocks from the same “block
    template,” each instance of which is initialized with different data. Here, for
    example, I have created two blocks and assigned them to the variables `salesTax`
    and `vat`, each of which calculates results based on different values (0.10) and
    (0.175):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了一个简单的方法来从相同的“块模板”创建多个块，每个实例都使用不同的数据初始化。例如，我创建了两个块，并将它们分配给变量 `salesTax`
    和 `vat`，每个都基于不同的值（0.10）和（0.175）计算结果：
- en: '*block_closure2.rb*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*block_closure2.rb*'
- en: '[PRE91]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Blocks and Instance Variables
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 块和实例变量
- en: One of the less obvious features of blocks is the way in which they use variables.
    If a block may truly be regarded as a nameless function or method, then, logically,
    it should be able to contain its own local variables and have access to the instance
    variables of the object to which the block belongs.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 块的一个不太明显的特点是它们使用变量的方式。如果块确实可以被视为一个无名的函数或方法，那么从逻辑上讲，它应该能够包含自己的局部变量，并且能够访问块所属对象的实例变量。
- en: 'Let’s look first at instance variables. Load the *closures1.rb* program. This
    provides another illustration of a block acting as a closure—by capturing the
    values of the local variables in the scope in which it was created. Here I have
    created a block using the `lambda` method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看实例变量。加载 *closures1.rb* 程序。这个程序提供了另一个块作为闭包的例子——通过捕获它创建的作用域中的局部变量的值。在这里，我使用
    `lambda` 方法创建了一个块：
- en: '*closures1.rb*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*closures1.rb*'
- en: '[PRE92]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This block appends the string “ yikes!” to the instance variable `@hello`.
    Notice that at this stage in the proceedings, no value has previously been assigned
    to `@hello`. I have, however, created a separate method, `aFunc`, which does assign
    a value to a variable called `@hello`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块将字符串 “yikes!” 追加到实例变量 `@hello` 上。注意，在这个阶段，`@hello` 还没有被分配任何值。然而，我创建了一个单独的方法
    `aFunc`，它确实为名为 `@hello` 的变量分配了一个值：
- en: '[PRE93]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When I pass my block (the `aClosure` argument) to the `aFunc` method, the method
    brings `@hello` into being. I can now execute the code inside the block using
    the `call` method. And sure enough, the `@hello` variable contains the “hello
    world” string. The same variable can also be used by calling the block outside
    of the method. Indeed, now, by repeatedly calling the block, I will end up repeatedly
    appending the string “ yikes!” to `@hello`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将我的块（`aClosure`参数）传递给`aFunc`方法时，该方法使`@hello`成为现实。我现在可以使用`call`方法执行块内的代码。果然，`@hello`变量包含了“hello
    world”字符串。同样，也可以在方法外部调用块来使用这个变量。实际上，现在，通过反复调用块，我会在`@hello`上反复追加字符串“yikes!”：
- en: '[PRE94]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If you think about it, this is not too surprising. After all, `@hello` is an
    instance variable, so it exists within the scope of an object. When you run a
    Ruby program, an object called `main` is automatically created. So, you should
    expect any instance variable created within that object (the program) to be available
    to everything inside it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这并不令人惊讶。毕竟，`@hello`是一个实例变量，所以它存在于对象的作用域内。当你运行Ruby程序时，会自动创建一个名为`main`的对象。因此，你应该期望在该对象（程序）内部创建的任何实例变量都可以在它内部使用。
- en: 'The question now arises: What would happen if you were to send the block to
    a method of some *other* object? If that object has its own instance variable,
    `@hello`, which variable will the block use—the `@hello` from the scope in which
    the block was created or the `@hello` from the scope of the object in which the
    block is called? Let’s try that. You’ll use the same block as before, except this
    time it will display a bit of information about the object to which the block
    belongs and the value of `@hello`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了一个问题：如果你将块发送到另一个对象的某个方法会发生什么？如果那个对象有自己的实例变量`@hello`，那么块将使用哪个变量——是创建块的作用域中的`@hello`还是调用块的对象作用域中的`@hello`？让我们试试。你将使用与之前相同的块，但这次它会显示有关块所属对象的一些信息以及`@hello`的值：
- en: '[PRE95]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, create a new object from a new class (X), and give it a method that will
    receive the block `b` and call the block:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从一个新的类（X）创建一个新的对象，并给它一个接收块`b`并调用块的方法：
- en: '[PRE96]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To test it, just pass the block `aClos` to the `y` method of `x`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，只需将块`aClos`传递给`x`的`y`方法：
- en: '[PRE97]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And this is what is displayed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是显示的内容：
- en: '[PRE98]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: So, it is clear that the block executes in the scope of the object in which
    it was *created* (`main`) and retains the instance variable from that object even
    though the object in whose scope the block is *called* has an instance variable
    with the same name and a different value.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，块是在创建它的对象的作用域内执行的（即`main`），即使调用块的对象的作用域中有一个同名的实例变量和不同的值，它也保留了该对象的实例变量。
- en: Blocks and Local Variables
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 块和局部变量
- en: 'Now let’s see how a block/closure deals with local variables. In the *closures2.rb*
    program, I declare a variable, `x`, which is local to the context of the program:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看块/闭包如何处理局部变量。在*closures2.rb*程序中，我声明了一个变量`x`，它是程序上下文中的局部变量：
- en: '*closures2.rb*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*closures2.rb*'
- en: '[PRE99]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The first block/closure is called `c1`. Each time I call this block, it picks
    up the value of `x` defined outside the block (3,000) and returns `x + 100`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块/闭包被命名为`c1`。每次调用这个块时，它会获取块外部定义的`x`的值（3,000）并返回`x + 100`：
- en: '[PRE100]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Incidentally, even though this returns a value (in ordinary Ruby methods, the
    default value is the result of the last expression to be evaluated), in Ruby 1.9
    you cannot explicitly use the `return` statement here like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，尽管这返回了一个值（在常规Ruby方法中，默认值是最后一个要评估的表达式的结果），但在Ruby 1.9中，你不能像这样显式地使用`return`语句：
- en: '[PRE101]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: If you do this, Ruby 1.9 throws a LocalJumpError exception. Ruby 1.8, on the
    other hand, does not throw an exception.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，Ruby 1.9会抛出一个LocalJumpError异常。另一方面，Ruby 1.8不会抛出异常。
- en: This block has no block parameters (that is, there are no “block-local” variables
    between upright bars), so when it is called with a variable, `someval`, that variable
    is discarded, unused. In other words, `c1.call(someval)` has the same effect as
    `c1.call()`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块没有块参数（也就是说，在竖线之间没有“块局部”变量），所以当它用一个变量`someval`调用时，该变量被丢弃，未使用。换句话说，`c1.call(someval)`的效果与`c1.call()`相同。
- en: 'So, when you call the block `c1`, it returns `x+100` (that is, 3,100); this
    value is then assigned to `someval`. When you call `c1` a second time, the same
    thing happens all over again, so once again `someval` is assigned 3,100:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你调用块`c1`时，它返回`x+100`（即3,100）；这个值随后被分配给`someval`。当你第二次调用`c1`时，同样的事情再次发生，所以`someval`再次被分配3,100：
- en: '[PRE102]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Instead of repeating the call to `c1`, as shown earlier, you could place the
    call inside a block and pass this to the `times` method of Integer like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是像前面展示的那样重复调用`c1`，你可以将调用放在一个块中，并将其传递给Integer的`times`方法，如下所示：
- en: '[PRE103]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '*However, because it can be hard enough to work out what just one block is
    up to (such as the* *`c1`* *block here), I’ve deliberately avoided using any more
    blocks than are absolutely necessary in this program!*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为仅确定一个块（例如这里的*`c1`*块）的功能就足够困难了，我故意在这个程序中避免使用任何不必要的额外块！
- en: 'The second block is named `c2`. This declares the “block parameter” `z`. This
    too returns a value:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个块被命名为`c2`。这声明了“块参数”`z`。这也返回一个值：
- en: '[PRE104]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'However, this time the returned value can be reused since the block parameter
    acts like an incoming argument to a method—so when the value of `someval` is changed
    after it is assigned the return value of `c2`, this changed value is subsequently
    passed as an argument:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这次返回的值可以被重用，因为块参数就像方法的一个传入参数——所以当`someval`被分配了`c2`的返回值之后，这个改变后的值随后被作为参数传递：
- en: '[PRE105]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The third block, `c3`, looks, at first sight, pretty much the same as the second
    block, `c2`. In fact, the only difference is that its block parameter is called
    `x` instead of `z`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个块`c3`乍一看与第二个块`c2`几乎相同。实际上，唯一的区别是它的块参数被命名为`x`而不是`z`：
- en: '[PRE106]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The name of the block parameter has no effect on the return value. As before,
    `someval` is first assigned the value 1,100 (that is, its original value, 1,000,
    plus the 100 added inside the block). Then, when the block is called a second
    time, `someval` is assigned the value 1,200 (its previous value, 1,100, plus 100
    assigned inside the block).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 块参数的名称对返回值没有影响。和之前一样，`someval`首先被分配了1,100的值（即，它的原始值1,000加上块内增加的100）。然后，当块被第二次调用时，`someval`被分配了1,200的值（它的前一个值1,100加上块内增加的100）。
- en: 'But now look at what happens to the value of the local variable `x`. This was
    assigned 3,000 at the top of the unit. Remember that, in Ruby 1.8, an assignment
    to a block parameter can change the value of a variable with the same name in
    its surrounding context. In Ruby 1.8, then the local variable `x` changes when
    the block parameter `x` is changed. It now has the value, 1,100—that is, the value
    that the block parameter, `x`, last had when the `c3` block was called:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在看看局部变量`x`的值发生了什么。这个值在单元顶部被分配为3,000。记住，在Ruby 1.8中，对块参数的赋值可以改变其周围上下文中同名变量的值。因此，在Ruby
    1.8中，当块参数`x`改变时，局部变量`x`也会改变。现在它的值是1,100——即，当调用`c3`块时块参数`x`最后的值：
- en: '[PRE107]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Incidentally, even though block-local variables and block parameters can affect
    similarly named local variables outside the block in Ruby 1.8, the block variables
    themselves have no “existence” outside the block. You can verify this using the
    `defined?` keyword to attempt to display the type of variable if it is, indeed,
    defined:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，尽管在Ruby 1.8中，块局部变量和块参数可以影响块外同名局部变量，但块变量本身在块外没有“存在”。你可以使用`defined?`关键字来验证这一点，尝试显示变量的类型，如果它确实被定义了：
- en: '[PRE108]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This demonstrates that only `x`, and not the block variable `z`, is defined
    in the main scope:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明只有`x`，而不是块变量`z`，在主作用域中被定义：
- en: '[PRE109]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Matz, the creator of Ruby, has described the scoping of local variables within
    a block as “regrettable.” Although Ruby 1.9 has addressed some issues, it is worth
    noting that one other curious feature of block scoping remains: Namely, local
    variables within a block are invisible to the method containing that block. This
    may be changed in future versions. For an example of this, look at this code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的创造者Matz曾将块内的局部变量作用域描述为“令人遗憾的”。尽管Ruby 1.9解决了某些问题，但值得注意的是，块作用域的一个其他奇特特性仍然存在：即，块内的局部变量对包含该块的函数是不可见的。这可能在未来的版本中改变。以下是一个例子：
- en: '*local_var_scope.rb*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*local_var_scope.rb*'
- en: '[PRE110]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here, the block parameter, `b`, and the block-local variable, `c`, are both
    visible only when inside the block. The block has access to both these variables
    and to the variable `a` (local to the `foo` method). However, outside of the block,
    `b` and `c` are inaccessible, and only `a` is visible.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，块参数`b`和块局部变量`c`仅在块内部可见。块可以访问这两个变量以及变量`a`（`foo`方法的局部变量）。然而，在块外部，`b`和`c`是不可访问的，只有`a`是可见的。
- en: 'Just to add to the confusion, whereas the block-local variable, `c`, and the
    block parameter, `b`, are both inaccessible outside the block in the previous
    example, they are accessible when you iterate a block with `for`, as in the following
    example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅是为了增加混淆，在先前的例子中，块局部变量`c`和块参数`b`在块外部都是不可访问的，但是当你使用`for`循环迭代一个块时，它们就变得可访问了，如下面的例子所示：
- en: '[PRE111]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
