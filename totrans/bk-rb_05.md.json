["```\n(* This is Pascal code, not Ruby! *)\nfor i := 1 to 3 do\n   writeln( i );\n```", "```\n# This is Ruby code...\nfor i in [1,2,3] do\n   puts( i )\nend\n```", "```\nfor s in ['one','two','three'] do\n   puts( s )\nend\n```", "```\n[1,2,3].each  do |i|\n   puts( i )\nend\n```", "```\n# --- Example 1 ---\n# i) for\nfor s in ['one','two','three'] do\n   puts( s )\nend\n\n# ii) each\n['one','two','three'].each do |s|\n   puts( s )\nend\n\n# --- Example 2 ---\n# i) for\nfor x in [1, \"two\", [3,4,5] ] do puts( x ) end\n\n# ii) each\n[1, \"two\", [3,4,5] ].each do |x| puts( x ) end\n```", "```\n# Here the 'do' keyword can be omitted\nfor s in ['one','two','three']\n   puts( s )\nend\n\n# But here it is required\nfor s in ['one','two','three'] do puts( s ) end\n```", "```\n# for\nfor s in 1..3\n   puts( s )\nend\n\n# each\n(1..3).each do |s|\n   puts(s)\nend\n```", "```\nfor i in (1..10) do\n   puts( i )\nend\n```", "```\n# do..end\n[[1,2,3],[3,4,5],[6,7,8]].each do\n   |a,b,c|\n     puts( \"#{a}, #{b}, #{c}\" )\nend\n\n# curly brackets {..}\n[[1,2,3],[3,4,5],[6,7,8]].each{\n   |a,b,c|\n     puts( \"#{a}, #{b}, #{c}\" )\n}\n```", "```\n0.upto(10) do\n    | i |\n    puts( i )\nend\n```", "```\n10.downto(0) do\n    | i |\n    puts( i )\nend\n```", "```\n# Here multiarr is an array containing two 'rows'\n# (subarrays) at index 0 and 1\nmultiarr = [    ['one','two','three','four'],\n                [1,2,3,4]\n           ]\n# This for loop runs twice (once for each 'row' of multiarr)\nfor (a,b,c,d) in multiarr\n   print(\"a=#{a}, b=#{b}, c=#{c}, d=#{d}\\n\" )\nend\n```", "```\na=one, b=two, c=three, d=four\na=1, b=2, c=3, d=4\n```", "```\nmultiarr.each do |a,b,c,d|\n   print(\"a=#{a}, b=#{b}, c=#{c}, d=#{d}\\n\" )\nend\n```", "```\nmultiarr.each{  |a,b,c,d|\n    print(\"a=#{a}, b=#{b}, c=#{c}, d=#{d}\\n\" )\n}\n```", "```\na=one, b=two, c=three, d=four\na=1, b=2, c=3, d=4\n```", "```\nwhile tired\n   sleep\nend\n```", "```\nsleep while tired\n```", "```\nbegin\n   sleep\n   snore\nend while tired\n```", "```\n$hours_asleep = 0\n\ndef tired\n    if $hours_asleep >= 8 then\n       $hours_asleep = 0\n      return false\n    else\n        $hours_asleep += 1\n        return true\n    end\nend\n\ndef snore\n    puts('snore....')\nend\n\ndef sleep\n    puts(\"z\" * $hours_asleep )\nend\n\nwhile tired do sleep end    # a single-line while loop\n\nwhile tired                 # a multiline while loop\n    sleep\nend\n\nsleep while tired           # single-line while modifier\n\nbegin                       # multiline while modifier\n    sleep\n    snore\nend while tired\n```", "```\nx = 100\n\n    # The code in this loop never runs\nwhile (x < 100) do puts('x < 100') end\n\n    # The code in this loop never runs\nputs('x < 100') while (x < 100)\n\n    # But the code in loop runs once\nbegin puts('x < 100') end while (x < 100)\n```", "```\ni = 10\n\nuntil i == 10 do puts(i) end     # never executes\n\nuntil i == 10                    # never executes\n    puts(i)\n    i += 1\nend\n\nputs(i) until i == 10            # never executes\n\nbegin                            # executes once\n    puts(i)\nend until i == 10\n```", "```\narr= [1,2,3,4,5]\ni = 0\n\nwhile i < arr.length\n    puts(arr[i])\n    i += 1\nend\n\ni=0\nuntil i == arr.length\n    puts(arr[i])\n    i +=1\nend\n```", "```\ni=0\nloop do\n    puts(arr[i])\n    i+=1\n    if (i == arr.length) then\n       break\n    end\nend\n\nloop {\n    puts(arr[i])\n    i+=1\n    if (i == arr.length) then\n       break\n    end\n}\n```", "```\nx = (1..5).collect{ |i| i }\np( x )                        #=> [1, 2, 3, 4, 5]\n\narr = [1,2,3,4,5]\ny = arr.collect{ |i| i }\np( y )                        #=> [1, 2, 3, 4, 5]\nz = arr.collect{ |i| i * i }\np( z )                        #=> [1, 4, 9, 16, 25]\n\np( arr.include?( 3 ) )        #=> true\np( arr.include?( 6 ) )        #=> false\np( arr.min )                  #=> 1\np( arr.max )                  #=> 5\n```", "```\nh = {'one'=>'for sorrow',\n    'two'=>'for joy',\n    'three'=>'for a girl',\n    'four'=>'for a boy'}\n\ny = h.collect{ |i| i }\np( y )\n```", "```\n[[\"one\", \"for sorrow\"], [\"two\", \"for joy\"], [\"three\", \"for a\n girl\"], [\"four\", \"for a boy\"]]\n```", "```\np( h.min )    #=> [\"one\", \"for sorrow\"]\np( h.max )    #=> [\"two\", \"for joy\"]\n```", "```\nh.sort{ |a,b| a.to_s <=> b.to_s  }\n```", "```\nh.min{ |a,b| a[0].length <=> b[0].length }\nh.max{|a,b| a[0].length <=> b[0].length }\n```", "```\n{'one'=>'for sorrow', 'two'=>'for joy'}\n```", "```\na = ['one', 'for sorrow']\nb = ['two', 'for joy']\n```", "```\na[0].length <=> b[0].length\n```", "```\np( h.min{|a,b| a[0].length <=> b[0].length } )\n```", "```\n[\"two\", \"for joy\"]\n```", "```\n[\"one\", \"for sorrow\"]\n```", "```\np( h.min{|a,b| a[1].length <=> b[1].length } )\np( h.max{|a,b| a[1].length <=> b[1].length } )\n```", "```\n[\"two\", \"for joy\"]\n[\"seven\", \"for a secret never to be told\"]\n```", "```\nstr_arr=['one','two','three','four','five','six','seven']\n```", "```\nh.min{|a,b| str_arr.index(a[0]) <=> str_arr.index(b[0])}\nh.max{|a,b| str_arr.index(a[0]) <=> str_arr.index(b[0])}\n```", "```\n[\"one\", \"for sorrow\"]\n[\"seven\", \"for a secret never to be told\"]\n```", "```\nclass MyCollection\n   include Enumerable\n\n   def initialize( someItems )\n     @items = someItems\n   end\n\n   def each\n     @items.each{ |i|\n       yield( i )\n     }\n   end\nend\n```", "```\nthings = MyCollection.new(['x','yz','defgh','ij','klmno'])\n\np( things.min )        #=> \"defgh\"\np( things.max )        #=> \"yz\"\np( things.collect{ |i| i.upcase } )\n                       #=> [\"X\", \"YZ\", \"DEFGH\", \"IJ\", \"KLMNO\"]\n```", "```\ndef min\n  @items.to_a.min{|a,b| a.length <=> b.length }\nend\n\ndef max\n  @items.to_a.max{|a,b| a.length <=> b.length }\nend\n```", "```\nclass MyCollection\n  include Enumerable\n\n    def initialize( someItems )\n        @items = someItems\n    end\n\n    def each\n        @items.each{ |i| yield i }\n    end\n\n    def min\n        @items.to_a.min{|a,b| a.length <=> b.length }\n    end\n\n    def max\n        @items.to_a.max{|a,b| a.length <=> b.length }\n    end\nend\n```", "```\nthings = MyCollection.new(['z','xy','defgh','ij','abc','klmnopqr'])\nx = things.collect{ |i| i }\np( x ) #=> [\"z\", \"xy\", \"defgh\", \"ij\", \"abc\", \"klmnopqr\"]\ny = things.max\np( y ) #=> \"klmnopqr\"\nz = things.min\np( z ) #=> \"z\"\n```", "```\ndef each\n   @items.each{ |i|\n       yield( i )\n   }\nend\n```"]