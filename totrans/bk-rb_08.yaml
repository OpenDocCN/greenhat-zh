- en: Chapter 8. Passing Arguments and Returning Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll be looking at many of the effects (and side effects)
    of passing arguments and returning values to and from methods. First, though,
    I’ll take a moment to summarize the types of methods you’ve used up to now.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing Instance, Class, and Singleton Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An instance method is declared inside a class definition and is intended for
    use by a specific object or “instance” of the class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A class method may be declared inside a class definition, in which case the
    method name may be preceded by the class name, or a `class << self` block may
    contain a “normal” method definition. Either way, a class method is intended for
    use by the class itself, not by a specific object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Singleton methods are methods that are added to a single object and cannot
    be used by other objects. A singleton method may be defined by appending the method
    name to the object name followed by a dot or by placing a “normal” method definition
    inside an *`ObjectName`* `<< self` block like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Returning Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many programming languages, a distinction is made between functions or methods
    that return a value to the calling code and those that do not. In Pascal, for
    example, a *function* returns a value, but a *procedure* does not. No such distinction
    is made in Ruby. All methods always return a value, though of course you are not
    obliged to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When no return value is specified, Ruby methods return the result of the last
    expression evaluated. Consider this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*return_vals.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last expression evaluated is `a + b`, which happens to return 3, so that
    is the value returned by this method. There may often be times when you don’t
    want to return the last expression evaluated. In such cases, you can specify the
    return value using the `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A method is not obliged to make any assignments in order to return a value.
    If a simple piece of data happens to be the last thing evaluated in a method,
    that will be the value the method returns. When nothing is evaluated, `nil` is
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: My own programming prejudice is to write code that is clear and unambiguous
    whenever possible. For that reason, whenever I plan to use the value returned
    by a method, I prefer to specify it using the `return` keyword; only when I do
    not plan to use the returned value do I omit this. However, this is not obligatory—Ruby
    leaves the choice to you.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Multiple Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But what about those occasions when you need a method to return more than one
    value? In other program languages, you may be able to “fake” this by passing arguments
    by reference (pointers to the original data items) rather than by value (a copy
    of the data); when you alter the values of “by reference” arguments, you alter
    the original values without explicitly having to return any values to the calling
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby doesn’t make a distinction between “by reference” and “by value,” so this
    technique is not available to you (though you will see some exceptions to the
    rule shortly). However, Ruby is capable of returning multiple values all in one
    go, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*return_many.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple return values are placed into an array. If you were to evaluate `ret_things.class`,
    Ruby would inform you that the returned object is an Array. You could, however,
    explicitly return a different collection type such as a Hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Default and Multiple Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ruby lets you specify default values for arguments. Default values can be assigned
    in the parameter list of a method using the usual assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If an unassigned variable is passed to that method, the default value will
    be assigned to it. If an assigned variable is passed, however, the assigned value
    takes precedence over the default. Here I use the `p()` method to inspect and
    print the return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, a method may need to be capable of receiving an uncertain number
    of arguments—say, for example, a method that processes a variable-length list
    of items. In this case, you can “mop up” any number of trailing items by preceding
    the final argument with an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '*default_args.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Assignment and Parameter Passing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, Ruby methods come with two access points—like the doors into
    and out of a room. The argument list provides the way in; the return value provides
    the way out. Modifications made to the input arguments do not affect the original
    data for the simple reason that when Ruby evaluates an expression, the result
    of that evaluation creates a new object, so any changes made to an argument affect
    only the new object, not the original piece of data. But there are exceptions
    to this rule, which I’ll show you now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the simplest case—a method that takes one value as
    a named parameter and returns another value:'
  prefs: []
  type: TYPE_NORMAL
- en: '*in_out.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the face of it, you might think you are dealing with a single object, `x`,
    here: The object `x` goes into the `change` method, and the same object `x` is
    returned. In fact, that is not the case. One object goes in (the argument), and
    a different object comes out (the return value). You can easily verify this using
    the `object_id` method to show a number that uniquely identifies each object in
    your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The identifier of the variable, `num`, is different before and after you call
    the `change` method. This shows that even though the variable name remains the
    same, the `num` object that is returned by the `change` method is different from
    the `num` object that was sent to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method call itself has nothing to do with the change of the object. You
    can verify this by running *method_call.rb*. This simply passes the `num` object
    to the change method and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*method_call.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `object_id` is the same after `num` is returned as it was
    before `num` was sent to the method. In other words, the object that went into
    the method is the same object as the one that came out again. That leads to the
    inevitable conclusion that there is something about the *assignment* in the `change`
    method (`x += 1`) that caused the creation of a new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'But assignment itself isn’t the whole explanation. If you simply assign a variable
    to itself, no new object is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*assignment.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you now display the `object_id` of the `num` variable, the number is the
    same before an after assignment, proving that this really is the same object.
    So, what if you assign to the object the same value that it already has?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the `object_id` is unchanged after the assignment. This demonstrates
    that assignment alone does not necessarily create a new object. Now let’s try
    assigning a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, if you display `num.object_id` before and after the assignment, you
    will see a different number—say 21 before and 23 after. The actual numbers are
    automatically determined by Ruby and may vary. The important thing to understand
    is that a different object ID indicates a different object. If the same variable
    returns a different `object_id` when a value is assigned to it, that means a new
    object has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Most data items are treated as unique, so one string “hello” is considered to
    be different from another string “hello,” and one float 10.5 is considered to
    be different from another float 10.5\. Thus, any string or float assignment will
    create a new object.
  prefs: []
  type: TYPE_NORMAL
- en: But when working with integers, only when the assignment value is *different*
    from the previous value is a new object created. You can do all kinds of complicated
    operations on the right side of the assignment, but if the yielded value is the
    same as the original value, no new object is created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the first assignment creates a new `num` object with
    the integer value 11\. Even though the result of a fairly complex expression is
    used in the next assignment, this still has the value 11\. Since the value of
    `num` is not changed, no new objects are created, and its `object_id` remains
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Integers Are Special
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Ruby, an integer (or Fixnum) has a fixed identity. Every instance of the
    number 10 or every variable to which the value 10 is assigned will have the same
    `object_id`. The same cannot be said of other data types. Each instance of a floating-point
    number such as 10.5 or of a string such as “hello world” will be a different object
    with a unique `object_id`. Be aware that when you assign an integer to a variable,
    that variable will have the `object_id` *of the integer itself*. But when you
    assign some other type of data to a variable, a new object will be created even
    if the data itself is the same at each assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '*object_ids.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: But why does all this matter?
  prefs: []
  type: TYPE_NORMAL
- en: It matters because of a few rare exceptions to the rule. As I said earlier,
    most of the time, a method has a well-defined way in and a well-defined way out.
    Once an argument goes inside a method, it enters a closed room. Any code outside
    that method has no way of learning about any changes that have been made to the
    argument until it comes out again in the form of a returned value. This is, in
    fact, one of the deep secrets of “pure” object orientation. The implementation
    details of methods should, in principle, be hidden away, or *encapsulated*. This
    ensures that code outside an object cannot be dependent on things that happen
    inside that object.
  prefs: []
  type: TYPE_NORMAL
- en: The One-Way-In, One-Way-Out Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most modern object-oriented languages such as Java and C#, encapsulation
    and information hiding are not rigorously enforced. In Smalltalk, on the other
    hand—the most famous and influential object-oriented language—encapsulation and
    information hiding are fundamental principles: If you send a variable `x` to a
    method `y` and the value of `x` is changed inside `y`, you cannot obtain the changed
    value of `x` from outside the method—*unless the method explicitly returns that
    value*.'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation or Information Hiding?
  prefs: []
  type: TYPE_NORMAL
- en: Often these two terms are used interchangeably. To be nitpicky, however, there
    is a difference. *Encapsulation* refers to the grouping together of an object’s
    “state” (its data) and the operations that may alter or interrogate its state
    (its methods). *Information hiding* refers to the fact that data is sealed off
    and can be accessed only using well-defined routes in and out—in object-oriented
    terms, this implies “accessor methods” to get or return values. In procedural
    languages, information hiding may take other forms; for example, you might have
    to define interfaces to retrieve data from code “units” or “modules” rather than
    from objects.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented terms, encapsulation and information hiding are almost synonymous—true
    encapsulation necessarily implies that the internal data of an object is hidden.
    However, many modern object-oriented languages such as Java, C#, C++, and Object
    Pascal are quite permissive in the degree to which information hiding is enforced
    (if at all).
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, Ruby adheres to this principle: Arguments go into a method, but any
    changes made inside the method cannot be accessed from the outside unless Ruby
    returns the changed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '*hidden.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the string value of the second object, `str2`, is received
    by the `anotherStr` argument of the `hidden` method. The argument is assigned
    a new string value and reversed. Even so, neither of the original variables, `str1`
    or `str2`, is changed. Only the variable assigned the return value, `str3`, contains
    the changed “hello world” string.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that there are occasions when arguments passed to a Ruby method
    can be used like the “by reference” arguments of other languages (that is, changes
    made *inside* the method may affect variables *outside* the method). This is because
    some Ruby methods modify the original object rather than yielding a value and
    assigning this to a new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are some methods ending with an exclamation mark that alter
    the original object. Similarly, the String append method `<<` concatenates the
    string on its right to the string on its left but does not create a new string
    object in the process: So, the value of the string on the left is modified, but
    the string object itself retains its original `object_id`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The consequence of this is that if you use the `<<` operator instead of the
    `+` operator in a method, your results will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '*not_hidden.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the `anotherStr` argument is concatenated with a space
    and the `aStr` argument using `<<`, and the resulting string is reversed when
    returned. If information hiding were rigorously enforced, this might be expected
    to produce the same results as in the previous program—that is, `str1` and `str2`
    would remain unchanged. However, the use of `<<` has had profound effects because
    it has caused the modifications made to the `aStr` argument *inside* the `nothidden`
    method to change the value of the `str1` object *outside* the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior, incidentally, would be the same if the `nothidden` method were
    placed into a separate class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*nothidden2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This shows that, in certain cases, the internal implementation details of an
    object’s methods may accidentally alter the code that calls it. It is generally
    safer to make implementation details hidden; otherwise, when code is rewritten
    inside a class, the changes may have side effects on code that uses that class.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Receivers and Yielding New Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall from [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes") that
    I made the distinction between methods that modify their receiver and those that
    do not. (Remember that a *receiver* is the object that “owns” the method.) In
    most cases, Ruby methods do not modify the receiver object. However, some methods,
    such as those ending with `!`, do modify their receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *str_reverse.rb* sample program should help clarify this. This shows that
    when you use the `reverse` method, for example, no change is made to the receiver
    object (that is, an object such as `str1`). But when you use the `reverse!` method,
    a change *is* made to the object (its letters are reversed). Even so, no new object
    is created: `str1` is the same object before and after the `reverse!` method is
    called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here `reverse` operates like most Ruby methods: It yields a value, and in order
    to use that value, you must assign it to a new object. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*str_reverse.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `str1` is unaffected by calling `reverse`. It still has the value “hello”
    and still has its original `object_id`. Now look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `str1` *is* changed (it becomes “olleh”). Even so, no new object
    is created: `str1` has the same `object_id` with which it started. So, how about
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This time, the value yielded by `str1.reverse` is assigned to `str1`. The yielded
    value is a new object, so `str1` is now assigned the reversed string (“olleh”),
    and it now has a new `object_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the sample program *concat.rb* for an example of the string concatenation
    method, `<<`, which, just like those methods that end with `!`, modifies the receiver
    object without creating a new object (once again, the actual `object_id` numbers
    may be different when you run the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '*concat.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `str1` is never modified, so it has the same `object_id` throughout;
    `str2` *is* modified through concatenation. However, the `<<` operator does not
    create a new object, so `str2` also retains its original `object_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But `str3` is a different object at the end than at the beginning, because
    it is assigned the value yielded by this expression: `str2 << str1`. This value
    happens to be the `str2` object itself, so the `object_id` of `str3` is now identical
    to that of `str2` (that is, `str2` and `str3` *now reference the same object*).'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, then, methods ending with a `!` such as `reverse!`, plus some other
    methods such as the `<<` concatenation method, change the value of the receiver
    object. Most other methods do not change the value of the receiver object. To
    use any new value yielded as a result of calling one of these methods, you have
    to assign that value to a variable (or pass the yielded value as an argument to
    a method).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fact that a few methods modify the receiver object whereas most do not
    may seem harmless enough, but beware: This behavior provides you with the ability
    to retrieve the values of arguments “by reference” rather than retrieving values
    that are explicitly returned. Doing so breaks encapsulation by allowing your code
    to rely upon the internal implementation details of a method. This can potentially
    lead to unpredictable side effects and, in my view, should be avoided.'
  prefs: []
  type: TYPE_NORMAL
- en: Potential Side Effects of Reliance on Argument Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a simple (but, in real-world programming, potentially serious) example
    of how relying on the modified values of arguments rather than on explicit return
    values can introduce undesirable dependencies on implementation details, see *side_effects.rb*.
    Here is a method called `stringProcess` that takes two string arguments, messes
    about with them, and returns the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '*side_effects.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume the object of the exercise is to take two lowercase strings and
    return a single string that combines these two strings, separated by a space and
    with the first and last letters capitalized. So, the two original strings might
    be “hello” and “world,” and the returned string is “Hello worlD.” This works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But now there is an impatient programmer who can’t be bothered with return
    values. He notices that the modifications made inside the method change the values
    of the ingoing arguments. So, heck! (he decides), he might as well use the arguments
    themselves! This is his version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By using the values of the input arguments, `str1` and `str2`, he has obtained
    the same result as if he had used the returned value, `str3`. He then goes away
    and writes a fabulously complicated text-processing system with thousands of bits
    of code reliant on the changed values of those two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now the programmer who originally wrote the `stringProcess` method decides
    that the original implementation was inefficient or inelegant and so rewrites
    the code confident in the knowledge that the return value is unchanged (if “hello”
    and “world” are sent as arguments, “Hello worlD” is returned just as it was by
    the previous version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Aha! But the new implementation causes the values of the input arguments to
    be changed inside the body of the method. So, the impatient programmer’s text-processing
    system, which relies on those *arguments* rather than on the return value, is
    now filled with bits of text saying “hello Dlrow” instead of the “Hello worlD”
    he was expecting (actually, it turns out that his program was processing the works
    of Shakespeare, so a generation of actors will end up declaiming, “To eb or ton
    to eb, that si the noitseuq...”). This is the kind of unexpected side effect that
    can easily be avoided by following the one-way-in, one-way-out principle.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned earlier that it is possible for a method to return multiple values,
    separated by commas. Often you will want to assign these returned values to a
    set of matching variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ruby, you can do this in a single operation by parallel assignment. This
    means you can have several variables to the left or an assignment operator and
    several values to the right. The values to the right will be assigned, in order,
    to the variables on the left, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*parallel_assign.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This ability not only gives you a shortcut way to make multiple assignments;
    it also lets you swap the values of variables (you just change their orders on
    either side of the assignment operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can make multiple assignments from the values returned by a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specify more variables to the left than there are values on the right
    of an assignment, any “trailing” variables will be assigned `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple values returned by a method are put into an array. When you put an
    array to the right of a multiple-variable assignment, its individual elements
    will be assigned to each variable, and once again if too many variables are supplied,
    the extra ones will be assigned `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: In this section we look at some of the inner workings of parameter-passing and
    object equality. I also discuss the value of parentheses for code clarity.
  prefs: []
  type: TYPE_NORMAL
- en: By Reference or By Value?
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, I said that Ruby does not make a distinction between arguments that
    are passed “by value” and “by reference.” Even so, if you search the Internet,
    you’ll soon discover that Ruby programmers often get into arguments about how
    exactly arguments are passed. In many procedural programming languages such as
    Pascal or C, there is a clear distinction between arguments passed by value or
    by reference.
  prefs: []
  type: TYPE_NORMAL
- en: A *by value* argument is a *copy* of the original variable; you can pass it
    to a function and mess around with it, and the value of the original variable
    remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: A *by reference* argument, on the other hand, is a *pointer* to the original
    variable. When this gets passed to a procedure, you are not passing a new copy
    but a reference to the bit of memory in which the original data is stored. So,
    any changes made inside the procedure are made to the original data and necessarily
    affect the value of the original variable.
  prefs: []
  type: TYPE_NORMAL
- en: So, which way does Ruby pass arguments? It’s actually pretty easy to resolve
    this issue. If Ruby passes by value, then it makes a copy of the original variable,
    and that copy will therefore have a different `object_id`. In fact, this is not
    the case. Try the *arg_passing.rb* program to prove this point.
  prefs: []
  type: TYPE_NORMAL
- en: '*arg_passing.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This prints out the object IDs of an integer, a floating-point number, a string,
    and a custom object both when they are originally declared and when they are passed
    as arguments to the `aMethod()` method. In each case, the ID of the argument is
    the same as the ID of the original variable, so the arguments must be passed by
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it may well be that in certain circumstances the passing of arguments could,
    “behind the scenes” so to speak, be *implemented* as “by value.” However, such
    implementation details should be of interest to writers of Ruby interpreters and
    compilers rather than to Ruby programmers. The plain fact of the matter is that
    if you program in a “pure” object-oriented way—by passing arguments into methods
    but only subsequently using the values that those methods return—the implementation
    details (by value or by reference) will be of no consequence to you.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, because Ruby can occasionally modify arguments (for example, using
    `!` methods or `<<`, as explained in [Modifying Receivers and Yielding New Objects](ch08s08.html
    "Modifying Receivers and Yielding New Objects") in [Modifying Receivers and Yielding
    New Objects](ch08s08.html "Modifying Receivers and Yielding New Objects")), some
    programmers have formed the habit of using the modified values of the arguments
    themselves (equivalent to using by reference arguments in C) rather than using
    the values returned. In my view, this is a bad practice. It makes your programs
    reliant upon the implementation details of methods and should, therefore, be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Are Assignments Copies or References?
  prefs: []
  type: TYPE_NORMAL
- en: 'I said earlier that a new object is created when a value is *yielded* by some
    expression. So, for example, if you assign a new value to a variable called `x`,
    the object after the assignment will be a different object from the one before
    the assignment (that is, it will have a different `object_id`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: But it isn’t the assignment that creates a new object. It is the value that
    is yielded that causes a new object to be created. In the previous example, `+=1`
    is an expression that yields a value (`x+=1` is equivalent to the expression `x=x+1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple assignment of one variable to another does not create a new object.
    So, let’s assume you have one variable called `num` and another called `num2`.
    If you assign `num2` to `num`, both variables will refer to the same object. You
    can test this using the `equal?` method of the Object class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*assign_ref.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Tests for Equality: == or equal?'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default (as defined in Ruby’s `Kernel` module), a test using `==` returns
    `true` when both objects being tested are the same object. So, it will return
    `false` if the values are the same but the objects are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '*equal_tests.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `==` is frequently overridden by classes such as String and will then
    return `true` when the values are the same but the objects are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For that reason, the `equal?` method is preferable when you want to establish
    whether two variables refer to the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When Are Two Objects Identical?
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule, if you initialize 10 variables with 10 values, each variable
    will refer to a different object. For example, if you create two strings like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*identical.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'then `s1` and `s2` will refer to independent objects. The same goes for two
    floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But, as mentioned earlier, integers are different. Create two integers with
    the same value, and they will end up referencing the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is even true with literal integer values. If in doubt, use the `equals?`
    method to test whether two variables or values reference exactly the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Parentheses Avoid Ambiguity
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods may share the same name as local variables. For example, you might
    have a variable called `name` and a method called `name`. If it is your habit
    to call methods without parentheses, it may not be obvious whether you are referring
    to a method or a variable. Once again, parentheses avoid ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '*parentheses.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
