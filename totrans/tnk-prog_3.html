<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Solving Problems with Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="solving_problems_with_arrays"/>Chapter 3. Solving Problems with Arrays</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id3"/><div class="mediaobject"><a id="I_mediaobject3_d1e2870"/><img src="httpatomoreillycomsourcenostarchimages1273151.png.jpg" alt="image with no caption"/></div></div><p>In the previous chapter, we limited ourselves to <span class="emphasis"><em>scalar variables</em></span>, that is, variables that can hold only one value at a time. In this chapter, we’ll look at problems using the most common aggregate data structure, the array. Although arrays are simple structures with fundamental limitations, their use greatly magnifies the power of our programs.<a id="IDX-CHP-3-0001" class="indexterm"/><a id="IDX-CHP-3-0002" class="indexterm"/><a id="IDX-CHP-3-0003" class="indexterm"/></p><p>In this chapter, we will primarily deal with actual arrays, that is, those declared with the built-in C++ syntax, such as:<a id="IDX-CHP-3-0004" class="indexterm"/></p><a id="I_programlisting3_d1e2896"/><pre class="programlisting">int tenIntegerArray[10];</pre><p>However, the techniques we discuss apply just as well to data structures with similar attributes. The most common of these structures is a vector. The term <span class="emphasis"><em>vector</em></span> is often used as a synonym for any array of a single dimension, but we’ll use it here in the more specific sense of a structure that has the attributes of an array without a specified maximum number of elements. So for our discussions, an array is of a fixed size, while a vector can grow or shrink automatically as needed. Each of the problems we discuss in this chapter includes some restriction that allows us to use a structure with a fixed number of elements. Problems without such restrictions, however, could be adapted to use a vector.</p><p>Moreover, the techniques used with arrays can often be used with data structures that do not have every attribute listed above. Some techniques, for example, don’t require random access, so they can be used with structures like linked lists. Because arrays are so common in programming, and because array techniques are frequently used in non-array contexts, arrays are a great training ground for the study of problem solving with data structures.<a id="IDX-CHP-3-0005" class="indexterm"/><a id="IDX-CHP-3-0006" class="indexterm"/></p><div class="sect1" title="Review of Array Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="review_of_array_fundamentals"/>Review of Array Fundamentals</h1></div></div></div><p>You should already know what an array is, but let’s go over some of the attributes of arrays for clarity. An <span class="emphasis"><em>array</em></span> is a collection of variables of the same type organized under one name, where the individual variables are denoted by a number. We call the individual variables the <span class="emphasis"><em>elements</em></span> of the array. In C++ and most other languages, the first element has number 0, but in some languages, this will vary.<a id="IDX-CHP-3-0007" class="indexterm"/></p><p>The primary attributes of the array follow directly from the definition. Every value stored in an array is of the same type, whereas other aggregate data structures can store values of mixed types. An individual element is referenced by a number called a <span class="emphasis"><em>subscript</em></span>; in other data structures, individual elements might be referenced by name or by a key value.<a id="IDX-CHP-3-0008" class="indexterm"/><a id="IDX-CHP-3-0009" class="indexterm"/></p><p>From these primary attributes, we can derive several secondary attributes. Because each of the elements is designated by a number in a sequence starting from 0, we can easily examine every value in an array. In other data structures, this may be difficult, inefficient, or even impossible. Also, whereas some data structures, such as linked lists, can be accessed only sequentially, an array offers <span class="emphasis"><em>random access</em></span>, meaning we can access any element of the array at any time.</p><p>These primary and secondary attributes determine how we can use arrays. When dealing with any aggregate data structure, it’s good to have a set of basic operations in mind as you consider problems. Think of these basic operations as common tools—the hammers, screwdrivers, and wrenches of the data structure. Not every mechanical problem can be solved with common tools, but you should always consider whether a problem can be solved with common tools before making a trip to the hardware store. Here’s my list of basic operations for arrays.<a id="IDX-CHP-3-0010" class="indexterm"/></p><div class="sect2" title="Store"><div class="titlepage"><div><div><h2 class="title"><a id="store"/>Store</h2></div></div></div><p>This is the most basic of operations. An array is a collection of variables, and we can assign a value to each of those variables. To assign the integer 5 to the first element (element 0) in the previously declared array, we just say:</p><a id="I_programlisting3_d1e2957"/><pre class="programlisting">tenIntegerArray[0] = 5;</pre><p>As with any variable, the values of the elements inside our array will be random “garbage” until particular values are assigned, so arrays should be initialized before they are used. In some cases, especially for testing, we will want to assign a particular value to every element in the array. We can do that with an initializer when the array is declared.<a id="IDX-CHP-3-0011" class="indexterm"/><a id="IDX-CHP-3-0012" class="indexterm"/></p><a id="I_programlisting3_d1e2971"/><pre class="programlisting">int tenIntegerArray[10] = {4, 5, 9, 12, −4, 0, −57, 30987, −287, 1};</pre><p>We’ll see a good use of an array initializer shortly. Sometimes, instead of assigning a different value to each element, we just want every element in the array to be initialized to the same value. There are some shortcuts for assigning a zero to every element in the array, depending on the situation or the compiler used (the C++ compiler in Microsoft Visual Studio, for example, initializes every value in any array to zero unless otherwise specified). At this stage, however, I would always explicitly initialize an array wherever initialization is required in order to enhance readability, as in this code, which sets every element in a 10-element array to −1:<a id="IDX-CHP-3-0013" class="indexterm"/></p><a id="I_programlisting3_d1e2980"/><pre class="programlisting">int tenIntegerArray[10];
for (int i = 0; i &lt; 10; i++) tenIntegerArray[i] = −1;</pre></div><div class="sect2" title="Copy"><div class="titlepage"><div><div><h2 class="title"><a id="copy"/>Copy</h2></div></div></div><p>We can make a copy of the array. There are two common situations in which this might be useful. First, we might want to heavily manipulate the array but still require the array in its original form for later processing. Putting the array back in its original form after manipulation may be difficult, or even impossible, if we’ve changed any of the values. By copying the entire array, we can manipulate the copy without disturbing the original. All we need to copy an entire array is a loop and an assignment statement, just like the code for initialization:<a id="IDX-CHP-3-0014" class="indexterm"/></p><a id="I_programlisting3_d1e2992"/><pre class="programlisting">int tenIntegerArray[10] = {4, 5, 9, 12, −4, 0, −57, 30987, −287, 1};
int secondArray[10];
for (int i = 0; i &lt; 10; i++) secondArray[i] = tenIntegerArray[i];</pre><p>That operation is available to most aggregate data structures. The second situation is more specific to arrays. Sometimes we want to copy part of the data from one array to a second array, or we want to copy the elements from one array to a second array as a method of rearranging the order of the elements. If you have studied the merge-sort algorithm, you’ve seen this idea in action. We’ll see examples of copying later in this chapter.</p></div><div class="sect2" title="Retrieval and Search"><div class="titlepage"><div><div><h2 class="title"><a id="retrieval_and_search"/>Retrieval and Search</h2></div></div></div><p>With the ability to put values into the array, we also need the ability to get them out of the array. Retrieving the value from a particular location is straightforward:</p><a id="I_programlisting3_d1e3001"/><pre class="programlisting">int num = tenIntegerArray[0];</pre><div class="sect3" title="Searching for a Specific Value"><div class="titlepage"><div><div><h3 class="title"><a id="searching_for_a_specific_value"/>Searching for a Specific Value</h3></div></div></div><p>Usually the situation isn’t that simple. Often we don’t know the location we need, and we instead have to <span class="emphasis"><em>search</em></span> the array to find the location of a specific value. If the elements in the array are in no particular order, the best we can do is a sequential search, where we look at each element in the array from one end to the other until we find the desired value. Here’s a basic version.<a id="IDX-CHP-3-0015" class="indexterm"/><a id="IDX-CHP-3-0016" class="indexterm"/><a id="IDX-CHP-3-0017" class="indexterm"/><a id="IDX-CHP-3-0018" class="indexterm"/><a id="IDX-CHP-3-0019" class="indexterm"/><a id="IDX-CHP-3-0020" class="indexterm"/><a id="IDX-CHP-3-0021" class="indexterm"/><a id="IDX-CHP-3-0022" class="indexterm"/></p><a id="I_programlisting3_d1e3051"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> const int ARRAY_SIZE = 10;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> int intArray[ARRAY_SIZE] = {4, 5, 9, 12, −4, 0, −57, 30987, −287, 1};
<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/> int targetValue = 12;
<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/> int targetPos = 0;
  while ((intArray[targetPos] != targetValue) &amp;&amp; (targetPos &lt; <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>ARRAY_SIZE))
      targetPos++;</pre><p>In this code, we have a constant that stores the size of the array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3084"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, the array itself <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3090"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, a variable to store the value we are looking for in the array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3096"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, and a variable to store the location where the value is found <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3102"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. In this example, we use our <code class="literal">ARRAY_SIZE</code> constant to limit the number of iterations over our array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3112"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>, so that we won’t run past the end of the array when <code class="literal">targetValue</code> is not found among the array elements. You could “hard-wire” the number 10 in place of the constant, but using the constant makes the code more general, thus making it easy to modify and reuse. We’ll use an <code class="literal">ARRAY_SIZE</code> constant in most of the code in this chapter. Note that if <code class="literal">targetValue</code> is not found in <code class="literal">intArra</code><code class="literal">y</code>, then <code class="literal">targetPos</code> will be equal to <code class="literal">ARRAY_SIZE</code> after the loop. This is enough to signify the event because <code class="literal">ARRAY_SIZE</code> is not a valid element number. It will be up to the code that follows, however, to check that. Also note that the code makes no effort to handle the possibility that the target value appears more than once. The first time the target value appears, the loop is over.</p></div><div class="sect3" title="Criterion-Based Search"><div class="titlepage"><div><div><h3 class="title"><a id="criterion-based_search"/>Criterion-Based Search</h3></div></div></div><p>Sometimes the value we are looking for isn’t a fixed value but a value based on the relationship with other values in the array. For example, we might want to find the highest value in the array. The mechanism to do that is what I call “King of the Hill,” in reference to the playground game. Have a variable that represents the highest value seen <span class="emphasis"><em>so far</em></span> in the array. Run through all the elements in the array with a loop, and each time you encounter a value higher than the previous highest value, the new value knocks the previous king off the hill, taking his place:</p><a id="I_programlisting3_d1e3150"/><pre class="programlisting">const int ARRAY_SIZE = 10;
  int intArray[ARRAY_SIZE] = {4, 5, 9, 12, −4, 0, −57, 30987, −287, 1};
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int highestValue = intArray[0];
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> for (int i = 1; i &lt; ARRAY_SIZE; i++) {
      <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>if (intArray[i] <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>&gt; highestValue) highestValue = intArray[i];
  }</pre><p>The variable <code class="literal">highestValue</code> stores the largest value found in the array so far. At its declaration, it is assigned the value of the first element in the array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3181"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which allows us to start the loop at the second element in the array (it allows us to start with <code class="literal">i</code> at 1 instead of 0) <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3190"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Inside the loop, we compare the value at the current position with <code class="literal">highestValue</code>, replacing <code class="literal">highestValue</code> if appropriate <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3203"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Note that finding the lowest value, instead of the highest, is just a matter of switching the “greater-than” comparison <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3209"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> to a “less-than” comparison (and changing the name of the variable so we don’t confuse ourselves). This basic structure can be applied to all sorts of situations in which we want to look at every element in the array to find the value that most exemplifies a particular quality.<a id="IDX-CHP-3-0023" class="indexterm"/><a id="IDX-CHP-3-0024" class="indexterm"/><a id="IDX-CHP-3-0025" class="indexterm"/><a id="IDX-CHP-3-0026" class="indexterm"/><a id="IDX-CHP-3-0027" class="indexterm"/><a id="IDX-CHP-3-0028" class="indexterm"/><a id="IDX-CHP-3-0029" class="indexterm"/></p></div></div><div class="sect2" title="Sort"><div class="titlepage"><div><div><h2 class="title"><a id="sort"/>Sort</h2></div></div></div><p><span class="emphasis"><em>Sorting</em></span> means putting data in a specified order. You have probably already encountered sorting algorithms for arrays. This is a classic area for performance analysis because there are so many competing sorting algorithms, each with performance characteristics that vary depending on features of the underlying data. The study of different sorting algorithms could be the subject of an entire book by itself, so we’re not going to explore this area in its full depth. Instead, we’re going to focus on what is practical. For most situations, you can make do with two sorts in your toolbox: a fast, easy-to-use sort and a decent, easy-to-understand sort that you can modify with confidence when the situation arises. For fast and easy, we’ll use the standard library function <code class="literal">qsort</code>, and when we need something to tweak, we’ll use an insertion sort.<a id="IDX-CHP-3-0030" class="indexterm"/><a id="IDX-CHP-3-0031" class="indexterm"/><a id="IDX-CHP-3-0032" class="indexterm"/><a id="IDX-CHP-3-0033" class="indexterm"/><a id="IDX-CHP-3-0034" class="indexterm"/></p><div class="sect3" title="Fast-and-Easy Sorting with qsort"><div class="titlepage"><div><div><h3 class="title"><a id="fast-and-easy_sorting_with_qsort"/>Fast-and-Easy Sorting with qsort</h3></div></div></div><p>The default fast sort for C/C++ programmers is the <code class="literal">qsort</code> function in the standard library (the name suggests that the underlying sort employs a quicksort, but the implementer of the library is not required to use that algorithm). To use <code class="literal">qsort</code>, we have to write a comparator function. This function will be called by <code class="literal">qsort</code> whatever it needs to compare two elements in the array to see which should appear earlier in sorted order. The function is passed two <code class="literal">void</code> pointers. We haven’t discussed pointers yet in this book, but all you need to know here is that you should cast those <code class="literal">void</code> pointers to pointers to the element type in your array. Then the function should return an <code class="literal">int</code>, either positive, negative, or zero, based on whether the first element is larger, smaller, or equal to the second element. The exact value returned doesn’t matter, only whether it is positive, negative, or zero. Let’s clear up this discussion with a quick example of sorting an array of 10 integers using <code class="literal">qsort</code>. Our comparator function:<a id="IDX-CHP-3-0035" class="indexterm"/><a id="IDX-CHP-3-0036" class="indexterm"/><a id="IDX-CHP-3-0037" class="indexterm"/></p><a id="I_programlisting3_d1e3318"/><pre class="programlisting">int compareFunc(<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>const void * voidA, const void * voidB) {
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>int * intA = (int *)(voidA);
    int * intB = (int *)(voidB);
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>return *intA - *intB;
}</pre><p>The parameter list consists of two <code class="literal">const void</code> pointers <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3343"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Again, this is always the case for the comparator. The code inside the function begins by declaring two <code class="literal">int</code> pointers <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3352"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> and casting the two <code class="literal">void</code> pointers to the <code class="literal">int</code> pointer type. We could write the function without the two temporary variables; I’m including them here for clarity. The point is, once we are done with those declarations, <code class="literal">intA</code> and <code class="literal">intB</code> will point at two elements in our array, and <code class="literal">*intA</code> and <code class="literal">*intB</code> will be two integers that must be compared. Finally, we return the result of subtracting the second integer from the first <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3377"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. This produces the result we want. If <code class="literal">intA</code> &gt; <code class="literal">intB</code>, for example, we want to return a positive number, and <code class="literal">intA</code> – <code class="literal">intB</code> will be positive if <code class="literal">intA</code> &gt; <code class="literal">intB</code>. Likewise, <code class="literal">intA</code> – <code class="literal">intB</code> will be negative if <code class="literal">intB</code> &gt; <code class="literal">intA</code> and will be zero when the two integers are equal.</p><p>With the comparator function in place, a sample use of <code class="literal">qsort</code> looks like this:</p><a id="I_programlisting3_d1e3420"/><pre class="programlisting">const int ARRAY_SIZE = 10;
int intArray[ARRAY_SIZE] = {87, 28, 100, 78, 84, 98, 75, 70, 81, 68};
qsort(<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>intArray, <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>ARRAY_SIZE, <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>sizeof(int), <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>compareFunc);</pre><p>As you can see, the call to <code class="literal">qsort</code> takes four parameters: the array to be sorted <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3451"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>; the number of elements in that array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3457"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>; the size of one element in the array, usually determined, as it is here, by the <code class="literal">sizeof</code> operator <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3466"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>; and finally, the comparator function <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3473"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. If you haven’t had much experience passing functions as parameters to other functions, note the syntax used for the last parameter. We are passing the function itself, not calling the function and passing the result of the call. Therefore, we simply state the name of the function, with no parameter list or parentheses.</p></div><div class="sect3" title="Easy-to-Modify Sorting with Insertion Sort"><div class="titlepage"><div><div><h3 class="title"><a id="easy-to-modify_sorting_with_insertion_so"/>Easy-to-Modify Sorting with Insertion Sort</h3></div></div></div><p>In some cases, you will need to write your own sorting code. Sometimes the built-in sort just won’t work for your situation. For example, suppose you had an array of data that you wanted to order based on the data in <span class="emphasis"><em>another</em></span> array. When you have to write your own sort, you will want a straightforward sorting routine that you believe in and can crank out on demand. A reasonable suggestion for a go-to sort is an <span class="emphasis"><em>insertion sort</em></span>. The insertion sort works the way many people would sort cards when playing bridge: They pick up the cards one at a time and insert them in the appropriate place in their hands to maintain the overall order, moving the other cards down to make room. Here’s a basic implementation for our integer array:<a id="IDX-CHP-3-0038" class="indexterm"/><a id="IDX-CHP-3-0039" class="indexterm"/></p><a id="I_programlisting3_d1e3502"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int start = 0;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> int end = ARRAY_SIZE - 1;
<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/> for (int i = start + 1; i &lt;= end; i++) {
      for (<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>int j = i; <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>j &gt; start &amp;&amp; <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>
intArray[j-1] &gt; intArray[j]; j--) {
        <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>int temp = intArray[j-1];
          intArray[j-1] = intArray[j];
          intArray[j] = temp;
      }
  }</pre><p>We start by declaring two variables, <code class="literal">start</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3551"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and <code class="literal">end</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3560"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, indicating the subscript of the first and last elements in the array. This improves the readability of the code and also allows the code to be easily modified to sort just a portion of the array, if desired. The outer loop selects the next “card” to be inserted into our ever-increasing sorted hand <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3566"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Notice that the loop initializes <code class="literal">i</code> to <code class="literal">start + 1</code>. Remember in the “find the largest value” code, we initialized our highest-value variable to the first element in the array and started our loop with the second element in the array. This is the same idea. If we have only one value (or “card”), then by definition it is “in order” and we can begin by considering whether the second value should come before or after the first. The inner loop puts the current value in its correct position by repeatedly swapping the current value with its predecessor until it reaches the correct location. The loop counter <code class="literal">j</code> starts at <code class="literal">i</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3585"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>, and the loop decrements <code class="literal">j</code> so long as we haven’t reached the lower end of the array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3595"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span> and haven’t yet found the right stopping point for this new value <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3601"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>. Until then, we use three assignment statements to swap the current value down one position in the array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3607"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. In other words, if you had a hand of 13 playing cards and had already sorted the leftmost 4 cards, you could put the 5th card from the left in the correct position by repeatedly moving it down one card until it was no longer of a lower value than the card to its left. That’s what the inner loop does. The outer loop does this for every card starting from the leftmost. So when we’re done, the entire array is sorted.<a id="IDX-CHP-3-0040" class="indexterm"/><a id="IDX-CHP-3-0041" class="indexterm"/><a id="IDX-CHP-3-0042" class="indexterm"/><a id="IDX-CHP-3-0043" class="indexterm"/></p><p>An insertion sort is not the most efficient sort for most circumstances, and to tell the truth, the previous code is not even the most efficient way to perform an insertion sort. It is reasonably efficient for small to moderately sized arrays, however, and it is simple enough that it can be memorized—think of it as a mental macro. Whether you choose this sort or another, you should have one decent or better sorting routine that you can code yourself with confidence. It’s not enough to have access to someone else’s sorting code that you don’t fully understand. You don’t want to tinker with the machinery if you’re not sure how everything works.</p></div></div><div class="sect2" title="Compute Statistics"><div class="titlepage"><div><div><h2 class="title"><a id="compute_statistics"/>Compute Statistics</h2></div></div></div><p>The final operation is similar to the retrieval operation, in that we need to look at every element in the array before returning a value. It is different from the retrieval operation, in that the value is not simply one of the elements in the array but some statistic computed from all the values in the array. For example, we might compute the average, median, or mode, and we will perform all of these computations later in this chapter. A basic statistic we might compute could be the average of a set of student grades:</p><a id="I_programlisting3_d1e3640"/><pre class="programlisting">const int ARRAY_SIZE = 10;
int gradeArray[ARRAY_SIZE] = {87, 76, 100, 97, 64, 83, 88, 92, 74, 95};
double sum = 0;
for (int i = 0; i &lt; ARRAY_SIZE; i++) {
    sum += gradeArray[i];
}
double average = sum / ARRAY_SIZE;</pre><p>As another simple example, consider data validation. Suppose an array of double values called <code class="literal">vendorPayments</code> represents payments to vendors. Only positive values are valid, and therefore negative values indicate data integrity problems. As part of a validation report, we might write a loop to count the number of negative values in the array:<a id="IDX-CHP-3-0044" class="indexterm"/><a id="IDX-CHP-3-0045" class="indexterm"/><a id="IDX-CHP-3-0046" class="indexterm"/><a id="IDX-CHP-3-0047" class="indexterm"/></p><a id="I_programlisting3_d1e3661"/><pre class="programlisting">const int ARRAY_SIZE = 10;
int countNegative = 0;
for (int i = 0; i &lt; ARRAY_SIZE; i++) {
    if (vendorPayments[i] &lt; 0) countNegative++;
}</pre></div></div><div class="sect1" title="Solving Problems with Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="solving_problems_with_arrays-id1"/>Solving Problems with Arrays</h1></div></div></div><p>Once you have the common operations understood, solving an array problem is not much different than solving problems with simple data, as we did in the previous chapter. Let’s take one example and run all the way through it using the techniques of the previous chapter and any of the common operations for arrays that we might need.</p><div class="sidebar"><a id="problem_colon_finding_the_mode"/><p class="title">Problem: Finding the mode</p><p>In statistics, the mode of a set of values is the value that appears most often. Write code that processes an array of survey data, where survey takers have responded to a question with a number in the range 1–10, to determine the mode of the data set. For our purpose, if multiple modes exist, any may be chosen.</p></div><p>In this problem, we’re asked to retrieve one of the values from an array. Using the techniques of searching for analogies and starting with what we know, we might hope that we can apply some variation of the retrieval technique we have already seen: finding the largest value in an array. That code works by storing the largest value seen thus far in a variable. The code then compares each subsequent value to this variable, replacing it if necessary. The analogous method here would be to say we’d store the most frequently seen value thus far in a variable and then replace the value in the variable whenever we discovered a more common value in the array. When we say it like that, in English, it almost sounds as if it could work, but when we think about the actual code, we discover the problem. Let’s take a look at a sample array and size constant for this problem:</p><a id="I_programlisting3_d1e3675"/><pre class="programlisting">const int ARRAY_SIZE = 12;
int surveyData[ARRAY_SIZE] = {4, 7, 3, 8, 9, 7, 3, 9, 9, 3, 3, 10};</pre><p>The mode of this data is 3 because 3 appears four times, which is more often than any other value. But if we’re processing this array sequentially, as we do for the “highest value” problem, at what point do we decide that 3 is our mode? How do we know, when we have encountered the fourth and final appearance of 3 in the array, that it is indeed the fourth and final appearance? There doesn’t seem to be any way to discover this information with a single, sequential processing of the array data.</p><p>So let’s turn to one of our other techniques: simplifying the problem. What if we made things easier on ourselves by putting all occurrences of the same number together? So, for example, what if our sample array survey data looked like this:<a id="IDX-CHP-3-0048" class="indexterm"/><a id="IDX-CHP-3-0049" class="indexterm"/></p><a id="I_programlisting3_d1e3689"/><pre class="programlisting">int surveyData[ARRAY_SIZE] = {4, 7, 7, 9, 9, 9, 8, 3, 3, 3, 3, 10};</pre><p>Now both of the 7s are together, the 9s are together, and the 3s are together. With the data grouped in this manner, it seems that we should be able to sequentially process the array to find the mode. Processing the array by hand, it’s easy to count the occurrences of each value, because you just keep counting down the array until you find the first number that’s different. Converting what we can do in our head into programming statements, however, can be tricky. So before we try writing the code for this simplified problem, let’s write some <span class="emphasis"><em>pseudocode</em></span>, which is programming-like statements that are not entirely English or C++ but something in between. This will remind us what we’re trying to do with each statement we need to write.<a id="IDX-CHP-3-0050" class="indexterm"/></p><a id="I_programlisting3_d1e3699"/><pre class="programlisting">int mostFrequent = <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>?;
  int highestFrequency = <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>?;
  int currentFrequency = 0;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> for (int i = 0; i &lt; ARRAY_SIZE; i++) {
    <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>currentFrequency++;
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>if (surveyData[i] IS LAST OCCURRENCE OF A VALUE) {
         <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>if (currentFrequency &gt; highestFrequency) {
               highestFrequency = currentFrequency;
               mostFrequent = surveyData[i];
           }
         <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>currentFrequency = 0;
      }
  }</pre><p>There is no right or wrong way to write pseudocode, and if you use this technique, you should adopt your own style. When I write pseudocode, I tend to write legal C++ for any statement I’m already confident about and then spell out in English the places where I still have thinking to do. Here, we know that we will need a variable (<code class="literal">mostFrequent</code>) to hold the most frequently found value so far, which at the end of the loop will be the mode once we’ve written everything correctly. We also need a variable to store how often that value occurs (<code class="literal">highestFrequency</code>) so we have something to compare against. Finally, we need a variable we can use to count the number of occurrences of the value we’re currently tracking as we sequentially process the array (<code class="literal">currentFrequency</code>). We know we need to initialize our variables. For <code class="literal">currentFrequency</code>, it logically has to start at 0, but it’s not clear how we need to initialize the other variables yet, without the other code in place. So let’s just drop in question marks <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3758"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> to remind us to look at that again later.</p><p>The loop itself is the same array-processing loop we’ve already seen, so that’s already in final form <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3767"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Inside the loop, we increment the variable that counts the occurrences of the current value <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3773"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, and then we reach the pivotal statement. We know we need to check to see whether we’ve reached the last occurrence of a particular value <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3779"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. The pseudocode allows us to skip figuring out the logic for now and sketch out the rest of the code. If this <span class="emphasis"><em>is</em></span> the last occurrence of the value, though, we know what to do because this is like the “highest value” code: We need to see whether this value’s count is higher than the highest seen so far. If it is, this value becomes the new most frequent value <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3788"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. Then, because the next value read will be the first occurrence of a new value, we reset our counter <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3795"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>.<a id="IDX-CHP-3-0051" class="indexterm"/></p><p>Let’s return to the <code class="literal">if</code> statement logic we skipped. How do we know whether this is the last occurrence of a value in the array? Because the values in the array are grouped, we know whether a value is the last occurrence when the next value in the array is something different: in C++ terms, when <code class="literal">surveyData[i]</code> and <code class="literal">surveyData[i + 1]</code> are not equal. Furthermore, the last value in the array is also the last occurrence of some value, even though there’s not a next value. We can check for this by checking to see whether <code class="literal">i == ARRAY_SIZE - 1</code>, in which case this is the last value in the array.</p><p>With all of that figured out, let’s think about those initial values for our variables. Remember with the “highest value” array-processing code, we initialized our “highest so far” variable to the first value in the array. Here, the “most frequently seen” value is represented by two variables, <code class="literal">mostFrequent</code> for the value itself and <code class="literal">highestFrequency</code> for the number of occurrences. It would be great if we could initialize <code class="literal">mostFrequent</code> to the first value that appears in the array and <code class="literal">highestFrequency</code> to its frequency count, but there’s no way to determine the first value’s frequency until we get into the loop and start counting. At this point, it might occur to us that the first value’s frequency, whatever it is, would be greater than zero. Therefore, if we set <code class="literal">highestFrequency</code> to zero, once we reach the last occurrence of the first value, our code will replace <code class="literal">mostFrequent</code> and <code class="literal">highestFrequency</code> with the numbers for the first value anyway. The completed code looks like this:</p><a id="I_programlisting3_d1e3844"/><pre class="programlisting">int mostFrequent;
int highestFrequency = 0;
int currentFrequency = 0;
for (int i = 0; i &lt; ARRAY_SIZE; i++) {
    currentFrequency++;
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>// if (surveyData[i] IS LAST OCCURENCE OF A VALUE)
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>if (i == ARRAY_SIZE - 1 || surveyData[i] != surveyData[i + 1]) {
        if (currentFrequency &gt; highestFrequency) {
            highestFrequency = currentFrequency;
            mostFrequent = surveyData[i];
        }
        currentFrequency = 0;
    }
}</pre><p>In this book, we won’t talk much about pure style issues, such as documentation (commenting) style, but since we are using pseudocode on this problem, I want to mention a tip. I’ve noticed that the lines I leave as “plain English” in the pseudocode are the lines that benefit most from a comment in the final code, and the plain English itself makes a great comment. I’ve demonstrated that in the code here. You might forget the exact meaning behind the conditional expression in the <code class="literal">if</code> statement <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3863"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, but the comment on the preceding line <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3869"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> clears things up nicely.</p><p>As for the code itself, it does the job, but remember that it requires our survey data to be grouped. Grouping the data might be a job in itself, except—what if we <span class="emphasis"><em>sorted</em></span> the array? We don’t actually need the data to be sorted, but sorting will accomplish the grouping we need. Because we don’t intend to do any special kind of sorting, let’s just add this call to <code class="literal">qsort</code> to the beginning of our code:<a id="IDX-CHP-3-0052" class="indexterm"/></p><a id="I_programlisting3_d1e3886"/><pre class="programlisting">qsort(surveyData, ARRAY_SIZE, sizeof(int), compareFunc);</pre><p>Note that we’re using the same <code class="literal">compareFunc</code> we wrote earlier for use with <code class="literal">qsort</code>. With the sorting step in place, we have a complete solution to the original problem. So our work is done. Or is it?</p><div class="sect2" title="Refactoring"><div class="titlepage"><div><div><h2 class="title"><a id="refactoring"/>Refactoring</h2></div></div></div><p>Some programmers talk about code that gives off “bad smells.” They are talking about working code that is free of bugs but still problematic in some way. Sometimes this means code that is too complicated or has too many special cases, making the program difficult for a programmer to modify and maintain. In other cases, the code isn’t as efficient as it could be, and while it works for test cases, the programmer worries that performance will break down with larger cases. That’s my concern here. The sorting step is nearly instantaneous for our tiny test case, but what if the array is huge? Also, I know that the quicksort algorithm, which <code class="literal">qsort</code> may be using, has its lowest performance when there are lots of duplicate values in the array, and the whole point of this problem is that all of our values are in the range 1–10. I therefore propose to <span class="emphasis"><em>refactor</em></span> the code. <span class="emphasis"><em>Refactoring</em></span> means improving working code, not changing what it does but how it does it. I want a solution that is highly efficient for even huge arrays, assuming that the values are in the range of 1–10.<a id="IDX-CHP-3-0053" class="indexterm"/><a id="IDX-CHP-3-0054" class="indexterm"/></p><p>Let’s think again about the operations we know how to do with arrays. We’ve already explored several versions of the “find the highest” code. We know that applying the “find the highest” code directly to our <code class="literal">surveyData</code> array won’t produce useful results. Is there an array to which we could apply the “stock” version of “find the highest” and get the mode of the survey data? The answer is yes. The array we need is the histogram of the <code class="literal">surveyData</code> array. A histogram is a graph showing how often different values appear in an underlying dataset; our array will be the data for such a histogram. In other words, we’ll store, in a 10-element array, how often each of the values 1 through 10 appears in <code class="literal">surveyData</code>. Here’s the code to create our histogram:<a id="IDX-CHP-3-0055" class="indexterm"/></p><a id="I_programlisting3_d1e3930"/><pre class="programlisting">const int MAX_RESPONSE = 10;
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int histogram[MAX_RESPONSE];
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> for (int i = 0; i &lt; MAX_RESPONSE; i++) {
      histogram[i] = 0;
  }
<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/> for (int i = 0; i &lt; ARRAY_SIZE; i++) {
     <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>histogram[surveyData[i] - 1]++;
  }</pre><p>On the first line, we declare the array to hold our histogram data <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3958"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. You’ll note we declare the array with 10 elements, but the range of our survey responses is 1–10, and the range of subscripts for this array is 0–9. Thus, we’ll have to make adjustments, putting the count of 1s in <code class="literal">histogram[0]</code> and so on. (Some programmers would choose to declare the array with 11 elements, leaving location <code class="literal">[0]</code> unused, to allow each count to go into its natural position.) We explicitly initialize the array values to zero with a loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3970"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, and then we are ready to count the occurrences of each value in <code class="literal">surveyData</code> with another loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3980"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. The statement inside the loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3986"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> has to be read carefully; we are using the value in the current location of <code class="literal">surveyData</code> to tell us which position in <code class="literal">histogram</code> to increment. To make this clear, let’s take an example. Suppose <code class="literal">i</code> is 42. We inspect <code class="literal">surveyData[42]</code> and find (let’s say) the value 7. So we need to increment our 7 counter. We subtract 1 from 7 to get 6 because the counter for 7s is in position <code class="literal">[6]</code> in <code class="literal">histogram</code>, and <code class="literal">histogram[6]</code> is incremented.<a id="IDX-CHP-3-0056" class="indexterm"/><a id="IDX-CHP-3-0057" class="indexterm"/><a id="IDX-CHP-3-0058" class="indexterm"/><a id="IDX-CHP-3-0059" class="indexterm"/></p><p>With the histogram data in place, we can write the rest of the code. Note that the histogram code was written separately so that it could be tested separately. No time is saved by writing all of the code at once in a situation where the problem is easily separated into parts that can be individually written and tested. Having tested the above code, we now search for the largest value in the <code class="literal">histogram</code> array:</p><a id="I_programlisting3_d1e4037"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int mostFrequent = 0;
  for (int i = 1; i &lt; MAX_RESPONSE; i++) {
      if (histogram[i] &gt; <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>histogram[mostFrequent]) <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>mostFrequent = i;
  }
<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/> mostFrequent++;</pre><p>Although this is an adaptation of the “find the highest” code, there is a difference. Although we are searching for the highest value in the histogram array, ultimately, we don’t want the value itself, but the position. In other words, with our sample array, we want to know that 3 occurs more often than any other value in the survey data, but the actual number of times 3 occurs isn’t important. So <code class="literal">mostFrequent</code> will be the position of the highest value in <code class="literal">histogram</code>, not the highest value itself. Therefore, we initialize it to <code class="literal">0</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4073"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and not the value in <code class="literal">location[0]</code>. This also means that in the <code class="literal">if</code> statement, we compare against <code class="literal">histogram[mostFrequent]</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4089"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> and not <code class="literal">mostFrequent</code> itself, and we assign <code class="literal">i</code>, not <code class="literal">histogram[i]</code>, to <code class="literal">mostFrequent</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4108"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> when a larger value is found. Finally, we increment <code class="literal">mostFrequent</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4117"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. This is the reverse of what we did in the earlier loop, subtracting 1 to get the right array position. If <code class="literal">mostFrequent</code> is telling us that the highest array position is 5, for example, it means that the most frequent entry in the survey data was 6.</p><p>The histogram solution scales linearly with the number of elements in our <code class="literal">surveyData</code> array, which is as good as we could hope for. Therefore, it’s a better solution than our original approach. This doesn’t mean that the first approach was a mistake or a waste of time. It’s possible, of course, to have written this code without going through the previous version, and we can be forgiven for wishing that we had driven directly to our destination instead of taking the longer route. However, I would caution against slapping yourself on the forehead on those occasions when the first solution turns out not to be the final solution. Writing an original program (and remember this means <span class="emphasis"><em>original for the programmer writing it</em></span>) is a learning process and can’t be expected to always progress in a straight line. Also, it’s often the case that taking a longer path on one problem helps us take a shorter path on a later problem. In this particular case, note that our original solution (while it doesn’t scale well for our particular problem) could be the right solution if the survey responses weren’t strictly limited to the small range of 1–10. Or suppose that you are later asked to write code that finds the <span class="emphasis"><em>median</em></span> of a set of integer values (the median is the value in the middle, such that half of the other values in the set are higher and half of the other values are lower). The histogram approach doesn’t get you anywhere with the median, but our first approach for the mode does.<a id="IDX-CHP-3-0060" class="indexterm"/><a id="IDX-CHP-3-0061" class="indexterm"/><a id="IDX-CHP-3-0062" class="indexterm"/><a id="IDX-CHP-3-0063" class="indexterm"/><a id="IDX-CHP-3-0064" class="indexterm"/><a id="IDX-CHP-3-0065" class="indexterm"/><a id="IDX-CHP-3-0066" class="indexterm"/><a id="IDX-CHP-3-0067" class="indexterm"/></p><p>The lesson here is that a long journey is not a waste of time if you learned something from it that you wouldn’t have learned by going the short way. This is another reason why it’s helpful to methodically store all of the code that you write so that you can easily find and reuse it later. Even the code that turns out to be a “dead end” can become a valuable resource.</p></div></div><div class="sect1" title="Arrays of Fixed Data"><div class="titlepage"><div><div><h1 class="title"><a id="arrays_of_fixed_data"/>Arrays of Fixed Data</h1></div></div></div><p>In most array problems, the array is a repository for data external to the program, such as user-entered data, data on a local disk, or data from a server. To get the most out of the array tool, however, you need to recognize other situations in which an array can be used. It’s often useful to create an array where the values never change after the initialization. Such an array can allow a simple loop or even a direct array lookup to replace a whole block of control statements.</p><p>In the final code for the <a class="xref" href="ch02.html#problem_colon_decode_a_message" title="Problem: Decode a message">Problem: Decode a message</a> problem in <a class="xref" href="ch02.html#tracking_state" title="Tracking State">Tracking State</a>, we used a <code class="literal">switch</code> statement to translate the decoded input number (in the range 1–8) to the appropriate character when in “punctuation mode” because the connection between the number and the character was arbitrary. Although this worked fine, it made that section of code longer than the equivalent code for the uppercase and lowercase modes, and the code would not scale well if the number of punctuation symbols increased. We can use an array to solve this problem instead of the <code class="literal">switch</code> statement. First, we need to permanently assign the punctuation symbols to an array in the same order they appear in the coding scheme:</p><a id="I_programlisting3_d1e4191"/><pre class="programlisting">const char punctuation[8] = {'!', '?', ',', '.', ' ', ';', '"', '\''};</pre><p>Notice that this array has been declared <code class="literal">const</code> because the values inside will never change. With that declaration in place, we can replace the entire switch statement with a single assignment statement that references the array:</p><a id="I_programlisting3_d1e4198"/><pre class="programlisting">outputCharacter = punctuation[number - 1];</pre><p>Because the input number is in the range 1–8, but array elements are numbered starting from 0, we have to subtract 1 from the input number before referencing the array; this is the same adjustment we made in the histogram version of the “Finding the Mode” program. You can use the same array to go in the other direction. Suppose instead of decoding the message, we had to encode a message—that is, we were given a series of characters to convert into numbers that could be decoded using the rules of the original problem. To convert a punctuation symbol into its number, we have to locate the symbol in the array. This is a retrieval, performed using the sequential search technique. Assuming the character is to be converted and stored in the <code class="literal">char</code> variable <code class="literal">targetValue</code>, we could adapt the sequential search code as follows:</p><a id="I_programlisting3_d1e4208"/><pre class="programlisting">const int ARRAY_SIZE = 8;
int targetPos = 0;
while (punctuation[targetPos] != targetValue &amp;&amp; targetPos &lt; ARRAY_SIZE)
    targetPos++;
int punctuationCode = targetPos + 1;</pre><p>Note that just as we had to subtract 1 from <code class="literal">number</code> in the previous example to get the right array position, we have to add 1 to the array position in this example to get our punctuation code, converting from the array’s range of 0–7 to our punctuation code range of 1–8. Although this code is not as simple as a single line, it’s still much simpler than a series of <code class="literal">switch</code> statements, and it scales well. If we were to double the number of punctuation symbols in our coding scheme, it would double the number of elements in the array, but the length of the code would stay the same.</p><p>In general, then, <code class="literal">const</code> arrays can be used as lookup tables, replacing a burdensome series of control statements. Suppose you are writing a program to compute the cost of a business license in a state where the license cost varies as the gross sales figures of the business vary.</p><div class="table"><a id="business_license_costs"/><p class="title">Table 3-1. Business License Costs</p><div class="table-contents"><table summary="Business License Costs" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Business category</p></th><th style="text-align: left" valign="bottom"><p>Sales threshold</p></th><th style="text-align: left" valign="bottom"><p>License cost</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>I</p></td><td style="text-align: left" valign="top"><p>$0</p></td><td style="text-align: left" valign="top"><p>$25</p></td></tr><tr><td style="text-align: left" valign="top"><p>II</p></td><td style="text-align: left" valign="top"><p>$50,000</p></td><td style="text-align: left" valign="top"><p>$200</p></td></tr><tr><td style="text-align: left" valign="top"><p>III</p></td><td style="text-align: left" valign="top"><p>$150,000</p></td><td style="text-align: left" valign="top"><p>$1,000</p></td></tr><tr><td style="text-align: left" valign="top"><p>IV</p></td><td style="text-align: left" valign="top"><p>$500,000</p></td><td style="text-align: left" valign="top"><p>$5,000</p></td></tr></tbody></table></div></div><p>With this problem, we could use arrays both to determine the business category based on the company’s gross sales and to assign the license cost based on the business category. Suppose a <code class="literal">double</code> variable, <code class="literal">grossSales</code>, stores the gross sales of a business, and based on the sales figure, we want to assign the proper values to <code class="literal">int category</code> and <code class="literal">double cost</code>:<a id="IDX-CHP-3-0068" class="indexterm"/><a id="IDX-CHP-3-0069" class="indexterm"/><a id="IDX-CHP-3-0070" class="indexterm"/></p><a id="I_programlisting3_d1e4311"/><pre class="programlisting">const int NUM_CATEGORIES = 4;
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> const double categoryThresholds[NUM_CATEGORIES ] =
      {0.0, 50000.0, 150000.0, 500000.0};
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> const double licenseCost[NUM_CATEGORIES ] =
      {50.0, 200.0, 1000.0, 5000.0};
<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/> category = 0;
<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/> while (category &lt; NUM_CATEGORIES &amp;&amp;
      categoryThresholds[category] &lt;= grossSales) {
          category++;
      }
<img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/> cost = licenseCost[category - 1];</pre><p>This code uses two arrays of fixed values. The first array stores the gross sales threshold for each business category <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4345"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. For example, a business with $65,000 in yearly gross sales is in category II because this amount exceeds the $50,000 threshold of category II but is less than the $150,000 threshold of category III. The second array stores the cost of a business license for each category <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4351"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. With the arrays in place, we initialize <code class="literal">category</code> to 0 <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4360"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> and search through the <code class="literal">categoryThresholds</code> array, stopping when the threshold exceeds the gross sales or when we run out of categories <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4370"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. In either case, when the loop is done, <code class="literal">category</code> will be correctly assigned 1–4 based on the gross sales. The last step is to use <code class="literal">category</code> to reference the license cost from the <code class="literal">licenseCost</code> array <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4385"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. As before, we have to make a small adjustment from the 1–4 range of the business categories to the 0–3 range of our array.</p></div><div class="sect1" title="Non-scalar Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="non-scalar_arrays"/>Non-scalar Arrays</h1></div></div></div><p>So far, we’ve just worked with arrays of simple data types, such as <code class="literal">int</code> and -<code class="literal">double</code>. Often, however, programmers must deal with arrays of compound data, either structures or objects (struct or <code class="literal">class</code>). Although the use of compound data types necessarily complicates the code somewhat, it doesn’t have to complicate our thinking about array processing. Usually the array processing just involves one data member of the <code class="literal">struct</code> or <code class="literal">class</code>, and we can ignore the other parts of the data structure. Sometimes, though, the use of compound data types requires us to make some changes to our approach.</p><p>For example, consider the problem of finding the highest of a set of student grades. Suppose that instead of an array of <code class="literal">int</code>, we have an array of data structures, each representing a student’s record:</p><a id="I_programlisting3_d1e4416"/><pre class="programlisting">struct student {
    int grade;
    int studentID;
    string name;
};</pre><p>One nice thing about working with arrays is that it is easy to initialize a whole array with literal values for easy testing, even with an array of <code class="literal">struct</code>:<a id="IDX-CHP-3-0071" class="indexterm"/><a id="IDX-CHP-3-0072" class="indexterm"/><a id="IDX-CHP-3-0073" class="indexterm"/><a id="IDX-CHP-3-0074" class="indexterm"/></p><a id="I_programlisting3_d1e4441"/><pre class="programlisting">const int ARRAY_SIZE = 10;
student studentArray[ARRAY_SIZE] = {
    {87, 10001, "Fred"},
    {28, 10002, "Tom"},
    {100, 10003, "Alistair"},
    {78, 10004, "Sasha"},
    {84, 10005, "Erin"},
    {98, 10006, "Belinda"},
    {75, 10007, "Leslie"},
    {70, 10008, "Candy"},
    {81, 10009, "Aretha"},
    {68, 10010, "Veronica"}
};</pre><p>This declaration means that <code class="literal">studentArray[0]</code> has an 87 for its <code class="literal">grade</code>, 10001 for its <code class="literal">studentID</code>, and “Fred” for a <code class="literal">name</code>, and so on for the other nine elements in the array. As for the rest of the code, it could be as simple as copying the code from the beginning of this chapter, and then replacing every reference of the form <code class="literal">intArray[subscript]</code> with <code class="literal">studentArray[subscript].grade</code>. That would result in the following:</p><a id="I_programlisting3_d1e4464"/><pre class="programlisting">int highest = studentArray[0].grade;
for (int i = 1; i &lt; ARRAY_SIZE; i++) {
    if (studentArray[i].grade &gt; highest) highest = studentArray[i].grade;
}</pre><p>Suppose instead that because we now have additional information for each student, we want to find the name of the student with the best grade, not the grade itself. This would require additional modification. When our loop is over, the only statistic we have is the best grade, and that does not allow us to directly determine the student to which it belongs. We’d have to run through the array again, searching for the <code class="literal">struct</code> with the matching <code class="literal">gra</code><code class="literal">de</code>, which seems like extra work we shouldn’t have to do. To avoid this issue, we should either additionally track the name of the student that matches the current value in <code class="literal">highest</code>, or, instead of tracking the highest grade, track the location in the array where the highest grade is found, much as we did with <code class="literal">histogram</code> earlier. The latter approach is the most general because tracking the array position allows us to retrieve <span class="emphasis"><em>any</em></span> of the data for that student later:</p><a id="I_programlisting3_d1e4485"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int highPosition = 0;
  for (int i = 1; i &lt; ARRAY_SIZE; i++) {
      if (studentArray[i].grade &gt; <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>studentArray[highPosition].grade) {
          <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>highPosition = i;
      }
  }</pre><p>Here, the variable <code class="literal">highPosition</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4509"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> takes the place of <code class="literal">highest</code>. Because we aren’t directly tracking the grade closest to the average, when it’s time to compare the closest grade against the current grade, we use <code class="literal">highPosition</code> as a reference into <code class="literal">studentArray</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4525"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. If the grade in the current array position is higher, the current position in our processing loop is assigned to <code class="literal">highPosition</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4534"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Once the loop is over, we can access the name of the student with the grade closest to the average using <code class="literal">studentArray[highPosition].name</code>, and we can also access any other data related to that student record.<a id="IDX-CHP-3-0075" class="indexterm"/><a id="IDX-CHP-3-0076" class="indexterm"/><a id="IDX-CHP-3-0077" class="indexterm"/><a id="IDX-CHP-3-0078" class="indexterm"/><a id="IDX-CHP-3-0079" class="indexterm"/><a id="IDX-CHP-3-0080" class="indexterm"/></p></div><div class="sect1" title="Multidimensional Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="multidimensional_arrays"/>Multidimensional Arrays</h1></div></div></div><p>So far, we’ve only discussed one-dimensional arrays because they are the most common. Two-dimensional arrays are uncommon, and arrays with three or more dimensions are rare. That’s because most data is one-dimensional by nature. Furthermore, data that is inherently multidimensional can be represented as multiple single-dimension arrays, so using a multidimensional array is always the choice of the programmer. Consider the business license data of <a class="xref" href="ch03.html#business_license_costs" title="Table 3-1. Business License Costs">Table 3-1</a>. That’s clearly multidimensional data. I mean, look at it—it’s a grid! I represented this multidimensional data, however, as two one-dimensional arrays, <code class="literal">categoryThresholds</code> and <code class="literal">licenseCost</code>. I could have represented the data table as a two-dimensional array, like this:<a id="IDX-CHP-3-0081" class="indexterm"/><a id="IDX-CHP-3-0082" class="indexterm"/></p><a id="I_programlisting3_d1e4594"/><pre class="programlisting">const double licenseData[2][numberCategories] = {
    {0.0, 50000.0, 150000.0, 500000.0},
    {50.0, 200.0, 1000.0, 5000.0}
};</pre><p>It’s difficult to discern any advantage from combining the two arrays into one. None of our code is simplified because there is no reason to process all of the data in the table at once. What is clear, though, is that we have lowered the readability and ease of use for our table data. In the original version, the names of the two separate arrays make it clear what data is stored in each. With the combined array, we programmers will have to remember that references of the form <code class="literal">licenseData[0][]</code> refer to the gross sales thresholds of the different business categories, while references of the form <code class="literal">licenseData[1][]</code> refer to business license costs.</p><p>Sometimes it does make sense to use a multidimensional array, though. Suppose we are processing the monthly sales data for three sales agents, and one of the tasks is finding the highest monthly sales, from any agent. Having all of the data in one 3 × 12 array means we can process the entire array at once, using nested loops:</p><a id="I_programlisting3_d1e4606"/><pre class="programlisting">const int NUM_AGENTS = 3;
  const int NUM_MONTHS = 12;
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int sales[NUM_AGENTS][NUM_MONTHS] = {
      {1856, 498, 30924, 87478, 328, 2653, 387, 3754, 387587, 2873, 276, 32},
      {5865, 5456, 3983, 6464, 9957, 4785, 3875, 3838, 4959, 1122, 7766, 2534},
      {23, 55, 67, 99, 265, 376, 232, 223, 4546, 564, 4544, 3434}
  };
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> int highestSales = sales[0][0];
  for (<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>int agent = 0; agent &lt; NUM_AGENTS; agent++) {
      for (<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>int month = 0; month &lt; NUM_MONTHS; month++) {
          if (sales[agent][month] &gt; highestSales)
              highestSales = sales[agent][month];
      }
  }</pre><p>Although this is a straightforward adaptation of the basic “find the largest number” code, there are a few wrinkles. When we declare our two-dimensional array, notice that the initializer is organized by agent, that is, as 3 groups of 12, not 12 groups of 3 <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4634"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. As you’ll see in the next problem, this decision can have consequences. We initialize <code class="literal">highestSales</code> to the first element in the array, as usual <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4643"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. It may occur to you that the first time through the nested loops, both of our loop counters will be 0, so we will be comparing this initial value of <code class="literal">highestSales</code> to itself. This doesn’t affect the outcome, but sometimes novice programmers will attempt to avoid this tiny inefficiency by putting in a second <code class="literal">if</code> statement in the inner loop body:<a id="IDX-CHP-3-0083" class="indexterm"/><a id="IDX-CHP-3-0084" class="indexterm"/></p><a id="I_programlisting3_d1e4668"/><pre class="programlisting">if (agent != 0 || month != 0)
    if (sales[agent][month] &gt; highestSales)
        highestSales = sales[agent][month];</pre><p>This, however, is considerably <span class="emphasis"><em>less</em></span> efficient than the previous version because we would be performing 50 extra comparisons while avoiding only one.</p><p>Notice also that I have used meaningful names for the loop variables: <code class="literal">agent</code> for the outside loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4680"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> and <code class="literal">month</code> for the inside loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4689"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. In a single loop that processes a one-dimensional array, little is gained by a descriptive identifier. In a double loop that processes a two-dimensional array, however, the meaningful identifiers help me keep my dimensions and subscripts straight because I can look up and see that I am using <code class="literal">agent</code> in the same dimension where I used <code class="literal">numAgents</code> in the array declaration.</p><p>Even when we have a multidimensional array, sometimes the best approach is to deal with just one dimension at a time. Suppose, using the same <code class="literal">sales</code> array as the previous code, we wanted to display the highest agent monthly sales average. We could do this using a double loop, as we have previously, but the code would be clearer to read and easier to write if we treated the whole array as three individual arrays and processed them separately.</p><p>Remember the code we’ve been repeatedly using to compute the average of an array of integers? Let’s make that into a function:</p><a id="I_programlisting3_d1e4710"/><pre class="programlisting">double arrayAverage(int intArray[], int ARRAY_SIZE) {
    double sum = 0;
    for (int i = 0; i &lt; ARRAY_SIZE; i++) {
        sum += intArray[i];
    }
    double average = (sum + 0.5) / ARRAY_SIZE;
    return average;
}</pre><p>With the function in place, we can modify the basic “find the largest number” again to find the agent with the highest monthly sales average:<a id="IDX-CHP-3-0085" class="indexterm"/><a id="IDX-CHP-3-0086" class="indexterm"/></p><a id="I_programlisting3_d1e4722"/><pre class="programlisting">int highestAverage = <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>arrayAverage(sales[0], 12);
for (int agent = 1; agent &lt; NUM_AGENTS; agent++) {
    int agentAverage = <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>arrayAverage(sales[agent], 12);
    if (agentAverage &gt; highestAverage)
        highestAverage = agentAverage;
}
cout &lt;&lt; "Highest monthly average: " &lt;&lt; highestAverage &lt;&lt; "\n";</pre><p>The big new idea here is shown in the two calls to <code class="literal">arrayAverage</code>. The first parameter accepted by this function is a one-dimensional array of <code class="literal">int</code>. In the first call, we pass <code class="literal">sales[0]</code> for the first argument <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4747"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, and in the second call, we pass <code class="literal">sales[agent]</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4757"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. So in both cases, we specify a subscript for the first dimension of our two-dimensional array <code class="literal">sales</code>, but not for the second dimension. Because of the direct relationship between arrays and addresses in C++, this reference indicates the address of the first element of the specified row, which can then be used by our function as the base address of a one-dimensional array consisting of just that row.</p><p>If that sounds confusing, look again at the declaration of the <code class="literal">sales</code> array, and in particular, the initializer. The values are laid out in the initializer in the same order they will be laid out in memory when the program is executing. So <code class="literal">sales[0][0]</code>, which is 1856, will come first, followed by <code class="literal">sales[0][1]</code>, 498, and so on through the last month for the first agent, <code class="literal">sales[0][11]</code>, 32. Then the values for the second agent will begin, starting with <code class="literal">sales[1][0]</code>, 5865. Therefore, even though the array is conceptually 3 rows of 12 values, it’s laid out in memory as one big sequence of 36 values.</p><p>It’s important to note that this technique works because of the order we’ve placed the data into the array. If the array were organized along the other axis, that is, by month instead of by agent, we couldn’t do what we are doing here. The good news is that there is an easy way to make sure you have set up the array appropriately—just check the initializer. If the data you want to individually process isn’t contiguous in the array initializer, you’ve organized the data the wrong way.</p><p>The last thing to note about this code is the use of the temporary variable, <code class="literal">agentAverage</code>. Because the average monthly sales for the current agent is potentially referenced twice, once in the conditional expression of the <code class="literal">if</code> statement and then again in the assignment statement in the body, the temporary variable eliminates the possibility of calling <code class="literal">arrayAverage</code> twice for the same agent’s data.</p><p>This technique of considering a multidimensional array as an array of arrays follows directly from our core principle of breaking problems up into simpler components and in general makes multidimensional array problems a lot easier to conceptualize. Even so, you may be thinking that the technique looks a little tricky to employ, and if you’re like most new C++ programmers, you are probably a little wary of addresses and behind-the-scenes address arithmetic. The best way around those feelings, I think, is to make the separation between the dimensions even stronger, by placing one level of array inside a <code class="literal">struct</code> or <code class="literal">class</code>. Suppose we made an <code class="literal">agentStruct</code>:<a id="IDX-CHP-3-0087" class="indexterm"/></p><a id="I_programlisting3_d1e4812"/><pre class="programlisting">struct agentStruct {
    int monthlySales[12];
};</pre><p>Having gone to the trouble of making a <code class="literal">struct</code>, we might think about adding other data, like an agent identification number, but this will get the job done in terms of simplifying our thought processes. With the <code class="literal">struct</code> in place, instead of creating a two-dimensional array of sales, we create a one-dimensional array of agents:<a id="IDX-CHP-3-0088" class="indexterm"/></p><a id="I_programlisting3_d1e4828"/><pre class="programlisting">agentStruct agents[3];</pre><p>Now when we make our call to the array-averaging function, we aren’t employing a C++ specific trick; we’re just passing a one-dimensional array. For example:</p><a id="I_programlisting3_d1e4832"/><pre class="programlisting">int highestAverage = arrayAverage(agents[1].monthlySales, 12);</pre></div><div class="sect1" title="Deciding When to Use Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="deciding_when_to_use_arrays"/>Deciding When to Use Arrays</h1></div></div></div><p>An array is just a tool. As with any tool, an important part of learning <span class="emphasis"><em>how</em></span> to use an array is learning <span class="emphasis"><em>when</em></span> to use it—and when not to use it. The sample problems discussed so far assumed the use of arrays in their descriptions. In most situations, though, we won’t have this detail spelled out for us, and we must instead make our own determination on array use. The most common situations in which we must make this decision are those in which we are given aggregate data but not told how it must be stored internally. For example, in the problem where we found the mode, suppose the line that began <span class="emphasis"><em>Write code that processes an array of survey data . . .</em></span>, had read <span class="emphasis"><em>Write code that processes a collection of survey data . . .</em></span>. Now the choice of using an array or not would be ours. How would we make this decision?</p><p>Remember that we cannot change the size of an array after it has been created. If we ran out of space, our program would fail. So the first consideration is whether we will know, at the place in our program where we need an aggregate data structure, how many values we will store or at least a reliable estimate on the maximum size. This doesn’t mean we have to know the size of the array when we write the program. C++, as well as most other languages, allows us to create an array that is sized at runtime. Suppose the mode problem was modified so that we didn’t know ahead of time how many survey responses we would have, but that number came to the program as user input. Then we could dynamically declare an array to store the survey data.</p><a id="I_programlisting3_d1e4853"/><pre class="programlisting">int ARRAY_SIZE;
  cout &lt;&lt; "Number of survey responses: ";
  cin &gt;&gt; ARRAY_SIZE;
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int *surveyData = new int[ARRAY_SIZE];
  for(int i = 0; i &lt; ARRAY_SIZE; i++) {
      cout &lt;&lt; "Survey response " &lt;&lt; i + 1 &lt;&lt; ": ";
    <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>cin &gt;&gt; surveyData[i];
  }</pre><p>We declare the array using pointer notation, initializing it through an invocation of the <code class="literal">new</code> operator <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4872"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Because of the fluidity between pointer and array types in C++, the elements can then be accessed using array notation <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4878"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, even though <code class="literal">surveyData</code> is declared as a pointer. Note that because this array is dynamically allocated, at the end of the program when we no longer need the array, we have to make sure to deallocate it:<a id="IDX-CHP-3-0089" class="indexterm"/><a id="IDX-CHP-3-0090" class="indexterm"/><a id="IDX-CHP-3-0091" class="indexterm"/><a id="IDX-CHP-3-0092" class="indexterm"/><a id="IDX-CHP-3-0093" class="indexterm"/><a id="IDX-CHP-3-0094" class="indexterm"/><a id="IDX-CHP-3-0095" class="indexterm"/></p><a id="I_programlisting3_d1e4919"/><pre class="programlisting">delete[] surveyData;</pre><p>The <code class="literal">delete[]</code> operator, rather than the usual <code class="literal">delete</code> operator, is used for arrays. Although it won’t make any difference with an array of integers, if you create an array of objects, the <code class="literal">delete[]</code> operator ensures that the individual objects in the array are deleted before the array itself is deleted. So you should adopt the habit of always using <code class="literal">delete[]</code> with dynamically allocated arrays.</p><p>Having the responsibility of cleaning up dynamic memory is the bane of the C++ programmer, but if you program in the language, it is something you simply must do. Beginning programmers often shirk this responsibility because their programs are so small and execute for such short periods of time that they never see the harmful effects of memory leaks (memory that is no longer used by the program but never deallocated and therefore unavailable to the rest of the system). Don’t develop this bad habit.<a id="IDX-CHP-3-0096" class="indexterm"/></p><p>Note that we can use the dynamic array only because the user tells us the number of survey responses beforehand. Consider another variant where the user begins by entering survey responses without telling us the number of responses, indicating that there are no more responses by entering a −1 (a data entry method known as a <span class="emphasis"><em>sentinel</em></span>). Can we still use an array to solve this problem?</p><p>This is a gray area. We could still use an array if we had a guaranteed maximum number of responses. In such a case, we could declare an array of that size and assume that we are safe. We might still have concerns over the long term, though. What if the size of the survey pool increases in the future? What if we want to use the same program with a different survey taker? More generally, why build a program with a known limitation if we can avoid it?</p><p>Better, then, to use a data collection without a fixed size. As discussed earlier, the vector class from the C++ standard template library acts like an array but grows as necessary. Once declared and initialized, the vector can be processed exactly the same way as an array. We can assign a value to a vector element or retrieve a value using standard array notation. If the vector has filled its initial size and we need to add another element, we can do so using the <code class="literal">push_back</code> method. Solving the modified problem with a vector looks like this:<a id="IDX-CHP-3-0097" class="indexterm"/><a id="IDX-CHP-3-0098" class="indexterm"/><a id="IDX-CHP-3-0099" class="indexterm"/></p><a id="I_programlisting3_d1e4966"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> vector&lt;int&gt; surveyData;
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> surveyData.reserve(30);
  int surveyResponse;
  cout &lt;&lt; "Enter next survey response or −1 to end: ";
<img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/> cin &gt;&gt; surveyResponse;
  while (surveyResponse != −1) {
     <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>surveyData.push_back(surveyResponse);
      cout &lt;&lt; "Enter next survey response or −1 to end: ";
      cin &gt;&gt; surveyResponse;
  }
<img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/> int vectorSize = surveyData.size();
  const int MAX_RESPONSE = 10;
  int histogram[MAX_RESPONSE];
  for (int i = 0; i &lt; MAX_RESPONSE; i++) {
      histogram[i] = 0;
  }
  for (int i = 0; i &lt; vectorSize; i++) {
      histogram[surveyData[i] - 1]++;
  }
  int mostFrequent = 0;
  for (int i = 1; i &lt; MAX_RESPONSE; i++) {
      if (histogram[i] &gt; histogram[mostFrequent]) mostFrequent = i;
  }
  mostFrequent++;</pre><p>In this code, we first declare the vector <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e4999"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and then reserve space for 30 survey responses <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5005"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. The second step is not strictly necessary, but reserving a small amount of space that is in excess of the likely number of elements prevents the vector from resizing itself frequently as we add values to it. We read the first grade before the data entry loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5011"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, a technique we first used in the previous chapter that allows us to check each entered value before processing. In this case, we want to avoid adding the sentinel value, −1, to our vector. The survey results are added to the vector using the <code class="literal">push_back</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5020"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. After the data entry loop is completed, we retrieve the size of the vector using the <code class="literal">size</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e5030"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. We could also have counted the number of elements ourselves in the data entry loop, but since the vector is already tracking its size, this avoids duplicate effort. The rest of the code is the same as the previous version with the array and the fixed number of responses, except that we have changed the names of the variables.</p><p>All this discussion of vectors, though, overlooks an important point. If we are reading the data directly from the user, rather than being told that we are starting with an array or other data collection, we may not need an array for the survey data, only one for the histogram. Instead, we can process the survey values as we read them. We need a data structure only when we need to read in all the values before processing or need to process the values more than once. In this case, we don’t need to do either:<a id="IDX-CHP-3-0100" class="indexterm"/><a id="IDX-CHP-3-0101" class="indexterm"/></p><a id="I_programlisting3_d1e5048"/><pre class="programlisting">const int MAX_RESPONSE = 10;
int histogram[MAX_RESPONSE];
for (int i = 0; i &lt; MAX_RESPONSE; i++) {
    histogram[i] = 0;
}
int surveyResponse;
cout &lt;&lt; "Enter next survey response or −1 to end: ";
cin &gt;&gt; surveyResponse;
while (surveyResponse != −1) {
    histogram[surveyResponse - 1]++;
    cout &lt;&lt; "Enter next survey response or −1 to end: ";
    cin &gt;&gt; surveyResponse;
}
int mostFrequent = 0;
for (int i = 1; i &lt; MAX_RESPONSE; i++) {
    if (histogram[i] &gt; histogram[mostFrequent]) mostFrequent = i;
}
mostFrequent++;</pre><p>Although this code was easy to write, given the previous versions as a guide, it would have been even easier just to read the user data into an array and use the previous processing loop verbatim. The benefit to this process-as-you-go approach is efficiency. We avoid unnecessarily storing each of the survey responses, when we need to store just one response at a time. Our vector-based solution was <span class="emphasis"><em>inefficient in space</em></span>: It took more space than required without providing a corresponding benefit. Furthermore, reading all of the grades into the vector required a loop on its own, separate from the loops to process all of the survey responses and find the highest value in the histogram. That means the vector version does more work than the version above. Therefore, the vector version is also <span class="emphasis"><em>inefficient in time</em></span>: It does more work than required without providing a corresponding benefit. In some cases, different solutions offer trade-offs, and programmers must decide between space efficiency and time efficiency. In this case, however, the use of the vector makes the program inefficient all around.<a id="IDX-CHP-3-0102" class="indexterm"/><a id="IDX-CHP-3-0103" class="indexterm"/></p><p>In this book, we won’t spend a lot of time tracking down every inefficiency. Programmers must sometimes engage in <span class="emphasis"><em>performance tuning</em></span>, which is the systematic analysis and improvement of a program’s efficiency in time and space. Performance tuning a program is a lot like performance tuning a race car: an exacting job, where small adjustments can have large effects and expert knowledge of how mechanisms work “under the hood” is required. Even if we don’t have the time, desire, or knowledge to fully tune a program’s performance, though, we should still avoid decisions that lead to gross inefficiencies. Using a vector or an array unnecessarily is not like an engine with a fuel-to-air mix that is too lean; it’s like driving a bus to the beach for vacation when you could have fit everything you were taking into a Honda Civic.<a id="IDX-CHP-3-0104" class="indexterm"/><a id="IDX-CHP-3-0105" class="indexterm"/><a id="IDX-CHP-3-0106" class="indexterm"/></p><p>If we’re sure we need to process the data multiple times, and we have a good handle on the maximum size of the data set, the last criterion for deciding whether to use an array is random access. Later on, we’ll discuss alternate data structures, such as lists, which like vectors can grow as needed but unlike vectors and arrays the elements can be accessed only sequentially. That is, if we want to access the 10th element in a list, we have to run through the first 9 items to get to it. By contrast, <span class="emphasis"><em>random access</em></span> means that we can access any element in an array or vector at any time. So the last rule is that we should use an array when we need random access. If we need only sequential access, we might consider a different structure.<a id="IDX-CHP-3-0107" class="indexterm"/></p><p>You might notice that many of the programs in this chapter fail on this last criterion; we access the data sequentially, not randomly, and yet we are using an array. This leads to the great, common-sense exception to all of these rules. If an array is small, then none of the previous objections holds much weight. What constitutes “small” may vary based on the platform or application. The point is, if your program needs a collection of as few as 1 or as many as 10 items, each of which requires 10 bytes, you have to consider whether the potential waste of 90 bytes that could result from allocating an array of the maximum required size is worth searching for a better solution. Use arrays wisely, but don’t let the perfect be the enemy of the good.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id3"/>Exercises</h1></div></div></div><p>As always, I urge you to try as many exercises as you can stand.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Are you disappointed we didn’t do more with sorting? I’m here to help. To make sure you are comfortable with <code class="literal">qsort</code>, write code that uses the function to sort an array of our student <code class="literal">struct</code>. First have it sort by grade, and then try it again using the student ID.</p></li><li class="listitem"><p>Rewrite the code that finds the agent with the best monthly sales average so that it finds the agent with the highest <span class="emphasis"><em>median</em></span> sales. As stated earlier, the median of a set of values is the “one in the middle,” such that half of the other values are higher and half of the other values are lower. If there is an even number of values, the median is the simple average of the two values in the middle. For example, in the set 10, 6, 2, 14, 7, 9, the values in the middle are 7 and 9. The average of 7 and 9 is 8, so 8 is the median.</p></li><li class="listitem"><p>Write a <code class="literal">bool</code> function that is passed an array and the number of elements in that array and determines whether the data in the array is sorted. This should require only one pass!</p></li><li class="listitem"><p>Here’s a variation on the array of <code class="literal">const</code> values. Write a program for creating a substitution cipher problem. In a substitution cipher problem, all messages are made of uppercase letters and punctuation. The original message is called the plaintext, and you create the ciphertext by substituting each letter with another letter (for example, each C could become an X). For this problem, hard-code a <code class="literal">const</code> array of 26 <code class="literal">char</code> elements for the cipher, and have your program read a plaintext message and output the equivalent ciphertext.</p></li><li class="listitem"><p>Have the previous program convert the ciphertext back to the plaintext to verify the encoding and decoding.</p></li><li class="listitem"><p>To make the ciphertext problem even more challenging, have your program randomly generate the cipher array instead of a hard-coded <code class="literal">const</code> array. Effectively, this means placing a random character in each element of the array, but remember that you can’t substitute a letter for itself. So the first element can’t be A, and you can’t use the same letter for two substitutions—that is, if the first element is S, no other element can be S.</p></li><li class="listitem"><p>Write a program that is given an array of integers and determines the <span class="emphasis"><em>mode</em></span>, which is the number that appears most frequently in the array.</p></li><li class="listitem"><p>Write a program that processes an array of <code class="literal">student</code> objects and determines the grade quartiles—that is, the grade one would need to score as well as or better than 25% of the students, 50% of the students, and 75% of the students.</p></li><li class="listitem"><p>Consider this modification of the <code class="literal">sales</code> array: Because salespeople come and go throughout the year, we are now marking months prior to a sales agent’s hiring, or after a sales agent’s last month, with a −1. Rewrite your highest sales average, or highest sales median, code to compensate.</p></li></ol></div></div></div></body></html>