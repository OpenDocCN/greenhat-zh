- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing a book about IDA Pro is a challenging task. The fact that it is a complex
    piece of software with more features than can even be mentioned, let alone detailed
    in a book of reasonable size, is the least of the difficulties. New releases of
    IDA also tend to occur frequently enough that any book will almost certainly be
    one, if not two, versions behind by the time it hits the streets. Including version
    5.3, which was released just as the first edition was going to press, seven new
    versions of IDA have been released since the first edition was published. The
    release of version 6.0 with a new, Qt-based graphical user interface motivated
    me to update the book and address many of the features that have been introduced
    in the interim. Of course, true to form, another version of IDA (6.1) was released
    late in the process just to make things more exciting.
  prefs: []
  type: TYPE_NORMAL
- en: My goal with this edition remains to help others get started with IDA and perhaps
    develop an interest in reverse engineering in general. For anyone looking to get
    into the reverse engineering field, I can’t stress how important it is that you
    develop competent programming skills. Ideally, you should love code, perhaps going
    so far as to eat, sleep, and breathe code. If programming intimidates you, then
    reverse engineering is probably not for you. It is possible to argue that reverse
    engineering requires no programming at all because all you are doing is taking
    apart someone else’s program; however, without committing to developing scripts
    and plug-ins to help automate your work, you will never become a truly effective
    reverse engineer. In my case, programming and reverse engineering substitute for
    the challenge of *The New York Times* Sunday crossword puzzle, so it is rarely
    tedious.
  prefs: []
  type: TYPE_NORMAL
- en: For continuity purposes, this edition preserves the overall structure of the
    first edition while elaborating and adding material where appropriate. There are
    a number of ways to read this book. Users with little reverse engineering background
    may wish to begin with [Chapter 1](ch01.html "Chapter 1. Introduction to Disassembly")
    and [Chapter 2](ch02.html "Chapter 2. Reversing and Disassembly Tools") for some
    background information on reverse engineering and disassemblers. Users without
    much IDA experience who are looking to dive right in can begin with [Chapter 3](ch03.html
    "Chapter 3. IDA Pro Background"), which discusses the basic layout of an IDA installation,
    while [Chapter 4](ch04.html "Chapter 4. Getting Started with IDA") covers what
    goes on when you launch IDA and load a file for analysis. [Chapter 5](ch05.html
    "Chapter 5. IDA Data Displays") through [Chapter 7](ch07.html "Chapter 7. Disassembly
    Manipulation") discuss IDA’s user interface features and basic capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Readers possessing some familiarity with IDA may wish to begin with [Chapter 8](ch08.html
    "Chapter 8. Datatypes and Data Structures"), which discusses how to use IDA to
    deal with complex data structures, including C++ classes. [Chapter 9](ch09.html
    "Chapter 9. Cross-References and Graphing"), in turn, covers IDA cross-references,
    which are the foundation for IDA’s graph-based displays (also covered in [Chapter 9](ch09.html
    "Chapter 9. Cross-References and Graphing")). [Chapter 10](ch10.html "Chapter 10. The
    Many Faces of IDA") provides a bit of a diversion useful for readers interested
    in running IDA on non-Windows platforms (Linux or OS X).
  prefs: []
  type: TYPE_NORMAL
- en: More advanced IDA users may find [Chapter 11](ch11.html "Chapter 11. Customizing
    IDA") through [Chapter 14](ch14.html "Chapter 14. Patching Binaries and Other
    IDA Limitations") a good place to start, because they cover some of the fringe
    uses of IDA and its companion tools. A brief run-through of some of IDA’s configuration
    options is presented in [Chapter 11](ch11.html "Chapter 11. Customizing IDA").
    [Chapter 12](ch12.html "Chapter 12. Library Recognition Using FLIRT Signatures")
    covers IDA’s FLIRT/FLAIR technology and related tools that are used to develop
    and utilize signatures to distinguish library code from application code. [Chapter 13](ch13.html
    "Chapter 13. Extending IDA’s Knowledge") offers some insight into IDA type libraries
    and ways to extend them, while [Chapter 14](ch14.html "Chapter 14. Patching Binaries
    and Other IDA Limitations") addresses the much-asked question of whether IDA can
    be used to patch binary files.
  prefs: []
  type: TYPE_NORMAL
- en: IDA is a quite capable tool right out of the box; however, one of its greatest
    strengths is its extensibility, which users have taken advantage of to make IDA
    do some very interesting things over the years. IDA’s extensibility features are
    covered in [Chapter 15](ch15.html "Chapter 15. IDA Scripting") through [Chapter 19](ch19.html
    "Chapter 19. IDA Processor Modules"), which begin with coverage of IDA’s scripting
    features, including increased coverage of IDAPython, and follow with a systematic
    walk through IDA’s programming API, as provided by its software development kit
    (SDK). [Chapter 16](ch16.html "Chapter 16. The IDA Software Development Kit")
    provides an overview of the SDK, while [Chapter 17](ch17.html "Chapter 17. The
    IDA Plug-in Architecture") through [Chapter 19](ch19.html "Chapter 19. IDA Processor
    Modules") walk you through plug-ins, file loaders, and processor modules.
  prefs: []
  type: TYPE_NORMAL
- en: With the bulk of IDA’s capabilities covered, [Chapter 20](ch20.html "Chapter 20. Compiler
    Personalities") through [Chapter 23](ch23.html "Chapter 23. Real-World IDA Plug-ins")
    turn to more practical uses of IDA for reverse engineering by examining how compilers
    differ ([Chapter 20](ch20.html "Chapter 20. Compiler Personalities")); how IDA
    may be used to analyze obfuscated code, as is often encountered when analyzing
    malware ([Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis")); and
    how IDA may be used in the vulnerability discovery and analysis process ([Chapter 22](ch22.html
    "Chapter 22. Vulnerability Analysis")). [Chapter 23](ch23.html "Chapter 23. Real-World
    IDA Plug-ins") concludes the section by presenting some useful IDA extensions
    (plug-ins) that have been published over the years.
  prefs: []
  type: TYPE_NORMAL
- en: The book concludes with expanded coverage of IDA’s built-in debugger in [Chapter 24](ch24.html
    "Chapter 24. The IDA Debugger") through [Chapter 26](ch26.html "Chapter 26. Additional
    Debugger Features"). [Chapter 24](ch24.html "Chapter 24. The IDA Debugger") begins
    by introducing the basic features of the debugger. [Chapter 25](ch25.html "Chapter 25. Disassembler/Debugger
    Integration") discusses some of the challenges of using the debugger to examine
    obfuscated code, including the challenge of dealing with any anti-debugging feature
    that may be present. [Chapter 26](ch26.html "Chapter 26. Additional Debugger Features")
    concludes the book with a discussion of IDA’s remote debugging capabilities and
    the use of the Bochs emulator as an integrated debugging platform.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, IDA version 6.1 was the most current version available,
    and the book is written largely from a 6.1 perspective. Hex-Rays is generous enough
    to make an older version of IDA available for free; the freeware version of IDA
    is a reduced-functionality version of IDA 5.0\. While many of the IDA features
    discussed in the book apply to the freeware version as well, [Appendix A](apa.html
    "Appendix A. Using IDA Freeware 5.0") provides a brief rundown of some of the
    differences a user of the freeware version can expect to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since it is a somewhat natural progression to begin with IDA scripting
    and move on to creating compiled plug-ins, [Appendix B](apb.html "Appendix B. IDC/SDK
    Cross-Reference") provides a complete mapping of every IDC function to its corresponding
    SDK counterparts. In some cases you will find a one-to-one correspondence between
    an IDC function and an SDK function (though in all cases the names of those functions
    are different); in other cases, you will find that several SDK function calls
    are required to implement a single IDC function. The intent of [Appendix B](apb.html
    "Appendix B. IDC/SDK Cross-Reference") is to answer questions along the lines
    of “I know how to do *X* in IDC, how can I do *X* with a plug-in?” The information
    in [Appendix B](apb.html "Appendix B. IDC/SDK Cross-Reference") was obtained by
    reverse engineering the IDA kernel, which is perfectly legal under IDA’s atypical
    licensing agreement.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, I have tried to avoid long sequences of code in favor of
    short sequences that demonstrate specific points. The vast majority of sample
    code, along with many of the binary files used to generate examples, is available
    on the book’s official website, [http://www.idabook.com/](http://www.idabook.com/),
    where you will also find additional examples not included in the book as well
    as a comprehensive list of references used throughout the book (such as live links
    to all URLs referred in footnotes).
  prefs: []
  type: TYPE_NORMAL
