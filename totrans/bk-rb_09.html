<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Exception Handling"><div class="titlepage"><div><div><h1 class="title"><a id="exception_handling"/>Chapter 9. Exception Handling</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id11"/><div class="mediaobject"><a id="I_mediaobject9_d1e10534"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>Even the most carefully written program will sometimes encounter unforeseen errors. For example, if you write a program that needs to read some data from disk, it works on the assumption that the specified disk is actually available and the data is valid. If your program does calculations based on user input, it works on the assumption that the input is suitable to be used in a calculation.</p><p>Although you may try to anticipate some potential problems before they arise—for example, by writing code to check that a file exists before reading data from it or checking that user input is numerical before doing a calculation—you will never be able to predict every possible problem in advance.</p><p>The user may remove a data disk after you’ve already started reading data from it, for example; or some obscure calculation may yield 0 just before your code attempts to divide by this value. When you know that there is the possibility that your code may be “broken” by some unforeseen circumstances at runtime, you can attempt to avoid disaster by using <span class="emphasis"><em>exception handling</em></span>.<a id="IDX-CHP-9-0001" class="indexterm"/><a id="IDX-CHP-9-0002" class="indexterm"/></p><p>An <span class="emphasis"><em>exception</em></span> is an error that is packaged into an object. The object is an instance of the Exception class (or one of its descendants). You can handle exceptions by trapping the Exception object, optionally using information that it contains (to print an appropriate error message, for instance) and taking any actions needed to recover from the error—perhaps by closing any files that are still open or assigning a sensible value to a variable that may have been assigned some nonsensical value as the result of an erroneous calculation.<a id="IDX-CHP-9-0003" class="indexterm"/></p><div class="sect1" title="rescue: Execute Code When Error Occurs"><div class="titlepage"><div><div><h1 class="title"><a id="rescue_colon_execute_code_when_error_occ"/>rescue: Execute Code When Error Occurs</h1></div></div></div><p>The basic syntax of exception handling can be summarized as follows:</p><a id="I_programlisting9_d1e10569"/><pre class="programlisting">begin
   # Some code which may cause an exception
rescue &lt;Exception Class&gt;
   # Code to recover from the exception
end</pre><p>When an exception is unhandled, your program may crash, and Ruby is likely to display a relatively unfriendly error message:</p><p><span class="emphasis"><em>div_by_zero.rb</em></span></p><a id="I_programlisting9_d1e10576"/><pre class="programlisting">x = 1/0
puts( x )</pre><p>The program terminates with this error:</p><a id="I_programlisting9_d1e10580"/><pre class="programlisting">C:/bookofruby/ch9/div_by_zero.rb:3:in `/': divided by 0 (ZeroDivisionError)
 from C:/bookofruby/ch9/div_by_zero.rb:3:in `&lt;main&gt;'</pre><p>To prevent this from happening, you should handle exceptions yourself. Here is an example of an exception handler that deals with an attempt to divide by zero:</p><p><span class="emphasis"><em>exception1.rb</em></span></p><a id="I_programlisting9_d1e10587"/><pre class="programlisting">begin
   x = 1/0
rescue Exception
   x = 0
   puts( $!.class )
   puts( $! )
end
puts( x )</pre><p>When this runs, the code following <code class="literal">rescue Exception</code> executes and displays this:<a id="IDX-CHP-9-0004" class="indexterm"/><a id="IDX-CHP-9-0005" class="indexterm"/><a id="IDX-CHP-9-0006" class="indexterm"/><a id="IDX-CHP-9-0007" class="indexterm"/><a id="IDX-CHP-9-0008" class="indexterm"/></p><a id="I_programlisting9_d1e10614"/><pre class="programlisting">ZeroDivisionError
divided by 0
0</pre><p>The code between <code class="literal">begin</code> and <code class="literal">end</code> is my exception-handling block. I’ve placed the troublesome code after <code class="literal">begin</code>. When an exception occurs, it is handled in the section beginning with <code class="literal">rescue</code>. The first thing I’ve done is to set the variable <code class="literal">x</code> to a meaningful value. Next come these two inscrutable statements:</p><a id="I_programlisting9_d1e10633"/><pre class="programlisting">puts( $!.class )
puts( $! )</pre><p>In Ruby, <code class="literal">$!</code> is a global variable to which is assigned the last exception. Printing <code class="literal">$!.class</code> displays the class name, which here is ZeroDivisionError; printing the variable <code class="literal">$!</code> alone has the effect of displaying the error message contained by the Exception object, which here is “divided by 0.”<a id="IDX-CHP-9-0009" class="indexterm"/><a id="IDX-CHP-9-0010" class="indexterm"/></p><p>I am not generally keen on relying upon global variables, particularly when they have names as undescriptive as <code class="literal">$!</code>. Fortunately, there is an alternative. You can associate a variable name with the exception by placing the “assoc operator” (<code class="literal">=&gt;</code>) after the class name of the exception and before the variable name:</p><p><span class="emphasis"><em>exception2.rb</em></span></p><a id="I_programlisting9_d1e10665"/><pre class="programlisting">rescue Exception =&gt; exc</pre><p>You can now use the variable name (here <code class="literal">exc</code>) to refer to the Exception object:</p><a id="I_programlisting9_d1e10672"/><pre class="programlisting">puts( exc.class )
puts( exc )</pre><p>Although it may seem pretty obvious that when you divide by zero, you are going to get a ZeroDivisionError exception, in real-world code there may be times when the type of exception is not so predictable. Let’s suppose, for instance, that you have a method that does a division based on two values supplied by a user:</p><a id="I_programlisting9_d1e10677"/><pre class="programlisting">def calc( val1, val2 )
    return val1 / val2
end</pre><p>This could potentially produce a variety of different exceptions. Obviously, if the second value entered by the user is 0, you will get a ZeroDivisionError.</p><div class="sidebar"><a id="exceptions_have_a_family_tree"/><p class="title">Exceptions Have a Family Tree</p><p>To understand how <code class="literal">rescue</code> clauses trap exceptions, just remember that exceptions are objects, and like all other objects, they are defined by a class. There is also a clear “line of descent” that starts with the base class: Object (in Ruby 1.8) or BasicObject (Ruby 1.9). Run <span class="emphasis"><em>exception_tree.rb</em></span> to display the ancestors of an exception. This is what is displayed by Ruby 1.9:<a id="IDX-CHP-9-0011" class="indexterm"/><a id="IDX-CHP-9-0012" class="indexterm"/><a id="IDX-CHP-9-0013" class="indexterm"/></p><a id="I_programlisting9_d1e10703"/><pre class="programlisting">ZeroDivisionError
StandardError
Exception
Object
BasicObject</pre></div><p><span class="emphasis"><em>exception_tree.rb</em></span></p><p>However, if the <span class="emphasis"><em>second</em></span> value is a string, the exception will be a TypeError, whereas if the <span class="emphasis"><em>first</em></span> value is a string, it will be a NoMethodError (because the String class does not define the “division operator,” which is <code class="literal">/</code>). Here the <code class="literal">rescue</code> block handles all possible exceptions:<a id="IDX-CHP-9-0014" class="indexterm"/><a id="IDX-CHP-9-0015" class="indexterm"/></p><p><span class="emphasis"><em>multi_except.rb</em></span></p><a id="I_programlisting9_d1e10735"/><pre class="programlisting">def calc( val1, val2 )
    begin
        result = val1 / val2
    rescue Exception =&gt; e
        puts( e.class )
        puts( e )
        result = nil
    end
    return result
end</pre><p>You can test this by deliberately generating different error conditions:</p><a id="I_programlisting9_d1e10739"/><pre class="programlisting">calc( 20, 0 )
      #=&gt; ZeroDivisionError
      #=&gt; divided by 0
calc( 20, "100" )
      #=&gt; TypeError
      #=&gt; String can't be coerced into Fixnum
calc( "100", 100 )
      #=&gt; NoMethodError
      #=&gt; undefined method `/' for "100":String</pre><p>Often it will be useful to take different actions for different exceptions. You can do that by adding multiple <code class="literal">rescue</code> clauses. Each <code class="literal">rescue</code> clause can handle multiple exception types, with the exception class names separated by commas. Here my <code class="literal">calc</code> method handles TypeError and NoMethodError exceptions in one clause with a catchall Exception handler to deal with other exception types:</p><p><span class="emphasis"><em>multi_except2.rb</em></span></p><a id="I_programlisting9_d1e10756"/><pre class="programlisting">def calc( val1, val2 )
    begin
        result = val1 / val2
    rescue TypeError, NoMethodError =&gt; e
        puts( e.class )
        puts( e )
        puts( "One of the values is not a number!" )
        result = nil
    rescue Exception =&gt; e
        puts( e.class )
        puts( e )
        result = nil
    end
    return result
end</pre><p>This time, when a TypeError or NoMethodError is handled (but no other sort of error), my additional error message is displayed like this:</p><a id="I_programlisting9_d1e10760"/><pre class="programlisting">NoMethodError
undefined method `/' for "100":String
One of the values is not a number!</pre><p>When handling multiple exception types, you should always put the <code class="literal">rescue</code> clauses dealing with specific exceptions first and then follow these with <code class="literal">rescue</code> clauses dealing with more generalized exceptions.</p><p>When a specific exception such as TypeError is handled, the <code class="literal">begin..end</code> exception block exits so the flow of execution won’t “trickle down” to more generalized <code class="literal">rescue</code> clauses. However, if you put a generalized exception-handling <code class="literal">rescue</code> clause first, that will handle all exceptions, so any more specific clauses lower down will never execute.</p><p>If, for example, I had reversed the order of the <code class="literal">rescue</code> clauses in my <code class="literal">calc</code> method, placing the generalized Exception handler first, this would match all exception types so the clause for the specific TypeError and NoMethodError exceptions would never be run:</p><p><span class="emphasis"><em>multi_except_err.rb</em></span></p><a id="I_programlisting9_d1e10792"/><pre class="programlisting"># This is incorrect...
rescue Exception =&gt; e
      puts( e.class )
      result = nil
   rescue TypeError, NoMethodError =&gt; e
      puts( e.class )
      puts( e )
      puts( "Oops! This message will never be displayed!" )
      result = nil
   end
calc( 20, 0 )        #=&gt; ZeroDivisionError
calc( 20, "100" )    #=&gt; TypeError
calc( "100", 100 )   #=&gt; NoMethodError</pre></div></div>
<div class="sect1" title="ensure: Execute Code Whether or Not an Error Occurs"><div class="titlepage"><div><div><h1 class="title"><a id="ensure_colon_execute_code_whether_or_not"/>ensure: Execute Code Whether or Not an Error Occurs</h1></div></div></div><p>There may be some circumstances in which you want to take some particular action whether or not an exception occurs. For example, whenever you are dealing with some kind of unpredictable input/output—say, when working with files and directories on disk—there is always the possibility that the location (the disk or directory) or the data source (the file) either may not be there at all or may provide some other kinds of problems—such as the disk being full when you attempt to write to it or the file containing the wrong kind of data when you attempt to read from it.<a id="IDX-CHP-9-0016" class="indexterm"/></p><p>You may need to perform some final “cleanup” procedures whether or not you have encountered any problems, such as logging onto a specific working directory or closing a file that was previously opened. You can do this by following a <code class="literal">begin..rescue</code> block of code with another block starting with the <code class="literal">ensure</code> keyword. The code in the <code class="literal">ensure</code> block will always execute, whether or not an exception has arisen beforehand.<a id="IDX-CHP-9-0017" class="indexterm"/></p><p>Let’s look at two simple examples. In the first one, I try to log onto a disk and display the directory listing. At the end of this, I want to be sure that my working directory (given by <code class="literal">Dir.getwd</code>) is always restored to its original location. I do this by saving the original directory in the <code class="literal">startdir</code> variable and once again making this the working directory in the <code class="literal">ensure</code> block:<a id="IDX-CHP-9-0018" class="indexterm"/></p><p><span class="emphasis"><em>ensure.rb</em></span></p><a id="I_programlisting9_d1e10837"/><pre class="programlisting">startdir = Dir.getwd

begin
   Dir.chdir( "X:\\" )
   puts( `dir` )
rescue Exception =&gt; e
   puts e.class
   puts e
ensure
   Dir.chdir( startdir )
end</pre><p>When I run this, the following is displayed:</p><a id="I_programlisting9_d1e10841"/><pre class="programlisting">We start out here: C:/Huw/programming/bookofruby/ch9
Errno::ENOENT
No such file or directory - X:\
We end up here: C:/Huw/programming/bookofruby/ch9</pre><p>Let’s now see how to deal with the problem of reading the incorrect data from a file. This might happen if the data is corrupt, if you accidentally open the wrong file, or—quite simply—if your program code contains a bug.</p><p>Here I have a file, <span class="emphasis"><em>test.txt</em></span>, containing six lines. The first five lines are numbers; the sixth line is a string, “six.” My code opens this file and reads in all six lines:</p><p><span class="emphasis"><em>ensure2.rb</em></span><a id="IDX-CHP-9-0019" class="indexterm"/></p><a id="I_programlisting9_d1e10857"/><pre class="programlisting">f = File.new( "test.txt" )
begin
    for i in (1..6) do
        puts("line number: #{f.lineno}")
        line = f.gets.chomp
        num = line.to_i
        puts( "Line '#{line}' is converted to #{num}" )
        puts( 100 / num )
    end
rescue Exception =&gt; e
    puts( e.class )
    puts( e )
ensure
    f.close
    puts( "File closed" )
end</pre><p>The lines are read in as strings (using <code class="literal">gets</code>), and the code attempts to convert them to integers (using <code class="literal">to_i</code>). No error is produced when the conversion fails; instead, Ruby returns the value 0. The problem arises in the next line of code, which attempts a division by the converted number.</p><p>Having opened the data file at the outset, I want to ensure that the file is closed whether or not an error occurs. If, for example, I read in only the first five lines by editing the range in the <code class="literal">for</code> loop to <code class="literal">(1..5)</code>, then there would be no exception. I would still want to close the file. But it would be no good putting the file-closing code (<code class="literal">f.close</code>) in the <code class="literal">rescue</code> clause because it would not, in this case, be executed. By putting it in the <code class="literal">ensure</code> clause, however, I can be certain that the file will be closed whether or not an exception occurs.</p></div>
<div class="sect1" title="else: Execute Code When No Error Occurs"><div class="titlepage"><div><div><h1 class="title"><a id="else_colon_execute_code_when_no_error_oc"/>else: Execute Code When No Error Occurs</h1></div></div></div><p>If the <code class="literal">rescue</code> section executes when an error occurs and <code class="literal">ensure</code> executes whether or not an error occurs, how can you specifically execute some code only when an error does <span class="emphasis"><em>not</em></span> occur?</p><p>The way to do this is to add an optional <code class="literal">else</code> clause after the <code class="literal">rescue</code> section and before the <code class="literal">ensure</code> section (if there is one), like this:<a id="IDX-CHP-9-0020" class="indexterm"/><a id="IDX-CHP-9-0021" class="indexterm"/></p><a id="I_programlisting9_d1e10917"/><pre class="programlisting">begin
        # code which may cause an exception
rescue [Exception Type]
else    # optional section executes if no exception occurs
ensure  # optional exception always executes
end</pre><p>This is an example:</p><p><span class="emphasis"><em>else.rb</em></span></p><a id="I_programlisting9_d1e10924"/><pre class="programlisting">def doCalc( aNum )
   begin
      result = 100 / aNum.to_i
   rescue Exception =&gt; e     # executes when there is an error
      result = 0
      msg = "Error: " + e.to_s
   else                      # executes when there is no error
      msg = "Result = #{result}"
   ensure                    # always executes
      msg = "You entered '#{aNum}'. " + msg
   end
   return msg
end</pre><p>Try running the previous program and enter a number such as 10, which won’t cause an error, so <code class="literal">msg</code> will be assigned in the <code class="literal">else</code> clause; then try entering 0, which will cause an error, so <code class="literal">msg</code> will be assigned in the <code class="literal">rescue</code> clause. Whether or not there is an error, the <code class="literal">ensure</code> section will execute to create a <code class="literal">msg</code> string that begins with “You entered ” followed by any other messages. For example:</p><a id="I_programlisting9_d1e10947"/><pre class="programlisting">You entered '5'. Result = 20
You entered '0'. Error: divided by 0</pre></div>
<div class="sect1" title="Error Numbers"><div class="titlepage"><div><div><h1 class="title"><a id="error_numbers"/>Error Numbers</h1></div></div></div><p>If you ran the <span class="emphasis"><em>ensure.rb</em></span> program earlier and you were watching closely, you may have noticed something unusual when you tried to log onto a nonexistent drive (for example, on my system that might be the <span class="emphasis"><em>X:\</em></span> drive). Often, when an exception occurs, the exception class is an instance of a specific named type such as ZeroDivisionError or NoMethodError. In this case, however, the class of the exception is shown to be <code class="literal">Errno::ENOENT</code>.<a id="IDX-CHP-9-0022" class="indexterm"/></p><p>It turns out that there is quite a variety of <code class="literal">Errno</code> errors in Ruby. Try <span class="emphasis"><em>disk_err.rb</em></span>. This defines a method, <code class="literal">chDisk</code>, which attempts to log onto a disk identified by the character, <code class="literal">aChar</code>. So if you pass “A” as an argument to <code class="literal">chDisk</code>, it will try to log onto the <span class="emphasis"><em>A:\</em></span> drive. I’ve called the <code class="literal">chDisk</code> method three times, passing to it a different string each time:</p><p><span class="emphasis"><em>disk_err.rb</em></span></p><a id="I_programlisting9_d1e10993"/><pre class="programlisting">def chDisk( aChar )
    startdir = Dir.getwd
    begin
        Dir.chdir( "#{aChar}:\\" )
        puts( `dir` )
    rescue Exception =&gt; e
        #showFamily( e.class ) # to see ancestors, uncomment
        puts e.class           # ...and comment out this
        puts e
    ensure
        Dir.chdir( startdir )
    end
end

chDisk( "F" )
chDisk( "X" )
chDisk( "ABC" )</pre><p>You might, of course, need to edit the paths to something different on your computer. On my PC, <span class="emphasis"><em>F:\</em></span> is my DVD drive. At the moment, it is empty, and when my program tries to log onto it, Ruby returns an exception of this type: <code class="literal">Errno::EACCES</code>.<a id="IDX-CHP-9-0023" class="indexterm"/></p><p>I have no <span class="emphasis"><em>X:\</em></span> drive on my PC, and when I try to log onto that, Ruby returns an exception of this type: <code class="literal">Errno::ENOENT</code>.</p><p>In the previous example, I pass the string parameter “ABC,” which is invalid as a disk identifier, and Ruby returns an exception of this type: <code class="literal">Errno::EINVAL</code>.</p><p>Errors of this type are descendants of the SystemCallError class. You can easily verify this by uncommenting the line of code to show the class’s family where indicated in the source code of <span class="emphasis"><em>disk_err.rb</em></span>. This calls the same <code class="literal">showFamily</code> method, which you used earlier in the <span class="emphasis"><em>exception_tree.rb</em></span> program.</p><p>These Error classes, in effect, wrap up integer error values that are returned by the underlying operating system. Both the names and the values of constants may vary according to the operating system and the version of Ruby. Here <code class="literal">Errno</code> is the name of the module containing the constants, such as <code class="literal">EACCES</code> and <code class="literal">ENOENT</code>, which match the integer error values.</p><p>To see a complete list of <code class="literal">Errno</code> constants, run this:</p><p><span class="emphasis"><em>errno.rb</em></span></p><a id="I_programlisting9_d1e11052"/><pre class="programlisting">puts( Errno.constants )</pre><p>To view the corresponding numerical value of any given constant, append <code class="literal">::Errno</code> to the constant name, like this:</p><a id="I_programlisting9_d1e11059"/><pre class="programlisting">Errno::EINVAL::Errno</pre><p>You can use the following code to display a list of all <code class="literal">Errno</code> constants along with their numerical values (here the <code class="literal">eval</code> method evaluates the expression passed to it—you’ll look at how this works in <a class="xref" href="ch20.html" title="Chapter 20. Dynamic Programming">Chapter 20</a>):</p><a id="I_programlisting9_d1e11071"/><pre class="programlisting">for err in Errno.constants do
   errnum = eval( "Errno::#{err}::Errno" )
   puts( "#{err}, #{errnum}" )
end</pre></div>
<div class="sect1" title="retry: Attempt to Execute Code Again After an Error"><div class="titlepage"><div><div><h1 class="title"><a id="retry_colon_attempt_to_execute_code_agai"/>retry: Attempt to Execute Code Again After an Error</h1></div></div></div><p>If you think an error condition may be transient or may be corrected (by the user, perhaps?), you can rerun all the code in a <code class="literal">begin..end</code> block using the keyword <code class="literal">retry</code>, as in this example that prompts the user to re-enter a value if an error such as ZeroDivisionError occurs:<a id="IDX-CHP-9-0024" class="indexterm"/><a id="IDX-CHP-9-0025" class="indexterm"/><a id="IDX-CHP-9-0026" class="indexterm"/><a id="IDX-CHP-9-0027" class="indexterm"/><a id="IDX-CHP-9-0028" class="indexterm"/></p><p><span class="emphasis"><em>retry.rb</em></span></p><a id="I_programlisting9_d1e11108"/><pre class="programlisting">def doCalc
    begin
        print( "Enter a number: " )
        aNum = gets().chomp()
        result = 100 / aNum.to_i
    rescue Exception =&gt; e
        result = 0
        puts( "Error: " + e.to_s + "\nPlease try again." )
        retry           # <em class="replaceable"><code>retry on exception</code></em>
    else
        msg = "Result = #{result}"
    ensure
        msg = "You entered '#{aNum}'. " + msg
    end
    return msg
end</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>When you want to append the message from an exception object such as <code class="literal">e</code> to a string such as <code class="literal">"Error: "</code>, Ruby 1.9 insists that you explicitly convert <code class="literal">e</code> to a string ( <code class="literal">"Error: " + e.to_s</code>), whereas Ruby 1.8 does the conversion for you ( <code class="literal">"Error: " + e</code>).</p></div><p>There is, of course, the danger that the error may not be as transient as you think, so if you use <code class="literal">retry</code>, you may want to provide a clearly defined exit condition to ensure that the code stops executing after a fixed number of attempts.</p><p>You could, for example, increment a local variable in the <code class="literal">begin</code> clause. (If you do this, make sure it is incremented <span class="emphasis"><em>before</em></span> any code that is liable to generate an exception since once an exception occurs, the remainder of the code prior to the <code class="literal">rescue</code> clause will be skipped!) Then test the value of that variable in the <code class="literal">rescue</code> section, like this:</p><a id="I_programlisting9_d1e11150"/><pre class="programlisting">rescue Exception =&gt; e
    if aValue &lt; someValue then
        retry
    end</pre><p>Here is a complete example, in which I test the value of a variable named <code class="literal">tries</code> to ensure no more than three tries to run the code without error before the exception-handling block exits:</p><p><span class="emphasis"><em>retry2.rb</em></span></p><a id="I_programlisting9_d1e11160"/><pre class="programlisting">def doCalc
    tries = 0
    begin
        print( "Enter a number: " )
        tries += 1
        aNum = gets().chomp()
        result = 100 / aNum.to_i
    rescue Exception =&gt; e
        msg = "Error: " + e.to_s
        puts( msg )
        puts( "tries = #{tries}" )
        result = 0
        if tries &lt; 3 then # set a fixed number of retries
           retry
        end
    else
        msg = "Result = #{result}"
    ensure
        msg = "You entered '#{aNum}'. " + msg
    end
    return msg
end</pre><p>If the user were to enter 0 three times in a row, this would be the output:</p><a id="I_programlisting9_d1e11165"/><pre class="programlisting">Enter a number: 0
Error: divided by 0
tries = 1
Enter a number: 0
Error: divided by 0
tries = 2
Enter a number: 0
Error: divided by 0
tries = 3
You entered '0'. Error: divided by 0</pre></div>
<div class="sect1" title="raise: Reactivate a Handled Error"><div class="titlepage"><div><div><h1 class="title"><a id="raise_colon_reactivate_a_handled_error"/>raise: Reactivate a Handled Error</h1></div></div></div><p>Sometimes you may want to keep an exception “alive” even after it has been trapped in an exception-handling block. You can do this, for example, to defer the handling of the exception, say by passing it on to some other method. You can do this using the <code class="literal">raise</code> method. You need to be aware, however, that, once raised, an exception needs to be rehandled; otherwise, it may cause your program to crash. Here is a simple example of raising a ZeroDivisionError exception and passing on the exception to a method called, in this case, <code class="literal">handleError</code>:<a id="IDX-CHP-9-0029" class="indexterm"/><a id="IDX-CHP-9-0030" class="indexterm"/></p><p><span class="emphasis"><em>raise.rb</em></span></p><a id="I_programlisting9_d1e11190"/><pre class="programlisting">begin
    divbyzero
rescue Exception =&gt; e
    puts( "A problem just occurred. Please wait..." )
    x = 0
    begin
        raise
    rescue
        handleError( e )
    end
end</pre><p>Here <code class="literal">divbyzero</code> is the name of a method in which the divide-by-zero operation takes place, and <code class="literal">handleError</code> is a method that prints more detailed information on the exception:<a id="IDX-CHP-9-0031" class="indexterm"/><a id="IDX-CHP-9-0032" class="indexterm"/></p><a id="I_programlisting9_d1e11208"/><pre class="programlisting">def handleError( e )
    puts( "Error of type: #{e.class}" )
    puts( e )
    puts( "Here is a backtrace: " )
    puts( e.backtrace )
end</pre><p>Notice that this uses the <code class="literal">backtrace</code> method, which displays an array of strings showing the filenames and line numbers where the error occurred and, in this case, the line that called the error-producing <code class="literal">divbyzero</code> method. This is an example of this program’s output:<a id="IDX-CHP-9-0033" class="indexterm"/><a id="IDX-CHP-9-0034" class="indexterm"/></p><a id="I_programlisting9_d1e11226"/><pre class="programlisting">A problem just occurred. Please wait...
Error of type: ZeroDivisionError
divided by 0
Here is a backtrace:
C:/Huw/programming/bookofruby/ch9/raise.rb:11:in `/'
C:/Huw/programming/bookofruby/ch9/raise.rb:11:in `divbyzero'
C:/Huw/programming/bookofruby/ch9/raise.rb:15:in `&lt;main&gt;'</pre><p>You can also specifically raise your exceptions to force an error condition even when the program code has not caused an exception. Calling <code class="literal">raise</code> on its own raises an exception of the type RuntimeError (or whatever exception is in the global variable <code class="literal">$!</code>):<a id="IDX-CHP-9-0035" class="indexterm"/></p><a id="I_programlisting9_d1e11241"/><pre class="programlisting">raise         # raises RuntimeError</pre><p>By default, this will have no descriptive message associated with it. You can add a message as a parameter, like this:</p><a id="I_programlisting9_d1e11246"/><pre class="programlisting">raise "An unknown exception just occurred!"</pre><p>You can raise a specific type of error:</p><a id="I_programlisting9_d1e11250"/><pre class="programlisting">raise ZeroDivisionError</pre><p>You can also create an object of a specific exception type and initialize it with a custom message:</p><a id="I_programlisting9_d1e11254"/><pre class="programlisting">raise ZeroDivisionError.new( "I'm afraid you divided by Zero" )</pre><p>This is a simple example:<a id="IDX-CHP-9-0036" class="indexterm"/></p><p><span class="emphasis"><em>raise2.rb</em></span></p><a id="I_programlisting9_d1e11266"/><pre class="programlisting">begin
    raise ZeroDivisionError.new( "I'm afraid you divided by Zero" )
rescue Exception =&gt; e
    puts( e.class )
    puts( "message: " + e.to_s )
end</pre><p>This outputs the following:</p><a id="I_programlisting9_d1e11270"/><pre class="programlisting">ZeroDivisionError
message: I'm afraid you divided by Zero</pre><p>If the standard exception types don’t meet your requirements, you can, of course, create new ones just by subclassing existing exceptions. Provide your classes with a <code class="literal">to_str</code> method in order to give them a default message.<a id="IDX-CHP-9-0037" class="indexterm"/></p><p><span class="emphasis"><em>raise3.rb</em></span></p><a id="I_programlisting9_d1e11286"/><pre class="programlisting">class NoNameError &lt; Exception
    def to_str
        "No Name given!"
    end
end</pre><p>Here is an example of how you might raise a custom exception:</p><a id="I_programlisting9_d1e11290"/><pre class="programlisting">def sayHello( aName )
    begin
        if (aName == "") or (aName == nil) then
             raise NoNameError
        end
    rescue Exception =&gt; e
        puts( e.class )
        puts( "error message: " + e.to_s )
        puts( e.backtrace )
    else
        puts( "Hello #{aName}" )
    end
end</pre><p>If you now enter <code class="literal">sayHello( nil )</code>, this would be the output:</p><a id="I_programlisting9_d1e11297"/><pre class="programlisting">NoNameError
error message: NoNameError
C:/Huw/programming/bookofruby/ch9/raise3.rb:12:in `sayHello'
C:/Huw/programming/bookofruby/ch9/raise3.rb:23:in `&lt;main&gt;'</pre><div class="sidebar"><a id="digging_deeper-id8"/><p class="title">Digging Deeper</p><p>When trapping exceptions, the <code class="literal">begin</code> keyword may, in some circumstances, be omitted. Here you will learn about this syntax. I will also clarify some potential confusion about <code class="literal">catch</code> and <code class="literal">throw</code>.<a id="IDX-CHP-9-0038" class="indexterm"/><a id="IDX-CHP-9-0039" class="indexterm"/><a id="IDX-CHP-9-0040" class="indexterm"/><a id="IDX-CHP-9-0041" class="indexterm"/><a id="IDX-CHP-9-0042" class="indexterm"/><a id="IDX-CHP-9-0043" class="indexterm"/><a id="IDX-CHP-9-0044" class="indexterm"/></p><p><span class="bolditalic">Omitting begin and end</span></p><p>You can optionally omit <code class="literal">begin</code> and <code class="literal">end</code> when trapping exceptions inside a method, a class, or a module. For example, all the following are legal:</p><p><span class="emphasis"><em>omit_begin_end.rb</em></span></p><a id="I_programlisting9_d1e11357"/><pre class="programlisting">def calc
        result = 1/0
    rescue Exception =&gt; e
        puts( e.class )
        puts( e )
        result = nil
    return result
end

class X
        @@x = 1/0
    rescue Exception =&gt; e
        puts( e.class )
        puts( e )
end

module Y
        @@x = 1/0
    rescue Exception =&gt; e
        puts( e.class )
        puts( e )
end</pre><p>In all the previous cases, the exception-handling will also work if you place the <code class="literal">begin</code> and <code class="literal">end</code> keywords at the start and end of the exception-handling code in the usual way.</p><p><span class="bolditalic">catch..throw</span></p><p>In some languages, exceptions are trapped using the keyword <code class="literal">catch</code> and may be raised using the keyword <code class="literal">throw</code>. Although Ruby provides <code class="literal">catch</code> and <code class="literal">throw</code> methods, these are not directly related to its exception handling. Instead, <code class="literal">catch</code> and <code class="literal">throw</code> are used to break out of a defined block of code when some condition is met. You could, of course, use <code class="literal">catch</code> and <code class="literal">throw</code> to break out of a block of code when an exception occurs (though this may not be the most elegant way of handling errors). For example, this code will exit the block delimited by curly brackets if a ZeroDivisionError occurs:</p><p><span class="emphasis"><em>catch_except.rb</em></span></p><a id="I_programlisting9_d1e11400"/><pre class="programlisting">catch( :finished) {
   print( 'Enter a number: ' )
   num = gets().chomp.to_i
   begin
      result = 100 / num
   rescue Exception =&gt; e
      throw :finished        # jump to end of block
   end
   puts( "The result of that calculation is #{result}" )
}     # end of :finished catch block</pre><p>See <a class="xref" href="ch06.html" title="Chapter 6. Conditional Statements">Chapter 6</a> for more on <code class="literal">catch</code> and <code class="literal">throw</code>.</p></div></div></body></html>