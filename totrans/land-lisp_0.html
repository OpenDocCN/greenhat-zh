<html><head></head><body><div class="preface" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="introduction"/>Introduction</h1></div></div></div><p>So, you’ve decided to pick up a book on Lisp and read the introduction. Perhaps you were surprised to see something that looks like a comic book mixed in with the other computer programming books on the shelf. Who would bother writing a comic book about a weird academic programming language like Lisp? Or maybe you’ve heard other people raving about the Lisp language and thought, “Boy, Lisp sure sounds different from other languages people talk about. Maybe I should pick up a Lisp book sometime.” Either way, you’re now holding a book about a programming language that is very cool but also very unusual.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e152"/><img src="httpatomoreillycomsourcenostarchimages703101.png" alt="image with no caption"/></div></div><div class="sect1" title="What Makes Lisp So Cool and Unusual?"><div class="titlepage"><div><div><h1 class="title"><a id="what_makes_lisp_so_cool_and_unusual_ques"/>What Makes Lisp So Cool and Unusual?</h1></div></div></div><p>Lisp is a very <span class="emphasis"><em>expressive</em></span> language. Lisp is designed to let you take the most complicated programming ideas and express them in a clear and appropriate way. Lispers have the freedom to write a program in exactly the way that is most helpful for solving any problem at hand.<a id="IDX-PREFACE-0002" class="indexterm"/></p><p>The power at your fingertips when writing Lisp code is what makes it so different. Once you “get” Lisp, you’ll be forever changed as a programmer. Even if you end up never writing Lisp code again for the rest of your life, learning Lisp will fundamentally change you as a coder.<a id="IDX-PREFACE-0003" class="indexterm"/></p><p>In a way, learning a typical programming language is similar to learning a foreign language as an adult. Suppose you go out tomorrow and decide you’re going to learn French. You may take every course on French that you can find, read materials that are only in French, and even move to France. But no matter what you do, your understanding of French will always remain a little imperfect. And no matter how good of a French speaker you eventually become, in your dreams you probably will still be speaking in your native language.</p><p>Lisp is different. It’s not just like learning any foreign language. Once you’ve learned Lisp, you’ll even dream in Lisp. Lisp is such a powerful idea that it will crowd out your previous programming experience and become your new mother tongue! Whenever you encounter a new programming idea in any language, you’ll always say to yourself, “That’s kind of how I’d do it in Lisp, except . . . .” That’s the kind of power only Lisp will give you.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e182"/><img src="httpatomoreillycomsourcenostarchimages703103.png.jpg" alt="image with no caption"/></div></div><p>At this point, all you may know about Lisp is that at least one person (me) is extremely excited about it. But your time is valuable, and learning something new is bound to require some effort.<a id="IDX-PREFACE-0004" class="indexterm"/><a id="IDX-PREFACE-0005" class="indexterm"/><a id="IDX-PREFACE-0006" class="indexterm"/></p><p>The good news is Lisp isn’t really as difficult as it may seem at first glance. For instance, the following is a valid Lisp expression:</p><a id="I_programlisting_d1e202"/><pre class="programlisting">(+ 3 (* 2 4))</pre><p>Can you guess what the value of this expression is? If you answered 11, then you’ve already figured out how to read basic Lisp code. It is written just like math, except that the functions—in this case, addition and multiplication—come before the numbers, and everything is in parentheses.</p></div></div>
<div class="sect1" title="If Lisp Is So Great, Why Don't More People Use It?"><div class="titlepage"><div><div><h1 class="title"><a id="if_lisp_is_so_great_comma_why_don_apostr"/>If Lisp Is So Great, Why Don't More People Use It?</h1></div></div></div><p>Actually, a fair number of large companies <span class="emphasis"><em>do</em></span> use Lisp for some serious work (you’ll find a long list of industrial Lisp projects at <a class="ulink" href="http://snipurl.com/e3lv9/">http://snipurl.com/e3lv9/</a>). Other programming languages are constantly “borrowing” features of Lisp and presenting them as the latest and greatest ideas. Also, the Semantic Web, which many believe will play a big role in the future of the Web, uses many tools written in Lisp.<a id="IDX-PREFACE-0007" class="indexterm"/><a id="IDX-PREFACE-0008" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The idea behind the Semantic Web is to create a set of protocols for websites to follow so that a computer can determine the “meaning” of information on a web page. This is done by annotating web pages with special metadata (usually in a format called Resource Description Framework, or RDF) that links to common vocabularies, which different websites may share. Many of the tools used for working with description logics and RDF data are written in Lisp (for example, RacerPro and AllegroGraph).</p></div><p>So, Lisp certainly has a promising future. But some may think that learning Lisp is not worth the effort.<a id="IDX-PREFACE-0009" class="indexterm"/><a id="IDX-PREFACE-0010" class="indexterm"/></p><p>How did Lisp get this undeserved reputation?</p><p>I think that people use a rule of thumb when deciding what things in life are worth learning. Most people seek knowledge in one of the following three categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>What many other people learn (calculus, C++, and so on)</p></li><li class="listitem"><p>What is easy to learn (hula-hooping, Ruby, and so on)</p></li><li class="listitem"><p>What has value that is easy to appreciate (thermonuclear physics, for example, or that ridiculously loud whistle where you stick your fingers in your mouth)</p></li></ul></div><p>Lisp doesn’t fall into any of these categories. It’s not as popular as calculus, particularly easy to learn, or as obviously valuable as that loud whistle. If we were to follow these (usually very sensible) rules of thumb, we would conclude that a reasonable person should stay away from Lisp. However, in the case of Lisp, we’re going to throw out these rules. As you’ll see from reading this book, Lisp gives you insights into computer programming that are so profound that every serious programmer should have some experience with this unusual language, even if it requires a little effort.</p><p>If you’re still not convinced, you might want to take a peek at the comic book epilogue way at the end of the book. You might not be able to understand everything in there right now, but it will give you a feel for the advanced features available within Lisp and what makes Lisp programming different from other types of programming.<a id="IDX-PREFACE-0011" class="indexterm"/></p></div>
<div class="sect1" title="Where Did Lisp Come From?"><div class="titlepage"><div><div><h1 class="title"><a id="where_did_lisp_come_from_question"/>Where Did Lisp Come From?</h1></div></div></div><p>The Lisp family of languages is truly ancient, with a history that differs from other languages. We’ll need to travel far back in time to get to the beginning of it all.</p><p>A long time ago (way back in the 1940s), the Earth was covered by a giant ocean called the Panthalassic Ocean, along with a single barren land mass named Pangaea. In this unforgiving environment, the first computer programs evolved, written in pure machine language (or “ones and zeros,” as they say).<a id="IDX-PREFACE-0012" class="indexterm"/></p><p>These protolanguages were tightly bound to specific computer systems, such as the ENIAC, the Zuse Z3, and other early vacuum-tube contraptions. Often, these early computers were so primitive that “programming” them involved simply flipping switches or patching cables to physically encode each operation.</p><p>The dark days of these protolanguages saw a lot of experimentation with different computer architectures and an explosion of different computer instruction sets. Competition was fierce. While most of these primitive language experiments ultimately disappeared—victims of ancient battles for survival—others thrived.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e273"/><img src="httpatomoreillycomsourcenostarchimages703105.png.jpg" alt="image with no caption"/></div></div><p>At a certain point, computers acquired their own in memory to store programs, along with primitive <span class="emphasis"><em>assemblers</em></span> that allowed programs to be written in text, instead of with just pure numbers. These <span class="emphasis"><em>assembly</em></span> languages included Short Code, ARC assembly, and EDSAC Initial Orders.<a id="IDX-PREFACE-0013" class="indexterm"/><a id="IDX-PREFACE-0014" class="indexterm"/><a id="IDX-PREFACE-0015" class="indexterm"/><a id="IDX-PREFACE-0016" class="indexterm"/><a id="IDX-PREFACE-0017" class="indexterm"/><a id="IDX-PREFACE-0018" class="indexterm"/></p><p>Assembly languages made software development much more efficient, enabling ancient assemblers to evade the many predators in this primordial ocean. But assembly languages still had significant limitations. They were always designed around the instruction set of a specific processor and so they were not portable across different machine architectures. Programming languages needed to evolve to survive beyond the confines of a specific machine instruction set.<a id="IDX-PREFACE-0019" class="indexterm"/></p><p>The 1950s saw the arrival of the first machine-independent programming languages. Languages like Autocode and Information Processing Language accomplished this independence not only through lungs and legs, but also through new types of software, such as compilers and interpreters.<a id="IDX-PREFACE-0020" class="indexterm"/><a id="IDX-PREFACE-0021" class="indexterm"/><a id="IDX-PREFACE-0022" class="indexterm"/><a id="IDX-PREFACE-0023" class="indexterm"/></p><p>With compilers and interpreters, computer programs could now be written in a human-friendly syntax. A <span class="emphasis"><em>compiler</em></span> can take a human-written computer program and convert it automatically into a machine-friendly binary format that the computer can execute. An <span class="emphasis"><em>interpreter</em></span>, on the other hand, performs the actions described in a human-written program directly, without converting them all the way down to a machine-friendly binary format.</p><p>For the first time, programmers could use languages that were designed to make computer programming a pleasant activity, without needing to operate at the primitive level of the computer hardware. These interpreted and compiled programming languages are what we now think of as the first “true” programming languages. One of the most imposing of these early languages, FORTRAN (developed in 1957), was widely supported on different architectures and is still used heavily to this day.<a id="IDX-PREFACE-0024" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e338"/><img src="httpatomoreillycomsourcenostarchimages703107.png.jpg" alt="image with no caption"/></div></div><p>Up until this point, the most successful languages had been designed around one central idea: to offer a general design and syntax that would make programming as easy as possible for novices. However, designing a good programming language turns out to be very difficult. Hence, most of these languages, like FORTRAN, BASIC, and C, were really just a mishmash of older ideas, copied from one another and thrown together in a way that lacked any real beauty. They were usually easy to use in only superficial ways. Nonetheless, these fierce languages roamed the jungles for decades in search of easy prey.<a id="IDX-PREFACE-0025" class="indexterm"/><a id="IDX-PREFACE-0026" class="indexterm"/></p><p>In the shadows of these fearsome beasts lurked a small, humble, and entirely different sort of creature—mostly hidden from view, but present almost since the very first machine-independent languages crawled onto land. These were languages that used mathematical syntax, such as the lambda calculus, developed by mathematicians in the 1930s.<a id="IDX-PREFACE-0027" class="indexterm"/></p><p>Not the least bit concerned with being pragmatic or easy for novices to learn, these languages were highly intelligent and wanted to push the limits of language design. They posed questions about program notation, language semantics, and the simplest possible language syntax.</p><p>From these highly intelligent mathematical syntaxes evolved one most notable creature: the original Lisp programming language. Unlike most other programming languages, it did not evolve from FORTRAN or other languages that were concerned with pragmatism or ease of use. Its lineage is a completely separate one, drawn straight from mathematics. But where did Lisp come from?</p><p>Some people claim that the story behind Lisp’s origins has been forever lost in the fog of time. Others (who are probably more correct) say Lisp’s creation was the work of John McCarthy in 1959. One day, it is said, he gathered together his tribe at MIT and presented an ingenious idea. McCarthy envisioned a completely theoretical programming language, which would have minimal syntax and semantics but, at the same time, create incredibly elegant programs. These programs were so elegant that even writing an interpreter for Lisp in Lisp itself would take only around 50 lines of computer code!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e363"/><img src="httpatomoreillycomsourcenostarchimages703109.png.jpg" alt="image with no caption"/></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>John McCarthy published the paper “Recursive Functions of Symbolic Expressions and Their Computation by Machine, <a class="xref" href="pt01.html" title="Part I. Lisp is Power">Part I</a>,” Communications of the ACM (April 1960): 184-195. You can read it at <a class="ulink" href="http://www-formal.stanford.edu/jmc/recursive.pdf">http://www-formal.stanford.edu/jmc/recursive.pdf</a>.<a id="IDX-PREFACE-0028" class="indexterm"/></p></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e381"/><img src="httpatomoreillycomsourcenostarchimages703111.png" alt="image with no caption"/></div></div><p>When McCarthy first published his idea, it was intended only as an intellectual exploration of mathematical syntax. But soon, the Lisp language evolved and could work with compilers and interpreters. It now ran on real computers, just like FORTRAN and the other programming languages! But unlike these other languages, Lisp retained a beauty derived from its mathematical ancestry.</p><p>Soon after the first Lisps appeared, the first Lisp programmers appeared, capturing these docile creatures and transforming them into ever-more-refined programming languages. Over time, these programmers turned the primal Lisps into dialects such as MACLISP and Interlisp.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e392"/><img src="httpatomoreillycomsourcenostarchimages703113.png" alt="image with no caption"/></div></div><p>Although the hunting of early Lisps was a successful avocation for early Lisp programmers, it soon became clear that these hunters had a competitor: Cro-Magnon man. The Cro-Magnons were more aggressive than the peaceful Lisp programmers, attacking ever-bigger software development projects using fearsome languages such as COBOL. Developed for business applications, COBOL was an ugly and vile behemoth that nonetheless made lucrative prey for the Cro-Magnons. Lisp programmers, on the other hand, were more content contemplating elegant programming and hunting the occasional Lisp.<a id="IDX-PREFACE-0029" class="indexterm"/><a id="IDX-PREFACE-0030" class="indexterm"/><a id="IDX-PREFACE-0031" class="indexterm"/><a id="IDX-PREFACE-0032" class="indexterm"/><a id="IDX-PREFACE-0033" class="indexterm"/><a id="IDX-PREFACE-0034" class="indexterm"/></p><p>Now, while Lisp was an incredibly powerful idea, other programming languages already had a head start in mind share and more mature development tools. This made it a challenge for Lisps, and the Lisp programmers dependent on them, to get the traction they needed for mainstream success. However, the gentle Lispers were not concerned with such petty things. Despite their differing dispositions, the Lispers and the Cro-Magnons lived side by side in relative harmony.</p><p>In their own way, the Lispers were thriving. At that time, they benefited heavily from highly academic research in areas such as image recognition, computerized data classification, and other problems that fall under the general umbrella of <span class="emphasis"><em>artificial intelligence (AI)</em></span>. The highly mathematical nature of these problems lent their investigation to a Lispy approach, and Lisp programmers built new dialects of Lisp into ever-more-advanced computer systems to attack them. Many consider this the Golden Age of Lisp.<a id="IDX-PREFACE-0035" class="indexterm"/><a id="IDX-PREFACE-0036" class="indexterm"/></p><p>Unfortunately, after this brief golden period, the winds unexpectedly turned on the poor Lispers. In the mid-1980s, a sudden tilt in the axis of the Earth altered the climate, causing shortages in the food sources that the Lisp languages needed to survive. Disappointments in the progress of AI research caused many grants for academic research to dry up, and much of the hardware favored by the Lisps (such as Lisp machines from Symbolics, Lisp Machine, Inc., and Texas Instruments) fell behind the capabilities of more traditional complex instruction set computer (CISC) and reduced instruction set computer (RISC) hardware architectures. The world had become an unwelcoming place for Lisps and the Lisp programmers that depended on them for survival. The “AI winter” had arrived, and Lisp was doomed.<a id="IDX-PREFACE-0037" class="indexterm"/><a id="IDX-PREFACE-0038" class="indexterm"/><a id="IDX-PREFACE-0039" class="indexterm"/></p><p>This finally gave the Cro-Magnons the definite advantage in the language race. The new craze of megalithic, FORTRAN-derived, object-oriented languages—such as C++, developed in 1983—had slowly conquered commercial software development. This gave the Cro-Magnons complete immunity from the AI winter, which was afflicting the Lispers. Furthermore, the wily Cro-Magnons borrowed some of the ideas pioneered by the Lispers to patch up the problems of mainstream languages. Thus, garbage collection and parametric polymorphism, originally found in the Lisps, became common in the languages used by mainstream programmers.<a id="IDX-PREFACE-0040" class="indexterm"/><a id="IDX-PREFACE-0041" class="indexterm"/></p><p>Eventually, through immense effort, the language behemoths of olden days had been tamed by the Cro-Magnons into C#, Java, and similar languages. The belief arose that these languages were more pleasant to use as tools than anything available in the past, with the Golden Age of Lisp long forgotten. More recently, languages such as Python and Ruby have further refined these Cro-Magnon languages into more modern directions.<a id="IDX-PREFACE-0042" class="indexterm"/><a id="IDX-PREFACE-0043" class="indexterm"/></p><p>But what has happened to the Lisp programmers during all this time? Have they completely succumbed to the AI winter? Are they once again lurking in the shadows, waiting for another day in the sun? No one knows for sure. But if you look hard enough, maybe in the highest mountains, in the deepest jungles, or on the lowest basement levels of MIT, you may catch a glimpse of an odd sort of creature. Some call it the Windigo; others refer to it as a yeti, Sasquatch, or rms. But those who really know think it just might be—that it could only be—a Lisp programmer.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e460"/><img src="httpatomoreillycomsourcenostarchimages703115.png.jpg" alt="image with no caption"/></div></div></div>
<div class="sect1" title="Where Does Lisp Get Its Power?"><div class="titlepage"><div><div><h1 class="title"><a id="where_does_lisp_get_its_power_question"/>Where Does Lisp Get Its Power?</h1></div></div></div><p>I’ve said that Lisp is a particularly powerful language. So what were the key insights that John McCarthy (and the other, later innovators of Lisp) had that made this power possible?<a id="IDX-PREFACE-0044" class="indexterm"/><a id="IDX-PREFACE-0045" class="indexterm"/><a id="IDX-PREFACE-0046" class="indexterm"/></p><p>To make a programming language powerful, you need to make it expressive. Having an expressive language means that you can do a lot of stuff with very little actual code. But what traits does a language need to make this possible? I think there are two that are most important.<a id="IDX-PREFACE-0047" class="indexterm"/></p><p>One trait is a lot of features built into the language. That way, for most things you need to get done, someone has already performed some of the work for you, and you can leverage that work to make your own code look pithy. Many modern languages have this trait. The Java language, for instance, is renowned for powerful libraries that, for example, let you acquire data from another PC over a socket with ease.<a id="IDX-PREFACE-0048" class="indexterm"/></p><p>The second trait that gives a language power is letting you muck around inside it as deeply as possible to make it do your bidding. That way, even if the designers of the language never conceived of what you’re trying to do, you can make your own changes to the language until it does exactly what you need to solve your problems elegantly. This trait is much more difficult to provide in a language. Suppose you wanted to add something like nested function definition support to Java. If you know Java well, thinking about how to add such support is in the realm of nightmares.</p><p>The reason most languages aren’t good at supporting both of these traits simultaneously is that they conflict with each other. The richer a language is at the start, the more complicated it is. And the more complicated the language, the more painful it is to muck with that language. That’s why making your own changes to the most mature programming languages is close to impossible.</p><p>Of course, if you try hard enough, you can always make fundamental changes to any language. For instance, when C++ was developed, it originally took the form of a C preprocessor. A special C program was written that could take code written in the new C++ dialect and convert it into plain-old C, which you could then just run through a standard C compiler. This is how Bjarne Stroustrup, the inventor of C++, was able to tweak the C language and add features to turn it into his own. However, writing a translator such as this is an extremely difficult and tedious process that you would consider only as a last resort.</p><p>In contrast, Lisp languages make it extremely easy for an experienced Lisper to alter the compiler/interpreter that runs a program, while still supporting rich language features with extensive libraries. In fact, messing around with the language within Lisp is easier than in any other language ever created!</p><p>For example, writing a function in Lisp to calculate the distance between two points would be simple, as in most other languages. But an experienced Lisper would find it equally easy to invent a new way to nest function definitions or devise a funky if-then command. Even writing your own object-oriented programming support inside Lisp is not complicated (and most Lispers have probably done so at some point). In Lisp, everyone gets to be a mini-Stroustrup!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e502"/><img src="httpatomoreillycomsourcenostarchimages703117.png.jpg" alt="image with no caption"/></div></div><p>How does Lisp make this neat feat possible? One of Lisp’s core characteristics is that writing a Lisp directly in Lisp is, itself, unbelievably simple. It turns out that <span class="emphasis"><em>this is the key property</em></span> that allows Lisp to break the paradox of the two traits. By starting out as a language that could perform a cool mathematical trick of elegantly writing itself, it ended up possessing the very property needed to be both feature-rich <span class="emphasis"><em>and</em></span> tweakable. That, in turn, makes it the perfect tool for actually writing just about any kind of program at all!</p><p>Think of it this way: Give a programmer a <code class="literal">fish</code> command in his programming language, and he will eat Chinese takeout and drink Jolt for a day. Give a programmer a programming language that allows him to write his own <code class="literal">fish</code> command, and he’ll eat Chinese takeout and drink Jolt for a lifetime (which, admittedly, would probably be cut short by nutritional deficiencies, and let’s not even discuss the probable heart arrhythmias).</p><p>So, now you have an idea of why Lisp is a very cool and very unusual programming language. It has a long and atypical history compared with most programming languages. Most languages came from the world of engineering, whereas Lisp originated from a more mathematical background. It has a lot to offer to those willing to spend a little time learning something new.</p></div></body></html>