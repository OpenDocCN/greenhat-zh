- en: Chapter 7. Solving Problems with Code Reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter is very different from those that came before. In previous chapters,
    I stressed the importance of finding your own solution to problems. That’s what
    the book is about, after all: writing original solutions to programming problems.
    Even in previous chapters, though, we talked about how you are always learning
    from what you’ve written before, and that’s why you should retain all the code
    that you write for future reference. In this chapter, we’ll go one step further
    and discuss how to use code and ideas from other programmers to solve our problems.'
  prefs: []
  type: TYPE_NORMAL
- en: If you remember how this book started, this topic may seem like an odd inclusion.
    At the beginning, I talked about what a mistake it was to try to solve complex
    problems by modifying someone else’s code. Not only does this have a low chance
    of success, but even when it succeeds, it provides no learning experience for
    you. And if this is all you ever do, you never actually become a programmer and
    are of limited use in software development. That said, once any programming problem
    reaches a respectable size, it’s not reasonable to expect a programmer to develop
    a solution entirely from scratch. That’s an inefficient use of the programmer’s
    time, and it relies too heavily on the programmer being an expert in all things.
    Plus, it’s more likely to lead to a buggy or difficult-to-maintain program.
  prefs: []
  type: TYPE_NORMAL
- en: Good Reuse and Bad Reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must therefore distinguish between good reuse, which allows us to write better
    programs and write them more quickly, and bad reuse, which may allow us to impersonate
    a programmer for a while but ultimately leads to poor development, of both the
    code and the programmer. [Table 7-1](ch07.html#good_and_bad_code_reuse "Table 7-1. Good
    and Bad Code Reuse") summarizes the differences. The left column shows the properties
    of good reuse and the right column shows the properties of bad reuse. When considering
    whether or not to attempt a reuse of code, ask yourself whether you are more likely
    to produce the properties in the left column or the right column.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1. Good and Bad Code Reuse
  prefs: []
  type: TYPE_NORMAL
- en: '| Good Reuse | Bad Reuse |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Following a blueprint | Copying someone else’s work |'
  prefs: []
  type: TYPE_TB
- en: '| Magnifies and extends your capabilities | Falsifies your capabilities |'
  prefs: []
  type: TYPE_TB
- en: '| Helps you learn | Helps you avoid learning |'
  prefs: []
  type: TYPE_TB
- en: '| Saves time in the short term and the long term | May save time in the short
    term but may lengthen time in the long term |'
  prefs: []
  type: TYPE_TB
- en: '| Results in a working program | May result in a program that doesn’t work
    anyway |'
  prefs: []
  type: TYPE_TB
- en: It’s important to note that the difference between good reuse and bad reuse
    doesn’t reside in what code you reuse or how you reuse it but in your relationship
    to the code and concepts that you are borrowing. Once, in writing a term paper
    in a literature class, I discovered that something I had learned in a previous
    course was relevant to my paper’s topic, so I included it. When I submitted a
    draft of my paper to the professor, she told me I needed a citation for that information.
    Frustrated, I asked my professor at what point I could simply state my knowledge
    in a paper without providing a reference. Her answer was that I could stop referencing
    others for what was in my head when I became such an expert that others were referencing
    me.
  prefs: []
  type: TYPE_NORMAL
- en: In programming terms, good reuse occurs when you write code yourself based on
    reading someone’s description of a general concept or when you make use of code
    that you could have written yourself. Throughout this chapter, we’re going to
    talk about how you can take ownership of coding concepts so that you can be sure
    that your reuse is helping you become a better programmer, not a lazier one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me also draw attention to the last row in [Table 7-1](ch07.html#good_and_bad_code_reuse
    "Table 7-1. Good and Bad Code Reuse"). Attempts at bad reuse often fail altogether.
    This is not surprising, because it involves a programmer using code that he or
    she doesn’t actually understand. In some situations, the borrowed code will work
    initially, but when the programmer attempts to modify or expand the borrowed code
    base, the lack of deep comprehension removes the possibility of an organized approach.
    The programmer then resorts to flailing about and trial and error, thus violating
    the first and most important of our general problem-solving rules: Always have
    a plan.'
  prefs: []
  type: TYPE_NORMAL
- en: Review of Component Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the kind of reuse we are aiming for, let’s categorize the different
    ways in which code can be reused. In this book, I’m going to use the term *component*
    to refer to anything created by one programmer that can be reused by another to
    help solve a programming problem. Components can exist anywhere on the continuum
    from abstract to concrete, from an idea to fully implemented code. If we think
    of solving a programming problem as analogous to tackling a handyman project,
    the techniques we’ve learned for solving problems are like tools, and components
    are like specialty parts. Each of the following components is a different way
    of reusing prior work of programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Code Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *code block* is just that: a block of code that has been copied from one
    program listing to another. More colloquially, we would call this a *copy-and-paste
    job*. This is the lowest form of component use and is often bad reuse, with all
    of the problems that implies. Of course, if the code you are copying is your own,
    there’s no real harm done, except that you might consider packaging the existing
    code as a class library or other structure to allow it to be reused in a cleaner
    and more easily maintained way.'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *algorithm* is a programming recipe; it’s a particular method of accomplishing
    a goal and is expressed either in plain language or pictorially as in a flowchart.
    For example, back in [Chapter 3](ch03.html "Chapter 3. Solving Problems with Arrays"),
    we discussed the *sort* operation for arrays and different ways this sort could
    be accomplished. One method of sorting an array is the insertion-sort algorithm,
    and I showed a sample implementation of the algorithm. It’s important to note
    that the given code was one implementation of the insertion sort, but insertion
    sort is the algorithm itself—that way of sorting an array—and not the particular
    code. Insertion sort works by repeatedly taking the next unsorted value in the
    array and shifting the sorted values “up” one position until we’ve made a hole
    in the correct position for the value we’re currently inserting. Any code that
    uses this method to sort an array is an insertion sort.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms are a high-level form of reuse and generally lead to good reuse properties.
    Algorithms are essentially just ideas, and you, the programmer, must implement
    the ideas, calling upon your programming skills and your deep understanding of
    the algorithm itself. The algorithms you will commonly use are well studied and
    have predictable performance in various situations. With an algorithm as a blueprint,
    you can have confidence in the correctness of your code and in its performance.
  prefs: []
  type: TYPE_NORMAL
- en: There are some potential downsides to basing code on an algorithm, though. When
    you use an algorithm, you are starting at the conceptual level. Therefore, you
    have a long road ahead to the finished code for that section of the program. The
    algorithm certainly saves time, because the problem-solving aspect is essentially
    complete, but depending on the algorithm and its particular application in your
    programming, the implementation of the algorithm can be nontrivial.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In programming, a *pattern* (or *design pattern*) is a template for a particular
    programming technique. The concept is related to an algorithm but distinguishable.
    Algorithms are like recipes for solving particular problems, while patterns are
    general techniques used in particular programming situations. The problems that
    patterns solve are typically within the structure of the code itself. For example,
    in [Chapter 6](ch06.html "Chapter 6. Solving Problems with Recursion") we discussed
    the problem presented by a recursive function in a linked-list class: The recursive
    function needed the “head” pointer to the first node in the list as a parameter,
    but that data needed to remain private. The solution was to create a *wrapper*,
    a function that would adapt one parameter list to another. The wrapper technique
    is a design pattern. We can use this pattern to solve the problem of a recursive
    function in a class, but it can be used in other ways as well. For example, suppose
    we had a `linkedList` class that allowed items to be inserted or removed at any
    point in the list, but what we needed was a stack class—that is, a list that allowed
    insertion and removal only at one end. We could create a new class stack that
    had public methods for the typical stack operations, such as `push` and `pop`.
    These methods would just call member functions on the `linkedList` object that
    was a private data member of our `stack` class. In this way, we would reuse the
    functionality of a linked-list class while providing the interface of a stack
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Like algorithms, patterns are a high-level form of component use, and learning
    patterns is a great way to build up your programming tool chest. Patterns share
    some of the potential problems of algorithms, though. Knowing that a pattern exists
    is not the same as knowing how to implement a pattern in the particular language
    you have chosen for a programming solution, and patterns are often tricky to implement
    correctly or with maximum performance. For example, there is a pattern known as
    a *singleton*, which is a class that allows only one object of the class to be
    created. Creating a singleton class is straightforward, but creating a singleton
    class that does not create the one allowed instance object until it is actually
    needed can be surprisingly difficult, and the best technique may vary from language
    to language.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *abstract data type*, as we discussed in [Chapter 5](ch05.html "Chapter 5. Solving
    Problems with Classes"), is a type defined by its operations, not by how those
    operations are implemented. The stack type, which we have used several times in
    this book, is a good example. Abstract data types are like patterns in that they
    define the effects of operations, but they do not specifically define how those
    operations are implemented. As with algorithms, however, there are well-known
    implementation techniques for these operations. For example, a stack can be implemented
    using any number of underlying data structures, such as a linked list or an array.
    Once we make the decision to use a particular data structure, though, the implementation
    decisions are sometimes already made. Suppose we implemented a stack using a linked
    list and are unable to wrap around an existing linked list, but we must write
    our own list code. Because the stack is a last-in-first-out structure, it only
    makes sense for us to insert and remove items at one end of the linked list. Furthermore,
    it only makes sense to insert and remove at the front of the list. Theoretically,
    you could insert and remove at the end, but this would result in an inefficient
    traversal of the entire list for every insertion or removal. To avoid those traversals
    would require a doubly linked list with a separate pointer to the last node in
    the list. Inserting and removing at the beginning of the list allows the simplest,
    most efficient implementation, so linked-list implementations of stacks are almost
    all implemented the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, even though the *abstract* in *abstract data type* means the type is conceptual
    and without implementation detail, in practice, when you choose to implement an
    abstract data type in your code, you won’t be figuring out the implementation
    from scratch. Rather, you will have existing implementations of the type as guides.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In programming, a *library* is a collection of related pieces of code. A library
    typically includes the code in compiled form, along with needed source code declarations.
    Libraries can include stand-alone functions, classes, type declarations, or anything
    else that can appear in code. In C++, the most obvious examples are the standard
    libraries. The `strcmp` function we used in previous chapters comes from the old
    C library *cstring*, the container classes such as `vector` come from the C++
    Standard Template Library, and even the `NULL` we have used in all of our pointer-based
    code is not part of the C++ language itself but defined in a library header file,
    *stdlib.h*. Because so much core functionality is contained within libraries,
    library use is inevitable in modern programming.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, library use is good code reuse. Code is included in a library because
    it provides functionality that is commonly needed in a variety of programs—library
    code helps programmers avoid “reinventing the wheel.” Nevertheless, as developing
    programmers, when we use library code, we must strive to learn from the experience
    and not merely take a shortcut. We’ll see an example of this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while many libraries are general purpose, others are designed as *application
    programming interfaces (APIs)* providing the high-level language programmer with
    a simplified or more coherent view of an underlying platform. For example, the
    Java language includes an API called JDBC, which provides classes that allow programs
    to interact with relational databases in a standard way. Another example is DirectX,
    which provides Microsoft Windows game programmers extensive functionality with
    sound and graphics. In both cases, the library provides a connection between the
    high-level program and foundation-level hardware and software—the database engine
    in the case of JDBC and the graphics and sound hardware in the case of DirectX.
    Moreover, in both cases, the code reuse is not just good—it is, for all practical
    purposes, required. A database programmer in Java or a graphics programmer writing
    C++ code for Windows is going to make use of an API—if not these APIs, then something
    else, but the programmer isn’t going to cook up a new connection to the platform
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Building Component Knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components are so helpful that programmers make use of them whenever possible.
    In order to use a component to aid in solving a problem, though, a programmer
    must know of its existence. Depending on how finely you define them, available
    components might number into the hundreds or even thousands, and a beginning programmer
    is going to be exposed to only a few of them. A good programmer must therefore
    always be adding component knowledge to his or her toolkit. Such knowledge gathering
    occurs in two different ways: A programmer may explicitly allot time for learning
    new components as a general task, or the programmer may search for a component
    to solve a specific problem. We’ll call the first approach *exploratory learning*
    and the second approach *as-needed learning*. To develop as a programmer, you
    will need to employ both approaches. Once you have mastered the syntax of your
    chosen programming language, discovering new components is one of the primary
    ways for you to better yourself as a programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory Learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with an exploratory learning example. Suppose we wanted to learn
    more about design patterns. Fortunately, there is general agreement about which
    design patterns are the most useful or frequently used, so we could begin with
    any number of resources on this topic and be fairly sure that we aren’t missing
    anything important. We would benefit by simply finding a list of design patterns
    and studying it, but we would gain more insight if we implemented some of the
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: One pattern we’ll find in a typical list is called *strategy* or *policy*. This
    is the idea of allowing an algorithm, or part of an algorithm, to be chosen at
    run-time. In the purest form, the strategy form, this pattern allows changing
    how a function or method operates but does not alter the result. For example,
    a method of a class that sorts its data, or involves sorting data, might allow
    the sort methodology (quicksort or insertion sort, for example) to be chosen.
    The result is the same in any case—sorted data—but allowing the client to choose
    the sort methodology could offer performance benefits. For example, the client
    could avoid using quicksort for data with a high rate of duplicates. In the policy
    form, the client’s choice affects the outcome. For example, suppose a class represents
    a hand of playing cards. The sorting policy could determine whether aces are considered
    high (above a king) or low (less than a 2).
  prefs: []
  type: TYPE_NORMAL
- en: Putting Learning into Practice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reading that paragraph, you now know what the strategy/policy pattern is, but
    you haven’t made it your own. It’s the difference between browsing tools at the
    hardware store and actually buying one and using it. So let’s take this design
    pattern down from the shelf and put it to use. The fastest way to try out a new
    technique is to incorporate it into code you’ve already written. Let’s create
    a problem that can be solved using this pattern and that is built upon code we’ve
    already written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem: The First Student'
  prefs: []
  type: TYPE_NORMAL
- en: At a particular school, each class has a designated “first student” who is responsible
    for maintaining order in the classroom if the teacher has to leave the room. Originally,
    this title was bestowed upon the student with the highest grade, but now some
    teachers think the first student should be the student with the greatest seniority,
    which means the lowest student ID number, as they are assigned sequentially. Another
    faction of teachers thinks the first student tradition is silly and intends to
    protest by simply choosing the student whose name appears first in the alphabetical
    class roll. Our task is to modify the student collection class, adding a method
    to retrieve the first student from the collection, while accommodating the selection
    criteria of the various teacher groups.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this problem is going to employ the policy form of the pattern.
    We want our method that returns the first student to return a different student
    based on a chosen criterion. In order to make this happen in C++, we’re going
    to use function pointers. We’ve briefly seen this concept in action in [Chapter 3](ch03.html
    "Chapter 3. Solving Problems with Arrays") with the `qsort` function, which takes
    a pointer to a function that compares two items in the array to be sorted. We’ll
    do something similar here; we’ll have a set of comparison functions that takes
    two of our `studentRecord` objects and determines whether the first student is
    “better” than the second by looking at the grades, ID numbers, or names of the
    students.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need to define a type for our comparison functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration creates a type named `firstStudentPolicy` as a pointer to
    a function that returns a `bool` and takes two parameters of type `studentRecord`.
    The parentheses around `* firstStudentPolicy` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    are necessary to prevent the declaration from being interpreted as a function
    that returns a pointer to a `bool`. With this declaration in place, we can create
    our three policy functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two functions are very simple: `higherGrade` returns `true` when
    the first record has the higher grade, and `lowerStudent` number returns `true`
    when the first record has the lower student number. The third function, `nameComesFirst`,
    is essentially the same, but it requires the `strcmp` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    library function, which expects two “C-style” strings—that is, null-terminated
    character arrays instead of `string` objects. So we have to invoke the `c_str()`![](httpatomoreillycomsourcenostarchimages1273191.png)
    method on the `name` strings in both student records. The `strcmp` function returns
    a negative number when the first string comes before the second alphabetically,
    so we check the return value to see whether it’s less than zero ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Now we are ready to modify the `studentCollection` class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the class declaration we saw back in [Chapter 5](ch05.html "Chapter 5. Solving
    Problems with Classes") with three new members: a private data member, `_currentPolicy`
    ![](httpatomoreillycomsourcenostarchimages1273193.png), to store a pointer to
    one of our policy functions; a `setFirstStudentPolicy` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    method to change this policy; and the `firstStudent` method itself ![](httpatomoreillycomsourcenostarchimages1273191.png),
    which will return the first student according to the current policy. The code
    for `setFirstStudentPolicy` is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the default constructor to initialize the current policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to write `firstStudent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The method begins by checking for special cases. If there is no list to review
    or no policy in place ![](httpatomoreillycomsourcenostarchimages1273182.png),
    we return a dummy record. Otherwise, we traverse the list to find the student
    who best meets the current policy, using the basic searching techniques we’ve
    been using throughout this book. We assign the record at the beginning of the
    list to `first` ![](httpatomoreillycomsourcenostarchimages1273191.png), start
    our loop variable at the second record in the list ![](httpatomoreillycomsourcenostarchimages1273193.png),
    and begin the traversal. Inside the traversal loop, a call to the current policy
    function ![](httpatomoreillycomsourcenostarchimages1273195.png) tells us whether
    the student we’re currently looking at is “better” than the best student we’ve
    found so far, based on the current criterion. When the loop is over, we return
    the “first student” ![](httpatomoreillycomsourcenostarchimages1273197.png).
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of First Student Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having solved a problem using the strategy/policy pattern, we’re much more likely
    to recognize situations in which the technique can be employed than if we had
    just read about the technique once and never used it. We can also analyze our
    sample problem to start forming our own opinion about the worth of the technique,
    when it can be properly employed, and when it might be a mistake, or at least
    more trouble than it’s worth. One thought that may have occurred to you about
    this particular pattern is that it weakens encapsulation and information hiding.
    For example, if the client code is providing the policy functions, it requires
    access to types that would normally remain internal to the class, in this case,
    the `studentRecord` type. (We’ll consider a way around this problem in the exercises.)
    This means the client code could break if we ever modify that type, and we must
    weigh this concern against the benefits of the pattern before applying it in other
    projects. In previous chapters, we discussed how knowing when to use a technique—or
    when not to use it—is as important as knowing how to use it. By examining your
    own code, you gain insight into this critical question.
  prefs: []
  type: TYPE_NORMAL
- en: For further practice, you can review your library of completed projects in search
    of code that could be refactored using this technique. Remember that much “real
    world” programming involves supplementing or modifying an existing code base,
    so this is excellent practice for such modifications, in addition to developing
    your skill with the particular component. Moreover, one of the benefits of good
    code reuse is that we learn from it, and this practice maximizes learning.
  prefs: []
  type: TYPE_NORMAL
- en: As-Needed Learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous section described what we might call “learning through wandering.”
    While such journeys are valuable to programmers, there are other times where we
    must move toward a particular goal. If you’re working on a particular problem,
    especially if you’re working against any kind of deadline, and you suspect that
    a component could be of great help to you, you don’t want to wander randomly through
    the world of programming and hope that you stumble upon what you need. Instead,
    you want to find the component or components that directly apply to your situation
    as quickly as possible. That sounds very tricky, though—how do you find what you
    need when you don’t know exactly what you’re looking for? Consider the following
    sample problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem: Efficient Traversal'
  prefs: []
  type: TYPE_NORMAL
- en: A programming project will use your `studentCollection` class. The client code
    needs the ability to traverse all of the students in the collection. Obviously,
    to maintain information hiding, the client code cannot be given direct access
    to the list, but it’s a requirement that the traversals are efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Because the key word in this description is *efficient*, let’s be precise about
    what that means in this case. Let’s suppose that a particular object of our `stu``dentCollection`
    class has 100 students. If we had direct access to the linked list, we could write
    a loop to traverse the list that would loop 100 times. That’s the most efficient
    any list traversal can be. Any solution that requires us to loop more than 100
    times to determine the result would be inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the requirement for efficiency, we might try to solve the problem by
    adding a simple `recordAt` method to our class that would return the student record
    at a particular position in the collection, numbering the first record as 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we use a loop ![](httpatomoreillycomsourcenostarchimages1273182.png)
    to traverse the list until we reach the desired position or we reach the end of
    the list. At the end of the loop, if the end of the list has been reached, we
    create and return a dummy record ![](httpatomoreillycomsourcenostarchimages1273191.png),
    or we return the record at the specified position ![](httpatomoreillycomsourcenostarchimages1273193.png).
    The problem is that we are performing a traversal merely to find one student record.
    This is not necessarily a full traversal, because we will stop when we reach the
    desired position, but it is a traversal nonetheless. Suppose the client code is
    attempting to average student grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For this code segment, assume that `sc` is a previously declared and populated
    `studentCollection` and `recNum` is an `int` storing the number of records. Suppose
    `recNum` is 100\. If you just glance at this code, it might appear that computing
    the average takes just 100 trips through the loop, but since each call to `recordAt`
    is itself a partial list traversal, this code involves 100 traversals, each of
    which will involve looping about 50 times for the average case. So instead of
    100 steps, which would be efficient, this could require about 5,000 steps, which
    is very inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: When to Search for a Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have now arrived at the real problem. Providing client access to collection
    members for traversals is easy; providing such access efficiently is not. We could,
    of course, try to solve this problem using only our own problem-solving ability,
    but we would reach the solution much faster if we could use a component. The first
    step in finding a previously unknown component that can aid our solution is assuming
    that such a component actually exists. Put another way, you won’t find a component
    unless you start searching for one. Therefore, to maximize the benefit of components,
    you need to be on the lookout for situations where they can help. When you find
    yourself stuck on some aspect of the problem, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Restate the problem generically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ask yourself: Is this likely to be a common problem?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step is important because if we state our problem as “Allow client
    code to efficiently compute the average student grade in a linked list of records
    encapsulated in a class,” it sounds like it’s specific to our situation. If, however,
    we state the problem as “Allow client code to efficiently traverse a linked list
    without providing direct access to the list’s pointers,” then we begin to understand
    that this might be a common problem. Surely, we might ask ourselves, as often
    as programs store linked lists and other sequentially accessed structures within
    classes, other programmers must have figured out ways to allow efficient access
    to every item in the structure?
  prefs: []
  type: TYPE_NORMAL
- en: Finding a Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve agreed to look, it’s time to find our component. To make things
    clear, let’s restate the original programming problem as a research problem: “Find
    a component we can use to modify our `studentCollection` class to allow client
    code to efficiently traverse the internal list.” How do we solve *this* problem?
    We could start by looking at any of our component types: patterns, algorithms,
    abstract data types, or libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we started by looking at the standard C++ libraries. We would not necessarily
    be looking for a class to “plug in” to our solution, but we instead could mine
    a library class that was similar to our `studentCollection` class for ideas. This
    employs the analogy strategy we used to solve programming problems. If we find
    a class that has an analogous problem, we can borrow its analogous solution. Our
    previous exposure to the C++ library has brought us into contact with its container
    classes, such as `vector`, and we should look for the container class that’s most
    like our student collection class. If we go to a favorite C++ reference, be that
    a book or a site on the Web, and review the C++ container classes, we see there
    is a “sequence container” called `list` that fits the bill. Does the `list` class
    allow efficient traversal by client code? It does, using an object known as an
    *iterator*. We see that the list class provides methods `begin` and `end` that
    produce iterators, which are objects that can reference a particular item in the
    list and be incremented to make the iterator reference the next object in the
    list. If `integerList` is a `list<int>`, populated with integers, and `iter` is
    a `list<int>::iterator`, then we could display all of the integers in the list
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Through the use of the iterator, the `list` class has solved the problem of
    providing a mechanism to the client for efficiently traversing the list. At this
    point, we might think to drop the `list` class itself into our `studentCollection`
    class, replacing our home-built linked list. We could then create `begin` and
    `end` methods for our class that would wrap the same methods from the embedded
    list object, and the problem would be solved. This, however, runs straight into
    the issue of good versus bad reuse. Once we fully understand the iterator concept
    and can reproduce it on our own in our own code, plugging an existing class from
    the Standard Template Library into our code will be a good option—perhaps the
    best option. If we’re not able to do that, using the `list` class becomes a shortcut
    that doesn’t help us grow as programmers. Sometimes, of course, we must avail
    ourselves of components that we couldn’t reproduce, but if we fall into the habit
    of depending on other programmers to solve our problems, we risk never becoming
    problem solvers ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s implement the iterator ourselves. Before we do that, though, let’s
    briefly look at other ways we could have arrived at the same place. We began the
    search in the standard template libraries, but we could have begun elsewhere.
    For example, we could have searched through a list of common design patterns.
    Under the heading of “behavioral patterns,” we would find the *iterator* pattern,
    in which the client is allowed sequential access to a collection of items without
    exposing the underlying structure of the collection. This is exactly what we need,
    but we could have found it only by searching through a list of patterns or remembering
    it from previous investigations of patterns. We could have started our search
    with abstract data types because *list* in general, and *linked list* in particular,
    are common abstract data types. However, many discussions and implementations
    of the list abstract data type do not consider client list traversal to be a basic
    operation, so the iterator concept never comes up. Finally, if we begin our search
    in the algorithms area, we would be unlikely to find anything helpful. Algorithms
    tend to describe tricky code, and the code to create an iterator is fairly simple,
    as we will soon see. In this case, then, the class library was the quickest route
    to our destination, followed by patterns. As a general rule, however, you must
    consider all component types when searching for a helpful component.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now know we’re going to make an iterator for our `studentCollection` class,
    but all the `list` standard library class has shown us is how the iterator methods
    work externally. If we got stuck on implementation, we might consider reviewing
    the source code `list` and its ancestor classes, but given the difficulty of reading
    large swaths of unfamiliar code, that’s a measure of last resort. Instead, let’s
    just think our way through this. Using the previous code example as a guide, we
    can say that an iterator is defined by four central operations:'
  prefs: []
  type: TYPE_NORMAL
- en: A method in the collection class that provides an iterator that references the
    first item in the collection. In the `list` class, this was `begin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mechanism to test whether the iterator has advanced past the last item in
    the collection. In the previous example, this was a method called `end` in the
    `list` class that produced a special iterator object to test against.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method in the iterator class that moves the iterator so that it references
    the next item in the collection. In the previous example, this was the overloaded
    `++` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method in the iterator class that returns the currently referenced item in
    the collection. In the previous example, this was the overloaded `*` (prefixed)
    operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of writing the code, nothing here looks difficult. It’s just a question
    of putting everything in the right place. So let’s get started. From the descriptions
    above, our iterator, which we’ll call `scIterator`, needs to store a reference
    to an item in the `studentCollection` and needs to be able to advance to the next
    item. Thus, our iterator should store a pointer to a `studentNode`. That will
    allow it to return the `studentRecord` contained within, as well as advance to
    the next `studentNode`. Therefore, the private section of iterator class will
    have this data member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Right away, we’ve got a problem. The `studentNode` type is declared within
    a private section of `studentCollection`, and therefore the line above won’t work.
    Our first thought is that perhaps `studentNode` shouldn’t have been declared privately,
    but that’s not the right answer. The node type is inherently private because we
    don’t want random client code to depend upon a particular implementation of the
    node type, thus creating code that could break if we modify our class. Nevertheless,
    we need to allow `scIterator` access to our -private type. We do that with a `friend`
    declaration. In the public section of `studentCollection`, we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `scIterator` can access the private declarations within `studentCollection`,
    including the declaration for `studentNode`. We can also declare some constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s hop over to the `studentCollection` for a second and write our *begin*
    method—a method that returns an iterator that references the first item in our
    collection. Following the naming scheme I have used in this book, this method
    should have a noun for a name, such as `firstItemIterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all we need to do here is stuff the head pointer of the linked
    list into a `scIterator` object and return it. If you’re anything like me, seeing
    the pointers flying around here may make you a little nervous, but note that `scIterator`
    is just going to hold onto a reference to an item in the `studentCollection` list.
    It’s not going to allocate any memory of its own, and therefore we don’t need
    to worry about deep copy and overloaded assignment operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to `scIterator` and write our other methods. We need a method
    to advance the iterator to the next item, as well as a method to determine whether
    we are past the end of the collection. We should think about both of these at
    the same time. In advancing the iterator, we need to know what value the iterator
    should have when it passes beyond the last node in the list. If we do nothing
    special, the iterator would naturally get the value of `NULL`, so that would be
    the easiest value to use. Note that we have initialized our iterator to `NULL`
    in the default constructor, so when we use `NULL` to indicate past-the-end we
    lose any distinction between these two states, but for this current problem that’s
    not an issue. The code for the methods is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we are just using the iterator concept to solve the original problem.
    We are not trying to duplicate the exact specification of a C++ Standard Template
    Library iterator, so we don’t have to use the same interface. In this case, rather
    than overloading the `++` operator, I have a method called `advance` ![](httpatomoreillycomsourcenostarchimages1273182.png),
    which checks to see that the `current` pointer isn’t `NULL` ![](httpatomoreillycomsourcenostarchimages1273191.png)
    before advancing it to the next node ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Similarly, I find having to create a special “end” iterator to compare against
    cumbersome, so I just have a `bool` method called `pastEnd` ![](httpatomoreillycomsourcenostarchimages1273195.png)
    that determines whether we’ve run out of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need a way to get the currently referenced `studentRecord` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’ve done previously, for safety, if our pointer is `NULL`, we create and
    return a dummy record ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Otherwise, we return the currently referenced record ![](httpatomoreillycomsourcenostarchimages1273191.png).
    This completes the implementation of the iterator concept with our `studentCollection`
    class. For clarity, here’s the complete declaration of the `scIterator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the code all in place, we can test our code with a sample traversal. Let’s
    implement that average grade computation for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This listing makes use of all of our iterator-related methods, so it’s a good
    test of our code. We call `firstItemIterator` to initialize our `scIterator` object
    ![](httpatomoreillycomsourcenostarchimages1273182.png). We call `pastEnd` as our
    loop termination test ![](httpatomoreillycomsourcenostarchimages1273191.png).
    We call the `student` method of the iterator object to get the current `studentRecord`
    so that we can extract the grade ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Finally, to move the iterator to the next record, we call the `advance` method
    ![](httpatomoreillycomsourcenostarchimages1273195.png). When this code works,
    we can be reasonably confident that we have implemented the various methods correctly,
    and more than that, that we have a firm understanding of the iterator concept.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of Efficient Traversal Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As before, just because the code works doesn’t mean the potential for learning
    from this event is over. We should carefully consider what we have done, its positive
    effects and negative effects, and contemplate expansions of the basic idea we
    have just implemented. In this case, we can say that the iterator concept definitely
    solves the original problem of inefficient client traversal of our collection,
    and once implemented, the use of the iterator is elegant and highly readable.
    On the downside, there’s no denying that the inefficient approach based on the
    `recordAt` method was much easier to write. In deciding whether or not the implementation
    of an iterator is valuable for a particular situation, we have to ask ourselves
    how often traversals would occur, how many items would typically be in our list,
    and so on. If traversals are infrequent and the list is small, the inefficiency
    is probably not important, but if we expect the list to grow large or cannot guarantee
    that it will not, the iterator may be required.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if we had decided to use a `list` object from the Standard Template
    Library, we would no longer worry about the difficulty of implementing the iterator
    because we would not be implementing it ourselves. The next time a situation like
    this arises, we can make use of the `list` class without feeling we are shortchanging
    ourselves or setting ourselves up for later difficulties, because we have investigated
    both lists and iterators to the point where we understand what must be going on
    behind the scenes, even if we never reviewed the actual source code.
  prefs: []
  type: TYPE_NORMAL
- en: Going further, we can think about broader applications of iterators and their
    possible limitations. Suppose, for example, we needed an iterator that could efficiently
    move not just to the next item in our `studentCollection` but also to the previous
    item. Now that we know how the iterator works, we can see that there is really
    no way to do this with our current `studentCollection` implementation. If the
    iterator maintains a link to a particular node in the list, advancing to the next
    node requires merely following the link in the node. Retreating to the previous
    node, however, requires traversing the list again up to that point. Instead, we
    would need a doubly linked list, where the nodes have pointers in both directions,
    to both the next node and the previous one. We can generalize this thought and
    start to consider different data structures and what kinds of traversals or data
    access can be efficiently offered to clients. For example, in the previous chapter
    on recursion, we briefly encountered the binary tree structure. Is there some
    way to allow an efficient client traversal of this structure in its standard form?
    If not, how would we have to modify it to allow efficient reversals? What is even
    the right order for the nodes in a binary tree to be traversed? Thinking through
    questions like these helps us to become better programmers. Not only will we teach
    ourselves new skills, but we’ll also learn more about the strengths and weaknesses
    of different components. Knowing the pros and cons of a component will allow us
    to use it wisely. Failing to consider the limitations of a particular approach
    can lead to dead ends, and the more we know about the components we use, the less
    likely this will happen to us.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Component Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve seen in these examples, the same problem can be solved using different
    types of components. A pattern may express the idea of a solution, an algorithm
    may outline an implementation of that idea or another idea that will solve the
    same problem, an abstract data type may encapsulate the concept, and a class in
    a library may contain a fully tested implementation of the abstract data type.
    If each of these is an expression of the same concept that we need to solve our
    problem, how do we know which component type to pull out of our toolbox?
  prefs: []
  type: TYPE_NORMAL
- en: One primary consideration is how much work may be required to integrate the
    component into our solution. Linking a class library into our code is often a
    fast way to solve a problem, whereas implementing an algorithm from a pseudocode
    description may take a lot of time. Another important consideration is how much
    flexibility the proposed component offers. Often, a component will come in a nice,
    prepackaged form, but when it is integrated into the project, the programmer discovers
    that while the component does most of what he or she needs, it doesn’t do everything.
    Perhaps the return value of one method is in the wrong format and requires additional
    processing, for example. If the component is used anyway, more trouble may be
    discovered down the road before the component is eventually discarded altogether
    and new code for that part of the problem is developed from scratch. If the programmer
    had chosen a component at a higher conceptual level, such as a pattern, the resulting
    code implementation would fit the problem perfectly because it was created specifically
    for that problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](ch07.html#flexibility_versus_work_required_for_com "Figure 7-1. Flexibility
    versus work required for component types") summarizes the interplay of these two
    factors. Generally, code from a library comes ready to use, but it cannot be directly
    modified. It can only be indirectly modified either through the use of C++ templates
    or if the code in question implements something like the *strategy* pattern we
    saw earlier in this chapter. At the other end of the scale, a pattern may be presented
    as nothing more than an idea (“a class that can have only one instance”), offering
    maximum implementation flexibility but requiring a lot of work from the programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just a general guideline, and individual cases will differ.
    Perhaps the class we’re using from the library is at such a low level in our program
    that flexibility won’t suffer. For example, we might wrap a collection class of
    our own design around a basic container class like `list`, which is broad enough
    in capabilities that even if we have to expand the functionality of our container
    class, we can expect the `list` class to handle it. Before using a pattern, perhaps
    we’ve already implemented a particular pattern before, so we’re not so much creating
    new code as adapting previously written code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flexibility versus work required for component types](httpatomoreillycomsourcenostarchimages1273267.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1. Flexibility versus work required for component types
  prefs: []
  type: TYPE_NORMAL
- en: 'The more experience you have in using components, the more confident you can
    be that you are starting in the right place. Until you develop that experience,
    you can use the trade-off between flexibility and work required as a rough guide.
    For each specific situation, ask yourself questions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Can I use the component as is, or does it require additional code to bolt it
    into my project?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Am I confident that I understand the full extent of the problem, or the part
    that relates to this component, and that it will not change in the future?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will I increase my programming knowledge by choosing this component?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your answers to these questions will help you estimate how much work will be
    involved and how much benefit you receive from each possible approach.
  prefs: []
  type: TYPE_NORMAL
- en: Component Choice in Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand the general idea, let’s run through a quick example to
    demonstrate the specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem: Sorting Some, Leaving Others Alone'
  prefs: []
  type: TYPE_NORMAL
- en: A project requires you to sort an array of `studentRecord` objects by grade,
    but there’s a catch. Another part of the program is using a special grade value
    of −1 to indicate a student whose record cannot be moved. So while all the other
    records must be moved around, those with −1 grades should be left exactly where
    they are, resulting in an array that is sorted except for −1 grades interspersed
    throughout.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a tricky problem, and there are lots of ways we could attempt to solve
    it. To keep things simple, let’s reduce our choices to two: Either we choose an
    algorithm—that is, a sorting routine like insertion sort—and modify it to ignore
    the `studentRecord` objects with −1 grades, or we figure out a way to use the
    `qsort` library routine to solve this problem. Both of these options are possible.
    Because we’re comfortable with the insertion-sort code, it shouldn’t be too difficult
    to throw in some `if` statements to explicitly check and skip over records with
    −1 grades. Making `qsort` do the work for us will take a bit of a workaround.
    We could copy the student records with the real grades into a separate array,
    sort them using `qsort`, and then copy them back, making sure we don’t copy over
    any of the −1 grade records.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow through with both options to see how the choice of component type
    affects the resulting code. We’ll start with the algorithm component, writing
    our own modified insertion sort to solve the problem. As usual, we’ll approach
    this problem in stages. First, let’s reduce the problem by removing the whole
    −1 grade issue and just sorting an array of `studentRecord` objects without any
    special rules. If `sra` is an array containing `arraysize` objects of type `studentRecord`,
    the resulting code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very similar to the insertion sort for integers. The only differences
    are that the comparison requires calls to the `grade` method ![](httpatomoreillycomsourcenostarchimages1273182.png),
    and our temporary object used for swap space has changed type ![](httpatomoreillycomsourcenostarchimages1273191.png).
    This code works fine, but there is one caveat for testing this and other code
    blocks that follow in this section: Our `studentRecord` class validates data,
    and as previously written, it will not accept a −1 grade, so make sure you make
    the necessary changes. Now we’re ready to complete this version of the solution.
    We need the insertion sort to ignore records with −1 grades. This is not as simple
    as it sounds. In the basic insertion-sort algorithm, we are always swapping adjacent
    locations in the array, `j` and `j - 1` in the code above. If we are leaving records
    with −1 grades in place, though, the locations of the next records to be swapped
    could be an arbitrary distance apart.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.html#arbitrary_distance_between_records_to_be "Figure 7-2. Arbitrary
    distance between records to be swapped in modified insertion sort") illustrates
    this problem with an example. If this shows the array in its original configuration,
    then the arrows indicate the locations of the first records to be swapped, and
    they are not adjacent. Furthermore, eventually the last record (for Art) will
    have to be swapped from location `[5]` to `[3]` and then from `[3]` to `[0]`,
    so all the swaps required to sort this array (as much as we are sorting it) involve
    nonadjacent records.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arbitrary distance between records to be swapped in modified insertion sort](httpatomoreillycomsourcenostarchimages1273269.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2. Arbitrary distance between records to be swapped in modified insertion
    sort
  prefs: []
  type: TYPE_NORMAL
- en: 'In considering how to solve this problem, I looked out for an analogy and found
    one in the processing of linked lists. In many linked-list algorithms, we have
    to maintain a pointer not only to the current node in our list traversal but also
    to the previous node. So at the end of loop bodies, we often assign the current
    pointer to the previous pointer before advancing the current pointer. Something
    similar needs to go on here. We need to keep track of the last “real” student
    record as we progress linearly through the array to find the next “real” record.
    Putting this idea into practice results in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the basic insertion-sort algorithm, we repeatedly insert unsorted items into
    an ever-growing sorted area within the array. The outer loop selects the next
    unsorted item to be placed in sorted order. In this version of the code, we start
    by checking that the grade in location `i` is not −1 ![](httpatomoreillycomsourcenostarchimages1273182.png)
    inside the outer loop body. If it is, we will just skip to the next record, leaving
    this record in place. Once we have established that the student record at location
    `i` can be moved, we initialize `rightswap` to this location ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Then we begin the inner loop. In the basic insertion-sort algorithm, each iteration
    of the inner loop swaps an item with its neighbor. In our version, though, because
    we are leaving records with −1 grades in place, we perform a swap only when location
    `j` does not contain a grade of −1 ![](httpatomoreillycomsourcenostarchimages1273195.png).
    We then swap between locations `leftswap` and `rightswap` and assign `leftswap`
    to `rightswap` ![](httpatomoreillycomsourcenostarchimages1273197.png), setting
    up the next swap in the inner loop if there is one. Finally, we have to modify
    our inner loop condition. Normally the inner loop in an insertion sort stops when
    we reach the front end of the array or when we find a value that is less than
    the value we are inserting. Here, we have to make a compound condition using logical
    *or* so that the loop continues past −1 grades ![](httpatomoreillycomsourcenostarchimages1273193.png)
    (because −1 will be less than any legitimate grade, thus stopping the loop prematurely).
  prefs: []
  type: TYPE_NORMAL
- en: This code solves our problem, but it’s possible that it may be giving off some
    “bad smells.” The standard insertion-sort code is easy to read, especially if
    you understand the gist of what it’s doing, but this modified version is hard
    on the eyes and probably needs some comment lines if we want to be able to understand
    it later. Perhaps a refactoring is in order, but let’s try the other approach
    for solving this problem and see how that reads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we’ll need is a comparison function for use with `qsort`. In
    this case, we’ll be comparing two `studentRecord` objects, and our function will
    subtract one grade from the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re ready to sort the records. We’ll do this in three phases. First,
    we will copy all of the records that don’t have a −1 grade to a secondary array,
    leaving no gaps. Then, we’ll call `qsort` to sort the secondary array. Finally,
    we will copy the records from the secondary array back to the original array,
    skipping over the records with the −1 grades. The resulting code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Although this code is about the same length as the other solution, it’s more
    straightforward and easier to read. We begin by declaring our secondary array,
    `sortArray` ![](httpatomoreillycomsourcenostarchimages1273182.png), of the same
    size as the original array. The variable `sortArrayCount` is initialized to zero
    ![](httpatomoreillycomsourcenostarchimages1273191.png); in the first loop, we’ll
    use this to track how many records we have copied into the secondary array. Inside
    that loop, each time we encounter a record without a −1 grade ![](httpatomoreillycomsourcenostarchimages1273193.png),
    we assign it to the next available slot in `sortArray` and increment `sortArrayCount`.
    When the loop is over, we sort the secondary array ![](httpatomoreillycomsourcenostarchimages1273195.png).
    The variable `sortArrayCount` is reset to 0 ![](httpatomoreillycomsourcenostarchimages1273197.png);
    we’ll use it in the second loop to track how many records we have copied from
    the secondary array back to the original array. Note that the second loop traverses
    the *original* array ![](httpatomoreillycomsourcenostarchimages1273199.png), looking
    for slots that need to be filled ![](httpatomoreillycomsourcenostarchimages1273203.png).
    If we approach this the other way, trying to loop through the secondary array
    and pushing the records over to the original array, we would need a double loop,
    with the inner loop searching for the next real-grade slot in the original array.
    This is another example of how the problem can be made easy or difficult based
    on our conceptualization of it.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both solutions work and are reasonable approaches. For most programmers, the
    first solution, in which we modified insertion sort to leave some records in place
    as we sorted around them, is harder to write and harder to read. The second solution,
    though, appears to introduce some inefficiency because it requires copying the
    data to the secondary array and back again. Here’s where a little knowledge of
    algorithm analysis comes in handy. Suppose we were sorting 10,000 records—if we
    were sorting much fewer, we wouldn’t really care about the efficiency. We can’t
    know for sure what algorithm underlies the `qsort` call, but the worst case for
    a general-purpose sort would require 100 million record swaps, and the best case
    would be around 130,000\. Regardless of where along the range we end up, copying
    10,000 records back and forth isn’t going to be a major performance drain compared
    to the sorting. Also, we have to consider that whatever algorithm is used by `qsort`
    may be more efficient than our simple insertion sort, wiping out any benefit we
    may have gained from avoiding copying the data to and from the secondary array.
  prefs: []
  type: TYPE_NORMAL
- en: So in this scenario, the second approach, using `qsort`, appears to be the winner.
    It’s simpler to implement, simpler to read and therefore more easily maintained,
    and we can expect its performance to be as good as, or possibly better than, the
    first solution. The best thing we can say about the first approach is that we
    may have learned skills that we can apply to other problems, whereas the second
    approach, by virtue of its simplicity, offers no such insights. As a general rule,
    when you are at the stage of programming where you are trying to maximize your
    learning, you should favor higher-level components such as algorithms and patterns.
    When you are at the stage of trying to maximize your efficiency as a programmer
    (or are under a hard deadline), you should favor lower-level components, choosing
    prebuilt code when possible. Of course, if time permits, trying several different
    approaches, as we have done here, provides the best of all worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try out as many components as you can. Once you get a handle on how to learn
    new components, your abilities as a programmer will start to grow quickly.
  prefs: []
  type: TYPE_NORMAL
- en: A complaint offered against the *policy/strategy* pattern is that it requires
    exposing some internals of the class, such as types. Modify the “first student”
    program from earlier in this chapter so that the policy functions are all stored
    within the class and are chosen by passing a code value (of a new, enumerated
    type, for example), instead of passing the policy function itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite our `studentCollection` functions from [Chapter 4](ch04.html "Chapter 4. Solving
    Problems with Pointers and Dynamic Memory") (`addRecord` and `averageRecord`)
    so that instead of directly implementing a linked list, you use a class from the
    C++ library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider a collection of `studentRecord` objects. We want to be able to quickly
    find a particular record based on student number. Store the student records in
    an array, sort the array by student number, and investigate and implement the
    *interpolation search* algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the problem in 7-3, implement a solution by implementing an abstract data
    type that allows an arbitrary number of items to be stored and individual records
    to be retrieved based on a key value. A generic term for a structure that can
    efficiently store and retrieve items based on a key value is a *symbol table*,
    and common implementations of the symbol table idea are *hash tables* and *binary
    search trees*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the problem in 7-3, implement a solution using a class from the C++ library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose you are working on a project in which a particular `studentRecord`
    may need to be augmented with one of the following pieces of data: term paper
    title, year of enrollment, or a `bool` indicating whether the student is auditing
    the class. You don’t want to include all of these data fields in the base `studentRecord`
    class, knowing that in most cases they won’t be used. Your first thought is to
    create three subclasses, each having one of the data fields, with names such as
    `studentRecordTitle`, `studentRecordYear` and `studentRecordAudit`. Then you are
    informed that some student records will contain two of these additional data fields
    or perhaps all three. Creating subclasses for each possible variation is impractical.
    Find a design pattern that addresses this conundrum, and implement a solution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Develop a solution to the problem described in 7-6 that does not make use of
    the pattern you discovered but instead solves the problem using C++ library classes.
    Rather than focusing on the three particular data fields described in the previous
    question, try to make a general solution: a version of the `studentRecord` class
    that allows arbitrary extra fields of data to be added to particular objects.
    So, for example, if `sr1` is a `studentRecord`, you might want client code to
    make the call `sr1.addExtraField("Title", "Problems of Unconditiona`l Branching"),
    and then later `sr1.retrieveField("Title")` would return “Problems of Unconditional
    Branching.”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Design your own: Take a problem you have already solved, and solve it again
    using a different component. Remember to analyze the results in comparison to
    your original solution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
