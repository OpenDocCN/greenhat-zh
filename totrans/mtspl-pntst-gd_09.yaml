- en: Chapter 9. Metasploit Auxiliary Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When most people think of Metasploit, exploits come to mind. Exploits are cool,
    exploits get you shell, and exploits get all the attention. But sometimes you
    need something more than that. By definition, a Metasploit module that is not
    an exploit is an *auxiliary module*, which leaves a lot to the imagination.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to providing valuable reconnaissance tools such as port scanners
    and service fingerprinters, auxiliary modules such as *ssh_login* can take a known
    list of usernames and passwords and then attempt to log in via brute force across
    an entire target network. Also included in the auxiliary modules are various protocol
    fuzzers such as *ftp_pre_post*, *http_get_uri_long*, *smtp_fuzzer*, *ssh_version_corrupt*,
    and more. You can launch these fuzzers at a target service in hopes of finding
    your own vulnerabilities to exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Just because auxiliary modules don’t have a payload, don’t think you won’t use
    them. But before we dive into their myriad uses, here’s an overview to help you
    see what we are dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding listing, modules are installed within the */modules/auxiliary*
    directory ![](../images/00002.gif) of the Framework, and within that, sorted based
    on the functions they provide. Should you want to create your own module or edit
    an existing one to suit a specific purpose, you will find them in their corresponding
    directories. For instance, if you need to develop a fuzzer module to hunt your
    own bugs, you will find some pre-existing modules in the */fuzzers* directory.
  prefs: []
  type: TYPE_NORMAL
- en: To list all the available auxiliary modules within Metasploit, simply issue
    the **`show auxiliary`** command ![](../images/00002.gif) within *msfconsole*.
    If you compare the preceding directory listing with the module names displayed
    in *msfconsole*, you will notice that the naming of the modules depends on the
    underlying directory structure, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this trimmed output, the auxiliary modules are organized by
    category. At your disposal are the DNS enumeration module, Wi-Fi fuzzers, and
    even a module to locate and abuse the Trojan backdoor that was included on Energizer
    USB battery chargers.
  prefs: []
  type: TYPE_NORMAL
- en: Using an auxiliary module is similar to using any exploit within the Framework
    — simply issue the `use` command followed by the module name. For example, to
    use the *webdav_scanner* module (explored in [Auxiliary Modules in Use](part0013.html#auxiliary_modules_in_use)
    in [Auxiliary Modules in Use](part0013.html#auxiliary_modules_in_use)), you would
    run `use scanner/http/webdav_scanner` as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In auxiliary modules, the basic options are slightly different with an `RHOSTS`
    option to target multiple machines and a `THREADS` value to fine-tune the speed
    of your scanning.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we issue the `use` command ![](../images/00002.gif) for the module of interest.
    We can then get a full dump of information from the system using the `info` command
    ![](../images/00004.gif), as well as a list of the various available options.
    Within the options, we see that the only required option without a default is
    `RHOSTS` ![](../images/00005.gif), which can take a single IP address, list, range,
    or CIDR notation.
  prefs: []
  type: TYPE_NORMAL
- en: The other options mostly vary depending on the auxiliary module being used.
    For instance, the `THREADS` ![](../images/00006.gif) option allows multiple threads
    to be launched as part of a scan, which speeds things up exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary Modules in Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auxiliary modules are exciting because they can be used in so many ways for
    so many things. If you can’t find the perfect auxiliary module, it’s easy to modify
    one to suit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a common example. Say you are conducting a remote penetration test,
    and upon scanning the network, you identify a number of web servers and not much
    else. Your attack surface is limited at this point, and you have to work with
    what is available to you. Your auxiliary *scanner/http* modules will now prove
    extremely helpful as you look for low-hanging fruit against which you can launch
    an exploit. To search for all available HTTP scanners, run **`search scanner/http`**
    as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of options here, so let’s identify some likely candidates in
    that list. Notice that there are the options for identifying the *robots.txt*
    ![](../images/00002.gif) file from various servers, numerous ways to interact
    with WebDAV ![](../images/00004.gif), tools to identify servers with writable
    file access ![](../images/00005.gif), and many other special-purpose modules.
  prefs: []
  type: TYPE_NORMAL
- en: You can see immediately that there are modules that you can use for subsequent
    exploration. Older versions of Microsoft IIS had a vulnerability in their WebDAV
    implementations that allowed for remote exploitation, so you could first run a
    scan against your targets in hopes of finding a server with WebDAV enabled, as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, a number of HTTP servers have been scanned in
    the search for WebDAV ![](../images/00002.gif), and only one happens to have Web-DAV
    enabled ![](../images/00004.gif). This module has quickly identified a specific
    system against which you can launch further attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Auxiliary module functionality goes far beyond scanning. As you will see in
    [Chapter 14](part0018.html#creating_your_own_exploits) auxiliary modules also
    work great as fuzzers with a little modification. A number of denial-of-service
    modules are also available for Wi-Fi (including *dos/wifi/deauth*), which can
    prove quite disruptive when used properly.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an Auxiliary Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at the makeup of an auxiliary module in a fun little example not
    currently in the Metasploit repository (because it does not pertain to penetration
    testing). This example will demonstrate how easy it is to off-load a great deal
    of programming to the Framework, allowing us to focus on the specifics of a module.
  prefs: []
  type: TYPE_NORMAL
- en: Chris Gates wrote an auxiliary module for the Framework that gave his Twitter
    followers the impression that he had somehow invented a device that allowed him
    to travel at the speed of light. It makes a great example of the code reuse available
    in Metasploit. (You can access the source of the script at [http://carnal0wnage.googlecode.com/](http://carnal0wnage.googlecode.com/).)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We’ve placed the module in our auxiliary directory ![](../images/00002.gif)
    so that it will be available for use by Metasploit. But before we use this module,
    let’s look at the actual script and break down the components so we can see exactly
    what the module contains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The module begins with the first two lines importing the auxiliary class ![](../images/00002.gif).
    Next it makes the HTTP client functions available for use ![](../images/00004.gif)
    within the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Within the initialization constructor ![](../images/00002.gif) we define much
    of the information ![](../images/00004.gif) that is reported back when issuing
    the `info` command in *msfconsole*. We can see where the various options are defined
    ![](../images/00005.gif) and whether they are required. So far, all are pretty
    direct and their purposes are clear. Still, we have yet to see any actual logic
    being performed. That comes next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we reach the actual logic of the script — what happens when `run` is called
    within the module. Initially the provided options are set to local variable names
    ![](../images/00002.gif) along with defining various other objects. An object
    is then created by calling the *send_request_cgi* method ![](../images/00004.gif)
    imported into the script from *lib/msf/core/exploit/http.rb* and defined as “Connects
    to the server, creates a request, sends the request, reads the response.” This
    method takes various parameters that make up the call to the actual server, as
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After this object is created, the results are printed ![](../images/00002.gif).
    If anything goes wrong, logic exists for catching any errors ![](../images/00004.gif)
    and reporting them to the user. All of this logic is simple and is just a matter
    of plugging various parameters into existing functions of the Framework. This
    is a great example of the power of the Framework, because it allows us to concentrate
    only on the information needed to address our goal. There is no reason to reproduce
    any of the standard functions such as error handling, connection management, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this module in action. If you don’t remember the full path to the
    module within the Metasploit directory structure, search for it like so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the prior example, we search for “foursquare” ![](../images/00002.gif), issue
    the `use` command ![](../images/00004.gif) to select the auxiliary module, and
    display the information ![](../images/00005.gif) for the selected module. Based
    on the options presented above, we need to configure a few of them first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order to run this module successfully, we need a valid set of Foursquare
    credentials to do the check-in. We first define the VenueID that we find online
    with a bit of Googling ![](../images/00002.gif), and then we set our Foursquare
    credentials ![](../images/00004.gif) and run the module. We get a successful result
    with the Foursquare service confirming our check-in and giving us five points
    ![](../images/00005.gif).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have submitted a request to “check in” at Union Station in
    Washington, DC, on the Foursquare service (see [Figure 9-1](part0013.html#a_successful_check-in_at_union_station)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A successful check-in at Union Station](../images/00038.jpeg)Figure 9-1. A
    successful check-in at Union Station'
  prefs: []
  type: TYPE_NORMAL
- en: When we check the Foursquare website, we see a successful result. Modules like
    these demonstrate that Metasploit allows us to implement nearly anything we can
    programmatically imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Going Forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have seen, auxiliary modules can have a wide range of uses. The infrastructure
    provided by the Metasploit Framework can produce a wide array of tools in a very
    short time. Using Metasploit’s auxiliary modules, you can scan an IP address range
    to determine which hosts are alive and which services are running on each host.
    You can then leverage this information to determine vulnerable services, such
    as in the WebDAV example, or even log in via brute force on a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can easily create custom auxiliary modules, don’t discount the
    existing auxiliary modules in the Framework. These modules may be the exact one-off
    tool you need.
  prefs: []
  type: TYPE_NORMAL
- en: The auxiliary modules provide a wide range of potential additional avenues.
    For a web application, the auxiliary modules offer more than 40 additional checks
    or attacks that you can perform. In some instances, you may want to brute force
    a web server to see which servers are listing directories. Or you may want to
    scan the web server to see if it can act as an open proxy and relay traffic out
    to the Internet. Regardless of your needs, the auxiliary modules can provide additional
    enumeration information, attack vectors, or vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
