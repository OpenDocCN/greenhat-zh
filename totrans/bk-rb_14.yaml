- en: Chapter 14. YAML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章。YAML
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: At some point, most desktop applications are going to want to save and read
    structured data to and from disk. You’ve already seen how to read and write data
    using simple IO routines such as `gets` and `puts`. But how would you go about
    saving and restoring data from, say, lists of mixed object types? One simple way
    of doing this with Ruby is by using YAML.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，大多数桌面应用程序都希望将结构化数据保存到磁盘并从中读取。你已经看到了如何使用简单的 IO 例程，如 `gets` 和 `puts` 来读取和写入数据。但如果你要保存和恢复来自混合对象类型列表的数据，你会怎么做？使用
    Ruby，一种简单的方法是使用 YAML。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: YAML is an acronym that is (debatably) either short for Yet Another Markup Language
    or (recursively) for YAML Ain’t Markup Language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 是一个首字母缩略词，有人认为它代表“另一种标记语言”（Yet Another Markup Language），或者（递归地）代表“YAML
    不是标记语言”（YAML Ain’t Markup Language）。
- en: Converting to YAML
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为 YAML
- en: 'YAML defines a serialization (data-saving) format that stores information as
    human-readable text. YAML can be used with a variety of programming languages;
    in order to use it in Ruby, your code needs access to routines from Ruby’s *yaml.rb*
    file. Generally, this would be done by loading or “requiring” the file at the
    top of a code unit like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 定义了一种序列化（数据保存）格式，以人类可读的文本形式存储信息。YAML 可以与各种编程语言一起使用；为了在 Ruby 中使用它，你的代码需要访问
    Ruby 的 *yaml.rb* 文件中的例程。通常，这会在代码单元的顶部通过以下方式加载或“要求”文件：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Having done this, you will have access to a variety of methods to convert Ruby
    objects to the YAML format so that they can write their data to a file. Subsequently,
    you will be able to read back this saved data and use it to reconstruct Ruby objects.
    To convert an object to YAML format, you can use the `to_yaml` method. This will
    convert standard object types such as strings, integers, arrays, hashes, and so
    on. For example, this is how you would convert a string:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，你将能够访问各种将 Ruby 对象转换为 YAML 格式的方法，以便将它们的数据写入文件。随后，你将能够读取这些保存的数据，并使用它来重建
    Ruby 对象。要将对象转换为 YAML 格式，你可以使用 `to_yaml` 方法。这将转换标准对象类型，如字符串、整数、数组、哈希等。例如，这是转换字符串的方法：
- en: '*to_yaml1.rb*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*to_yaml1.rb*'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And this is how you would convert an array:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是转换数组的方法：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the YAML format that you would obtain as a result of this array conversion:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数组转换的结果 YAML 格式，其中每个键值对都放置在新的一行上：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the three dashes that define the start of a new YAML “document” and the
    single dash that defines each new element in a list. In YAML terms, a document
    is not a separate file on disk but a separate YAML definition; one disk file may
    contain many YAML documents. For more information on the YAML format, refer to
    [Digging Deeper](ch14s07.html#digging_deeper-id13 "Digging Deeper") in [Digging
    Deeper](ch14s07.html#digging_deeper-id13 "Digging Deeper").
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意定义 YAML “文档”开始的三条横线和定义列表中每个新元素的单条横线。在 YAML 术语中，文档不是磁盘上的单独文件，而是单独的 YAML 定义；一个磁盘文件可能包含多个
    YAML 文档。有关 YAML 格式的更多信息，请参阅 [深入挖掘](ch14s07.html#digging_deeper-id13 "深入挖掘") 中的
    [深入挖掘](ch14s07.html#digging_deeper-id13 "深入挖掘")。
- en: 'You can also convert objects of nonstandard types to YAML. For example, let’s
    suppose you create this class and object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将非标准类型的对象转换为 YAML。例如，假设你创建了这个类和对象：
- en: '*to_yaml2.rb*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*to_yaml2.rb*'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The YAML representation of this object will be preceded by the text `!ruby/object:`
    followed by the class name, the names of variables with a colon appended (but
    minus the `@`), and their values, one per line:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象的 YAML 表示形式将先于文本 `!ruby/object:`，然后是类名，变量名后跟冒号（但去掉 `@`），以及它们的值，每行一个：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to print out the YAML representation of an object, you can use
    the method `y()`, which is a sort of YAML equivalent of the familiar `p()` method
    used to inspect and print normal Ruby objects:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要打印出对象的 YAML 表示形式，你可以使用方法 `y()`，这是 YAML 的一个类似于熟悉 `p()` 方法的等效方法，用于检查和打印正常的
    Ruby 对象：
- en: '*yaml_test1.rb*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*yaml_test1.rb*'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This displays the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下内容：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You could similarly display a hash:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以类似地显示一个哈希：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'in which case each key-value pair is placed onto a new line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个键值对都放置在新的一行上：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ordering of hash elements may differ according to which version of Ruby
    you are using (see [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes")). It
    is best to assume no intrinsic order when working with a hash.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希元素的顺序可能因你使用的 Ruby 版本而异（见第 4 章）。在处理哈希时，最好假设没有内在的顺序。
- en: 'Or you could display your own “custom” objects:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以显示你自己的“自定义”对象：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This displays data formatted, as in the earlier example where I used `to_yaml`,
    with the class name at the top and with pairs of variable names and values on
    successive lines. This is the YAML representation of a Treasure object containing
    the instance variables `@name` and `@value`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了数据格式，就像在之前的示例中我使用`to_yaml`时一样，类名在顶部，变量名和值成对地出现在连续的行上。这是包含实例变量`@name`和`@value`的Treasure对象的YAML表示：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can even use `y()` to display quite complex objects such as nested arrays:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用`y()`来显示嵌套数组等相当复杂的对象：
- en: '*yaml_test2.rb*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*yaml_test2.rb*'
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the YAML representation of `arr1`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`arr1`的YAML表示：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is another example of an array containing objects of user-defined types:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个包含用户定义类型对象的数组的示例：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This outputs the following YAML:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下YAML：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Nested Sequences
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套序列
- en: 'When related sequences of data (such as arrays) are nested inside other sequences
    of data, this relationship is indicated by indentation. So, for example, let’s
    suppose you have this array declared in Ruby:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当相关的数据序列（如数组）嵌套在其他数据序列内部时，这种关系通过缩进来表示。例如，假设你在Ruby中声明了这个数组：
- en: '*nested_arrays.rb*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*nested_arrays.rb*'
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When rendered as YAML (for example, by `y( arr )`), this becomes as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当以YAML格式呈现（例如，通过`y(arr)`）时，它将如下所示：
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Saving YAML Data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存YAML数据
- en: 'Another handy way of turning your Ruby objects into YAML format is provided
    by the `dump` method. At its simplest, this converts your Ruby data into YAML
    format and “dumps” it into a string:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的Ruby对象转换为YAML格式的另一种方便的方法是由`dump`方法提供的。在最简单的情况下，它将你的Ruby数据转换为YAML格式并将其“写入”字符串：
- en: '*yaml_dump1.rb*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*yaml_dump1.rb*'
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'More usefully, the `dump` method can take a second argument, which is some
    kind of IO object, typically a file. You can open a file and dump data to it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的是，`dump`方法可以接受第二个参数，这是一种IO对象，通常是文件。你可以打开一个文件并将数据写入它：
- en: '*yaml_dump2.rb*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*yaml_dump2.rb*'
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or you can open the file (or some other type of IO object) and pass this into
    an associated block:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以打开文件（或某种其他类型的IO对象）并将其传递给一个关联的块：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In each case, the YAML representation of the data from the array will be saved,
    as plaintext, into the specified file. For example, when the previous code executes,
    it writes this text into the *morefriends.yml* file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，数组的YAML表示都将作为纯文本保存到指定的文件中。例如，当之前的代码执行时，它将以下文本写入*morefriends.yml*文件：
- en: '*morefriends.yml*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*morefriends.yml*'
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you use a block, the file will be closed automatically on exiting the block;
    otherwise, you should explicitly close the file using the `close` method. You
    can also use a block in a similar way to open a file and read in YAML data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个块，文件将在退出块时自动关闭；否则，你应该显式地使用`close`方法关闭文件。你也可以以类似的方式使用块来打开文件并读取YAML数据：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Assuming *morefriends.yml* contains the data saved earlier, once it is loaded
    and assigned to the global variable `$arr` in the block shown earlier, `$arr`
    will contain this array of strings:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*morefriends.yml*包含之前保存的数据，一旦它被加载并分配给之前显示的块中的全局变量`$arr`，`$arr`将包含这个字符串数组：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Omitting Variables on Saving
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存时省略变量
- en: 'If, for some reason, you want to omit some instance variables when serializing
    objects, you can do so by defining a method named `to_yaml_properties`. In the
    body of this method, place an array of strings. Each string should match the name
    of the instance variable to be saved. Any variables that are not specified will
    not be saved. Take a look at this example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，你希望在序列化对象时省略一些实例变量，你可以通过定义一个名为`to_yaml_properties`的方法来实现。在这个方法的主体中，放置一个字符串数组。每个字符串都应该匹配要保存的实例变量的名称。任何未指定的变量将不会被保存。看看这个例子：
- en: '*limit_y.rb*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*limit_y.rb*'
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here `to_yaml_properties` limits the variables that will be saved when you call
    `YAML.dump` to `@num` and `@arr`. The string variable, `@str`, will not be saved.
    If you want to reconstruct the objects based on the saved YAML data, it is your
    responsibility to ensure that any “missing” variables are either not needed (in
    which case they may be ignored) or, if they are needed, that they are initialized
    with some meaningful value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`to_yaml_properties`限制了在调用`YAML.dump`时将保存的变量，即`@num`和`@arr`。字符串变量`@str`将不会被保存。如果你想根据保存的YAML数据重建对象，你有责任确保任何“缺失”的变量要么不是必需的（在这种情况下可以忽略），要么如果它们是必需的，它们应该被初始化为一些有意义的值。
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Multiple Documents, One File
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多文档，一个文件
- en: 'Earlier, I mentioned that three dashes are used to mark the start of a new
    YAML section known as a *document*. For example, let’s assume you want to save
    two arrays, `arr1` and `arr2`, to a file, *multidoc.yml*. Here `arr1` is an array
    containing two nested arrays, and `arr2` is an array containing two CD objects:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到，三个短横线用于标记一个名为*document*的新YAML部分的开始。例如，假设你想要将两个数组`arr1`和`arr2`保存到一个文件中，*multidoc.yml*。在这里，`arr1`是一个包含两个嵌套数组的数组，而`arr2`是一个包含两个CD对象的数组：
- en: '*multi_docs.rb*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*multi_docs.rb*'
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is my routine to dump these arrays to YAML and write them to a file (as
    explained in [Chapter 13](ch13.html "Chapter 13. Files and IO"), the `''w''` argument
    causes the file to be opened for writing):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的将数组转换为YAML并写入文件的常规操作（如第13章[Files and IO](ch13.html "Chapter 13. Files and
    IO")中所述），`'w'`参数导致文件以写入模式打开）：
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you now look at the file *multidoc.yml*, you’ll see that the data has been
    saved as two separate “documents,” each one beginning with three dashes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在查看*multidoc.yml*文件，你会看到数据已经被保存为两个独立的“文档”，每个文档都以三个短横线开始：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, I need to find a way of reconstructing these arrays by reading in the
    data as two documents. This is where the `load_documents` method comes to the
    rescue. The `load_documents` method calls a block and passes to it each consecutive
    document. Here is an example of how to use this method in order to reconstruct
    two arrays (placed inside another array, `$new_arr`) from the two YAML documents:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要找到一种方法通过读取两个文档来重建这些数组。这就是`load_documents`方法发挥作用的地方。`load_documents`方法调用一个块，并将每个连续的文档传递给它。以下是如何使用此方法从两个YAML文档中重建两个数组（放置在另一个数组`$new_arr`中）的示例：
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can verify that `$new_arr` has been initialized with the two arrays by
    executing the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下操作来验证`$new_arr`是否已初始化为两个数组：
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This displays an array containing the loaded data in two nested arrays:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了包含加载数据的两个嵌套数组的数组：
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Because this is a bit unmanageable, you might prefer to display each of the
    nested arrays individually using an index into the outer array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这有点难以管理，你可能更喜欢使用外数组的索引来单独显示每个嵌套数组：
- en: '[PRE32]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The previous assumes that you know, in advance, the number of nested arrays
    available. Alternatively, here’s a more generic way of doing the same thing, using
    the `each` method to pass all available items into a block; this works with any
    number of arrays:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的假设是你事先知道可用的嵌套数组的数量。作为替代，这里有一个更通用的方法来做同样的事情，使用`each`方法将所有可用的项目传递到一个块中；这适用于任何数量的数组：
- en: '[PRE33]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A YAML Database
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML数据库
- en: 'For an example of a slightly more complicated application that saves and loads
    data in YAML format, take a look at the *cd_db.rb* sample program. This implements
    a simple CD database. It defines three types of CD objects: a basic `CD` that
    contains data on the name, artist, and number of tracks; and two more specialized
    descendants, `PopCD`, which adds data on the genre (for example, rock or country),
    and `ClassicalCD`, which adds data on the conductor and composer:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看一个稍微复杂一点的示例，该示例以YAML格式保存和加载数据，请查看*cd_db.rb*示例程序。它实现了一个简单的CD数据库。它定义了三种类型的CD对象：一个包含名称、艺术家和曲目数量的基本`CD`；以及两个更专业的派生对象，`PopCD`，它添加了关于流派（例如，摇滚或乡村）的数据，以及`ClassicalCD`，它添加了关于指挥家和作曲家的数据：
- en: '*cd_db.rb*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*cd_db.rb*'
- en: '[PRE34]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the program is run, the user can enter data to create new CD objects of
    any of these three types. There is also an option to save data to disk. When the
    application is run subsequently, the existing data is reloaded.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，用户可以输入数据以创建任何这三种类型的新的CD对象。还有一个选项可以将数据保存到磁盘上。当应用程序随后再次运行时，现有的数据将被重新加载。
- en: 'The data itself is organized very simply (trivially even) in the code, with
    the data for each object being read into an array before the object itself is
    created. The whole database of CD objects is saved into the global variable `$cd_arr`,
    and this is written to disk and reloaded into memory using YAML methods:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据本身在代码中组织得非常简单（甚至可以说是简单的），每个对象的数据在创建对象之前被读入一个数组。整个CD对象数据库被保存到全局变量`$cd_arr`中，并使用YAML方法写入磁盘并重新加载到内存中：
- en: '[PRE35]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Bear in mind that this program has been written for simplicity rather than beauty.
    In a real-world application, you would, I am sure, want to create somewhat more
    elegant data structures to manage your Dolly Parton collection!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个程序是为了简单而不是美观而编写的。在现实世界的应用中，你肯定希望创建一些更优雅的数据结构来管理你的Dolly Parton收藏！
- en: Adventures in YAML
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML冒险之旅
- en: As one final example of using YAML, I’ve provided an elementary framework for
    an adventure game (*gamesave_y.rb*). This creates some Treasure objects and some
    Room objects. The Treasure objects are put “into” the Room objects (that is, they
    are placed into arrays contained by the Rooms), and the Room objects are then
    put into a Map object. This has the effect of constructing a moderately complex
    data structure in which an object of one type (a Map) contains an arbitrary number
    of objects of another type (Rooms), each of which may contain zero or more objects
    of yet other types (Treasures).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 YAML 的最后一个示例，我提供了一个冒险游戏的基本框架（*gamesave_y.rb*）。这创建了一些宝藏对象和一些房间对象。宝藏对象被“放入”房间对象中（即，它们被放置在房间包含的数组中），然后房间对象被放入地图对象中。这相当于构建了一个中等复杂的数据结构，其中一个类型的对象（地图）包含任意数量的另一个类型的对象（房间），每个房间可能包含零个或多个其他类型的对象（宝藏）。
- en: At first sight, finding a way of storing this entire network of mixed object
    types to disk and reconstructing that network at a later stage might look like
    a programming nightmare. In fact, thanks to the serialization capabilities supplied
    by Ruby’s YAML library, saving and restoring this data could hardly be easier.
    This is because serialization relieves you of the chore of saving each object
    one by one. Instead, you have to “dump” only the top-level object; here, that
    is the Map object, `mymap`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，找到一种方法将整个混合对象类型的网络存储到磁盘上并在以后阶段重建这个网络可能看起来像是一个编程噩梦。实际上，多亏了 Ruby YAML 库提供的序列化功能，保存和恢复这些数据几乎可以轻松完成。这是因为序列化可以免除你逐个保存每个对象的麻烦。相反，你只需要“转储”顶层对象；在这里，即地图对象，`mymap`。
- en: 'When this is done, any objects that the top-level object “contains” (such as
    Rooms) or that the *contained* objects themselves contain (such as Treasures)
    are automatically saved for you. They can then be reconstructed just by loading
    all the saved data in a single operation and assigning it to the “top-level” object
    (here the map):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，顶层对象“包含”的任何对象（如房间）或包含的对象本身所包含的任何对象（如宝藏）都将自动为你保存。然后，只需通过一次性加载所有保存的数据并将其分配给“顶层”对象（在这里是地图）即可重新构建它们：
- en: '*gamesave_y.rb*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*gamesave_y.rb*'
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The full code of this program is too long to show here, so I suggest you try
    the program supplied in the source code archive in order to appreciate how simple
    it is to save and load a fairly complex data structure with YAML.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的完整代码太长，无法在此展示，所以我建议你尝试源代码存档中提供的程序，以欣赏使用 YAML 保存和加载相当复杂的数据结构是多么简单。
- en: Digging Deeper
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: This section summarizes the structure of a YAML datafile and explains how to
    save nested hashes in YAML format.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了 YAML 数据文件的结构，并解释了如何在 YAML 格式中保存嵌套哈希。
- en: A Brief Guide to YAML
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 指南简述
- en: 'As I mentioned earlier, YAML stores information in the form of chunks of text
    known as *documents* containing *sequences* of data. Each document begins with
    three hyphens (`---`), and each individual element in a list begins with a single
    hyphen (`-`) character. Here, for example, is a YAML datafile comprising one document
    and two list items:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，YAML 以称为 *documents* 的文本块的形式存储信息，这些文档包含数据的 *sequences*。每个文档以三个连字符（`---`）开始，列表中的每个单独元素都以单个连字符（`-`）字符开始。例如，以下是一个包含一个文档和两个列表项的
    YAML 数据文件：
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the previous example, you can see that each list item consists of two parts:
    a name such as `artist:` (which is the same in each list item) and a piece of
    data to its right, such as `Dolly Parton`, which may vary for each list item.
    These items are like the key-value pairs in a Ruby hash. YAML refers to key-value
    lists as *maps*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到每个列表项由两部分组成：一个名称，如 `artist:`（在列表项中相同），以及其右侧的数据，如 `Dolly Parton`，这可能因列表项而异。这些项类似于
    Ruby 哈希中的键值对。YAML 将键值列表称为 *maps*。
- en: 'The following is a YAML document containing a list of two items, each of which
    contains three items; in other words, it is the YAML representation of an array
    containing two three-item “nested” arrays:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含两个项目的 YAML 文档，每个项目包含三个项目；换句话说，它是包含两个三项目“嵌套”数组的数组的 YAML 表示：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let’s see how YAML would deal with nested hashes. Consider this hash:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 YAML 如何处理嵌套哈希。考虑这个哈希：
- en: '*hash_to_yaml.rb*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash_to_yaml.rb*'
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you’ve already seen, a hash is quite naturally represented in YAML as a
    list of key-value pairs. However, in the example shown previously, the *key* `:morefriends`
    is associated with a nested hash as its *value*. How does YAML represent that?
    It turns out that, as with arrays (see [Nested Sequences](ch14s02.html "Nested
    Sequences") in [Nested Sequences](ch14s02.html "Nested Sequences")), it simply
    indents the nested hash:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，在 YAML 中，哈希自然地表示为键值对列表。然而，在前面展示的示例中，键 `:morefriends` 与其值关联的是一个嵌套的哈希。YAML
    是如何表示这个嵌套哈希的呢？结果是，与数组（参见 [嵌套序列](ch14s02.html "嵌套序列")）一样，它只是简单地缩进嵌套的哈希：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For in-depth information on YAML, see [http://www.yaml.org/](http://www.yaml.org/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如需深入了解 YAML，请参阅 [http://www.yaml.org/](http://www.yaml.org/)。
- en: The YAML libraries supplied with Ruby are quite large and complex, and many
    more methods are available than have been described in this chapter. However,
    you should now have enough of an understanding of YAML to use it to good effect
    in your own programs. You may explore the outer reaches of the YAML libraries
    at your leisure. It turns out, though, that YAML is not the only way of serializing
    data in Ruby. You’ll be looking at another way in the next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 伴随的 YAML 库相当庞大且复杂，其中包含的方法比本章描述的要多得多。然而，您现在应该对 YAML 有足够的了解，可以在自己的程序中有效地使用它。您可以在空闲时间探索
    YAML 库的外围。不过，结果却是 YAML 并非在 Ruby 中序列化数据的唯一方式。您将在下一章中看到另一种方法。
