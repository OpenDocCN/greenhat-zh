- en: Chapter 14. YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At some point, most desktop applications are going to want to save and read
    structured data to and from disk. You’ve already seen how to read and write data
    using simple IO routines such as `gets` and `puts`. But how would you go about
    saving and restoring data from, say, lists of mixed object types? One simple way
    of doing this with Ruby is by using YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: YAML is an acronym that is (debatably) either short for Yet Another Markup Language
    or (recursively) for YAML Ain’t Markup Language.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'YAML defines a serialization (data-saving) format that stores information as
    human-readable text. YAML can be used with a variety of programming languages;
    in order to use it in Ruby, your code needs access to routines from Ruby’s *yaml.rb*
    file. Generally, this would be done by loading or “requiring” the file at the
    top of a code unit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done this, you will have access to a variety of methods to convert Ruby
    objects to the YAML format so that they can write their data to a file. Subsequently,
    you will be able to read back this saved data and use it to reconstruct Ruby objects.
    To convert an object to YAML format, you can use the `to_yaml` method. This will
    convert standard object types such as strings, integers, arrays, hashes, and so
    on. For example, this is how you would convert a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '*to_yaml1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how you would convert an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the YAML format that you would obtain as a result of this array conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice the three dashes that define the start of a new YAML “document” and the
    single dash that defines each new element in a list. In YAML terms, a document
    is not a separate file on disk but a separate YAML definition; one disk file may
    contain many YAML documents. For more information on the YAML format, refer to
    [Digging Deeper](ch14s07.html#digging_deeper-id13 "Digging Deeper") in [Digging
    Deeper](ch14s07.html#digging_deeper-id13 "Digging Deeper").
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also convert objects of nonstandard types to YAML. For example, let’s
    suppose you create this class and object:'
  prefs: []
  type: TYPE_NORMAL
- en: '*to_yaml2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML representation of this object will be preceded by the text `!ruby/object:`
    followed by the class name, the names of variables with a colon appended (but
    minus the `@`), and their values, one per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to print out the YAML representation of an object, you can use
    the method `y()`, which is a sort of YAML equivalent of the familiar `p()` method
    used to inspect and print normal Ruby objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*yaml_test1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You could similarly display a hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'in which case each key-value pair is placed onto a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ordering of hash elements may differ according to which version of Ruby
    you are using (see [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes")). It
    is best to assume no intrinsic order when working with a hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or you could display your own “custom” objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays data formatted, as in the earlier example where I used `to_yaml`,
    with the class name at the top and with pairs of variable names and values on
    successive lines. This is the YAML representation of a Treasure object containing
    the instance variables `@name` and `@value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even use `y()` to display quite complex objects such as nested arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '*yaml_test2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the YAML representation of `arr1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of an array containing objects of user-defined types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Nested Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When related sequences of data (such as arrays) are nested inside other sequences
    of data, this relationship is indicated by indentation. So, for example, let’s
    suppose you have this array declared in Ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: '*nested_arrays.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendered as YAML (for example, by `y( arr )`), this becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Saving YAML Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another handy way of turning your Ruby objects into YAML format is provided
    by the `dump` method. At its simplest, this converts your Ruby data into YAML
    format and “dumps” it into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '*yaml_dump1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'More usefully, the `dump` method can take a second argument, which is some
    kind of IO object, typically a file. You can open a file and dump data to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*yaml_dump2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can open the file (or some other type of IO object) and pass this into
    an associated block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In each case, the YAML representation of the data from the array will be saved,
    as plaintext, into the specified file. For example, when the previous code executes,
    it writes this text into the *morefriends.yml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '*morefriends.yml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use a block, the file will be closed automatically on exiting the block;
    otherwise, you should explicitly close the file using the `close` method. You
    can also use a block in a similar way to open a file and read in YAML data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming *morefriends.yml* contains the data saved earlier, once it is loaded
    and assigned to the global variable `$arr` in the block shown earlier, `$arr`
    will contain this array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Omitting Variables on Saving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If, for some reason, you want to omit some instance variables when serializing
    objects, you can do so by defining a method named `to_yaml_properties`. In the
    body of this method, place an array of strings. Each string should match the name
    of the instance variable to be saved. Any variables that are not specified will
    not be saved. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*limit_y.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here `to_yaml_properties` limits the variables that will be saved when you call
    `YAML.dump` to `@num` and `@arr`. The string variable, `@str`, will not be saved.
    If you want to reconstruct the objects based on the saved YAML data, it is your
    responsibility to ensure that any “missing” variables are either not needed (in
    which case they may be ignored) or, if they are needed, that they are initialized
    with some meaningful value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Multiple Documents, One File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, I mentioned that three dashes are used to mark the start of a new
    YAML section known as a *document*. For example, let’s assume you want to save
    two arrays, `arr1` and `arr2`, to a file, *multidoc.yml*. Here `arr1` is an array
    containing two nested arrays, and `arr2` is an array containing two CD objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_docs.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is my routine to dump these arrays to YAML and write them to a file (as
    explained in [Chapter 13](ch13.html "Chapter 13. Files and IO"), the `''w''` argument
    causes the file to be opened for writing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now look at the file *multidoc.yml*, you’ll see that the data has been
    saved as two separate “documents,” each one beginning with three dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I need to find a way of reconstructing these arrays by reading in the
    data as two documents. This is where the `load_documents` method comes to the
    rescue. The `load_documents` method calls a block and passes to it each consecutive
    document. Here is an example of how to use this method in order to reconstruct
    two arrays (placed inside another array, `$new_arr`) from the two YAML documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that `$new_arr` has been initialized with the two arrays by
    executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays an array containing the loaded data in two nested arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this is a bit unmanageable, you might prefer to display each of the
    nested arrays individually using an index into the outer array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous assumes that you know, in advance, the number of nested arrays
    available. Alternatively, here’s a more generic way of doing the same thing, using
    the `each` method to pass all available items into a block; this works with any
    number of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A YAML Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For an example of a slightly more complicated application that saves and loads
    data in YAML format, take a look at the *cd_db.rb* sample program. This implements
    a simple CD database. It defines three types of CD objects: a basic `CD` that
    contains data on the name, artist, and number of tracks; and two more specialized
    descendants, `PopCD`, which adds data on the genre (for example, rock or country),
    and `ClassicalCD`, which adds data on the conductor and composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cd_db.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When the program is run, the user can enter data to create new CD objects of
    any of these three types. There is also an option to save data to disk. When the
    application is run subsequently, the existing data is reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data itself is organized very simply (trivially even) in the code, with
    the data for each object being read into an array before the object itself is
    created. The whole database of CD objects is saved into the global variable `$cd_arr`,
    and this is written to disk and reloaded into memory using YAML methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that this program has been written for simplicity rather than beauty.
    In a real-world application, you would, I am sure, want to create somewhat more
    elegant data structures to manage your Dolly Parton collection!
  prefs: []
  type: TYPE_NORMAL
- en: Adventures in YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As one final example of using YAML, I’ve provided an elementary framework for
    an adventure game (*gamesave_y.rb*). This creates some Treasure objects and some
    Room objects. The Treasure objects are put “into” the Room objects (that is, they
    are placed into arrays contained by the Rooms), and the Room objects are then
    put into a Map object. This has the effect of constructing a moderately complex
    data structure in which an object of one type (a Map) contains an arbitrary number
    of objects of another type (Rooms), each of which may contain zero or more objects
    of yet other types (Treasures).
  prefs: []
  type: TYPE_NORMAL
- en: At first sight, finding a way of storing this entire network of mixed object
    types to disk and reconstructing that network at a later stage might look like
    a programming nightmare. In fact, thanks to the serialization capabilities supplied
    by Ruby’s YAML library, saving and restoring this data could hardly be easier.
    This is because serialization relieves you of the chore of saving each object
    one by one. Instead, you have to “dump” only the top-level object; here, that
    is the Map object, `mymap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this is done, any objects that the top-level object “contains” (such as
    Rooms) or that the *contained* objects themselves contain (such as Treasures)
    are automatically saved for you. They can then be reconstructed just by loading
    all the saved data in a single operation and assigning it to the “top-level” object
    (here the map):'
  prefs: []
  type: TYPE_NORMAL
- en: '*gamesave_y.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The full code of this program is too long to show here, so I suggest you try
    the program supplied in the source code archive in order to appreciate how simple
    it is to save and load a fairly complex data structure with YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: This section summarizes the structure of a YAML datafile and explains how to
    save nested hashes in YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: A Brief Guide to YAML
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, YAML stores information in the form of chunks of text
    known as *documents* containing *sequences* of data. Each document begins with
    three hyphens (`---`), and each individual element in a list begins with a single
    hyphen (`-`) character. Here, for example, is a YAML datafile comprising one document
    and two list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, you can see that each list item consists of two parts:
    a name such as `artist:` (which is the same in each list item) and a piece of
    data to its right, such as `Dolly Parton`, which may vary for each list item.
    These items are like the key-value pairs in a Ruby hash. YAML refers to key-value
    lists as *maps*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a YAML document containing a list of two items, each of which
    contains three items; in other words, it is the YAML representation of an array
    containing two three-item “nested” arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see how YAML would deal with nested hashes. Consider this hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_to_yaml.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve already seen, a hash is quite naturally represented in YAML as a
    list of key-value pairs. However, in the example shown previously, the *key* `:morefriends`
    is associated with a nested hash as its *value*. How does YAML represent that?
    It turns out that, as with arrays (see [Nested Sequences](ch14s02.html "Nested
    Sequences") in [Nested Sequences](ch14s02.html "Nested Sequences")), it simply
    indents the nested hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For in-depth information on YAML, see [http://www.yaml.org/](http://www.yaml.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The YAML libraries supplied with Ruby are quite large and complex, and many
    more methods are available than have been described in this chapter. However,
    you should now have enough of an understanding of YAML to use it to good effect
    in your own programs. You may explore the outer reaches of the YAML libraries
    at your leisure. It turns out, though, that YAML is not the only way of serializing
    data in Ruby. You’ll be looking at another way in the next chapter.
  prefs: []
  type: TYPE_NORMAL
