["```\nsolveRPN :: String -> Double\n```", "```\n[\"10\",\"4\",\"3\",\"+\",\"2\",\"*\",\"-\"].\n```", "```\nsolveRPN :: String -> Double\nsolveRPN expression = head (foldl foldingFunction [] (words expression))\n    where  foldingFunction stack item = ...\n```", "```\nsolveRPN :: String -> Double\nsolveRPN = head . foldl foldingFunction [] . words\n    where  foldingFunction stack item = ...\n```", "```\nsolveRPN :: String -> Double\nsolveRPN = head . foldl foldingFunction [] . words\n    where  foldingFunction (x:y:ys) \"*\" = (y * x):ys\n           foldingFunction (x:y:ys) \"+\" = (y + x):ys\n           foldingFunction (x:y:ys) \"-\" = (y - x):ys\n           foldingFunction xs numberString = read numberString:xs\n```", "```\nghci> solveRPN \"10 4 3 + 2 * -\"\n-4.0\nghci> solveRPN \"2 3.5 +\"\n5.5\nghci> solveRPN \"90 34 12 33 55 66 + * - +\"\n-3947.0\nghci> solveRPN \"90 34 12 33 55 66 + * - + -\"\n4037.0\nghci> solveRPN \"90 3.8 -\"\n86.2\n```", "```\nsolveRPN :: String -> Double\nsolveRPN = head . foldl foldingFunction [] . words\n    where  foldingFunction (x:y:ys) \"*\" = (y * x):ys\n           foldingFunction (x:y:ys) \"+\" = (y + x):ys\n           foldingFunction (x:y:ys) \"-\" = (y - x):ys\n           foldingFunction (x:y:ys) \"/\" = (y / x):ys\n           foldingFunction (x:y:ys) \"^\" = (y ** x):ys\n           foldingFunction (x:xs) \"ln\" = log x:xs\n           foldingFunction xs \"sum\" = [sum xs]\n           foldingFunction xs numberString = read numberString:xs\n```", "```\nghci> solveRPN \"2.7 ln\"\n0.9932517730102834\nghci> solveRPN \"10 10 10 10 sum 4 /\"\n10.0\nghci> solveRPN \"10 10 10 10 10 sum 4 /\"\n12.5\nghci> solveRPN \"10 2 ^\"\n100.0\n```", "```\n50\n10\n30\n5\n90\n20\n40\n2\n25\n10\n8\n0\n```", "```\ndata Section = Section { getA :: Int, getB :: Int, getC :: Int }\n    deriving (Show)\n\ntype RoadSystem = [Section]\n```", "```\nheathrowToLondon :: RoadSystem\nheathrowToLondon = [ Section 50 10 30\n                   , Section 5 90 20\n                   , Section 40 2 25\n                   , Section 10 8 0\n                   ]\n```", "```\ndata Label = A | B | C deriving (Show)\ntype Path = [(Label, Int)]\n```", "```\noptimalPath :: RoadSystem -> Path\n```", "```\n[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8)]\n```", "```\nroadStep :: (Path, Path) -> Section -> (Path, Path)\n```", "```\nroadStep :: (Path, Path) -> Section -> (Path, Path)\nroadStep (pathA, pathB) (Section a b c) =\n    let timeA = sum (map snd pathA)\n        timeB = sum (map snd pathB)\n        forwardTimeToA = timeA + a\n        crossTimeToA = timeB + b + c\n        forwardTimeToB = timeB + b\n        crossTimeToB = timeA + a + c\n        newPathToA = if forwardTimeToA <= crossTimeToA\n                        then (A, a):pathA\n                        else (C, c):(B, b):pathB\n        newPathToB = if forwardTimeToB <= crossTimeToB\n                        then (B, b):pathB\n                        else (C, c):(A, a):pathA\n    in  (newPathToA, newPathToB)\n```", "```\nghci> roadStep ([], []) (head heathrowToLondon)\n([(C,30),(B,10)],[(B,10)])\n```", "```\noptimalPath :: RoadSystem -> Path\noptimalPath roadSystem =\n    let (bestAPath, bestBPath) = foldl roadStep ([], []) roadSystem\n    in  if sum (map snd bestAPath) <= sum (map snd bestBPath)\n            then reverse bestAPath\n            else reverse bestBPath\n```", "```\nghci> optimalPath heathrowToLondon\n[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8),(C,0)]\n```", "```\ngroupsOf :: Int -> [a] -> [[a]]\ngroupsOf 0 _ = undefined\ngroupsOf _ [] = []\ngroupsOf n xs = take n xs : groupsOf n (drop n xs)\n```", "```\n[[1,2,3],[4,5,6],[7,8,9],[10]]\n```", "```\n[1,2,3] : groupsOf 3 [4,5,6,7,8,9,10]\n```", "```\nimport Data.List\n\nmain = do\n    contents <- getContents\n    let threes = groupsOf 3 (map read $ lines contents)\n        roadSystem = map (\\[a,b,c] -> Section a b c) threes\n        path = optimalPath roadSystem\n        pathString = concat $ map (show . fst) path\n        pathTime = sum $ map snd path\n    putStrLn $ \"The best path to take is: \" ++ pathString\n    putStrLn $ \"Time taken: \" ++ show pathTime\n```", "```\n50\n10\n30\n5\n90\n20\n40\n2\n25\n10\n8\n0\n```", "```\n$ runhaskell heathrow.hs < paths.txt\nThe best path to take is: BCACBBC\nTime taken: 75\n```", "```\n$ ghc --make -O heathrow.hs\n```"]