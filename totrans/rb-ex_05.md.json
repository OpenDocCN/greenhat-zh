["```\nirb(main):001:0> 2 ** 2    *Exponentiation*\n=> 4\nirb(main):002:0> 2 ** 3\n=> 8\n```", "```\nirb(main):003:0> 2 ** (1 + 2)\n=> 8\nirb(main):004:0> 8 ** (1.0/3.0)\n=> 2.0\n```", "```\n  #!/usr/bin/env ruby\n  # power_of.rb\n\n  class Integer\n\n  =begin rdoc\n  Add a simple <b>Integer</b>-only method that reports the\n  exponent to which the base must be raised to get self.\n  =end\n❶   def power_of(base)    *Recursion*\n      # return nil for inapplicable situations\n      return nil   unless base.is_a?(Integer)    *The **`is_a?`** Method*\n❷     return nil   if (base.zero? and not [0,1].include?(self))\n\n      # deal with odd but reasonable\n      # numeric situations\n❸     return 1     if base == self\n❹     return 0     if self == 1\n❺     return false if base == 1\n❻     return false if base.abs > self.abs    *The **`abs`** Method*\n\n❼     exponent = (self/base).power_of(base)\n❽     return exponent ? exponent + 1 : exponent\n    end\n\n  end\n```", "```\nirb(main):005:0> (42 * 1) == (1 * 42)\n=> true\nirb(main):006:0> (1 * 42) == (42 * 1)\n=> true\nirb(main):007:0> (42 * 1) == 42\n=> true\nirb(main):008:0> (1 * 42) == 42\n=> true\n```", "```\nirb(main):009:0> 3 ** 3\n=> 27\nirb(main):010:0> 3 ** 2\n=> 9\nirb(main):011:0> 27 == 9 * 3\n=> true\n```", "```\n$ irb -r power_of.rb\nirb(main):001:0> 1.power_of(1)\n=> 1\nirb(main):002:0> 1.power_of(2)\n=> 0\nirb(main):003:0> 4.power_of(2)\n=> 2\nirb(main):004:0> 2.power_of(4)\n=> false\n```", "```\nirb(main):001:0> Integer.ancestors    *The **`ancestors`** Method*\n=> [Integer, Precision, Numeric, Comparable, Object, Kernel]\nirb(main):002:0> Float.ancestors\n=> [Float, Precision, Numeric, Comparable, Object, Kernel]\nirb(main):003:0>\n```", "```\nirb(main):003:0> Integer.class\n=> Class\nirb(main):004:0> Float.class\n=> Class\nirb(main):005:0> Precision.class\n=> Module\n```", "```\n  module Precision    *Modules*\n\n❶   # What character should be displayed at each breakpoint?\n    COMMIFY_DELIMITER = ','\n\n    # What should the decimal point character be?\n    COMMIFY_DECIMAL = '.'\n\n    # What power of 10 defines each breakpoint?\n    COMMIFY_BREAKPOINT = 3\n\n    # Should an explicit '0' be shown in the 100ths place,\n    # such as for currency?\n    COMMIFY_PAD_100THS = true\n\n  =begin rdoc\n  This method returns a <b>String</b> representing the numeric value of\n  self, with delimiters at every digit breakpoint. 4 Optional arguments:\n\n  1\\. delimiter (<b>String</b>): defaults to a comma\n  2\\. breakpoint (<b>Integer</b>): defaults to 3, showing every multiple of 1000\n  3\\. decimal_pt (<b>String</b>): defaults to '.'\n  4\\. show_hundredths (<b>Boolean</b>): whether an explicit '0' should be shown\n  in the hundredths place, defaulting to <b>true</b>.\n  =end\n❷   def commify(args = {})    *Optional Arguments*\n\n❸     args[:delimiter]       ||= COMMIFY_DELIMITER\n      args[:breakpoint]      ||= COMMIFY_BREAKPOINT\n      args[:decimal_pt]      ||= COMMIFY_DECIMAL\n      args[:show_hundredths] ||= COMMIFY_PAD_100THS\n\n❹     int_as_string, float_as_string = to_s.split('.')\n\n      int_out = format_int(\n        int_as_string,\n        args[:breakpoint],\n        args[:delimiter]\n      )\n\n      float_out = format_float(\n        float_as_string,\n        args[:decimal_pt],\n        args[:show_hundredths]\n      )\n\n❺     return int_out + float_out\n    end\n\n    private\n\n  =begin rdoc\n  Return a <b>String</b> representing the properly-formatted\n  <b>Integer</b> portion of self.\n  =end\n❻   def format_int(int_as_string, breakpoint, delimiter)\n      reversed_groups = int_as_string.reverse.split(/(\\d{#{breakpoint}})/)\n      reversed_digits = reversed_groups.grep(/\\d+/)\n      digit_groups = reversed_digits.reverse.map { |unit| unit.reverse }\n      return digit_groups.join(delimiter)\n    end\n  =begin rdoc\n  Return a <b>String</b> representing the properly-formatted\n  floating-point portion of self.\n  =end\n❼   def format_float(float_as_string, decimal_pt, show_hundredths)\n      return ''unless float_as_string\n      output = decimal_pt + float_as_string\n❽     return output unless show_hundredths\n❾     output += '0' if (float_as_string.size == 1)\n      return output\n    end\n\n  end\n```", "```\nirb(main):001:0> int_as_string = '186282'\n=> \"186282\"\nirb(main):002:0> breakpoint = 3\n=> 3\nirb(main):003:0> delimiter = ','\n=> \",\"\n```", "```\nirb(main):004:0> reversed_groups = int_as_string.reverse.split(/(\\d{#{breakpoint}})/)\n=> [\"\", \"282\", \"\", \"681\"]\n```", "```\nirb(main):005:0> reversed_digits = reversed_groups.grep(/\\d+/)\n=> [\"282\", \"681\"]\n```", "```\nirb(main):006:0> reversed_digits.reverse\n=> [\"681\", \"282\"]\n```", "```\nirb(main):007:0> reversed_digits.map { |unit| unit.reverse }\n=> [\"282\", \"186\"]\n```", "```\nirb(main):008:0> digit_groups = reversed_digits.reverse.map { |unit| unit.reverse }\n=> [\"186\", \"282\"]\n```", "```\nirb(main):009:0> digit_groups.join(delimiter)\n=> \"186,282\"\n```", "```\n#!/usr/bin/env ruby\n# test_commify.rb\n\nrequire 'commify'\n\nputs ARGV[0].to_f.commify()\nalt_args = {\n    :breakpoint => 2,\n    :decimal_pt => 'dp',\n    :show_hundredths => false\n}\nputs ARGV[0].to_f.commify(alt_args)\n```", "```\n186,282.437\n18,62,82dp437\n```", "```\n$ irb -r roman_numeral.rb\nirb(main):001:0> 42.to_roman\n=> \"XLII\"\nirb(main):002:0> 1.to_roman\n=> \"I\"\nirb(main):003:0> 5.to_roman\n=> \"V\"\nirb(main):004:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):005:0> digits.map { |d| d.to_roman }\n=> [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n```", "```\n  class Integer\n\n    # Base conversion Hash\n❶   ARABIC_TO_ROMAN = {\n      1000 => 'M',\n       500 => 'D',\n       100 => 'C',\n        50 => 'L',\n        10 => 'X',\n         5 => 'V',\n         1 => 'I',\n         0 => '',\n    }\n\n    # Represent 4 as 'IV', rather than 'IIII'?\n    SUBTRACTIVE_TO_ROMAN = {\n       900 => 'CM',\n       400 => 'CD',\n        90 => 'XC',\n        40 => 'XL',\n         9 => 'IX',\n         4 => 'IV',\n    }\n\n    # Use SUBTRACTIVE_TO_ROMAN Hash?\n    SUBTRACTIVE = true\n\n❷   def to_roman()\n      @@roman_of ||= create_roman_of()    *Class Variables*\n❸     return ''unless (self > 0)\n❹     return to_s if self > maximum_representable()\n❺     base = @@roman_of.keys.sort.reverse.detect { |k| k <= self }    *The **`detect`** Method*\n❻     return '' unless (base and base > 0)\n❼     return (@@roman_of[base] * round_to_base(base)) + (self % base).to_roman()\n    end\n\n    private\n  =begin rdoc\n  Use constants to create a <b>Hash</b> of appropriate roman numeral values.\n  =end\n❽   def create_roman_of()\n      return ARABIC_TO_ROMAN unless SUBTRACTIVE\n      ARABIC_TO_ROMAN.merge(SUBTRACTIVE_TO_ROMAN)    *The **`merge`** Method*\n    end\n\n  =begin rdoc\n  What is the largest number that this method can reasonably represent?\n  =end\n   def maximum_representable()\n❾    (@@roman_of.keys.max * 5) - 1\n   end\n\n❿  def round_to_base(base)\n     (self - (self % base)) / base\n   end\n\n end\n```", "```\nirb(main):001:0> class String\nirb(main):002:1> @@class_var = \"I'm a Class Variable.\"\nirb(main):003:1> def cv\nirb(main):004:2> @@class_var\nirb(main):005:2> end\nirb(main):006:1> end\n=> nil\nirb(main):007:0> ''.cv\n=> \"I'm a Class Variable.\"\nirb(main):008:0> 'Some other String'.cv\n=> \"I'm a Class Variable.\"\nirb(main):009:0> 'Yet another String.'.cv\n=> \"I'm a Class Variable.\"\n```", "```\nirb(main):001:0> hash1 = { 'key1' => 'value1', 'key2' => 'value2' }\n=> {\"key1\"=>\"value1\", \"key2\"=>\"value2\"}\nirb(main):002:0> hash2 = { 'key3' => 'value3', 'key4' => 'value4' }\n=> {\"key3\"=>\"value3\", \"key4\"=>\"value4\"}\nirb(main):003:0> hash1\n=> {\"key1\"=>\"value1\", \"key2\"=>\"value2\"}\nirb(main):004:0> hash2\n=> {\"key3\"=>\"value3\", \"key4\"=>\"value4\"}\nirb(main):005:0> hash1.merge(hash2)\n=> {\"key1\"=>\"value1\", \"key2\"=>\"value2\", \"key3\"=>\"value3\", \"key4\"=>\"value4\"}\nirb(main):006:0> hash3 = { 'key1' => nil }\n=> {\"key1\"=>nil}\nirb(main):007:0> hash1.merge(hash2).merge(hash3)\n=> {\"key1\"=>nil, \"key2\"=>\"value2\", \"key3\"=>\"value3\", \"key4\"=>\"value4\"}\n```", "```\nirb(main):001:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):002:0> digits.map { |d| (4995+d).to_roman }\n=> [\"MMMMCMXCV\", \"MMMMCMXCVI\", \"MMMMCMXCVII\", \"MMMMCMXCVIII\", \"MMMMCMXCIX\",\n\"5000\", \"5001\", \"5002\", \"5003\", \"5004\"]\n```", "```\nirb(main):001:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):002:0> digits.detect { |d| d % 3 }\n=> 0\nirb(main):003:0> digits.reverse.detect { |d| d % 3 }\n=> 9\nirb(main):004:0> digits.detect { |d| d > 4 }\n=> 5\nirb(main):005:0> digits.reverse.detect { |d| d % 2 == 1 }\n=> 9\n```", "```\nirb(main):006:0> 'M' * 2\n=> \"MM\"\n```", "```\n$ irb -r roman_numeral.rb\nirb(main):001:0> (0..9).to_a.map { |n| n.to_roman }\n```", "```\n=> [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n```", "```\n  irb(main):001:0> cc = CurrencyConverter.new()\n  => #<CurrencyConverter:0xb7c979f4 @name_of={\"USD\"=>\"US Dollar\"},\n  @base_currency=\"USD\">\n❶ irb(main):002:0> puts cc.output_rates(1)\n  1 US Dollar (USD) =\n          46.540136 Indian Rupees(INR)\n          0.781738 Euros(EUR)\n          10.890852 Mexican Pesos(MXN)\n          7.977233 Chinese Yuans(CNY)\n          1.127004 Canadian Dollars(CAD)\n  => nil\n❷ irb(main):003:0> puts cc.output_rates(42)\n  42 US Dollars (USD) =\n          1954.685712 Indian Rupees(INR)\n          32.832996 Euros(EUR)\n          457.415784 Mexican Pesos(MXN)\n          335.043786 Chinese Yuans(CNY)\n          47.334168 Canadian Dollars(CAD)\n  => nil\n```", "```\n  #!/usr/bin/env ruby\n  # currency_converter1.rb\n  # Using fixed exchange rates\n\n  class CurrencyConverter\n\n❶   BASE_ABBR_AND_NAME = { 'USD' => 'US Dollar' }\n\n    FULLNAME_OF = {\n      'EUR' => 'Euro',\n      'CAD' => 'Canadian Dollar',\n      'CNY' => 'Chinese Yuan',\n      'INR' => 'Indian Rupee',\n      'MXN' => 'Mexican Peso',\n    }\n\n    EXCHANGE_RATES = {\n      'EUR' => 0.781738,\n      'INR' => 46.540136,\n      'CNY' => 7.977233,\n      'MXN' => 10.890852,\n      'CAD' => 1.127004,\n    }\n\n❷   def initialize()    *Initializing Class Variables*\n      @base_currency = BASE_ABBR_AND_NAME.keys[0] \n      @name          = BASE_ABBR_AND_NAME[@base_currency]\n    end\n\n❸   def output_rates(mult=1)\n      get_value(mult, get_rates) + \"\\n\"\n    end\n\n    private\n\n❹   def get_rates()\n      return EXCHANGE_RATES\n    end\n\n❺   def get_value(mult, rates)\n❻     return pluralize(mult, @name) +\n      \" (#{@base_currency}) = \\n\" +\n❼     rates.keys.map do |abbr|\n❽       \"\\t\" +\n        pluralize(mult * rates[abbr], FULLNAME_OF[abbr]) +\n        \"(#{abbr})\"\n❾     end.join(\"\\n\")\n    end\n\n  =begin rdoc\n  This assumes that all plurals will be formed by adding an 's'.\n  It could be made more flexible with a Hash of plural suffixes\n  (which could be the empty string) or explicit plural forms that\n  are simple replacements for the singular.\n\n  For convenience, this outputs a string with the number of items,\n  a space, and then the pluralized form of the currency unit.\n  That suited the needs of this particular script.\n  =end\n❿   def pluralize(num, term)\n      (num == 1) ? \"#{num} #{term}\" : \"#{num} #{term}s\"\n    end\n\n  end\n```", "```\n$ irb -r currency_converter1.rb\nirb(main):001:0> cc = CurrencyConverter.new()\n=> #<CurrencyConverter:0xb7c94b4c @base_currency=\"USD\", @name=\"US Dollar\">\nirb(main):002:0> cc.output_rates\n=> \"1 US Dollar (USD) = \\n\\t46.540136 Indian Rupees(INR)\\n\\t0.781738\nEuros(EUR)\\n\\t10.890852 Mexican Pesos(MXN)\\n\\t7.977233 Chinese Yuans(CNY)\\n\\\nt1.127004 Canadian Dollars(CAD)\\n\"\nirb(main):003:0> puts cc.output_rates\n1 US Dollar (USD) =\n        46.540136 Indian Rupees(INR)\n        0.781738 Euros(EUR)\n        10.890852 Mexican Pesos(MXN)\n        7.977233 Chinese Yuans(CNY)\n        1.127004 Canadian Dollars(CAD)\n=> nil\n```", "```\n  #!/usr/bin/env ruby\n  # currency_converter2.rb\n\n  ### RSS feeds for rates at\n  # http://www.currencysource.com/rss_currencyexchangerates.html\n\n  =begin rdoc\n  open-uri allows Kernel.open to read data using a URI, not just from\n  a local file.\n  =end\n❶ require 'open-uri'\n  =begin rdoc\n  YAML[http://www.yaml.org] stands for \"YAML Ain't Markup Language\"\n  and is a simple human-readable data markup format.\n  =end\n  require 'yaml'    *YAML*\n\n  =begin rdoc\n  I also want to add a method to all <b>Hash</b>es.\n  =end\n  class Hash\n\n  =begin rdoc\n  Allow <b>Hash</b>es to be subtracted from each other.\n  =end\n❷   def -(hash_with_pairs_to_remove_from_self)    *A Subtraction Method for Hashes; The **`delete`** Method*\n      output = self.dup\n      hash_with_pairs_to_remove_from_self.each_key do |k|\n        output.delete(k)\n      end\n      output\n    end\n\n  end\n\n❸ class CurrencyConverter\n\n    BASE_URL = 'http://currencysource.com/RSS'\n    CURRENCY_CODES = {\n      'EUR' => 'Euro',\n      'CAD' => 'Canadian Dollar',\n      'CNY' => 'Chinese Yuan',\n      'INR' => 'Indian Rupee',\n      'MXN' => 'Mexican Peso',\n      'USD' => 'US Dollar',\n    }\n    RATES_DIRECTORY = 'extras/currency_exchange_rates'\n\n    def initialize(code='USD')    *The `has_key?` and `fail` Methods*\n      unless CURRENCY_CODES.has_key?(code)\n        fail \"I know nothing about #{code}\"\n      end\n      @base_currency = code\n      @name          = CURRENCY_CODES[code]\n    end\n\n❹   def output_rates(mult=1, try_new_rates=true)\n      rates = get_rates(try_new_rates)\n      save_rates_in_local_file!(rates)\n      return get_value(mult, rates) + \"\\n\"\n    end\n\n    private\n\n❺   def download_new_rates()\n      puts 'Downloading new exchange rates...'\n      begin    ***`begin - rescue - end`***\n        raw_rate_lines = get_xml_lines()\n      rescue\n        puts 'Download failed. Falling back to local file.'\n        return nil\n      end\n      rates = Hash.new('')\n      comparison_codes = CURRENCY_CODES - { @base_currency => @name }\n      comparison_codes.each_key do |abbr|\n        rates[abbr] = get_rate_for_abbr_from_raw_rate_lines(\n          abbr,\n          raw_rate_lines\n        )\n      end\n      return rates\n    end\n\n❻   def get_rates(try_new_rates)\n      return load_old_rates unless try_new_rates\n      return download_new_rates || load_old_rates\n    end\n\n    def get_rate_for_abbr_from_raw_rate_lines(abbr, raw_rate_lines)\n      regex = {\n        :open =>\n          /^\\<title\\>1 #{@base_currency} = #{abbr} \\(/,\n        :close =>\n          /\\)\\<\\/title\\>\\r\\n$/\n      }\n      line = raw_rate_lines.detect { |line| line =~ /#{abbr}/ }\n      line.gsub(regex[:open], '').gsub(regex[:close], '').to_f\n    end\n\n    def get_value(mult, rates)\n      return \"#{pluralize(mult, @name)} (#{@base_currency}) = \\n\" +\n        rates.keys.map do |abbr|\n          \"\\t#{pluralize(mult * rates[abbr], CURRENCY_CODES[abbr])} (#{abbr})\"\n        end.join(\"\\n\")\n    end\n  =begin rdoc\n  get_xml_lines is able to read from a URI with the open-uri library.\n  This also could have been implemented with the RSS library\n  written by Kouhei Sutou <kou@cozmixng.org> and detailed at\n  http://www.cozmixng.org/~rwiki/?cmd=view;name=RSS+Parser%3A%3ATutorial.en\n  =end\n❼   def get_xml_lines()    *XML*\n      open(\"#{BASE_URL}/#{@base_currency}.xml\").readlines.find_all do |line|\n        line =~ /1 #{@base_currency} =/\n      end\n    end\n\n❽   def load_old_rates()\n      puts \"Reading stored exchange rates from local file #{rates_filename()}\"\n      rates = YAML.load(File.open(rates_filename))    ***`YAML.load`***\n      fail 'no old rates' unless rates\n      return rates\n    end\n\n    def pluralize(num, term)\n      (num == 1) ? \"#{num} #{term}\" : \"#{num} #{term}s\"\n    end\n\n❾   def rates_filename()\n      \"#{RATES_DIRECTORY}/#{@base_currency}.yaml\"\n    end\n\n  =begin rdoc\n  Store new rates in an external YAML file.\n  This is a side-effect akin to memoization, hence the bang.\n  =end\n❿   def save_rates_in_local_file!(rates)\n      return unless rates\n      File.open(rates_filename, 'w') { |rf| YAML.dump(rates, rf) }    ***`YAML.dump`***\n    end\n\n  end\n```", "```\n<item>\n<title>1 USD = ARS (3.017607)</title>\n<link>http://www.currencysource.com/tables/USD/1X_USD.htm</link>\n<description><![CDATA[As of Thursday, May 04, 2006...<br>1 U.S. Dollar (USD) =\n3.017607 Argentine Peso (ARS)<br><br>Call 1-877-627-4817 for 'LIVE'\nassistance.<br><br>Source: IMF<br><br>Aggregated and published by\nCurrencySource.com<br>'Rated #1 in Currency Exchange']]></description>\n<pubDate>Sun, 08 Oct 2006 06:00:04 CST</pubDate>\n</item>\n<item>\n<title>1 USD = AUD (1.342818)</title>\n<link>http://www.currencysource.com/tables/USD/1X_USD.htm</link>\n<description><![CDATA[As of Sunday, October 08, 2006...<br>1 U.S. Dollar (USD)\n= 1.342818 Australian Dollar (AUD)<br><br>Call 1-877-627-4817 for 'LIVE'\nassistance.<br><br>Source: IMF<br><br>Aggregated and published by\nCurrencySource.com<br>'Rated #1 in Currency Exchange']]></description>\n<pubDate>Sun, 08 Oct 2006 06:00:04 CST</pubDate>\n</item>\n```", "```\n---\nEUR: 0.789639\nINR: 45.609987\nCNY: 7.890017\nMXN: 11.062366\nCAD: 1.126398\n```", "```\n  irb(main):001:0> usd = CurrencyConverter.new\n  => #<CurrencyConverter:0xb7bfb498 @name=\"US Dollar\", @base_currency=\"USD\">\n  irb(main):002:0> inr = CurrencyConverter.new('INR')\n  => #<CurrencyConverter:0xb7bef990 @name=\"Indian Rupee\", @base_currency=\"INR\">\n  irb(main):003:0> usd.output_rates(1)\n  Downloading new exchange rates...\n  => \"1 US Dollar (USD) = \\n\\t45.609987 Indian Rupees (INR)\\n\\t0.789639 Euros\n  (EUR)\\n\\t11.062366 Mexican Pesos (MXN)\\n\\t7.890017 Chinese Yuans (CNY)\\n\\\n  t1.126398 Canadian Dollars (CAD)\\n\"\n  irb(main):004:0> inr.output_rates(1)\n  Downloading new exchange rates...\n  => \"1 Indian Rupee (INR) = \\n\\t0.017313 Euros (EUR)\\n\\t0.242543 Mexican Pesos\n  (MXN)\\n\\t0.172989 Chinese Yuans (CNY)\\n\\t0.021925 US Dollars (USD)\\n\\t0.024696\n  Canadian Dollars (CAD)\\n\"\n  irb(main):005:0> usd.output_rates(1, false)\n  Reading stored exchange rates from local file extras/currency_exchange_rates/USD.yaml\n  => \"1 US Dollar (USD) = \\n\\t0.789639 Euros (EUR)\\n\\t45.609987 Indian Rupees \n  (INR)\\n\\t7.890017 Chinese Yuans (CNY)\\n\\t11.062366 Mexican Pesos (MXN)\\n\\\n  t1.126398 Canadian Dollars (CAD)\\n\"\n  irb(main):006:0> inr.output_rates(100, false)\n  Reading stored exchange rates from local file extras/currency_exchange_rates/\n  INR.yaml\n  => \"100 Indian Rupees (INR) = \\n\\t1.7313 Euros (EUR)\\n\\t17.2989 Chinese Yuans \n  (CNY)\\n\\t24.2543 Mexican Pesos (MXN)\\n\\t2.4696 Canadian Dollars (CAD)\\n\\\n  t2.1925 US Dollars (USD)\\n\"\n❶ irb(main):007:0> inr.output_rates(100, (not true))\n  Reading stored exchange rates from local file extras/currency_exchange_rates/\n  INR.yaml\n  => \"100 Indian Rupees (INR) = \\n\\t1.7313 Euros (EUR)\\n\\t24.2543 Mexican Pesos\n  (MXN)\\n\\t17.2989 Chinese Yuans (CNY)\\n\\t2.1925 US Dollars (USD)\\n\\t2.4696\n  Canadian Dollars (CAD)\\n\"\n```"]