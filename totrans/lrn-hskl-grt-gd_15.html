<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;Zippers"><div class="titlepage"><div><div><h1 class="title"><a id="zippers"/>Chapter 15. Zippers</h1></div></div></div><p>While Haskell’s purity comes with a whole bunch of benefits, it makes us tackle some problems differently than we would in impure languages.<a id="IDX-CHP-15-0001" class="indexterm"/></p><p>Because of referential transparency, one value is as good as another in Haskell if it represents the same thing. So, if we have a tree full of fives (high fives, maybe?), and we want to change one of them into a six, we must have some way of knowing exactly which five in our tree we want to change. We need to know where it is in our tree. In impure languages, we could just note where the five is located in memory and change that. But in Haskell, one five is as good as another, so we can’t discriminate based on their location in memory.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e31316"/><img src="httpatomoreillycomsourcenostarchimages802724.png.jpg" alt="image with no caption"/></div></div><p>We also can’t really <span class="emphasis"><em>change</em></span> anything. When we say that we “change a tree,” we actually mean that we take a tree and return a new one that’s similar to the original, but slightly different.</p><p>One thing we can do is remember a path from the root of the tree to the element that we want to change. We could say, “Take this tree, go left, go right and then left again, and change the element that’s there.” While this works, it can be inefficient. If we want to later change an element that’s near the element that we previously changed, we need to walk all the way from the root of the tree to our element again!<a id="IDX-CHP-15-0002" class="indexterm"/></p><p>In this chapter, you’ll see how to take some data structure and equip it with something called a <span class="emphasis"><em>zipper</em></span> to focus on a part of the data structure in a way that makes changing its elements easy and walking around it efficient. Nice!</p><div class="sect1" title="Taking a Walk"><div class="titlepage"><div><div><h1 class="title"><a id="taking_a_walk"/>Taking a Walk</h1></div></div></div><p>As you learned in biology class, there are many different kinds of trees, so let’s pick a seed that we will use to plant ours. Here it is:</p><a id="I_programlisting15_d1e31343"/><pre class="programlisting">data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)</pre><p>Our tree is either empty or it’s a node that has an element and two subtrees. Here’s a fine example of such a tree, which I give to you, the reader, for free!</p><a id="I_programlisting15_d1e31347"/><pre class="programlisting">freeTree :: Tree Char freeTree =
    Node 'P'
        (Node 'O'
            (Node 'L'
                (Node 'N' Empty Empty)
                (Node 'T' Empty Empty)
            )
            (Node 'Y'
                (Node 'S' Empty Empty)
                (Node 'A' Empty Empty)
            )
        )
        (Node 'L'
            (Node 'W'
                (Node 'C' Empty Empty)
                (Node 'R' Empty Empty)
            )
            (Node 'A'
                (Node 'A' Empty Empty)
                (Node 'C' Empty Empty)
            )
        )</pre><p>And here's this tree represented graphically:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e31352"/><img src="httpatomoreillycomsourcenostarchimages802726.png.jpg" alt="image with no caption"/></div></div><p>Notice that <code class="literal">W</code> in the tree there? Say we want to change it into a <code class="literal">P</code>. How would we go about doing that? Well, one way would be to pattern match on our tree until we find the element, by first going right and then left. Here’s the code for this:</p><a id="I_programlisting15_d1e31365"/><pre class="programlisting">changeToP :: Tree Char -&gt; Tree Char
changeToP (Node x l (Node y (Node _ m n) r)) = Node x l (Node y (Node 'P' m n) r)</pre><p>Yuck! Not only is this rather ugly, it’s also kind of confusing. What is actually happening here? Well, we pattern match on our tree and name its root element <code class="literal">x</code> (that becomes the <code class="literal">'P'</code> in the root) and its left subtree <code class="literal">l</code>. Instead of giving a name to its right subtree, we further pattern match on it. We continue this pattern matching until we reach the subtree whose root is our <code class="literal">'W'</code>. Once we’ve made the match, we rebuild the tree, but with the subtree that contained the <code class="literal">'W'</code> at its root now having a <code class="literal">'P'</code>.</p><p>Is there a better way of doing this? How about if we make our function take a tree along with a list of directions. The directions will be either <code class="literal">L</code> or <code class="literal">R</code>, representing left or right, respectively, and we’ll change the element that we arrive at by following the supplied directions. Check it out:</p><a id="I_programlisting15_d1e31397"/><pre class="programlisting">data Direction = L | R deriving (Show)
type Directions = [Direction]

changeToP :: Directions -&gt; Tree Char -&gt; Tree Char
changeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r
changeToP (R:ds) (Node x l r) = Node x l (changeToP ds r)
changeToP [] (Node _ l r) = Node 'P' l r</pre><p>If the first element in the list of directions is <code class="literal">L</code>, we construct a new tree that’s like the old tree, but its left subtree has an element changed to <code class="literal">'P'</code>. When we recursively call <code class="literal">changeToP</code>, we give it only the tail of the list of directions, because we already took a left. We do the same thing in the case of an <code class="literal">R</code>. If the list of directions is empty, that means that we’re at our destination, so we return a tree that’s like the one supplied, except that it has <code class="literal">'P'</code> as its root element.<a id="IDX-CHP-15-0003" class="indexterm"/><a id="IDX-CHP-15-0004" class="indexterm"/><a id="IDX-CHP-15-0005" class="indexterm"/><a id="IDX-CHP-15-0006" class="indexterm"/></p><p>To avoid printing out the whole tree, let’s make a function that takes a list of directions and tells us the element at the destination:</p><a id="I_programlisting15_d1e31437"/><pre class="programlisting">elemAt :: Directions -&gt; Tree a -&gt; a
elemAt (L:ds) (Node _ l _) = elemAt ds l
elemAt (R:ds) (Node _ _ r) = elemAt ds r
elemAt [] (Node x _ _) = x</pre><p>This function is actually quite similar to <code class="literal">changeToP</code>. The difference is that instead of remembering stuff along the way and reconstructing the tree, it ignores everything except its destination. Here, we change the <code class="literal">'W'</code> to a <code class="literal">'P'</code> and see if the change in our new tree sticks:</p><a id="I_programlisting15_d1e31450"/><pre class="programlisting">ghci&gt; let newTree = changeToP [R,L] freeTree
ghci&gt; elemAt [R,L] newTree
'P'</pre><p>This seems to work. In these functions, the list of directions acts as a sort of <span class="emphasis"><em>focus</em></span>, because it pinpoints one exact subtree of our tree. A direction list of <code class="literal">[R]</code> focuses on the subtree that’s to the right of the root, for example. An empty direction list focuses on the main tree itself.</p><p>While this technique may seem cool, it can be rather inefficient, especially if we want to repeatedly change elements. Say we have a really huge tree and a long direction list that points to some element all the way at the bottom of the tree. We use the direction list to take a walk along the tree and change an element at the bottom. If we want to change another element that’s close to the element that we just changed, we need to start from the root of the tree and walk all the way to the bottom again. What a drag!</p><p>In the next section, we’ll find a better way of focusing on a subtree—one that allows us to efficiently switch focus to subtrees that are nearby.</p><div class="sect2" title="A Trail of Breadcrumbs"><div class="titlepage"><div><div><h2 class="title"><a id="a_trail_of_breadcrumbs"/>A Trail of Breadcrumbs</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e31468"/><img src="httpatomoreillycomsourcenostarchimages802728.png.jpg" alt="image with no caption"/></div></div><p>For focusing on a subtree, we want something better than just a list of directions that we always follow from the root of our tree. Would it help if we started at the root of the tree and moved either left or right one step at a time, leaving “breadcrumbs” along the way? Using this approach, when we go left, we remember that we went left, and when we go right, we remember that we went right. Let’s try it.<a id="IDX-CHP-15-0007" class="indexterm"/><a id="IDX-CHP-15-0008" class="indexterm"/></p><p>To represent our breadcrumbs, we’ll also use a list of direction values (<code class="literal">L</code> and <code class="literal">R</code> values), but instead of calling it <code class="literal">Directions</code>, we’ll call it <code class="literal">Breadcrumbs</code>, because our directions will now be reversed as we leave them while going down our tree.</p><a id="I_programlisting15_d1e31499"/><pre class="programlisting">type Breadcrumbs = [Direction]</pre><p>Here’s a function that takes a tree and some breadcrumbs and moves to the left subtree while adding <code class="literal">L</code> to the head of the list that represents our breadcrumbs:</p><a id="I_programlisting15_d1e31506"/><pre class="programlisting">goLeft :: (Tree a, Breadcrumbs) -&gt; (Tree a, Breadcrumbs)
goLeft (Node _ l _, bs) = (l, L:bs)</pre><p>We ignore the element at the root and the right subtree, and just return the left subtree along with the old breadcrumbs with <code class="literal">L</code> as the head.</p><p>Here’s a function to go right:</p><a id="I_programlisting15_d1e31515"/><pre class="programlisting">goRight :: (Tree a, Breadcrumbs) -&gt; (Tree a, Breadcrumbs)
goRight (Node _ _ r, bs) = (r, R:bs)</pre><p>It works the same way as the one to go left.</p><p>Let’s use these functions to take our <code class="literal">freeTree</code> and go right and then left.</p><a id="I_programlisting15_d1e31525"/><pre class="programlisting">ghci&gt; goLeft (goRight (freeTree, []))
(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e31528"/><img src="httpatomoreillycomsourcenostarchimages802730.png.jpg" alt="image with no caption"/></div></div><p>Now we have a tree that has <code class="literal">'W'</code> in its root, <code class="literal">'C'</code> in the root of its left subtree, and <code class="literal">'R'</code> in the root of its right subtree. The breadcrumbs are <code class="literal">[L,R]</code>, because we first went right and then went left.</p><p>To make walking along our tree clearer, we can use the <code class="literal">-:</code> function from <a class="xref" href="ch13.html" title="Chapter 13. A Fistful of Monads">Chapter 13</a> that we defined like so:</p><a id="I_programlisting15_d1e31554"/><pre class="programlisting">x -: f = f x</pre><p>This allows us to apply functions to values by first writing the value, then a <code class="literal">-:</code>, and then the function. So, instead of <code class="literal">goRight (freeTree, [])</code>, we can write <code class="literal">(freeTree, []) -: goRight</code>. Using this form, we can rewrite the preceding example so that it’s more apparent that we’re going right and then left:</p><a id="I_programlisting15_d1e31567"/><pre class="programlisting">ghci&gt; (freeTree, []) -: goRight -: goLeft
(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])</pre></div><div class="sect2" title="Going Back Up"><div class="titlepage"><div><div><h2 class="title"><a id="going_back_up"/>Going Back Up</h2></div></div></div><p>What if we want to go back up in our tree? From our breadcrumbs, we know that the current tree is the left subtree of its parent and that it is the right subtree of its parent, and that’s all we know. The breadcrumbs don’t tell us enough about the parent of the current subtree for us to be able to go up in the tree. It would seem that apart from the direction that we took, a single breadcrumb should also contain all the other data we need to go back up. In this case, that’s the element in the parent tree along with its right subtree.<a id="IDX-CHP-15-0009" class="indexterm"/></p><p>In general, a single breadcrumb should contain all the data needed to reconstruct the parent node. So, it should have the information from all the paths that we didn’t take, and it should also know the direction that we did take. However, it must not contain the subtree on which we’re currently focusing. That’s because we already have that subtree in the first component of the tuple. If we also had it in the breadcrumb, we would have duplicate information.</p><p>We don’t want duplicate information because if we were to change some elements in the subtree that we’re focusing on, the existing information in the breadcrumbs would be inconsistent with the changes that we made. The duplicate information becomes outdated as soon as we change something in our focus. It can also hog a lot of memory if our tree contains a lot of elements.</p><p>Let’s modify our breadcrumbs so that they also contain information about everything that we previously ignored when moving left and right. Instead of <code class="literal">Direction</code>, we’ll make a new data type:</p><a id="I_programlisting15_d1e31588"/><pre class="programlisting">data Crumb a = LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)</pre><p>Now, instead of just <code class="literal">L</code>, we have a <code class="literal">LeftCrumb</code>, which also contains the element in the node that we moved from and the right tree that we didn’t visit. Instead of <code class="literal">R</code>, we have <code class="literal">RightCrumb</code>, which contains the element in the node that we moved from and the left tree that we didn’t visit.</p><p>These breadcrumbs now contain all the data needed to re-create the tree that we walked through. So, instead of just being normal breadcrumbs, they’re more like floppy disks that we leave as we go along, because they contain a lot more information than just the direction that we took.</p><p>In essence, every breadcrumb is now like a tree node with a hole in it. When we move deeper into a tree, the breadcrumb carries all the information that the node that we moved away from carried, <span class="emphasis"><em>except</em></span> the subtree on which we chose to focus. It also needs to note where the hole is. In the case of a <code class="literal">LeftCrumb</code>, we know that we moved left, so the missing subtree is the left one.</p><p>Let’s also change our <code class="literal">Breadcrumbs</code> type synonym to reflect this:</p><a id="I_programlisting15_d1e31619"/><pre class="programlisting">type Breadcrumbs a = [Crumb a]</pre><p>Next up, we need to modify the <code class="literal">goLeft</code> and <code class="literal">goRight</code> functions to store information about the paths that we didn’t take in our breadcrumbs, instead of ignoring that information as they did before. Here’s <code class="literal">goLeft</code>:</p><a id="I_programlisting15_d1e31633"/><pre class="programlisting">goLeft :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)</pre><p>You can see that it’s very similar to our previous <code class="literal">goLeft</code>, but instead of just adding a <code class="literal">L</code> to the head of our list of breadcrumbs, we add a <code class="literal">LeftCrumb</code> to signify that we went left. We also equip our <code class="literal">LeftCrumb</code> with the element in the node that we moved from (that’s the <code class="literal">x</code>) and the right subtree that we chose not to visit.</p><p>Note that this function assumes that the current tree that’s under focus isn’t <code class="literal">Empty</code>. An empty tree doesn’t have any subtrees, so if we try to go left from an empty tree, an error will occur. This is because the pattern match on <code class="literal">Node</code> won’t succeed, and there’s no pattern that takes care of <code class="literal">Empty</code>.</p><p><code class="literal">goRight</code> is similar:</p><a id="I_programlisting15_d1e31667"/><pre class="programlisting">goRight :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goRight (Node x l r, bs) = (r, RightCrumb x l:bs)</pre><p>We were previously able to go left and right. What we have now is the ability to actually go back up by remembering stuff about the parent nodes and the paths that we didn’t visit. Here’s the <code class="literal">goUp</code> function:</p><a id="I_programlisting15_d1e31674"/><pre class="programlisting">goUp :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goUp (t, LeftCrumb x r:bs) = (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = (Node x l t, bs)</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e31677"/><img src="httpatomoreillycomsourcenostarchimages802732.png.jpg" alt="image with no caption"/></div></div><p>We’re focusing on the tree <code class="literal">t</code>, and we check the latest <code class="literal">Crumb</code>. If it’s a <code class="literal">LeftCrumb</code>, we construct a new tree using our tree <code class="literal">t</code> as the left subtree and using the information about the right subtree and element that we didn’t visit to fill out the rest of the <code class="literal">Node</code>. Because we “moved back” and picked up the last breadcrumb, then used it to re-create the parent tree, the new list doesn’t contain that breadcrumb.</p><p>Note that this function causes an error if we’re already at the top of a tree and we want to move up. Later on, we’ll use the <code class="literal">Maybe</code> monad to represent possible failure when moving focus.</p><p>With a pair of <code class="literal">Tree a</code> and <code class="literal">Breadcrumbs a</code>, we have all the information we need to rebuild the whole tree, and we also have a focus on a subtree. This scheme enables us to easily move up, left, and right.<a id="IDX-CHP-15-0010" class="indexterm"/><a id="IDX-CHP-15-0011" class="indexterm"/><a id="IDX-CHP-15-0012" class="indexterm"/><a id="IDX-CHP-15-0013" class="indexterm"/></p><p>A pair that contains a focused part of a data structure and its surroundings is called a <span class="emphasis"><em>zipper</em></span>, because moving our focus up and down the data structure resembles the operation of a zipper on a pair of pants. So, it’s cool to make a type synonym as such:</p><a id="I_programlisting15_d1e31736"/><pre class="programlisting">type Zipper a = (Tree a, Breadcrumbs a)</pre><p>I would prefer naming the type synonym <code class="literal">Focus</code>, because that makes it clearer that we’re focusing on a part of a data structure. But since the name <code class="literal">Zipper</code> is more widely used to describe such a setup, we’ll stick with it.</p></div><div class="sect2" title="Manipulating Trees Under Focus"><div class="titlepage"><div><div><h2 class="title"><a id="manipulating_trees_under_focus"/>Manipulating Trees Under Focus</h2></div></div></div><p>Now that we can move up and down, let’s make a function that modifies the element in the root of the subtree on which the zipper is focusing:</p><a id="I_programlisting15_d1e31752"/><pre class="programlisting">modify :: (a -&gt; a) -&gt; Zipper a -&gt; Zipper a
modify f (Node x l r, bs) = (Node (f x) l r, bs)
modify f (Empty, bs) = (Empty, bs)</pre><p>If we’re focusing on a node, we modify its root element with the function <code class="literal">f</code>. If we’re focusing on an empty tree, we leave it as is. Now we can start off with a tree, move to anywhere we want, and modify an element, all while keeping focus on that element so that we can easily move further up or down. Here’s an example:</p><a id="I_programlisting15_d1e31759"/><pre class="programlisting">ghci&gt; let newFocus = modify (\_ -&gt; 'P') (goRight (goLeft (freeTree, [])))</pre><p>We go left, then right, and then modify the root element by replacing it with a <code class="literal">'P'</code>. This reads even better if we use <code class="literal">-:</code>:</p><a id="I_programlisting15_d1e31769"/><pre class="programlisting">ghci&gt; let newFocus = (freeTree, []) -: goLeft -: goRight -: modify (\_ -&gt; 'P')</pre><p>We can then move up if we want and replace an element with a mysterious <code class="literal">'X'</code>:</p><a id="I_programlisting15_d1e31776"/><pre class="programlisting">ghci&gt; let newFocus2 = modify (\_ -&gt; 'X') (goUp newFocus)</pre><p>Or we can write it with <code class="literal">-:</code>:</p><a id="I_programlisting15_d1e31783"/><pre class="programlisting">ghci&gt; let newFocus2 = newFocus -: goUp -: modify (\_ -&gt; 'X')</pre><p>Moving up is easy because the breadcrumbs that we leave form the part of the data structure that we’re not focusing on, but it’s inverted, sort of like turning a sock inside out. That’s why when we want to move up, we don’t need to start from the root and make our way down. We just take the top of our inverted tree, thereby uninverting a part of it and adding it to our focus.<a id="IDX-CHP-15-0014" class="indexterm"/></p><p>Each node has two subtrees, even if those subtrees are empty. So, if we’re focusing on an empty subtree, one thing we can do is to replace it with a nonempty subtree, thus attaching a tree to a leaf node. The code for this is simple:</p><a id="I_programlisting15_d1e31795"/><pre class="programlisting">attach :: Tree a -&gt; Zipper a -&gt; Zipper a
attach t (_, bs) = (t, bs)</pre><p>We take a tree and a zipper, and return a new zipper that has its focus replaced with the supplied tree. Not only can we extend trees this way by replacing empty subtrees with new trees, but we can also replace existing subtrees. Let’s attach a tree to the far left of our <code class="literal">freeTree</code>:</p><a id="I_programlisting15_d1e31802"/><pre class="programlisting">ghci&gt; let farLeft = (freeTree, []) -: goLeft -: goLeft -: goLeft -: goLeft
ghci&gt; let newFocus = farLeft -: attach (Node 'Z' Empty Empty)</pre><p><code class="literal">newFocus</code> is now focused on the tree that we just attached, and the rest of the tree lies inverted in the breadcrumbs. If we were to use <code class="literal">goUp</code> to walk all the way to the top of the tree, it would be the same tree as <code class="literal">freeTree</code>, but with an additional <code class="literal">'Z'</code> on its far left.</p></div><div class="sect2" title="Going Straight to the Top, Where the Air Is Fresh and Clean!"><div class="titlepage"><div><div><h2 class="title"><a id="going_straight_to_the_top_comma_where_th"/>Going Straight to the Top, Where the Air Is Fresh and Clean!</h2></div></div></div><p>Making a function that walks all the way to the top of the tree, regardless of what we’re focusing on, is really easy. Here it is:</p><a id="I_programlisting15_d1e31822"/><pre class="programlisting">topMost :: Zipper a -&gt; Zipper a
topMost (t, []) = (t, [])
topMost z = topMost (goUp z)</pre><p>If our trail of beefed-up breadcrumbs is empty, that means we’re already at the root of our tree, so we just return the current focus. Otherwise, we go up to get the focus of the parent node, and then recursively apply <code class="literal">topMost</code> to that.</p><p>So, now we can walk around our tree, going left, right, and up, applying <code class="literal">modify</code> and <code class="literal">attach</code> as we travel. Then, when we’re finished with our modifications, we use <code class="literal">topMost</code> to focus on the root of our tree and see the changes that we’ve made in proper perspective.</p></div></div></div>
<div class="sect1" title="Focusing on Lists"><div class="titlepage"><div><div><h1 class="title"><a id="focusing_on_lists"/>Focusing on Lists</h1></div></div></div><p>Zippers can be used with pretty much any data structure, so it’s no surprise that they work with sublists of lists. After all, lists are pretty much like trees, except where a node in a tree has an element (or not) and several subtrees, a node in a list has an element and only a single sublist. When we implemented our own lists in <a class="xref" href="ch07.html" title="Chapter 7. Making Our Own Types and Type Classes">Chapter 7</a>, we defined our data type like so:<a id="IDX-CHP-15-0015" class="indexterm"/><a id="IDX-CHP-15-0016" class="indexterm"/><a id="IDX-CHP-15-0017" class="indexterm"/><a id="IDX-CHP-15-0018" class="indexterm"/></p><a id="I_programlisting15_d1e31867"/><pre class="programlisting">data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)</pre><p>Compare this with the definition of our binary tree, and it’s easy to see how lists can be viewed as trees where each node has only one subtree.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e31872"/><img src="httpatomoreillycomsourcenostarchimages802734.png.jpg" alt="image with no caption"/></div></div><p>A list like <code class="literal">[1,2,3]</code> can be written as <code class="literal">1:2:3:[]</code>. It consists of the head of the list, which is <code class="literal">1</code>, and then the list’s tail, which is <code class="literal">2:3:[]</code>. <code class="literal">2:3:[]</code> also has a head, which is <code class="literal">2</code>, and a tail, which is <code class="literal">3:[]</code>. With <code class="literal">3:[]</code>, the <code class="literal">3</code> is the head, and the tail is the empty list <code class="literal">[]</code>.</p><p>Let’s make a zipper for lists. To change the focus on sublists of a list, we move either forward or back (whereas with trees, we move up, left, or right). The focused part will be a subtree, and along with that, we’ll leave breadcrumbs as we move forward.<a id="IDX-CHP-15-0019" class="indexterm"/></p><p>Now, what would a single breadcrumb for a list consist of? When we were dealing with binary trees, the breadcrumb needed to hold the element in the root of the parent node along with all the subtrees that we didn’t choose. It also had to remember if we went left or right. So, it needed to have all the information that a node has, except for the subtree on which we chose to focus.</p><p>Lists are simpler than trees. We don’t need to remember if we went left or right, because there’s only one way to go deeper into a list. Because there’s only one subtree to each node, we don’t need to remember the paths that we didn’t take either. It seems that all we must remember is the previous element. If we have a list like <code class="literal">[3,4,5]</code> and we know that the previous element was <code class="literal">2</code>, we can go back by just putting that element at the head of our list, getting <code class="literal">[2,3,4,5]</code>.</p><p>Because a single breadcrumb here is just the element, we don’t really need to put it inside a data type, as we did when we made the <code class="literal">Crumb</code> data type for tree zippers.</p><a id="I_programlisting15_d1e31935"/><pre class="programlisting">type ListZipper a = ([a], [a])</pre><p>The first list represents the list that we’re focusing on, and the second list is the list of breadcrumbs. Let’s make functions that go forward and backward in lists:<a id="IDX-CHP-15-0020" class="indexterm"/><a id="IDX-CHP-15-0021" class="indexterm"/></p><a id="I_programlisting15_d1e31950"/><pre class="programlisting">goForward :: ListZipper a -&gt; ListZipper a
goForward (x:xs, bs) = (xs, x:bs)

goBack :: ListZipper a -&gt; ListZipper a
goBack (xs, b:bs) = (b:xs, bs)</pre><p>When we’re going forward, we focus on the tail of the current list and leave the head element as a breadcrumb. When we’re moving backward, we take the latest breadcrumb and put it at the beginning of the list. Here are these two functions in action:</p><a id="I_programlisting15_d1e31954"/><pre class="programlisting">ghci&gt; let xs = [1,2,3,4]
ghci&gt; goForward (xs, [])
([2,3,4],[1])
ghci&gt; goForward ([2,3,4], [1])
([3,4],[2,1])
ghci&gt; goForward ([3,4], [2,1])
([4],[3,2,1])
ghci&gt; goBack ([4], [3,2,1])
([3,4],[2,1])</pre><p>You can see that the breadcrumbs in the case of lists are nothing more than a reversed part of your list. The element that we move away from always goes into the head of the breadcrumbs. Then it’s easy to move back by just taking that element from the head of the breadcrumbs and making it the head of our focus. This also makes it easier to see why we call this a <span class="emphasis"><em>zipper</em></span>— it really looks like the slider of a zipper moving up and down.</p><p>If you were making a text editor, you could use a list of strings to represent the lines of text that are currently opened, and you could then use a zipper so that you know on which line the cursor is currently focused. Using a zipper would also make it easier to insert new lines anywhere in the text or delete existing ones.</p></div>
<div class="sect1" title="A Very Simple Filesystem"><div class="titlepage"><div><div><h1 class="title"><a id="a_very_simple_filesystem"/>A Very Simple Filesystem</h1></div></div></div><p>To demonstrate how zippers work, let’s use trees to represent a very simple filesystem. Then we can make a zipper for that filesystem, which will allow us to move between folders, just as we do when jumping around a real filesystem.</p><p>The average hierarchical filesystem is mostly made up of files and folders. <span class="emphasis"><em>Files</em></span> are units of data and have names. <span class="emphasis"><em>Folders</em></span> are used to organize those files and can contain files or other folders. For our simple example, let’s say that an item in a filesystem is either one of these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A file, which comes with a name and some data</p></li><li class="listitem"><p>A folder, which has a name and contains other items that are either files or folders themselves</p></li></ul></div><p>Here’s a data type for this and some type synonyms, so we know what’s what:</p><a id="I_programlisting15_d1e31985"/><pre class="programlisting">type Name = String
type Data = String
data FSItem = File Name Data | Folder Name [FSItem] deriving (Show)</pre><p>A file comes with two strings, which represent its name and the data it holds. A folder comes with a string that is its name and a list of items. If that list is empty, then we have an empty folder.</p><p>Here’s a folder with some files and subfolders (actually what my disk contains right now):</p><a id="I_programlisting15_d1e31991"/><pre class="programlisting">myDisk :: FSItem
myDisk =
    Folder "root"
        [ File "goat_yelling_like_man.wmv" "baaaaaa"
        , File "pope_time.avi" "god bless"
        , Folder "pics"
            [ File "ape_throwing_up.jpg" "bleargh"
            , File "watermelon_smash.gif" "smash!!"
            , File "skull_man(scary).bmp" "Yikes!"
            ]
        , File "dijon_poupon.doc" "best mustard"
        , Folder "programs"
            [ File "fartwizard.exe" "10gotofart"
            , File "owl_bandit.dmg" "mov eax, h00t"
            , File "not_a_virus.exe" "really not a virus"
            , Folder "source code"
                [ File "best_hs_prog.hs" "main = print (fix error)"
                , File "random.hs" "main = print 4"
                ]
            ]
        ]</pre><div class="sect2" title="Making a Zipper for Our Filesystem"><div class="titlepage"><div><div><h2 class="title"><a id="making_a_zipper_for_our_filesystem"/>Making a Zipper for Our Filesystem</h2></div></div></div><p>Now that we have a filesystem, all we need is a zipper so we can zip and zoom around it, and add, modify, and remove files and folders. As with binary trees and lists, our breadcrumbs will contain information about all the stuff that we chose not to visit. A single bread-crumb should store everything except the subtree on which we’re currently focusing. It should also note where the hole is, so that once we move back up, we can plug our previous focus into the hole.<a id="IDX-CHP-15-0022" class="indexterm"/><a id="IDX-CHP-15-0023" class="indexterm"/><a id="IDX-CHP-15-0024" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e32012"/><img src="httpatomoreillycomsourcenostarchimages802736.png.jpg" alt="image with no caption"/></div></div><p>In this case, a breadcrumb should be like a folder, only it should be missing the folder that we currently chose. “Why not like a file?” you ask? Well, because once we’re focusing on a file, we can’t move deeper into the filesystem, so it doesn’t make sense to leave a breadcrumb that says that we came from a file. A file is sort of like an empty tree.</p><p>If we’re focusing on the folder <code class="literal">"root"</code>, and we then focus on the file <code class="literal">"dijon_poupon.doc"</code>, what should the breadcrumb that we leave look like? Well, it should contain the name of its parent folder along with the items that come before and after the file on which we’re focusing. So, all we need is a <code class="literal">Name</code> and two lists of items. By keeping separate lists for the items that come before the item that we’re focusing on and for the items that come after it, we know exactly where to place it once we move back up. That way, we know the location of the hole.</p><p>Here’s our breadcrumb type for the filesystem:</p><a id="I_programlisting15_d1e32032"/><pre class="programlisting">data FSCrumb = FSCrumb Name [FSItem] [FSItem] deriving (Show)</pre><p>And here’s a type synonym for our zipper:</p><a id="I_programlisting15_d1e32036"/><pre class="programlisting">type FSZipper = (FSItem, [FSCrumb])</pre><p>Going back up in the hierarchy is very simple. We just take the latest breadcrumb and assemble a new focus from the current focus and breadcrumb, like so:</p><a id="I_programlisting15_d1e32040"/><pre class="programlisting">fsUp :: FSZipper -&gt; FSZipper
fsUp (item, FSCrumb name ls rs:bs) = (Folder name (ls ++ [item] ++ rs), bs)</pre><p>Because our breadcrumb knew the parent folder’s name, as well as the items that came before our focused item in the folder (that’s <code class="literal">ls</code>) and the items that came after (that’s <code class="literal">rs</code>), moving up was easy.</p><p>How about going deeper into the filesystem? If we’re in the <code class="literal">"root"</code> and we want to focus on <code class="literal">"dijon_poupon.doc"</code>, the breadcrumb that we leave will include the name <code class="literal">"root"</code>, along with the items that precede <code class="literal">"dijon_poupon.doc"</code> and the ones that come after it. Here’s a function that, given a name, focuses on a file or folder that’s located in the current focused folder:<a id="IDX-CHP-15-0025" class="indexterm"/></p><a id="I_programlisting15_d1e32070"/><pre class="programlisting">import Data.List (break)

fsTo :: Name -&gt; FSZipper -&gt; FSZipper
fsTo name (Folder folderName items, bs) =
    let (ls, item:rs) = break (nameIs name) items
    in  (item, FSCrumb folderName ls rs:bs)

nameIs :: Name -&gt; FSItem -&gt; Bool
nameIs name (Folder folderName _) = name == folderName
nameIs name (File fileName _) = name == fileName</pre><p><code class="literal">fsTo</code> takes a <code class="literal">Name</code> and a <code class="literal">FSZipper</code> and returns a new <code class="literal">FSZipper</code> that focuses on the file with the given name. That file must be in the current focused folder. This function doesn’t search all over the place—it just looks in the current folder.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e32086"/><img src="httpatomoreillycomsourcenostarchimages802738.png" alt="image with no caption"/></div></div><p>First, we use <code class="literal">break</code> to break the list of items in a folder into those that precede the file that we’re searching for and those that come after it. <code class="literal">break</code> takes a predicate and a list and returns a pair of lists. The first list in the pair holds items for which the predicate returns <code class="literal">False</code>. Then, once the predicate returns <code class="literal">True</code> for an item, it places that item and the rest of the list in the second item of the pair. We made an auxiliary function called <code class="literal">nameIs</code>, which takes a name and a filesystem item and returns <code class="literal">True</code> if the names match.</p><p>Now <code class="literal">ls</code> is a list that contains the items that precede the item that we’re searching for, <code class="literal">item</code> is that very item, and <code class="literal">rs</code> is the list of items that come after it in its folder. Now that we have these, we just present the item that we got from <code class="literal">break</code> as the focus and build a breadcrumb that has all the data it needs.</p><p>Note that if the name we’re looking for isn’t in the folder, the pattern <code class="literal">item:rs</code> will try to match on an empty list, and we’ll get an error. And if our current focus is a file, rather than a folder, we get an error as well, and the program crashes.</p><p>So, we can move up and down our filesystem. Let’s start at the root and walk to the file <code class="literal">"skull_man(scary).bmp"</code>:</p><a id="I_programlisting15_d1e32136"/><pre class="programlisting">ghci&gt; let newFocus = (myDisk, []) -: fsTo "pics" -: fsTo "skull_man(scary).bmp"</pre><p><code class="literal">newFocus</code> is now a zipper that’s focused on the <code class="literal">"skull_man(scary).bmp"</code> file. Let’s get the first component of the zipper (the focus itself) and see if that’s really true:</p><a id="I_programlisting15_d1e32146"/><pre class="programlisting">ghci&gt; fst newFocus
File "skull_man(scary).bmp" "Yikes!"</pre><p>Let’s move up and focus on its neighboring file <code class="literal">"watermelon_smash.gif"</code>:</p><a id="I_programlisting15_d1e32153"/><pre class="programlisting">ghci&gt; let newFocus2 = newFocus -: fsUp -: fsTo "watermelon_smash.gif"
ghci&gt; fst newFocus2
File "watermelon_smash.gif" "smash!!"</pre></div><div class="sect2" title="Manipulating a Filesystem"><div class="titlepage"><div><div><h2 class="title"><a id="manipulating_a_filesystem"/>Manipulating a Filesystem</h2></div></div></div><p>Now that we can navigate our filesystem, manipulating it is easy. Here’s a function that renames the currently focused file or folder:<a id="IDX-CHP-15-0026" class="indexterm"/><a id="IDX-CHP-15-0027" class="indexterm"/></p><a id="I_programlisting15_d1e32168"/><pre class="programlisting">fsRename :: Name -&gt; FSZipper -&gt; FSZipper
fsRename newName (Folder name items, bs) = (Folder newName items, bs)
fsRename newName (File name dat, bs) = (File newName dat, bs)</pre><p>Let’s rename our <code class="literal">"pics"</code> folder to <code class="literal">"cspi"</code>:</p><a id="I_programlisting15_d1e32178"/><pre class="programlisting">ghci&gt; let newFocus = (myDisk, []) -: fsTo "pics" -: fsRename "cspi" -: fsUp</pre><p>We descended to the <code class="literal">"pics"</code> folder, renamed it, and then moved backup.</p><p>How about a function that makes a new item in the current folder? Behold:</p><a id="I_programlisting15_d1e32187"/><pre class="programlisting">fsNewFile :: FSItem -&gt; FSZipper -&gt; FSZipper
fsNewFile item (Folder folderName items, bs) =
    (Folder folderName (item:items), bs)</pre><p>Easy as pie. Note that this would crash if we tried to add an item but were focusing on a file instead of a folder.</p><p>Let’s add a file to our <code class="literal">"pics"</code> folder, and then move back up to the root:</p><a id="I_programlisting15_d1e32196"/><pre class="programlisting">ghci&gt; let newFocus =
    (myDisk, []) -: fsTo "pics" -: fsNewFile (File "heh.jpg" "lol") -: fsUp</pre><p>What’s really cool about all this is that when we modify our filesystem, our changes are not actually made in place, but instead, the function returns a whole new filesystem. That way, we have access to our old filesystem (in this case, <code class="literal">myDisk</code>), as well as the new one (the first component of <code class="literal">newFocus</code>).</p><p>By using zippers, we get versioning for free. We can always refer to older versions of data structures, even after we’ve changed them. This isn’t unique to zippers, but it is a property of Haskell, because its data structures are immutable. With zippers, however, we get the ability to easily and efficiently walk around our data structures, so the persistence of Haskell’s data structures really begins to shine.<a id="IDX-CHP-15-0028" class="indexterm"/><a id="IDX-CHP-15-0029" class="indexterm"/><a id="IDX-CHP-15-0030" class="indexterm"/><a id="IDX-CHP-15-0031" class="indexterm"/><a id="IDX-CHP-15-0032" class="indexterm"/></p></div></div>
<div class="sect1" title="Watch Your Step"><div class="titlepage"><div><div><h1 class="title"><a id="watch_your_step"/>Watch Your Step</h1></div></div></div><p>So far, while walking through our data structures—whether they were binary trees, lists, or filesystems—we didn’t really care if we took a step too far and fell off. For instance, our <code class="literal">goLeft</code> function takes a zipper of a binary tree and moves the focus to its left subtree:</p><a id="I_programlisting15_d1e32240"/><pre class="programlisting">goLeft :: Zipper a -&gt; Zipper a
goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)</pre><p>But what if the tree we’re stepping off from is an empty tree? What if it’s not a <code class="literal">Node</code>, but an <code class="literal">Empty</code>? In this case, we would get a runtime error, because the pattern match would fail, and we have not made a pattern to handle an empty tree, which doesn’t have any subtrees.</p><p>So far, we just assumed that we would never try to focus on the left subtree of an empty tree, as its left subtree doesn’t exist. But going to the left subtree of an empty tree doesn’t make much sense, and so far we’ve just conveniently ignored this.</p><p>Or what if we are already at the root of some tree and don’t have any breadcrumbs but still try to move up? The same thing would happen. It seems that when using zippers, any step could be our last (cue ominous music). In other words, any move can result in a success, but it can also result in a failure. Does that remind you of something? Of course: monads! More specifically, the <code class="literal">Maybe</code> monad, which adds a context of possible failure to normal values.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e32258"/><img src="httpatomoreillycomsourcenostarchimages802740.png.jpg" alt="image with no caption"/></div></div><p>Let’s use the <code class="literal">Maybe</code> monad to add a context of possible failure to our movements. We’re going to take the functions that work on our binary tree zipper and make them into monadic functions.</p><p>First, let’s take care of possible failure in <code class="literal">goLeft</code> and <code class="literal">goRight</code>. So far, the failure of functions that could fail was always reflected in their result, and this example is no different.</p><p>Here are <code class="literal">goLeft</code> and <code class="literal">goRight</code> with an added possibility of failure:</p><a id="I_programlisting15_d1e32284"/><pre class="programlisting">goLeft :: Zipper a -&gt; Maybe (Zipper a)
goLeft (Node x l r, bs) = Just (l, LeftCrumb x r:bs)
goLeft (Empty, _) = Nothing

goRight :: Zipper a -&gt; Maybe (Zipper a)
goRight (Node x l r, bs) = Just (r, RightCrumb x l:bs)
goRight (Empty, _) = Nothing</pre><p>Now, if we try to take a step to the left of an empty tree, we get a <code class="literal">Nothing</code>!</p><a id="I_programlisting15_d1e32292"/><pre class="programlisting">ghci&gt; goLeft (Empty, [])
Nothing
ghci&gt; goLeft (Node 'A' Empty Empty, [])
Just (Empty,[LeftCrumb 'A' Empty])</pre><p>Looks good! How about going up? The problem before happened if we tried to go up but we didn’t have any more breadcrumbs, which meant that we were already at the root of the tree. This is the <code class="literal">goUp</code> function that throws an error if we don’t keep within the bounds of our tree:</p><a id="I_programlisting15_d1e32299"/><pre class="programlisting">goUp :: Zipper a -&gt; Zipper a
goUp (t, LeftCrumb x r:bs) = (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = (Node x l t, bs)</pre><p>Let’s modify it to fail gracefully:</p><a id="I_programlisting15_d1e32303"/><pre class="programlisting">goUp :: Zipper a -&gt; Maybe (Zipper a)
goUp (t, LeftCrumb x r:bs) = Just (Node x t r, bs)
goUp (t, RightCrumb x l:bs) = Just (Node x l t, bs)
goUp (_, []) = Nothing</pre><p>If we have breadcrumbs, everything is okay, and we return a successful new focus. If we don’t have breadcrumbs, we return a failure.</p><p>Before, these functions took zippers and returned zippers, which meant that we could chain them like this to walk around:</p><a id="I_programlisting15_d1e32309"/><pre class="programlisting">gchi&gt; let newFocus = (freeTree, []) -: goLeft -: goRight</pre><p>But now, instead of returning <code class="literal">Zipper a</code>, they return <code class="literal">Maybe (Zipper a)</code>, and chaining functions like this won’t work. We had a similar problem when we were dealing with our tightrope walker in <a class="xref" href="ch13.html" title="Chapter 13. A Fistful of Monads">Chapter 13</a>. He also walked one step at a time, and each of his steps could result in failure, because a bunch of birds could land on one side of his balancing pole and make him fall.</p><p>Now the joke is on us, because we’re the ones doing the walking, and we’re traversing a labyrinth of our own devising. Luckily, we can learn from the tightrope walker and just do what he did: replace normal function application with <code class="literal">&gt;&gt;=</code>. This takes a value with a context (in our case, the <code class="literal">Maybe (Zipper a)</code>, which has a context of possible failure) and feeds it into a function, while making sure that the context is handled. So just like our tightrope walker, we’re going to trade in all our <code class="literal">-:</code> operators for <code class="literal">&gt;&gt;=</code> operators. Then we will be able to chain our functions again! Watch how it works:</p><a id="I_programlisting15_d1e32336"/><pre class="programlisting">ghci&gt; let coolTree = Node 1 Empty (Node 3 Empty Empty)
ghci&gt; return (coolTree, []) &gt;&gt;= goRight
Just (Node 3 Empty Empty,[RightCrumb 1 Empty])
ghci&gt; return (coolTree, []) &gt;&gt;= goRight &gt;&gt;= goRight
Just (Empty,[RightCrumb 3 Empty,RightCrumb 1 Empty])
ghci&gt; return (coolTree, []) &gt;&gt;= goRight &gt;&gt;= goRight &gt;&gt;= goRight
Nothing</pre><p>We used <code class="literal">return</code> to put a zipper in a <code class="literal">Just</code>, and then used <code class="literal">&gt;&gt;=</code> to feed that to our <code class="literal">goRight</code> function. First, we made a tree that has on its left an empty subtree and on its right a node that has two empty subtrees. When we try to go right once, the result is a success, because the operation makes sense. Going right twice is okay, too. We end up with the focus on an empty subtree. But going right three times doesn’t make sense—we can’t go to the right of an empty subtree. This is why the result is a <code class="literal">Nothing</code>.</p><p>Now we’ve equipped our trees with a safety net that will catch us should we fall off. (Wow, I nailed that metaphor.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Our filesystem also has a lot of cases where an operation could fail, such as trying to focus on a file or folder that doesn’t exist. As an exercise, you can equip our filesystem with functions that fail gracefully by using the <code class="literal">Maybe</code> monad.</p></div></div>
<div class="sect1" title="Thanks for Reading!"><div class="titlepage"><div><div><h1 class="title"><a id="thanks_for_reading_exclamation"/>Thanks for Reading!</h1></div></div></div><p>Or just flipping to the last page! I hope you found this book useful and fun. I have strived to give you good insight into the Haskell language and its idioms. While there’s always something new to learn in Haskell, you should now be able to code cool stuff, as well as read and understand other people’s code. So hurry up and get coding! See you on the other side!</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject15_d1e32370"/><img src="httpatomoreillycomsourcenostarchimages802742.png.jpg" alt="image with no caption"/></div></div></div></body></html>