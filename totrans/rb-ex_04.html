<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Text Manipulation"><div class="titlepage"><div><div><h1 class="title"><a id="text_manipulation"/>Chapter 4. Text Manipulation</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e4982"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages686190.png.jpg"/></div></div><p>Text is the basic format for storing configuration data, web content, email, as well as data written in XML (eXtensible Markup Language) and YAML (YAML Ain’t Markup Language) which we’ll be looking at in greater detail later. It’s important for a programming language to deal with text easily and efficiently. Luckily, Ruby meets this requirement. This chapter includes several scripts that demonstrate Ruby’s approach to some common text-oriented problems.</p><div class="sect1" title="#9 End-of-Line Conversion (dos2unix.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp9_end-of-line_conversion_dos2unixrb"/>#9 End-of-Line Conversion (dos2unix.rb)</h1></div></div></div><p>If you’ve never had to deal with <a class="indexterm" id="idx-CHP-4-0326"/>end-of-line (EOL) differences among operating systems, consider yourself fortunate. <a class="indexterm" id="idx-CHP-4-0327"/>Microsoft, <a class="indexterm" id="idx-CHP-4-0328"/>Apple, and the various <a class="indexterm" id="idx-CHP-4-0329"/>Unix-like operating systems (such as the BSDs and GNU/Linux systems) all disagree about how a text file should show the end of a line. This is further complicated by Apple’s transition to a Unix-like operating system with Mac OS X, which is very similar to FreeBSD. Unix-like systems mark the end of a line with the <span class="emphasis"><em>line feed</em></span> character (also called <span class="emphasis"><em>newline</em></span>); in interfaces that predate the cathode-ray tube (CRT), this character indicated that the paper should move up a line so that there would be more blank paper on which to print. On the other hand, older Macintosh systems (pre–Mac OS X) indicated the end of a line with the <span class="emphasis"><em>carriage return</em></span> character, which indicated that the printer should move back to the left side to start printing again (this assumes you are using a language that is written left to right, like English). Windows (and DOS) systems, on the third hand, mark the end of a line with a carriage return followed by a line feed.<a class="indexterm" id="idx-CHP-4-0330"/><a class="indexterm" id="idx-CHP-4-0331"/><a class="indexterm" id="idx-CHP-4-0332"/><a class="indexterm" id="idx-CHP-4-0333"/><a class="indexterm" id="idx-CHP-4-0334"/></p><div class="note" title="Note"><h3 class="title"><a id="note-31"/>Note</h3><p><span class="emphasis"><em>Some Internet protocols also use the Windows EOL convention, despite often being hosted on Unix-like machines. Go figure</em></span>.<a class="indexterm" id="idx-CHP-4-0335"/></p></div><p>Why the difference? One could argue that the Windows approach makes the most sense—if we’re modeling the physical action of something like a typewriter, then both a carriage return and a line feed would be needed. However, the Unix-like and Macintosh approaches have the benefit of only using one character. This is an important savings, given how often newlines appear in text documents, and it was even more important in the early days of computers when both RAM and storage were much more limited and expensive than they are now.<sup>[<a class="footnote" href="#ftn.CHP-4-FNOTE-1" id="CHP-4-FNOTE-1">9</a>]</sup></p><p>Today, most text editors and similar programs can deal with these differences without too much difficulty, so the <a class="indexterm" id="idx-CHP-4-0336"/>end-of-line compatibility problem is generally no more than a nuisance. But why put up with a nuisance when you don’t have to? We can write a Ruby program that converts DOS or old-style Mac EOLs to Unix EOLs for us.</p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id008"/>The Code</h2></div></div></div><a id="I_programlisting4_d1e5071"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-4-0337"/>dos2unix.rb
  # converts line feeds from DOS (or old-style Mac) to Unix format
❶ ARGV.each do |filename|
    contents_file = File.open(filename, 'r')
❷   contents = contents_file.read()
    contents_file.close()
❸   contents.gsub!(/\r\n?/, "\n")    <em class="lineannotation"><span class="lineannotation">Regular Expressions</span></em>
    replace_file = File.new(filename, 'w+')
❹   replace_file.puts(contents)
    replace_file.close()
  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id008"/>How It Works</h2></div></div></div><p>My pro-Unix biases are clear from both the name and purpose of this program. Let’s see what it does. At ❶, we start looping through the arguments to the script, calling each <code class="literal">filename</code> in turn. We open and close that argument (currently called <code class="literal">filename</code>) as we’ve done before, reading its contents into the creatively named variable <code class="literal">contents</code>. We do some magic with <code class="literal">gsub!</code> at ❸, and then write <code class="literal">contents</code> into a new file (❹) called <code class="literal">replace_file</code>. What’s the magic at ❸? Let’s look at it again.<a class="indexterm" id="idx-CHP-4-0338"/></p><a id="I_programlisting4_d1e5107"/><pre class="programlisting">contents.gsub!(/\r\n?/, "\n")</pre><p>We’re calling a method called <code class="literal">gsub!</code> on our <code class="literal">contents</code> String. We know that <code class="literal">gsub!</code> (which stands for <span class="emphasis"><em>global substitution</em></span>) is a destructive method because of its exclamation-mark ending, and it looks like it takes two arguments. The first argument is enclosed in <a class="indexterm" id="idx-CHP-4-0339"/>regular slashes, and the second argument is a newline String. The first argument is a <span class="emphasis"><em>regular expression</em></span>, which is a special kind of variable that can describe the contents of a piece of text without knowing everything about it. <a class="indexterm" id="idx-CHP-4-0340"/>Regular expressions (<span class="emphasis"><em>regexes</em></span> for short) allow you to test for conditions like <span class="emphasis"><em>Does this text consist entirely of digits?</em></span>, which you could imagine might be useful before using the <code class="literal">to_i</code> method of a String. Regexes also allow tests like <span class="emphasis"><em>Are there exactly seven words in the text?</em></span> or <span class="emphasis"><em>Do all words in this text start with a capital letter?</em></span>, as well as many others.<a class="indexterm" id="idx-CHP-4-0341"/></p><p>Regexes accomplish tasks by defining descriptors for characters as well as groupings and the number of occurrences of those characters. As you can see in the code, regexes are delineated with slashes. This practice of using slashes is not specific to Ruby; it is common in other languages as well. The question mark in the regex does not mean a literal question mark appearing in the text; instead, it means that whatever preceded it is optional, occurring zero or more times. Let’s try out some regexes in irb. We’ll use a new operator called <code class="literal">=~</code>, which is similar to <code class="literal">==</code>. Instead of <a class="indexterm" id="idx-CHP-4-0342"/>testing for exact equality, though, it tests whether or not the regular expression matches any part of the String we call it on. It returns the first point at which a match occurs if the question the regex represents (i.e., <span class="emphasis"><em>Does this text consist entirely of digits?</em></span>) is true for that String; it returns <code class="literal">nil</code> if there is no match.<a class="indexterm" id="idx-CHP-4-0343"/></p><a id="I_programlisting4_d1e5180"/><pre class="programlisting">irb(main):001:0&gt; letters = 'abcde'
=&gt; "abcde"
irb(main):002:0&gt; letters =~ /a/
=&gt; 0
irb(main):003:0&gt; letters =~ /b/
=&gt; 1
irb(main):004:0&gt; letters =~ /e/
=&gt; 4
irb(main):005:0&gt; letters =~ /x/
=&gt; nil</pre><p>We have our String, <code class="literal">letters</code>, which is just the first five letters of the alphabet. We then test whether the letter <span class="emphasis"><em>a</em></span> appears anywhere in <code class="literal">letters</code>. It does, right at the beginning, so our test returns zero. Why? Because that is the index within the String where the first match occurs—remember that we start counting with zero, not one. Since the next letter is <span class="emphasis"><em>b</em></span>, when we test for the presence of <span class="emphasis"><em>b</em></span> within <code class="literal">letters</code>, we should get a result that is one higher than the value when we tested for <span class="emphasis"><em>a</em></span>. We do. Jumping ahead to the letter <span class="emphasis"><em>e</em></span>, we have a match at the last index, which is the fifth letter and has the index of four, again because we start counting with zero. When we test for a letter that does not appear in <code class="literal">letters</code>, we get the return value <code class="literal">nil</code>.</p><p>That’s simple matching. Now let’s use that question mark.</p><a id="I_programlisting4_d1e5217"/><pre class="programlisting">irb(main):006:0&gt; letters =~ /aa?/
=&gt; 0
irb(main):007:0&gt; letters =~ /ax?/
=&gt; 0</pre><p>At first, line six seems similar to line two. Line seven is more interesting, in that the optional second letter is a new letter that does not appear in <code class="literal">letters</code> at all. In both cases, the second letter precedes a question mark, which makes it optional. On line six, we are asking if our String (consisting of the first five letters) has an <span class="emphasis"><em>a</em></span> followed by zero or more <span class="emphasis"><em>a</em></span>s. It does, starting at index zero, so that is our return value. We then ask if our String has an <span class="emphasis"><em>a</em></span> followed by zero or more <span class="emphasis"><em>x</em></span>s. It does, starting at index zero. Let’s continue.</p><a id="I_programlisting4_d1e5236"/><pre class="programlisting">irb(main):008:0&gt; letters =~ /ab?/
=&gt; 0
irb(main):009:0&gt; letters =~ /bc?/
=&gt; 1
irb(main):010:0&gt; letters =~ /b?/
=&gt; 0</pre><p>Line eight asks if <code class="literal">letters</code> has an <span class="emphasis"><em>a</em></span> followed by any optional <span class="emphasis"><em>b</em></span>s, which it does at index zero. Line nine asks if <code class="literal">letters</code> has a <span class="emphasis"><em>b</em></span> followed by any optional <span class="emphasis"><em>c</em></span> s, which is does at index one. Line ten asks if <code class="literal">letters</code> has any optional <span class="emphasis"><em>b</em></span>s, which it does at index zero. The lesson is clear—matching optional characters is very enthusiastic, and the complete absence of a character matches zero or more occurrences of any character. Be very careful with your use of the question mark, especially as a regex argument used by a destructive method. Here’s another demonstration of a match for zero occurrences of a character:</p><a id="I_programlisting4_d1e5266"/><pre class="programlisting">irb(main):011:0&gt; letters =~ //
=&gt; 0</pre><p>There’s nothing at the beginning of <code class="literal">letters</code>. Matching on nothing is conceptually odd, but it can be very useful when you want to break a String into an Array of each of its characters. You may recall we used the <code class="literal">split</code> method matching the empty string in our <a class="indexterm" id="idx-CHP-4-0344"/>script <code class="literal">palindrome2.rb</code> (<a class="xref" href="ch03.html" title="Chapter 3. Programmer Utilities">Chapter 3</a>) to deal with each letter in the String in turn.</p><p>Now we’ve done our matching. I said earlier that <code class="literal">gsub</code> stands for <span class="emphasis"><em>global substitution</em></span>, so let’s do some substituting, again in irb.<a class="indexterm" id="idx-CHP-4-0345"/><a class="indexterm" id="I_indexterm4_d1e5296"/><a class="indexterm" id="I_indexterm4_d1e5301"/></p><a id="I_programlisting4_d1e5306"/><pre class="programlisting">irb(main):012:0&gt; letters.gsub(/a/, 'x')    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> gsub</code></strong>  Method</span></em>
=&gt; "xbcde"
irb(main):013:0&gt; letters.gsub(/ab?/, 'x')
=&gt; "xcde"
irb(main):014:0&gt; letters.gsub(/ac?/, 'x')
=&gt; "xbcde"</pre><p>You can see that <code class="literal">gsub</code> finds the portion of the String that matches the first argument and returns a result in which the first argument is replaced by the second argument. Now let’s review the differences between destructive and non-destructive methods, as they relate to these substitutions.</p><a id="I_programlisting4_d1e5319"/><pre class="programlisting">irb(main):015:0&gt; letters
=&gt; "abcde"
irb(main):016:0&gt; letters.gsub!(/ac?/, 'x')
=&gt; "xbcde"
irb(main):017:0&gt; letters
=&gt; "xbcde"</pre><p>The non-destructive version leaves the original <code class="literal">letters</code> alone, as you’d expect, while the destructive version makes permanent changes to <code class="literal">letters</code>. The <code class="literal">gsub!</code> method also returns <code class="literal">nil</code> if it is unable to comply, as shown in irb:</p><a id="I_programlisting4_d1e5335"/><pre class="programlisting"> irb(main):001:0&gt; foo = 'abcd'
=&gt; "abcd"
irb(main):002:0&gt; foo.gsub(/a/, 'b')
=&gt; "bbcd"
irb(main):003:0&gt; foo.gsub!(/a/, 'b')
=&gt; "bbcd"
irb(main):004:0&gt; foo.gsub(/a/, 'b')
=&gt; "bbcd"
irb(main):005:0&gt; foo.gsub!(/a/, 'b')
=&gt; nil</pre><p>This interlude barely scratches the surface of <a class="indexterm" id="idx-CHP-4-0346"/>regular expressions—they’re tremendously useful. I’ll certainly explain the specific regexes used in the scripts in this book, but there’s a lot more to learn about them. If you want to explore regular expressions further, an excellent resource is Jeffrey <a class="indexterm" id="idx-CHP-4-0347"/>Friedl’s <a class="indexterm" id="idx-CHP-4-0348"/><em class="citetitle">Mastering Regular Expressions</em> (O’Reilly, 2006) and its companion website, <a class="ulink" href="http://regex.info">http://regex.info</a>. This is the definitive text on the subject of regular expressions. It has a slight Perl bias, although its respect for Ruby seems to increase with every new edition. Since the implementation of regular expressions in many languages (including Ruby) is inspired by Perl, the Perl-specific content is easily transferable to Ruby, largely because the two languages’ treatment of regular expressions is so similar in the first place.</p><p>How does all this relate to our script, <code class="literal">dos2unix.rb</code>? The <code class="literal">\r</code> String stands for the carriage return character—the one used on older Macintosh systems to indicate a line break. The <code class="literal">\n</code> String is the newline character, which is used on Unix-like systems and after a carriage return on Windows systems to indicate a line break. This substitution finds all occurrences of a carriage return, as well as any optional newlines that follow it, and replaces them with a single newline.<a class="indexterm" id="idx-CHP-4-0349"/><a class="indexterm" id="I_indexterm4_d1e5371"/></p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id007"/>Running the Script</h2></div></div></div><p>Execute this as <code class="literal">ruby -w dos2unix.rb file_to_modify</code>.<a class="indexterm" id="idx-CHP-4-0350"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id006"/>The Results</h2></div></div></div><p>When I look at my sample file <code class="literal">extras/DOS_file.txt</code> in my text editor of choice (vim), it looks like this:</p><a id="I_programlisting4_d1e5395"/><pre class="programlisting">I am a DOS file.^MI am a DOS file.</pre><p>The <code class="literal">^M</code> is how vim displays a <code class="literal">\r</code> character on my system. After running the script with <code class="literal">ruby -w dos2unix.rb extras/DOS_file.txt</code>, the results are<a class="indexterm" id="idx-CHP-4-0351"/></p><a id="I_programlisting4_d1e5411"/><pre class="programlisting">I am a DOS file.
I am a DOS file.</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id006"/>Hacking the Script</h2></div></div></div><p>What if you want to convert to one of the other line break formats? To convert a file to Windows EOL format, you can replace the line at ❸ in <code class="literal">dos2unix.rb</code> with the following line, which essentially means <span class="emphasis"><em>Replace all occurrences of either a carriage return or a newline with a carriage return followed by a new line</em></span>.<a class="indexterm" id="idx-CHP-4-0352"/></p><a id="I_programlisting4_d1e5429"/><pre class="programlisting">contents.gsub!(/(\r|\n)/, "\r\n")</pre><p>For a nostalgic Mac that wants to go back to its pre–OS X line breaks, you can convert to the old Apple format by replacing the line at ❸ with this line; this will replace all optional carriage returns followed by a mandatory new-line with just a carriage return.</p><a id="I_programlisting4_d1e5433"/><pre class="programlisting">contents.gsub!(/\r?\n/, "\r")</pre><p>The parentheses in a regex are similar to the parentheses in Ruby—they indicate a grouping that should be considered a single entity. The <span class="emphasis"><em>pipe</em></span> character (also called the <span class="emphasis"><em>vertical bar</em></span>) in a regex indicates a choice between what is on either side of it.<a class="indexterm" id="idx-CHP-4-0353"/></p><div class="note" title="Note"><h3 class="title"><a id="note-32"/>Note</h3><p><span class="emphasis"><em>Subexpressions that are grouped together by parentheses within a regular expression are also captured into specific variables, depending on the programming language’s implementation of regular expressions. You can read more in Friedl’s book if this topic interests you</em></span>.<a class="indexterm" id="idx-CHP-4-0354"/></p></div><p>You can also accomplish a <a class="indexterm" id="idx-CHP-4-0355"/>DOS-to-Unix EOL conversion with a one-liner:<a class="indexterm" id="I_indexterm4_d1e5460"/></p><a id="I_programlisting4_d1e5465"/><pre class="programlisting">ruby -pi <a class="indexterm" id="idx-CHP-4-0356"/>-e 'gsub(/\r\n?/, "\n")' some_file</pre><p>Sometimes a quick-and-dirty solution is all you need. If you’re curious about the implementation of this one-liner, you can consult the Ruby man page (<code class="literal">man ruby</code>) for more about the <code class="literal">-p</code> flag (which provides a shortcut for dealing with the lines of a file), the <code class="literal">-i</code> flag (which specifies in-place editing of a file), and the <code class="literal">-e</code> flag (which specifies that a command should be executed).<a class="indexterm" id="idx-CHP-4-0357"/><a class="indexterm" id="idx-CHP-4-0358"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FNOTE-1" id="ftn.CHP-4-FNOTE-1">9</a>] </sup>This is also the reason many Unix commands are so short: <code class="literal">rm</code> for <span class="emphasis"><em>remove</em></span>, <code class="literal">cp</code> for <span class="emphasis"><em>copy</em></span>, and so on.</p></div></div></div>
<div class="sect1" title="#10 Showing Line Numbers (line_num.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp10_showing_line_numbers_line_numrb"/>#10 Showing Line Numbers (line_num.rb)</h1></div></div></div><p>Another useful trick when dealing with text files is the ability to automatically add line numbers to them. Here’s a script that does just that.<a class="indexterm" id="idx-CHP-4-0359"/><a class="indexterm" id="idx-CHP-4-0360"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id009"/>The Code</h2></div></div></div><a id="I_programlisting4_d1e5507"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-4-0361"/>line_num.rb

❶ def <a class="indexterm" id="idx-CHP-4-0362"/>get_lines(filename)
    return File.open(filename, 'r').readlines
  end

❷ def <a class="indexterm" id="idx-CHP-4-0363"/>get_format(lines)
    return "%0#{lines.size.to_s.size}d"    <em class="lineannotation"><span class="lineannotation"><strong class="userinput"><code>sprintf</code></strong> Formats</span></em>
  end

❸ def get_output(lines)
    format = get_format(lines)
❹   output = ''    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> each_with_index</code></strong> and<strong class="userinput"><code> sprintf</code></strong> Methods</span></em>
❺   lines.each_with_index do |line,i|
❻     output += "#{sprintf(format, i+1)}: #{line}"
    end
    return output
  end

  print get_output(get_lines(ARGV[0]))</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id009"/>How It Works</h2></div></div></div><p>The <code class="literal">get_lines</code> method (❶) should look familiar at this point, since we’ve covered some very similar methods earlier in the book. This method returns an Array of lines based on the contents of an input filename. The <code class="literal">get_format</code> method (❷), on the other hand, behaves a bit differently. It returns a single String with the form <code class="literal">“%0</code><em class="replaceable"><code>x</code></em><code class="literal">d”</code>, where <em class="replaceable"><code>x</code></em> is the number of characters taken up by the String representation of the number of members of the <code class="literal">lines</code> Array. Let’s explore the methods a bit in irb:</p><a id="I_programlisting4_d1e5562"/><pre class="programlisting">irb(main):001:0&gt; def get_format(lines)
irb(main):002:1&gt; return "%0#{lines.size.to_s.size}d"
irb(main):003:1&gt; end
=&gt; nil
irb(main):004:0&gt; has10items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
irb(main):005:0&gt; get_format(has10items)
=&gt; "%02d"
irb(main):006:0&gt; has100items = has10items * 10     <em class="lineannotation"><span class="lineannotation">Multiplying Arrays</span></em>
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4,
5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,
1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6,
7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
irb(main):007:0&gt; get_format(has100items)
=&gt; "%03d"</pre><p>You can see that the numeral part of the format changes; it is always equal to the digits taken up by the size of the Array. Incidentally, you can also see how the Array class implements multiplication. One way would have been to multiply each member of the Array by the operand outside of the Array, but that would only work when each member of the Array knows how to be multiplied by something. Instead, the Array just duplicates itself as many times as the value of the operand. If you multiply an Array by one, you should get an equivalent Array.</p><a id="I_programlisting4_d1e5569"/><pre class="programlisting">irb(main):008:0&gt; has10items * 1
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
irb(main):009:0&gt; (has10items * 1) == has10items
=&gt; true</pre><p>We see that we do.</p><p>The <code class="literal">get_output</code> method (❸) starts by establishing the necessary <code class="literal">format</code> and setting a variable called <code class="literal">output</code> to the empty String. You can guess that we’ll be concatenating other Strings onto it.<a class="indexterm" id="idx-CHP-4-0364"/></p><p>We do that at ❺ with a new Array method called <code class="literal">each_with_index</code>. This method is very similar to the <code class="literal">each</code> method that we’ve already seen, except that it also gives us the appropriate index number. We’ll call the given element of <code class="literal">lines</code> by the name <code class="literal">line</code>, and we’ll refer to the index number as the letter <code class="literal">i</code>. We then use a new method called <code class="literal">sprintf</code> that formats data into Strings (❻). It takes two arguments: the first is the format to use, and the second is the data to be formatted. We want to format the index number <code class="literal">i</code> using the output of the <code class="literal">get_format</code> method.<sup>[<a class="footnote" href="#ftn.CHP-4-FNOTE-2" id="CHP-4-FNOTE-2">10</a>]</sup> The purpose of this operation is to calculate the number of digits needed for the maximum line number we’ll be <a class="indexterm" id="idx-CHP-4-0366"/><a class="indexterm" id="idx-CHP-4-0367"/>displaying (the width), and format each line number according to that width. This formatting ensures a prettier output.</p><p>Each line of our output consists of <code class="literal">sprintf</code>’s output, a colon, a space, and the original line. All of this happens with the first argument on the command line.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id008"/>Running the Script</h2></div></div></div><p>You can run with <code class="literal">ruby -w line_num.rb</code> <em class="replaceable"><code>some_file</code></em>, replacing <em class="replaceable"><code>some_file</code></em> with the file to which you want to add line numbers.<a class="indexterm" id="idx-CHP-4-0368"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id007"/>The Results</h2></div></div></div><a id="I_programlisting4_d1e5660"/><pre class="programlisting">$ ruby -w <a class="indexterm" id="idx-CHP-4-0369"/>line_num.rb line_num.rb
01: #!/usr/bin/env ruby
02: # line_num.rb
03:
04: def get_lines(filename)
05:   return File.open(filename, 'r').readlines
06: end
07:
08: def get_format(lines)
09:   return "%0#{lines.size.to_s.size}d"
10: end
11:
12: def get_output(lines)
13:   format = get_format(lines)
14:   output = ''
15:   lines.each_with_index do |<a class="indexterm" id="idx-CHP-4-0370"/>line,i|
16:     output += "#{sprintf(format, i+1)}: #{line}"
17:   end
18:   return output
19: end
20:
21: print get_output(get_lines(ARGV[0]))</pre><p>If your text file has one 100 or more lines, the pre-colon portion of this output will automatically add as many characters as needed to accommodate its new requirements. That’s all there is to it.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FNOTE-2" id="ftn.CHP-4-FNOTE-2">10</a>] </sup>Actually, we format the value of <em class="replaceable"><code>i</code></em> + 1; we want to call the first line number one, but the index value is zero, because computers start counting with zero.<a class="indexterm" id="idx-CHP-4-0365"/></p></div></div></div>
<div class="sect1" title="#11 Wrapping Lines of Text (softwrap.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp11_wrapping_lines_of_text_softwrapr"/>#11 Wrapping Lines of Text (softwrap.rb)</h1></div></div></div><p>Sometimes you may have a text file that you want to perform whitespace compression on, such as converting all <a class="indexterm" id="idx-CHP-4-0371"/>repeated spaces into a single space. The <a class="indexterm" id="idx-CHP-4-0372"/>script below assumes that all double line breaks should be preserved and that all single line breaks should be converted into <a class="indexterm" id="idx-CHP-4-0373"/>spaces. Each group of repeated spaces should also be converted into a single space. Let’s dive right in.<a class="indexterm" id="idx-CHP-4-0374"/><a class="indexterm" id="idx-CHP-4-0375"/><a class="indexterm" id="I_indexterm4_d1e5699"/><a class="indexterm" id="I_indexterm4_d1e5702"/><a class="indexterm" id="I_indexterm4_d1e5708"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id010"/>The Code</h2></div></div></div><a id="I_programlisting4_d1e5716"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-4-0376"/>softwrap.rb

  =begin rdoc
  "Softwrap" a filename argument, preserving "\n\n"
  between paragraphs but compressing "\n" and other
  whitespace within each paragraph into a single space.
  =end
❶ def softwrap(filename)
❷   File.open(filename, 'r').readlines.inject('') do |output,line|    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> inject</code></strong> Method</span></em>
❸     output += softwrap_line(line)
❽   end.gsub(/\t+/, ' ').gsub(/ +/, ' ')
  end # softwrap

  =begin rdoc
  Return "\n\n" if the &lt;b&gt;String&lt;/b&gt; argument has no length after being
  chomped (signifying that it was a blank line separating paragraphs),
  otherwise return the chomped line with a trailing space for padding.
  =end
❹ def <a class="indexterm" id="idx-CHP-4-0377"/>softwrap_line(line)
❺   return "\n\n" if line == "\n"
❻   return line.chomp + ' '
  end # softwrap_line

❼ puts softwrap(ARGV[0])</pre><p>We define a <code class="literal">softwrap</code> method (❶) that takes a <code class="literal">filename</code> argument and then call <code class="literal">softwrap</code> on the first command-line argument to the <a class="indexterm" id="idx-CHP-4-0378"/>script. The script then calls the <code class="literal">readlines</code> method upon the opening of a file, as we’ve done many times already. Usually, as in the previous script, we would assign that result into an Array of <a class="indexterm" id="idx-CHP-4-0379"/>lines. This time, we call a new method called <code class="literal">inject</code> that you can see takes an argument (the empty String, in our example) and a block; we define two variables within the block in the process (❷).<a class="indexterm" id="idx-CHP-4-0380"/><a class="indexterm" id="idx-CHP-4-0381"/></p><p>In our example, we’re calling those two variables <code class="literal">output</code> and <code class="literal">line</code>. The name <code class="literal">line</code> is familiar enough. The name <code class="literal">output</code> is apt, as the <code class="literal">inject</code> method assumes that the first block-level variable should start with the value of the argument to <code class="literal">inject</code> that preceded the block—the empty String, in this case. The <code class="literal">inject</code> method is remarkable in that modifications of the <code class="literal">output</code> variable persist from each iteration to the next. At ❸ we append <code class="literal">softwrap_line(line)</code> onto <code class="literal">output</code> each time through the iterations within <code class="literal">inject</code>, and the appends are remembered each time. The <code class="literal">inject</code> method is very useful for any sort of appending or successive operations. Let’s look at how it operates on some numbers in irb.</p><a id="I_programlisting4_d1e5808"/><pre class="programlisting">irb(main):001:0&gt; nums = [1, 2, 3, 4]
=&gt; [1, 2, 3, 4]
irb(main):002:0&gt; nums.inject(0) { |sum,number| sum += number }
=&gt; 10
irb(main):003:0&gt; nums.inject(0) { |product,number| product *= number }
=&gt; 0
irb(main):004:0&gt; nums.inject(1) { |product,number| product *= number }
=&gt; 24</pre><p>On line one we define a variable that holds the digits from one to four. One operation that <code class="literal">inject</code> seems well suited for is adding a list of numbers; we do that on line two. The <code class="literal">inject</code> method can handle any operation, though, so let’s try multiplication on line three. When we do this, we get a result of zero. The reason is that our initial value for <code class="literal">product</code> is zero, so any multiplication after that will get us nowhere. On line four, we set the initial value to one, which is more appropriate for multiplication, and we get a result that makes sense.</p><p>The <code class="literal">inject</code> method is your first real taste of <span class="emphasis"><em>functional programming</em></span>, a style of programming in which operations are treated as mathematical functions and side effects are minimized. We’ll see much more of <code class="literal">inject</code> and similar methods in later chapters. For now, all we need to concern ourselves with is the fact that it collects each line, passes <code class="literal">line</code> through the <code class="literal">softwrap_line</code> function, and then appends the result onto <code class="literal">output</code>.<a class="indexterm" id="idx-CHP-4-0382"/></p><div class="note" title="Note"><h3 class="title"><a id="note-33"/>Note</h3><p><span class="emphasis"><em>Remember that</em></span> <a class="indexterm" id="idx-CHP-4-0383"/>side effects <span class="emphasis"><em>are persistent changes made to something (anything) apart from the value returned. In Ruby, methods that have side effects generally end with an exclamation mark, as we’ve seen already. Methods with no side effects return some value that you requested, but leave the object on which the method was called in the same state it was in before you called the method</em></span>.<a class="indexterm" id="idx-CHP-4-0384"/><a class="indexterm" id="idx-CHP-4-0385"/></p></div><p>What does <code class="literal">softwrap_line</code> do? The name suggests that it performs the soft-wrapping operation (however we are about to define it) on one line at a time.</p><p>The method definition starts at ❹, where it takes in a <code class="literal">line</code>. At ❺, we return right away if our new <code class="literal">line</code> variable is only a carriage return, since this would indicate a real break that we want to preserve. In all other cases, we return the chomped <code class="literal">line</code> plus a space character (❻), which is how this <a class="indexterm" id="idx-CHP-4-0386"/>script implements the actual <a class="indexterm" id="idx-CHP-4-0387"/>wrapping. We do this <code class="literal">softwrap_line</code> operation on every line, appending it onto the <code class="literal">inject</code> ’s <code class="literal">output</code> variable at ❸ as described earlier. Our block for <code class="literal">inject</code> is of the <code class="literal">do</code>/<code class="literal">end</code> variety, rather than one that uses the brace characters.</p><p>We see something new at ❽—a method called on the keyword <code class="literal">end</code>.<sup>[<a class="footnote" href="#ftn.CHP-4-FNOTE-3" id="CHP-4-FNOTE-3">11</a>]</sup> There’s no reason we shouldn’t see this, though. Everything in Ruby is a object, and the the result of our <code class="literal">inject</code> method is whatever has accumulated into its <code class="literal">output</code> variable. In our script, it’s a String, so the value of our <code class="literal">inject</code> block can respond to any String methods, such as <code class="literal">gsub</code>.</p><p>The first <code class="literal">gsub</code> at ❽ searches for any grouping of tab characters (represented within the regular expression as <code class="literal">“\t”</code>) and replaces the set of them with a space. The plus sign within the regular expression is similar to the question mark we’ve seen before, except that instead of meaning <span class="emphasis"><em>Zero or more of the preceding thing</em></span> it means <span class="emphasis"><em>One or more of the preceding thing</em></span>. This regular expression replaces one tab with one space, three tabs with one space, and so on. Let’s try something similar in irb. I’ll use letters rather than tabs in the irb example because they’ll be easy to read in a printed book. The question mark was just for a review and to show the difference between it and the plus sign within a regular expression.</p><a id="I_programlisting4_d1e5950"/><pre class="programlisting">irb(main):001:0&gt; s = 'abcde'    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> +</code></strong> sign in Regular Expressions</span></em>
=&gt; "abcde"
irb(main):002:0&gt; s.gsub(/ab+/, 'ba')
=&gt; "bacde"
irb(main):003:0&gt; s.gsub(/abb+/, 'ba')
=&gt; "abcde"
irb(main):004:0&gt; s.gsub(/abb?/, 'ba')
=&gt; "bacde"</pre><p>So we replace tabs (if there are any) with a space. The output of the first <code class="literal">gsub</code> is also a String, so it can respond to any String methods, such as another <code class="literal">gsub</code>. This time we want to replace any occurrences of one or more spaces with a single space—basically just compressing the whitespace. The last line of the script at ❼ shows that we do all of this on the first <code class="literal">filename</code> argument to the script.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id009"/>Running the Script</h2></div></div></div><p>This script is run with <code class="literal">ruby -w softwrap.rb some_file</code>, where <em class="replaceable"><code>some_file</code></em> is the file whose whitespace will be compressed. Note that this script does not modify the original file, but rather outputs the changed version, just like a non-destructive method in Ruby.<a class="indexterm" id="idx-CHP-4-0388"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id008"/>The Results</h2></div></div></div><p>Here’s the result of calling this script on itself:</p><a id="I_programlisting4_d1e5988"/><pre class="programlisting">$ ruby -w <a class="indexterm" id="idx-CHP-4-0389"/>softwrap.rb softwrap.rb
#!/usr/bin/env ruby # softwrap.rb

=begin rdoc "Softwrap" a filename argument, preserving "\n\n" between
paragraphs but compressing "\n" and other whitespace within each paragraph
into a single space. =end def softwrap(filename) File.open(filename,
'r').readlines.inject('') do |output,line| output <a class="indexterm" id="idx-CHP-4-0390"/>+= softwrap_line(line)
end.gsub(/\t+/, ' ').gsub(/ <a class="indexterm" id="idx-CHP-4-0391"/>+/, ' ') end # softwrap

=begin rdoc Return "\n\n" if the &lt;b&gt;String&lt;/b&gt; argument has no length after
being chomped (signifying that it was a blank line separating paragraphs),
otherwise return the chomped line with a trailing space for padding. =end def
softwrap_line(line) return "\n\n" if line == "\n" return line.chomp + ' ' end
# softwrap_line

puts softwrap(ARGV[0])</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id007"/>Hacking the Script</h2></div></div></div><p>The successive <code class="literal">gsub</code> calls on line ❽ could have been expressed with a more complex regular expression instead: <code class="literal">gsub(/(\t| )+/, ‘ ’)</code>.<a class="indexterm" id="I_indexterm4_d1e6017"/><a class="indexterm" id="I_indexterm4_d1e6020"/><a class="indexterm" id="I_indexterm4_d1e6023"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FNOTE-3" id="ftn.CHP-4-FNOTE-3">11</a>] </sup>More precisely, the method is being called on the result of the code concluded by <code class="literal">end</code>.</p></div></div></div>
<div class="sect1" title="#12 Counting Words in a File (word_count.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp12_counting_words_in_a_file_word_co"/>#12 Counting Words in a File (word_count.rb)</h1></div></div></div><p>It’s often handy to know the number of <a class="indexterm" id="idx-CHP-4-0392"/>words in a file. Word count is a standard feature in word-processing programs, but if you’re not using a word processor, obtaining a word count might not be so easy. I originally wrote this script when I was working on a project using an XML-based document production system called <span class="emphasis"><em>DocBook</em></span> (<a class="ulink" href="http://www.docbook.org">http://www.docbook.org</a>) and wanted to have a word count that roughly corresponded to those you could get from a word processor. The Unix command <code class="literal">wc</code> counts words, but the numbers it reported didn’t necessarily match what a word processor might report; the main reason probably had to do with issues like whether words with fewer than a certain number of letters should count as a “word” in the word processor’s counter. I knew the approximate ratio of the word processor’s word count versus the output of <code class="literal">wc</code> (I call this the <span class="emphasis"><em>fudge factor</em></span>), and I could certainly do the math, but I wanted something that would do all of this for me automatically. Let’s take a look.<a class="indexterm" id="idx-CHP-4-0393"/><a class="indexterm" id="idx-CHP-4-0394"/><a class="indexterm" id="idx-CHP-4-0395"/><a class="indexterm" id="idx-CHP-4-0396"/><a class="indexterm" id="idx-CHP-4-0397"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id011"/>The Code</h2></div></div></div><a id="I_programlisting4_d1e6074"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-4-0398"/>word_count.rb

  class String

❶   def num_matches(thing_to_match)
      return self.split(thing_to_match).size - 1
    end # num_matches

  end # String

❷ BAR_LENGTH   = 20

  # to match these calculations with the output of some word processors
❸ FUDGE_FACTOR = 0.82

❹ def word_count(files)
    output = ''
    total_word_count = 0
❺   files.each do |filename|
      file_word_count = word_count_for_file(filename)
      output += "#{filename} has #{file_word_count} <a class="indexterm" id="idx-CHP-4-0399"/>words.\n"
      total_word_count += file_word_count
    end # each file
❻   return output +
      '-' * BAR_LENGTH + "\n" +    <em class="lineannotation"><span class="lineannotation">Multiplying Strings</span></em>
      "Total word count = #{total_word_count}" +
      " (#{(total_word_count * FUDGE_FACTOR)})"
  end # word_count

❼ def word_count_for_file(filename)
    f = File.new(filename, 'r')
    contents = f.read()
    f.close()
    spaces = contents.num_matches(' ')
    breaks = contents.num_matches("\n")
    false_doubles = contents.num_matches(" \n")
    double_spaces = contents.num_matches('  ')
    hyphens = contents.num_matches('-')
    false_doubles += double_spaces + hyphens
    <a class="indexterm" id="idx-CHP-4-0400"/>words = spaces + breaks - false_doubles + 1
    return <a class="indexterm" id="idx-CHP-4-0401"/>words
  end # word_count_for_file

  puts word_count(ARGV)</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id010"/>How It Works</h2></div></div></div><p>We start out by adding a new method called <code class="literal">num_matches</code> to the String class (❶). It simply returns the number of times the argument appears within the calling String. I also define top-level constants called <code class="literal">BAR_LENGTH</code> (❷), which is just for visual formatting, and <code class="literal">FUDGE_FACTOR</code> (❸), which I already noted is the ratio between the two different word-counting programs I was working with.<a class="indexterm" id="idx-CHP-4-0402"/></p><p>We then define the <code class="literal">word_count</code> method (❹), which takes the <code class="literal">files</code> argument. You’ll notice on the last line of the script that this program takes an arbitrary number of filenames as its argument, which is different from our earlier scripts that would only deal with a single file at a time. The <code class="literal">word_count</code> method defines local variables called <code class="literal">output</code> and <code class="literal">total_word_count</code>, setting them to useful defaults for a String and an Integer, respectively. We then loop through the files (❺), assigning the proper values into <code class="literal">file_word_count</code> and <code class="literal">output</code> and accumulating each <code class="literal">file_word_count</code> into the <code class="literal">total_word_count</code>. The <code class="literal">output</code> variable now has a description of each file’s count. We <code class="literal">return</code> that, followed by a line consisting of the hyphen character multiplied by the <code class="literal">BAR_LENGTH</code> constant (❻). Multiplication of Strings is very similar to multiplication of Arrays, which we’ve already seen. We add a String consisting of 20 hyphen characters to the overall expression returned. The returned expression closes with the total multiplied by the <code class="literal">FUDGE_FACTOR</code> constant in parentheses.<a class="indexterm" id="idx-CHP-4-0403"/></p><p>Before finishing with this script, we need to understand how it calculates the word count for each file. Let’s examine the <code class="literal">word_count_for_file</code> function (❼). It opens by getting the <code class="literal">contents</code> out of the file being worked on. It then uses some quick-and-dirty calls to the <code class="literal">num_matches</code> method on the <code class="literal">contents</code> variable to get counts for spaces, line breaks, and so on. It then calculates the number of <a class="indexterm" id="idx-CHP-4-0404"/>words in the <code class="literal">contents</code> String using those rough numbers.<a class="indexterm" id="idx-CHP-4-0405"/></p><p>There are more accurate ways to count <a class="indexterm" id="idx-CHP-4-0406"/>words in a String, many of which use techniques described in Jeffrey <a class="indexterm" id="idx-CHP-4-0407"/>Friedl’s <a class="indexterm" id="idx-CHP-4-0408"/><em class="citetitle">Mastering Regular Expressions</em>. However, this script is intended for quick, approximate results, given that it uses a fudge factor. This script shows that just adding one new method to an existing class can be very handy even for a short, back-of-the-envelope task. We’ll see more of that in later scripts, as well.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id010"/>Running the Script</h2></div></div></div><p>You can run this script with <code class="literal">ruby -w word_count.rb</code> <em class="replaceable"><code>some_file</code></em>, where <em class="replaceable"><code>some_file</code></em> is the file whose word count you want to compute.<a class="indexterm" id="idx-CHP-4-0409"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id009"/>The Results</h2></div></div></div><p>Here is the result of calling this file on itself:<a class="indexterm" id="I_indexterm4_d1e6227"/></p><a id="I_programlisting4_d1e6232"/><pre class="programlisting">$ ruby -w <a class="indexterm" id="idx-CHP-4-0410"/>word_count.rb word_count.rb
word_count.rb has 132 <a class="indexterm" id="idx-CHP-4-0411"/>words.
--------------------
Total word count = 132 (108.24)</pre><p>Notice how the script reports both the literal and fudged word counts.</p></div></div>
<div class="sect1" title="#13 Word Histogram (most_common_words.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp13_word_histogram_most_common_words"/>#13 Word Histogram (most_common_words.rb)</h1></div></div></div><p>And now for something that most word processors don’t do: finding the most commonly used words in a document. Like the previous script, it adds an additional “helper” method to an existing built-in class to simplify the job for our new main method. Let’s take a look.<a class="indexterm" id="idx-CHP-4-0412"/><a class="indexterm" id="idx-CHP-4-0413"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id012"/>The Code</h2></div></div></div><a id="I_programlisting4_d1e6262"/><pre class="programlisting">  #!/usr/bin/env ruby
  #<a class="indexterm" id="idx-CHP-4-0414"/>most_common_words.rb

  class Array

❶   def <a class="indexterm" id="idx-CHP-4-0415"/>count_of(item)
❷     <a class="indexterm" id="idx-CHP-4-0416"/>grep(item).size    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> grep</code></strong> Method</span></em>
❸     #<a class="indexterm" id="idx-CHP-4-0417"/>inject(0) { |count,each_item| item == each_item ? count+1 : count }
    end

  end

❹   def most_common_words(input, limit=25)
      freq = Hash.new()
      sample = input.downcase.split(/\W/)
      sample.uniq.each do |word|
❺       freq[word] = sample.count_of(word) unless word == ''
      end
❻     words = freq.keys.sort_by do |word|
        freq[word]
      end.reverse.map do |word|    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> map</code></strong> Method</span></em>
❼       "#{word} #{freq[word]}"
      end
❽     return words[0, limit]
    end

❾ puts most_common_words(readlines.to_s).join("\n")</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id011"/>How It Works</h2></div></div></div><p>The new method of Array is called <code class="literal">count_of</code> (❶); it takes an argument called <code class="literal">item</code> and returns the number of times that <code class="literal">item</code> is found within the Array in question. The default implementation of this method (❷) uses an Array method called <code class="literal">grep</code>, which takes an argument and returns all elements that match that element. Since we want the count of items matching the condition (and not those items themselves), we call the <code class="literal">size</code> method on the return value of <code class="literal">grep</code>.</p><p>The line at ❸ shows a way to accomplish the same task using the <code class="literal">inject</code> method, which we’ve already covered.</p><p>At ❹ we define the <code class="literal">most_common_words</code> method; it takes a mandatory <code class="literal">input</code> argument and an optional <code class="literal">limit</code> argument, which defaults to 25. We define a new Hash variable called <code class="literal">freq</code>, which will store the frequency of each word. We define an Array called <code class="literal">sample</code>, which consists of a case-insensitive input, broken at <a class="indexterm" id="idx-CHP-4-0418"/>each whitespace portion (the <code class="literal">\W</code> in the regular expression means <span class="emphasis"><em>any whitespace</em></span>). We loop through each unique <code class="literal">word</code> in the sample, adding its frequency to the <code class="literal">freq</code> Hash. I chose to skip the empty string, not counting it as a word (❺).<a class="indexterm" id="idx-CHP-4-0419"/><a class="indexterm" id="idx-CHP-4-0420"/></p><p>Once we’ve constructed the <code class="literal">freq</code> Hash, we want to use our <code class="literal">limit</code> argument. We loop through the keys of <code class="literal">freq</code> (which are the actual words themselves) and sort them by their frequency of appearance (❻). We want to see the most common words, rather than the least common words, so we <code class="literal">reverse</code> that sorted list, and <code class="literal">map</code> an operation onto it.</p><p>The <code class="literal">map</code> operation is very common in the world of functional programming. It’s often used as an alternative to looping, so in Ruby, we’ll often find that we want to use either the <code class="literal">each</code> method or the <code class="literal">map</code> method for a given task, depending on our needs. Generally, if you want to make destructive changes to a list of items, use <code class="literal">each</code>; if you want to make a new list of transformed items, use <code class="literal">map</code>. Let’s try <code class="literal">map</code> in irb. I’ve been showing you lots of irb examples with digits, so now I’ll show you a quick way to create an Array of them. Ruby has a class called <span class="emphasis"><em>Range</em></span>, which indicates the items from a given starting point to a given endpoint. We’ll use that class to construct an Array.<a class="indexterm" id="idx-CHP-4-0421"/></p><a id="I_programlisting4_d1e6411"/><pre class="programlisting">irb(main):001:0&gt; digit_range = 0..9    <em class="lineannotation"><span class="lineannotation">Ranges</span></em>
=&gt; 0..9
irb(main):002:0&gt; digit_range.class
=&gt; Range
irb(main):003:0&gt; digits = digit_range.to_a
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
irb(main):004:0&gt; digits.map { |num| num + 1 }
=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
irb(main):005:0&gt; digits.map { |num| num + 10 }
=&gt; [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
irb(main):006:0&gt; digits.map { |num| num * 2 }
=&gt; [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
irb(main):007:0&gt; digits.map { |num| num ** 2 }
=&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
irb(main):008:0&gt; digits
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
irb(main):009:0&gt; digits.map! { |num| num ** 2 }
=&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
irb(main):010:0&gt; digits
=&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</pre><p>As you can see, <code class="literal">map</code> is very convenient for any sort of transformation of a list of items that can be expressed with a simple description, such as <span class="emphasis"><em>double all of these things</em></span> on line six, or <span class="emphasis"><em>square all of these things</em></span> on line seven. Remember that <code class="literal">map</code> is non-destructive (as shown on line eight) unless you call it with the exclamation mark (as shown on lines nine and ten). We’ll <code class="literal">map</code> an operation onto the words, sorted in <code class="literal">reverse</code> order by frequency of appearance in our sample text. The operation to be mapped (❼) is the outputting of a String consisting of the <code class="literal">word</code> itself followed by a space character, followed by the frequency of that <code class="literal">word</code>.</p><p>All of this occurs within the assignment into the <code class="literal">words</code> variable on the same line as ❺, so each member of the Array called <code class="literal">words</code> is a String that is the result of the ❼ operation. At ❽, we <code class="literal">return</code> a subsection of the <code class="literal">words</code> Array, starting at the beginning, and limit it to a length equal to the <code class="literal">limit</code> argument. Since the output of the <code class="literal">most_common_words</code> method is an Array and we want to print it as a String, we do a <code class="literal">join</code> with a newline at ❾, making each Array item a separate line.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id011"/>Running the Script</h2></div></div></div><p>We call this script with <code class="literal">ruby most_common_words.rb filename_to_analyze</code>, calling <code class="literal">readlines.to_s</code> on the <code class="literal">filename</code> argument, which provides the input to analyze. Let’s try it on itself.<a class="indexterm" id="idx-CHP-4-0422"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id010"/>The Results</h2></div></div></div><a id="I_programlisting4_d1e6487"/><pre class="programlisting">$ ruby <a class="indexterm" id="idx-CHP-4-0423"/>most_common_words.rb most_common_words.rb
<a class="indexterm" id="idx-CHP-4-0424"/>word 9
end 6
freq 5
do 3
sample 3
most_common_words 3
count 3
item 3
0 2
count_of 2
words 2
input 2
def 2
limit 2
each_item 2
split 1
unless 1
1 1
downcase 1
map 1
rb 1
array 1
ruby 1
usr 1
each 1</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id008"/>Hacking the Script</h2></div></div></div><p>Just as an aside, you could also implement <code class="literal">count_of</code> using this line:<a class="indexterm" id="I_indexterm4_d1e6507"/><a class="indexterm" id="I_indexterm4_d1e6510"/><a class="indexterm" id="I_indexterm4_d1e6513"/></p><a id="I_programlisting4_d1e6518"/><pre class="programlisting">dup.delete_if { |i| i != item }.size || 0</pre></div></div>
<div class="sect1" title="#14 Rotating Characters in a String (rotate.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp14_rotating_characters_in_a_string_"/>#14 Rotating Characters in a String (rotate.rb)</h1></div></div></div><p>We’ll close with a simple program that rotates the order of characters within a String. We’ll accomplish this via a <a class="indexterm" id="idx-CHP-4-0425"/>method that takes a character (meaning a String of length one) argument. The String to be rotated will try to keep <a class="indexterm" id="idx-CHP-4-0426"/>rotating until the character argument appears at index <code class="literal">0</code>. If the character is not found at all, it will return <code class="literal">nil</code>.<a class="indexterm" id="idx-CHP-4-0427"/><a class="indexterm" id="idx-CHP-4-0428"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id013"/>The Code</h2></div></div></div><a id="I_programlisting4_d1e6550"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-4-0429"/>rotate.rb

  class String

❶   def rotate(char)
❷     return nil unless <a class="indexterm" id="idx-CHP-4-0430"/>self.match(char)
❸     return self if (self[0] == char[0])
❹     chars = self.split(//)
      return ([chars.pop] + chars).join('').rotate(char)    <em class="lineannotation"><span class="lineannotation"><a class="indexterm" id="idx-CHP-4-0431"/>Recursion</span></em>
    end

❻   def rotate!(char)
      replace(rotate(char))
    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id012"/>How It Works</h2></div></div></div><p>This program introduces a concept called <span class="emphasis"><em>recursion</em></span>, which (like <code class="literal">map</code>) is used frequently in functional programming, often as an alternative to looping. A <span class="emphasis"><em>recursive operation</em></span> is one that is partly defined in terms of itself. Let’s explore the concept in our <code class="literal">rotate.rb</code> script.</p><p>The definition of the main <code class="literal">rotate</code> method that we add to the String object is at ❶. I said earlier that if the character argument (called <code class="literal">char</code>) is not found within the main String (here called <code class="literal">self</code>), the rotate method will return <code class="literal">nil</code> (❷). If <code class="literal">char</code> is the initial character within the String, we don’t need to do any rotating, so it will return the main String under those conditions (❸). The numeral <code class="literal">0</code> within braces is not an anonymous Array—it’s a method of <code class="literal">self</code> that returns the first character of a String. We call that method on both the <code class="literal">self</code> String and the single-character String <code class="literal">char</code>. When those two Strings are equal, we know that the <code class="literal">self</code> String starts with the requested rotation character.</p><div class="note" title="Note"><h3 class="title"><a id="note-34"/>Note</h3><p><span class="emphasis"><em>We use an index of zero within the braces to return the first character in the String on line ❸ because Ruby (like many languages) starts counting indexes at zero, not one</em></span>.<a class="indexterm" id="idx-CHP-4-0432"/><a class="indexterm" id="idx-CHP-4-0433"/></p></div><p>We know that if we’ve gotten this far without returning, we have a String that is eligible for rotation (because it contains <code class="literal">char</code>), and needs to be rotated to match (because it doesn’t start with <code class="literal">char</code>). We perform the rotation by defining a new variable called <code class="literal">chars</code> (❹), which is an Array of each character within the String. We use the <code class="literal">pop</code> method at ❺ to remove the last character from <code class="literal">chars</code>, remembering that <code class="literal">pop</code> is destructive (despite the lack of an exclamation mark, for historical reasons). The <code class="literal">chars</code> Array now contains all the <a class="indexterm" id="idx-CHP-4-0434"/>characters except the one that was just <code class="literal">pop</code>ped off. If we add those Arrays together, putting the Array containing the <code class="literal">pop</code>ped character first, we’ve just created a new Array in which the last member has been moved from the end to the front, shifting all other members back.<a class="indexterm" id="idx-CHP-4-0435"/></p><p>We wrap the <code class="literal">pop</code>ped character in brackets so that we can more easily add the two Arrays (the <code class="literal">pop</code>ped off character and the remaining characters, respectively). Since the <code class="literal">rotate</code> method will eventually return a String, we <code class="literal">join</code> our Array elements with an empty String separator. This produces a String that has been rotated once. Are we done? Not really.<a class="indexterm" id="idx-CHP-4-0436"/></p><div class="sect3" title="Recursion"><div class="titlepage"><div><div><h3 class="title"><a id="recursion"/>Recursion</h3></div></div></div><p>The rotation works well, but it might not be enough. What if we need to <code class="literal">rotate</code> multiple characters before we find a match? There’s an easy way to do that; it’s called the <code class="literal">rotate</code> method—you know, the method we’re still in the process of defining. We can just call <code class="literal">rotate</code> on our newly created String.<a class="indexterm" id="idx-CHP-4-0437"/></p><p>We already know that our newly created String will pass the test at ❷. We’re mainly interested in whether or not it needs further rotation. That’s the test at ❸. If only one rotation was needed, this second call to the <code class="literal">rotate</code> method will return the newly created String, and since the second call to <code class="literal">rotate</code> was within a <code class="literal">return</code> call on the line at ❺, the main call to <code class="literal">rotate</code> will <code class="literal">return</code> that value, as well.</p><p>If only one rotation was not enough to find a match, our second call to the <code class="literal">rotate</code> method will do the same shifting of characters (starting at ❹) that we just discussed, culminating in yet another call to <code class="literal">rotate</code>, this time on a String that has been rotated two characters’ worth, and so on.</p><p>Each successive time <code class="literal">rotate</code> is called, the String to be operated on is one step closer to our desired result. This is very common in recursion, which we will be discussing in greater depth in later chapters. As you can see at ❻, we also define a destructive version called <code class="literal">rotate!</code>.<a class="indexterm" id="idx-CHP-4-0438"/></p></div></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id012"/>Running the Script</h2></div></div></div><p>Let’s look at some output using irb with <code class="literal">irb -r rotate.rb</code>.<a class="indexterm" id="idx-CHP-4-0439"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id011"/>The Results</h2></div></div></div><a id="I_programlisting4_d1e6750"/><pre class="programlisting">$ irb -r <a class="indexterm" id="idx-CHP-4-0440"/>rotate.rb
irb(main):001:0&gt; 'I am a String.'.rotate('a')
=&gt; "a String.I am "
irb(main):002:0&gt; 'I am a String.'.rotate('S')
=&gt; "String.I am a "</pre><p>In each case, the String on which <code class="literal">rotate</code> is called has its characters shifted until the character asked for is the first character in the String. That’s it for this chapter’s scripts.</p></div></div>
<div class="sect1" title="Chapter Recap"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_recap-id002"/>Chapter Recap</h1></div></div></div><p>What was new in this chapter?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>End-of-line differences among operating systems</p></li><li class="listitem"><p>Regular expressions, including the <code class="literal">?</code> counter</p></li><li class="listitem"><p>The <code class="literal">sprintf</code> method</p></li><li class="listitem"><p>Multiplication of Arrays</p></li><li class="listitem"><p>The <code class="literal">inject</code> method</p></li><li class="listitem"><p>Regular expressions with the <code class="literal">+</code> counter</p></li><li class="listitem"><p>Objects as the results of blocks</p></li><li class="listitem"><p>Calling successive methods on the output of methods (“chaining” methods)</p></li><li class="listitem"><p>Using new methods of Open Classes in quick scripts</p></li><li class="listitem"><p>Multiplication of Strings</p></li><li class="listitem"><p>The <code class="literal">grep</code> method</p></li><li class="listitem"><p>The <code class="literal">map</code> method</p></li><li class="listitem"><p>The Range class</p></li><li class="listitem"><p>Recursion</p></li></ul></div><p>That’s quite a bit, including some important new functional concepts like recursion and a few very handy functional methods. You’ll need these concepts as we move on. Let’s proceed to some more complex treatment of numbers in <a class="xref" href="ch05.html" title="Chapter 5. Number Utilities">Chapter 5</a>.<a class="indexterm" id="I_indexterm4_d1e6834"/><a class="indexterm" id="I_indexterm4_d1e6837"/><a class="indexterm" id="I_indexterm4_d1e6840"/><a class="indexterm" id="I_indexterm4_d1e6845"/></p></div></body></html>