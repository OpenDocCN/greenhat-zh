<html><head></head><body><div class="part" title="Part&#xA0;II-2.&#xA0;TCP/IP NETWORK INTERFACE/INTERNET LAYER CONNECTION PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_network_interfaceinternet_layer_co"/>Part II-2. TCP/IP NETWORK INTERFACE/INTERNET LAYER CONNECTION PROTOCOLS</h1></div></div></div><div class="partintro" id="id3205034" title="TCP/IP NETWORK INTERFACE/INTERNET LAYER CONNECTION PROTOCOLS"><div/><p><a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a></p><p><a class="xref" href="ch14.html" title="Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP REVERSE ADDRESS RESOLUTION PROTOCOL (RARP)">Chapter 14</a></p><p>The second layer of the OSI Reference Model is the <span class="emphasis"><em>data link layer</em></span>; it corresponds to the TCP/IP <span class="emphasis"><em>network interface layer</em></span>. At this layer, most local area network (LAN), wide area network (WAN), and wireless LAN (WLAN) technologies are defined, such as Ethernet and IEEE 802.11.</p><p>The third layer of the OSI Reference Model is the <span class="emphasis"><em>network layer</em></span>, also called the <span class="emphasis"><em>internet layer</em></span> in the TCP/IP model. At this layer, internetworking protocols are defined, the most notable being the Internet Protocol (IP).</p><p>The second and third layers are intimately related, because messages sent at the network layer must be carried over individual physical networks at the data link layer. They perform different tasks, but as neighbors in the protocol stack, they must cooperate with each other.</p><p>A set of protocols serves the important task of linking together these two layers and allowing them to work together. The problem is deciding where exactly these protocols should live. They are sort of the black sheep of the networking world. Nobody denies their importance, but they always think they belong in "the other guy's" layer. For example, since these protocols pass data on layer 2 networks, the folks who deal with layer 2 technologies say the protocols belong at layer 3. But those who work with layer 3 protocols consider these low-level protocols that provide services to layer 3, and hence put them as part of layer 2.</p><p>So where do these protocols go? Well, to some extent, it doesn't really matter. I consider them somewhat special, so I gave them their own home. Welcome to networking layer limbo, also known as OSI model layer 2.5. This is where I put a couple of protocols that serve as glue between the data link and network layers. The main job performed here is address resolution, or providing mappings between layer 2 and layer 3 addresses. This resolution can be done in either direction, and is represented by the two TCP/IP protocols described in this part: the Address Resolution Protocol (ARP) and the Reverse Address Resolution Protocol (RARP), which, despite their similarities, are used for rather different purposes.</p><p>I suggest familiarity with the basics of layer 2 and layer 3 (described in Parts I-2 and I-3) before proceeding here. In particular, some understanding of IP addressing is helpful, though not strictly necessary.</p></div></div>
<div class="chapter" title="Chapter&#xA0;13.&#xA0;ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)"><div class="titlepage"><div><div><h1 class="title"><a id="address_resolution_and_the_tcpip_address"/>Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e14007"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Communication on an internetwork is accomplished by sending data at layer 3 using a network layer address, but the actual transmission of that data occurs at layer 2 using a data link layer address. This means that every device with a fully specified networking protocol stack will have both a layer 2 and a layer 3 address. It is necessary to define some way of being able to link these addresses together. Usually, this is done by taking a network layer address and determining what data link layer address goes with it. This process is called <span class="emphasis"><em>address resolution</em></span>.<a class="indexterm" id="idx-CHP-13-0577"/></p><p>In this chapter, I look at the problem of address resolution at both a conceptual and practical level, with, of course, a focus on how it is done in the TCP/IP protocol suite. I begin with an overview of address resolution in gen-eral terms, which describes the issues involved in the process. I then fully describe the TCP/IP Address Resolution Protocol (ARP), probably the best-known and most commonly used <a class="indexterm" id="idx-CHP-13-0578"/>address resolution technique. I then provide a brief look <a class="indexterm" id="idx-CHP-13-0579"/>at how address resolution is done for multicast addresses in the Internet Protocol (IP), and finally, the method used in the new IP version 6 (IPv6).</p><div class="sect1" title="Address Resolution Concepts and Issues"><div class="titlepage"><div><div><h1 class="title"><a id="address_resolution_concepts_and_issues"/>Address Resolution Concepts and Issues</h1></div></div></div><p>Due to the prominence of TCP/IP in the world of networking, most discussions of address resolution jump straight to TCP/IP's ARP. This protocol is indeed important, and we will take a look at it later in this chapter. However, the basic problem of address resolution is not unique to any given implementation that deals with it, such as ARP. To provide better understanding of resolving addresses between the data link layer and the network layer and to support our examination of ARP, we'll begin by looking at the matter in more general terms.</p><p>I start by discussing the need for address resolution in general terms. I then describe the two main methods for solving the address resolution problem: direct mapping and dynamic resolution. I also explore some of the efficiency issues involved in practical dynamic address resolution, with a focus on the importance of caching.</p><div class="sect2" title="The Need for Address Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="the_need_for_address_resolution"/>The Need for Address Resolution</h2></div></div></div><p>Some people may balk at the notion of address resolution and the need for protocols that perform this function. In <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>'s discussion of the OSI Reference Model, I talked extensively about how the whole point of having conceptual layers was to separate logical functions and allow higher-layer protocols to be hidden from lower-layer details. Given this, why do you need address resolution protocols that tie protocols and layers together?</p><p>This is true. However, the OSI Reference Model is exactly that—a <span class="emphasis"><em>model</em></span>. There are often practicalities that arise that require solutions that don't strictly fit the layer model. When the model doesn't fit reality, the model must yield. And so it is in dealing with the problem of address resolution.</p><div class="sect3" title="Addressing at Layer 2 and Layer 3"><div class="titlepage"><div><div><h3 class="title"><a id="addressing_at_layer_2_and_layer_3"/>Addressing at Layer 2 and Layer 3</h3></div></div></div><p>When you consider the seven layers of the OSI Reference Model, there are two that deal with addressing: the data link layer and the network layer. The physical layer is not strictly concerned with addressing at all, but rather, only with sending at the bit level. The layers above the network layer all work with network layer addresses.</p><p>But why is addressing done at two different layers? The answer is that they are very different types of addresses that are used for different purposes. The layer 2 addresses (such as IEEE 802 MAC addresses) are used for local transmissions between hardware devices that can communicate directly. They are used to implement basic local area network (LAN), wireless LAN (WLAN), and wide area network (WAN) technologies. In contrast, layer 3 addresses (most commonly, IP addresses) are used in internetworking to create the equivalent of a massive virtual network at the network layer.</p><p>The most important distinction between these types of addresses is between layers 2 and 3: Layer 2 deals with directly connected devices (on the same network), while layer 3 deals with <span class="emphasis"><em>indirectly</em></span> connected devices (as well as directly connected ones). Say, for example, you want to connect to the web server at <a class="indexterm" id="idx-CHP-13-0580"/><a class="ulink" href="http://www.tcpipguide.com">http://www.tcpipguide.com</a>. This is a website that runs on a server that has an Ethernet card in it that's used for connecting it to its Internet service provider site. However, even if you know its <a class="indexterm" id="idx-CHP-13-0581"/>MAC address, you cannot use it to talk directly to this server using the Ethernet card in your home PC, because the devices are on different networks—in fact, they may be on different continents!</p><p>Instead, you communicate at layer 3, using the IP and higher-layer protocols such as the Transmission Control Protocol (TCP) and Hypertext Transfer Protocol (HTTP). Your request is <span class="emphasis"><em>routed</em></span> from your home <a class="indexterm" id="idx-CHP-13-0582"/>machine, through a sequence of routers to the server at <span class="emphasis"><em>The TCP/IP Guide</em></span>, and the response is routed back to you. The communication is, logically, at layers 3 and above; you send the request not to the <a class="indexterm" id="idx-CHP-13-0583"/>MAC address of the server's network card, but rather to the server's IP address.</p><p>However, though you can <span class="emphasis"><em>virtually</em></span> connect devices at layer 3, these connections are really conceptual only. When you send a request using IP, it is sent one <span class="emphasis"><em>hop</em></span> at a time, from one physical network to the next. At each of these hops, an actual transmission occurs at the physical and data link layers. When your request is sent to your local router at layer 3, the actual request is encapsulated in a frame using whatever method you physically connect to the router, and then passed to the router using its data link layer address. The same happens for each subsequent step, until finally, the router nearest the destination sends to the destination using its data link (MAC) address. This is illustrated in <a class="xref" href="ch13.html#why_address_resolution_is_necessary_even" title="Figure 13-1. Why address resolution is necessary Even though conceptually the client and server are directly connected at layer 3, in reality, information passing between them goes over multiple layer 2 links. In this example, a client on the local network is accessing a server somewhere on the Internet. Logically, this connection can be made directly between the client and server, but in reality, it is a sequence of physical links at layer 2. In this case, there are six such links, most of them between routers that lie between the client and server. At each step, the decision of where to send the data is made based on a layer 3 address, but the actual transmission must be performed using the layer 2 address of the next intended recipient in the route.">Figure 13-1</a>.</p><div class="figure"><a id="why_address_resolution_is_necessary_even"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e14106"/><img alt="Why address resolution is necessary Even though conceptually the client and server are directly connected at layer 3, in reality, information passing between them goes over multiple layer 2 links. In this example, a client on the local network is accessing a server somewhere on the Internet. Logically, this connection can be made directly between the client and server, but in reality, it is a sequence of physical links at layer 2. In this case, there are six such links, most of them between routers that lie between the client and server. At each step, the decision of where to send the data is made based on a layer 3 address, but the actual transmission must be performed using the layer 2 address of the next intended recipient in the route." src="httpatomoreillycomsourcenostarchimages287769.png.jpg"/></div></div><p class="title">Figure 13-1. Why address resolution is necessary Even though conceptually the client and server are directly connected at layer 3, in reality, information passing between them goes over multiple layer 2 links. In this example, a client on the local network is accessing a server somewhere on the Internet. Logically, this connection can be made directly between the client and server, but in reality, it is a sequence of physical links at layer 2. In this case, there are six such links, most of them between routers that lie between the client and server. At each step, the decision of where to send the data is made based on a layer 3 address, but the actual transmission must be performed using the layer 2 address of the next intended recipient in the route.</p></div><p>The basic problem is that IP addresses are at <span class="emphasis"><em>too high of a level</em></span> for the physical hardware on networks to deal with; they don't understand what they are. When your request shows up at the router that connects to <span class="emphasis"><em>The TCP/IP Guide</em></span>, it can see the <a class="ulink" href="http://www.tcpipguide.com">http://www.tcpipguide.com</a> server's IP address, but that isn't helpful: It needs to send to server's <span class="emphasis"><em>MAC address</em></span>.<a class="indexterm" id="idx-CHP-13-0584"/></p><p>The identical issue exists even with communication between devices on a LAN. Even if the web server is sitting on the same desk as the client, the communication is logically at the IP layer, but must also be accomplished at the data link layer. This means you need a way of translating between the addresses at these two layers. This process is called <span class="emphasis"><em>address resolution</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-68"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Address resolution is required because internetworked devices communicate logically using layer 3 addresses, but the actual transmissions between devices take place using layer 2 (hardware) addresses.</p></div></div><div class="sect3" title="General Address Resolution Methods"><div class="titlepage"><div><div><h3 class="title"><a id="general_address_resolution_methods"/>General Address Resolution Methods</h3></div></div></div><p>In fact, not only do you need to have a way of making this translation, but you need to be concerned with the manner in which it is done. Since the translation occurs for each hop of every datagram sent over an internetwork, the efficiency of the process is extremely important. You don't want to use a resolution method that takes a lot of network resources.<a class="indexterm" id="idx-CHP-13-0585"/></p><p>Address resolution can be accomplished in two basic ways: <a class="indexterm" id="idx-CHP-13-0586"/>direct mapping and dynamic resolution.</p><div class="note" title="Note"><h3 class="title"><a id="note-57"/>Note</h3><p><span class="emphasis"><em>By necessity, it is not possible to have a fully general address resolution method that works automatically. Since it deals with linking data link layer addresses to network layer addresses, the implementation must be specific to the technologies used in each of these layers. The only method that could really be considered generic would be the use of static, manually updated tables that say, link this layer 3 address to this layer 2 address." This, of course, is not automatic and brings with it all the limitations of manual configuration</em></span>.</p></div></div></div><div class="sect2" title="Address Resolution Through Direct Mapping"><div class="titlepage"><div><div><h2 class="title"><a id="address_resolution_through_direct_mappin"/>Address Resolution Through Direct Mapping</h2></div></div></div><p>Network layer addresses must be resolved into data link layer addresses numerous times during the travel of each datagram across an internetwork. You therefore want the process to be as simple and efficient as possible. The easiest method of accomplishing this is to do <span class="emphasis"><em>direct mapping</em></span> between the two types of addresses.</p><div class="sect3" title="How Direct Mapping Works"><div class="titlepage"><div><div><h3 class="title"><a id="how_direct_mapping_works"/>How Direct Mapping Works</h3></div></div></div><p>In the direct mapping technique, a formula is used to map the higher-layer address into the lower-layer address. This is the simpler and more efficient technique, but it has some limitations, especially regarding the size of the data link layer address compared to the network layer address.</p><p>The basic idea behind direct mapping is to choose a scheme for layer 2 and layer 3 addresses so that you can determine one from the other using a simple algorithm. This enables you to take the layer 3 address and follow a short procedure to convert it into a layer 2 address. In essence, whenever you have the layer 3 address, you already have the layer 2 address.</p><p>The simplest example of <a class="indexterm" id="idx-CHP-13-0587"/>direct mapping would be if you used the same structure and semantics for both data link and network layer addresses. This is generally impractical, because the two types of addresses serve different purposes, and are therefore based on incompatible standards. However, you can still perform direct mapping if you have the flexibility of creating layer 3 addresses that are large enough to encode a complete data link layer address within them. Then determining the layer 2 address is a simply matter of selecting a certain portion of the layer 3 address.</p><p>As an example, consider a simple LAN technology like <a class="indexterm" id="idx-CHP-13-0588"/>ARCNet. It uses a short, 8-bit data link layer address, with valid values of 1 to 255, which can be assigned by an administrator. You could easily set up an IP network on such a LAN by taking a Class C network and using the <a class="indexterm" id="idx-CHP-13-0589"/>ARCNet data link layer as the last octet. So, if the network was, for example, 222.101.33.0, you could assign the IP address 222.101.33.1 to the device with ARCNet address #1, the IP address 222.101.33.29 to the device with ARCNet address #29, and so forth, as shown in <a class="xref" href="ch13.html#address_resolution_through_direct_-id001" title="Figure 13-2. Address resolution through direct mapping With a small hardware address size, you can easily map each hardware address to a layer 3 address. As you can see in this figure, when the hardware address is small, it is easy to define a mapping that directly corresponds to a portion of a layer 3 address. In this example, an 8-bit MAC address, such as the one used for ARCNet, is mapped to the last byte of the device's IP address, thereby making address resolution a trivial matter.">Figure 13-2</a>.</p><div class="figure"><a id="address_resolution_through_direct_-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e14206"/><img alt="Address resolution through direct mapping With a small hardware address size, you can easily map each hardware address to a layer 3 address. As you can see in this figure, when the hardware address is small, it is easy to define a mapping that directly corresponds to a portion of a layer 3 address. In this example, an 8-bit MAC address, such as the one used for ARCNet, is mapped to the last byte of the device's IP address, thereby making address resolution a trivial matter." src="httpatomoreillycomsourcenostarchimages287771.png.jpg"/></div></div><p class="title">Figure 13-2. Address resolution through direct mapping With a small hardware address size, you can easily map each hardware address to a layer 3 address. As you can see in this figure, when the hardware address is small, it is easy to define a mapping that directly corresponds to a portion of a layer 3 address. In this example, an 8-bit MAC address, such as the one used for ARCNet, is mapped to the last byte of the device's IP address, thereby making address resolution a trivial matter.</p></div><p>The appeal of this system is obvious. Conceptually, it is trivial to understand—to get the hardware address for a device, you just use the final eight bits of the IP address. It's also very simple to program devices to perform, and highly efficient, requiring no exchange of data on the network at all.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-69"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> When the layer 2 address is smaller than the layer 3 address, it is possible to define a direct mapping between them so that the hardware address can be determined directly from the network layer address. This makes address resolution extremely simple, but reduces flexibility in how addresses are assigned.</p></div></div><div class="sect3" title="Problems with Direct Mapping"><div class="titlepage"><div><div><h3 class="title"><a id="problems_with_direct_mapping"/>Problems with Direct Mapping</h3></div></div></div><p>Unfortunately, direct mapping works only when it is possible to express the data link layer address as a function of the network layer address. Consider instead the same IP address, 222.101.33.29, which is running on an Ethernet network. Here, the data link layer addresses are hardwired into the hardware itself (they can sometimes be overridden, but usually this is not done). More important, the MAC address is 48 bits wide, not 8. This means the layer 2 address is bigger than the layer 3 address, and there is no way to do direct mapping, as <a class="xref" href="ch13.html#address_resolution_problems_with_large_h" title="Figure 13-3. Address resolution problems with large hardware address size Direct mapping is impossible when the layer 2 address is larger in size than the layer 3 address.">Figure 13-3</a> illustrates. As you can see, when the layer 2 address is larger in size than the layer 3 address, it is not possible to define a mapping between them that can be used for address resolution.</p><div class="figure"><a id="address_resolution_problems_with_large_h"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e14228"/><img alt="Address resolution problems with large hardware address size Direct mapping is impossible when the layer 2 address is larger in size than the layer 3 address." src="httpatomoreillycomsourcenostarchimages287773.png.jpg"/></div></div><p class="title">Figure 13-3. Address resolution problems with large hardware address size Direct mapping is impossible when the layer 2 address is larger in size than the layer 3 address.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-58"/>Note</h3><p><span class="emphasis"><em>When the hardware address size exceeds the network layer address size, you could do a partial mapping. For example, you could use the IP address to get</em></span> part <span class="emphasis"><em>of the MAC address and hope you don't have any duplication in the bits you didn't use. This method is not well suited to regular transmissions, but is used for resolving multicast addresses in IPv4 to Ethernet addresses. You'll see how this is done near the end of the chapter</em></span>.<a class="indexterm" id="idx-CHP-13-0590"/></p></div><p>In general, then, direct mapping is not possible when the layer 3 address is smaller than the layer 2 address. Consider that Ethernet is the most popular technology at layer 2 and uses a 48-bit address, and IP is the most popular technology at layer 3 and uses a 32-bit address. This is one reason why direct mapping is a technique that is not widely used.</p><p>What about the next generation of IP? IPv6 supports massive 128-bit addresses (see <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a>). Furthermore, regular (unicast) addresses are even defined using a method that creates them from data link layer addresses using a special mapping. This would, in theory, allow IPv6 to use direct mapping for address resolution.</p><p>However, the decision was made to have IPv6 use dynamic resolution just as IPv4 does. One reason might be historical, since IPv4 uses dynamic resolution. However, the bigger reason is probably due to a disadvantage of direct mapping: its inflexibility. <a class="indexterm" id="idx-CHP-13-0591"/>Dynamic <a class="indexterm" id="idx-CHP-13-0592"/>resolution is a more generalized solution, because it allows data link layer and network layer addresses to be independent, and its disadvantages can be mostly neutralized through careful implementation, as you will see.</p><p>In fact, evidence for this can be seen in the fact that dynamic resolution of IP is defined on ARCNet, the example I just used. You could do direct mapping there, but it restricts you to a certain pattern of IP addressing that reduces flexibility.</p></div></div><div class="sect2" title="Dynamic Address Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="dynamic_address_resolution"/>Dynamic Address Resolution</h2></div></div></div><p>You just saw that direct mapping provides a simple and highly efficient means of resolving network layer addresses into data link layer addresses. Unfortunately, it is a technique that you either cannot or should not use in a majority of cases. You cannot use it when the size of the data link layer address is larger than that of the network layer address. You shouldn't use it when you need flexibility, because direct mapping requires you to make layer 3 and layer 2 addresses correspond.</p><p>The alternative to direct mapping is a technique called <span class="emphasis"><em>dynamic address resolution</em></span>. This uses a special protocol that allows a device with only an IP address to determine the corresponding data link layer address, even if the two address types take completely different forms. This is normally done by interrogating one or more other devices on a local network to determine what data link layer address corresponds to a given IP address. This is more complex and less efficient than direct mapping, but it's more flexible.</p><div class="sect3" title="How Dynamic Addressing Works"><div class="titlepage"><div><div><h3 class="title"><a id="how_dynamic_addressing_works"/>How Dynamic Addressing Works</h3></div></div></div><p>To understand how dynamic addressing works, you can consider a simple analogy. I'm sure you've seen a limousine driver who is waiting to pick up a person at the airport. (Well, you've seen it in a movie, haven't you?) This is similar to the problem here: The driver knows the name of the person who will be transported, but not the person's face (a type of "local address" in a manner of speaking!). To find the person, the driver holds up a card bearing that person's name. Everyone other than that person ignores the card, but the named individual should recognize it and approach the driver.</p><p>You do the same thing with dynamic address resolution in a network. Let's say that Device A wants to send to Device B but knows only Device B's network layer address (its "name") and not its data link layer address (its "face"). It broadcasts a layer 2 frame containing the layer 3 address of Device B—this is like holding up the card with someone's name on it. The devices other than Device B don't recognize this layer 3 address and ignore it. Device B, however, knows its own network layer address. It recognizes this in the broadcast frame and sends a direct response back to Device A. This tells Device A what Device B's layer 2 address is, and the resolution is complete. <a class="xref" href="ch13.html#dynamic_address_resolution_the_device_th" title="Figure 13-4. Dynamic address resolution The device that wants to send data broadcasts a request asking for a response with a hardware address from the other device. Device A needs to send data to Device B, but knows only its IP address (IPB) and not its hardware address. Device A broadcasts a request asking to be sent the hardware address of the device using the IP address IPB. Device B responds back to Device A directly with the hardware address.">Figure 13-4</a> illustrates the process.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-70"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Dynamic address resolution</em></span> is usually implemented using a special protocol. A device that knows only the network layer address of another device can use this protocol to request the other device's hardware address.</p></div><div class="figure"><a id="dynamic_address_resolution_the_device_th"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e14300"/><img alt="Dynamic address resolution The device that wants to send data broadcasts a request asking for a response with a hardware address from the other device. Device A needs to send data to Device B, but knows only its IP address (IPB) and not its hardware address. Device A broadcasts a request asking to be sent the hardware address of the device using the IP address IPB. Device B responds back to Device A directly with the hardware address." src="httpatomoreillycomsourcenostarchimages287775.png.jpg"/></div></div><p class="title">Figure 13-4. Dynamic address resolution The device that wants to send data broadcasts a request asking for a response with a hardware address from the other device. Device A needs to send data to Device B, but knows only its IP address (IPB) and not its hardware address. Device A broadcasts a request asking to be sent the hardware address of the device using the IP address IPB. Device B responds back to Device A directly with the hardware address.</p></div><p>Direct mapping is very simple, but as you can see, <a class="indexterm" id="idx-CHP-13-0593"/>dynamic <a class="indexterm" id="idx-CHP-13-0594"/>resolution isn't exactly rocket science either! It's a simple technique that is easily implemented. Furthermore, it removes the restrictions associated with direct mapping. There is no need for any specific relationship between the network layer address and the data link layer address; they can have a completely different structure and size.</p><p>There is one nagging issue though: the efficiency problem. Where direct mapping involves a quick calculation, dynamic resolution requires you to use a protocol to send a message over the network. Fortunately, there are techniques that you can employ to remove some of the sting of this cost through careful implementation.</p></div><div class="sect3" title="Dynamic Address Resolution Caching and Efficiency Issues"><div class="titlepage"><div><div><h3 class="title"><a id="dynamic_address_resolution_caching_and_e"/>Dynamic Address Resolution Caching and Efficiency Issues</h3></div></div></div><p>You've now seen how dynamic address resolution removes the restrictions that you saw in direct mapping, thereby allowing you to easily associate layer 2 and layer 3 addresses of any size or structure. The only problem with it is that each address resolution requires you to send an extra message that would not be required in direct mapping. Worse yet, since you don't know the layer 2 identity of the recipient, you must use a broadcast message (or at least a multicast), which means that many devices on the local network must take resources to examine the data frame and check which IP address is being resolved.<a class="indexterm" id="idx-CHP-13-0595"/></p><p>Sure, sending one extra message may not seem like that big of a deal, and the frame doesn't have to be very large since it contains only a network layer address and some control information. However, when you have to do this for <span class="emphasis"><em>every</em></span> hop of every datagram transmission, the overhead really adds up. For this reason, while basic dynamic address resolution is simple and functional, it's usually not enough. You must add some <span class="emphasis"><em>intelligence</em></span> to the implementation of address resolution in order to reduce the impact on the performance of continual address resolutions.</p><p>Consider that most devices on a local network send to only a small handful of other physical devices and tend to do so over and over again. This is a phenomenon known as <span class="emphasis"><em>locality of reference</em></span>, which is observed in a variety of different areas in the computing field. If you send a request to an Internet website from your office PC, it will need to go first to your company network's local router, so you will need to resolve the router's layer 2 address. If you later click a link on that site, that request will also need to go to the router. In fact, almost everything you do off your local network probably goes first to that same router (commonly called a <span class="emphasis"><em>default gateway</em></span>). Having to do a fresh resolution each time would be, well, stupid. It would be like having to look up the phone number of your best friend every time you want to call to say hello.<a class="indexterm" id="idx-CHP-13-0596"/></p><p>To avoid being accused of making address resolution protocols that are, well, stupid, designers always include a <span class="emphasis"><em>caching</em></span> mechanism. After a device's network layer address is resolved to a data link layer address, the link between the two is kept in the memory of the device for a period of time. When it needs the layer 2 address the next time, the device just does a quick lookup in its cache. This means that instead of doing a broadcast on every datagram, you do it only once for a whole sequence of datagrams.<a class="indexterm" id="idx-CHP-13-0597"/></p><p>Caching is by far the most important performance-enhancing tool in dynamic resolution. It transforms what would otherwise be a very wasteful process into one that, most of the time, is no less efficient than direct mapping. It does, however, add complexity. The cache table entries must be maintained. There is also the problem that the information in the table may become <span class="emphasis"><em>stale</em></span> over time. What happens if you change the network layer address or the data link layer address of a device? For this reason, cache entries must be set to expire periodically. The discussion of caching in TCP/IP's ARP later in this chapter shows some of the particulars of how these issues are handled.</p></div><div class="sect3" title="Other Enhancements to Dynamic Resolution"><div class="titlepage"><div><div><h3 class="title"><a id="other_enhancements_to_dynamic_resolution"/>Other Enhancements to Dynamic Resolution</h3></div></div></div><p>Other enhancements are also possible to the basic dynamic resolution scheme. Let's consider again our example of sending a request to the Internet. You send a request that needs to go to the local router, so you resolve its address and send it the request. A moment later, the reply comes back to the router to be sent to you, so the router needs <span class="emphasis"><em>your</em></span> address. Thus, it would have to do a dynamic resolution on you, even though you just exchanged frames. Again, this is stupid. Instead, you can improve efficiency through <span class="emphasis"><em>cross-resolution</em></span>; when Device A resolves the address of Device B, Device B also adds the entry for Device A to <span class="emphasis"><em>its</em></span> cache.<a class="indexterm" id="idx-CHP-13-0598"/></p><p>Another improvement can be made, too. If you think about it, the devices on a local network are going to talk to each other fairly often, even if they aren't chatting right now. If Device A is resolving Device B's network layer address, it will broadcast a frame that Devices C, D, E, and so on all see. Why not have them also update <span class="emphasis"><em>their</em></span> cache tables with resolution information that they see, for future use?</p><p>These and other enhancements all serve to cut down on the efficiency problems with dynamic address resolution. They combine to make dynamic resolution close enough to direct mapping in overall capability that there is no good reason not to use it. Once again, you can see some more particulars of this in the section that describes <a class="indexterm" id="idx-CHP-13-0599"/>ARP's caching feature.</p><p>Incidentally, one other performance-improving idea sometimes comes up during this discussion: Instead of preceding a datagram transmission with an extra broadcast step for address resolution, why not just broadcast the datagram and be done with it? You actually could do this, and if the datagram were small enough, it would be more efficient. Usually, though, datagrams are large, while resolution frames can be quite compact; it makes sense to do a small broadcast and then a large unicast rather than a large broadcast. Also, suppose you did broadcast this one datagram. What about the next datagram and the one after that? Each of these would then need to be broadcast also. When you do a resolution with caching, you need to broadcast only once in a while, instead of continually.</p></div></div></div></div>
<div class="sect1" title="TCP/IP Address Resolution Protocol (ARP)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_address_resolution_protocol_arp"/>TCP/IP Address Resolution Protocol (ARP)</h1></div></div></div><p>ARP is a full-featured, dynamic resolution protocol used to match IP addresses to underlying data link layer addresses. Originally developed for Ethernet, it has now been generalized to allow IP to operate over a wide variety of layer 2 technologies.</p><div class="note" title="Note"><h3 class="title"><a id="note-59"/>Note</h3><p><span class="emphasis"><em>The Address Resolution Protocol described here is used for resolving unicast addresses in version 4 of the Internet Protocol (IPv4). Multicast addresses under IPv4 use a direct mapping method, and IPv6 uses the new Neighbor Discovery (ND) Protocol instead of ARP. These methods are both discussed near the end of this chapter</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-71"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>For a discussion of ARP-related issues in networks with mobile IP devices, see <a class="xref" href="ch30.html" title="Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)">Chapter 30</a></em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-72"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>The software application <code class="literal">arp</code>, which is used to administer the TCP/IP ARP implementation on a host, is covered in <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a></em></span>.</p></div><p>Physical networks function at layers 1 and 2 of the OSI Reference Model and use data link layer addresses. In contrast, internetworking protocols function at layer 3, interconnecting these physical networks to create a possibly huge internetwork of devices specified using network layer addresses. Address resolution is the process whereby network layer addresses are resolved into data link layer addresses. This permits data to be sent one hop at a time across an internetwork.</p><p>The problem of address resolution was apparent from the very start in the development of the TCP/IP protocol suite. Much of the early development of IP was performed on the then-fledgling Ethernet LAN technology; this was even before Ethernet had been officially standardized as IEEE 802.3. It was necessary to define a way to map IP addresses to Ethernet addresses to allow communication over Ethernet networks.</p><p>As we have already seen in this chapter, there are two basic methods to correlate IP and Ethernet addresses: direct mapping or dynamic resolution. However, Ethernet addresses are 48 bits long, while IP addresses are only 32 bits, which immediately rules out direct mapping. Furthermore, the designers of IP wanted the flexibility that results from using the dynamic resolution model. To this end, they developed the TCP/IP <span class="emphasis"><em>Address Resolution Protocol (ARP)</em></span>. This protocol is described in one of the earliest of the Internet RFCs still in common use: RFC 826, "An Ethernet Address Resolution Protocol," which was published in 1982.</p><p>The name makes clear that ARP was originally developed for Ethernet. Thus, it represents a nexus between the most popular layer 2 LAN protocol and the most popular layer 3 internetworking protocol. This is true even two decades later. However, it was also obvious from the beginning that even though Ethernet was a very common way of transporting IP, it would not be the only one. Therefore, ARP was made a general protocol that was capable of resolving addresses from IP to Ethernet as well as numerous other data link layer technologies.</p><p>The basic operation of ARP involves encoding the IP address of the intended recipient in a broadcast message. It is sent on a local network to allow the intended recipient of an IP datagram to respond to the source with its data link layer address. This is done using a simple request and reply method. A special format is used for ARP messages, which are passed down to the local data link layer for transmission.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-73"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>ARP</em></span> was developed to facilitate dynamic address resolution between IP and Ethernet and can now be used on other layer 2 technologies as well. It works by allowing an IP device to send a broadcast on the local network, and it requests a response with a hardware address from another device on the same local network.</p></div><p>This basic operation is supplemented by methods to improve performance. Since it was known from the start that having to perform a resolution using broadcast for each datagram was ridiculously inefficient, ARP has always used a cache, where it keeps bindings between IP addresses and data link layer addresses on the local network. Over time, various techniques have been developed to improve the methods used for maintaining cache entries. Refinements and additional features, such as support for cross-resolution by pairs of devices as well as proxy ARP, have also been defined over the years and added to the basic ARP feature set.</p><div class="sect2" title="ARP Address Specification and General Operation"><div class="titlepage"><div><div><h2 class="title"><a id="arp_address_specification_and_general_op"/>ARP Address Specification and General Operation</h2></div></div></div><p>An ARP transaction begins when a source device on an IP network has an IP datagram to send. It must first decide whether the destination device is on the local network or a distant network. If it's the former, it will send directly to the destination; if it's the latter, it will send the datagram to one of the routers on the physical network for forwarding. Either way, it will determine the IP address of the device that needs to be the immediate destination of its IP datagram on the local network. After packaging the datagram it will pass it to its ARP software for address resolution.</p><p>The basic operation of ARP is a <span class="emphasis"><em>request and response</em></span> pair of transmissions on the local network. The source (the one that needs to send the IP datagram) transmits a broadcast containing information about the destination (the intended recipient of the datagram). The destination then responds via unicast back to the source, telling the source the hardware address of the destination.</p><div class="sect3" title="ARP Message Types and Address Designations"><div class="titlepage"><div><div><h3 class="title"><a id="arp_message_types_and_address_designatio"/>ARP Message Types and Address Designations</h3></div></div></div><p>The terms <span class="emphasis"><em>source</em></span> and <span class="emphasis"><em>destination</em></span> apply to the same devices throughout the transaction. However, there are two different messages sent in <a class="indexterm" id="idx-CHP-13-0600"/>ARP: one from the source to the destination and one from the destination to the source. For each <a class="indexterm" id="idx-CHP-13-0601"/>ARP message, the <span class="emphasis"><em>sender</em></span> is the one that is transmitting the message and the <span class="emphasis"><em>target</em></span> is the one receiving it. Thus, the identity of the sender and target changes for each message. Here's how the sender and target identities work for <a class="indexterm" id="idx-CHP-13-0602"/>requests and replies:</p><p><span class="strong"><strong>Request</strong></span> For the initial request, the sender is the source (the device with the IP datagram to send), and the target is the destination.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-13-0603"/>Reply</strong></span> For the reply to the <a class="indexterm" id="idx-CHP-13-0604"/>ARP request, the sender is the destination. It replies to the source, which becomes the target.</p><p>Each of the two parties in any message has two <a class="indexterm" id="idx-CHP-13-0605"/>addresses (layer 2 and layer 3) to be concerned with, so the following four different addresses are involved in each message:</p><p><span class="strong"><strong>Sender Hardware Address</strong></span> The layer 2 address of the sender of the <a class="indexterm" id="idx-CHP-13-0606"/>ARP message.</p><p><span class="strong"><strong>Sender Protocol Address</strong></span> The layer 3 (IP) address of the sender of the ARP message.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-13-0607"/>Target Hardware Address</strong></span> The layer 2 address of the target of the ARP message.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-13-0608"/>Target Protocol Address</strong></span> The layer 3 (IP) address of the target.</p><p>These addresses each have a position in the ARP message format, which we'll examine shortly.</p></div><div class="sect3" title="ARP General Operation"><div class="titlepage"><div><div><h3 class="title"><a id="arp_general_operation"/>ARP General Operation</h3></div></div></div><p>With that background in place, let's look at the steps that occur in an ARP transaction. (These steps are also shown graphically in the illustration in <a class="xref" href="ch13s02.html#address_resolution_protocol_arp_transact" title="Figure 13-5. Address Resolution Protocol (ARP) transaction process ARP works by having the source device broadcast a request to find the destination, which responds using a reply message. ARP caches are also consulted and updated as needed.">Figure 13-5</a>.) This diagram shows the sequence of steps that occur in a typical ARP transaction, as well as the message exchanges between a source and destination device, and the cache checking and update functions. (Incidentally, those little stacks are hard disks, not cans of soup!)</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Source Device Checks Cache</strong></span> The source device will first check its cache to determine if it already has a resolution of the destination device. If so, it can skip to step 9.</p></li><li class="listitem"><p><span class="strong"><strong>Source Device Generates ARP Request Message</strong></span> The source device generates an ARP Request message. It puts its own data link layer address as the Sender Hardware Address and its own IP address as the Sender Protocol Address. It fills in the IP address of the destination as the Target Protocol Address. (It must leave the Target Hardware Address blank, since that it is what it is trying to determine!)</p></li><li class="listitem"><p><span class="strong"><strong>Source Device Broadcasts ARP Request Message</strong></span> The source broadcasts the ARP Request message on the local network.</p><div class="figure"><a id="address_resolution_protocol_arp_transact"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e14579"/><img alt="Address Resolution Protocol (ARP) transaction process ARP works by having the source device broadcast a request to find the destination, which responds using a reply message. ARP caches are also consulted and updated as needed." src="httpatomoreillycomsourcenostarchimages287777.png.jpg"/></div></div><p class="title">Figure 13-5. Address Resolution Protocol (ARP) transaction process ARP works by having the source device broadcast a request to find the destination, which responds using a reply message. ARP caches are also consulted and updated as needed.</p></div></li><li class="listitem"><p><span class="strong"><strong>Local Devices <a class="indexterm" id="idx-CHP-13-0609"/>Process ARP Request Message</strong></span> The message is received by each device on the local network. It is processed, with each device looking for a match on the Target Protocol Address. Those that do not match will drop the message and take no further action.</p></li><li class="listitem"><p><span class="strong"><strong>Destination Device Generates ARP Reply Message</strong></span> The one device whose IP address matches the contents of the Target Protocol Address of the message will generate an ARP Reply message. It takes the Sender Hardware Address and Sender Protocol Address fields from the ARP Request message and uses these as the values for the Target Hardware Address and Target Protocol Address of the reply. It then fills in its own layer 2 address as the Sender Hardware Address and its IP address as the Sender Protocol Address. Other fields are filled in, as explained in the description of the ARP message format in the following section.</p></li><li class="listitem"><p><span class="strong"><strong>Destination Device Updates ARP Cache</strong></span> If the source needs to send an IP datagram to the destination now, it makes sense that the destination will probably need to send a response to the source at some point soon. (After all, most communication on a network is bidirectional.) Next, as an optimization, the destination device will add an entry to its own ARP cache that contains the hardware and IP addresses of the source that sent the ARP Request. This saves the destination from needing to do an unnecessary resolution cycle later on.</p></li><li class="listitem"><p><span class="strong"><strong>Destination Device Sends ARP Reply Message</strong></span> The destination device sends the ARP Reply message. This reply is, however, sent unicast to the source device, because there is no need to broadcast it.</p></li><li class="listitem"><p><span class="strong"><strong>Source Device Processes ARP Reply Message</strong></span> The source device processes the reply from the destination. It stores the Sender Hardware Address as the layer 2 address of the destination and uses that address for sending its IP datagram.</p></li><li class="listitem"><p><span class="strong"><strong>Source Device Updates ARP Cache</strong></span> The source device uses the Sender Protocol Address and Sender Hardware Address to update its ARP cache for use in the future when transmitting to this device.</p></li></ol></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-74"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> ARP is a relatively simple request-and-reply protocol. The source device broadcasts an ARP Request that's looking for a particular device based on the device's IP address. That device responds with its hardware address in an ARP Reply message.</p></div><p>Note that this description goes a bit beyond the basic steps in address resolution, because two enhancements are mentioned. One is caching, which you'll explore shortly. The other is cross-resolution (described earlier in this chapter in the overview of caching issues in dynamic resolution), which is step 6 of the process. This is why the source device includes its IP address in the request. It isn't really needed for any other reason, so you can see that this feature was built into ARP from the start.</p></div></div><div class="sect2" title="ARP Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="arp_message_format"/>ARP Message Format</h2></div></div></div><p>You've just seen how address resolution is accomplished in ARP, through an exchange of messages between the source device seeking to perform the resolution and the destination device that responds to it. As with other protocols, a special <span class="emphasis"><em>message format</em></span> is used for containing the information required for each step of the resolution process.<a class="indexterm" id="idx-CHP-13-0610"/></p><p>ARP messages use a relatively simple format. It includes a field describing the type of message (its <span class="emphasis"><em>operational code</em></span> or <span class="emphasis"><em>opcode</em></span>) and information on both layer 2 and layer 3 addresses. In order to support addresses that may be of varying length, the format specifies the type of protocol used at both layer 2 and layer 3, as well as the length of the addresses used at each of these layers. It then includes space for all four of the address combinations described earlier in this chapter: Sender Hardware Address, Sender Protocol Address, Target Hardware Address, and Target Protocol Address.</p><p>The format used for ARP messages is described in <a class="xref" href="ch13s02.html#arp_message_format-id001" title="Table 13-1. ARP Message Format">Table 13-1</a>. <a class="xref" href="ch13s02.html#arp_message_format-id002" title="Figure 13-6. ARP message format">Figure 13-6</a> shows how the ARP message format is designed to accommodate layer 2 and layer 3 addresses of various sizes. This diagram shows the most common implementation, which uses 32 bits for the layer 3 ("Protocol") addresses and 48 bits for the layer 2 hardware addresses. These numbers correspond to the address sizes of the IPv4 and IEEE 802 MAC addresses that are used by Ethernet.</p><div class="table"><a id="arp_message_format-id001"/><p class="title">Table 13-1. ARP Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ARP Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">HRD</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Hardware Type: This field specifies the type of hardware used for the local network transmitting the ARP message; thus, it also identifies the type of addressing used. Some of the most common values for this field are shown in <a class="xref" href="ch13s02.html#arp_hardware_type_hrd_field_values" title="Table 13-2. ARP Hardware Type (HRD) Field Values">Table 13-2</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">PRO</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Protocol Type: This field is the complement of the Hardware Type field, specifying the type of layer 3 addresses used in the message. For IPv4 addresses, this value is 2048 (0800 hex), which corresponds to the EtherType code for IP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">HLN</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Hardware Address Length: Specifies how long hardware addresses are in this message. For Ethernet or other networks using IEEE 802 MAC addresses, the value is 6.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">PLN</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Protocol Address Length: Again, the complement of the preceding field; specifies how long protocol (layer 3) addresses are in this message. For IPv4 addresses, this value is 4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">OP</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Opcode: This field specifies the nature of the ARP message being sent. The first two values (1 and 2) are used for regular ARP. Numerous other values are also defined to support other protocols that use the ARP frame <a class="indexterm" id="idx-CHP-13-0611"/>format, such as RARP, as shown in <a class="xref" href="ch13s02.html#arp_opcode_op_field_values" title="Table 13-3. ARP Opcode (OP) Field Values">Table 13-3</a>. Some protocols are more widely used than others.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">SHA</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable, equals value in HLN field</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sender Hardware Address: The hardware (layer 2) address of the device sending this message, which is the IP datagram source device on a request, and the IP datagram destination on a reply.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">SPA</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable, equals value in PLN field</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sender Protocol Address: The IP address of the device sending this message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="bolditalic">THA</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable, equals value in HLN field</p></td><td style="border-bottom: 0.5pt solid ; "><p>Target Hardware Address: The hardware (layer 2) address of the device this message is being sent to. This is the IP datagram destination device on a request, and the IP datagram source on a reply.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="bolditalic">TPA</span></p></td><td style="border-right: 0.5pt solid ; "><p>Variable, equals value in PLN field</p></td><td style=""><p>Target Protocol Address: The IP address of the device this message is being sent to.</p></td></tr></tbody></table></div></div><div class="table"><a id="arp_hardware_type_hrd_field_values"/><p class="title">Table 13-2. ARP Hardware Type (HRD) Field Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ARP Hardware Type (HRD) Field Values"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hardware Type (HRD) Value</p></th><th style="border-bottom: 0.5pt solid ; "><p>Hardware Type</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Ethernet (10 Mb)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>IEEE 802 Networks</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>ARCNeT</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-bottom: 0.5pt solid ; "><p>Frame Relay</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Asynchronous Transfer Mode (ATM)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-bottom: 0.5pt solid ; "><p>HDLC</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18</p></td><td style="border-bottom: 0.5pt solid ; "><p>Fibre Channel</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>19</p></td><td style="border-bottom: 0.5pt solid ; "><p>Asynchronous Transfer Mode (ATM)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>20</p></td><td style=""><p>Serial Line</p></td></tr></tbody></table></div></div><div class="table"><a id="arp_opcode_op_field_values"/><p class="title">Table 13-3. ARP Opcode (OP) Field Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="ARP Opcode (OP) Field Values"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opcode</p></th><th style="border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-13-0612"/>ARP Message Type</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>ARP Request</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>ARP Reply</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>RARP Request</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>RARP Reply</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>DRARP Request</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>DRARP Reply</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>DRARP Error</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>InARP Request</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>9</p></td><td style=""><p>InARP Reply</p></td></tr></tbody></table></div></div><div class="figure"><a id="arp_message_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e14950"/><img alt="ARP message format" src="httpatomoreillycomsourcenostarchimages287779.png"/></div></div><p class="title">Figure 13-6. ARP message format</p></div><p>Once the ARP message has been composed, it is passed down to the data link layer for transmission. The entire contents of the ARP message become the payload for the message actually sent on the network, such as an Ethernet frame on an Ethernet LAN. Note that the total size of the ARP message is variable, since the address fields are of variable length. Normally, though, these messages are quite small. For example, they are only 28 bytes for a network carrying IPv4 datagrams in IEEE 802 MAC addresses.<a class="indexterm" id="idx-CHP-13-0613"/></p></div><div class="sect2" title="ARP Caching"><div class="titlepage"><div><div><h2 class="title"><a id="arp_caching"/>ARP Caching</h2></div></div></div><p>ARP is a dynamic resolution protocol, which means that every resolution requires the interchange of messages on the network. Each time a device sends an ARP message, it ties up the local network, consuming network bandwidth that cannot be used for other traffic. ARP messages aren't large, but having to send them for every hop of every IP datagram would represent an unacceptable performance hit on the network. It also wastes time compared to the simpler direct mapping method of resolution. On top of this, the ARP Request message is broadcasted, which means every device on the local network must spend CPU time examining the contents of each one.<a class="indexterm" id="idx-CHP-13-0614"/></p><p>The general solution to the efficiency issues with dynamic resolution is to employ <span class="emphasis"><em>caching</em></span>. In addition to reducing network traffic, caching also ensures that the resolution of commonly used addresses is fast, thereby making overall performance comparable to direct mapping. For this reason, caching functionality has been built into ARP from the start.</p><div class="sect3" title="Static and Dynamic ARP Cache Entries"><div class="titlepage"><div><div><h3 class="title"><a id="static_and_dynamic_arp_cache_entries"/>Static and Dynamic ARP Cache Entries</h3></div></div></div><p>The ARP cache takes the form of a table containing matched sets of hardware and IP addresses. Each device on the network manages its own ARP cache table. There are two different ways that cache entries can be put into the ARP cache:<a class="indexterm" id="idx-CHP-13-0615"/></p><p><span class="strong"><strong>Static ARP Cache Entries</strong></span> These are address resolutions that are manually added to the cache table for a device and are kept in the cache on a permanent basis. Static entries are typically managed using a tool such as the arp software utility (see <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a>).</p><p><span class="strong"><strong>Dynamic ARP Cache Entries</strong></span> These are hardware and IP address pairs that are added to the cache by the software itself as a result of past ARP resolutions that were successfully completed. They are kept in the cache for only a period of time and are then removed.</p><p>A device's ARP cache can contain both static and dynamic entries, each of which has advantages and disadvantages. However, dynamic entries are used most often because they are automatic and don't require administrator intervention.</p><p>Static ARP entries are best used for devices that a given device needs to communicate with on a regular basis. For example, a workstation might have a static ARP entry for its local router and file server. Since the entry is static, it is always found in step 1 of the ARP transaction process, and there is no need to ever send resolution messages for the destination in that entry. The disadvantage is that these entries must be manually added, and they must also be changed if the hardware or IP addresses of any of the hardware in the entries change. Also, each static entry takes space in the ARP cache, so you don't want to overuse static entries. It wouldn't be a good idea to have static entries for every device on the network, for example.</p></div><div class="sect3" title="Cache Entry Expiration"><div class="titlepage"><div><div><h3 class="title"><a id="cache_entry_expiration"/>Cache Entry Expiration</h3></div></div></div><p>Dynamic entries are added automatically to the cache on an as-needed basis, so they represent mappings for hosts and routers that a given device is actively using. They do not need to be manually added or maintained. However, it is also important to realize that dynamic entries cannot be added to the cache and left there forever—dynamic entries left in place for a long time can become stale.</p><p>Consider Device A's ARP cache, which contains a dynamic mapping for Device B, which is another host on the network. If dynamic entries stayed in the cache forever, the following situations might arise.</p><p><span class="strong"><strong>Device Hardware Changes</strong></span> Device B might experience a hardware failure that requires its network interface card to be replaced. The mapping in Device A's cache would become invalid, since the hardware address in the entry is no longer on the network.</p><p><span class="strong"><strong>Device IP Address Changes</strong></span> Similarly, the mapping in Device A's cache also would become invalid if Device B's IP address changed.</p><p><span class="strong"><strong>Device Removal</strong></span> Suppose Device B is removed from the local network. Device A would never need to send to it again at the data link layer, but the mapping would remain in Device A's cache, wasting space and possibly taking up search time.</p><p>To avoid these problems, dynamic cache entries must be set to automatically expire after a period of time. This is handled automatically by the ARP implementation, with typical timeout values being 10 or 20 minutes. After a particular entry times out, it is removed from the cache. The next time that address mapping is needed, a fresh resolution is performed to update the cache. This is very slightly less efficient than static entries, but sending two 28-byte messages every 10 or 20 minutes isn't a big deal.</p><p>As mentioned in the overview of ARP operation, dynamic cache entries are added not only when a device initiates a resolution, but when it is the destination device as well. This is another enhancement that reduces unnecessary address resolution traffic.</p></div><div class="sect3" title="Other Caching Features"><div class="titlepage"><div><div><h3 class="title"><a id="other_caching_features"/>Other Caching Features</h3></div></div></div><p>Other enhancements are also typically put into place, depending on the implementation. Standard ARP requires that if Device A initiates resolution with a broadcast, each device on the network should update its own cache entries for Device A, even if they are not the device that Device A is trying to reach. However, these "third-party" devices are <span class="emphasis"><em>not</em></span> required to create new cache entries for Device A in this situation.</p><p>The issue here is a trade-off. Creating a new cache entry would save any of those devices from needing to resolve Device A's address in the near future. However, it also means every device on the network will quickly have an ARP cache table filled up with the addresses of most of the other devices on the network. This may not be desirable in larger networks. Even in smaller ones, this model may not make sense, given that modern computing is client/server in nature and peer devices on a LAN may not often communicate directly. Some devices may choose to create such cache entries, but they may set them to expire after a very short time to avoid filling the cache.</p><p>Each ARP implementation is also responsible for any other housekeeping required to maintain the cache. For example, if a device is on a local network with many hosts and its cache table is too small, it might be necessary for older, less frequently used entries to be removed to make room for newer ones. Ideally, the cache should be large enough to hold all the other devices with which a device communicates on a regular basis on the network, along with some room for ones it occasionally talks to.</p></div></div><div class="sect2" title="Proxy ARP"><div class="titlepage"><div><div><h2 class="title"><a id="proxy_arp"/>Proxy ARP</h2></div></div></div><p>ARP was designed to be <a class="indexterm" id="idx-CHP-13-0616"/>used by devices that are directly connected on a local network. Each device on the network should be capable of sending both unicast and broadcast transmissions directly to one another. Normally, if Device A and Device B are separated by a router, they would not be considered local to each other. Device A would not send directly to Device B or vice versa; they would send to the router instead at layer 2 and would be considered two hops apart at layer 3.</p><p>In some networking situations, however, there might be two physical network segments that are in the same IP network or subnetwork and are connected by a router. In other words, Device A and Device B might be on different networks at the data link layer level, but on the same IP network or subnet. When this happens, Device A and Device B will each think the other is on the local network when they look to send IP datagrams.</p><p>In this situation, suppose that Device A wants to send a datagram to Device B. It doesn't have Device B's hardware address in the cache, so it begins an address resolution. When it broadcasts the ARP Request message to get Device B's hardware address, however, it will quickly run into a problem: Device B is not on Device A's local network. The router between them will not pass Device A's broadcast onto Device B's part of the network, because routers don't pass hardware-layer broadcasts. Device B will never get the request, and thus Device A will not get a reply containing Device B's hardware address.</p><p>The solution to this situation is called <span class="emphasis"><em>ARP proxying</em></span> or <span class="emphasis"><em>Proxy ARP</em></span>. In this technique, the router that sits between the local networks is configured to respond to Device A's broadcast on behalf of Device B. It does not send back to Device A the hardware address of Device B. Since they are not on the same network, Device A cannot send directly to Device B anyway. Instead, the router sends Device A its own hardware address. Device A then sends to the router, which forwards the message to Device B on the other network. Of course, the router also does the same thing on Device A's behalf for Device B, and for every other device on both networks, when a broadcast is sent that targets a device that isn't on the same actual physical network as the resolution initiator. This is illustrated in <a class="xref" href="ch13s02.html#arp_proxy_operation_these_two_examples_s" title="Figure 13-7. ARP Proxy operation These two examples show how a router acting as an ARP proxy returns its own hardware address in response to requests by one device for an address on the other network. In this small internetwork shown, a single router connects two LANs that are on the same IP network or subnet. The router will not pass ARP broadcasts, but has been configured to act as an ARP proxy. In this example, Device A and Device D are each trying to send an IP datagram to the other, and so each broadcasts an ARP Request. The router responds to the request sent by Device A as if it were Device D, giving to Device A its own hardware address (without propagating Device A's broadcast). It will forward the message sent by Device A to Device D on Device D's network. Similarly, it responds to Device D as if it were Device A, giving its own address, then forwarding what Device D sends to it over to the network where Device A is located.">Figure 13-7</a>.<a class="indexterm" id="idx-CHP-13-0617"/><a class="indexterm" id="idx-CHP-13-0618"/></p><p><a class="indexterm" id="idx-CHP-13-0619"/>Proxy ARP provides flexibility for networks where hosts are not all actually on the same physical network but are configured as if they were at the network layer. It can be used to provide support in other special situations where a device cannot respond directly to ARP message broadcasts. It may be used when a firewall is configured for security purposes. A type of proxying is also used as part of Mobile IP to solve the problem of address resolution when a mobile device travels away from its home network.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-75"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since ARP relies on broadcasts for address resolution, and broadcasts are not propagated beyond a physical network, ARP cannot function between devices on different physical networks. When such operation is required, a device, such as a router, can be configured as an ARP proxy to respond to ARP requests on the behalf of a device on a different network.</p></div><div class="figure"><a id="arp_proxy_operation_these_two_examples_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e15084"/><img alt="ARP Proxy operation These two examples show how a router acting as an ARP proxy returns its own hardware address in response to requests by one device for an address on the other network. In this small internetwork shown, a single router connects two LANs that are on the same IP network or subnet. The router will not pass ARP broadcasts, but has been configured to act as an ARP proxy. In this example, Device A and Device D are each trying to send an IP datagram to the other, and so each broadcasts an ARP Request. The router responds to the request sent by Device A as if it were Device D, giving to Device A its own hardware address (without propagating Device A's broadcast). It will forward the message sent by Device A to Device D on Device D's network. Similarly, it responds to Device D as if it were Device A, giving its own address, then forwarding what Device D sends to it over to the network where Device A is located." src="httpatomoreillycomsourcenostarchimages287781.png.jpg"/></div></div><p class="title">Figure 13-7. ARP Proxy operation These two examples show how a router acting as an ARP proxy returns its own hardware address in response to requests by one device for an address on the other network. In this small internetwork shown, a single router connects two LANs that are on the same IP network or subnet. The router will not pass ARP broadcasts, but has been configured to act as an ARP proxy. In this example, Device A and Device D are each trying to send an IP datagram to the other, and so each broadcasts an ARP Request. The router responds to the request sent by Device A as if it were Device D, giving to Device A its own hardware address (without propagating Device A's broadcast). It will forward the message sent by Device A to Device D on Device D's network. Similarly, it responds to Device D as if it were Device A, giving its own address, then forwarding what Device D sends to it over to the network where Device A is located.</p></div><p>The main advantage of <a class="indexterm" id="idx-CHP-13-0620"/>proxying is that it is transparent to the hosts on the different physical network segments. The technique has some drawbacks, however. First, it introduces added complexity. Second, if more than one router connects two physical networks using the same network ID, problems may arise. Third, it introduces potential security risks; since it essentially means that a router impersonates devices by acting as a proxy for them, the potential for a device spoofing another is real. For these reasons, it may be better to redesign the network so that routing is done between physical networks separated by a router, if possible.</p></div></div>
<div class="sect1" title="TCP/IP Address Resolution for IP Multicast Addresses"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_address_resolution_for_ip_multicas"/>TCP/IP Address Resolution for IP Multicast Addresses</h1></div></div></div><p>Like most discussions of <a class="indexterm" id="idx-CHP-13-0621"/>address resolution, most of this chapter so far has focused on unicast communication, where a datagram is sent from one source device to one destination device. Whether direct mapping or dynamic <a class="indexterm" id="idx-CHP-13-0622"/>resolution is used for resolving a network layer address, it is a relatively simple matter to resolve addresses when there is only one intended recipient of the datagram. As you've seen, TCP/IP uses ARP for its dynamic resolution scheme, which is designed for unicast resolution only.</p><p>However, IP also supports <span class="emphasis"><em>multicasting</em></span> of datagrams, as I explain in the sections on IP multicasting and IP multicast addressing in Chapters <a class="xref" href="ch23.html" title="Chapter 23. IP ROUTING AND MULTICASTING">Chapter 23</a> and <a class="xref" href="ch17.html" title="Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING">Chapter 17</a>, respectively. In this situation, the datagram must be sent to multiple recipients, which complicates matters considerably. You need to establish a relationship of some sort between the IP multicast group address and the addresses of the devices at the data link layer. You could do this by converting the IP multicast datagram to individual unicast transmissions at the data link layer with each using ARP for resolution, but this would be horribly inefficient.</p><p>When possible, IP makes use of the multicast addressing and delivery capabilities of the underlying network to deliver multicast datagrams on a physical network. Perhaps surprisingly, even though ARP employs dynamic resolution, multicast address resolution is done using a version of the direct mapping technique. By defining a <span class="emphasis"><em>mapping</em></span> between IP multicast groups and data link layer multicast groups, you enable physical devices to know when to pay attention to multicasted datagrams.</p><p>The most commonly used multicast-capable data link addressing scheme is the IEEE 802 addressing system best known for its use in Ethernet networks. These data link layer addresses have 48 bits, arranged into two blocks of 24. The upper 24 bits are arranged into a block called the <span class="emphasis"><em>organizationally unique identifier (OUI)</em></span>, with different values assigned to individual organizations; the lower 24 bits are then used for specific devices.<a class="indexterm" id="idx-CHP-13-0623"/></p><p>The Internet Assigned Number Authority (IANA) itself has an <a class="indexterm" id="idx-CHP-13-0624"/>OUI that it uses for mapping multicast addresses to <a class="indexterm" id="idx-CHP-13-0625"/>IEEE 802 addresses. This OUI is 01:00:5E. To form a mapping for Ethernet, 24 bits are used for this OUI, and the 25th (of the 48) is always zero. This leaves 23 bits of the original 48 to encode the multicast address. To do the mapping, the lower-order 23 bits of the multicast address are used as the last 23 bits of the Ethernet address starting with 01:00:5E for sending the multicast message.</p><p><a class="xref" href="ch13s03.html#mapping_of_multicast_ip_addresses_to_iee" title="Figure 13-8. Mapping of multicast IP Addresses to IEEE 802 multicast MAC addresses Multicast IP addresses are mapped to IEEE 802 multicast MAC addresses by copying the IANA multicast OUI value (01-00-5E) to the top 24 bits, setting the 25th bit to zero, and copying the bottom 23 bits of the multicast address to the remaining 23 bits. To create a 48-bit multicast IEEE 802 (Ethernet) address, the top 24 bits are filled in with the IANA's multicast OUI, 01-00-5E. The 25th bit is zero, and the bottom 23 bits of the multicast group are put into the bottom 23 bits of the MAC address. This leaves 5 bits (shown hatched) that are not mapped to the MAC address, meaning that 32 different IP addresses may have the same mapped multicast MAC address.">Figure 13-8</a> illustrates how the multicast address mapping process works.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-76"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IP multicast addresses are resolved to IEEE 802 (Ethernet) MAC addresses using a direct mapping technique that uses 23 of the 28 bits in the IP multicast group address.</p></div><p>Of course, there are 28 unique bits in IP multicast addresses, so this is a "bit" of a problem! What it means is that there is no unique mapping between IP multicast <a class="indexterm" id="idx-CHP-13-0626"/>addresses and Ethernet multicast addresses. Since 5 of the 28 bits of the multicast group cannot be encoded in the Ethernet address, 32 (2<sup>5</sup>) different IP multicast addresses map onto each possible Ethernet multicast address. In theory, this would be a problem, but in practice, it isn't. The chances of any two IP multicast addresses on a single network mapping to the same Ethernet multicast address at the same time are pretty small.</p><div class="figure"><a id="mapping_of_multicast_ip_addresses_to_iee"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e15176"/><img alt="Mapping of multicast IP Addresses to IEEE 802 multicast MAC addresses Multicast IP addresses are mapped to IEEE 802 multicast MAC addresses by copying the IANA multicast OUI value (01-00-5E) to the top 24 bits, setting the 25th bit to zero, and copying the bottom 23 bits of the multicast address to the remaining 23 bits. To create a 48-bit multicast IEEE 802 (Ethernet) address, the top 24 bits are filled in with the IANA's multicast OUI, 01-00-5E. The 25th bit is zero, and the bottom 23 bits of the multicast group are put into the bottom 23 bits of the MAC address. This leaves 5 bits (shown hatched) that are not mapped to the MAC address, meaning that 32 different IP addresses may have the same mapped multicast MAC address." src="httpatomoreillycomsourcenostarchimages287783.png"/></div></div><p class="title">Figure 13-8. Mapping of multicast IP Addresses to IEEE 802 multicast MAC addresses Multicast IP addresses are mapped to IEEE 802 multicast MAC addresses by copying the IANA multicast OUI value (01-00-5E) to the top 24 bits, setting the 25th bit to zero, and copying the bottom 23 bits of the multicast address to the remaining 23 bits. To create a 48-bit multicast IEEE 802 (Ethernet) address, the top 24 bits are filled in with the IANA's multicast OUI, 01-00-5E. The 25th bit is zero, and the bottom 23 bits of the multicast group are put into the bottom 23 bits of the MAC address. This leaves 5 bits (shown hatched) that are not mapped to the MAC address, meaning that 32 different IP addresses may have the same mapped multicast MAC address.</p></div><p>Still, it is possible that two IP multicast groups might be in use on the same physical network and might map to the same data link layer multicast address. For this reason, devices must not assume that all multicast messages they receive are for their groups; they must pass up the messages to the IP layer to check the full IP multicast address to make sure that they really were supposed to get the multicast datagram they received. If they accidentally get one that was intended for a multicast group they are not a member of, they discard it. This happens infrequently, so the relative lack of efficiency is not a large concern.</p></div>
<div class="sect1" title="TCP/IP Address Resolution for IP Version 6"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_address_resolution_for_ip_version_"/>TCP/IP Address Resolution for IP Version 6</h1></div></div></div><p>The TCP/IP ARP is a fairly generic protocol for dynamically resolving network layer addresses into data link layer addresses. Even though it was designed for IPv4, the message format allows for variable-length addresses at both the hardware and network layers. This flexibility means it would have been theoretically possible to use it for the new version of IP, <a class="indexterm" id="idx-CHP-13-0627"/>IPv6. Some minor changes might have been required, but the technique could have been about the same.<a class="indexterm" id="idx-CHP-13-0628"/></p><p>The designers of IPv6 chose not to do this, however. Changing IP is a big job that has been under way for many years, providing a rare opportunity to change various aspects of TCP/IP. The Internet Engineering Task Force (IETF) decided to take advantage of the changes in IPv6 to overhaul not only IP itself, but also many of the protocols that support or assist it. In IPv6, the address resolution job of ARP has been combined with several functions performed by the Internet Control Message Protocol (ICMP) in the original TCP/IP suite, supplemented with additional capabilities and defined as the new Neighbor Discovery (ND) Protocol.</p><p>The term <span class="emphasis"><em>neighbor</em></span> in IPv6 simply refers to devices on a local network, and as the name implies, ND is responsible for tasks related to communicating information between neighbors (among other things). I describe ND briefly in <a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a>, including a discussion of the various tasks it performs. Here, I focus specifically on how ND performs address resolution.</p><p>The basic concepts of address resolution in IPv6 ND aren't all that different from those in IPv4 ARP. Resolution is still dynamic and is based on the use of a cache table that maintains pairings of IPv6 addresses and hardware addresses. Each device on a physical network keeps track of this information for its neighbors. When a source device needs to send an IPv6 datagram to a local network neighbor but doesn't have its hardware address, it initiates the resolution process. For clarity in the text let's say that, as usual, Device A is trying to send to Device B.</p><p>Instead of sending an ARP Request message, Device A creates an ND Neighbor Solicitation message. Now, here's where the first big change can be seen from ARP. If the underlying data link protocol supports multicasting, as Ethernet does, the Neighbor Solicitation message is not broadcast. Instead, it is sent to the <span class="emphasis"><em>solicited-node address</em></span> of the device whose IPv6 address you are trying to resolve. So Device A won't broadcast the message, but it will multicast it to Device B's solicited-node multicast address.</p><p>The solicited-node multicast address is a special mapping that each device on a multicast-capable network creates from its unicast address; it is described in <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a>'s discussion of IPv6 multicast addresses. The solicited-node address isn't unique for every IPv6 address, but the odds of any two neighbors on a given network having the same one are small. Each device that receives a multicasted Neighbor Solicitation must still check to make sure it is the device whose address the source is trying to resolve.</p><p>Why bother with this, if devices still have to check each message? The multicast will affect at most a small number of devices. With a broadcast, each and every device on the local network would receive the message, while the use of the solicited-node address means at most that a couple of devices will need to process it. Other devices don't even have to bother checking the Neighbor Solicitation message at all.</p><p>Device B will receive the Neighbor Solicitation and respond back to Device A with a Neighbor Advertisement. This is analogous to the ARP Reply and tells Device A the physical address of Device B. Device A then adds Device B's information to its neighbor cache. For efficiency, cross-resolution is supported, as in IPv4 address resolution. This is done by having Device A include its own layer 2 address in the Neighbor Solicitation, assuming it knows it. Device B will record this along with Device A's IP address in Device B's neighbor cache.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-77"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Address resolution in IPv6 uses the new <span class="emphasis"><em>Neighbor Discovery (ND) Protocol</em></span> instead of the Address Resolution Protocol (ARP). A device trying to send an IPv6 datagram sends a Neighbor Solicitation message to get the address of another device, which responds with a Neighbor Advertisement. When possible, to improve efficiency, the request is sent using a special type of multicast address rather than broadcast.</p></div><p>This is actually a fairly simplified explanation of how resolution works in IPv6, because ND is quite complicated. Neighbor solicitations and advertisements are also used for other functions, such as testing the reachability of nodes and determining if duplicate addresses are in use. There are many special cases and issues that ND addresses to ensure that no problems develop during address resolution. ND also supports proxied address resolution.</p><div class="note" title="Note"><h3 class="title"><a id="note-60"/>Note</h3><p><span class="emphasis"><em>Even though I put this discussion where it would be near the other discussions of address resolution, ND really isn't a layer connection or lower-level protocol like ARP. It is analogous to ICMP (<a class="xref" href="ch31.html" title="Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION">Chapter 31</a>) in its role and function, and, in fact, makes use of ICMP(v6) messages. One advantage of this architectural change is that there is less dependence on the characteristics of the physical network, so resolution is accomplished in a way that's more similar to other network support activities. Thus, it is possible to make use of facilities that can be applied to all IP datagram transmissions, such as IP security features. <a class="xref" href="ch36.html" title="Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL">Chapter 36</a> contains much more information on this subject</em></span>.</p></div></div>
<div class="chapter" title="Chapter&#xA0;14.&#xA0;REVERSE ADDRESS RESOLUTION AND THE TCP/IP REVERSE ADDRESS RESOLUTION PROTOCOL (RARP)"><div class="titlepage"><div><div><h1 class="title"><a id="reverse_address_resolution_and_the_tcpip"/>Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP REVERSE ADDRESS RESOLUTION PROTOCOL (RARP)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e15246"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>In <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>, you explored the operation of the TCP/IP Address Resolution Protocol (ARP). ARP is used when a device needs to determine the layer 2 (hardware) address of some other device but has only its layer 3 (network, IP) address. It broadcasts a hardware layer request, and the target device responds with the hardware address that matches the known IP address.</p><p>In theory, it is also possible to use ARP in the opposite way. If you know the hardware address of a device but not its IP address, you could broadcast a request containing the hardware address and get back a response that contains the IP address. In this chapter, you will briefly explore this concept of <span class="emphasis"><em>reverse address resolution</em></span>.<a class="indexterm" id="idx-CHP-14-0629"/></p><p>The obvious first question is why would you ever need to do this? Since you are dealing with communication on an Internet Protocol (IP) internetwork, you are always going to know the IP address of the destination of the datagram you need to send—it's right there in the datagram itself. You also know your own IP address as well. Or do you?</p><p>In a traditional TCP/IP network, every normal host on a network knows its IP address because it is stored somewhere on the machine. When you turn on your PC, the TCP/IP software reads the IP address from a file, which allows your PC to learn and start using its IP address. However, there are some devices, such as diskless workstations, that don't have any means of storing an IP address where it can be easily retrieved. When these units are powered up, they know their physical address only (because it's wired into the hardware) but not their IP address.</p><p>The problem you need to solve here is what is commonly called <span class="emphasis"><em>bootstrapping</em></span> in the computer industry. This refers to the concept of starting something from a zero state; it is analogous to "pulling yourself up by your own bootstraps." This is seemingly impossible, just as it seems paradoxical to use TCP/IP to configure the IP address that is needed for TCP/IP communications. However, it is indeed possible to do this, by making use of broadcasts, which allow local communication even when the target's address is not known.<a class="indexterm" id="idx-CHP-14-0630"/></p><div class="sect1" title="The Reverse Address Resolution Protocol (RARP)"><div class="titlepage"><div><div><h1 class="title"><a id="the_reverse_address_resolution_protocol_"/>The Reverse Address Resolution Protocol (RARP)</h1></div></div></div><p>The first method devised to address the bootstrapping problem in TCP/IP was the backward use of ARP, which is described in the previous chapter. This technique was formalized in RFC 903, "A <a class="indexterm" id="idx-CHP-14-0631"/>Reverse Address Resolution Protocol (RARP)," published in 1984. ARP allows Device A to say, "I am Device A, and I have Device B's IP address. Device B please tell me your hardware address." <a class="indexterm" id="idx-CHP-14-0632"/>RARP is used by Device A to say, "I am Device A, and I am sending this broadcast using my hardware address; can someone please tell me <span class="emphasis"><em>my</em></span> IP address?"<a class="indexterm" id="idx-CHP-14-0633"/></p><p>The two-step operation of <a class="indexterm" id="idx-CHP-14-0634"/>RARP is illustrated in <a class="xref" href="ch14.html#operation_of_the_reverse_address_resolut" title="Figure 14-1. Operation of the Reverse Address Resolution Protocol (RARP) RARP works like ARP but in reverse; a device broadcasts its hardware address and an RARP server responds with its IP address. Here, instead of Device A providing the IP address of another device and asking for its hardware address, it is providing its own hardware address and asking for an IP address it can use. The answer, in this case, is provided by Device D, which is serving as an RARP server for this network.">Figure 14-1</a>. As the name suggests, RARP works like ARP but in reverse, which is why this diagram is similar to <a class="xref" href="ch13.html#dynamic_address_resolution_the_device_th" title="Figure 13-4. Dynamic address resolution The device that wants to send data broadcasts a request asking for a response with a hardware address from the other device. Device A needs to send data to Device B, but knows only its IP address (IPB) and not its hardware address. Device A broadcasts a request asking to be sent the hardware address of the device using the IP address IPB. Device B responds back to Device A directly with the hardware address.">Figure 13-4</a>.</p><p>The next question then is who knows Device A's IP address if Device A doesn't? The answer is that a special <span class="emphasis"><em>RARP server</em></span> must be configured to listen for RARP requests and then issue replies to them. Each physical network where RARP is in use must have RARP software running on at least one machine.</p><p>RARP is not only very similar to ARP, it basically is ARP. RFC 903 doesn't define a whole new protocol from scratch; it just describes a new method for using ARP to perform the opposite of its normal function. RARP uses ARP messages in the same format as ARP (described in <a class="xref" href="ch13.html" title="Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)">Chapter 13</a>), but uses different opcodes to accomplish its reverse function. As in ARP, a request and reply are used in an exchange. The meaning of the address fields is the same, too: The sender is the device transmitting a message, while the target is the one receiving it.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-78"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Reverse Address Resolution Protocol (RARP)</em></span> is the earliest and simplest protocol that's designed to allow a device to obtain an IP address for use on a TCP/IP network. It is based directly on ARP and works in basically the same way, but in reverse: A device sends a request containing its hardware address, and a device set up as an RARP server responds back with the device's assigned IP address.</p></div><div class="figure"><a id="operation_of_the_reverse_address_resolut"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15329"/><img alt="Operation of the Reverse Address Resolution Protocol (RARP) RARP works like ARP but in reverse; a device broadcasts its hardware address and an RARP server responds with its IP address. Here, instead of Device A providing the IP address of another device and asking for its hardware address, it is providing its own hardware address and asking for an IP address it can use. The answer, in this case, is provided by Device D, which is serving as an RARP server for this network." src="httpatomoreillycomsourcenostarchimages287785.png.jpg"/></div></div><p class="title">Figure 14-1. Operation of the Reverse Address Resolution Protocol (RARP) RARP works like ARP but in reverse; a device broadcasts its hardware address and an RARP server responds with its IP address. Here, instead of Device A providing the IP address of another device and asking for its hardware address, it is providing its own hardware address and asking for an IP address it can use. The answer, in this case, is provided by Device D, which is serving as an RARP server for this network.</p></div></div></div>
<div class="sect1" title="RARP General Operation"><div class="titlepage"><div><div><h1 class="title"><a id="rarp_general_operation"/>RARP General Operation</h1></div></div></div><p><a class="xref" href="ch14s02.html#reverse_address_resolution_protocol_rarp" title="Figure 14-2. Reverse Address Resolution Protocol (RARP) operation RARP consists of the exchange of one broadcast request message and one unicast reply message.">Figure 14-2</a> shows the steps followed in a <a class="indexterm" id="idx-CHP-14-0635"/>RARP transaction. As you can see, RARP uses a simple request and reply exchange to allow a device to obtain an IP address.</p><div class="figure"><a id="reverse_address_resolution_protocol_rarp"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15347"/><img alt="Reverse Address Resolution Protocol (RARP) operation RARP consists of the exchange of one broadcast request message and one unicast reply message." src="httpatomoreillycomsourcenostarchimages287787.png"/></div></div><p class="title">Figure 14-2. Reverse Address Resolution Protocol (RARP) operation RARP consists of the exchange of one broadcast request message and one unicast reply message.</p></div><p>Here's what happens at each step:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Source Device Generates RARP Request Message</strong></span> The source device generates an RARP Request message. Thus, it uses the value 3 for the <span class="emphasis"><em>opcode</em></span> in the message. It puts its own data link layer address as both the Sender Hardware Address and also the Target Hardware Address. It leaves both the Sender Protocol Address and the Target Protocol Address blank, since it doesn't know either.</p></li><li class="listitem"><p><span class="strong"><strong>Source Device Broadcasts RARP Request Message</strong></span> The source broadcasts the ARP Request message on the local network.</p></li><li class="listitem"><p><span class="strong"><strong>Local Devices Process RARP Request Message</strong></span> The message is received by each device on the local network and processed. Devices that are not configured to act as RARP servers ignore the message.</p></li><li class="listitem"><p><span class="strong"><strong>RARP Server Generates RARP Reply Message</strong></span> Any device on the network that is set up to act as an RARP server responds to the broadcast from the source device. It generates an RARP Reply using an opcode value of 4. It sets the Sender Hardware Address and Sender Protocol Address to its own hardware and IP address, since it is the sender of the reply. It then sets the Target Hardware Address to the hardware address of the original source device. It looks up in a table the hardware address of the source, determines that device's IP address assignment, and puts it into the Target Protocol Address field.</p></li><li class="listitem"><p><span class="strong"><strong>RARP Server Sends RARP Reply Message</strong></span> The RARP server sends the RARP Reply message unicast to the device looking to be configured.</p></li><li class="listitem"><p><span class="strong"><strong>Source Device Processes RARP Reply Message</strong></span> The source device processes the reply from the RARP server. It then configures itself using the IP address in the Target Protocol Address supplied by the RARP server.</p></li></ol></div><div class="note" title="Note"><h3 class="title"><a id="note-61"/>Note</h3><p><span class="emphasis"><em>More than one RARP server may respond to a request, if two or more are configured on any local network. The source device will typically use the first reply and discard the others</em></span>.</p></div></div>
<div class="sect1" title="Limitations of RARP"><div class="titlepage"><div><div><h1 class="title"><a id="limitations_of_rarp"/>Limitations of RARP</h1></div></div></div><p>RARP is the earliest and most rudimentary of the class of technologies I call <span class="emphasis"><em>host configuration protocols</em></span>, which I describe in general terms in <a class="xref" href="ch59.html" title="Chapter 59. HOST CONFIGURATION CONCEPTS, ISSUES, AND MOTIVATION">Chapter 59</a>. As the first of these protocols, RARP was a useful addition to TCP/IP in the early 1980s, but has several shortcomings, the most important of which are as follows:</p><p><span class="strong"><strong>Low-Level Hardware Orientation</strong></span> RARP works using hardware broadcasts. This means that if you have a large internetwork with many physical networks, you need an RARP server on <span class="emphasis"><em>every</em></span> network segment. Worse, if you need reliability to make sure RARP keeps running even if one RARP server goes down, you need <span class="emphasis"><em>two</em></span> on each physical network. This makes centralized management of IP addresses difficult.</p><p><span class="strong"><strong>Manual Assignment</strong></span> RARP allows hosts to configure themselves automatically, but the RARP server must still be set up with a manual table of bindings between hardware and IP addresses. These must be maintained for each server, which is, again, a lot of work for an administrator.</p><p><span class="strong"><strong>Limited Information</strong></span> RARP provides a host with only its IP address. It cannot provide other needed information such as, for example, a subnet mask or default gateway.</p><p>The importance of host configuration has increased dramatically since the early 1980s. Many organizations assign IP addresses dynamically even for hosts that have disk storage, because of the many advantages this provides in administration and because of the efficient use of address space. For this reason, RARP has been replaced by two more capable technologies that operate at higher layers in the TCP/IP protocol stack: BOOTP and DHCP. They are discussed in the application layer section on host configuration protocols, in Chapters <a class="xref" href="ch60.html" title="Chapter 60. TCP/IP BOOTSTRAP PROTOCOL (BOOTP)">Chapter 60</a> through <a class="xref" href="ch64.html" title="Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT">Chapter 64</a>.</p></div></body></html>