- en: Chapter 18. Debugging and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The development of any real-world application progresses in steps. Most of us
    would prefer to take more steps forward than backward. To minimize the backward
    steps—caused by coding errors or unforeseen side effects—you can take advantage
    of testing and debugging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a brief overview of some of the most useful debugging
    tools available to Ruby programmers. Bear in mind, however, that if you are using
    a dedicated Ruby IDE, you may have more powerful visual debugging tools at your
    disposal. I will be discussing only the “standard” tools available to Ruby in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'IRB: Interactive Ruby'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you may just want to “try something” with Ruby. It is possible to
    do this using the standard Ruby interpreter: Enter `ruby` at the command prompt,
    and then enter your code one line at a time. However, this is far from being an
    ideal interactive environment. For one thing, the code you enter will be executed
    only when you enter an end-of-file character such as `^Z` or `^D` (that is, ctrl-Z
    on Windows or ctrl-D on some other operating systems). So, to do something as
    simple as displaying the value of 1 plus 1, you would enter the following sequence
    commands (remembering to enter whichever end-of-file character is required on
    your operating system).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Only once the end-of-file character (here `^Z`) has been entered does Ruby
    execute the code and display the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For a better way to interact with Ruby, use the Interactive Ruby shell (IRB).
    To start IRB, go to a command prompt and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see a prompt similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you are ready to start entering some Ruby code. You can enter an expression
    over more than one line; as soon as the expression is complete, IRB will evaluate
    it and display the result. Try the following (pressing enter after the `+` on
    the first line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, press enter after the closing parenthesis. Now IRB will evaluate the
    expression and show the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now evaluate `x`. Enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'IRB shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, up to this point, your entire IRB session should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful, though. Try entering this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This time the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is, in fact, normal Ruby behavior. It is normal because a line break acts
    as a terminator, while the `+` operator, when it begins the new line, acts as
    a unary operator (that is, rather than adding together *two* values—one to its
    left and one to its right—it merely asserts that the *single* expression that
    follows the `+` is positive). You will find a fuller explanation of this in [Digging
    Deeper](ch18s03.html#digging_deeper-id17 "Digging Deeper") in [Digging Deeper](ch18s03.html#digging_deeper-id17
    "Digging Deeper").
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, just be aware that when entering expressions one line at a time, the
    position of the line break is important! When using IRB, you can tell whether
    the interpreter considers that you have ended a statement. If you have done so,
    a prompt is displayed ending with `>` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If a statement is complete and returns a result, a `=>` prompt is displayed
    followed by the result. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the statement is incomplete, the prompt ends with an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To end an IRB session, enter the word `quit` or `exit` at the prompt. You can,
    if you want, load a Ruby program into IRB by passing to it the program name when
    you run IRB like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also invoke IRB with a variety of options to do things such as load
    a module (`irb -r` *`[load-module]`*) or display the IRB version number (`irb
    -v`). Many of the available IRB options are rather esoteric and are not likely
    to be required by most users. The full range of options may be listed by entering
    this at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Although IRB may be useful for trying out some code, it does not provide all
    the features you need for debugging programs. Ruby does, however, provide a command-line
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default Ruby debugger allows you to set breakpoints and watchpoints and
    evaluate variables while your programs execute. To run a program in the debugger,
    use the `-r debug` option (where `-r` means “require” and `debug` is the name
    of the debugging library) when you start the Ruby interpreter. For example, this
    is how you would debug a program called *debug_test.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the debugger has started, you can enter various commands to step through
    your code, set breakpoints to cause the execution to pause at specific lines,
    set watches to monitor the values of variables, and so on. The following are the
    available debugging commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`b[reak] [file|class:]<line|method>`** and **`b[reak] [file|class:]<line|method>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets breakpoint to some position
  prefs: []
  type: TYPE_NORMAL
- en: '**`b[reak] [class.]<line|method>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets breakpoint to some position
  prefs: []
  type: TYPE_NORMAL
- en: '**`wat[ch] <expression>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets watchpoint to some expression
  prefs: []
  type: TYPE_NORMAL
- en: '**`cat[ch] <an Exception>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets catchpoint to an exception
  prefs: []
  type: TYPE_NORMAL
- en: '**`b[reak]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Lists breakpoints
  prefs: []
  type: TYPE_NORMAL
- en: '**`cat[ch]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows catchpoint
  prefs: []
  type: TYPE_NORMAL
- en: '**`del[ete][ nnn]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes some or all breakpoints
  prefs: []
  type: TYPE_NORMAL
- en: '**`disp[lay] <expression>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Adds expression to display expression list
  prefs: []
  type: TYPE_NORMAL
- en: '**`undisp[lay][ nnn]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes one particular or all display expressions
  prefs: []
  type: TYPE_NORMAL
- en: '**`c[ont]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Runs until end or breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: '**`s[tep][ nnn]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Steps (into code) one line or to line `nnn`
  prefs: []
  type: TYPE_NORMAL
- en: '**`n[ext][ nnn]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Goes over one line or until line `nnn`
  prefs: []
  type: TYPE_NORMAL
- en: '**`w[here]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays frames
  prefs: []
  type: TYPE_NORMAL
- en: '**`f[rame]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Is the alias for `where`
  prefs: []
  type: TYPE_NORMAL
- en: '**`l[ist][ (-|nn-mm)]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Lists program, lists backward `nn-mm`, lists given lines
  prefs: []
  type: TYPE_NORMAL
- en: '**`up[ nn]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Moves to higher frame
  prefs: []
  type: TYPE_NORMAL
- en: '**`down[ nn]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Moves to lower frame
  prefs: []
  type: TYPE_NORMAL
- en: '**`fin[ish]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns to outer frame
  prefs: []
  type: TYPE_NORMAL
- en: '**`tr[ace] (on|off)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets trace mode of current thread
  prefs: []
  type: TYPE_NORMAL
- en: '**`tr[ace] (on|off) all`**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets trace mode of all threads
  prefs: []
  type: TYPE_NORMAL
- en: '**`q[uit]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Exits from debugger
  prefs: []
  type: TYPE_NORMAL
- en: '**`v[ar] g[lobal]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows global variables
  prefs: []
  type: TYPE_NORMAL
- en: '**`v[ar] l[ocal]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows local variables
  prefs: []
  type: TYPE_NORMAL
- en: '**`v[ar] i[nstance] <object>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows instance variables of object
  prefs: []
  type: TYPE_NORMAL
- en: '**`v[ar] c[onst] <object>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows constants of object
  prefs: []
  type: TYPE_NORMAL
- en: '**`m[ethod] i[nstance] <obj>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows methods of object
  prefs: []
  type: TYPE_NORMAL
- en: '**`m[ethod] <class|module>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows instance methods of class or module
  prefs: []
  type: TYPE_NORMAL
- en: '**`th[read] l[ist]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Lists all threads
  prefs: []
  type: TYPE_NORMAL
- en: '**`th[read] c[ur[rent]]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows current thread
  prefs: []
  type: TYPE_NORMAL
- en: '**`th[read] [sw[itch]] <nnn>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Switches thread context to `nnn`
  prefs: []
  type: TYPE_NORMAL
- en: '**`th[read] stop <nnn>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Stops thread `nnn`
  prefs: []
  type: TYPE_NORMAL
- en: '**`th[read] resume <nnn>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Resumes thread `nnn`
  prefs: []
  type: TYPE_NORMAL
- en: '**`p expression`**'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluates expression and prints its value
  prefs: []
  type: TYPE_NORMAL
- en: '**`h[elp]`**'
  prefs: []
  type: TYPE_NORMAL
- en: Prints this help
  prefs: []
  type: TYPE_NORMAL
- en: '**`<everything else>`**'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluates
  prefs: []
  type: TYPE_NORMAL
- en: Ubygems? What’s Ubygems?
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, if you enter the command `ruby -r debug`, you may see an inscrutable
    message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If this happens, when you then start debugging, you will find yourself trying
    to debug the file *ubygems.rb* rather than your program! This problem may occur
    when some software (for example, some customized Ruby installers) set the environment
    variable `RUBYOPT=-rubygems`. In most cases, this has the desirable effect of
    allowing your Ruby programs to use the Ruby Gems “packaging system,” which helps
    install Ruby libraries. When you try to use the `-r` option, however, this is
    interpreted as `-r ubygems`, which is why an attempt is made to load the file
    *ubygems.rb*. Ruby conveniently (or possibly confusingly?) provides a file named
    *ubygems.rb* that does nothing apart from requiring *rubygems.rb*. There are two
    ways of dealing with this. You can remove `RUBYOPT` permanently, or you can disable
    it temporarily. If you choose to remove it permanently, however, you may encounter
    side effects when using Ruby Gems later. The way in which environment variables
    are added or removed varies according to your operating system. On Windows, you
    would need to click the Start menu (then Settings if using XP) and click Control
    Panel (then System and Maintenance if using Vista); then click System (on Vista,
    you should now click Advanced System Settings). In the System Properties dialog,
    select the Advanced tab. Next, click Environment Variables; finally, in the System
    Variables panel, find `RUBYOPT` and delete it. A safer alternative is to disable
    the variable at the command prompt prior to loading the debugger. To do this,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will disable the `RUBYOPT` environment variable for this command session
    only. You can verify this by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, open another command window and enter `set RUBYOPT`, and you will see
    that the environment variable here retains its default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how a few of these commands might be used in a real debugging session.
    Open a system prompt, and navigate to the directory containing the file *debug_test.rb*,
    which is supplied in the sample code for this chapter. Start the debugger by entering
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*debug_test.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try a few commands. In these examples, I’ve written `[Enter]` to
    show that you should press the enter key after each command. First let’s see a
    code listing (here note that `l` is a lowercase *L* character):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this, which is a partial listing of the file *debug_test.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you see a listing from a file called *ubygems.rb* at this point instead of
    your program, refer to [Ubygems? What’s Ubygems?](ch18s02.html#ubygems_question_whatas_ubygems_question
    "Ubygems? What’s Ubygems?") in [Ubygems? What’s Ubygems?](ch18s02.html#ubygems_question_whatas_ubygems_question
    "Ubygems? What’s Ubygems?") for ways of correcting this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `l` you entered is the “list” command, which instructs the debugger to
    list the code in bite-sized chunks. The actual number of lines will vary with
    the code being debugged. Let’s list some more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now list a specific number of lines. Enter the letter `l` followed by the digit
    `1`, a hyphen, and `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s put a breakpoint on line 78:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ruby debugger should reply with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also set one or more *watchpoints*. A watchpoint can be used to trigger
    a break on a simple variable (for example, entering `wat @t2` would break when
    the `@t2` object is created); or it may be set to match a specific value (for
    example, `i == 10`). Here I want to set a watchpoint that breaks when the `name`
    attribute of `@t4` is “wombat”. Enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger should confirm this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the watchpoint number is 2\. You’ll need that number if you subsequently
    decide to delete the watchpoint. Okay, so now let’s continue (`c`) execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will run until it hits the breakpoint. You will see a message similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it shows the line number it’s stopped on and the code on that line. Let’s
    continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This time it breaks here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the line immediately following the successful evaluation of the watchpoint
    condition. Check that by listing the line number indicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger shows a set of lines with the current line of execution (86) preceded
    by the `=>` marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, line 86 contains the code that matches the watchpoint condition.
    Notice that execution did not stop after line 82, where `@t4` was originally created,
    because the watchpoint condition was not met there (its `name` attribute was “potto”
    and not “wombat”). If you want to inspect the value of a variable when paused
    at a breakpoint or watchpoint, just enter its name. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can similarly enter other expressions to be evaluated. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This shows `800`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or enter some arbitrary expression such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This shows `12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now delete the watchpoint (recall that its number is 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And continue until the program exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use many more commands to debug a program in this way, and you may
    want to experiment with those shown in the table given earlier. You can also view
    a list of commands during a debugging session by entering `help` or just `h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To quit a debugging session, enter `quit` or `q`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Although the standard Ruby debugger has its uses, it is far from as simple or
    convenient to use as one of the graphical debuggers provided by integrated development
    environments. Moreover, it is quite slow. In my view, it is fine for debugging
    simple scripts but cannot be recommended for debugging large and complex programs.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Unit testing* is a postdebugging testing technique that lets you try bits
    of your program in order to verify that they work as expected. Some programmers
    use unit testing habitually in addition to or even instead of interactive debugging;
    other programmers use it rarely or never. Entire books have been written on the
    techniques and methodologies of unit testing, and I will only cover its fundamentals
    here.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of unit testing is that you can write a number of “assertions”
    stating that certain results should be obtained as the consequence of certain
    actions. For example, you might assert that the return value of a specific method
    should be 100, that it should be a Boolean, or that it should be an instance of
    a specific class. If, when the test is run, the assertion proves to be correct,
    it passes the test; if it is incorrect, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example, which will fail if the `getVal` method of the object, `t`,
    returns any value other than 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can’t just pepper your code with assertions of this sort. There are
    precise rules to the game. First you have to require the *test/unit* file. Then
    you need to derive a test class from the TestCase class, which is found in the
    `Unit` module, which is itself in the `Test` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this class you can write one or more methods, each of which constitutes
    a test containing one or more assertions. The method names must begin with `test`
    (so methods called `test1` or `testMyProgram` are okay, but a method called `myTestMethod`
    isn’t). The following method contains a test that makes the single assertion that
    the return value of `TestClass.new(100).getVal` is 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a complete (albeit simple) test suite in which I have defined a
    TestCase class called MyTest that tests the class, TestClass. Here (with a little
    imagination!), TestClass may be taken to represent a whole program that I want
    to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '*test1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This test suite contains two tests: `test1` (which contains three assertions)
    and `test2` (which contains one). To run the tests, you just need to run the program;
    you don’t have to create an instance of MyClass. You will see a report of the
    results that states there were two tests, three assertions, and one failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, I made *four* assertions. However, assertions following a failure
    are not evaluated in a given test. In `test1`, this assertion fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Having failed, the next assertion is skipped. If I now correct this failed
    assertion (asserting 100 instead of 101), this next assertion will also be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'But this too fails. This time, the report states that four assertions have
    been evaluated with one failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in a real-life situation, you should aim to write correct assertions,
    and when any failures are reported, it should be the failing code that is rewritten—not
    the assertion!
  prefs: []
  type: TYPE_NORMAL
- en: 'For a slightly more complex example of testing, see the *test2.rb* program
    (which requires a file called *buggy.rb*). This is a small adventure game that
    includes the following test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '*test2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here the first method, `test1`, performs an `assert` test on an array of objects
    passed into a block, and it fails when a `value` attribute is *not* less than
    2,000\. The second method, `test2`, tests the class types of two objects using
    the `assert_kind_of` method. The second test in this method fails when `@game.map`
    is found to be of the type `TestMod::Adventure::Map` rather than `Array` as is
    asserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code also contains two more methods named `setup` and `teardown`. When
    defined, methods with these names will be run before and after each test method.
    In other words, in *test2.rb*, the following methods will run in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1\. `setup` | 2\. `test1` | 3\. `teardown` |'
  prefs: []
  type: TYPE_TB
- en: '| 4\. `setup` | 5\. `test2` | 6\. `teardown` |'
  prefs: []
  type: TYPE_TB
- en: 'This gives you the opportunity of reinitializing any variables to specific
    values prior to running each test or, as in this case, re-creating objects to
    ensure that they are in a known state as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: This section contains a summary of assertions for unit testing, explains why
    IRB may show different results for what appears to be the same code, and considers
    the merits of more advanced debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions Available When Unit Testing
  prefs: []
  type: TYPE_NORMAL
- en: The list of assertions shown next is provided for ease of reference. A full
    explanation of each assertion is beyond the scope of this book. You can find complete
    documentation of the testing libraries at [http://ruby-doc.org/stdlib/](http://ruby-doc.org/stdlib/).
    On this site, select the class listing for `Test::Unit::Assertions` in order to
    view the full documentation of the available assertions plus numerous code samples
    demonstrating their usage.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert(boolean, message=nil)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Asserts that boolean is not false or nil.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_block(message="assert_block failed.") {|| ...}`**'
  prefs: []
  type: TYPE_NORMAL
- en: The assertion upon which all other assertions are based. Passes if the block
    yields true.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_equal(expected, actual, message=nil`**`)`'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `expected` == `actual`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_in_delta(expected_float, actual_float, delta, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `expected_float` and `actual_float` are equal within `delta` tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_instance_of(klass, object, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if object `.instance_of?` klass.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_kind_of(klass, object, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if object `.kind_of?` klass.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_match(pattern, string, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if string `=˜` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_nil(object, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if object is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_no_match(regexp, string, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if regexp `!˜` string.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_not_equal(expected, actual, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if expected `!=` actual.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_not_nil(object, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `!` object .nil?.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_not_same(expected, actual, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `!` actual `.equal?` expected.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_nothing_raised(*args) {|| ...}`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if block does not raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_nothing_thrown(message="", &proc)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if block does not throw anything.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_operator(object1, operator, object2, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Compares the `object1` with `object2` using operator. Passes if `object1.send(operator,
    object2)` is true.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_raise(*args) {|| ...}`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the block raises one of the given exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_raises(*args, &block)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Alias of `assert_raise`. (Deprecated in Ruby 1.9 and to be removed in 2.0.)
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_respond_to(object, method, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if object `.respond_to?` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_same(expected, actual, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if actual `.equal?` expected (in other words, they are the same instance).
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_send(send_array, message="")`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the method send returns a true value.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_throws(expected_symbol, message="", &proc)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the block throws `expected_symbol`
  prefs: []
  type: TYPE_NORMAL
- en: '**`build_message(head, template=nil, *arguments)`**'
  prefs: []
  type: TYPE_NORMAL
- en: Builds a failure message; head is added before the template and `*arguments`
    replaces the question marks positionally in the template.
  prefs: []
  type: TYPE_NORMAL
- en: '**`flunk(message="Flunked")`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`flunk` always fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Line Breaks Are Significant
  prefs: []
  type: TYPE_NORMAL
- en: 'I said earlier that you need to take care when entering line breaks into the
    interactive Ruby console (IRB) since the position of line breaks may alter the
    meaning of your Ruby code. So, for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*linebreaks.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'assigns `18` to `x`, but the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: assigns `8` to `x`.
  prefs: []
  type: TYPE_NORMAL
- en: This is not merely a quirk of IRB. This is normal behavior of Ruby code even
    when entered into a text editor and executed by the Ruby interpreter. The second
    example just shown evaluates `10` on the first line, finds this to be a perfectly
    acceptable value, and promptly forgets about it; then it evaluates `+ (2*4)`,
    which it also finds to be an acceptable value (`8`), but it has no connection
    with the previous value (`10`), so `8` is returned and assigned to `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to tell Ruby to evaluate expressions split over multiple lines,
    ignoring the line breaks, you can use the line continuation character (`\`). This
    is what I’ve done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This time, `x` is assigned the value `18`.
  prefs: []
  type: TYPE_NORMAL
- en: Graphical Debuggers
  prefs: []
  type: TYPE_NORMAL
- en: For serious debugging, I strongly recommend a graphical debugger. For example,
    the debugger in the Ruby In Steel IDE allows you to set breakpoints and watchpoints
    by clicking the margin of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860166.png)'
  prefs: []
  type: TYPE_IMG
- en: It lets you monitor the values of selected “watch variables” or all local variables
    in separate docked windows. It maintains a “callstack” of all method calls leading
    to the current point of execution and allows you to navigate “backward” through
    the callstack to view the changing values of variables. It also has “drill-down”
    expansion of variables to allow you to expand arrays and hashes and look inside
    complex objects. These capabilities go well beyond the features of the standard
    Ruby debugger. For information on Ruby IDEs, see [Appendix D](apd.html "Appendix D. Ruby
    and Rails Development Software").
  prefs: []
  type: TYPE_NORMAL
