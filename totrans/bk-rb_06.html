<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Conditional Statements"><div class="titlepage"><div><div><h1 class="title"><a id="conditional_statements"/>Chapter 6. Conditional Statements</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id8"/><div class="mediaobject"><a id="I_mediaobject6_d1e6711"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>Computer programs, like life itself, are full of difficult decisions waiting to be made. Things like “If I stay in bed, I will get more sleep, else I will have to go to work; if I go to work, I will earn some money, else I will lose my job,” and so on. You’ve already performed a number of <code class="literal">if</code> tests in previous programs. To take a simple example, this is from the Tax calculator in <a class="xref" href="ch01.html" title="Chapter 1. Strings, Numbers, Classes, and Objects">Chapter 1</a>:<a id="IDX-CHP-6-0001" class="indexterm"/></p><a id="I_programlisting6_d1e6726"/><pre class="programlisting">if (subtotal &lt; 0.0) then
   subtotal = 0.0
end</pre><p>In this program, the user was prompted to enter a value, <code class="literal">subtotal</code>, that was then used in order to calculate the tax due on it. If the user, in a fit of madness, enters a value less than 0, the <code class="literal">if</code> test spots this since the test <code class="literal">(subtotal &lt; 0.0)</code> evaluates to true, which causes the body of the code between the <code class="literal">if</code> test and the <code class="literal">end</code> keyword to be executed; here, this sets the value of <code class="literal">subtotal</code> to 0.</p><div class="sect1" title="if..then..else"><div class="titlepage"><div><div><h1 class="title"><a id="if..then..else"/>if..then..else</h1></div></div></div><p>A simple test like this has only one of two possible results. Either a bit of code is run or it isn’t, depending on whether the test evaluates to true or not. Often, you will need to have more than two possible outcomes. Let’s suppose, for example, that your program needs to follow one course of action if the day is a weekday and a different course of action if it is a weekend. You can test these conditions by adding an <code class="literal">else</code> section after the <code class="literal">if</code> section, like this:<a id="IDX-CHP-6-0002" class="indexterm"/><a id="IDX-CHP-6-0003" class="indexterm"/><a id="IDX-CHP-6-0004" class="indexterm"/><a id="IDX-CHP-6-0005" class="indexterm"/><a id="IDX-CHP-6-0006" class="indexterm"/></p><p><span class="emphasis"><em>if_else.rb</em></span></p><a id="I_programlisting6_d1e6784"/><pre class="programlisting">if aDay == 'Saturday' or aDay == 'Sunday'
   daytype = 'weekend'
else
   daytype = 'weekday'
end</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Like many other programming languages, Ruby uses one equal sign (<code class="literal">=</code>) to assign a value and two (<code class="literal">==</code>) to test a value.</p></div><p>The <code class="literal">if</code> condition here is straightforward. It tests two possible conditions: if the value of the variable <code class="literal">aDay</code> is equal to the string “Saturday” and if the value of <code class="literal">aDay</code> is equal to the string “Sunday.” If either of those conditions is true, then the next line of code executes <code class="literal">daytype = 'weekend'</code>; in all other cases, the code after <code class="literal">else</code> executes <code class="literal">daytype = 'weekday'</code>.</p><p>When an <code class="literal">if</code> test and the code to be executed are placed on separate lines, the <code class="literal">then</code> keyword is optional. When the test and the code are placed on a single line, the <code class="literal">then</code> keyword is obligatory:</p><p><span class="emphasis"><em>if_then.rb</em></span></p><a id="I_programlisting6_d1e6830"/><pre class="programlisting">if x == 1 then puts( 'ok' ) end    # with 'then'
if x == 1 puts( 'ok' ) end         # syntax error!</pre><p>In Ruby 1.8, a colon character (<code class="literal">:</code>) was permitted as an alternative to <code class="literal">then</code>. This syntax is not supported in Ruby 1.9:</p><a id="I_programlisting6_d1e6840"/><pre class="programlisting">if x == 1 : puts( 'ok' ) end    # This works with Ruby 1.8 only</pre><p>An <code class="literal">if</code> test isn’t restricted to evaluating just two conditions. Let’s suppose, for example, that your code needs to work out whether a certain day is a working day or a holiday. All weekdays are working days; all Saturdays are holidays, but Sundays are only holidays when you are not working overtime. This is my first attempt to write a test to evaluate all these conditions:</p><p><span class="emphasis"><em>and_or_wrong.rb</em></span></p><a id="I_programlisting6_d1e6851"/><pre class="programlisting">working_overtime = true
if aDay == 'Saturday' or aDay == 'Sunday' and not working_overtime
   daytype = 'holiday'
   puts( "Hurrah!" )
else
   daytype = 'working day'
end</pre><p>Unfortunately, this doesn’t have quite the effect intended. Remember that Saturday is always a holiday. But this code insists that Saturday is a working day. This is because Ruby takes the test to mean “If the day is Saturday and I am not working overtime or if the day is Sunday and I am not working overtime,” whereas what I really meant was “If the day is Saturday or if the day is Sunday and I am not working overtime.” The easiest way to resolve this ambiguity is to put parentheses around any code to be evaluated as a single unit, like this:<a id="IDX-CHP-6-0007" class="indexterm"/><a id="IDX-CHP-6-0008" class="indexterm"/><a id="IDX-CHP-6-0009" class="indexterm"/><a id="IDX-CHP-6-0010" class="indexterm"/><a id="IDX-CHP-6-0011" class="indexterm"/><a id="IDX-CHP-6-0012" class="indexterm"/><a id="IDX-CHP-6-0013" class="indexterm"/><a id="IDX-CHP-6-0014" class="indexterm"/><a id="IDX-CHP-6-0015" class="indexterm"/><a id="IDX-CHP-6-0016" class="indexterm"/><a id="IDX-CHP-6-0017" class="indexterm"/><a id="IDX-CHP-6-0018" class="indexterm"/><a id="IDX-CHP-6-0019" class="indexterm"/></p><p><span class="emphasis"><em>and_or.rb</em></span></p><a id="I_programlisting6_d1e6906"/><pre class="programlisting">if aDay == 'Saturday' or (aDay == 'Sunday' and not working_overtime)</pre></div></div>
<div class="sect1" title="and, or, and not"><div class="titlepage"><div><div><h1 class="title"><a id="and_comma_or_comma_and_not"/>and, or, and not</h1></div></div></div><p>Incidentally, Ruby has two different syntaxes for testing Boolean (true/false) conditions. In the previous example, I’ve used the English-language style operators: <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code>. If you prefer, you could use alternative operators similar to those used in many other programming languages, namely, <code class="literal">&amp;&amp;</code> (and), <code class="literal">||</code> (or), and <code class="literal">!</code> (not).</p><p>Be careful, though: The two sets of operators aren’t completely interchangeable. For one thing, they have different precedence, which means that when multiple operators are used in a single test, the parts of the test may be evaluated in different orders depending on which operators you use. For example, look at this test:</p><p><span class="emphasis"><em>days.rb</em></span></p><a id="I_programlisting6_d1e6937"/><pre class="programlisting">if aDay == 'Saturday' or aDay == 'Sunday' and not working_overtime
   daytype = 'holiday'
end</pre><p>Assuming that the Boolean variable <code class="literal">working_overtime</code> is true, would this test succeed if the variable <code class="literal">aDay</code> were initialized with the string “Saturday”? In other words, would <code class="literal">daytype</code> be assigned the value “holiday” if <code class="literal">aDay</code> is “Saturday”? The answer is no, it wouldn’t. The test will succeed only if <code class="literal">aDay</code> is either “Saturday” or “Sunday” and <code class="literal">working_overtime</code> is not true. So, when <code class="literal">or</code> is used in the previous code, Saturday would be deemed to be a working day.</p><p>Now consider this test:</p><a id="I_programlisting6_d1e6965"/><pre class="programlisting">if aDay == 'Saturday' || aDay == 'Sunday' &amp;&amp;  !working_overtime
   daytype = 'holiday'
end</pre><p>On the face of it, this is the same test as the last one; the only difference is that this time I’ve used the alternative syntax for the operators. However, the change is more than cosmetic since if <code class="literal">aDay</code> is “Saturday,” this test evaluates to true and <code class="literal">daytype</code> is initialized with the value “holiday.” This is because the <code class="literal">||</code> operator has a higher precedence than the <code class="literal">or</code> operator. So, this test succeeds either if <code class="literal">aDay</code> is “Saturday” <span class="emphasis"><em>or</em></span> if <code class="literal">aDay</code> is “Sunday” and <code class="literal">working_overtime</code> is not true. So, when <code class="literal">||</code> is used in the previous code, Saturday would be deemed to be a holiday.</p><p>Refer to <a class="xref" href="ch06s07.html#digging_deeper-id5" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch06s07.html#digging_deeper-id5" title="Digging Deeper">Digging Deeper</a> for more on this. As a general principle, you would do well to decide which set of operators you prefer—stick to them and use parentheses to avoid ambiguity.<a id="IDX-CHP-6-0020" class="indexterm"/><a id="IDX-CHP-6-0021" class="indexterm"/><a id="IDX-CHP-6-0022" class="indexterm"/><a id="IDX-CHP-6-0023" class="indexterm"/><a id="IDX-CHP-6-0024" class="indexterm"/><a id="IDX-CHP-6-0025" class="indexterm"/></p></div>
<div class="sect1" title="Negation"><div class="titlepage"><div><div><h1 class="title"><a id="negation"/>Negation</h1></div></div></div><p>In the previous example, I used the negation operator (<code class="literal">!</code>) in the expression <code class="literal">!working_overtime</code>, which can be read as “not working_overtime.” The negation operator can be used at the start of an expression; as an alternative, you can use the “not equals” (<code class="literal">!=</code> ) operator between the left and right sides of an expression:<a id="IDX-CHP-6-0026" class="indexterm"/></p><p><span class="emphasis"><em>negation.rb</em></span></p><a id="I_programlisting6_d1e7047"/><pre class="programlisting">!(1==1)         #=&gt; false
1!=1            #=&gt; false</pre><p>Alternatively, you can use <code class="literal">not</code> instead of <code class="literal">!</code>:</p><a id="I_programlisting6_d1e7057"/><pre class="programlisting">not( 1==1 )        #=&gt; false</pre></div>
<div class="sect1" title="if..elsif"><div class="titlepage"><div><div><h1 class="title"><a id="if..elsif"/>if..elsif</h1></div></div></div><p>There will no doubt be occasions when you will need to take multiple different actions based on several alternative conditions. One way of doing this is by evaluating one <code class="literal">if</code> condition followed by a series of other test conditions placed after the keyword <code class="literal">elsif</code>. The whole lot must then be terminated using the <code class="literal">end</code> keyword.</p><p>For example, here I am repeatedly taking input from a user inside a <code class="literal">while</code> loop. An <code class="literal">if</code> condition tests whether the user enters “q” (I’ve used <code class="literal">chomp()</code> to remove the carriage return from the input). If “q” is not entered, the first <code class="literal">elsif</code> condition tests whether the integer value of the input (<code class="literal">input.to_i</code>) is greater than 800; if this test fails, the next <code class="literal">elsif</code> condition tests whether it is less than or equal to 800:</p><p><span class="emphasis"><em>if_elsif.rb</em></span></p><a id="I_programlisting6_d1e7097"/><pre class="programlisting">while input != 'q' do
   puts("Enter a number between 1 and 1000 (or 'q' to quit)")
   print("?- ")
   input = gets().chomp()
   if input == 'q'
      puts( "Bye" )
   elsif input.to_i &gt; 800
      puts( "That's a high rate of pay!" )
   elsif input.to_i &lt;= 800
      puts( "We can afford that" )
   end
end</pre><p>The problem with this program is that, even though it asks the user to enter a value between 1 and 1,000, it accepts values less than 1 (incidentally, if you really want a salary in negative figures, I’ll be glad to offer you a job!) and greater than 1,000 (in which case, don’t look to me for employment!).<a id="IDX-CHP-6-0027" class="indexterm"/></p><p>You can fix this by rewriting the two <code class="literal">elsif</code> conditions and adding an <code class="literal">else</code> section that executes if all the preceding tests fail:</p><p><span class="emphasis"><em>if_elsif2.rb</em></span></p><a id="I_programlisting6_d1e7115"/><pre class="programlisting">if input == 'q'
   puts( "Bye" )
elsif input.to_i &gt; 800 &amp;&amp; input.to_i &lt;= 1000
   puts( "That's a high rate of pay!" )
elsif input.to_i &lt;= 800 &amp;&amp; input.to_i &gt; 0
   puts( "We can afford that" )
else
   puts( "I said: Enter a number between 1 and 1000!" )
end</pre><div class="sidebar"><a id="shorthand_notation_for_if..then..else"/><p class="title">Shorthand Notation for if..then..else</p><p>Ruby also has a short-form notation for <code class="literal">if..then..else</code> in which a question mark (<code class="literal">?</code>) replaces the <code class="literal">if..then</code> part and a colon (<code class="literal">:</code>) acts as <code class="literal">else</code>. Formally, this may be known either as a <span class="emphasis"><em>ternary operator</em></span> or as a <span class="emphasis"><em>conditional operator</em></span>.</p><a id="I_programlisting6_d1e7144"/><pre class="programlisting"><em class="replaceable"><code>&lt; Test Condition &gt;</code></em> ? <em class="replaceable"><code>&lt;if true do this&gt;</code></em> : <em class="replaceable"><code>&lt;else do this&gt;</code></em></pre><p>For example:</p><a id="I_programlisting6_d1e7155"/><pre class="programlisting">x == 10 ? puts("it's 10") : puts( "it's some other number" )</pre><p>When the test condition is complex (if it uses <code class="literal">and</code>s and <code class="literal">or</code>s), you should enclose it in parentheses. If the tests and code span several lines, the <code class="literal">?</code> must be placed on the same line as the preceding condition and the <code class="literal">:</code> must be placed on the same line as the code immediately following the <code class="literal">?</code>. In other words, if you put a newline before the <code class="literal">?</code> or the <code class="literal">:</code>, you will generate a syntax error. This is an example of a valid multiline code block:</p><a id="I_programlisting6_d1e7181"/><pre class="programlisting">(aDay == 'Saturday' or aDay == 'Sunday') ?
   daytype = 'weekend' :
   daytype = 'weekday'</pre></div><p><span class="emphasis"><em>if_else_alt.rb</em></span></p><p>Here’s another example of a longer sequence of <code class="literal">if..elsif</code> sections followed by a catchall <code class="literal">else</code> section. This time the trigger value, <code class="literal">i</code>, is an integer:</p><p><span class="emphasis"><em>days2.rb</em></span></p><a id="I_programlisting6_d1e7201"/><pre class="programlisting">def showDay( i )
   if i == 1 then puts("It's Monday" )
   elsif i == 2 then puts("It's Tuesday" )
   elsif i == 3 then puts("It's Wednesday" )
   elsif i == 4 then puts("It's Thursday" )
   elsif i == 5 then puts("It's Friday" )
   elsif (6..7) === i then puts( "Yippee! It's the weekend! " )
   else puts( "That's not a real day!" )
   end
end</pre><p>Notice that I’ve used the range <code class="literal">(6..7)</code> to match the two integer values for Saturday and Sunday. The <code class="literal">===</code> method (that is, three <code class="literal">=</code> characters) tests whether a value (here <code class="literal">i</code>) is a member of the range. In the previous example, the following:<a id="IDX-CHP-6-0028" class="indexterm"/><a id="IDX-CHP-6-0029" class="indexterm"/><a id="IDX-CHP-6-0030" class="indexterm"/><a id="IDX-CHP-6-0031" class="indexterm"/><a id="IDX-CHP-6-0032" class="indexterm"/></p><a id="I_programlisting6_d1e7233"/><pre class="programlisting">(6..7) === i</pre><p>could be rewritten as this:</p><a id="I_programlisting6_d1e7237"/><pre class="programlisting">(6..7).include?(i)</pre><p>The <code class="literal">===</code> method is defined by the Object class and overridden in descendant classes. Its behavior varies according to the class. As you will see shortly, one of its fundamental uses is to provide meaningful tests for <code class="literal">case</code> statements.</p></div>
<div class="sect1" title="unless"><div class="titlepage"><div><div><h1 class="title"><a id="unless"/>unless</h1></div></div></div><p>Ruby also can also perform <code class="literal">unless</code> tests, which are the exact opposite of <code class="literal">if</code> tests:</p><p><span class="emphasis"><em>unless.rb</em></span></p><a id="I_programlisting6_d1e7261"/><pre class="programlisting">unless aDay == 'Saturday' or aDay == 'Sunday'
   daytype = 'weekday'
else
   daytype = 'weekend'
end</pre><p>Think of <code class="literal">unless</code> as being an alternative way of expressing “if not.” The following is equivalent to the previous code; both consider Saturday and Sunday to be the weekend and other days to be weekdays:</p><a id="I_programlisting6_d1e7268"/><pre class="programlisting">if !(aDay == 'Saturday' or aDay == 'Sunday')
   daytype = 'weekday'
else
   daytype = 'weekend'
end</pre></div>
<div class="sect1" title="if and unless Modifiers"><div class="titlepage"><div><div><h1 class="title"><a id="if_and_unless_modifiers"/>if and unless Modifiers</h1></div></div></div><p>You may recall the alternative syntax for <code class="literal">while</code> loops mentioned in <a class="xref" href="ch05.html" title="Chapter 5. Loops and Iterators">Chapter 5</a>. Instead of writing this:</p><a id="I_programlisting6_d1e7280"/><pre class="programlisting">while tired do sleep end</pre><p>you can write this:<a id="IDX-CHP-6-0033" class="indexterm"/><a id="IDX-CHP-6-0034" class="indexterm"/></p><a id="I_programlisting6_d1e7290"/><pre class="programlisting">sleep while tired</pre><p>This alternative syntax, in which the <code class="literal">while</code> keyword is placed between the code to execute and the test condition, is called a <span class="emphasis"><em>while modifier</em></span>. It turns out that Ruby has <code class="literal">if</code> and <code class="literal">unless</code> modifiers too. Here are a few examples:</p><p><span class="emphasis"><em>if_unless_mod.rb</em></span></p><a id="I_programlisting6_d1e7309"/><pre class="programlisting">sleep if tired

begin
   sleep
   snore
end if tired

sleep unless not tired

begin
   sleep
   snore
end unless not tired</pre><p>The terseness of this syntax is useful when you repeatedly need to take some well-defined action if some condition is true. You might, for example, pepper your code with debugging output if a constant called <code class="literal">DEBUG</code> is true:<a id="IDX-CHP-6-0035" class="indexterm"/></p><a id="I_programlisting6_d1e7319"/><pre class="programlisting">puts( "somevar = #{somevar}" ) if DEBUG</pre></div>
<div class="sect1" title="Case Statements"><div class="titlepage"><div><div><h1 class="title"><a id="case_statements"/>Case Statements</h1></div></div></div><p>When you need to take a variety of different actions based on the value of a single variable, multiple <code class="literal">if..elsif</code> tests are verbose and repetitive.</p><p>A neater alternative is provided by a <code class="literal">case</code> statement. This begins with the word <code class="literal">case</code> followed by the variable name to test. Then comes a series of <code class="literal">when</code> sections, each of which specifies a “trigger” value followed by some code.</p><p>This code executes only when the test variable equals the trigger value:</p><p><span class="emphasis"><em>case.rb</em></span></p><a id="I_programlisting6_d1e7346"/><pre class="programlisting">case( i )
   when 1 then puts("It's Monday" )
   when 2 then puts("It's Tuesday" )
   when 3 then puts("It's Wednesday" )
   when 4 then puts("It's Thursday" )
   when 5 then puts("It's Friday" )
   when (6..7) then puts( "Yippee! It's the weekend! " )
   else puts( "That's not a real day!" )
end</pre><div class="sidebar"><a id="constants"/><p class="title">Constants</p><p>In principle, constants are objects whose values never change. For example, <code class="literal">PI</code> in Ruby’s <code class="literal">Math</code> module is a constant. Constants in Ruby begin with a capital letter. Class names are also constants. You can obtain a list of all defined constants using the <code class="literal">constants</code> method:<a id="IDX-CHP-6-0036" class="indexterm"/><a id="IDX-CHP-6-0037" class="indexterm"/><a id="IDX-CHP-6-0038" class="indexterm"/><a id="IDX-CHP-6-0039" class="indexterm"/><a id="IDX-CHP-6-0040" class="indexterm"/><a id="IDX-CHP-6-0041" class="indexterm"/></p><a id="I_programlisting6_d1e7387"/><pre class="programlisting">Object.constants</pre><p>Ruby provides the <code class="literal">const_get</code> and <code class="literal">const_set</code> methods to get and set the value of named constants specified as symbols (identifiers preceded by a colon such as <code class="literal">:RUBY_VERSION</code>). Note that, unlike the constants in many other programming languages, Ruby’s constants may be assigned new values:</p><a id="I_programlisting6_d1e7400"/><pre class="programlisting">RUBY_VERSION = "1.8.7"
RUBY_VERSION = "2.5.6"</pre><p>The previous reassignment of the <code class="literal">RUBY_VERSION</code> constant produces an “already initialized constant” warning but not an error! You can even reassign constants declared in Ruby’s standard class library. For example, here I reassign the value of <code class="literal">PI</code>. Although this displays a warning, the assignment succeeds nonetheless:</p><a id="I_programlisting6_d1e7410"/><pre class="programlisting">puts Math::PI    #=&gt; 3.141592653589793
Math::PI = 100   #=&gt; warning: already initialized constant PI
puts Math::PI    #=&gt; 100</pre><p>You need to be aware that the constancy of Ruby’s constants is a programming <span class="emphasis"><em>convention</em></span>, rather than a rigorously enforced <span class="emphasis"><em>rule</em></span>. Naturally, it is not good programming practice to reassign constants.</p></div><p><span class="emphasis"><em>constants.rb</em></span></p><p><span class="emphasis"><em>math_pi.rb</em></span></p><p>In the previous example, I’ve used the <code class="literal">then</code> keyword to separate each <code class="literal">when</code> test from the code to execute. In Ruby 1.8, just as with <code class="literal">if</code> tests mentioned earlier, you could use a colon as an alternative, but this syntax is not supported in Ruby 1.9:</p><a id="I_programlisting6_d1e7437"/><pre class="programlisting">when 1 : puts("It's Monday" )  # This works in Ruby 1.8 only!</pre><p>The <code class="literal">then</code> can be omitted if the test and the code to be executed are on separate lines. Unlike <code class="literal">case</code> statements in C-like languages, there is no need to enter a <code class="literal">break</code> keyword when a match is made in order to prevent execution trickling down through the remainder of the sections. In Ruby, once a match is made, the <code class="literal">case</code> statement exits:<a id="IDX-CHP-6-0042" class="indexterm"/></p><p><span class="emphasis"><em>case_break.rb</em></span></p><a id="I_programlisting6_d1e7460"/><pre class="programlisting">def showDay( i )
    case( i )
    when 5 then puts("It's Friday" )
        puts("...nearly the weekend!")
    when 6 then puts("It's Saturday!" )
        # the following never executes
    when 5 then puts( "It's Friday all over again!" )
    end
end

showDay( 5 )
showDay( 6 )</pre><p>This displays the following:<a id="IDX-CHP-6-0043" class="indexterm"/></p><a id="I_programlisting6_d1e7469"/><pre class="programlisting">It's Friday
...nearly the weekend!
It's Saturday!</pre><p>You can include several lines of code between each <code class="literal">when</code> condition, and you can include multiple values separated by commas to trigger a single <code class="literal">when</code> block, like this:</p><a id="I_programlisting6_d1e7479"/><pre class="programlisting">when 6, 7 then puts( "Yippee! It's the weekend! " )</pre><p>The condition in a <code class="literal">case</code> statement is not obliged to be a simple variable; it can be an expression like this:</p><p><span class="emphasis"><em>case2.rb</em></span></p><a id="I_programlisting6_d1e7489"/><pre class="programlisting">case( i + 1 )</pre><p>You can also use noninteger types such as a string. If multiple trigger values are specified in a <code class="literal">when</code> section, they may be of varying types—for example, both string and integers:</p><a id="I_programlisting6_d1e7497"/><pre class="programlisting">when 1, 'Monday', 'Mon' then puts( "Yup, '#{i}' is Monday" )</pre><p>Here is a longer example, illustrating some of the syntactical elements mentioned earlier:</p><p><span class="emphasis"><em>case3.rb</em></span></p><a id="I_programlisting6_d1e7504"/><pre class="programlisting">case( i )
    when 1 then puts("It's Monday" )
    when 2 then puts("It's Tuesday" )
    when 3 then puts("It's Wednesday" )
    when 4 then puts("It's Thursday" )
    when 5 then puts("It's Friday" )
          puts("...nearly the weekend!")
    when 6, 7
          puts("It's Saturday!" ) if i == 6
          puts("It's Sunday!" ) if i == 7
          puts( "Yippee! It's the weekend! " )
          # the following never executes
    when 5 then puts( "It's Friday all over again!" )
    else puts( "That's not a real day!" )
end</pre><div class="sect2" title="The === Method"><div class="titlepage"><div><div><h2 class="title"><a id="the_equals_equals_equals_method"/>The === Method</h2></div></div></div><p>As mentioned earlier, the <code class="literal">when</code> tests on an object used in a <code class="literal">case</code> statement are performed using the <code class="literal">===</code> method. So, for example, just as the <code class="literal">===</code> method returns true when an integer forms part of a range, a <code class="literal">when</code> test returns true when an integer variable in a <code class="literal">case</code> statement forms part of a range expression:<a id="IDX-CHP-6-0044" class="indexterm"/><a id="IDX-CHP-6-0045" class="indexterm"/><a id="IDX-CHP-6-0046" class="indexterm"/></p><a id="I_programlisting6_d1e7541"/><pre class="programlisting">when (6..7) then puts( "Yippee! It's the weekend! " )</pre><p>If in doubt on the effect of the <code class="literal">===</code> method for a specific object, refer to the Ruby documentation on that object’s class. Ruby’s standard classes are documented in the core API here: <a class="ulink" href="http://www.ruby-doc.org/">http://www.ruby-doc.org/</a>.</p></div><div class="sect2" title="Alternative Case Syntax"><div class="titlepage"><div><div><h2 class="title"><a id="alternative_case_syntax"/>Alternative Case Syntax</h2></div></div></div><p>There is an alternative form of the <code class="literal">case</code> statement that is like a shorthand form of a series of <code class="literal">if..then..else</code> statements. Each <code class="literal">when</code> section can perform some arbitrary test and execute one or more lines of code. No <code class="literal">case</code> variable is required. Each <code class="literal">when</code> section returns a value that, just like a method, is the result of the last piece of code that’s evaluated. This value can be assigned to a variable preceding the <code class="literal">case</code> statement:</p><p><span class="emphasis"><em>case4.rb</em></span></p><a id="I_programlisting6_d1e7577"/><pre class="programlisting">salary = 2000000
season = 'summer'

happy = case
    when salary &gt; 10000 &amp;&amp; season == 'summer' then
        puts( "Yes, I really am happy!" )
        'Very happy'
    when salary &gt; 500000 &amp;&amp; season == 'spring' then 'Pretty happy'
    else puts( 'miserable' )
end

puts( happy ) #=&gt; 'Very happy'</pre><div class="sidebar"><a id="digging_deeper-id5"/><p class="title">Digging Deeper</p><p>There is more to Ruby comparison operators than meets the eye. Here you will learn about their effects and side effects and discover how to break out of blocks when a condition is met.<a id="IDX-CHP-6-0047" class="indexterm"/><a id="IDX-CHP-6-0048" class="indexterm"/><a id="IDX-CHP-6-0049" class="indexterm"/><a id="IDX-CHP-6-0050" class="indexterm"/><a id="IDX-CHP-6-0051" class="indexterm"/><a id="IDX-CHP-6-0052" class="indexterm"/><a id="IDX-CHP-6-0053" class="indexterm"/><a id="IDX-CHP-6-0054" class="indexterm"/></p><p><span class="bolditalic">Boolean Operators</span></p><p>The following operators are available in Ruby for testing expressions that may yield true or false values.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">and</code> and <code class="literal">&amp;&amp;</code></p></td><td style="text-align: left" valign="top"><p>These operators evaluate the left-hand side; only if the result is true do they then evaluate the right side. <code class="literal">and</code> has lower precedence than <code class="literal">&amp;&amp;</code>.<a id="IDX-CHP-6-0055" class="indexterm"/><a id="IDX-CHP-6-0056" class="indexterm"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">or</code> and <code class="literal">||</code></p></td><td style="text-align: left" valign="top"><p>These operators evaluate the left-hand side; if the result is false, then they evaluate the right side. <code class="literal">or</code> has lower precedence than <code class="literal">||</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">not</code> and <code class="literal">!</code></p></td><td style="text-align: left" valign="top"><p>These operators negate a Boolean value; in other words, they return true when false and return false when true.</p></td></tr></tbody></table></div><p>Be careful when using the alternative Boolean operators. Because of the difference in precedence, conditions will be evaluated in different orders and may yield different results.<a id="IDX-CHP-6-0057" class="indexterm"/></p><p>Consider the following:</p><p><span class="emphasis"><em>boolean_ops.rb</em></span></p><a id="I_programlisting6_d1e7687"/><pre class="programlisting"># Example 1
if ( 1==3 ) and (2==1) || (3==3) then
   puts('true')
else
   puts('false')
end

# Example 2
if ( 1==3 ) and (2==1) or (3==3) then
   puts('true')
else
   puts('false')
end</pre><p>These may look the same at first sight. In fact, Example 1 prints “false,” while Example 2 prints “true.” This is entirely because <code class="literal">or</code> has lower precedence than <code class="literal">||</code>. As a consequence, Example 1 tests “if 1 equals 3 [<span class="emphasis"><em>false</em></span>] and (either 2 equals 1 or 3 equals 3) [<span class="emphasis"><em>true</em></span>].” Because one of these two necessary conditions is false, the entire test returns false.</p><p>Now look at Example 2. This tests “(if 1 equals 3 and 2 equals 1) [<span class="emphasis"><em>false</em></span>] or 3 equals 3 [<span class="emphasis"><em>true</em></span>].” This time, you need only one of the two tests to succeed; the second test evaluates to true so the entire tests returns true.</p><p>The side effects of operator precedence in this kind of test can lead to very obscure bugs. You can avoid these by clarifying the meaning of the test using parentheses. Here, I have rewritten Examples 1 and 2; in each case, the addition of one pair of parentheses has inverted the initial Boolean value returned by the test:<a id="IDX-CHP-6-0058" class="indexterm"/><a id="IDX-CHP-6-0059" class="indexterm"/><a id="IDX-CHP-6-0060" class="indexterm"/></p><a id="I_programlisting6_d1e7727"/><pre class="programlisting"># Example 1 (b) - now returns true
if (( 1==3 ) and (2==1)) || (3==3) then
   puts('true')
else
   puts('false')
end

# Example 2 (b) - now returns false
if ( 1==3 ) and ((2==1) or (3==3)) then
   puts('true')
else
   puts('false')
end</pre><p><span class="bolditalic">Eccentricities of Boolean Operators</span></p><p>Be warned that Ruby’s Boolean operators can sometimes behave in a curious and unpredictable manner. For example:</p><p><span class="emphasis"><em>eccentricities.rb</em></span></p><a id="I_programlisting6_d1e7737"/><pre class="programlisting">puts( (not( 1==1 )) )                # This is okay
puts( not( 1==1 ) )                  # Syntax error in Ruby 1.8
                                     # but okay in Ruby 1.9

puts( true &amp;&amp; true &amp;&amp; !(true) )      # This is okay
puts( true &amp;&amp; true and !(true) )     # This is a syntax error

puts( ((true) and (true)) )          # This is okay
puts( true &amp;&amp; true )                 # This is okay
puts( true and true )                # This is a syntax error</pre><p>In many cases, you can avoid problems by sticking to one style of operator (either <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code> <span class="emphasis"><em>or</em></span> <code class="literal">&amp;&amp;</code>, <code class="literal">||</code>, and <code class="literal">!</code>) rather than mixing the two. In addition, the generous use of parentheses is recommended!<a id="IDX-CHP-6-0061" class="indexterm"/></p><p><span class="bolditalic">catch and throw</span></p><p>Ruby provides a pair of methods, <code class="literal">catch</code> and <code class="literal">throw</code>, which can be used to break out of a block of code when some condition is met. This is Ruby’s nearest equivalent to a <code class="literal">goto</code> in some other programming languages. The block must begin with <code class="literal">catch</code> followed by a symbol (that is, a unique identifier preceded by a colon), such as <code class="literal">:done</code> or <code class="literal">:finished</code>. The block itself may be delimited either by curly brackets or by the keywords <code class="literal">do</code> and <code class="literal">end</code>, like this:<a id="IDX-CHP-6-0062" class="indexterm"/><a id="IDX-CHP-6-0063" class="indexterm"/></p><a id="I_programlisting6_d1e7804"/><pre class="programlisting"># think of this as a block called :done
catch( :done ){
   # some code here
}

# and this is a block called :finished
catch( :finished ) do
   # some code here
end</pre><p>Inside the block, you can call <code class="literal">throw</code> with a symbol as an argument. Normally you would call <code class="literal">throw</code> when some specific condition is met that makes it desirable to skip all the remaining code in the block. For instance, let’s assume the block contains some code that prompts the user to enter a number, divides some value by that number, and then goes on to do a multitude of other complex calculations with the result. Obviously, if the user enters 0, then none of the calculations that follow can be completed, so you would want to skip them all by jumping right out of the block and continuing with any code that follows it. This is one way of doing that:</p><p><span class="emphasis"><em>catch_throw.rb</em></span></p><a id="I_programlisting6_d1e7818"/><pre class="programlisting">catch( :finished) do
   print( 'Enter a number: ' )
   num = gets().chomp.to_i
   if num == 0 then
      throw :finished # if num is 0, jump out of the block
   end
      # Here there may be hundreds of lines of
      # calculations based on the value of num
      # if num is 0 this code will be skipped
end
      # the throw method causes execution to
      # jump to here - outside of the block
puts( "Finished" )</pre><p>You can, in fact, have a call to <code class="literal">throw</code> outside the block, like this:</p><a id="I_programlisting6_d1e7825"/><pre class="programlisting">def dothings( aNum )
   i = 0
   while true
      puts( "I'm doing things..." )
      i += 1
      throw( :go_for_tea ) if (i == aNum )
                        # throws to end of go_to_tea block
   end
end

catch( :go_for_tea ){   # this is the :go_to_tea block
      dothings(5)
}</pre><p>And you can have <code class="literal">catch</code> blocks nested inside other <code class="literal">catch</code> blocks, like this:</p><a id="I_programlisting6_d1e7835"/><pre class="programlisting">catch( :finished) do
   print( 'Enter a number: ' )
   num = gets().chomp.to_i
   if num == 0 then throw :finished end
      puts( 100 / num )


   catch( :go_for_tea ){
      dothings(5)
   }

   puts( "Things have all been done. Time for tea!" )
end</pre><p>As with <code class="literal">goto</code>s and jumps in other programming languages, <code class="literal">catch</code> and <code class="literal">throw</code> in Ruby should be used with great care because they break the logic of your code and can, potentially, introduce hard-to-find bugs.</p></div></div></div></body></html>