- en: Chapter 5. GAMES AND LEARNING TOOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 游戏和学习工具
- en: '![GAMES AND LEARNING TOOLS](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![游戏和学习工具](../Images/00001.jpg)'
- en: Everyone knows that games are fun—the gaming industry is *huge*. This chapter
    will show you how to design scripts that can be used for amusement, learning,
    and gaming. I find writing scripts that produce games is a lot more interesting
    than writing scripts to parse through firewall logs. But hey, that's just me.
    Read through these and see what you think. The first script is a Sudoku solver,
    and while not a game script, it is guaranteed to find the solution for every Sudoku
    puzzle!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道游戏很有趣——游戏产业是**巨大的**。这一章将向您展示如何设计用于娱乐、学习和游戏的脚本。我发现编写生成游戏的脚本比编写解析防火墙日志的脚本有趣得多。但嘿，那只是我个人的看法。读一读这些，看看你有什么想法。第一个脚本是一个数独求解器，虽然不是一个游戏脚本，但它保证能找到每个数独谜题的解决方案！
- en: Sudoku Solver
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数独求解器
- en: Sudoku Solver
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数独求解器
- en: sudoku.rb
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sudoku.rb
- en: There are a few things you have always been able to count on in your local newspaper.
    One is crossword puzzles, and the other is word scrambles—that is, until the Sudoku
    craze. I find myself occasionally attempting to solve these puzzles, but most
    of the time, I get stuck or mess up. If I can't solve the puzzle, I have to wait
    for the next newspaper to come out the following day, which is frustrating because
    I've usually forgotten about the puzzle by then. To alleviate my frustration,
    I wrote this script. The algorithm comes from a Perl script written by Edmund
    von der Burg ([http://www.ecclestoad.co.uk/](http://www.ecclestoad.co.uk/)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在您当地的报纸上，有一些事情您一直可以依赖。其中之一是填字游戏，另一个是单词拼图——也就是说，直到数独热潮来临。我发现自己偶尔会尝试解决这些谜题，但大多数时候，我会卡住或出错。如果我不能解决这个谜题，我就不得不等到第二天报纸出来，这很令人沮丧，因为那时候我通常已经忘记了谜题。为了缓解我的沮丧，我写了这个脚本。算法来自由Edmund
    von der Burg编写的Perl脚本([http://www.ecclestoad.co.uk/](http://www.ecclestoad.co.uk/))。
- en: The Code
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` class SudokuSolver      def initialize(puzzle)          @@p = puzzle.split(//)
         end      ![](../Images/00002.jpg)       def solver        h=Hash.new ![](../Images/00003.jpg)  
       81.times do |j|          next if $p[j].to_i!=0 ![](../Images/00004.jpg)    
         80.times do |k| ![](../Images/00005.jpg)            if k/9==j/9 || k%9==j%9
    || k/27==j/27 && k%9/3==j%9/3              temp = $p[k]            else       
          temp = 0            end ![](../Images/00006.jpg)           h[temp] =1   
          end           1.upto(9) do |v|            next if h.has_key?(v.to_s)   
            $p[j]=v.to_s ![](../Images/00007.jpg)           solver          end   
          return $p[j]=0        end             puts "\n\nThe solution is:\n"     
      print "+-----------------------------+\n|" ![](../Images/00008.jpg)       1.upto(81)
    do |x|          print " #{$p[x-1]} "          if x%3==0 and x%9 !=0           
    print "|"          end          if x%9==0 and x%81 !=0            print"|\n|-----------------------------|\n|"
             end          if x%81==0            puts "|"          end             
      end        puts "+-----------------------------+"        return      end   
    end  ![](../Images/00009.jpg) unless ARGV[0].length==81      puts "Your input
    was invalid.  Please try again."      puts "USAGE: ruby sudoku.rb <Sudoku puzzle
    on one line/no spaces with 0''s  being the blanks>"      puts "Example:ruby sudoku.rb
    000201600.....09605000"      exit  end  ![](../Images/00011.jpg) answer = SudokuSolver.new(ARGV[0])   puts
    "\n\n\nSolving puzzle, wait one moment..."  answer.solver`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '` class SudokuSolver      def initialize(puzzle)          @@p = puzzle.split(//)
         end      ![](../Images/00002.jpg)       def solver        h=Hash.new ![](../Images/00003.jpg)  
       81.times do |j|          next if $p[j].to_i!=0 ![](../Images/00004.jpg)    
         80.times do |k| ![](../Images/00005.jpg)            if k/9==j/9 || k%9==j%9
    || k/27==j/27 && k%9/3==j%9/3              temp = $p[k]            else       
          temp = 0            end ![](../Images/00006.jpg)           h[temp] =1   
          end           1.upto(9) do |v|            next if h.has_key?(v.to_s)   
            $p[j]=v.to_s ![](../Images/00007.jpg)           solver          end   
          return $p[j]=0        end             puts "\n\nThe solution is:\n"     
      print "+-----------------------------+\n|" ![](../Images/00008.jpg)       1.upto(81)
    do |x|          print " #{$p[x-1]} "          if x%3==0 and x%9 !=0           
    print "|"          end          if x%9==0 and x%81 !=0            print"|\n|-----------------------------|\n|"
             end          if x%81==0            puts "|"          end             
      end        puts "+-----------------------------+"        return      end   
    end  ![](../Images/00009.jpg) unless ARGV[0].length==81      puts "Your input
    was invalid.  Please try again."      puts "USAGE: ruby sudoku.rb <Sudoku puzzle
    on one line/no spaces with 0''s  being the blanks>"      puts "Example:ruby sudoku.rb
    000201600.....09605000"      exit  end  ![](../Images/00011.jpg) answer = SudokuSolver.new(ARGV[0])   puts
    "\n\n\nSolving puzzle, wait one moment..."  answer.solver`'
- en: Running the Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To solve the Sudoku puzzle, you must enter the original puzzle configuration
    as part of the command-line argument. For each blank, substitute a zero. If the
    puzzle looked like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决数独谜题，你必须将原始谜题配置作为命令行参数的一部分输入。对于每个空白，用零替换。如果谜题看起来像这样：
- en: '![image with no caption](../Images/00015.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](../Images/00015.jpg)'
- en: 'Your input would be:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输入将是：
- en: '``**`ruby sudoku.rb 000700390090500000300240800700900200000000000003007008004026007000005060026001000`**``'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby sudoku.rb 000700390090500000300240800700900200000000000003007008004026007000005060026001000`**``'
- en: The Results
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`The solution is: +-----------------------------+ | 5  4  2 | 7  6  8 | 3  9
     1 | |-----------------------------| | 6  9  8 | 5  1  3 | 7  2  4 | |-----------------------------|
    | 3  7  1 | 2  4  9 | 8  5  6 | |-----------------------------| | 7  6  5 | 9
     8  4 | 2  1  3 | |-----------------------------| | 4  8  9 | 1  3  2 | 6  7  5
    | |-----------------------------| | 2  1  3 | 6  5  7 | 9  4  8 | |-----------------------------|
    | 9  5  4 | 3  2  6 | 1  8  7 | |-----------------------------| | 1  3  7 | 8
     9  5 | 4  6  2 | |-----------------------------| | 8  2  6 | 4  7  1 | 5  3  9
    | +-----------------------------+`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`解决方案是：+-----------------------------+ | 5  4  2 | 7  6  8 | 3  9  1 | |-----------------------------|
    | 6  9  8 | 5  1  3 | 7  2  4 | |-----------------------------| | 3  7  1 | 2
     4  9 | 8  5  6 | |-----------------------------| | 7  6  5 | 9  8  4 | 2  1  3
    | |-----------------------------| | 4  8  9 | 1  3  2 | 6  7  5 | |-----------------------------|
    | 2  1  3 | 6  5  7 | 9  4  8 | |-----------------------------| | 9  5  4 | 3
     2  6 | 1  8  7 | |-----------------------------| | 1  3  7 | 8  9  5 | 4  6  2
    | |-----------------------------| | 8  2  6 | 4  7  1 | 5  3  9 | +-----------------------------+`'
- en: How It Works
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: This script is completely different than every script we've discussed in the
    book thus far, so pay close attention. The main difference is the use of a class
    and methods within the class, instead of linear script progression. To solve the
    Sudoku puzzle, the script needs to call a method recursively. *Recursion* is when
    a method calls itself as a subroutine. To use recursion, you need to first have
    a method to call. To begin dissecting this script, we'll actually start from the
    bottom and jump back up to the top.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本与书中迄今为止讨论的每一个脚本都完全不同，所以请务必注意。主要区别在于使用了类及其内部的方法，而不是线性脚本执行。为了解决数独谜题，脚本需要递归地调用一个方法。*递归*是指一个方法作为子程序调用自身。要使用递归，首先需要有一个可以调用的方法。为了开始分析这个脚本，我们将从底部开始，然后跳回顶部。
- en: As mentioned above, you must supply the Sudoku puzzle as a command-line argument
    when running the script. If you don't supply an 81-character puzzle, the script
    will yell at you and exit ![](../Images/00009.jpg). The first action taken to
    solve the puzzle is initializing a `SudokuSolver` object called `answer` ![](../Images/00011.jpg).
    The puzzle is passed as an initialization parameter and subsequently broken up
    by the `split` method. The `split` method gives us the ability to break the string
    of 81 characters into little pieces for further manipulation. The resulting array
    is stored in the class variable `@@p`. After the object is initialized, `solver`
    is called to solve the puzzle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，在运行脚本时，你必须将数独谜题作为命令行参数提供。如果你不提供一个81个字符的谜题，脚本会大声抱怨并退出 ![image](../Images/00009.jpg)。解决谜题的第一步是初始化一个名为`answer`的`SudokuSolver`对象
    ![image](../Images/00011.jpg)。谜题作为初始化参数传递，然后通过`split`方法分解。`split`方法使我们能够将81个字符的字符串分解成小块，以便进一步操作。结果数组存储在类变量`@@p`中。对象初始化后，调用`solver`来解决谜题。
- en: Moving to the top of the script, you will see `solver` defined ![](../Images/00002.jpg).
    First, a hash is created to track which values have been used. Next, we enter
    a loop for 81 iterations, as there are 81 blocks in a Sudoku puzzle ![](../Images/00003.jpg).
    Each index of the array `@@p` is analyzed for further computations as needed.
    If the array element already has a value that is not equal to zero, then the script
    won't waste any time solving for that number—it is already provided. If the array
    element contains a zero, then the script begins a second loop of 80 iterations
    (the total number of blocks in the Sudoku puzzle minus the element we are solving)
    ![](../Images/00004.jpg). After a tricky `if` statement ![](../Images/00005.jpg),
    the script will either leave the zero value alone or set a hash equal to one.
    This `if` statement is very important; it's where most of the magic happens. Based
    on the modulus operations and comparisons, the script is able to determine which
    row needs to be analyzed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本移动到顶部，你会看到定义了`solver` ![图片](../Images/00002.jpg)。首先，创建一个哈希表来跟踪哪些值已被使用。接下来，我们进入一个循环，循环81次，因为数独谜题中有81个方块
    ![图片](../Images/00003.jpg)。根据需要，分析数组`@@p`的每个索引以进行进一步计算。如果数组元素已经有一个不等于零的值，那么脚本将不会浪费时间解决那个数字——它已经提供了。如果数组元素包含一个零，那么脚本开始一个80次的第二个循环（数独谜题中所有方块的总数减去我们要解决的元素）
    ![图片](../Images/00004.jpg)。在复杂的`if`语句 ![图片](../Images/00005.jpg) 之后，脚本将保留零值不变或设置一个等于一的哈希表。这个`if`语句非常重要；它就是大多数魔法发生的地方。基于模运算和比较，脚本能够确定需要分析哪一行。
- en: The only numbers available to solve the Sudoku puzzle are 1 through 9, so in
    order to keep from violating the Sudoku rules, the hash keeps track of which numbers
    have been used ![](../Images/00006.jpg). If a number has been used for the loop
    spanning the range of 1 through 9, then the next number is called.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决数独谜题可用的唯一数字是1到9，因此为了不违反数独规则，哈希表会跟踪哪些数字已被使用 ![图片](../Images/00006.jpg)。如果一个数字在1到9的范围内已被使用，那么下一个数字就会被调用。
- en: Once a number is found that hasn't been used, the script starts its recursion;
    you can see the method `solver` calling itself ![](../Images/00007.jpg). After
    all loops have terminated, the last step is to output the solution. The easy way
    would be to spit out a long string of each element in the array, but frankly,
    that's ugly. I find inputting the original puzzle challenging enough.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个尚未使用的数字，脚本开始它的递归；你可以看到`solver`方法在调用自己 ![图片](../Images/00007.jpg)。在所有循环都终止后，最后一步是输出解决方案。简单的方法是输出数组中每个元素的长字符串，但坦白说，那很丑。我发现输入原始谜题就足够具有挑战性了。
- en: Again, using the modulus operators to determine when a new row and column should
    be started, the script outputs a perfect Sudoku puzzle ![](../Images/00008.jpg).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用模运算符来确定何时开始新的行和列，脚本输出一个完美的数独谜题 ![图片](../Images/00008.jpg)。
- en: Flash Cards
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flash Cards
- en: Flash Cards
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flash Cards
- en: flashCards.rb
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: flashCards.rb
- en: Flash cards have been the savior of many a cramming student. They can be used
    to memorize historical dates, vocabulary words, foreign languages, and virtually
    anything else worth remembering. If you've never encountered flash cards before,
    I'll give you a quick run down. Traditionally, flash cards are made using both
    sides of a three-by-five index card. You write a question on the front of the
    index card and the answer to that question on the back. Then you can test yourself
    to ace whatever you're studying. This script could be tweaked for either a game
    (think *Jeopardy!*) or learning tool, but we'll focus on the latter option. The
    script will prompt you for a question, and you must provide the right answer,
    or else …
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 闪卡曾经是许多临时抱佛脚学生的救星。它们可以用来记忆历史日期、词汇、外语以及几乎所有值得记住的东西。如果你以前从未遇到过闪卡，我会给你一个简要的介绍。传统上，闪卡是使用三乘五的索引卡的两面制作的。你在索引卡的正面写一个问题，在背面写那个问题的答案。然后你可以测试自己，以通过你正在学习的任何内容。这个脚本可以调整为一个游戏（想想*Jeopardy!*）或学习工具，但我们将关注后者。脚本将提示你一个问题，你必须提供正确的答案，否则……
- en: The Code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` unless ARGV[0]      puts "\n\nUsage is flashCards.rb <file>\n\n"      exit
     end   ![](../Images/00002.jpg) flash = []  ![](../Images/00003.jpg) card = Struct.new(:question,
    :answer)   File.open(ARGV[0], "rb").each do |line|      if line =~ /(.*)\s{3,10}(.*)/
    ![](../Images/00004.jpg)       flash << card.new($1.strip, $2.strip)      end
     end  ![](../Images/00005.jpg) flash.replace(flash.sort_by { rand })  ![](../Images/00006.jpg) until
    flash.empty?      drill = flash.pop ![](../Images/00007.jpg)       print "#{drill.question}?
    "      guess = $stdin.gets.chomp       if guess.downcase == drill.answer.downcase
    ![](../Images/00008.jpg)            puts "\n\nCorrect -- The answer is: #{drill.answer}\n\n\n"
         else ![](../Images/00009.jpg)            puts "\n\nWRONG -- The answer is:
    #{drill.answer}\n\n\n"      end  end`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script requires a flash card file based on the following format, with
    five spaces between the *`Question`* and the *`Answer`*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '``*`Question     Answer`*``'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: To run the script, supply the flash card file as an argument.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Results
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script begins prompting the user for the answer to a randomly selected
    question. In this example, I used an English-to-Spanish flash card file. The output
    was:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`train? El traino WRONG - The answer is: el tren  orange? La naranja Correct
    - The answer is: la naranja`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script takes the flash card file and opens it for reading ![](../Images/00002.jpg).
    Until this script, we've been using data structures that were already defined,
    such as arrays and hashes. Sometimes you'll find a need to customize your own
    data structure. I used the `Struct` command to create my own data structure, called
    `card` ![](../Images/00003.jpg).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*When you are storing the name of a person, you should save the name in a string
    variable. These common data structures are predefined to save programmers time,
    but you can define your own data structures like I have done with `Struct`.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '`card` contains two elements—`question` and `answer`. In order to make and
    collect all the flash cards, the flash card file `infile` is broken down line
    by line. Each flash card is added to an array called `flash` ![](../Images/00004.jpg).
    Once it reaches the end-of-file, the array `flash` has a complete collection of
    cards with questions and answers on them. I love it!'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: All of the flash cards have been created—so we're almost ready to start torturing
    quizzing the user. We need to ensure some randomness among the questions, so the
    `rand` function comes on the scene. In combination with the `sort` and `replace`
    methods, `rand` makes the question-asking a bit more chaotic and unpredictable
    ![](../Images/00005.jpg). The number of cards that the array has will determine
    the number of questions asked ![](../Images/00006.jpg). A random card is selected,
    `drill`, and the `question` variable is presented to the user ![](../Images/00007.jpg).
    The user input is read from the standard input at the console and compared to
    `answer`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的闪卡都已经创建好了——所以我们几乎准备好开始折磨用户进行测验了。我们需要确保问题之间有一定的随机性，所以`rand`函数出现了。结合`sort`和`replace`方法，`rand`使得提问变得稍微混乱和不可预测
    ![图片](../Images/00005.jpg)。数组中的卡片数量将决定问题的数量 ![图片](../Images/00006.jpg)。随机选择一张卡片，`drill`，然后将`question`变量展示给用户
    ![图片](../Images/00007.jpg)。用户输入从控制台的标准输入读取，并与`answer`进行比较。
- en: If the user's guess is correct, the script congratulates the user and asks another
    question ![](../Images/00008.jpg). However, if more studying is needed and the
    user gets the question wrong, he will see a big *WRONG* followed by the correct
    answer ![](../Images/00009.jpg). You could come up with a different way to indicate
    an incorrect guess—maybe something a bit easier on the ego—but this seemed to
    get the point across.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的猜测是正确的，脚本会恭喜用户并询问另一个问题 ![图片](../Images/00008.jpg)。然而，如果需要更多的学习，并且用户回答错误，他将会看到一个大的
    *错误* 标签，后面跟着正确的答案 ![图片](../Images/00009.jpg)。你可以想出一种不同的方式来表示错误的猜测——可能是一种对自尊心稍微温和一些的方式——但这种方法似乎已经传达了重点。
- en: Hacking the Script
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本破解
- en: There are a lot of tweaks you can make to this script. Some ideas to get you
    thinking include making the number of questions asked a variable or continuing
    to ask questions until 100 percent accuracy is obtained. Finally, the script could
    keep a scorecard to let the user know how well he or she did once all the questions
    had been asked. Flash cards are great, so give it a shot. Who knows, maybe you'll
    start learning another language!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对这个脚本进行很多调整。以下是一些启发你思考的想法：将询问的问题数量设为变量或者继续提问直到达到100%的准确率。最后，脚本可以保持一个计分板，让用户在所有问题都问过之后知道他或她的表现如何。闪卡很棒，所以不妨试试。谁知道呢，也许你开始学习另一种语言了！
- en: Number-Guessing Game
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字猜谜游戏
- en: Number-Guessing Game
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字猜谜游戏
- en: guessingGame.rb
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: guessingGame.rb
- en: 'This number-guessing game seems simple enough when you''re a little kid: Someone
    picks a number and you try to guess it. In this script, a computer is doing the
    pseudo-random number generation, which is a lot more unpredictable than your friend
    picking his favorite number. As I wrote this, I got to thinking, "This sounds
    an awful lot like a game adults play—the lottery." How crazy is that? The same
    game that entertained you as a kid is still entertaining as an adult. Although
    the payoff is a lot better in the lottery, the odds are a lot worse. The bottom
    line is that this game is all about chance.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你还是一个小孩的时候，这个数字猜谜游戏看起来足够简单：有人选择一个数字，你尝试猜出来。在这个脚本中，计算机进行的是伪随机数生成，这比你的朋友选择他最喜欢的数字要不可预测得多。当我写这段文字的时候，我开始想，“这听起来非常像成年人玩的游戏——彩票。”这有多疯狂？那个曾经让你作为小孩感到娱乐的游戏，现在作为成年人仍然很有趣。尽管彩票的回报要好得多，但几率要差得多。总的来说，这个游戏完全是关于机会的。
- en: The Code
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` puts "\nWelcome to the number-guessing game!\n\n\n\n"  print "What difficulty
    level would you like (low, medium, or hard): "  level = gets.chomp  puts "Enter
    ''q'' to quit.\n\n\n\n\n"  min = 1  ![](../Images/00002.jpg) max = case level
         when "medium" then 100      when "hard"   then 1000      else            
      10  end   puts "The magic number is between #{min} and #{max}.\n\n"  magic_number
    = rand(max)+1   print "What is your guess? "  guess = gets.chomp  ![](../Images/00003.jpg) while
    guess =~ /\d/ ![](../Images/00004.jpg)        case guess.to_i          when 0...magic_number
                 puts "Too Low, try again.\n\n"          when magic_number       
          puts "\nYou guessed it!!!\nThe magic number was #{magic_number}.\n\n\n"
                 print "Press the ''enter'' key to continue."              gets   
              exit          else              puts "Too High, try again.\n\n"     
        end      print "What is your guess? "      guess = gets.chomp  end   puts
    "Invalid entry, you lose."`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game doesn''t require any arguments to begin playing. Type the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby guessingGame.rb`**``'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Welcome to the number-guessing game!  What difficulty level would you like
    (low, medium, high): low Enter ''q'' to quit.  The magic number is between 1 and
    10. What is your guess? 7 Too Low, try again.  What is your guess? 9  You guessed
    it!!! The magic number was 9.  Press the ''enter'' key to continue.`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entire script revolves around three variables: `min`, `max`, and `guess`.
    To set the game for play, the script asks for a difficulty-level setting. The
    difficulty level corresponds to the range of numbers the computer will pick from.
    The levels are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: low = 1-10medium = 1-100hard = 1-1000
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After the script asks for the user input for the difficulty level, the response
    is run through a `case` statement ![](../Images/00002.jpg). `case` statements
    are like a bunch of `if` statements on steroids. Depending on the response, the
    script will set the value for `max`. Note that `min` is always set to 1.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: As long as the user continues supplying valid guesses, the game will continue
    responding that the guess was either higher or lower than the secret number ![](../Images/00003.jpg).
    Another `case` statement makes returning the appropriate response very easy ![](../Images/00004.jpg).
    If the guess is between 0 and the `magic_number`, then the guess was too low.
    Likewise, if the guess is between the `magic_number` and `max`, then the guess
    is too high. If the `magic_number` is guessed, then the user wins. Unfortunately,
    you won't win any money playing this script.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: rps.rb
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I still use Rock, Paper, Scissors whenever there is a big decision involving
    another person that needs an unbiased opinion. I guess I could flip a quarter,
    but Rock, Paper, Scissors is a lot more suspenseful. Seriously though, this game
    is big in some circles. If you didn't know, there are clubs and tournaments to
    support the game. This script will be your practice partner until you make it
    to the big leagues.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然在涉及另一个人且需要无偏见的意见的重大决策时使用剪刀石头布。我想我可以抛硬币，但剪刀石头布更有悬念。说真的，这个游戏在某些圈子中很受欢迎。如果你不知道，还有俱乐部和锦标赛来支持这个游戏。此脚本将成为你的练习伙伴，直到你进入高级别。
- en: The Code
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) puts "\n\nWelcome to Rock, Paper, Scissors!"  puts
    "This is a game of chance; the computer randomly picks one of three choices."
     puts "\nRock beats Scissors, but is beaten by Paper."  puts "Scissors beat Paper,
    but are beaten by Rock."  puts "Paper beats Rock, but is beaten by Scissors."   puts
    "r for Rock"  puts "s for Scissors"  puts "p for Paper\n"  print "\nEnter one
    of the above to play: "  ![](../Images/00003.jpg) computer = "rsp"[rand(3)].chr
    ![](../Images/00004.jpg) player = $stdin.gets.chomp.downcase  ![](../Images/00005.jpg) case
    [player, computer] ![](../Images/00006.jpg)       when [''p'',''r''], [''s'',''p''],
    [''r'',''s'']      puts "\n\nYou win!" ![](../Images/00007.jpg)       when [''r'',''r''],
    [''p'',''p''], [''s'',''s'']      puts "\n\nYou tied!"  else      puts "\n\nYou
    lose!"  end   puts "The computer chose: #{computer}"  ![](../Images/00008.jpg) puts
    "Press <Enter> to continue."  $stdin.gets`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) puts "\n\n欢迎来到剪刀石头布！"  puts "这是一个机会游戏；电脑随机选择三种选择之一。"
     puts "\n石头胜剪刀，但被布打败。"  puts "剪刀胜布，但被石头打败。"  puts "布胜石头，但被剪刀打败。"   puts "r 代表石头"
     puts "s 代表剪刀"  puts "p 代表布\n"  print "\n请输入上述选项之一进行游戏： "  ![](../Images/00003.jpg) computer
    = "rsp"[rand(3)].chr ![](../Images/00004.jpg) player = $stdin.gets.chomp.downcase  ![](../Images/00005.jpg) case
    [player, computer] ![](../Images/00006.jpg)       when [''p'',''r''], [''s'',''p''],
    [''r'',''s'']      puts "\n\n你赢了！" ![](../Images/00007.jpg)       when [''r'',''r''],
    [''p'',''p''], [''s'',''s'']      puts "\n\n你平局了！"  else      puts "\n\n你输了！" 
    end   puts "电脑选择了：#{computer}"  ![](../Images/00008.jpg) puts "按<Enter>键继续。"  $stdin.gets`'
- en: Running the Code
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'No command-line arguments are needed to run this script—just pure concentration.
    Simply type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本不需要命令行参数——只需全神贯注。只需输入：
- en: '``**`ruby rps.rb`**``'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby rps.rb`**``'
- en: The Results
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'I won this game, but I got lucky. The computer seems to beat me more often
    than not. I probably wouldn''t fare so well at the tournaments. The winning game
    looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我赢得了这场比赛，但我运气好。电脑似乎总是打败我。我可能不会在锦标赛上表现得那么好。获胜的游戏看起来是这样的：
- en: '`Welcome to Rock, Paper, Scissors! This is a game of chance; the computer randomly
    picks one of three choices.  Rock beats Scissors, but is beaten by Paper. Scissors
    beat Paper, but are beaten by Rock. Paper beats Rock, but is beaten by Scissors.  r
    for Rock s for Scissors p for Paper  Enter one of the above to play: r  You WIN!
    The computer chose: s Press <Enter> to continue.`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`欢迎来到剪刀石头布！这是一个机会游戏；电脑随机选择三种选择之一。石头胜剪刀，但被布打败。剪刀胜布，但被石头打败。布胜石头，但被剪刀打败。r 代表石头
    s 代表剪刀 p 代表布  输入上述选项之一进行游戏：r  你赢了！电脑选择了：s 按Enter键继续。`'
- en: How It Works
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The first step for any game is to output the rules and objective so the user
    has a fair chance of winning ![](../Images/00002.jpg). After that, winning is
    totally up to the user. This script outputs the notation being used and reminds
    the user that Rock, Paper, Scissors is a game of chance. The letters `r`, `p`,
    and `s` are used as a shortcut for playing Rock, Paper, or Scissors. An interesting
    aspect of the script was figuring out how to generate a random play for the computer
    then determining what constituted a win.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏的第一步是输出规则和目标，这样用户就有公平的获胜机会！[![](../Images/00002.jpg)](https://example.org/images/00002.jpg)。之后，获胜完全取决于用户。此脚本输出正在使用的符号，并提醒用户剪刀石头布是一个机会游戏。字母
    `r`、`p` 和 `s` 用作玩石头、剪刀或布的快捷方式。脚本的一个有趣之处在于找出如何为电脑生成随机选择，然后确定什么构成了胜利。
- en: To address the random computer play, I used the `rand` method and passed `3`
    as the parameter to let the method know I only wanted one of three options back
    ![](../Images/00003.jpg). To deal with the winning conditions, I needed user input,
    so `player` is used to store the user's play ![](../Images/00004.jpg). Note that
    the user actually makes his choice after the computer has already chosen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理电脑的随机选择，我使用了 `rand` 方法，并将 `3` 作为参数传递，让该方法知道我只想要三种选项中的一个！[![](../Images/00003.jpg)](https://example.org/images/00003.jpg)。为了处理获胜条件，我需要用户输入，因此使用
    `player` 存储用户的玩法！[![](../Images/00004.jpg)](https://example.org/images/00004.jpg)。请注意，用户实际上是在电脑已经选择之后做出选择的。
- en: 'If you think about the game, there are only three outcomes: win, lose, or draw.
    Likewise, there are only three ways to win and three ways to lose. Instead of
    typing up a separate `if` statement for each outcome, I tried to abstract the
    conditions and consolidate them into a short `case` statement ![](../Images/00005.jpg).
    If the player has Rock and the computer has Scissors, then the player wins. If
    the player has Paper and the computer has Rock, then the player wins. If the player
    has Scissors and the computer has Paper, then the player wins ![](../Images/00006.jpg).
    The game is considered a tie if the player and the computer have the same choice
    ![](../Images/00007.jpg). If there are any other combinations, then the player
    loses. This synopsis isn''t complicated; you just need to think through it.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑这个游戏，只有三种结果：赢、输或平局。同样，只有三种获胜方式和三种失败方式。与其为每种结果分别编写一个单独的`if`语句，我尝试将条件抽象化并将它们合并成一个简短的`case`语句
    ![图片](../Images/00005.jpg)。如果玩家出石头，电脑出剪刀，那么玩家获胜。如果玩家出布，电脑出石头，那么玩家获胜。如果玩家出剪刀，电脑出布，那么玩家获胜
    ![图片](../Images/00006.jpg)。如果玩家和电脑选择相同，则游戏视为平局 ![图片](../Images/00007.jpg)。如果有任何其他组合，则玩家失败。这个概述并不复杂；你只需要仔细思考一下。
- en: Finally, to ensure the user the game was not rigged, the computer's choice is
    output. The statement `Press <Enter> to continue` is used to allow the user to
    process the game's conclusion ![](../Images/00008.jpg).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了确保用户游戏没有被操纵，输出电脑的选择。使用语句`按<Enter>键继续`允许用户处理游戏的结论 ![图片](../Images/00008.jpg)。
- en: Hacking the Script
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本破解
- en: You can hack this script by adding a Retry option if the Tie condition is met.
    Also, a best of three or five, where a score is kept, could be fun. I'm happy
    with my one win, so I'll stick with that. And if you aren't satisfied with the
    Rock, Paper, Scissors choice, you can add things like Spock and Lizard (see [http://www.samkass.com/theories/RPSSL.html/](http://www.samkass.com/theories/RPSSL.html/)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足平局条件，你可以通过添加重试选项来破解这个脚本。此外，进行三局或五局最佳，并记录分数，可能会很有趣。我对我的一个胜利感到满意，所以我会坚持这样做。如果你对剪刀石头布的选择不满意，你可以添加像斯波克和蜥蜴（见[http://www.samkass.com/theories/RPSSL.html/](http://www.samkass.com/theories/RPSSL.html/)）这样的东西。
- en: Word Scramble
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单词拼图
- en: Word Scramble
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词拼图
- en: wordScramble.rb
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wordScramble.rb
- en: As I mentioned in "#29 Sudoku Solver" on [Sudoku Solver](../Text/dummy_split_204.html#filepos410291),
    word scramble is a classic game. There is something fascinating about a game that
    can hold your attention while exercising your vocabulary. This classic game can
    be found in newspapers, magazines, and even books dedicated solely to word scrambles.
    But who needs those when you can customize your own game?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[Sudoku Solver](../Text/dummy_split_204.html#filepos410291)上的"#29 数独求解器"中提到的，单词拼图是一款经典游戏。一个能够同时锻炼你的词汇量和吸引你注意力的游戏是非常迷人的。这款经典游戏可以在报纸、杂志甚至仅限于单词拼图的书籍中找到。但当你能定制自己的游戏时，谁还需要那些呢？
- en: The Code
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` unless ARGV[0] and File.exists?(ARGV[0])      puts "\n\nUsage is wordScramble.rb
    <word.file>\n\n"      exit  end  ![](../Images/00002.jpg) tries = 10   words =
    File.readlines(ARGV[0]) ![](../Images/00003.jpg) mystery_word = words[rand(words.size)].chomp  ![](../Images/00004.jpg) scramble_word
    = mystery_word.split(//).sort_by{rand}.join  scramble_word.downcase!   puts "\n\n\nThe
    scrambled word is:  #{scramble_word}"   puts "Guess the word..."   puts "You have
    #{tries} guesses left."  guess = $stdin.gets.chomp.downcase  ![](../Images/00005.jpg) while
    guess =~ /[^Qq]/      if tries == 0          puts "\n\nNice try, but the word
    is: #{mystery_word}."          exit      elsif guess != mystery_word.downcase
             puts "\nYour guess was incorrect.  #{tries-=1} left..."          puts
    "\nThe scrambled word is:  #{scramble_word}."          guess = $stdin.gets.chomp.downcase
         else          puts "\n\n\nYou got it, great job!\n\n"          puts "Press
    <Enter> to continue."          $stdin.gets          exit      end  end`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '` unless ARGV[0] and File.exists?(ARGV[0])      puts "\n\n用法是 wordScramble.rb
    <word.file>\n\n"      exit  end  ![图片](../Images/00002.jpg)` tries = 10   words
    = File.readlines(ARGV[0]) ![图片](../Images/00003.jpg) mystery_word = words[rand(words.size)].chomp
    ![图片](../Images/00004.jpg) scramble_word = mystery_word.split(//).sort_by{rand}.join
     scramble_word.downcase!   puts "\n\n\n打乱的单词是:  #{scramble_word}"   puts "猜猜这个单词..."   puts
    "你还有 #{tries} 次猜测机会。"  guess = $stdin.gets.chomp.downcase ![图片](../Images/00005.jpg) while
    guess =~ /[^Qq]/      if tries == 0          puts "\n\n好尝试，但单词是: #{mystery_word}."
             exit      elsif guess != mystery_word.downcase          puts "\n你的猜测不正确。
     #{tries -= 1} 剩余..."          puts "\n打乱的单词是:  #{scramble_word}。"          guess
    = $stdin.gets.chomp.downcase      else          puts "\n\n\n你猜对了，干得好!\n\n"   
          puts "按<Enter>键继续。"          $stdin.gets          exit      end  end`'
- en: Running the Code
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'You''ll need a word list from which a word can be selected to scramble. The
    dictionary word list is a perfect example: one word per line, as many characters
    as wanted. Just remember that the longer the word is, the higher the difficulty.
    To play, type:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个单词列表，从中可以选择一个单词来打乱。字典单词列表是一个完美的例子：每行一个单词，字符数量不限。只需记住，单词越长，难度越高。要玩这个游戏，请输入：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Results
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How It Works
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'This script is a basic word scramble game. There aren''t any tricks: The only
    objective is to guess the scrambled word. There is a limit to the number of guesses.
    In this script, the user has 10 tries to guess the scrambled word ![](../Images/00002.jpg).
    To get a random word to scramble, the script reads the file passed as the command-line
    argument and saves the contents to `words`. Then a random word is selected and
    stored in `mystery_word`. All of this happens on one line ![](../Images/00003.jpg).
    I''ll break the line down for you. First, a random number is selected from zero
    to `words.size` using the `rand` function. Then that randomly selected element
    of the `words.array` is the word the script will scramble. The word is cleaned
    up with the `chomp` method and, finally, saved into `mystery_word`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是一个基本的单词打乱游戏。没有任何技巧：唯一的目标是猜测打乱的单词。猜测的次数是有限的。在这个脚本中，用户有10次机会猜测打乱的单词 ![图片](../Images/00002.jpg)。为了得到一个随机单词来打乱，脚本读取作为命令行参数传递的文件，并将内容保存到`words`中。然后选择一个随机单词并存储在`mystery_word`中。所有这些都在一行中完成
    ![图片](../Images/00003.jpg)。我将为你分解这一行。首先，使用`rand`函数从0到`words.size`中选择一个随机数。然后，随机选择的`words.array`中的元素就是脚本将要打乱的单词。单词使用`chomp`方法进行清理，最后保存到`mystery_word`中。
- en: Now that a random word has been selected, we can proceed with the chaos. The
    interesting part of this script is figuring out how to mess up the `mystery_word`
    enough so the user is challenged. The way I chose to scramble the word was to
    rely on the `split`, `rand`, `sort_by`, and `join` methods ![](../Images/00004.jpg).
    The `split` method breaks the word apart, then `rand` and `sort_by` scramble the
    word, and `join` puts the pieces back together. The last half of the script is
    devoted to processing the user's guess ![](../Images/00005.jpg). As long as the
    user doesn't type Q to quit, the game will go on. Obviously, if the correct word
    is guessed, the script will congratulate the user and exit. If the guess is incorrect,
    the user will get another chance as long as `tries` is greater than zero.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经随机选择了一个单词，我们可以开始混乱的游戏了。这个脚本的有趣之处在于如何足够地打乱`mystery_word`，使用户感到挑战。我选择打乱单词的方式是依赖于`split`、`rand`、`sort_by`和`join`方法
    ![图片](../Images/00004.jpg)。`split`方法将单词拆分，然后`rand`和`sort_by`打乱单词，最后`join`将碎片重新组合。脚本的最后部分是处理用户的猜测
    ![图片](../Images/00005.jpg)。只要用户没有输入Q来退出，游戏就会继续。显然，如果猜对了正确的单词，脚本将祝贺用户并退出。如果猜测不正确，只要`tries`大于零，用户就会得到另一次机会。
- en: Hangman
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂字游戏
- en: Hangman
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂字游戏
- en: hangman.rb
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hangman.rb
- en: Hangman is another fun word game! Most people know how to play hangman. If a
    user doesn't know how to play, the rules are simple to explain. A word is randomly
    chosen and only the number of characters is known—sort of like *Wheel of Fortune*.
    The user has six tries to figure out the word, or else the man is hanged and game
    lost.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 挂字游戏是另一种有趣的单词游戏！大多数人知道如何玩挂字游戏。如果用户不知道如何玩，规则很简单解释。随机选择一个单词，只知道字符的数量——有点像*幸运轮盘*。用户有六次机会猜出单词，否则人就会被绞死，游戏结束。
- en: The Code
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` unless ARGV[0] and File.exists?(ARGV[0])      puts "\n\nUsage is hangman.rb
    <word.file>\n\n"      exit  end   words = File.readlines(ARGV[0])  mystery_word
    = words[rand(words.size)].chomp  solution = Array.new(mystery_word.length, "-")
     guessed = []  steps = 6  ![](../Images/00002.jpg) while steps > 0 ![](../Images/00003.jpg)  
        puts <<EOM      \n\n\nYou have #{steps} guesses left.      Guessed: #{guessed}
         Word:  #{solution}  EOM      print "Enter a letter or guess the word: "   
      guess = $stdin.gets.downcase.chomp   ![](../Images/00004.jpg)       if guess
    == mystery_word.to_s          puts "You have been pardoned!"          exit   
      end      ![](../Images/00005.jpg)       if guessed.include?(guess)         
    puts "You have already guessed that letter. Try again..."          next ![](../Images/00006.jpg)  
        elsif mystery_word.include?(guess)          puts "The letter was found."   
          mystery_word.each_index do |x|              if mystery_word[x] == guess
    ![](../Images/00007.jpg)                     solution[x] = guess             
    end          end ![](../Images/00008.jpg)       else          puts "Sorry, that
    letter is not correct."      end      guessed << guess      steps -= 1  end   puts
    "\n\n\nOh No!  You were HANGED!"  puts "The word was: #{mystery_word}."`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '` unless ARGV[0] and File.exists?(ARGV[0])      puts "\n\n用法是 hangman.rb <word.file>\n\n"
         exit  end   words = File.readlines(ARGV[0])  mystery_word = words[rand(words.size)].chomp
     solution = Array.new(mystery_word.length, "-")  guessed = []  steps = 6  ![图片](../Images/00002.jpg) while
    steps > 0  ![图片](../Images/00003.jpg)       puts <<EOM      \n\n\n你还有 #{steps}
    次猜测机会。      已猜出的字母：#{guessed}      Word:  #{solution}  EOM      print "输入一个字母或猜出单词:
    "      guess = $stdin.gets.downcase.chomp   ![图片](../Images/00004.jpg)       if
    guess == mystery_word.to_s          puts "你被赦免了！"          exit      end     
    ![图片](../Images/00005.jpg)       if guessed.include?(guess)          puts "你已经猜过那个字母了。再试一次..."
             next ![图片](../Images/00006.jpg)       elsif mystery_word.include?(guess)
             puts "那个字母被找到了。"          mystery_word.each_index do |x|             
    if mystery_word[x] == guess ![图片](../Images/00007.jpg)                     solution[x]
    = guess              end          end ![图片](../Images/00008.jpg)       else   
          puts "对不起，那个字母不正确。"      end      guessed << guess      steps -= 1  end   puts
    "\n\n\n哎呀！  你被吊死了！"  puts "单词是：#{mystery_word}。"`'
- en: Running the Code
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: The hangman script requires one argument to specify the file from which to select
    a word.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 挂人游戏脚本需要一个参数来指定选择单词的文件。
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Results
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`You have 6 guesses left. Guessed: Word:  ---- Enter a letter or guess the
    word: r The letter was found.  You have 5 guesses left. Guessed: r Word:  r---
    Enter a letter or guess the word: s Sorry, that letter is not correct.  You have
    4 guesses left. Guessed: rs Word:  r--- Enter a letter or guess the word: t Sorry,
    that letter is not correct.  You have 3 guesses left. Guessed: rst Word:  r---
    Enter a letter or guess the word: b The letter was found.  You have 2 guesses
    left. Guessed: rstb Word:  r-b- Enter a letter or guess the word: y The letter
    was found.  You have 1 guesses left. Guessed: rstby Word:  r-by Enter a letter
    or guess the word: e Sorry, that letter is not correct.  Oh No!  You were HANGED!
    The word was: ruby.`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`你还有6次猜测机会。已猜出的字母：Word:  ---- 输入一个字母或猜出单词：r 字母被找到了。  你还有5次猜测机会。已猜出的字母：r Word:
     r--- 输入一个字母或猜出单词：s 对不起，那个字母不正确。  你还有4次猜测机会。已猜出的字母：rs Word:  r--- 输入一个字母或猜出单词：t
    对不起，那个字母不正确。  你还有3次猜测机会。已猜出的字母：rst Word:  r--- 输入一个字母或猜出单词：b 字母被找到了。  你还有2次猜测机会。已猜出的字母：rstb
    Word:  r-b- 输入一个字母或猜出单词：y 字母被找到了。  你还有1次猜测机会。已猜出的字母：rstby Word:  r-by 输入一个字母或猜出单词：e
    对不起，那个字母不正确。  哎呀！  你被吊死了！单词是：ruby。`'
- en: How It Works
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: 'The game starts off similarly to "#33 Word Scramble" on [Word Scramble](../Text/dummy_split_230.html#filepos451915):
    The script picks a random word from the word file (passed as a command-line argument).
    `guessed` is used to keep track of the guessed letters and a `solution` array
    is created.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始的方式类似于[Word Scramble](../Text/dummy_split_230.html#filepos451915)中的"#33
    Word Scramble"：脚本从单词文件中随机选择一个单词（作为命令行参数传递）。`guessed`用于跟踪已猜出的字母，并创建一个`solution`数组。
- en: A while loop controls the flow of the program ![](../Images/00002.jpg). The
    user has six guesses to figure out the `mystery_word`. (The six steps represent
    the head, body, two arms, and two legs of the user, in case you were wondering.)
    The game begins by showing the user which letters have been guessed and the blanks
    in the solution, and it prompts the user to enter a letter ![](../Images/00003.jpg).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个while循环控制着程序的流程 ![图片](../Images/00002.jpg)。用户有六次猜测的机会来猜出`mystery_word`。 (这六个步骤代表了用户的头部、身体、两个手臂和两条腿，以防你有所疑问。)
    游戏开始时，会向用户展示已经猜出的字母和解决方案中的空格，并提示用户输入一个字母 ![图片](../Images/00003.jpg)。
- en: If the user types the `mystery_word`, the game is won; that is the first check
    made on the input ![](../Images/00004.jpg). If the user only enters a letter,
    then the script checks to see if the letter is included in the `mystery_word`
    ![](../Images/00005.jpg). If the letter is not found in the `mystery_word`, the
    script tells the user to guess another letter ![](../Images/00006.jpg). If the
    letter is found, then the script begins to work its magic. This is the part of
    the script I find most interesting ![](../Images/00007.jpg).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了 `mystery_word`，则游戏获胜；这是对输入进行的第一次检查 ![图片](../Images/00004.jpg)。如果用户只输入了一个字母，则脚本会检查该字母是否包含在
    `mystery_word` 中 ![图片](../Images/00005.jpg)。如果字母在 `mystery_word` 中未找到，脚本会告诉用户猜测另一个字母
    ![图片](../Images/00006.jpg)。如果找到字母，则脚本开始施展其魔法。这是我找到的最有趣的脚本部分 ![图片](../Images/00007.jpg)。
- en: The method `each_index` is used to iterate through each letter. The reason I
    chose `each_index` as opposed to `each` is that `each` will return the letters
    located at each index. I only want to use the index of each letter and compare
    the letters. You will see why as you read on. The index is used to compare the
    letter guessed and the current letter of the `mystery_word`. If the letter is
    found, then the corresponding index in the solution is set to the letter ![](../Images/00008.jpg).
    This gives the effect of revealing the correctly guessed letters when the solution
    is printed. This method also captures repeated letters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`each_index` 方法用于遍历每个字母。我选择 `each_index` 而不是 `each` 的原因是 `each` 会返回每个索引处的字母。我只想使用每个字母的索引并比较字母。当你继续阅读时，你会明白原因。索引用于比较猜测的字母和
    `mystery_word` 的当前字母。如果找到字母，则将解决方案中的相应索引设置为该字母 ![图片](../Images/00008.jpg)。这会在打印解决方案时揭示正确猜测的字母。此方法还会捕获重复的字母。'
- en: The process of letter-guessing continues until the correct word is guessed or
    the user runs out of turns. Overall, the script is short, but it is so much fun
    to play.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 字母猜测的过程会一直持续，直到猜对正确的单词或者用户用完了机会。总体来说，脚本很短，但玩起来非常有趣。
- en: Pig
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pig
- en: Pig
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pig
- en: pig.rb
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pig.rb
- en: Pig is one of the lesser-known games of our time, but nonetheless, a fun one
    to play. All it requires is a six-sided die. The goal of the game is to reach
    100 points by adding the totals of your throws. You can throw the die as many
    times as you want during your turn, but if you roll a 1, you lose all of the points
    gained during that turn and then your opponent gets a chance to rack up points.
    Pig is a simple game, but it is deceptively difficult to win.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Pig 是我们这个时代不太为人所知的游戏之一，但无论如何，它是一个很有趣的游戏。它只需要一个六面的骰子。游戏的目标是通过添加投掷的总和来达到 100 分。在你的回合中，你可以想投多少次就投多少次，但如果投出
    1 点，你将失去那个回合获得的所有分数，然后你的对手有机会积累分数。Pig 是一个简单的游戏，但它赢得胜利却出奇地困难。
- en: The Code
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) puts "\n\n\n\n\n\n\nWelcome to the game PIG!"  puts
    "\n----INSTRUCTIONS----"  puts "The object of the game is to reach 100 points."
     puts "*** Be careful, if you roll a 1 you lose your ***"  puts "*** turn and
    any points you may have received. ***"  puts "\nGood Luck!"   puts "\n\nPress
    <Enter> to continue..."  gets  ![](../Images/00003.jpg) player1 = 0  player2 =
    0  turn_total = 0  turn = true  d1 = rand(6)+1   puts "\n\n\n\n---Player 1 Roll---"
     puts "Press <Enter> to roll again or ''h'' to hold."  input = gets.chomp.downcase   while
    input != ''q'' ![](../Images/00004.jpg)       unless input == ''h''          if
    turn              puts "\n\n\n\n---Player 1 Roll---"              puts "Player
    1''s total is: #{player1}\n\n"          else              puts "\n\n\n\n---Player
    2 Roll---"              puts "Player 2''s total is: #{player2}\n\n"          end
             d1 = rand(6)+1          puts "You rolled a: #{d1}\n\n"          ![](../Images/00005.jpg)
                if d1 == 1                 puts "****So sorry, you receive no points
    and forfeit your turn.***"               puts "Press <Enter> to continue..."   
               gets               turn_total = 0               input = ''h''     
             next           end          ![](../Images/00006.jpg)             turn_total
    = turn_total+d1           puts "Your total for this turn is: #{turn_total}" ![](../Images/00008.jpg)  
             if turn_total >= 100               puts "You WIN!"               exit
              end                    puts "Press <Enter> to roll again or ''h'' to
    hold."           input = gets.chomp.downcase       else           if turn     
             player1 = player1+turn_total               puts "\n\nPlayer 1''s total
    is #{player1}\n\n" ![](../Images/00007.jpg)                if player1 >= 100   
                   puts "\n\nPlayer 1 wins!\n\n\n"                   exit         
         end               turn = false           else               player2 = player2+turn_total
                  puts "\n\nPlayer 2''s total is #{player2}"  ![](../Images/00007.jpg)  
                 if player2 >= 100                   puts "\n\nPlayer 2 wins!\n\n\n"
                      exit              end              turn = true          end
             turn_total = 0          input = ''other''      end  end`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) puts "\n\n\n\n\n\n\n欢迎来到游戏PIG！"  puts "\n----说明----"
     puts "游戏的目标是达到100分。"  puts "*** 注意，如果你掷出1点，你将失去 ***"  puts "*** 你的回合和你可能获得的任何分数。
    ***"  puts "\n祝你好运！"   puts "\n\n按<Enter>键继续..."  gets  ![](../Images/00003.jpg) player1
    = 0  player2 = 0  turn_total = 0  turn = true  d1 = rand(6)+1   puts "\n\n\n\n---玩家1掷骰子---"
     puts "按<Enter>键再次掷骰子或按''h''键保持。"  input = gets.chomp.downcase   while input !=
    ''q'' ![](../Images/00004.jpg)       unless input == ''h''          if turn   
              puts "\n\n\n\n---玩家1掷骰子---"              puts "玩家1的总分是: #{player1}\n\n"
             else              puts "\n\n\n\n---玩家2掷骰子---"              puts "玩家2的总分是:
    #{player2}\n\n"          end          d1 = rand(6)+1          puts "你掷出了: #{d1}\n\n"
             ![](../Images/00005.jpg)             if d1 == 1                 puts
    "****很抱歉，你没有得分并且失去了你的回合。***"              puts "按<Enter>键继续..."              gets
                  turn_total = 0               input = ''h''               next   
           end          ![](../Images/00006.jpg)             turn_total = turn_total+d1
              puts "你这一轮的总分是: #{turn_total}" ![](../Images/00008.jpg)            if
    turn_total >= 100               puts "你赢了！"               exit           end   
                    puts "按<Enter>键再次掷骰子或按''h''键保持。"           input = gets.chomp.downcase
          else           if turn               player1 = player1+turn_total       
           puts "\n\n玩家1的总分是 #{player1}\n\n" ![](../Images/00007.jpg)            
       if player1 >= 100                   puts "\n\n玩家1赢了！\n\n\n"               
       exit               end               turn = false           else           
       player2 = player2+turn_total               puts "\n\n玩家2的总分是 #{player2}"  ![](../Images/00007.jpg)  
                 if player2 >= 100                   puts "\n\n玩家2赢了！\n\n\n"     
                 exit              end              turn = true          end     
        turn_total = 0          input = ''other''      end  end`'
- en: Running the Code
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The script runs by itself with no arguments. The game is played on one terminal
    with two people taking turns trying to improve their scores. After execution,
    read the instructions and be the first to win:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本无需任何参数即可自动运行。游戏在一台终端上由两个人轮流进行，试图提高自己的得分。执行后，阅读说明并成为第一个获胜的人：
- en: '``**`ruby pig.rb`**``'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby pig.rb`**``'
- en: The Results
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`Welcome to the game PIG!  ----INSTRUCTIONS---- The object of the game is to
    reach 100 points. *** Be careful, if you roll a 1 you lose your *** *** turn and
    any points you may have received. ***  Good Luck!  Press <Enter> to continue...  ---Player
    1 Roll--- Press <Enter> to roll again or ''h'' to hold.   ---Player 1 Roll---
    Player 1''s total is: 0  You rolled a: 6  Your total for this turn is: 6 Press
    <Enter> to roll again or ''h'' to hold.   ---Player 1 Roll--- Player 1''s total
    is: 0 You rolled a: 6  Your total for this turn is: 12 Press <Enter> to roll again
    or ''h'' to hold.   ---Player 1 Roll--- Player 1''s total is: 0  You rolled a:
    4  Your total for this turn is: 16 Press <Enter> to roll again or ''h'' to hold.   ---Player
    1 Roll--- Player 1''s total is: 0  You rolled a: 4  Your total for this turn is:
    20 Press <Enter> to roll again or ''h'' to hold. h   Player 1''s total is 20   ---Player
    2 Roll--- Player 2''s total is: 0  You rolled a: 4  Your total for this turn is:
    4 Press <Enter> to roll again or ''h'' to hold.   ---Player 2 Roll--- Player 2''s
    total is: 0  You rolled a: 1  ****So sorry, you receive no points and forfeit
    your turn.*** Press <Enter> to continue...   Player 2''s total is 4   -----SNIP-----
    (catching back up to player 1 later on in the game)    ---Player 1 Roll--- Player
    1''s total is: 53  You rolled a: 3  Your total for this turn is: 42 Press <Enter>
    to roll again or ''h'' to hold.   ---Player 1 Roll--- Player 1''s total is: 53  You
    rolled a: 5  Your total for this turn is: 47 Press <Enter> to roll again or ''h''
    to hold.   Player 1''s total is 100   Player 1 wins!`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`欢迎来到游戏PIG！  ----说明---- 游戏的目标是达到100分。*** 注意，如果你掷出1，你将失去你的 *** *** 轮次和你可能获得的任何分数。***
    祝你好运！按<Enter>键继续...  ---玩家1掷骰子--- 按下<Enter>键再次掷骰子或按''h''键保持。   ---玩家1掷骰子--- 玩家1的总分是：0  你掷出了：6  你本轮的总分是：6
    按下<Enter>键再次掷骰子或按''h''键保持。   ---玩家1掷骰子--- 玩家1的总分是：0 你掷出了：6  你本轮的总分是：12 按下<Enter>键再次掷骰子或按''h''键保持。   ---玩家1掷骰子---
    玩家1的总分是：0 你掷出了：4  你本轮的总分是：16 按下<Enter>键再次掷骰子或按''h''键保持。   ---玩家1掷骰子--- 玩家1的总分是：0
    你掷出了：4  你本轮的总分是：20 按下<Enter>键再次掷骰子或按''h''键保持。h   玩家1的总分是20   ---玩家2掷骰子--- 玩家2的总分是：0  你掷出了：4  你本轮的总分是：4
    按下<Enter>键再次掷骰子或按''h''键保持。   ---玩家2掷骰子--- 玩家2的总分是：0  你掷出了：1  ****非常抱歉，你得不到任何分数，并且将失去你的轮次。***
    按下<Enter>键继续...   玩家2的总分是4   -----省略----- (在游戏中稍后回到玩家1)    ---玩家1掷骰子--- 玩家1的总分是：53  你掷出了：3  你本轮的总分是：42
    按下<Enter>键再次掷骰子或按''h''键保持。   ---玩家1掷骰子--- 玩家1的总分是：53  你掷出了：5  你本轮的总分是：47 按下<Enter>键再次掷骰子或按''h''键保持。   玩家1的总分是100   玩家1获胜！`'
- en: How It Works
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'As with most games, chance is involved. Whenever chance is involved, there''s
    usually a `rand` statement somewhere to be found in the code. You may be wondering
    how to make a die in Ruby. It''s actually very easy. The following code snippet
    will create the response of a six-sided die: `rand(6)+1`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数游戏一样，游戏中涉及运气。每当涉及运气时，通常在代码中可以找到一个`rand`语句。你可能想知道如何在Ruby中创建一个骰子。实际上非常简单。以下代码片段将创建一个六面骰子的响应：`rand(6)+1`。
- en: The script starts with instructions for those users who aren't familiar with
    Pig ![](../Images/00002.jpg). Next, the variables are initialized ![](../Images/00003.jpg).
    `player1` and `player2` will hold the player totals after each roll has finished.
    `turn_total` will be used to store the individual turn totals. `turn` will be
    used to determine whose roll it is; `player1` will be true and `player2` will
    be false. The last variable, `d1`, is the die we'll be using throughout the game.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本从为不熟悉Pig游戏的用户提供的说明开始 ![图片](../Images/00002.jpg)。接下来，初始化变量 ![图片](../Images/00003.jpg)。`player1`和`player2`将分别存储每个掷骰子结束后的玩家总分。`turn_total`将用于存储单个轮次的总分。`turn`将用于确定轮到哪位玩家掷骰子；`player1`为true，`player2`为false。最后一个变量`d1`是我们将在整个游戏中使用的骰子。
- en: As long as Q isn't entered, the game proceeds, changing turns based on rolling
    a 1 or else holding. If a player presses anything besides h (for hold), the die
    will be rolled ![](../Images/00004.jpg). If the player rolls a 1, then all the
    points for that turn are lost as well as the player's turn ![](../Images/00005.jpg).
    If something other than a 1 is rolled, the die total is added to the turn total
    ![](../Images/00006.jpg). When the player feels like holding, the turn total is
    added to the player's total.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有输入Q，游戏就会继续进行，根据掷出1还是保持来改变轮次。如果玩家按下除'h'（保持）以外的任何键，骰子将被掷出 ![图片](../Images/00004.jpg)。如果玩家掷出1，那么本轮的所有分数都将丢失，以及玩家的轮次
    ![图片](../Images/00005.jpg)。如果掷出的不是1，则骰子的总分将加到轮次总分上 ![图片](../Images/00006.jpg)。当玩家想保持时，轮次总分将加到玩家的总分上。
- en: If the player's total is greater than or equal to 100 points, he or she wins
    the game ![](../Images/00007.jpg). I also added an unrealistic case where a player
    rolls over 100 points in a single turn—highly unlikely, but possible ![](../Images/00008.jpg).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的总分大于或等于100分，他或她将赢得游戏 ![图片](../Images/00007.jpg)。我还添加了一个不切实际的情况，即玩家在一次投掷中超过100分——非常不可能，但有可能
    ![图片](../Images/00008.jpg)。
- en: Hacking the Script
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: You can hack this script to use two dice. Just add a `d2` variable and add `d2`
    to `d1` whenever it is added to the total rolled. Now that you know how to create
    dice, can you recreate more complex dice games like craps?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改这个脚本以使用两个骰子。只需添加一个`d2`变量，并在每次将其加到投掷总数时，将`d2`加到`d1`上。现在你已知如何创建骰子，能否重新创建更复杂的骰子游戏，比如克朗普斯？
