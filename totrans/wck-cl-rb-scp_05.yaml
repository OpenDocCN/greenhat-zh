- en: Chapter 5. GAMES AND LEARNING TOOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![GAMES AND LEARNING TOOLS](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Everyone knows that games are fun—the gaming industry is *huge*. This chapter
    will show you how to design scripts that can be used for amusement, learning,
    and gaming. I find writing scripts that produce games is a lot more interesting
    than writing scripts to parse through firewall logs. But hey, that's just me.
    Read through these and see what you think. The first script is a Sudoku solver,
    and while not a game script, it is guaranteed to find the solution for every Sudoku
    puzzle!
  prefs: []
  type: TYPE_NORMAL
- en: Sudoku Solver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sudoku Solver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: sudoku.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few things you have always been able to count on in your local newspaper.
    One is crossword puzzles, and the other is word scrambles—that is, until the Sudoku
    craze. I find myself occasionally attempting to solve these puzzles, but most
    of the time, I get stuck or mess up. If I can't solve the puzzle, I have to wait
    for the next newspaper to come out the following day, which is frustrating because
    I've usually forgotten about the puzzle by then. To alleviate my frustration,
    I wrote this script. The algorithm comes from a Perl script written by Edmund
    von der Burg ([http://www.ecclestoad.co.uk/](http://www.ecclestoad.co.uk/)).
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` class SudokuSolver      def initialize(puzzle)          @@p = puzzle.split(//)
         end      ![](../Images/00002.jpg)       def solver        h=Hash.new ![](../Images/00003.jpg)  
       81.times do |j|          next if $p[j].to_i!=0 ![](../Images/00004.jpg)    
         80.times do |k| ![](../Images/00005.jpg)            if k/9==j/9 || k%9==j%9
    || k/27==j/27 && k%9/3==j%9/3              temp = $p[k]            else       
          temp = 0            end ![](../Images/00006.jpg)           h[temp] =1   
          end           1.upto(9) do |v|            next if h.has_key?(v.to_s)   
            $p[j]=v.to_s ![](../Images/00007.jpg)           solver          end   
          return $p[j]=0        end             puts "\n\nThe solution is:\n"     
      print "+-----------------------------+\n|" ![](../Images/00008.jpg)       1.upto(81)
    do |x|          print " #{$p[x-1]} "          if x%3==0 and x%9 !=0           
    print "|"          end          if x%9==0 and x%81 !=0            print"|\n|-----------------------------|\n|"
             end          if x%81==0            puts "|"          end             
      end        puts "+-----------------------------+"        return      end   
    end  ![](../Images/00009.jpg) unless ARGV[0].length==81      puts "Your input
    was invalid.  Please try again."      puts "USAGE: ruby sudoku.rb <Sudoku puzzle
    on one line/no spaces with 0''s  being the blanks>"      puts "Example:ruby sudoku.rb
    000201600.....09605000"      exit  end  ![](../Images/00011.jpg) answer = SudokuSolver.new(ARGV[0])   puts
    "\n\n\nSolving puzzle, wait one moment..."  answer.solver`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To solve the Sudoku puzzle, you must enter the original puzzle configuration
    as part of the command-line argument. For each blank, substitute a zero. If the
    puzzle looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](../Images/00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your input would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby sudoku.rb 000700390090500000300240800700900200000000000003007008004026007000005060026001000`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`The solution is: +-----------------------------+ | 5  4  2 | 7  6  8 | 3  9
     1 | |-----------------------------| | 6  9  8 | 5  1  3 | 7  2  4 | |-----------------------------|
    | 3  7  1 | 2  4  9 | 8  5  6 | |-----------------------------| | 7  6  5 | 9
     8  4 | 2  1  3 | |-----------------------------| | 4  8  9 | 1  3  2 | 6  7  5
    | |-----------------------------| | 2  1  3 | 6  5  7 | 9  4  8 | |-----------------------------|
    | 9  5  4 | 3  2  6 | 1  8  7 | |-----------------------------| | 1  3  7 | 8
     9  5 | 4  6  2 | |-----------------------------| | 8  2  6 | 4  7  1 | 5  3  9
    | +-----------------------------+`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script is completely different than every script we've discussed in the
    book thus far, so pay close attention. The main difference is the use of a class
    and methods within the class, instead of linear script progression. To solve the
    Sudoku puzzle, the script needs to call a method recursively. *Recursion* is when
    a method calls itself as a subroutine. To use recursion, you need to first have
    a method to call. To begin dissecting this script, we'll actually start from the
    bottom and jump back up to the top.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, you must supply the Sudoku puzzle as a command-line argument
    when running the script. If you don't supply an 81-character puzzle, the script
    will yell at you and exit ![](../Images/00009.jpg). The first action taken to
    solve the puzzle is initializing a `SudokuSolver` object called `answer` ![](../Images/00011.jpg).
    The puzzle is passed as an initialization parameter and subsequently broken up
    by the `split` method. The `split` method gives us the ability to break the string
    of 81 characters into little pieces for further manipulation. The resulting array
    is stored in the class variable `@@p`. After the object is initialized, `solver`
    is called to solve the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to the top of the script, you will see `solver` defined ![](../Images/00002.jpg).
    First, a hash is created to track which values have been used. Next, we enter
    a loop for 81 iterations, as there are 81 blocks in a Sudoku puzzle ![](../Images/00003.jpg).
    Each index of the array `@@p` is analyzed for further computations as needed.
    If the array element already has a value that is not equal to zero, then the script
    won't waste any time solving for that number—it is already provided. If the array
    element contains a zero, then the script begins a second loop of 80 iterations
    (the total number of blocks in the Sudoku puzzle minus the element we are solving)
    ![](../Images/00004.jpg). After a tricky `if` statement ![](../Images/00005.jpg),
    the script will either leave the zero value alone or set a hash equal to one.
    This `if` statement is very important; it's where most of the magic happens. Based
    on the modulus operations and comparisons, the script is able to determine which
    row needs to be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: The only numbers available to solve the Sudoku puzzle are 1 through 9, so in
    order to keep from violating the Sudoku rules, the hash keeps track of which numbers
    have been used ![](../Images/00006.jpg). If a number has been used for the loop
    spanning the range of 1 through 9, then the next number is called.
  prefs: []
  type: TYPE_NORMAL
- en: Once a number is found that hasn't been used, the script starts its recursion;
    you can see the method `solver` calling itself ![](../Images/00007.jpg). After
    all loops have terminated, the last step is to output the solution. The easy way
    would be to spit out a long string of each element in the array, but frankly,
    that's ugly. I find inputting the original puzzle challenging enough.
  prefs: []
  type: TYPE_NORMAL
- en: Again, using the modulus operators to determine when a new row and column should
    be started, the script outputs a perfect Sudoku puzzle ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Flash Cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flash Cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: flashCards.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flash cards have been the savior of many a cramming student. They can be used
    to memorize historical dates, vocabulary words, foreign languages, and virtually
    anything else worth remembering. If you've never encountered flash cards before,
    I'll give you a quick run down. Traditionally, flash cards are made using both
    sides of a three-by-five index card. You write a question on the front of the
    index card and the answer to that question on the back. Then you can test yourself
    to ace whatever you're studying. This script could be tweaked for either a game
    (think *Jeopardy!*) or learning tool, but we'll focus on the latter option. The
    script will prompt you for a question, and you must provide the right answer,
    or else …
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` unless ARGV[0]      puts "\n\nUsage is flashCards.rb <file>\n\n"      exit
     end   ![](../Images/00002.jpg) flash = []  ![](../Images/00003.jpg) card = Struct.new(:question,
    :answer)   File.open(ARGV[0], "rb").each do |line|      if line =~ /(.*)\s{3,10}(.*)/
    ![](../Images/00004.jpg)       flash << card.new($1.strip, $2.strip)      end
     end  ![](../Images/00005.jpg) flash.replace(flash.sort_by { rand })  ![](../Images/00006.jpg) until
    flash.empty?      drill = flash.pop ![](../Images/00007.jpg)       print "#{drill.question}?
    "      guess = $stdin.gets.chomp       if guess.downcase == drill.answer.downcase
    ![](../Images/00008.jpg)            puts "\n\nCorrect -- The answer is: #{drill.answer}\n\n\n"
         else ![](../Images/00009.jpg)            puts "\n\nWRONG -- The answer is:
    #{drill.answer}\n\n\n"      end  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script requires a flash card file based on the following format, with
    five spaces between the *`Question`* and the *`Answer`*:'
  prefs: []
  type: TYPE_NORMAL
- en: '``*`Question     Answer`*``'
  prefs: []
  type: TYPE_NORMAL
- en: To run the script, supply the flash card file as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script begins prompting the user for the answer to a randomly selected
    question. In this example, I used an English-to-Spanish flash card file. The output
    was:'
  prefs: []
  type: TYPE_NORMAL
- en: '`train? El traino WRONG - The answer is: el tren  orange? La naranja Correct
    - The answer is: la naranja`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script takes the flash card file and opens it for reading ![](../Images/00002.jpg).
    Until this script, we've been using data structures that were already defined,
    such as arrays and hashes. Sometimes you'll find a need to customize your own
    data structure. I used the `Struct` command to create my own data structure, called
    `card` ![](../Images/00003.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*When you are storing the name of a person, you should save the name in a string
    variable. These common data structures are predefined to save programmers time,
    but you can define your own data structures like I have done with `Struct`.*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`card` contains two elements—`question` and `answer`. In order to make and
    collect all the flash cards, the flash card file `infile` is broken down line
    by line. Each flash card is added to an array called `flash` ![](../Images/00004.jpg).
    Once it reaches the end-of-file, the array `flash` has a complete collection of
    cards with questions and answers on them. I love it!'
  prefs: []
  type: TYPE_NORMAL
- en: All of the flash cards have been created—so we're almost ready to start torturing
    quizzing the user. We need to ensure some randomness among the questions, so the
    `rand` function comes on the scene. In combination with the `sort` and `replace`
    methods, `rand` makes the question-asking a bit more chaotic and unpredictable
    ![](../Images/00005.jpg). The number of cards that the array has will determine
    the number of questions asked ![](../Images/00006.jpg). A random card is selected,
    `drill`, and the `question` variable is presented to the user ![](../Images/00007.jpg).
    The user input is read from the standard input at the console and compared to
    `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: If the user's guess is correct, the script congratulates the user and asks another
    question ![](../Images/00008.jpg). However, if more studying is needed and the
    user gets the question wrong, he will see a big *WRONG* followed by the correct
    answer ![](../Images/00009.jpg). You could come up with a different way to indicate
    an incorrect guess—maybe something a bit easier on the ego—but this seemed to
    get the point across.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of tweaks you can make to this script. Some ideas to get you
    thinking include making the number of questions asked a variable or continuing
    to ask questions until 100 percent accuracy is obtained. Finally, the script could
    keep a scorecard to let the user know how well he or she did once all the questions
    had been asked. Flash cards are great, so give it a shot. Who knows, maybe you'll
    start learning another language!
  prefs: []
  type: TYPE_NORMAL
- en: Number-Guessing Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Number-Guessing Game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: guessingGame.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This number-guessing game seems simple enough when you''re a little kid: Someone
    picks a number and you try to guess it. In this script, a computer is doing the
    pseudo-random number generation, which is a lot more unpredictable than your friend
    picking his favorite number. As I wrote this, I got to thinking, "This sounds
    an awful lot like a game adults play—the lottery." How crazy is that? The same
    game that entertained you as a kid is still entertaining as an adult. Although
    the payoff is a lot better in the lottery, the odds are a lot worse. The bottom
    line is that this game is all about chance.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` puts "\nWelcome to the number-guessing game!\n\n\n\n"  print "What difficulty
    level would you like (low, medium, or hard): "  level = gets.chomp  puts "Enter
    ''q'' to quit.\n\n\n\n\n"  min = 1  ![](../Images/00002.jpg) max = case level
         when "medium" then 100      when "hard"   then 1000      else            
      10  end   puts "The magic number is between #{min} and #{max}.\n\n"  magic_number
    = rand(max)+1   print "What is your guess? "  guess = gets.chomp  ![](../Images/00003.jpg) while
    guess =~ /\d/ ![](../Images/00004.jpg)        case guess.to_i          when 0...magic_number
                 puts "Too Low, try again.\n\n"          when magic_number       
          puts "\nYou guessed it!!!\nThe magic number was #{magic_number}.\n\n\n"
                 print "Press the ''enter'' key to continue."              gets   
              exit          else              puts "Too High, try again.\n\n"     
        end      print "What is your guess? "      guess = gets.chomp  end   puts
    "Invalid entry, you lose."`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game doesn''t require any arguments to begin playing. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby guessingGame.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Welcome to the number-guessing game!  What difficulty level would you like
    (low, medium, high): low Enter ''q'' to quit.  The magic number is between 1 and
    10. What is your guess? 7 Too Low, try again.  What is your guess? 9  You guessed
    it!!! The magic number was 9.  Press the ''enter'' key to continue.`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entire script revolves around three variables: `min`, `max`, and `guess`.
    To set the game for play, the script asks for a difficulty-level setting. The
    difficulty level corresponds to the range of numbers the computer will pick from.
    The levels are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: low = 1-10medium = 1-100hard = 1-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After the script asks for the user input for the difficulty level, the response
    is run through a `case` statement ![](../Images/00002.jpg). `case` statements
    are like a bunch of `if` statements on steroids. Depending on the response, the
    script will set the value for `max`. Note that `min` is always set to 1.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the user continues supplying valid guesses, the game will continue
    responding that the guess was either higher or lower than the secret number ![](../Images/00003.jpg).
    Another `case` statement makes returning the appropriate response very easy ![](../Images/00004.jpg).
    If the guess is between 0 and the `magic_number`, then the guess was too low.
    Likewise, if the guess is between the `magic_number` and `max`, then the guess
    is too high. If the `magic_number` is guessed, then the user wins. Unfortunately,
    you won't win any money playing this script.
  prefs: []
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: rps.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I still use Rock, Paper, Scissors whenever there is a big decision involving
    another person that needs an unbiased opinion. I guess I could flip a quarter,
    but Rock, Paper, Scissors is a lot more suspenseful. Seriously though, this game
    is big in some circles. If you didn't know, there are clubs and tournaments to
    support the game. This script will be your practice partner until you make it
    to the big leagues.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) puts "\n\nWelcome to Rock, Paper, Scissors!"  puts
    "This is a game of chance; the computer randomly picks one of three choices."
     puts "\nRock beats Scissors, but is beaten by Paper."  puts "Scissors beat Paper,
    but are beaten by Rock."  puts "Paper beats Rock, but is beaten by Scissors."   puts
    "r for Rock"  puts "s for Scissors"  puts "p for Paper\n"  print "\nEnter one
    of the above to play: "  ![](../Images/00003.jpg) computer = "rsp"[rand(3)].chr
    ![](../Images/00004.jpg) player = $stdin.gets.chomp.downcase  ![](../Images/00005.jpg) case
    [player, computer] ![](../Images/00006.jpg)       when [''p'',''r''], [''s'',''p''],
    [''r'',''s'']      puts "\n\nYou win!" ![](../Images/00007.jpg)       when [''r'',''r''],
    [''p'',''p''], [''s'',''s'']      puts "\n\nYou tied!"  else      puts "\n\nYou
    lose!"  end   puts "The computer chose: #{computer}"  ![](../Images/00008.jpg) puts
    "Press <Enter> to continue."  $stdin.gets`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No command-line arguments are needed to run this script—just pure concentration.
    Simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby rps.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I won this game, but I got lucky. The computer seems to beat me more often
    than not. I probably wouldn''t fare so well at the tournaments. The winning game
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Welcome to Rock, Paper, Scissors! This is a game of chance; the computer randomly
    picks one of three choices.  Rock beats Scissors, but is beaten by Paper. Scissors
    beat Paper, but are beaten by Rock. Paper beats Rock, but is beaten by Scissors.  r
    for Rock s for Scissors p for Paper  Enter one of the above to play: r  You WIN!
    The computer chose: s Press <Enter> to continue.`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step for any game is to output the rules and objective so the user
    has a fair chance of winning ![](../Images/00002.jpg). After that, winning is
    totally up to the user. This script outputs the notation being used and reminds
    the user that Rock, Paper, Scissors is a game of chance. The letters `r`, `p`,
    and `s` are used as a shortcut for playing Rock, Paper, or Scissors. An interesting
    aspect of the script was figuring out how to generate a random play for the computer
    then determining what constituted a win.
  prefs: []
  type: TYPE_NORMAL
- en: To address the random computer play, I used the `rand` method and passed `3`
    as the parameter to let the method know I only wanted one of three options back
    ![](../Images/00003.jpg). To deal with the winning conditions, I needed user input,
    so `player` is used to store the user's play ![](../Images/00004.jpg). Note that
    the user actually makes his choice after the computer has already chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think about the game, there are only three outcomes: win, lose, or draw.
    Likewise, there are only three ways to win and three ways to lose. Instead of
    typing up a separate `if` statement for each outcome, I tried to abstract the
    conditions and consolidate them into a short `case` statement ![](../Images/00005.jpg).
    If the player has Rock and the computer has Scissors, then the player wins. If
    the player has Paper and the computer has Rock, then the player wins. If the player
    has Scissors and the computer has Paper, then the player wins ![](../Images/00006.jpg).
    The game is considered a tie if the player and the computer have the same choice
    ![](../Images/00007.jpg). If there are any other combinations, then the player
    loses. This synopsis isn''t complicated; you just need to think through it.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to ensure the user the game was not rigged, the computer's choice is
    output. The statement `Press <Enter> to continue` is used to allow the user to
    process the game's conclusion ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can hack this script by adding a Retry option if the Tie condition is met.
    Also, a best of three or five, where a score is kept, could be fun. I'm happy
    with my one win, so I'll stick with that. And if you aren't satisfied with the
    Rock, Paper, Scissors choice, you can add things like Spock and Lizard (see [http://www.samkass.com/theories/RPSSL.html/](http://www.samkass.com/theories/RPSSL.html/)).
  prefs: []
  type: TYPE_NORMAL
- en: Word Scramble
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Word Scramble
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: wordScramble.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned in "#29 Sudoku Solver" on [Sudoku Solver](../Text/dummy_split_204.html#filepos410291),
    word scramble is a classic game. There is something fascinating about a game that
    can hold your attention while exercising your vocabulary. This classic game can
    be found in newspapers, magazines, and even books dedicated solely to word scrambles.
    But who needs those when you can customize your own game?
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` unless ARGV[0] and File.exists?(ARGV[0])      puts "\n\nUsage is wordScramble.rb
    <word.file>\n\n"      exit  end  ![](../Images/00002.jpg) tries = 10   words =
    File.readlines(ARGV[0]) ![](../Images/00003.jpg) mystery_word = words[rand(words.size)].chomp  ![](../Images/00004.jpg) scramble_word
    = mystery_word.split(//).sort_by{rand}.join  scramble_word.downcase!   puts "\n\n\nThe
    scrambled word is:  #{scramble_word}"   puts "Guess the word..."   puts "You have
    #{tries} guesses left."  guess = $stdin.gets.chomp.downcase  ![](../Images/00005.jpg) while
    guess =~ /[^Qq]/      if tries == 0          puts "\n\nNice try, but the word
    is: #{mystery_word}."          exit      elsif guess != mystery_word.downcase
             puts "\nYour guess was incorrect.  #{tries-=1} left..."          puts
    "\nThe scrambled word is:  #{scramble_word}."          guess = $stdin.gets.chomp.downcase
         else          puts "\n\n\nYou got it, great job!\n\n"          puts "Press
    <Enter> to continue."          $stdin.gets          exit      end  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ll need a word list from which a word can be selected to scramble. The
    dictionary word list is a perfect example: one word per line, as many characters
    as wanted. Just remember that the longer the word is, the higher the difficulty.
    To play, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script is a basic word scramble game. There aren''t any tricks: The only
    objective is to guess the scrambled word. There is a limit to the number of guesses.
    In this script, the user has 10 tries to guess the scrambled word ![](../Images/00002.jpg).
    To get a random word to scramble, the script reads the file passed as the command-line
    argument and saves the contents to `words`. Then a random word is selected and
    stored in `mystery_word`. All of this happens on one line ![](../Images/00003.jpg).
    I''ll break the line down for you. First, a random number is selected from zero
    to `words.size` using the `rand` function. Then that randomly selected element
    of the `words.array` is the word the script will scramble. The word is cleaned
    up with the `chomp` method and, finally, saved into `mystery_word`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that a random word has been selected, we can proceed with the chaos. The
    interesting part of this script is figuring out how to mess up the `mystery_word`
    enough so the user is challenged. The way I chose to scramble the word was to
    rely on the `split`, `rand`, `sort_by`, and `join` methods ![](../Images/00004.jpg).
    The `split` method breaks the word apart, then `rand` and `sort_by` scramble the
    word, and `join` puts the pieces back together. The last half of the script is
    devoted to processing the user's guess ![](../Images/00005.jpg). As long as the
    user doesn't type Q to quit, the game will go on. Obviously, if the correct word
    is guessed, the script will congratulate the user and exit. If the guess is incorrect,
    the user will get another chance as long as `tries` is greater than zero.
  prefs: []
  type: TYPE_NORMAL
- en: Hangman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hangman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: hangman.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hangman is another fun word game! Most people know how to play hangman. If a
    user doesn't know how to play, the rules are simple to explain. A word is randomly
    chosen and only the number of characters is known—sort of like *Wheel of Fortune*.
    The user has six tries to figure out the word, or else the man is hanged and game
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` unless ARGV[0] and File.exists?(ARGV[0])      puts "\n\nUsage is hangman.rb
    <word.file>\n\n"      exit  end   words = File.readlines(ARGV[0])  mystery_word
    = words[rand(words.size)].chomp  solution = Array.new(mystery_word.length, "-")
     guessed = []  steps = 6  ![](../Images/00002.jpg) while steps > 0 ![](../Images/00003.jpg)  
        puts <<EOM      \n\n\nYou have #{steps} guesses left.      Guessed: #{guessed}
         Word:  #{solution}  EOM      print "Enter a letter or guess the word: "   
      guess = $stdin.gets.downcase.chomp   ![](../Images/00004.jpg)       if guess
    == mystery_word.to_s          puts "You have been pardoned!"          exit   
      end      ![](../Images/00005.jpg)       if guessed.include?(guess)         
    puts "You have already guessed that letter. Try again..."          next ![](../Images/00006.jpg)  
        elsif mystery_word.include?(guess)          puts "The letter was found."   
          mystery_word.each_index do |x|              if mystery_word[x] == guess
    ![](../Images/00007.jpg)                     solution[x] = guess             
    end          end ![](../Images/00008.jpg)       else          puts "Sorry, that
    letter is not correct."      end      guessed << guess      steps -= 1  end   puts
    "\n\n\nOh No!  You were HANGED!"  puts "The word was: #{mystery_word}."`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hangman script requires one argument to specify the file from which to select
    a word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`You have 6 guesses left. Guessed: Word:  ---- Enter a letter or guess the
    word: r The letter was found.  You have 5 guesses left. Guessed: r Word:  r---
    Enter a letter or guess the word: s Sorry, that letter is not correct.  You have
    4 guesses left. Guessed: rs Word:  r--- Enter a letter or guess the word: t Sorry,
    that letter is not correct.  You have 3 guesses left. Guessed: rst Word:  r---
    Enter a letter or guess the word: b The letter was found.  You have 2 guesses
    left. Guessed: rstb Word:  r-b- Enter a letter or guess the word: y The letter
    was found.  You have 1 guesses left. Guessed: rstby Word:  r-by Enter a letter
    or guess the word: e Sorry, that letter is not correct.  Oh No!  You were HANGED!
    The word was: ruby.`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game starts off similarly to "#33 Word Scramble" on [Word Scramble](../Text/dummy_split_230.html#filepos451915):
    The script picks a random word from the word file (passed as a command-line argument).
    `guessed` is used to keep track of the guessed letters and a `solution` array
    is created.'
  prefs: []
  type: TYPE_NORMAL
- en: A while loop controls the flow of the program ![](../Images/00002.jpg). The
    user has six guesses to figure out the `mystery_word`. (The six steps represent
    the head, body, two arms, and two legs of the user, in case you were wondering.)
    The game begins by showing the user which letters have been guessed and the blanks
    in the solution, and it prompts the user to enter a letter ![](../Images/00003.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: If the user types the `mystery_word`, the game is won; that is the first check
    made on the input ![](../Images/00004.jpg). If the user only enters a letter,
    then the script checks to see if the letter is included in the `mystery_word`
    ![](../Images/00005.jpg). If the letter is not found in the `mystery_word`, the
    script tells the user to guess another letter ![](../Images/00006.jpg). If the
    letter is found, then the script begins to work its magic. This is the part of
    the script I find most interesting ![](../Images/00007.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The method `each_index` is used to iterate through each letter. The reason I
    chose `each_index` as opposed to `each` is that `each` will return the letters
    located at each index. I only want to use the index of each letter and compare
    the letters. You will see why as you read on. The index is used to compare the
    letter guessed and the current letter of the `mystery_word`. If the letter is
    found, then the corresponding index in the solution is set to the letter ![](../Images/00008.jpg).
    This gives the effect of revealing the correctly guessed letters when the solution
    is printed. This method also captures repeated letters.
  prefs: []
  type: TYPE_NORMAL
- en: The process of letter-guessing continues until the correct word is guessed or
    the user runs out of turns. Overall, the script is short, but it is so much fun
    to play.
  prefs: []
  type: TYPE_NORMAL
- en: Pig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: pig.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pig is one of the lesser-known games of our time, but nonetheless, a fun one
    to play. All it requires is a six-sided die. The goal of the game is to reach
    100 points by adding the totals of your throws. You can throw the die as many
    times as you want during your turn, but if you roll a 1, you lose all of the points
    gained during that turn and then your opponent gets a chance to rack up points.
    Pig is a simple game, but it is deceptively difficult to win.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) puts "\n\n\n\n\n\n\nWelcome to the game PIG!"  puts
    "\n----INSTRUCTIONS----"  puts "The object of the game is to reach 100 points."
     puts "*** Be careful, if you roll a 1 you lose your ***"  puts "*** turn and
    any points you may have received. ***"  puts "\nGood Luck!"   puts "\n\nPress
    <Enter> to continue..."  gets  ![](../Images/00003.jpg) player1 = 0  player2 =
    0  turn_total = 0  turn = true  d1 = rand(6)+1   puts "\n\n\n\n---Player 1 Roll---"
     puts "Press <Enter> to roll again or ''h'' to hold."  input = gets.chomp.downcase   while
    input != ''q'' ![](../Images/00004.jpg)       unless input == ''h''          if
    turn              puts "\n\n\n\n---Player 1 Roll---"              puts "Player
    1''s total is: #{player1}\n\n"          else              puts "\n\n\n\n---Player
    2 Roll---"              puts "Player 2''s total is: #{player2}\n\n"          end
             d1 = rand(6)+1          puts "You rolled a: #{d1}\n\n"          ![](../Images/00005.jpg)
                if d1 == 1                 puts "****So sorry, you receive no points
    and forfeit your turn.***"               puts "Press <Enter> to continue..."   
               gets               turn_total = 0               input = ''h''     
             next           end          ![](../Images/00006.jpg)             turn_total
    = turn_total+d1           puts "Your total for this turn is: #{turn_total}" ![](../Images/00008.jpg)  
             if turn_total >= 100               puts "You WIN!"               exit
              end                    puts "Press <Enter> to roll again or ''h'' to
    hold."           input = gets.chomp.downcase       else           if turn     
             player1 = player1+turn_total               puts "\n\nPlayer 1''s total
    is #{player1}\n\n" ![](../Images/00007.jpg)                if player1 >= 100   
                   puts "\n\nPlayer 1 wins!\n\n\n"                   exit         
         end               turn = false           else               player2 = player2+turn_total
                  puts "\n\nPlayer 2''s total is #{player2}"  ![](../Images/00007.jpg)  
                 if player2 >= 100                   puts "\n\nPlayer 2 wins!\n\n\n"
                      exit              end              turn = true          end
             turn_total = 0          input = ''other''      end  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script runs by itself with no arguments. The game is played on one terminal
    with two people taking turns trying to improve their scores. After execution,
    read the instructions and be the first to win:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby pig.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Welcome to the game PIG!  ----INSTRUCTIONS---- The object of the game is to
    reach 100 points. *** Be careful, if you roll a 1 you lose your *** *** turn and
    any points you may have received. ***  Good Luck!  Press <Enter> to continue...  ---Player
    1 Roll--- Press <Enter> to roll again or ''h'' to hold.   ---Player 1 Roll---
    Player 1''s total is: 0  You rolled a: 6  Your total for this turn is: 6 Press
    <Enter> to roll again or ''h'' to hold.   ---Player 1 Roll--- Player 1''s total
    is: 0 You rolled a: 6  Your total for this turn is: 12 Press <Enter> to roll again
    or ''h'' to hold.   ---Player 1 Roll--- Player 1''s total is: 0  You rolled a:
    4  Your total for this turn is: 16 Press <Enter> to roll again or ''h'' to hold.   ---Player
    1 Roll--- Player 1''s total is: 0  You rolled a: 4  Your total for this turn is:
    20 Press <Enter> to roll again or ''h'' to hold. h   Player 1''s total is 20   ---Player
    2 Roll--- Player 2''s total is: 0  You rolled a: 4  Your total for this turn is:
    4 Press <Enter> to roll again or ''h'' to hold.   ---Player 2 Roll--- Player 2''s
    total is: 0  You rolled a: 1  ****So sorry, you receive no points and forfeit
    your turn.*** Press <Enter> to continue...   Player 2''s total is 4   -----SNIP-----
    (catching back up to player 1 later on in the game)    ---Player 1 Roll--- Player
    1''s total is: 53  You rolled a: 3  Your total for this turn is: 42 Press <Enter>
    to roll again or ''h'' to hold.   ---Player 1 Roll--- Player 1''s total is: 53  You
    rolled a: 5  Your total for this turn is: 47 Press <Enter> to roll again or ''h''
    to hold.   Player 1''s total is 100   Player 1 wins!`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with most games, chance is involved. Whenever chance is involved, there''s
    usually a `rand` statement somewhere to be found in the code. You may be wondering
    how to make a die in Ruby. It''s actually very easy. The following code snippet
    will create the response of a six-sided die: `rand(6)+1`.'
  prefs: []
  type: TYPE_NORMAL
- en: The script starts with instructions for those users who aren't familiar with
    Pig ![](../Images/00002.jpg). Next, the variables are initialized ![](../Images/00003.jpg).
    `player1` and `player2` will hold the player totals after each roll has finished.
    `turn_total` will be used to store the individual turn totals. `turn` will be
    used to determine whose roll it is; `player1` will be true and `player2` will
    be false. The last variable, `d1`, is the die we'll be using throughout the game.
  prefs: []
  type: TYPE_NORMAL
- en: As long as Q isn't entered, the game proceeds, changing turns based on rolling
    a 1 or else holding. If a player presses anything besides h (for hold), the die
    will be rolled ![](../Images/00004.jpg). If the player rolls a 1, then all the
    points for that turn are lost as well as the player's turn ![](../Images/00005.jpg).
    If something other than a 1 is rolled, the die total is added to the turn total
    ![](../Images/00006.jpg). When the player feels like holding, the turn total is
    added to the player's total.
  prefs: []
  type: TYPE_NORMAL
- en: If the player's total is greater than or equal to 100 points, he or she wins
    the game ![](../Images/00007.jpg). I also added an unrealistic case where a player
    rolls over 100 points in a single turn—highly unlikely, but possible ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can hack this script to use two dice. Just add a `d2` variable and add `d2`
    to `d1` whenever it is added to the total rolled. Now that you know how to create
    dice, can you recreate more complex dice games like craps?
  prefs: []
  type: TYPE_NORMAL
