<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Modules and Mixins"><div class="titlepage"><div><div><h1 class="title"><a id="modules_and_mixins"/>Chapter 12. Modules and Mixins</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id14"/><div class="mediaobject"><a id="I_mediaobject12_d1e14151"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>In Ruby, each class has only one immediate “parent,” though each parent class may have many “children.” By restricting class hierarchies to a single line of descent, Ruby avoids some of the problems that may occur in those programming languages (such as C++) that permit multiple lines of descent. When classes have many parents as well as many children and when their parents and children also have other parents and children, you risk ending up with an impenetrable network (a knotwork?) rather than the neat, well-ordered hierarchy that you may have intended.</p><p>Nevertheless, sometimes it is useful for classes that are not closely related to implement some shared features. For example, a Sword might be a type of Weapon but also a type of Treasure; a PC might be a type of Computer but also a type of Investment; and so on. But, since the classes defining Weapons and Treasures or Computers and Investments descend from different ancestor classes, their class hierarchy gives them no obvious way of sharing data and methods. Ruby’s solution to this problem is provided by modules.<a id="IDX-CHP-12-0001" class="indexterm"/></p><div class="sect1" title="A Module Is Like a Class . . ."><div class="titlepage"><div><div><h1 class="title"><a id="a_module_is_like_a_class"/>A Module Is Like a Class . . .</h1></div></div></div><p>The definition of a module looks very similar to the definition of a class. In fact, modules and classes are closely related; the Module class is the immediate ancestor of the Class class. Just like a class, a module can contain constants, methods, and classes. Here’s a simple module:<a id="IDX-CHP-12-0002" class="indexterm"/><a id="IDX-CHP-12-0003" class="indexterm"/><a id="IDX-CHP-12-0004" class="indexterm"/><a id="IDX-CHP-12-0005" class="indexterm"/><a id="IDX-CHP-12-0006" class="indexterm"/></p><p><span class="emphasis"><em>simple_module.rb</em></span></p><a id="I_programlisting12_d1e14194"/><pre class="programlisting">module MyModule
    REWARD = 100

    def prize
        return "You've won #{REWARD} credits"
    end

end</pre><p>As you can see, this contains a constant, <code class="literal">REWARD</code>, and an <span class="emphasis"><em>instance method</em></span>, <code class="literal">prize</code>.</p></div></div>
<div class="sect1" title="Module Methods"><div class="titlepage"><div><div><h1 class="title"><a id="module_methods"/>Module Methods</h1></div></div></div><p>In addition to instance methods, a module may also have module methods. Just as class methods are prefixed with the name of the class, module methods are prefixed with the name of the module:</p><a id="I_programlisting12_d1e14212"/><pre class="programlisting">def MyModule.lose
    return "Sorry, you didn't win"
end</pre><p>You can call a module’s module methods just as you would call a class’s class methods, using dot notation, like this:</p><a id="I_programlisting12_d1e14216"/><pre class="programlisting">MyModule.lose   #=&gt; "Sorry, you didn't win"</pre><p>But how do you call an instance method? Neither of the following attempts succeeds:</p><a id="I_programlisting12_d1e14220"/><pre class="programlisting">puts( prize )           # Error: undefined local variable or method
puts( MyModule.prize )  # Error: undefined method 'prize'</pre><p>In spite of their similarities, classes possess two major features that modules do not: <span class="emphasis"><em>instances</em></span> and <span class="emphasis"><em>inheritance</em></span>. Classes can have instances (objects created from the class), superclasses (parents), and subclasses (children); modules can have none of these. It is not possible to call an instance method from an instance of a module (a “module object”) for the simple reason that it is impossible to create instances of a module. This explains the errors when you try to call the <code class="literal">prize</code> method in the previous code.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The Module class does have a superclass, namely, Object. However, any named modules that you create do not have superclasses. For a more detailed account of the relationship between modules and classes, see <a class="xref" href="ch12s08.html#digging_deeper-id11" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch12s08.html#digging_deeper-id11" title="Digging Deeper">Digging Deeper</a>.<a id="IDX-CHP-12-0007" class="indexterm"/><a id="IDX-CHP-12-0008" class="indexterm"/><a id="IDX-CHP-12-0009" class="indexterm"/><a id="IDX-CHP-12-0010" class="indexterm"/></p></div><p>That leads me to the next question: If you can’t create an object from a module, what are modules for? This can be answered in two words: <span class="emphasis"><em>namespaces</em></span> and <span class="emphasis"><em>mixins</em></span>. Ruby’s mixins provide a way of dealing with the problem of multiple inheritance. You’ll learn how mixins work shortly. First, though, let’s look at namespaces.</p></div>
<div class="sect1" title="Modules as Namespaces"><div class="titlepage"><div><div><h1 class="title"><a id="modules_as_namespaces"/>Modules as Namespaces</h1></div></div></div><p>You can think of a module as a sort of named “wrapper” around a set of methods, constants, and classes. The various bits of code inside the module share the same “namespace,” so they are all visible to each other but are not visible to code outside the module.</p><p>The Ruby class library defines a number of modules such as <code class="literal">Math</code> and <code class="literal">Kernel</code>. The <code class="literal">Math</code> module contains mathematical methods such as <code class="literal">sqrt</code> to return a square route and constants such as <code class="literal">PI</code>. The <code class="literal">Kernel</code> module contains many of the methods you’ve been using from the outset such as <code class="literal">print</code>, <code class="literal">puts</code>, and <code class="literal">gets</code>.<a id="IDX-CHP-12-0011" class="indexterm"/><a id="IDX-CHP-12-0012" class="indexterm"/></p><p>Let’s assume you have written this module:</p><p><span class="emphasis"><em>modules1.rb</em></span></p><a id="I_programlisting12_d1e14308"/><pre class="programlisting">module MyModule
    GOODMOOD = "happy"
    BADMOOD = "grumpy"

    def greet
        return "I'm #{GOODMOOD}. How are you?"
    end

    def MyModule.greet
        return "I'm #{BADMOOD}. How are you?"
    end
end</pre><p>You’ve already seen how to use a module method such as <code class="literal">MyModule.greet</code>, and you can access the module constants just as you would access class constants, using the scope resolution operator, <code class="literal">::</code> , like this:</p><a id="I_programlisting12_d1e14318"/><pre class="programlisting">puts(MyModule::GOODMOOD)    #=&gt; happy</pre><p>But how can you access the instance method, <code class="literal">greet</code>? This is where mixins enter the picture.</p></div>
<div class="sect1" title="Included Modules, or &#x201C;Mixins&#x201D;"><div class="titlepage"><div><div><h1 class="title"><a id="included_modules_comma_or_lmixinsr"/>Included Modules, or “Mixins”</h1></div></div></div><p>An object can access the instance methods of a module by including that module using the <code class="literal">include</code> method. If you were to include <code class="literal">MyModule</code> in your program, everything inside that module would suddenly pop into existence within the current scope. So, the <code class="literal">greet</code> method of <code class="literal">MyModule</code> will now be accessible:<a id="IDX-CHP-12-0013" class="indexterm"/></p><p><span class="emphasis"><em>modules2.rb</em></span></p><a id="I_programlisting12_d1e14348"/><pre class="programlisting">include MyModule</pre><p>Note that only instance methods are included. In the previous example, the <code class="literal">greet</code> (instance) method has been included, but the <code class="literal">MyModule.greet</code> (module) method has not. As it’s included, the <code class="literal">greet</code> instance method can be used just as though it were a normal instance method within the current scope, whereas the module method, also named <code class="literal">greet</code>, is accessed using dot notation:</p><a id="I_programlisting12_d1e14364"/><pre class="programlisting">puts( greet )            #=&gt; I'm happy. How are you?
puts( MyModule.greet )   #=&gt; I'm grumpy. How are you?</pre><p>The process of including a module is also called <span class="emphasis"><em>mixing in</em></span>, which explains why included modules are often called mixins. When you mix modules into a class definition, any objects created from that class will be able to use the instance methods of the mixed-in module just as though they were defined in the class itself. Here the MyClass class mixes in the <code class="literal">MyModule</code> module:<a id="IDX-CHP-12-0014" class="indexterm"/></p><p><span class="emphasis"><em>modules3.rb</em></span></p><a id="I_programlisting12_d1e14380"/><pre class="programlisting">class MyClass
    include MyModule

    def sayHi
        puts( greet )
    end

end</pre><p>Not only can the methods of this class access the <code class="literal">greet</code> method from <code class="literal">MyModule</code>, but so too can any objects created from the class:</p><a id="I_programlisting12_d1e14390"/><pre class="programlisting">ob = MyClass.new
ob.sayHi          #=&gt; I'm happy. How are you?
puts(ob.greet)    #=&gt; I'm happy. How are you?</pre><p>You can think of modules as discrete code units that may simplify the creation of reusable code libraries. On the other hand, you might be more interested in using modules as an alternative to multiple inheritance.</p><p>Returning to an example that I mentioned at the start of this chapter, let’s assume you have a Sword class that is not only a weapon but also a treasure. Maybe Sword is a descendant of the Weapon class (so it inherits the Weapon’s <code class="literal">deadliness</code> attribute), but it also needs to have the attributes of a Treasure (such as <code class="literal">value</code> and <code class="literal">owner</code>). Moreover, since this happens to be an Elvish Sword, it also requires the attributes of a MagicThing. If you define these attributes inside <code class="literal">Treasure</code> and <code class="literal">MagicThing</code> <span class="emphasis"><em>modules</em></span> rather than Treasure and MagicThing <span class="emphasis"><em>classes</em></span>, the Sword class would be able to include those modules in order to “mix in” their methods or attributes:<a id="IDX-CHP-12-0015" class="indexterm"/></p><p><span class="emphasis"><em>modules4.rb</em></span></p><a id="I_programlisting12_d1e14427"/><pre class="programlisting">module MagicThing
    attr_accessor :power
end

module Treasure
    attr_accessor :value
    attr_accessor :owner
end

class Weapon
    attr_accessor :deadliness
end

class Sword &lt; Weapon        # descend from Weapon
    include Treasure        # mix in Treasure
    include MagicThing      # mix in MagicThing
    attr_accessor :name
end</pre><p>The Sword object now has access to the methods and attributes of the Sword class, of its ancestor class, Weapon, and also of its mixed-in modules, <code class="literal">Treasure</code> and <code class="literal">MagicThing</code>:<a id="IDX-CHP-12-0016" class="indexterm"/></p><a id="I_programlisting12_d1e14442"/><pre class="programlisting">s = Sword.new
s.name = "Excalibur"
s.deadliness = "fatal"
s.value = 1000
s.owner = "Gribbit The Dragon"
s.power = "Glows when Orcs appear"
puts(s.name)            #=&gt; Excalibur
puts(s.deadliness)      #=&gt; fatal
puts(s.value)           #=&gt; 1000
puts(s.owner)           #=&gt; Gribbit The Dragon
puts(s.power)           #=&gt; Glows when Orcs appear</pre><p>Note, incidentally, that any variables that are <span class="emphasis"><em>local</em></span> to the module cannot be accessed from outside the module. This is the case even if a method inside the module tries to access a local variable and that method is invoked by code from outside the module, such as when the module is mixed in through inclusion:</p><p><span class="emphasis"><em>mod_vars.rb</em></span></p><a id="I_programlisting12_d1e14452"/><pre class="programlisting">x = 1             # local to this program

module Foo
    x = 50        # local to module Foo

                  # this can be mixed in but the variable x won't be visible
    def no_bar
        return x
    end

    def bar
         @x = 1000
         return  @x
    end
    puts( "In Foo: x = #{x}" )   # this can access the module-local x
end

include Foo                      # mix in the Foo module</pre><p>When you run this program, the <code class="literal">puts</code> method executes when the module is initialized, and it displays the value of the module-local variable <code class="literal">x</code>:</p><a id="I_programlisting12_d1e14462"/><pre class="programlisting">In Foo: x = 50</pre><p>If you display the <code class="literal">x</code> variable within the main scope of the program, the value of the variable <code class="literal">x</code> local to the main scope of the program is used, <span class="emphasis"><em>not</em></span> the value of the variable <code class="literal">x</code> local to the module:</p><a id="I_programlisting12_d1e14479"/><pre class="programlisting">puts(x)           #=&gt; 1</pre><p>But any attempt to execute the <code class="literal">no_bar</code> method will fail:</p><a id="I_programlisting12_d1e14486"/><pre class="programlisting">puts( no_bar )    # Error: undefined local variable or method 'x'</pre><p>Here the <code class="literal">no_bar</code> method is unable to access either of the local variables named <code class="literal">x</code> even though <code class="literal">x</code> is declared both in the scope of the module (<code class="literal">x = 50</code>) and in the current or “main” scope (<code class="literal">x = 1</code>). But there is no such problem with instance variables. The <code class="literal">bar</code> method is able to return the value of the instance variable <code class="literal">@x</code>:</p><a id="I_programlisting12_d1e14512"/><pre class="programlisting">puts(bar)         #=&gt; 1000</pre><p>A module may have its own instance variables that belong exclusively to the module “object.” These instance variables will be in scope to a module method:</p><p><span class="emphasis"><em>inst_class_vars.rb</em></span></p><a id="I_programlisting12_d1e14519"/><pre class="programlisting">module X
    @instvar = "X's @instvar"

    def self.aaa
        puts(@instvar)
    end
end

X.aaa #=&gt; X's @instvar</pre><p>But instance variables that are referenced in instance objects “belong” to the scope into which that module is included:<a id="IDX-CHP-12-0017" class="indexterm"/></p><a id="I_programlisting12_d1e14528"/><pre class="programlisting">module X
    @instvar = "X's @instvar"
    @anotherinstvar = "X's 2nd @instvar"

        def amethod
             @instvar = 10       # creates @instvar in current scope
             puts(@instvar)
        end
end

include X
p( @instvar )                    #=&gt; nil
amethod                          #=&gt; 10
puts( @instvar )                 #=&gt; 10
@instvar = "hello world"
puts( @instvar )                 #=&gt; "hello world"</pre><p>Class variables are also mixed in, and like instance variables, their values may be reassigned within the current scope:</p><a id="I_programlisting12_d1e14533"/><pre class="programlisting">module X
    @@classvar = "X's @@classvar"
end

include X

puts( @@classvar )         #=&gt; X's @classvar
@@classvar = "bye bye"
puts( @@classvar )         #=&gt; "bye bye"</pre><p>You may obtain an array of instance variable names using the <code class="literal">instance_variables</code> method:<a id="IDX-CHP-12-0018" class="indexterm"/><a id="IDX-CHP-12-0019" class="indexterm"/></p><a id="I_programlisting12_d1e14548"/><pre class="programlisting">p( X.instance_variables )      #=&gt; [:@instvar, @anotherinstvar]
p( self.instance_variables )   #=&gt; [:@instvar]</pre><p>Here, <code class="literal">X.instance_variables</code> returns a list of the instance variables belonging to the X class, while <code class="literal">self.instance_variables</code> returns the instance variables of the current, main, object. The <code class="literal">@instvar</code> variable is different in each case.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In Ruby 1.9, the <code class="literal">instance_variables</code> method returns an array of symbols. In Ruby 1.8, it returns an array of strings.</p></div></div>
<div class="sect1" title="Name Conflicts"><div class="titlepage"><div><div><h1 class="title"><a id="name_conflicts"/>Name Conflicts</h1></div></div></div><p>Module methods (those methods specifically preceded by the module name) can help protect your code from accidental name conflicts. However, no such protection is given by instance methods within modules. Let’s suppose you have two modules—one called <code class="literal">Happy</code> and the other called <code class="literal">Sad</code>. They each contain a module method called <code class="literal">mood</code> and an instance method called <code class="literal">expression</code>.<a id="IDX-CHP-12-0020" class="indexterm"/></p><p><span class="emphasis"><em>happy_sad.rb</em></span></p><a id="I_programlisting12_d1e14592"/><pre class="programlisting">module Happy
    def Happy.mood        # module method
        return "happy"
    end

    def expression        # instance method
        return "smiling"
    end
end
module Sad
    def Sad.mood          # module method
        return "sad"
    end

    def expression        # instance method
        return "frowning"
    end
end</pre><p>Now a class, Person, includes both these modules:</p><a id="I_programlisting12_d1e14596"/><pre class="programlisting">class Person
    include Happy
    include Sad
    attr_accessor :mood

    def initialize
        @mood = Happy.mood
    end
end</pre><p>The <code class="literal">initialize</code> method of the Person class needs to set the value of its <code class="literal">@mood</code> variable using the <code class="literal">mood</code> method from one of the included modules. The fact that they both have a <code class="literal">mood</code> method is no problem; being a module method, <code class="literal">mood</code> must be preceded by the module name so <code class="literal">Happy.mood</code> won’t be confused with <code class="literal">Sad.mood</code>.</p><p>But both the <code class="literal">Happy</code> and <code class="literal">Sad</code> modules also contain a method called <code class="literal">expression</code>. This is an <span class="emphasis"><em>instance</em></span> method, and when both the modules are included in the Person class, the <code class="literal">expression</code> method can be called without any qualification:</p><a id="I_programlisting12_d1e14639"/><pre class="programlisting">p1 = Person.new
puts(p1.expression)</pre><p>Which <code class="literal">expression</code> method is object <code class="literal">p1</code> using here? It turns out that it uses the method last defined. In the example case, that happens to be the method defined in the <code class="literal">Sad</code> module for the simple reason that <code class="literal">Sad</code> is included after <code class="literal">Happy</code>. So, <code class="literal">p1.expression</code> returns “frowning.” If you change the order of inclusion so that <code class="literal">Happy</code> is included after <code class="literal">Sad</code>, the <code class="literal">p1</code> object will use the version of the <code class="literal">expression</code> method defined in the Happy module and will display “smiling.”</p><p>Before getting carried away with the possibilities of creating big, complex modules and mixing them into your classes on a regular basis, bear this potential problem in mind: <span class="emphasis"><em>Included instance methods with the same name will “overwrite” one another</em></span>. The problem may be obvious to spot in my little program here. But it may not be so obvious in a huge application!</p></div>
<div class="sect1" title="Alias Methods"><div class="titlepage"><div><div><h1 class="title"><a id="alias_methods"/>Alias Methods</h1></div></div></div><p>One way of avoiding ambiguity when you use similarly named methods from multiple modules is to <span class="emphasis"><em>alias</em></span> those methods. An alias is a copy of an existing method with a new name. You use the <code class="literal">alias</code> keyword followed by the new name and then the old name:<a id="IDX-CHP-12-0021" class="indexterm"/><a id="IDX-CHP-12-0022" class="indexterm"/></p><a id="I_programlisting12_d1e14698"/><pre class="programlisting">alias  happyexpression expression</pre><p>You can also use <code class="literal">alias</code> to make copies of methods that have been overridden so that you can specifically refer to a version prior to its overridden definition:</p><p><span class="emphasis"><em>alias_methods.rb</em></span></p><a id="I_programlisting12_d1e14708"/><pre class="programlisting">module Happy
    def Happy.mood
        return "happy"
    end

    def expression
        return "smiling"
    end
    alias happyexpression expression
end

module Sad
    def Sad.mood
        return "sad"
    end

    def expression
        return "frowning"
    end
    alias sadexpression expression
end

class Person
    include Happy
    include Sad
    attr_accessor :mood
    def initialize
        @mood = Happy.mood
    end
end

p2 = Person.new
puts(p2.mood)                 #=&gt; happy
puts(p2.expression)           #=&gt; frowning
puts(p2.happyexpression)      #=&gt; smiling
puts(p2.sadexpression)        #=&gt; frowning</pre></div>
<div class="sect1" title="Mix In with Care!"><div class="titlepage"><div><div><h1 class="title"><a id="mix_in_with_care_exclamation"/>Mix In with Care!</h1></div></div></div><p>Although each class can descend from only one superclass, it can mix in numerous modules. In fact, it is perfectly permissible to mix one lot of modules into another lot of modules, then mix those other modules into classes, then place those classes into yet more modules, and so on.<a id="IDX-CHP-12-0023" class="indexterm"/></p><p>The following is an example of some code that subclasses some classes, mixes in some modules, and even subclasses classes from within mixed-in modules. I’ve deliberately simplified the following code to help you see what is happening. For the full horror of a working example, see the sample program, <span class="emphasis"><em>multimods.rb</em></span>, which is supplied in the code archive for this chapter:</p><p><span class="emphasis"><em>multimods.rb</em></span></p><a id="I_programlisting12_d1e14728"/><pre class="programlisting"># This is an example of how NOT to use modules!
module MagicThing                           # module
    class MagicClass                        # class inside module
    end
end

module Treasure                             # module
end

module MetalThing
    include MagicThing                      # mixin
    class Attributes &lt; MagicClass           # subclasses class from mixin
    end
end

include MetalThing                          # mixin
class Weapon &lt; MagicClass                   # subclass class from mixin
    class WeaponAttributes &lt; Attributes     # subclass
    end
end

class Sword &lt; Weapon                        # subclass
    include Treasure                        # mixin
    include MagicThing                      # mixin
end</pre><p>Let me emphasize that the code shown previously and included in the archive is <span class="emphasis"><em>not</em></span> intended as a model to be emulated. Far from it! It is included purely to demonstrate how rapidly a program that makes overenthusiastic use of modules may become difficult to understand and nearly impossible to debug.<a id="IDX-CHP-12-0024" class="indexterm"/><a id="IDX-CHP-12-0025" class="indexterm"/><a id="IDX-CHP-12-0026" class="indexterm"/></p><p>In brief, although modules may, when used with care, help avoid some of the complexities associated with the C++ type of multiple inheritance, they are nonetheless open to misuse. If programmers really want to create convoluted hierarchies of classes with inscrutable dependencies on multiple levels of mixed-in modules, then they can certainly do so. The code in <span class="emphasis"><em>multimods.rb</em></span> shows how easy it is to write an impenetrable program in just a few lines. Imagine what you could do over many thousands of lines of code spread over dozens of code files! Think carefully before mixing in modules.</p></div>
<div class="sect1" title="Including Modules from Files"><div class="titlepage"><div><div><h1 class="title"><a id="including_modules_from_files"/>Including Modules from Files</h1></div></div></div><p>So far, I’ve mixed in modules that have been defined within a single source file. Often it is more useful to define modules in separate files and mix them in as needed. The first thing you have to do in order to use code from another file is to load that file using the <code class="literal">require</code> method, like this:<a id="IDX-CHP-12-0027" class="indexterm"/></p><p><span class="emphasis"><em>require_module.rb</em></span></p><a id="I_programlisting12_d1e14770"/><pre class="programlisting">require( "./testmod.rb" )</pre><p>Optionally, you may omit the file extension:</p><a id="I_programlisting12_d1e14774"/><pre class="programlisting">require( "./testmod" )  # this works too</pre><p>If no path is given, the required file must be in the current directory, on the search path, or in a folder listed in the predefined array variable <code class="literal">$:</code>. You can add a directory to this array variable using the usual array-append method, <code class="literal">&lt;&lt;</code>, in this way:<a id="IDX-CHP-12-0028" class="indexterm"/><a id="IDX-CHP-12-0029" class="indexterm"/><a id="IDX-CHP-12-0030" class="indexterm"/></p><a id="I_programlisting12_d1e14797"/><pre class="programlisting">$: &lt;&lt; "C:/mydir"</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The global variable, <code class="literal">$:</code> (a dollar sign and a colon), contains an array of strings representing the directories that Ruby searches when looking for a loaded or required file.</p></div><p>There is one documented difference in the way <code class="literal">require</code> works in Ruby 1.8 and Ruby 1.9. In Ruby 1.8, the filename is <span class="emphasis"><em>not</em></span> converted to an absolute path, so <code class="literal">require "a"; require "./a"</code> will load <span class="emphasis"><em>a.rb</em></span> twice. In Ruby 1.9, the filename <span class="emphasis"><em>is</em></span> converted to an absolute path, so <code class="literal">require "a"; require "./a"</code> will not load <span class="emphasis"><em>a.rb</em></span> twice.</p><p>In addition, I’ve found that <code class="literal">require</code> may, in at least some versions of Ruby 1.9, fail to load a file from the current directory if you use an unqualified filename as in <code class="literal">require("testmod")</code>. In such cases, a LoadError is thrown. This occurs when the array of searchable directories stored in the global variable, <code class="literal">$:</code>, does not contain the current directory. You can verify whether this is the case by running this code:<a id="IDX-CHP-12-0031" class="indexterm"/></p><p><span class="emphasis"><em>search_dirs.rb</em></span></p><a id="I_programlisting12_d1e14847"/><pre class="programlisting">puts( $: )</pre><p>The search paths will be displayed one per line. There should be a line that displays a single dot (<code class="literal">.</code>) representing the current directory. If that dot is missing, then files in the current directory are not on the search path and cannot be loaded using an unqualified filename.</p><p>To ensure that the file is loaded, I have preceded the filename with a dot to specify the current directory, and this now succeeds: <code class="literal">require( "./testmod" )</code>. Alternatively, you could use the <code class="literal">require_relative</code> method, though this is new to Ruby 1.9 and cannot be used in earlier versions:<a id="IDX-CHP-12-0032" class="indexterm"/><a id="IDX-CHP-12-0033" class="indexterm"/></p><a id="I_programlisting12_d1e14870"/><pre class="programlisting">require_relative( "testmod.rb" )    # Ruby 1.9 only</pre><p>Alternatively, if <code class="literal">$:</code> doesn’t contain the current directory, you could add it. Once this is done, <code class="literal">require</code> will work with the unqualified names of files in the current directory:</p><a id="I_programlisting12_d1e14880"/><pre class="programlisting">$: &lt;&lt; "."              # add current directory to array of search paths
require( "testmod.rb" )</pre><p>The <code class="literal">require</code> method returns a <code class="literal">true</code> value if the specified file is successfully loaded; otherwise, it returns <code class="literal">false</code>. If the file does not exist, it returns a LoadError. If in doubt, you can simply display the result.</p><a id="I_programlisting12_d1e14893"/><pre class="programlisting">puts(require( "testmod.rb" )) #=&gt; true, false or LoadError</pre><p>Any code that would normally be executed when a file is run will be executed when that file is required. So, if the file, <span class="emphasis"><em>testmod.rb</em></span>, contains this code:<a id="IDX-CHP-12-0034" class="indexterm"/></p><p><span class="emphasis"><em>testmod.rb</em></span></p><a id="I_programlisting12_d1e14909"/><pre class="programlisting">def sing
    puts( "Tra-la-la-la-la....")
end

puts( "module loaded")
sing</pre><p>when the <span class="emphasis"><em>require_module.rb</em></span> program is run and it requires <span class="emphasis"><em>testmod.rb</em></span>, this will be displayed:</p><a id="I_programlisting12_d1e14919"/><pre class="programlisting">module loaded
Tra-la-la-la-la....</pre><p>When a module is declared in the required file, it can be mixed in:</p><a id="I_programlisting12_d1e14923"/><pre class="programlisting">require_module2.rb
require( "testmod.rb")
include MyModule       #mix in MyModule declared in testmod.rb</pre><p>Ruby also lets you load a file using the <code class="literal">load</code> method. In most respects, <code class="literal">require</code> and <code class="literal">load</code> can be regarded as interchangeable. But there are a few subtle differences. In particular, <code class="literal">load</code> can take an optional second argument, which, if this is <code class="literal">true</code>, loads and executes the code as an unnamed or anonymous module:<a id="IDX-CHP-12-0035" class="indexterm"/></p><a id="I_programlisting12_d1e14946"/><pre class="programlisting">load( "testmod.rb", true)</pre><p>When the second argument is <code class="literal">true</code>, the file loaded does not introduce the new namespace into the main program, and you will not have access to the module(s) in the loaded file. In that case, the Module methods, constants, and instance methods will <span class="emphasis"><em>not</em></span> be available to your code:</p><p><span class="emphasis"><em>load_module.rb</em></span></p><a id="I_programlisting12_d1e14959"/><pre class="programlisting">load( "testmod.rb", true)

puts( MyModule.greet )   #=&gt;Error:uninitialized constant Object::MyModule
puts(MyModule::GOODMOOD) #=&gt;Error:uninitialized constant Object::MyModule
include MyModule         #=&gt;Error:uninitialized constant Object::MyModule
puts( greet )            #=&gt;Error:undefined local variable or method 'greet'</pre><p>When the second argument to <code class="literal">load</code> is <code class="literal">false</code> or when there is no second argument, however, you <span class="emphasis"><em>will</em></span> have access to modules in the loaded file:</p><p><span class="emphasis"><em>load_module_false.rb</em></span></p><a id="I_programlisting12_d1e14976"/><pre class="programlisting">load( "testmod.rb", false)

puts( MyModule.greet )   #=&gt; I'm grumpy. How are you?
puts(MyModule::GOODMOOD) #=&gt; happy
include MyModule         #=&gt; [success]
puts( greet )            #=&gt; I'm happy. How are you?</pre><p>Note that you must enter the full filename with <code class="literal">load</code> (<span class="emphasis"><em>testmod</em></span> minus the <span class="emphasis"><em>.rb</em></span> extension will not suffice). Another difference between <code class="literal">load</code> and <code class="literal">require</code> is that <code class="literal">require</code> loads a file once only (even if your code requires that file many times), whereas <code class="literal">load</code> causes the specified file to be reloaded each time <code class="literal">load</code> is called. Let’s suppose you have a file, <span class="emphasis"><em>test.rb</em></span>, containing this code:</p><p><span class="emphasis"><em>test.rb</em></span></p><a id="I_programlisting12_d1e15011"/><pre class="programlisting">MyConst = 1
if @a == nil then
    @a = 1
else
    @a += MyConst
end

puts @a</pre><p>You now <span class="emphasis"><em>require</em></span> this file three times:</p><p><span class="emphasis"><em>require_again.rb</em></span></p><a id="I_programlisting12_d1e15021"/><pre class="programlisting">require "./test"
require "./test"
require "./test"</pre><p>This will be the output:</p><a id="I_programlisting12_d1e15025"/><pre class="programlisting">1</pre><p>But if you <span class="emphasis"><em>load</em></span> the file three times . . .</p><p><span class="emphasis"><em>load_again.rb</em></span></p><a id="I_programlisting12_d1e15036"/><pre class="programlisting">load "test.rb"
load "test.rb"
load "test.rb"</pre><p>then this will be the output:</p><a id="I_programlisting12_d1e15040"/><pre class="programlisting">1
./test.rb:1: warning: already initialized constant MyConst
2
./test.rb:1: warning: already initialized constant MyConst
3</pre><div class="sidebar"><a id="digging_deeper-id11"/><p class="title">Digging Deeper</p><p>How exactly is a module related to a class? Here we answer that question, examine some important Ruby modules and find out how to use modules to extend objects.<a id="IDX-CHP-12-0036" class="indexterm"/><a id="IDX-CHP-12-0037" class="indexterm"/><a id="IDX-CHP-12-0038" class="indexterm"/><a id="IDX-CHP-12-0039" class="indexterm"/><a id="IDX-CHP-12-0040" class="indexterm"/></p><p><span class="bolditalic">Modules and Classes</span></p><p>In this chapter, I’ve discussed the <span class="emphasis"><em>behavior</em></span> of a module. Let’s now find out what a module really <span class="emphasis"><em>is</em></span>. It turns out that, as with most other things in Ruby, a module is an object. Each named module is, in fact, an instance of the Module class:</p><p><span class="emphasis"><em>module_inst.rb</em></span></p><a id="I_programlisting12_d1e15086"/><pre class="programlisting">module MyMod
end

puts( MyMod.class )            #=&gt; Module</pre><p>You cannot create descendants of <span class="emphasis"><em>named modules</em></span>, so this is not allowed:</p><a id="I_programlisting12_d1e15093"/><pre class="programlisting">module MyMod
end

module MyOtherMod &lt; MyMod      # You can't do this!
end</pre><p>However, as with other classes, it is permissible to create a descendant of the Module <span class="emphasis"><em>class</em></span>:</p><a id="I_programlisting12_d1e15100"/><pre class="programlisting">class X &lt; Module               # But you can do this
end</pre><p>Indeed, the Class class is itself a descendant of the Module class. It inherits the behavior of Module and adds some important new behavior, notably the ability to create objects. You can verify that Module is the superclass of Class by running the <span class="emphasis"><em>modules_classes.rb</em></span> program, which shows this hierarchy:</p><p><span class="emphasis"><em>modules_classes.rb</em></span></p><a id="I_programlisting12_d1e15111"/><pre class="programlisting">Class
Module            #=&gt; is the superclass of Class
Object            #=&gt; is the superclass of Module
BasicObject       #=&gt; (in Ruby 1.9) is the superclass of Module</pre><p><span class="bolditalic">Predefined Modules</span></p><p>The following modules are built into the Ruby interpreter: <code class="literal">Comparable</code>, <code class="literal">Enumerable</code>, <code class="literal">FileTest</code>, <code class="literal">GC</code>, <code class="literal">Kernel</code>, <code class="literal">Math</code>, <code class="literal">ObjectSpace</code>, <code class="literal">Precision</code>, <code class="literal">Process</code>, and <code class="literal">Signal</code>.</p><p><code class="literal">Comparable</code> is a mixin module that permits the including class to implement comparison operators. The including class must define the <code class="literal">&lt;=&gt;</code> operator, which compares the receiver against another object, returning −1, 0, or +1 depending on whether the receiver is less than, equal to, or greater than the other object.<a id="IDX-CHP-12-0041" class="indexterm"/><a id="IDX-CHP-12-0042" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">Comparable</code> uses <code class="literal">&lt;=&gt;</code> to implement the conventional comparison operators (<code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">==</code>, <code class="literal">&gt;=</code>, and <code class="literal">&gt;</code>) and the method <code class="literal">between?</code>.</p></li><li class="listitem"><p><code class="literal">Enumerable</code> is a mixin module for enumeration. The including class must provide the method <code class="literal">each</code>.<a id="IDX-CHP-12-0043" class="indexterm"/></p></li><li class="listitem"><p><code class="literal">FileTest</code> is a module containing file test functions; its methods can also be accessed from the File class.<a id="IDX-CHP-12-0044" class="indexterm"/></p></li><li class="listitem"><p>The <code class="literal">GC</code> module provides an interface to Ruby’s mark and sweep garbage collection mechanism. Some of the underlying methods are also available via the <code class="literal">ObjectSpace</code> module.<a id="IDX-CHP-12-0045" class="indexterm"/><a id="IDX-CHP-12-0046" class="indexterm"/></p></li><li class="listitem"><p><code class="literal">Kernel</code> is a module included by the Object class; it defines Ruby’s “built-in” methods.<a id="IDX-CHP-12-0047" class="indexterm"/></p></li><li class="listitem"><p><code class="literal">Math</code> is a module containing module functions for basic trigonometric and transcendental functions. It has both “instance methods” and module methods of the same definitions and names.<a id="IDX-CHP-12-0048" class="indexterm"/></p></li><li class="listitem"><p><code class="literal">ObjectSpace</code> is a module that contains routines that interact with the garbage collection facility and allow you to traverse all living objects with an iterator.</p></li><li class="listitem"><p><code class="literal">Precision</code> is a mixin for concrete numeric classes with precision. Here, “precision” means the fineness of approximation of a real number, so this module should not be included into anything that is not a subset of Real (so it should not be included in classes such as Complex or Matrix).<a id="IDX-CHP-12-0049" class="indexterm"/></p></li><li class="listitem"><p><code class="literal">Process</code> is the module for manipulating processes. All its methods are module methods.<a id="IDX-CHP-12-0050" class="indexterm"/></p></li><li class="listitem"><p><code class="literal">Signal</code> is the module for handling signals sent to running processes. The list of available signal names and their interpretation is system dependent.<a id="IDX-CHP-12-0051" class="indexterm"/></p></li></ul></div><p>The following is a brief overview of three of the most commonly used Ruby modules.</p><p><span class="strong"><strong>Kernel</strong></span></p><p>The most important of the predefined modules is <code class="literal">Kernel</code>, which provides many of the “standard” Ruby methods such as <code class="literal">gets</code>, <code class="literal">puts</code>, <code class="literal">print</code>, and <code class="literal">require</code>. In common with much of the Ruby class library, <code class="literal">Kernel</code> is written in the C language. Although <code class="literal">Kernel</code> is, in fact, “built into” the Ruby interpreter, conceptually it can be regarded as a mixed-in module that, just like a normal Ruby mixin, makes its methods directly available to any class that requires it. Since it is mixed into the Object class from which all other Ruby classes descend, the methods of <code class="literal">Kernel</code> are universally accessible.</p><p><span class="strong"><strong>Math</strong></span></p><p>The <code class="literal">Math</code> module’s methods are provided as both “module” and “instance” methods and can therefore be accessed either by mixing <code class="literal">Math</code> into a class or by accessing the module methods “from the outside” by using the module name, a dot, and the method name; you can access constants using a double colon:<a id="IDX-CHP-12-0052" class="indexterm"/><a id="IDX-CHP-12-0053" class="indexterm"/><a id="IDX-CHP-12-0054" class="indexterm"/><a id="IDX-CHP-12-0055" class="indexterm"/><a id="IDX-CHP-12-0056" class="indexterm"/><a id="IDX-CHP-12-0057" class="indexterm"/></p><p><span class="emphasis"><em>math.rb</em></span></p><a id="I_programlisting12_d1e15336"/><pre class="programlisting">puts( Math.sqrt(144) )  #=&gt; 12.0
puts( Math::PI )        #=&gt; 3.141592653589793</pre><p><span class="strong"><strong>Comparable</strong></span></p><p>The <code class="literal">Comparable</code> module provides the neat ability to define your own comparison “operators” as in <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">==</code>, <code class="literal">&gt;=</code>, and <code class="literal">&gt;</code> (strictly speaking, these are methods, but they can be used like the comparison operators in other languages). This is done by mixing the module into your class and defining the <code class="literal">&lt;=&gt;</code> method. You can then specify the criteria for comparing some value from the current object with some other value. You might, for example, compare two integers, the length of two strings, or some more eccentric value such as the position of a string in an array. I’ve opted for this eccentric type of comparison in my example program, <span class="emphasis"><em>compare.rb</em></span>. This uses the index of a string in an array of mythical beings in order to compare the name of one being with that of another. A low index such as <code class="literal">hobbit</code> at index 0 is considered to be “less than” a high index such as <code class="literal">dragon</code> at index 6:<a id="IDX-CHP-12-0058" class="indexterm"/></p><p><span class="emphasis"><em>compare.rb</em></span></p><a id="I_programlisting12_d1e15380"/><pre class="programlisting">class Being
       include Comparable

       BEINGS = ['hobbit','dwarf','elf','orc','giant','oliphant','dragon']

       attr_accessor :name

       def &lt;=&gt; (anOtherName)
               BEINGS.index(@name)&lt;=&gt;BEINGS.index(anOtherName.name)
       end

       def initialize( aName )
               @name = aName
       end

end

elf =  Being.new('elf')
orc = Being.new('orc')
giant = Being.new('giant')

puts( elf &lt; orc )     #=&gt; true
puts( elf &gt; giant )   #=&gt; false</pre><p><span class="bolditalic">Scope Resolution</span></p><p>As with classes, you can use the double-colon scope resolution operator to access constants (including classes and other modules) declared inside modules. For example, let’s suppose you have nested modules and classes, like this:<a id="IDX-CHP-12-0059" class="indexterm"/><a id="IDX-CHP-12-0060" class="indexterm"/><a id="IDX-CHP-12-0061" class="indexterm"/><a id="IDX-CHP-12-0062" class="indexterm"/></p><a id="I_programlisting12_d1e15403"/><pre class="programlisting">module OuterMod
    moduleInnerMod
        class Class1
        end
    end
end</pre><p>You could use the <code class="literal">::</code> operator to access Class1, like this:</p><a id="I_programlisting12_d1e15410"/><pre class="programlisting">OuterMod::InnerMod::Class1</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>See <a class="xref" href="ch02.html" title="Chapter 2. Class Hierarchies, Attributes, and Class Variables">Chapter 2</a> for an introduction to scope resolution of constants within classes.</p></div><p>Each module and class has its own scope, which means that a single constant name might be used in different scopes. This being so, you could use the <code class="literal">::</code> operator to specify a constant within a precise scope:</p><a id="I_programlisting12_d1e15423"/><pre class="programlisting">Scope1::Scope2::Scope3        #...etc</pre><p>If you use this operator at the very start of the constant name, this has the effect of breaking out of the current scope and accessing the “top-level” scope:</p><a id="I_programlisting12_d1e15427"/><pre class="programlisting">::ACONST                      # refers to ACONST at top-level scope</pre><p>The following program provides some examples of the scope operator:</p><p><span class="emphasis"><em>scope_resolution.rb</em></span></p><a id="I_programlisting12_d1e15434"/><pre class="programlisting">ACONST = "hello"                         # This is a top-level constant

module OuterMod
   module InnerMod
      ACONST=10                          # OuterMod::InnerMod::ACONST
      class Class1
         class Class2
            module XYZ
               class ABC
                  ACONST=100             # Deeply nested ACONST
                  def xyz
                     puts( ::ACONST )    # &lt;= This refers to top-level ACONST
                  end
               end
            end
         end
      end
   end
end

puts(OuterMod::InnerMod::ACONST)                             #=&gt; 10
puts(OuterMod::InnerMod::Class1::Class2::XYZ::ABC::ACONST)   #=&gt; 100
ob = OuterMod::InnerMod::Class1::Class2::XYZ::ABC.new
ob.xyz                                                       #=&gt; hello</pre><p><span class="bolditalic">Module Functions</span></p><p>If you want a function to be available both as an instance and as a module method, you can use the <code class="literal">module_function</code> method with a symbol matching the name of an instance method, like this:<a id="IDX-CHP-12-0063" class="indexterm"/><a id="IDX-CHP-12-0064" class="indexterm"/><a id="IDX-CHP-12-0065" class="indexterm"/></p><p><span class="emphasis"><em>module_func.rb</em></span></p><a id="I_programlisting12_d1e15461"/><pre class="programlisting">module MyModule
    def sayHi
        return "hi!"
    end

    def sayGoodbye
        return "Goodbye"
  end

    module_function :sayHi
end</pre><p>The <code class="literal">sayHi</code> method may now be mixed into a class and used as an instance method:</p><a id="I_programlisting12_d1e15468"/><pre class="programlisting">class MyClass
    include MyModule
        def speak
            puts(sayHi)
            puts(sayGoodbye)
        end
end</pre><p>It may be used as a module method, using dot notation:</p><a id="I_programlisting12_d1e15472"/><pre class="programlisting">ob = MyClass.new
ob.speak                   #=&gt; hi!\nGoodbye
puts(MyModule.sayHi)       #=&gt; hi!</pre><p>Since the <code class="literal">sayGoodbye</code> method here is not a module function, it cannot be used in this way:</p><a id="I_programlisting12_d1e15479"/><pre class="programlisting">puts(MyModule.sayGoodbye)  #=&gt; Error: undefined method</pre><p>Ruby uses <code class="literal">module_function</code> in some of its standard modules such as <code class="literal">Math</code> (in the Ruby library file, <span class="emphasis"><em>complex.rb</em></span>) to create “matching pairs” of module and instance methods.</p><p><span class="bolditalic">Extending Objects</span></p><p>You can add the methods of a module to a specific object (rather than to an entire class) using the <code class="literal">extend</code> method, like this:<a id="IDX-CHP-12-0066" class="indexterm"/><a id="IDX-CHP-12-0067" class="indexterm"/><a id="IDX-CHP-12-0068" class="indexterm"/><a id="IDX-CHP-12-0069" class="indexterm"/></p><p><span class="emphasis"><em>extend.rb</em></span></p><a id="I_programlisting12_d1e15522"/><pre class="programlisting">module A
    def method_a
        puts( 'hello from a' )
    end
end

class MyClass
    def mymethod
        puts( 'hello from mymethod of class MyClass' )
    end
end

ob = MyClass.new
ob.mymethod       #=&gt; hello from mymethod of class MyClass
ob.extend(A)</pre><p>Now that the object <code class="literal">ob</code> is extended with the module <code class="literal">A</code>, it can access that module’s instance method, <code class="literal">method_a</code>:</p><a id="I_programlisting12_d1e15535"/><pre class="programlisting">ob.method_a      #=&gt; hello from a</pre><p>You can, in fact, extend an object with several modules all at once. Here, the modules <code class="literal">B</code> and <code class="literal">C</code> extend the object, <code class="literal">ob</code>:</p><a id="I_programlisting12_d1e15548"/><pre class="programlisting">module B
    def method_b
        puts( 'hello from b' )
    end
end

module C
    def mymethod
        puts( 'hello from mymethod of module C' )
    end
end

ob.extend(B, C)
ob.method_b       #=&gt; hello from b
ob.mymethod       #=&gt; hello from mymethod of module C</pre><p>When an object is extended with a module containing a method with the same name as a method in the object’s class, the method from the module replaces the method from the class. So, when <code class="literal">ob</code> is extended with <code class="literal">C</code> and you call <code class="literal">ob.mymethod</code>, the string “hello from mymethod of module <code class="literal">C</code>” will be displayed rather than the “hello from mymethod of class MyClass” that was displayed before <code class="literal">ob</code> was extended with module <code class="literal">C</code>.</p><p><span class="bolditalic">Freezing Objects</span></p><p>You can explicitly prevent an object from being extended it by “freezing” it using the <code class="literal">freeze</code> method:<a id="IDX-CHP-12-0070" class="indexterm"/><a id="IDX-CHP-12-0071" class="indexterm"/><a id="IDX-CHP-12-0072" class="indexterm"/></p><a id="I_programlisting12_d1e15592"/><pre class="programlisting">ob.freeze</pre><p>Any attempt to extend this object further would result in a runtime error:</p><a id="I_programlisting12_d1e15596"/><pre class="programlisting">module D
    def method_d
        puts( 'hello from d' )
    end
end
ob.extend( D ) #=&gt; Error: can't modify frozen object (RuntimeError)</pre><p>To avoid such an error, you can use the <code class="literal">frozen?</code> method to test whether an object has been frozen:<a id="IDX-CHP-12-0073" class="indexterm"/></p><a id="I_programlisting12_d1e15607"/><pre class="programlisting">if !(ob.frozen?)
    ob.extend( D )
    ob.method_d
else
    puts( "Can't extend a frozen object" )
end</pre></div></div></body></html>