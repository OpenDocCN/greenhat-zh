<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page309"/><img src="../images/333-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="app2"/><a href="toc.html#app2"><b>REVIEW OF SNMP</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">This appendix is supplied for those who would like additional details or background information on SNMP.</p>&#13;
<p class="noindent">In this appendix, we will cover the following topics:</p>&#13;
<ul>&#13;
<li>Why SNMP</li>&#13;
<li>Agents and managers</li>&#13;
<li>Namespace, grammar, and protocol</li>&#13;
<li>The MIB</li>&#13;
<li>The OID</li>&#13;
<li>MIB-2</li>&#13;
<li>The SMI</li>&#13;
<li>The SNMP protocol</li>&#13;
<li>SNMPv1, SNMPv2, and SNMPv3</li>&#13;
<li>SNMP data types</li>&#13;
<li>Defining new types</li>&#13;
<li>Structure of an MIB file</li>&#13;
</ul>&#13;
<p class="secl"><a id="app2.1"/><a href="toc.html#app2.1"><b>Why SNMP?</b></a></p>&#13;
<p class="noindent"><a id="page310"/>In the early 1970s, computers and their I/O devices were large enough to need air-conditioned rooms of their own. Most large companies performed their computing tasks on stand-alone systems. It wasn’t hard to tell when something went wrong—an error would print on the system console, and the front panel lights would stop blinking.</p>&#13;
<p class="indent">Today, even small technology companies have a server room with racks of computers and network appliances from multiple vendors, including switches, routers, print servers, webservers, RAID servers, and so forth. Network printers are distributed at convenient locations around the site, and each desk has a desktop or laptop computer. In fact, high-tech firms typically have more computers than employees.</p>&#13;
<p class="indent">Unlike those large computers of yore, the failure of any single component in this network of devices is not so easy to detect. IT managers need some form of automation to help them manage all these devices.</p>&#13;
<p class="indent">The automation may be as simple as a roll-your-own script that performs periodic ping sweeps, but larger networks are likely to rely on a Network Management System (NMS) that uses SNMP, such as Hewlett Packard’s OpenView. Such a system can tell much more than when a device breaks down. It can record performance statistics, keep a restart history, and maintain a log of notifications sent from the devices themselves about impending problems. Devices may report excessive packet drops or retransmissions; connectivity failures; a fan running slowly or a CPU running too hot; excessive CPU, memory, or disk utilization; as well as system restarts.</p>&#13;
<p class="secl"><a id="app2.2"/><a href="toc.html#app2.2"><b>Agents and Managers</b></a></p>&#13;
<p class="noindent">The managed devices (routers, switches, web hosts, desktop computers, network printers, and so on) each run a server process (daemon) called an SNMP agent. This <i>agent</i> listens on a particular UDP port (usually, but not always, port 161) for read (GET) and write (SET) commands. It’s the agent’s responsibility to fetch the requested data and return it. This agent, as well as other monitoring software on the device, may also send spontaneous notifications called <i>traps</i> or <i>informs</i> to one or more configured target systems.</p>&#13;
<p class="indent">Management applications (<i>managers</i>) poll the agents for information. They may keep historical information, generate reports, or create graphical maps of the devices in your network. Some management applications are just simple command-line tools (like the snmpwalk, snmpget, and snmpset commands supplied with Net-SNMP).</p>&#13;
<p class="secl"><a id="app2.3"/><a href="toc.html#app2.3"><b>Namespace, Grammar, and Protocol</b></a></p>&#13;
<p class="noindent">SNMP stands for Simple Network Management Protocol, but it is actually more than just a protocol—it’s a way of naming data, a grammar for describing data, and a protocol for exchanging data over a network. These components are called the <i>MIB</i> (the naming scheme), <i>SMI</i> (the grammar) and the <i>SNMP protocol</i>. The RFCs that describe SNMP include a common set of information useful in managing networked devices. This is called called <i>MIB-2</i> (it took two tries to get it right). We’ll be discussing more about MIB-2 later.</p>&#13;
<p class="secl"><a id="app2.4"/><a href="toc.html#app2.4"><b>The MIB</b></a></p>&#13;
<p class="noindent"><a id="page311"/>MIB stands for <i>Management Information Base.</i> That’s a mouthful, but you can just think of it as a hierarchical naming scheme for a virtual database. This is a “virtual” database because the data may not exist anywhere in storage until the agent receives a request to read the data. When asked for an object (think of this as a field in a record in the database) the agent retrieves the information and returns it in a process that may involve getting multiple pieces of information from the managed system and computing the value to be returned. (You might think of this as a just-in-time database.) The very act of requesting a piece of information may trigger the creation of the value.</p>&#13;
<p class="indent">Although there is one universal addressing scheme, we break it down into subdivisions, which we also call MIBs. Normally, when people use the word <i>MIB,</i> they are referring not to the overall namespace, but to one of these subdivisions. MIB-2 is one of them, and many others are defined by different groups for different purposes. Some are produced by standards groups, while others are defined by private companies to describe proprietary data furnished by their networked products. (In Chapter 14 we describe how you can define a private MIB for your own appliance and find a place for it in the namespace.)</p>&#13;
<p class="secl"><a id="app2.5"/><a href="toc.html#app2.5"><b>The OID</b></a></p>&#13;
<p class="noindent">Every object in every MIB has an object identifier (OID). An <i>OID</i> is a unique name consisting of a sequence of decimal digits separated by periods, or dots, like this:</p>&#13;
<p class="ex">.1.3.6.1.2.1.1.2.0</p>&#13;
<p class="indent">This name represents the object’s location in the namespace. The first dot represents the root of the tree, and each number represents a <i>node</i> (the base of a branch) in the tree. Everything nameable in SNMP is located somewhere in this OID tree, and every name (OID) contains the entire path to that object from the root of the tree.</p>&#13;
<p class="indent">This may look strange at first, but it works in the same way as the Unix filesystem, with which you should be familiar. Paths to files start at root, indicated by an initial slash (/), proceed through a number of named nodes <i>(directories)</i> separated by more slashes, and end with the name of the file itself.</p>&#13;
<p class="indent">Let’s take the example of a file on a Unix filesystem:</p>&#13;
<p class="ex">/usr/local/bin/myprog</p>&#13;
<p class="indent">If we use a dot to separate directories instead of a slash, the path to the file would look like this:</p>&#13;
<p class="ex">.usr.local.bin.myprog</p>&#13;
<p class="indent"><a id="page312"/>Suppose the following table defined a map between the directory names and a set of numbers:</p>&#13;
<p class="imgc"><img src="../images/336-1.jpg" alt=""/></p>&#13;
<p class="indent">If we use the numbers in place of the names, the path would look like this:</p>&#13;
<p class="ex">.1.3.6.1</p>&#13;
<p class="indent">Figure B-1 shows part of the OID tree (or namespace). Note that some nodes in the tree are named for organizations: ISO is the International Standards Organization, and DOD is the US Department of Defense. (The DOD is in this structure because it was instrumental in the creation of DARPANet, which originally consisted of a four-computer network. By 1972, DARPANet had grown to a network of 37 computers and was renamed ARPANet, which led to today’s Internet. End of history lesson.)</p>&#13;
<p class="imgc"><img src="../images/336-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure B-1: The OID tree</i></p>&#13;
<p class="indent">The Internet Assigned Numbers Authority (IANA) is responsible for assigning numbers to companies and organizations under the <i>enterprises node</i>, giving the company or organization the authority to administer the OIDs in their own subtrees.</p>&#13;
<p class="indent"><a id="page313"/>The part of the tree that we’re most interested in is under .1.3.6.1 (.iso.org .dod.internet). Beneath this node are the mgmt.mib-2 (.1.3.6.1.2.1) subtree and the private.enterprises (.1.3.6.1.4.1) subtree. MIB-2 is the common set of objects that we mentioned earlier; it is supported by all networked devices that are manageable by SNMP. The enterprises OID is where organizations register their private MIBs. (For more on this topic, see Chapter 14.)</p>&#13;
<p class="secl"><a id="app2.6"/><a href="toc.html#app2.6"><b>MIB-2</b></a></p>&#13;
<p class="noindent">MIB-2, defined in RFC 1213,<sup>1</sup> describes a core set of information that is helpful for managing networked devices. MIB-2 is organized into the ten groups shown below. Not all groups are supported on all networked devices, but you can generally expect to find most of them.</p>&#13;
<p class="noindent1"><b>System</b></p>&#13;
<p class="bl">This group contains objects such as sysDescr (a printable description of the operating system, hardware, networking software, etc.), sysContact (typically the email address of the person administering this system), sysLocation (a printable description of where the system is located), and sysObjectID (an OID that can be used to determine the type of device).</p>&#13;
<p class="noindent1"><b>Interfaces</b></p>&#13;
<p class="bl">This group is a table describing the network interfaces available on the system. The interfaces table contains information on the speed of each interface and the activity on the interface (octets in and out). By polling the in and out octets periodically, you can tell what percent of the bandwidth available in the interface is being used. This can help you monitor the capacity of routers in a network.</p>&#13;
<p class="noindent1"><b>AT</b></p>&#13;
<p class="bl">This is the Address Translation group. MIB-2 deprecates this group and includes it only for compatibility with devices implementing MIB-1. You should ignore this group unless you have a particular interest in SNMP history.</p>&#13;
<p class="noindent1"><b>IP</b></p>&#13;
<p class="bl">This group includes information related to the IP (network) layer, including ipAddrTable (IP Address Table), which describes the IP address of the interfaces available on the system.</p>&#13;
<p class="noindent1"><b>ICMP</b></p>&#13;
<p class="bl">This group includes various Internet Control Message Protocol (ICMP) statistics.</p>&#13;
<p class="noindent1"><b>TCP</b></p>&#13;
<p class="bl">This group includes various TCP layer statistics, including the tcpConnTable (TCP Connection Table) describing the current TCP connections between this and other systems in the network. This table is often used in network discovery. Once you have the address of this system, you can find out the addresses of other systems that are in contact with it.</p>&#13;
<p class="noindent1"><b>UDP</b></p>&#13;
<p class="bl">This group includes various User Datagram Protocol (UDP) datagram statistics.</p>&#13;
<p class="noindent1"><a id="page314"/><b>EGP</b></p>&#13;
<p class="bl">This group contains Exterior Gateway Protocol (EGP) statistics for those systems supporting the EGP protocol.</p>&#13;
<p class="noindent1"><b>Transmission</b></p>&#13;
<p class="bl">This group contains information related to managing transmission media.</p>&#13;
<p class="noindent1"><b>SNMP</b></p>&#13;
<p class="bl">This group includes various statistics related to the SNMP protocol, itself.</p>&#13;
<p class="secl"><a id="app2.7"/><a href="toc.html#app2.7"><b>The SMI</b></a></p>&#13;
<p class="noindent">MIBs are described using a grammar defined by the Structure of Management Information (SMI), which is a subset of Abstract Syntax Notation One (ASN.1). ASN.1 was created to allow description of data in a way independent of machine architecture (for example, no assumptions about endian-ness or word size). The SNMP SMI adopted a subset of the object types definable under ASN.1 and then simplified the notation.</p>&#13;
<p class="indent">All you really need to know about all this is how to read and write the notation used to describe a MIB. This is best accomplished with minimal notation definitions illustrated by examples. You can create a new MIB largely by cutting and pasting from other MIBs.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>We’ve attempted to keep our discussion of MIBs as simple as possible. For more in-depth coverage, pick up a copy of</i> Understanding SNMP MIBs <i>by David Perkins and Evan McGinnis (Prentice Hall, 1996).</i></p>&#13;
<p class="indent1">Here is an example of an object definition using the grammar described in the SMI:</p>&#13;
<p class="imgl"><img src="../images/338-1.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page315"/>The ::= reads <i>is defined as</i>, and {mib-2 1} means that if mib-2 is .1.3.6.1.2.1, then system is .1.3.6.1.2.1.1. Therefore, sysDescr is .1.3.6.1.2.1.1.1. Each definition describes a single step in the OID tree.</p>&#13;
<p class="indent">Note that some object identifiers simply describe nodes in the tree structure and others describe objects you may actually read (leaf nodes). These are like directories and files in a filesystem. In fact, when you try to read sysDescr, you must ask for .1.3.6.1.4.1.1.1.0. This is where we diverge a bit from the filesystem analogy. The ending zero says you are retrieving an <i>instance</i> of the object. Scalar object instances (scalars are just stand-alone objects not in a table) are always .0 (dot zero). In object-oriented terminology, it’s like .1.3.6.1.2.1.1.1 is the <i>class</i>, while .0 describes an object that is an instance of the class.</p>&#13;
<p class="indent">This may make more sense if you think of objects as fields in a table structure that must be retrieved by a row index. The table row number would replace the zero. For example, ifDescr is a field in a table whose rows each describe information about a particular network interface on the machine. Another node under mib-2, interfaces, is described as</p>&#13;
<p class="ex">interfaces OBJECT IDENTIFIER ::= { mib-2 2 }</p>&#13;
<p class="indent">If you retrieved the ifDescr field for the first two interfaces on a system, you might get this:</p>&#13;
<p class="ex">interfaces.ifTable.ifEntry.ifDescr.1 = lo<br/>interfaces.ifTable.ifEntry.ifDescr.2 = eth0</p>&#13;
<p class="indent">Contrast this with what you might retrieve when asking for sysDescr:</p>&#13;
<p class="ex">system.sysDescr.0 = Linux localhost.localdomain 2.4.18-27.8.0 #1 Fri Mar 14 06:45:49 EST 2003 i686</p>&#13;
<p class="indent">The .1 and .2 at the end of the ifDescr OIDs indicate the table row from which they were retrieved. In SNMP table rows are numbered from 1, which leaves 0 to indicate a scalar.</p>&#13;
<p class="indent">The SMI description of a MIB is normally distributed in a <i>MIB file.</i> This is a text file containing the unambiguous description of a portion of the universal MIB.</p>&#13;
<p class="indent">Sometimes descriptions of individual tables are placed in separate files. Other files just contain common objects or definitions, such as textual conventions, used by a set of other MIB files. Generally, a private MIB for a particular product is described in a single file or a small set of files, importing types and conventions as needed from other files, much like the use of the #include statement in the C language.</p>&#13;
<p class="indent">The MIB file is used as a formal definition of the MIB for humans, but it is also used programmatically to interpret SNMP responses for display to human beings. (We’ll see this below.) MIB files, therefore, must be as syntactically correct as any computer program. There are MIB compilers and checkers (the equivalent of the lint program for C) to help verify the correctness of a MIB file. (We discuss this further in Chapter 14, where we cover the creation and validation of our own MIB.)</p>&#13;
<p class="secl"><a id="app2.8"/><a href="toc.html#app2.8"><b>The SNMP Protocol</b></a></p>&#13;
<p class="noindent"><a id="page316"/>Although worthy of a chapter all its own, we can understand most of what we need to know about the SNMP protocol from the Protocol Data Units (PDUs) it defines and their uses.</p>&#13;
<p class="secs"><a id="app2.9"/><a href="toc.html#app2.9"><i><b>The Basic Commands: GET, SET, GETNEXT</b></i></a></p>&#13;
<p class="noindent">The SNMP protocol is used to exchange information between managed systems and the applications written to manage them. Managed systems host a daemon called an <i>agent,</i> usually named snmpd, which provides the ability to read information from or write information to one or more MIBs. The GET, SET, and GETNEXT PDUs are used to read from, write to, and walk a MIB.</p>&#13;
<p class="secs"><a id="app2.10"/><a href="toc.html#app2.10"><i><b>Walking a MIB with GETNEXT</b></i></a></p>&#13;
<p class="noindent">GETNEXT allows you to name one object and ask the agent to return the OID and value of the next object in the MIB tree. <i>Walking a MIB</i> means starting at some point in the OID tree and traversing the entire subtree below it with repeated use of the GETNEXT command. The walk is finished when the OID returned is not within the subtree defined by the first OID. An application can find out which MIBs are supported on a managed system by walking the entire MIB tree in this way.</p>&#13;
<p class="secs"><a id="app2.11"/><a href="toc.html#app2.11"><i><b>Traps and Informs</b></i></a></p>&#13;
<p class="noindent">Managed systems can also spontaneously send information to a configured target-management node, a process called sending an SNMP <i>trap</i> or <i>inform.</i> A trap is sent toward a target system, but the sender never knows if it got there. An inform is an improvement over a trap because it expects a reply from the receiver; it can be retried if the reply is not received in a reasonable amount of time.</p>&#13;
<p class="secs"><a id="app2.12"/><a href="toc.html#app2.12"><i><b>Command-Line Tools: Examples</b></i></a></p>&#13;
<p class="noindent">Let’s look at some examples of using command-line tools that use the SNMP PDUs we have just discussed to achieve their function. These commands are supplied as part of the Net-SNMP package (<a href="http://net-snmp.sourceforge.net/">http://net-snmp.sourceforge.net</a>), which we use throughout the SNMP chapters in this book.</p>&#13;
<p class="indent">To retrieve the sysDescr field shown in the previous section, you might issue the command</p>&#13;
<p class="ex">snmpget -c public 10.1.1.21 .1.3.6.1.2.1.1.1.0</p>&#13;
<p class="indent"><a id="page317"/>This asks for the instance of the sysDescr object from the system whose IP address is 10.1.1.21, using the community name public (think of this as a password). As you can guess from its name, the snmpget command generates an SNMP GET PDU.</p>&#13;
<p class="indent">Now let’s walk a subtree. The snmpwalk command uses a series of GETNEXT PDUs. If you issue the following command to retrieve the interface table from a system:</p>&#13;
<p class="ex">snmpwalk -c public 10.1.1.21 .1.3.6.1.2.1.2</p>&#13;
<p class="indent">This is what you might get back:</p>&#13;
<p class="imgl"><img src="../images/341-1.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page318"/>This output is a little awkward to read because it is a depth-first walk; that is, it walks down each column before going back to row one and starting down the next column. This is a result of the lexical ordering of the OIDs. For example, since ifDescr is ifEntry.1 and ifType is ifEntry.2, you see all ifDescr fields before any ifType fields.</p>&#13;
<div class="box">&#13;
<p class="bo"><b>KNOWING AN APPLIANCE BY ITS MIBS</b></p>&#13;
<p class="noindent">Walking can often identify the type of a machine by the MIBs it supports. For example, one of the authors was once assigned an IP address for a new workstation and found that someone else was already using this address. Since he had been assigned this address through proper channels, he assumed someone else was invalidly using it. He turned off his system and used another system to read system.sysContact from the offending system; this should have been set to the contact information for the administrator for that node, but it was not. He then tried walking all the MIBs supported by that system and found that it supported the printer MIB. Hmm . . . As it turned out, he had been incorrectly given the IP address of the department’s printer!</p>&#13;
</div>&#13;
<p class="secl"><a id="app2.13"/><a href="toc.html#app2.13"><b>SNMPv1, SNMPv2, and SNMPv3</b></a></p>&#13;
<p class="noindent">There are three main variants of SNMP. The original, SNMPv1 (version 1), is the simplest, but it has some drawbacks that newer versions seek to remedy. Its shortcomings include:</p>&#13;
<ul>&#13;
<li>No support for integers larger than 32 bits.</li>&#13;
<li>No means to ask for bulk data (each object must be asked for by name).</li>&#13;
<li>No mechanism to ensure that a trap reaches its destination.</li>&#13;
<li>Security/authentication is accomplished using community names, which are like passwords, but are transmitted on the network in the clear (that is, unencrypted).</li>&#13;
</ul>&#13;
<p class="indent">SNMPv2c (community-based SNMPv2) addressed the first three of these problems, but reaching an agreement on a new security mechanism proved more difficult, so SNMPv2c still relies on community names for authentication. SNMPv2c includes 64-bit integers, the GETBULK command, and introduces informs, which are confirmed traps.</p>&#13;
<p class="indent">SNMPv3 replaces the community-name authentication mechanism with more secure authentication and encryption, but in-depth discussion of it is beyond the scope of this book.</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>SNMPv1 has been moved to “historical” status, but many applications used by IT organizations still use it. Your network appliance may need to speak SNMPv1 for compatibility with these older applications. Expect, however, that in the not-too-distant future, some of your customers will want to disable the older, less secure versions of SNMP.</i></p>&#13;
<p class="secl"><a id="app2.14"/><a href="toc.html#app2.14"><b>SNMP Data Types</b></a></p>&#13;
<p class="noindent"><a id="page319"/>SNMP data types are a subset of ASN.1 types. A complete description of the SNMP data types and their uses is beyond the scope of this brief introduction, but this section is a summary of the major types. SNMP defines three kinds of data types: primitive, defined, and constructor. We won’t dwell on the differences here, other than to say primitives are the basic types, defined types have special meanings but have underlying primitive types, and constructor types are the tables we will discuss below. Although it may look a little strange, we’ll try to stay consistent here with SNMP’s standard of using all capital letters in the names of primitive types, but just initial capitals for the defined types.</p>&#13;
<p class="seca"><b>INTEGER</b></p>&#13;
<p class="bl">An INTEGER may be positive or negative. Its values may be enumerated, a range of legal values specified in the form of (lowValue..highValue), or a fixed size (e.g., Size(4)). In SNMPv2 INTEGER becomes Integer32, explicitly indicating the size as 32 bits. SNMPv2 also adds an Unsigned32 type for a 32-bit integer of only positive values.</p>&#13;
<p class="seca"><b>Gauge</b></p>&#13;
<p class="bl">Gauges are integers that take only non-negative values and whose values rise or fall within a specified range (e.g., between 0 and 100 percent, or between 0 and some maximum capacity). SNMPv2 redefines this as Gauge32.</p>&#13;
<p class="seca"><b>Counter</b></p>&#13;
<p class="bl">Like Gauge, Counter is an integer that takes only non-negative values. Unlike Gauge, the value of a counter only increases until it wraps back to zero at its maximum limit. SNMPv2 replaced Counter with Counter32 and Counter64.</p>&#13;
<p class="seca"><b>TimeTicks</b></p>&#13;
<p class="bl">TimeTicks are integers describing time in 1/100ths of a second. They are generally used to describe the time since some significant event or starting point, such as system boot or last configuration change.</p>&#13;
<p class="seca"><b>OCTET STRING</b></p>&#13;
<p class="bl">An OCTET STRING is a string of eight-bit bytes. It is not necessarily a null-terminated C string; each octet can contain any value (0..255) at any position (i.e., there may be nulls in the middle). SNMPv2 added the restriction that an OCTET STRING may be no longer than 65,535 (i.e., its length must be expressible in 16 bits).</p>&#13;
<p class="seca"><b>OBJECT IDENTIFIER</b></p>&#13;
<p class="bl">This is used to contain SNMP OID values. SNMPv2 added the restriction that an OBJECT IDENTIFIER may contain no more than 128 components, each of which must be expressible in a maximum of 32 bits.</p>&#13;
<p class="seca"><b>IpAddress</b></p>&#13;
<p class="bl">The IpAddress string is an octet string of length four. (Note that this allows expression only of Ipv4 addresses.)</p>&#13;
<p class="seca"><a id="page320"/><b>Opaque</b></p>&#13;
<p class="bl">This type is much like OCTET STRING in that it is a string of octets with similar restrictions. Opaque was defined to allow extensions of the SMI. Defining new types based on the Opaque type is strongly discouraged.</p>&#13;
<p class="seca"><b>BITS</b></p>&#13;
<p class="bl">BITS was added in SNMPv2 to provide a way to express bit fields of labeled bits (i.e., where each bit has a separate meaning).</p>&#13;
<p class="seclas"><b>NOTE</b></p>&#13;
<p class="noindent"><i>Types that have been removed from the later revisions of SNMP are not shown in the above list.</i></p>&#13;
<p class="secl"><a id="app2.15"/><a href="toc.html#app2.15"><b>SNMP Tables</b></a></p>&#13;
<p class="noindent">In addition to the simple types described above, tables may be described using SEQUENCE and SEQUENCE OF. A table in a MIB is described as a SEQUENCE OF a type that describes the entry. The table entry is then described as a SEQUENCE containing the individual fields of the entry. The entry type describes the columns that constitute each row in the table, while the table itself is described as an array of these entry structures.</p>&#13;
<p class="indent">For example, here’s the definition of the interfaces table from MIB-2:</p>&#13;
<p class="imgl"><img src="../images/344-1.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page321"/><img src="../images/345-1.jpg" alt=""/></p>&#13;
<p class="indent">Note the use of both if Entry and IfEntry, one initial-capped and the other not. All object names start with lowercase; for example, ifTable and if Entry. Because If Entry is initial-capped, we know that it describes a type, rather than an object.</p>&#13;
<p class="indent">The IfEntry type is like a struct in C; it describes the layout of each table row. The lowercase ifEntry is a node in the OID tree beneath which the column objects will be defined. Thus, the description of a particular interface will have an OID like this:</p>&#13;
<p class="ex">ifTable.ifEntry.ifDescr.<i>x</i></p>&#13;
<p class="noindent">where <i>x</i> is the row index.</p>&#13;
<p class="indent">Following the definition of the entry type will be the definitions of each of the objects that make up the entry sequence. You will see this format again and again in MIB definitions; much MIB information is organized into tables.</p>&#13;
<p class="secl"><a id="app2.16"/><a href="toc.html#app2.16"><b>Defining New Types</b></a></p>&#13;
<p class="noindent">Although the data types defined in the SMI are sufficient, it is sometimes convenient to be a bit more specific. For example, you may want to restrict the possible values in an OCTET STRING or the range covered by an Integer32; if your MIB uses the same restricted values repeatedly, it will become tedious to describe these same restrictions repeatedly.</p>&#13;
<p class="indent">RFC 1903 describes the <i>textual convention,</i> a macro that allows you to bind your clarifications together into a new type. The following textual convention is taken from the file SNMPv2-TC.txt distributed with Net-SNMP (version 5.0.8).</p>&#13;
<p class="imgl"><img src="../images/345-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page322"/><img src="../images/346-1.jpg" alt=""/></p>&#13;
<p class="indent">This describes a type called DisplayString that can take up to 255 octets whose values are restricted to those that correspond to displayable characters. The DISPLAY-HINT clause shows how a DisplayString may appear. <i>255a</i> means it can take the form of up to 255 ASCII characters. RFC 1903 describes the complete syntax for the display hint.</p>&#13;
<p class="secl"><a id="app2.17"/><a href="toc.html#app2.17"><b>Structure of a MIB File</b></a></p>&#13;
<p class="noindent">When you read a MIB file, you will notice that it is named and defined between BEGIN and END statements. It will describe what it includes from other MIB files, and it will name the module being defined in this MIB file, the contact information for the person responsible for the MIB, and the revision history. Next you will see the definition of the objects in the MIB.</p>&#13;
<p class="indent">If you look at the IF-MIB, again distributed with the Net-SNMP package, you can see all of these parts. The MIB is enclosed within these lines</p>&#13;
<p class="ex">IF-MIB DEFINITIONS ::= BEGIN<br/><br/>END</p>&#13;
<p class="indent">The first section states the external dependencies.</p>&#13;
<p class="imgl"><img src="../images/346-2.jpg" alt=""/></p>&#13;
<p class="imgl"><a id="page323"/><img src="../images/347-1.jpg" alt=""/></p>&#13;
<p class="indent">Then comes the definition of the module.</p>&#13;
<p class="imgl"><img src="../images/347-2.jpg" alt=""/></p>&#13;
<p class="indent">This describes the module ifMib, which takes the location { mib-2 31 } in the overall MIB address space. The organization and contact information are clearly identifiable, followed by the descriptions of the various revisions of this MIB in reverse chronological order. The time and date look pretty cryptic, but they are just a concatenation of year, month, day, hour, and minute in GMT (indicated by the <i>Z</i> for Zulu Time). Therefore, the most recent revision (200006140000Z) was made on June 14, 2000.</p>&#13;
<p class="indent">Next, you’ll see the definition of the actual structure of the MIB objects, along with any textual conventions new to this MIB.</p>&#13;
<p class="secl"><a id="app2.18"/><a href="toc.html#app2.18"><b>Summary</b></a></p>&#13;
<p class="noindent"><a id="page324"/>This has been a whirlwind tour of SNMP. We’ve covered the basic parts of SNMP: the protocol, the grammar, and the first group of managed objects. You should now understand the acronyms <i>SMI</i>, <i>MIB</i>, and <i>OID</i>, and the terms <i>object</i> and <i>trap</i>. You should also be familiar with the term MIB-2 and have an idea of what it contains. We have discussed the various data types, both scalars and tables. At this point, you should be able to take an unfamiliar MIB and read through it, understanding its basic structure and what it is trying to describe. We have also touched on a couple of the command-line utilities you may find useful to probe an SNMP-enabled device: snmpwalk and snmpget.</p>&#13;
<p class="indent">With a little cut and paste and some judicious modifications, you may now be able to develop a simple MIB.</p>&#13;
<p class="noindent1">__________________</p>&#13;
<p class="foot"><sup>1</sup> Network Working Group, Request For Comments: 1213. <i>Management Information Base for Network Management of TCP/IP-based internets: MIB-II</i>. K. McCloghrie and M. Rose, March 1991.</p>&#13;
</div>&#13;
</body></html>