- en: Chapter 0x700. CRYPTOLOGY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Cryptology* is defined as the study of cryptography or cryptanalysis. *Cryptography*
    is simply the process of communicating secretly through the use of ciphers, and
    *cryptanalysis* is the process of cracking or deciphering such secret communications.
    Historically, cryptology has been of particular interest during wars, when countries
    used secret codes to communicate with their troops while also trying to break
    the enemy''s codes to infiltrate their communications.'
  prefs: []
  type: TYPE_NORMAL
- en: The wartime applications still exist, but the use of cryptography in civilian
    life is becoming increasingly popular as more critical transactions occur over
    the Internet. Network sniffing is so common that the paranoid assumption that
    someone is always sniffing network traffic might not be so paranoid. Passwords,
    credit card numbers, and other proprietary information can all be sniffed and
    stolen over unencrypted protocols. Encrypted communication protocols provide a
    solution to this lack of privacy and allow the Internet economy to function. Without
    Secure Sockets Layer (SSL) encryption, credit card transactions at popular websites
    would be either very inconvenient or insecure.
  prefs: []
  type: TYPE_NORMAL
- en: All of this private data is protected by cryptographic algorithms that are probably
    secure. Currently, cryptosystems that can be proven to be secure are far too unwieldy
    for practical use. So in lieu of a mathematical proof of security, cryptosystems
    that are *practically secure* are used. This means that it's possible that shortcuts
    for defeating these ciphers exist, but no one's been able to actualize them yet.
    Of course, there are also cryptosystems that aren't secure at all. This could
    be due to the implementation, key size, or simply cryptanalytic weaknesses in
    the cipher itself. In 1997, under US law, the maximum allowable key size for encryption
    in exported software was 40 bits. This limit on key size makes the corresponding
    cipher insecure, as was shown by RSA Data Security and Ian Goldberg, a graduate
    student from the University of California, Berkeley. RSA posted a challenge to
    decipher a message encrypted with a 40-bit key, and three and a half hours later,
    Ian had done just that. This was strong evidence that 40-bit keys aren't large
    enough for a secure cryptosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptology is relevant to hacking in a number of ways. At the purest level,
    the challenge of solving a puzzle is enticing to the curious. At a more nefarious
    level, the secret data protected by that puzzle is perhaps even more alluring.
    Breaking or circumventing the cryptographic protections of secret data can provide
    a certain sense of satisfaction, not to mention a sense of the protected data's
    contents. In addition, strong cryptography is useful in avoiding detection. Expensive
    network intrusion detection systems designed to sniff network traffic for attack
    signatures are useless if the attacker is using an encrypted communication channel.
    Often, the encrypted Web access provided for customer security is used by attackers
    as a difficult-to-monitor attack vector.
  prefs: []
  type: TYPE_NORMAL
- en: Information Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the concepts of cryptographic security stem from the mind of Claude
    Shannon. His ideas have influenced the field of cryptography greatly, especially
    the concepts of *diffusion* and *confusion*. Although the following concepts of
    unconditional security, one-time pads, quantum key distribution, and computational
    security weren't actually conceived by Shannon, his ideas on perfect secrecy and
    information theory had great influence on the definitions of security.
  prefs: []
  type: TYPE_NORMAL
- en: Unconditional Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cryptographic system is considered to be unconditionally secure if it cannot
    be broken, even with infinite computational resources. This implies that cryptanalysis
    is impossible and that even if every possible key were tried in an exhaustive
    brute-force attack, it would be impossible to determine which key was the correct
    one.
  prefs: []
  type: TYPE_NORMAL
- en: One-Time Pads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One example of an unconditionally secure cryptosystem is the *one-time pad*.
    A one-time pad is a very simple cryptosystem that uses blocks of random data called
    *pads*. The pad must be at least as long as the plaintext message that is to be
    encoded, and the random data on the pad must be truly random, in the most literal
    sense of the word. Two identical pads are made: one for the recipient and one
    for the sender. To encode a message, the sender simply XORs each bit of the plaintext
    message with the corresponding bit of the pad. After the message is encoded, the
    pad is destroyed to ensure that it is only used once. Then the encrypted message
    can be sent to the recipient without fear of cryptanalysis, since the encrypted
    message cannot be broken without the pad. When the recipient receives the encrypted
    message, he also XORs each bit of the encrypted message with the corresponding
    bit of his pad to produce the original plaintext message.'
  prefs: []
  type: TYPE_NORMAL
- en: While the one-time pad is theoretically impossible to break, in reality it's
    not really all that practical to use. The security of the one-time pad hinges
    on the security of the pads. When the pads are distributed to the recipient and
    the sender, it is assumed that the pad transmission channel is secure. To be truly
    secure, this could involve a face-to-face meeting and exchange, but for convenience,
    the pad transmission may be facilitated via yet another cipher. The price of this
    convenience is that the entire system is now only as strong as the weakest link,
    which would be the cipher used to transmit the pads. Since the pad consists of
    random data of the same length as the plaintext message, and since the security
    of the whole system is only as good as the security of pad transmission, it usually
    makes more sense to just send the plaintext message encoded using the same cipher
    that would have been used to transmit the pad.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Key Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The advent of quantum computation brings many interesting things to the field
    of cryptology. One of these is a practical implementation of the onetime pad,
    made possible by quantum key distribution. The mystery of quantum entanglement
    can provide a reliable and secret method of sending a random string of bits that
    can be used as a key. This is done using nonorthogonal quantum states in photons.
  prefs: []
  type: TYPE_NORMAL
- en: Without going into too much detail, the polarization of a photon is the oscillation
    direction of its electric field, which in this case can be along the horizontal,
    vertical, or one of the two diagonals. *Nonorthogonal* simply means the states
    are separated by an angle that isn't 90 degrees. Curiously enough, it's impossible
    to determine with certainty which of these four polarizations a single photon
    has. The rectilinear basis of the horizontal and vertical polarizations is incompatible
    with the diagonal basis of the two diagonal polarizations, so, due to the Heisenberg
    uncertainty principle, these two sets of polarizations cannot both be measured.
    Filters can be used to measure the polarizations— one for the rectilinear basis
    and one for the diagonal basis. When a photon passes through the correct filter,
    its polarization won't change, but if it passes through the incorrect filter,
    its polarization will be randomly modified. This means that any eavesdropping
    attempt to measure the polarization of a photon has a good chance of scrambling
    the data, making it apparent that the channel isn't secure.
  prefs: []
  type: TYPE_NORMAL
- en: These strange aspects of quantum mechanics were put to good use by Charles Bennett
    and Gilles Brassard in the first and probably best-known quantum key distribution
    scheme, called *BB84*. First, the sender and receiver agree on bit representation
    for the four polarizations, such that each basis has both 1 and 0\. In this scheme,
    1 could be represented by both vertical photon polarization and one of the diagonal
    polarizations (positive 45 degrees), while 0 could be represented by horizontal
    polarization and the other diagonal polarization (negative 45 degrees). This way,
    1s and 0s can exist when the rectilinear polarization is measured and when the
    diagonal polarization is measured.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the sender sends a stream of random photons, each coming from a randomly
    chosen basis (either rectilinear or diagonal), and these photons are recorded.
    When the receiver receives a photon, he also randomly chooses to measure it in
    either the rectilinear basis or the diagonal basis and records the result. Now,
    the two parties publicly compare which basis they used for each photon, and they
    keep only the data corresponding to the photons they both measured using the same
    basis. This doesn't reveal the bit values of the photons, since there are both
    1s and 0s in each basis. This makes up the key for the one-time pad.
  prefs: []
  type: TYPE_NORMAL
- en: Since an eavesdropper would ultimately end up changing the polarization of some
    of these photons and thus scramble the data, eavesdropping can be detected by
    computing the error rate of some random subset of the key. If there are too many
    errors, someone was probably eavesdropping, and the key should be thrown away.
    If not, the transmission of the key data was secure and private.
  prefs: []
  type: TYPE_NORMAL
- en: Computational Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cryptosystem is considered to be *computationally secure* if the best-known
    algorithm for breaking it requires an unreasonable amount of computational resources
    and time. This means that it is theoretically possible for an eavesdropper to
    break the encryption, but it is practically infeasible to actually do so, since
    the amount of time and resources necessary would far exceed the value of the encrypted
    information. Usually, the time needed to break a computationally secure cryptosystem
    is measured in tens of thousands of years, even with the assumption of a vast
    array of computational resources. Most modern cryptosystems fall into this category.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the best-known algorithms for breaking cryptosystems
    are always evolving and being improved. Ideally, a cryptosystem would be defined
    as computationally secure if the *best* algorithm for breaking it requires an
    unreasonable amount of computational resources and time, but there is currently
    no way to prove that a given encryption-breaking algorithm is and always will
    be the best one. So, the *current* best-known algorithm is used instead to measure
    a cryptosystem's security.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic Run Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Algorithmic run time* is a bit different from the run time of a program. Since
    an algorithm is simply an idea, there''s no limit to the processing speed for
    evaluating the algorithm. This means that an expression of algorithmic run time
    in minutes or seconds is meaningless.'
  prefs: []
  type: TYPE_NORMAL
- en: Without factors such as processor speed and architecture, the important unknown
    for an algorithm is *input size*. A sorting algorithm running on 1,000 elements
    will certainly take longer than the same sorting algorithm running on 10 elements.
    The input size is generally denoted by *n*, and each atomic step can be expressed
    as a number. The run time of a simple algorithm, such as the one that follows,
    can be expressed in terms of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm loops *n* times, each time doing two actions, and then does one
    last action, so the *time complexity* for this algorithm would be 2*n* + 1\. A
    more complex algorithm with an additional nested loop tacked on, shown below,
    would have a time complexity of *n*² + 2*n* + 1, since the new action is executed
    *n*² times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But this level of detail for time complexity is still too granular. For example,
    as *n* becomes larger, the relative difference between 2*n* + 5 and 2*n* + 365
    becomes less and less. However, as *n* becomes larger, the relative difference
    between 2*n*² + 5 and 2*n* + 5 becomes larger and larger. This type of generalized
    trending is what is most important to the run time of an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Consider two algorithms, one with a time complexity of 2*n* + 365 and the other
    with 2*n*² + 5\. The 2*n*² + 5 algorithm will outperform the 2*n* + 365 algorithm
    on small values for *n*. But for *n* = 30, both algorithms perform equally, and
    for all *n* greater than 30, the 2*n* + 365 algorithm will outperform the 2*n*²
    + 5 algorithm. Since there are only 30 values for *n* in which the 2*n*² + 5 algorithm
    performs better, but an infinite number of values for *n*in which the 2*n* + 365
    algorithm performs better, the 2*n* + 365 algorithm is generally more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, in general, the growth rate of the time complexity of an algorithm
    with respect to input size is more important than the time complexity for any
    fixed input. While this might not always hold true for specific real-world applications,
    this type of measurement of an algorithm's efficiency tends to be true when averaged
    over all possible applications.
  prefs: []
  type: TYPE_NORMAL
- en: Asymptotic Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Asymptotic notation* is a way to express an algorithm''s efficiency. It''s
    called asymptotic because it deals with the behavior of the algorithm as the input
    size approaches the asymptotic limit of infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the examples of the 2*n* + 365 algorithm and the 2*n*² + 5 algorithm,
    we determined that the 2*n* + 365 algorithm is generally more efficient because
    it follows the trend of *n*, while the 2*n*² + 5 algorithm follows the general
    trend of *n*². This means that 2*n* + 365 is bounded above by a positive multiple
    of *n* for all sufficiently large *n*, and 2*n*² + 5 is bounded above by a positive
    multiple of *n*² for all sufficiently large *n*.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds kind of confusing, but all it really means is that there exists
    a positive constant for the trend value and a lower bound on *n*, such that the
    trend value multiplied by the constant will always be greater than the time complexity
    for all *n* greater than the lower bound. In other words, 2*n*² + 5 is in the
    order of *n*², and 2*n* + 365 is in the order of *n*. There's a convenient mathematical
    notation for this, called *big-oh notation*, which looks like O(*n*²) to describe
    an algorithm that is in the order of *n*².
  prefs: []
  type: TYPE_NORMAL
- en: A simple way to convert an algorithm's time complexity to big-oh notation is
    to simply look at the high-order terms, since these will be the terms that matter
    most as *n* becomes sufficiently large. So an algorithm with a time complexity
    of 3*n*⁴ + 43*n*³ + 763*n* + log *n* + 37 would be in the order of O(*n*⁴), and
    54*n*⁷ + 23*n*⁴ + 4325 would be O(*n*⁷).
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Symmetric* ciphers are cryptosystems that use the same key to encrypt and
    decrypt messages. The encryption and decryption process is generally faster than
    with asymmetric encryption, but key distribution can be difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: These ciphers are generally either block ciphers or stream ciphers. A *block
    cipher* operates on blocks of a fixed size, usually 64 or 128 bits. The same block
    of plaintext will always encrypt to the same ciphertext block, using the same
    key. DES, Blowfish, and AES (Rijndael) are all block ciphers. *Stream ciphers*
    generate a stream of pseudo-random bits, usually either one bit or byte at a time.
    This is called the *keystream*, and it is XORed with the plaintext. This is useful
    for encrypting continuous streams of data. RC4 and LSFR are examples of popular
    stream ciphers. RC4 will be discussed in depth in "Wireless 802.11b Encryption"
    on [Wireless 802.11b Encryption](ch07s07.html "Wireless 802.11b Encryption").
  prefs: []
  type: TYPE_NORMAL
- en: DES and AES are both popular block ciphers. A lot of thought goes into the construction
    of block ciphers to make them resistant to known cryptanalytical attacks. Two
    concepts used repeatedly in block ciphers are confusion and diffusion. *Confusion*
    refers to methods used to hide relationships between the plaintext, the ciphertext,
    and the key. This means that the output bits must involve some complex transformation
    of the key and plaintext. *Diffusion*serves to spread the influence of the plaintext
    bits and the key bits over as much of the ciphertext as possible. *Product ciphers*
    combine both of these concepts by using various simple operations repeatedly.
    Both DES and AES are product ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: DES also uses a Feistel network. It is used in many block ciphers to ensure
    that the algorithm is invertible. Basically, each block is divided into two halves,
    left (*L*) and right (*R*). Then, in one round of operation, the new left half
    (*L[i]*) is set to be equal to the old right half (*R[i-1]*), and the new right
    half (*R[i]*) is made up of the old left half (*L[i-1]*) XORed with the output
    of a function using the old right half (*R[i-1]*) and the subkey for that round
    (*K[i]*). Usually, each round of operation has a separate subkey, which is calculated
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values for *L[i]* and *R[i]* are as follows (the ⊕ symbol denotes the XOR
    operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '| *L[i] = R[i-1]* |'
  prefs: []
  type: TYPE_TB
- en: '| *R[i] = L[i-1] ⊕ f(R[i-1], K[i])* |'
  prefs: []
  type: TYPE_TB
- en: DES uses 16 rounds of operation. This number was specifically chosen to defend
    against differential cryptanalysis. DES's only real known weakness is its key
    size. Since the key is only 56 bits, the entire keyspace can be checked in an
    exhaustive brute-force attack in a few weeks on specialized hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Triple-DES fixes this problem by using two DES keys concatenated together for
    a total key size of 112 bits. Encryption is done by encrypting the plaintext block
    with the first key, then decrypting with the second key, and then encrypting again
    with the first key. Decryption is done analogously, but with the encryption and
    decryption operations switched. The added key size makes a brute-force effort
    exponentially more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Most industry-standard block ciphers are resistant to all known forms of cryptanalysis,
    and the key sizes are usually too big to attempt an exhaustive brute-force attack.
    However, quantum computation provides some interesting possibilities, which are
    generally overhyped.
  prefs: []
  type: TYPE_NORMAL
- en: Lov Grover's Quantum Search Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantum computation gives the promise of massive parallelism. A quantum computer
    can store many different states in a superposition (which can be thought of as
    an array) and perform calculations on all of them at once. This is ideal for brute
    forcing anything, including block ciphers. The superposition can be loaded up
    with every possible key, and then the encryption operation can be performed on
    all the keys at the same time. The tricky part is getting the right value out
    of the superposition. Quantum computers are weird in that when the superposition
    is looked at, the whole thing decoheres into a single state. Unfortunately, this
    decoherence is initially random, and the odds of decohering into each state in
    the superposition are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Without some way to manipulate the odds of the superposition states, the same
    effect could be achieved by just guessing keys. Fortuitously, a man named Lov
    Grover came up with an algorithm that can manipulate the odds of the superposition
    states. This algorithm allows the odds of a certain desired state to increase
    while the others decrease. This process is repeated several times until the decohering
    of the superposition into the desired state is nearly guaranteed. This takes about
    ![](httpatomoreillycomsourcenostarchimages254340.png.jpg) steps.
  prefs: []
  type: TYPE_NORMAL
- en: Using some basic exponential math skills, you will notice that this just effectively
    halves the key size for an exhaustive brute-force attack. So, for the ultra paranoid,
    doubling the key size of a block cipher will make it resistant to even the theoretical
    possibilities of an exhaustive brute-force attack with a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asymmetric ciphers use two keys: a public key and a private key. The *public
    key* is made public, while the *private key* is kept private; hence the clever
    names. Any message that is encrypted with the public key can only be decrypted
    with the private key. This removes the issue of key distribution—public keys are
    public, and by using the public key, a message can be encrypted for the corresponding
    private key. Unlike symmetric ciphers, there''s no need for an out-of-band communication
    channel to transmit the secret key. However, asymmetric ciphers tend to be quite
    a bit slower than symmetric ciphers.'
  prefs: []
  type: TYPE_NORMAL
- en: RSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RSA is one of the more popular asymmetric algorithms. The security of RSA is
    based on the difficulty of factoring large numbers. First, two prime numbers are
    chosen, *P* and *Q*, and their product, *N*, is computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *N = P · Q* |'
  prefs: []
  type: TYPE_TB
- en: Then, the number of numbers between 1 and *N* – 1 that are relatively prime
    to *N* must be calculated (two numbers are *relatively prime* if their greatest
    common divisor is 1). This is known as Euler's totient function, and it is usually
    denoted by the lowercase Greek letter phi (φ).
  prefs: []
  type: TYPE_NORMAL
- en: For example, φ(9) = 6, since 1, 2, 4, 5, 7, and 8 are relatively prime to 9\.
    It should be easy to notice that if *N* is prime, φ(*N* ) will be *N* –1\. A somewhat
    less obvious fact is that if *N* is the product of exactly two prime numbers,
    *P*and *Q*, then φ(*P · Q) = (P –1) · (Q* –1). This comes in handy, since φ(*N*)
    must be calculated for RSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'An encryption key, *E*, that is relatively prime to φ(*N*), must be chosen
    at random. Then a decryption key must be found that satisfies the following equation,
    where *S* is any integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *E · D = S · φ(N*) + 1 |'
  prefs: []
  type: TYPE_TB
- en: This can be solved with the extended Euclidean algorithm. The *Euclidean algorithm*
    is a very old algorithm that happens to be a very fast way to calculate the greatest
    common divisor (GCD) of two numbers. The larger of the two numbers is divided
    by the smaller number, paying attention only to the remainder. Then, the smaller
    number is divided by the remainder, and the process is repeated until the remainder
    is zero. The last value for the remainder before it reaches zero is the greatest
    common divisor of the two original numbers. This algorithm is quite fast, with
    a run time of O(log[10]*N*). That means that it should take about as many steps
    to find the answer as the number of digits in the larger number.
  prefs: []
  type: TYPE_NORMAL
- en: In the table below, the GCD of 7253 and 120, written as gcd(7253, 120), will
    be calculated. The table starts by putting the two numbers in the columns A and
    B, with the larger number in column A. Then A is divided by B, and the remainder
    is put in column R. On the next line, the old B becomes the new A, and the old
    R becomes the new B. R is calculated again, and this process is repeated until
    the remainder is zero. The last value of R before zero is the greatest common
    divisor.
  prefs: []
  type: TYPE_NORMAL
- en: '| gcd(7253, 120) |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | B | R |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 7253 | 120 | 53 |'
  prefs: []
  type: TYPE_TB
- en: '| 120 | 53 | 14 |'
  prefs: []
  type: TYPE_TB
- en: '| 53 | 14 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 11 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: So, the greatest common divisor of 7243 and 120 is 1\. That means that 7250
    and 120 are relatively prime to each other.
  prefs: []
  type: TYPE_NORMAL
- en: The *extended Euclidean algorithm* deals with finding two integers, *J* and
    *K*, such that
  prefs: []
  type: TYPE_NORMAL
- en: '| *J · A + K · B = R* |'
  prefs: []
  type: TYPE_TB
- en: when gcd(*A, B) = R*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by working the Euclidean algorithm backward. In this case, though,
    the quotients are important. Here is the math from the prior example, with the
    quotients:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7253 = 60 · 120 + **53** |'
  prefs: []
  type: TYPE_TB
- en: '| 120 = 2 · 53 + **14** |'
  prefs: []
  type: TYPE_TB
- en: '| 53 = 3 · 14 + **11** |'
  prefs: []
  type: TYPE_TB
- en: '| 14 = 1 · 11 + **3** |'
  prefs: []
  type: TYPE_TB
- en: '| 11 = 3 · 3 + **2** |'
  prefs: []
  type: TYPE_TB
- en: '| 3 = 1 · 2 + **1** |'
  prefs: []
  type: TYPE_TB
- en: 'With a little bit of basic algebra, the terms can be moved around for each
    line so the remainder (shown in bold) is by itself on the left of the equal sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **53** = 7253 – 60 · 120 |'
  prefs: []
  type: TYPE_TB
- en: '| **14** = 120 – 2 · 53 |'
  prefs: []
  type: TYPE_TB
- en: '| **11** = 53 – 3 · 14 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** = 14 – 1 · 11 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** = 11 – 3 · 3 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** = 3 – 1 · 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Starting from the bottom, it''s clear that:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 3 – 1 · **2** |'
  prefs: []
  type: TYPE_TB
- en: 'The line above that, though, is 2 = 11 –3 · 3, which gives a substitution for
    2:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 3 – 1 · (11 – 3 · 3) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 = 4 · **3** – 1 · 11 |'
  prefs: []
  type: TYPE_TB
- en: 'The line above that shows that 3 = 14 –1 · 11, which can also be substituted
    in for 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 4 · (14 – 1 · 11) – 1 · 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 = 4 · 14 – 5 · **11** |'
  prefs: []
  type: TYPE_TB
- en: 'Of course, the line above that shows that 11 = 53 –3 · 14, prompting another
    substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 4 · 14 – 5 · (53 – 3 · 14) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 = 19 · **14** – 5 · 53 |'
  prefs: []
  type: TYPE_TB
- en: 'Following the pattern, we use the line that shows 14 = 120 –2 · 53, resulting
    in another substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 19 · (120 – 2 · 53) – 5 · 53 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 = 19 · 120 – 43 · **53** |'
  prefs: []
  type: TYPE_TB
- en: 'And finally, the top line shows that 53 = 7253 –60 · 120, for a final substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 19 · 120 – 43 · (7253 – 60 · 120) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 = 2599 · 120 – 43 · 7253 |'
  prefs: []
  type: TYPE_TB
- en: '| 2599 · 120 + – 43 · 7253 = 1 |'
  prefs: []
  type: TYPE_TB
- en: This shows that *J* and *K* would be 2599 and –43, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The numbers in the previous example were chosen for their relevance to RSA.
    Assuming the values for *P* and *Q* are 11 and 13, *N* would be 143\. Therefore,
    φ(*N*) = 120 = (11 –1) · (13 –1). Since 7253 is relatively prime to 120, that
    number makes an excellent value for *E*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, the goal was to find a value for *D* that satisfies the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *E · D = S · φ(N) + 1* |'
  prefs: []
  type: TYPE_TB
- en: 'Some basic algebra puts it in a more familiar form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *D · E + S · φ(N*) = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| *D · 7253 ± S* · 120 = 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Using the values from the extended Euclidean algorithm, it''s apparent that
    *D* = –43\. The value for *S* doesn''t really matter, which means this math is
    done modulo φ(*N*), or modulo 120\. That, in turn, means that a positive equivalent
    value for *D* is 77, since 120 –43 = 77\. This can be put into the prior equation
    from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *E · D = S · φ(N*) + 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7253 · 77 = 4654 · 120 + 1 |'
  prefs: []
  type: TYPE_TB
- en: The values for *N* and *E* are distributed as the public key, while *D* is kept
    secret as the private key. *P* and *Q* are discarded. The encryption and decryption
    functions are fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: '| Encryption: *C* = *M^E*(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: '| Decryption: *M* = *C^D*(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: 'For example, if the message, *M*, is 98, encryption would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 98^(7253) = 76(mod143) |'
  prefs: []
  type: TYPE_TB
- en: 'The ciphertext would be 76\. Then, only someone who knew the value for *D*
    could decrypt the message and recover the number 98 from the number 76, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 76^(77) = 98(mod143) |'
  prefs: []
  type: TYPE_TB
- en: Obviously, if the message, *M*, is larger than *N*, it must be broken down into
    chunks that are smaller than *N*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is made possible by Euler''s totient theorem. It states that if
    *M* and *N* are relatively prime, with *M* being the smaller number, then when
    *M* is multiplied by itself φ(*N*) times and divided by *N*, the remainder will
    always be 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '| If gcd(*M, N*) = 1 and *M* < *N* then *M^(φ(N))* = 1(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: 'Since this is all done modulo *N*, the following is also true, due to the way
    multiplication works in modulus arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *M^(φ(N)) · M^(φ(N))* = 1 ·1(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: '| *M*^(2 · φ(*N*)) = 1(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: 'This process could be repeated again and again *S* times to produce this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *M^(S · φ(N))* = 1(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: 'If both sides are multiplied by *M*, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *M^(S · φ(N)) · M* = 1 ·*M*(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: '| *M^(S · φ(N) + 1)* = *M*(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: 'This equation is basically the core of RSA. A number, *M*, raised to a power
    modulo *N*, produces the original number *M* again. This is basically a function
    that returns its own input, which isn''t all that interesting by itself. But if
    this equation could be broken up into two separate parts, then one part could
    be used to encrypt and the other to decrypt, producing the original message again.
    This can be done by finding two numbers, *E* and *D*, that multiplied together
    equal *S* times φ(*N*) plus 1\. Then this value can be substituted into the previous
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *E · D* = *S* ·φ(*N*) + 1 |'
  prefs: []
  type: TYPE_TB
- en: '| *M^(E · D)* = *M*(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *M^(E^D) = (M*mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: 'which can be broken up into two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *ME* = *C*(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: '| *CD* = *M*(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: And that's basically RSA. The security of the algorithm is tied to keeping*D*
    secret. But since *N* and *E* are both public values, if *N* can be factored into
    the original *P* and *Q*, then φ(*N*) can easily be calculated with (*P* –1) ·
    (*Q* –1), and then *D* can be determined with the extended Euclidean algorithm.
    Therefore, the key sizes for RSA must be chosen with the best-known factoring
    algorithm in mind to maintain computational security. Currently, the best-known
    factoring algorithm for large numbers is the number field sieve (NFS). This algorithm
    has a subexponential run time, which is pretty good, but still not fast enough
    to crack a 2,048-bit RSA key in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Peter Shor's Quantum Factoring Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, quantum computation promises amazing increases in computation potential.
    Peter Shor was able to take advantage of the massive parallelism of quantum computers
    to efficiently factor numbers using an old number-theory trick.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is actually quite simple. Take a number, *N*, to factor. Choose
    a value, *A*, that is less than *N*. This value should also be relatively prime
    to *N*, but assuming that *N* is the product of two prime numbers (which will
    always be the case when trying to factor numbers to break RSA), if *A* isn't relatively
    prime to *N*, then *A* is one of *N*'s factors.
  prefs: []
  type: TYPE_NORMAL
- en: Next, load up the superposition with sequential numbers counting up from 1 and
    feed every one of those values through the function *f*(*x*) = *A^x*(mod*N*).
    This is all done at the same time, through the magic of quantum computation. A
    repeating pattern will emerge in the results, and the period of this repetition
    must be found. Luckily, this can be done quickly on a quantum computer with a
    Fourier transform. This period will be called *R*.
  prefs: []
  type: TYPE_NORMAL
- en: Then, simply calculate gcd(*A^(R/2)* + 1, *N*) and gcd(*A^(R/2)* –1, *N*). At
    least one of these values should be a factor of *N*. This is possible because
    *A*^R = 1(mod*N*) and is further explained below.
  prefs: []
  type: TYPE_NORMAL
- en: '| *A^R* = 1(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: '| (*A^(R/2)*)² = 1(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: '| (*A^(R/2)*)² –1 = 0(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: '| (*A^(R/2)* –1) · (*A^(R/2)* + 1) = 0(mod*N*) |'
  prefs: []
  type: TYPE_TB
- en: This means that (*A^(R/2)* –1) · (*A^(R/2)* + 1) is an integer multiple of *N*.
    As long as these values don't zero themselves out, one of them will have a factor
    in common with *N*.
  prefs: []
  type: TYPE_NORMAL
- en: To crack the previous RSA example, the public value *N* must be factored. In
    this case *N* equals 143\. Next, a value for *A* is chosen that is relatively
    prime to and less than *N*, so *A* equals 21\. The function will look like *f*(*x*)
    = 21*^x*(mod143). Every sequential value from 1 up to as high as the quantum computer
    will allow will be put through this function.
  prefs: []
  type: TYPE_NORMAL
- en: To keep this brief, the assumption will be that the quantum computer has three
    quantum bits, so the superposition can hold eight values.
  prefs: []
  type: TYPE_NORMAL
- en: '| *x* = 1 | 211(mod143) = 21 |'
  prefs: []
  type: TYPE_TB
- en: '| *x* = 2 | 212(mod143) = 12 |'
  prefs: []
  type: TYPE_TB
- en: '| *x* = 3 | 213(mod143) = 109 |'
  prefs: []
  type: TYPE_TB
- en: '| *x* = 4 | 214(mod143) = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| *x* = 5 | 215(mod143) = 21 |'
  prefs: []
  type: TYPE_TB
- en: '| *x* = 6 | 216(mod143) = 12 |'
  prefs: []
  type: TYPE_TB
- en: '| *x* = 7 | 217(mod143) = 109 |'
  prefs: []
  type: TYPE_TB
- en: '| *x* = 8 | 218(mod143) = 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Here the period is easy to determine by eye: *R* is 4\. Armed with this information,
    gcd(21² –1143) and gcd(21² + 1143) should produce at least one of the factors.
    This time, both factors actually appear, since gcd(440, 143) = 11 and gcd(442,
    142) = 13\. These factors can then be used to recalculate the private key for
    the previous RSA example.'
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid Ciphers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *hybrid* cryptosystem gets the best of both worlds. An asymmetric cipher is
    used to exchange a randomly generated key that is used to encrypt the remaining
    communications with a symmetric cipher. This provides the speed and efficiency
    of a symmetric cipher, while solving the dilemma of secure key exchange. Hybrid
    ciphers are used by most modern cryptographic applications, such as SSL, SSH,
    and PGP.
  prefs: []
  type: TYPE_NORMAL
- en: Since most applications use ciphers that are resistant to cryptanalysis, attacking
    the cipher usually won't work. However, if an attacker can intercept communications
    between both parties and masquerade as one or the other, the key exchange algorithm
    can be attacked.
  prefs: []
  type: TYPE_NORMAL
- en: Man-in-the-Middle Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *man-in-the-middle (MitM) attack* is a clever way to circumvent encryption.
    The attacker sits between the two communicating parties, with each party believing
    they are communicating with the other party, but both are communicating with the
    attacker.
  prefs: []
  type: TYPE_NORMAL
- en: When an encrypted connection between the two parties is established, a secret
    key is generated and transmitted using an asymmetric cipher. Usually, this key
    is used to encrypt further communication between the two parties. Since the key
    is securely transmitted and the subsequent traffic is secured by the key, all
    of this traffic is unreadable by any would-be attacker sniffing these packets.
  prefs: []
  type: TYPE_NORMAL
- en: However, in an MitM attack, party A believes that she is communicating with
    B, and party B believes he is communicating with A, but in reality, both are communicating
    with the attacker. So, when A negotiates an encrypted connection with B, A is
    actually opening an encrypted connection with the attacker, which means the attacker
    securely communicates with an asymmetric cipher and learns the secret key. Then
    the attacker just needs to open another encrypted connection with B, and B will
    believe that he is communicating with A, as shown in the following illustration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254189.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x700-1.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the attacker actually maintains two separate encrypted communication
    channels with two separate encryption keys. Packets from A are encrypted with
    the first key and sent to the attacker, which A believes is actually B. The attacker
    then decrypts these packets with the first key and re-encrypts them with the second
    key. Then the attacker sends the newly encrypted packets to B, and B believes
    these packets are actually being sent by A. By sitting in the middle and maintaining
    two separate keys, the attacker is able to sniff and even modify traffic between
    A and B without either side being the wiser.
  prefs: []
  type: TYPE_NORMAL
- en: After redirecting traffic using an ARP cache poisoning tool, there are a number
    of SSH man-in-the-middle attack tools that can be used. Most of these are just
    modifications to the existing openssh source code. One notable example is the
    aptly named mitm-ssh package, by Claes Nyberg, which has been included on the
    LiveCD.
  prefs: []
  type: TYPE_NORMAL
- en: This can all be done with the ARP redirection technique from "Active Sniffing"
    on [Active Sniffing](ch04s04.html#active_sniffing "Active Sniffing") and a modified
    openssh package aptly called mitmssh. There are other tools that do this; however,
    Claes Nyberg's mitm-ssh is publicly available and the most robust. The source
    package is on the LiveCD in /usr/src/mitm-ssh, and it has already been built and
    installed. When running, it accepts connections to a given port and then proxies
    these connections to the real destination IP address of the target SSH server.
    With the help of arpspoof to poison ARP caches, traffic to the target SSH server
    can be redirected to the attacker's machine running mitm-ssh. Since this program
    listens on localhost, some IP filtering rules are needed to redirect the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, the target SSH server is at 192.168.42.72\. When mitm-ssh
    is run, it will listen on port 2222, so it doesn't need to be run as root. The
    iptables command tells Linux to redirect all incoming TCP connections on port
    22 to localhost 2222, where mitm-ssh will be listening.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then in another terminal window on the same machine, Dug Song's arpspoof tool
    is used to poison ARP caches and redirect traffic destined for 192.168.42.72 to
    our machine, instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And now the MitM attack is all set up and ready for the next unsuspecting victim.
    The output below is from another machine on the network (192.168.42.250), which
    makes an SSH connection to 192.168.42.72.
  prefs: []
  type: TYPE_NORMAL
- en: On Machine 192.168.42.250 (tetsuo), Connecting to 192.168.42.72 (loki)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Everything seems okay, and the connection appeared to be secure. However, the
    connection was secretly routed through the attacker's machine, which used a separate
    encrypted connection to back to the target server. Back on the attacker's machine,
    everything about the connection has been logged.
  prefs: []
  type: TYPE_NORMAL
- en: On the Attacker's Machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since the authentication was actually redirected, with the attacker's machine
    acting as a proxy, the password *sP#byp%srt* could be sniffed. In addition, the
    data transmitted during the connection is captured, showing the attacker everything
    the victim did during the SSH session.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker's ability to masquerade as either party is what makes this type
    of attack possible. SSL and SSH were designed with this in mind and have protections
    against identity spoofing. SSL uses certificates to validate identity, and SSH
    uses host fingerprints. If the attacker doesn't have the proper certificate or
    fingerprint for B when A attempts to open an encrypted communication channel with
    the attacker, the signatures won't match and A will be alerted with a warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, 192.168.42.250 (tetsuo) had never previously communicated
    over SSH with 192.168.42.72 (loki) and therefore didn''t have a host fingerprint.
    The host fingerprint that it accepted was actually the fingerprint generated by
    mitm-ssh. If, however, 192.168.42.250 (tetsuo) had a host fingerprint for 192.168.42.72
    (loki), the whole attack would have been detected, and the user would have been
    presented with a very blatant warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The openssh client will actually prevent the user from connecting until the
    old host fingerprint has been removed. However, many Windows SSH clients don't
    have the same kind of strict enforcement of these rules and will present the user
    with an "Are you sure you want to continue?" dialog box. An uninformed user might
    just click right through the warning.
  prefs: []
  type: TYPE_NORMAL
- en: Differing SSH Protocol Host Fingerprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH host fingerprints do have a few vulnerabilities. These vulnerabilities have
    been compensated for in the most recent versions of openssh, but they still exist
    in older implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the first time an SSH connection is made to a new host, that host''s
    fingerprint is added to a `known_hosts` file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, there are two different protocols of SSH—SSH1 and SSH2— each with separate
    host fingerprints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The banner presented by the SSH server describes which SSH protocols it understands
    (shown in bold below):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The banner from 192.168.42.72 (loki) includes the string `SSH-1.99`, which,
    by convention, means that the server speaks both protocols 1 and 2\. Often, the
    SSH server will be configured with a line like `Protocol 2,1`, which also means
    the server speaks both protocols and tries to use SSH2 if possible. This is to
    retain backward compatibility, so SSH1-only clients can still connect.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the banner from 192.168.42.1 includes the string `SSH-2.0`, which
    shows that the server only speaks protocol 2\. In this case, it's obvious that
    any clients connecting to it have only communicated with SSH2 and therefore only
    have host fingerprints for protocol 2.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for loki (192.168.42.72); however, loki also accepts SSH1,
    which has a different set of host fingerprints. It's unlikely that a client will
    have used SSH1, and therefore doesn't have the host fingerprints for this protocol
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: If the modified SSH daemon being used for the MitM attack forces the client
    to communicate using the other protocol, no host fingerprint will be found. Instead
    of being presented with a lengthy warning, the user will simply be asked to add
    the new fingerprint. The mitm-sshtool uses a configuration file similar to openssh's,
    since it's built from that code. By adding the line `Protocol 1` to /usr/local/etc/mitm-ssh_config,
    the mitm-ssh daemon will claim it only speaks the SSH1 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The output below shows that loki's SSH server usually speaks using both SSH1
    and SSH2 protocols, but when mitm-ssh is put in the middle using the new configuration
    file, the fake server claims it only speaks SSH1 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: From 192.168.42.250 (tetsuo), Just an Innocent Machine on the Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On the Attacker's Machine, Setting Up mitm-ssh to Only Use SSH1 Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now Back on 192.168.42.250 (tetsuo)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Usually, clients such as tetsuo connecting to loki at 192.168.42.72 would have
    only communicated using SSH2\. Therefore, there would only be a host fingerprint
    for SSH protocol 2 stored on the client. When protocol 1 is forced by the MitM
    attack, the attacker's fingerprint won't be compared to the stored fingerprint,
    due to the differing protocols. Older implementations will simply ask to add this
    fingerprint since, technically, no host fingerprint exists for this protocol.
    This is shown in the output below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this vulnerability was made public, newer implementations of OpenSSH
    have a slightly more verbose warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This modified warning isn't as strong as the warning given when host fingerprints
    of the same protocol don't match. Also, since not all clients will be up to date,
    this technique can still prove to be useful for an MitM attack.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy Fingerprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Konrad Rieck had an interesting idea regarding SSH host fingerprints. Often,
    a user will connect to a server from several different clients. The host fingerprint
    will be displayed and added each time a new client is used, and a security-conscious
    user will tend to remember the general structure of the host fingerprint. While
    no one actually memorizes the entire fingerprint, major changes can be detected
    with little effort. Having a general idea of what the host fingerprint looks like
    when connecting from a new client greatly increases the security of that connection.
    If an MitM attack is attempted, the blatant difference in host fingerprints can
    usually be detected by eye.
  prefs: []
  type: TYPE_NORMAL
- en: However, the eye and the brain can be tricked. Certain fingerprints will look
    very similar to others. Digits 1 and 7 look very similar, depending on the display
    font. Usually, the hex digits found at the beginning and end of the fingerprint
    are remembered with the greatest clarity, while the middle tends to be a bit hazy.
    The goal behind the fuzzy fingerprint technique is to generate a host key with
    a fingerprint that looks similar enough to the original fingerprint to fool the
    human eye.
  prefs: []
  type: TYPE_NORMAL
- en: The openssh package provides tools to retrieve the host key from servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that the host key fingerprint format is known for 192.168.42.72 (loki),
    fuzzy fingerprints can be generated that look similar. A program that does this
    has been developed by Rieck and is available at [http://www.thc.org/thc-ffp/](http://www.thc.org/thc-ffp/).
    The following output shows the creation of some fuzzy fingerprints for 192.168.42.72
    (loki).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This fuzzy fingerprint generation process can go on for as long as desired.
    The program keeps track of some of the best fingerprints and will display them
    periodically. All of the state information is stored in /var/tmp/ffp.state, so
    the program can be exited with a CTRL-C and then resumed again later by simply
    running `ffp` without any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: After running for a while, SSH host key pairs can be extracted from the state
    file with the `-e` switch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, 10 public and private host key pairs have been generated.
    Fingerprints for these key pairs can then be generated and compared with the original
    fingerprint, as seen in the following output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: From the 10 generated key pairs, the one that seems to look the most similar
    can be determined by eye. In this case, ssh-rsa02.pub, shown in bold, was chosen.
    Regardless of which key pair is chosen, though, it will certainly look more like
    the original fingerprint than any randomly generated key would.
  prefs: []
  type: TYPE_NORMAL
- en: This new key can be used with mitm-ssh to make for an even more effective attack.
    The location for the host key is specified in the configuration file, so using
    the new key is simply matter of adding a `HostKey` line in /usr/local/etc/mitm-ssh_config,
    as shown below. Since we need to remove the `Protocol 1` line we added earlier,
    the output below simply overwrites the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In another terminal window, arpspoof is running to redirect the traffic to mitm-ssh,
    which will use the new host key with the fuzzy fingerprint. The output below compares
    the output a client would see when connecting.
  prefs: []
  type: TYPE_NORMAL
- en: Normal Connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: MitM-Attacked Connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Can you immediately tell the difference? These fingerprints look similar enough
    to trick most people into simply accepting the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Password Cracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passwords aren't generally stored in plaintext form. A file containing all the
    passwords in plaintext form would be far too attractive a target, so instead,
    a one-way hash function is used. The best-known of these functions is based on
    DES and is called `crypt()`, which is described in the manual page shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a one-way hash function that expects a plaintext password and a salt
    value for input, and then outputs a hash with the salt value prepended to it.
    This hash is mathematically irreversible, meaning that it is impossible to determine
    the original password using only the hash. Writing a quick program to experiment
    with this function will help clarify any confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Password Cracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: crypt_test.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When this program is compiled, the crypt library needs to be linked. This is
    shown in the following output, along with some test runs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the last two runs, the same password is encrypted, but using
    different salt values. The salt value is used to perturb the algorithm further,
    so there can be multiple hash values for the same plaintext value if different
    salt values are used. The hash value (including the prepended salt) is stored
    in the password file under the premise that if an attacker were to steal the password
    file, the hashes would be useless.
  prefs: []
  type: TYPE_NORMAL
- en: When a legitimate user needs to authenticate using the password hash, that user's
    hash is looked up in the password file. The user is prompted to enter her password,
    the original salt value is extracted from the password file, and whatever the
    user types is sent through the same one-way hash function with the salt value.
    If the correct password was entered, the one-way hashing function will produce
    the same hash output as is stored in the password file. This allows authentication
    to function as expected, without ever having to store the plaintext password.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out, however, that the encrypted passwords in the password file aren't
    so useless after all. Sure, it's mathematically impossible to reverse the hash,
    but it is possible to just quickly hash every word in a dictionary, using the
    salt value for a specific hash, and then compare the result with that hash. If
    the hashes match, then that word from the dictionary must be the plaintext password.
  prefs: []
  type: TYPE_NORMAL
- en: A simple dictionary attack program can be whipped up fairly easily. It just
    needs to read words from a file, hash each one using the proper salt value, and
    display the word if there is a match. The following source code does this using
    filestream functions, which are included with stdio.h. These functions are easier
    to work with, since they wrap up the messiness of `open()` calls and file descriptors,
    using FILE structure pointers, instead. In the source below, the `fopen()` call's
    `r` argument tells it to open the file for reading. It returns NULL on failure,
    or a pointer to the open filestream. The `fgets()` call gets a string from the
    filestream, up to a maximum length or when it reaches the end of a line. In this
    case, it's used to read each line from the word-list file. This function also
    returns NULL on failure, which is used to detect then end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: crypt_crack.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The following output shows this program being used to crack the password hash
    *jeHEAX1m66RV.*, using the words found in /usr/share/dict/words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since the word *test* was the original password and this word is found in the
    words file, the password hash will eventually be cracked. This is why it's considered
    poor security practice to use passwords that are dictionary words or based on
    dictionary words.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside to this attack is that if the original password isn''t a word
    found in the dictionary file, the password won''t be found. For example, if a
    non-dictionary word such as `h4R%` is used as a password, the dictionary attack
    won''t be able to find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Custom dictionary files are often made using different languages, standard modifications
    of words (such as transforming letters to numbers), or simply appending numbers
    to the end of each word. While a bigger dictionary will yield more passwords,
    it will also take more time to process.
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive Brute-Force Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dictionary attack that tries every single possible combination is an *exhaustive
    brute-force* attack. While this type of attack will technically be able to crack
    every conceivable password, it will probably take longer than your grandchildren's
    grandchildren would be willing to wait.
  prefs: []
  type: TYPE_NORMAL
- en: With 95 possible input characters for `crypt()-`style passwords, there are 95⁸
    possible passwords for an exhaustive search of all eight-character passwords,
    which works out to be over seven quadrillion possible passwords. This number gets
    so big so quickly because, as another character is added to the password length,
    the number of possible passwords grows exponentially. Assuming 10,000 cracks per
    second, it would take about 22,875 years to try every password. Distributing this
    effort across many machines and processors is one possible approach; however,
    it is important to remember that this will only achieve a linear speedup. If one
    thousand machines were combined, each capable of 10,000 cracks per second, the
    effort would still take over 22 years. The linear speedup achieved by adding another
    machine is marginal compared to the growth in keyspace when another character
    is added to the password length.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the inverse of the exponential growth is also true; as characters are
    removed from the password length, the number of possible passwords decreases exponentially.
    This means that a four-character password only has 95⁴ possible passwords. This
    keyspace has only about 84 million possible passwords, which can be exhaustively
    cracked (assuming 10,000 cracks per second) in a little over two hours. This means
    that, even though a password like `h4R%` isn't in any dictionary, it can be cracked
    in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, in addition to avoiding dictionary words, password length is
    also important. Since the complexity scales up exponentially, doubling the length
    to produce an eight-character password should bring the level of effort required
    to crack the password into the unreasonable time frame.
  prefs: []
  type: TYPE_NORMAL
- en: Solar Designer has developed a password-cracking program called John the Ripper
    that uses first a dictionary attack and then an exhaustive brute-force attack.
    This program is probably the most popular one of its kind; it is available at
    [http://www.openwall.com/john](http://www.openwall.com/john). It has been included
    on the LiveCD.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this output, the account jose is shown to have the password of `testing7`.
  prefs: []
  type: TYPE_NORMAL
- en: Hash Lookup Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another interesting idea for password cracking is using a giant hash lookup
    table. If all the hashes for all possible passwords were precomputed and stored
    in a searchable data structure somewhere, any password could be cracked in the
    time it takes to search. Assuming a binary search, this time would be about O(log[2]
    *N*), where *N* is the number of entries. Since *N* is 95⁸ in the case of eight-character
    passwords, this works out to about O(8 log[2] 95), which is quite fast.
  prefs: []
  type: TYPE_NORMAL
- en: However, a hash lookup table like this would require about 100,000 terabytes
    of storage. In addition, the design of the password-hashing algorithm takes this
    type of attack into consideration and mitigates it with the salt value. Since
    multiple plaintext passwords will hash to different password hashes with different
    salts, a separate lookup table would have to be created for each salt. With the
    DES-based `crypt()` function, there are 4,096 possible salt values, which means
    that even for a smaller keyspace, such as all possible four-character passwords,
    a hash lookup table becomes impractical. With a fixed salt, the storage space
    needed for a single lookup table for all possible four-character passwords is
    about one gigabyte, but because of the salt values, there are 4,096 possible hashes
    for a single plaintext password, necessitating 4,096 different tables. This raises
    the needed storage space up to about 4.6 terabytes, which greatly dissuades such
    an attack.
  prefs: []
  type: TYPE_NORMAL
- en: Password Probability Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a trade-off between computational power and storage space that exists
    everywhere. This can be seen in the most elementary forms of computer science
    and everyday life. MP3 files use compression to store a high-quality sound file
    in a relatively small amount of space, but the demand for computational resources
    increases. Pocket calculators use this trade-off in the other direction by maintaining
    a lookup table for functions such as sine and cosine to save the calculator from
    doing heavy computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This trade-off can also be applied to cryptography in what has become known
    as a time/space trade-off attack. While Hellman''s methods for this type of attack
    are probably more efficient, the following source code should be easier to understand.
    The general principle is always the same, though: Try to find the sweet spot between
    computational power and storage space, so that an exhaustive brute-force attack
    can be completed in a reasonable amount of time, using a reasonable amount of
    space. Unfortunately, the dilemma of salts will still present itself, since this
    method still requires some form of storage. However, there are only 4,096 possible
    salts with `crypt()`-style password hashes, so the effect of this problem can
    be diminished by reducing the needed storage space far enough to remain reasonable
    despite the 4,096 multiplier.'
  prefs: []
  type: TYPE_NORMAL
- en: This method uses a form of lossy compression. Instead of having an exact hash
    lookup table, several thousand possible plaintext values will be returned when
    a password hash is entered. These values can be checked quickly to converge on
    the original plaintext password, and the lossy compression allows for a major
    space reduction. In the demonstration code that follows, the keyspace for all
    possible four-character passwords (with a fixed salt) is used. The storage space
    needed is reduced by 88 percent, compared to a full hash lookup table (with a
    fixed salt), and the keyspace that must be brute-forced through is reduced by
    about 1,018 times. Under the assumption of 10,000 cracks per second, this method
    can crack any four-character password (with a fixed salt) in under eight seconds,
    which is a considerable speedup when compared to the two hours needed for an exhaustive
    bruteforce attack of the same keyspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method builds a three-dimensional binary matrix that correlates parts
    of the hash values with parts of the plaintext values. On the x-axis, the plaintext
    is split into two pairs: the first two characters and the second two characters.
    The possible values are enumerated into a binary vector that is 95², or 9,025,
    bits long (about 1,129 bytes). On the y-axis, the ciphertext is split into four
    three-character chunks. These are enumerated the same way down the columns, but
    only four bits of the third character are actually used. This means there are
    64².4, or 16,384, columns. The z-axis exists simply to maintain eight different
    two-dimensional matrices, so four exist for each of the plaintext pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to split the plaintext into two paired values that are enumerated
    along a vector. Every possible plaintext is hashed into ciphertext, and the ciphertext
    is used to find the appropriate column of the matrix. Then the plaintext enumeration
    bit across the row of the matrix is turned on. When the ciphertext values are
    reduced into smaller chunks, collisions are inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: '| Plaintext | Hash |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| test | je**HEA**X1m66RV. |'
  prefs: []
  type: TYPE_TB
- en: '| !J)h | je**HEA**38vqlkkQ |'
  prefs: []
  type: TYPE_TB
- en: '| ".F+ | je**HEA**1Tbde5FE |'
  prefs: []
  type: TYPE_TB
- en: '| "8,J | je**HEA**nX8kQK3I |'
  prefs: []
  type: TYPE_TB
- en: In this case, the column for `HEA` would have the bits corresponding to the
    plaintext pairs `te, !J,` "., and `"8` turned on, as these plaintext/hash pairs
    are added to the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: After the matrix is completely filled out, when a hash such as `jeHEA38vqlkkQ`
    is entered, the column for `HEA` will be looked up, and the two-dimensional matrix
    will return the values `te, !J`, "., and `"8` for the first two characters of
    the plaintext. There are four matrices like this for the first two characters,
    using ciphertext substring from characters 2 through 4, 4 through 6, 6 though
    8, and 8 though 10, each with a different vector of possible first two-character
    plaintext values. Each vector is pulled, and they are combined with a bitwise
    AND. This will leave only those bits turned on that correspond to the plaintext
    pairs listed as possibilities for each substring of ciphertext. There are also
    four matrices like this for the last two characters of plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sizes of the matrices were determined by the pigeonhole principle. This
    is a simple principle that states: If *k* + 1 objects are put into *k* boxes,
    at least one of the boxes will contain two objects. So, to get the best results,
    the goal is for each vector to be a little bit less than half full of 1s. Since
    95⁴, or 81,450,625, entries will be put in the matrices, there need to be about
    twice as many holes to achieve 50 percent saturation. Since each vector has 9,025
    entries, there should be about (95⁴ · 2) / 9025 columns. This works out to be
    about 18,000 columns. Since ciphertext substrings of three characters are being
    used for the columns, the first two characters and four bits from the third character
    are used to provide 64² · 4, or about 16 thousand columns (there are only 64 possible
    values for each character of ciphertext hash). This should be close enough, because
    when a bit is added twice, the overlap is ignored. In practice, each vector turns
    out to be about 42 percent saturated with 1s.'
  prefs: []
  type: TYPE_NORMAL
- en: Since there are four vectors that are pulled for a single ciphertext, the probability
    of any one enumeration position having a 1 value in each vector is about 0.42⁴,
    or about 3.11 percent. This means that, on average, the 9,025 possibilities for
    the first two characters of plaintext are reduced by about 97 percent to 280 possibilities.
    This is also done for the last two characters, providing about 280², or 78,400,
    possible plaintext values. Under the assumption of 10,000 cracks per second, this
    reduced keyspace would take under 8 seconds to check.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are downsides. First, it takes at least as long to create the
    matrix as the original brute-force attack would have taken; however, this is a
    one-time cost. Also, the salts still tend to prohibit any type of storage attack,
    even with the reduced storage-space requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The following two source code listings can be used to create a password probability
    matrix and crack passwords with it. The first listing will generate a matrix that
    can be used to crack all possible four-character passwords salted with `je`. The
    second listing will use the generated matrix to actually do the password cracking.
  prefs: []
  type: TYPE_NORMAL
- en: ppm_gen.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first piece of code, ppm_gen.c, can be used to generate a fourcharacter
    password probability matrix, as shown in the output below. The `-O3` option passed
    to GCC tells it to optimize the code for speed when it compiles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The 142MB 4char.ppm file contains loose associations between the plaintext and
    hash data for every possible four-character password. This data can then be used
    by this next program to quickly crack four-character passwords that would foil
    a dictionary attack.
  prefs: []
  type: TYPE_NORMAL
- en: ppm_crack.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The second piece of code, ppm_crack.c, can be used to crack the troublesome
    password of `h4R%` in a matter of seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These programs are proof-of-concept hacks, which take advantage of the bit diffusion
    provided by hash functions. There are other time-space trade-off attacks, and
    some have become quite popular. RainbowCrack is a popular tool, which has support
    for multiple algorithms. If you want to learn more, consult the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless 802.11b Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wireless 802.11b security has been a big issue, primarily due to the absence
    of it. Weaknesses in *Wired Equivalent Privacy (WEP)*, the encryption method used
    for wireless, contribute greatly to the overall insecurity. There are other details,
    sometimes ignored during wireless deployments, which can also lead to major vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that wireless networks exist on layer 2 is one of these details. If
    the wireless network isn't VLANed off or firewalled, an attacker associated to
    the wireless access point could redirect all the wired network traffic out over
    the wireless via ARP redirection. This, coupled with the tendency to hook wireless
    access points to internal private networks, can lead to some serious vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if WEP is turned on, only clients with the proper WEP key will be
    allowed to associate to the access point. If WEP is secure, there shouldn't be
    any concern about rogue attackers associating and causing havoc. This begs the
    question, "How secure is WEP?"
  prefs: []
  type: TYPE_NORMAL
- en: Wired Equivalent Privacy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WEP was meant to be an encryption method providing security equivalent to a
    wired access point. It was originally designed with 40-bit keys; later, WEP2 came
    along to increase the key size to 104 bits. All of the encryption is done on a
    per-packet basis, so each packet is essentially a separate plaintext message to
    send. The packet will be called *M*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a checksum of message M is computed, so the message integrity can be
    checked later. This is done using a 32-bit cyclic redundancy checksum function
    aptly named CRC32\. This checksum will be called *CS*, so CS = CRC32(M). This
    value is appended to the end of the message, which makes up the plaintext message
    P:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254289.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x700-2.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the plaintext message needs to be encrypted. This is done using RC4, which
    is a stream cipher. This cipher, initialized with a seed value, can generate a
    keystream, which is just an arbitrarily long stream of pseudorandom bytes. WEP
    uses an initialization vector (IV) for the seed value. The IV consists of 24 bits
    generated for each packet. Some older WEP implementations simply use sequential
    values for the IV, while others use some form of pseudo-randomizer.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how the 24 bits of IV are chosen, they are prepended to the WEP
    key. (These 24 bits of IV are included in the WEP key size in a bit of clever
    marketing spin; when a vendor talks about 64-bit or 128-bit WEP keys, the actual
    keys are only 40 bits and 104 bits, respectively, combined with 24 bits of IV.)
    The IV and the WEP key together make up the seed value, which will be called S.
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254242.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x700-3.
  prefs: []
  type: TYPE_NORMAL
- en: Then the seed value S is fed into RC4, which will generate a keystream. This
    keystream is XORed with the plaintext message P to produce the ciphertext C. The
    IV is prepended to the ciphertext, and the whole thing is encapsulated with yet
    another header and sent out over the radio link.
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254525.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x700-4.
  prefs: []
  type: TYPE_NORMAL
- en: When the recipient receives a WEP-encrypted packet, the process is simply reversed.
    The recipient pulls the IV from the message and then concatenates the IV with
    his own WEP key to produce a seed value of S. If the sender and receiver both
    have the same WEP key, the seed values will be the same. This seed is fed into
    RC4 again to produce the same keystream, which is XORed with the rest of the encrypted
    message. This will produce the original plaintext message, consisting of the packet
    message M concatenated with the integrity checksum CS. The recipient then uses
    the same CRC32 function to recalculate the checksum for M and checks that the
    calculated value matches the received value of CS. If the checksums match, the
    packet is passed on. Otherwise, there were too many transmission errors or the
    WEP keys didn't match, and the packet is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: That's basically WEP in a nutshell.
  prefs: []
  type: TYPE_NORMAL
- en: RC4 Stream Cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RC4 is a surprisingly simple algorithm. It consists of two algorithms: the
    Key Scheduling Algorithm (KSA) and the Pseudo-Random Generation Algorithm (PRGA).
    Both of these algorithms use an *8-by-8 S-box*, which is just an array of 256
    numbers that are both unique and range in value from 0 to 255\. Stated simply,
    all the numbers from 0 to 255 exist in the array, but they''re all just mixed
    up in different ways. The KSA does the initial scrambling of the S-box, based
    on the seed value fed into it, and the seed can be up to 256 bits long.'
  prefs: []
  type: TYPE_NORMAL
- en: First, the S-box array is filled with sequential values from 0 to 255\. This
    array will be aptly named *S*. Then, another 256-byte array is filled with the
    seed value, repeating as necessary until the entire array is filled. This array
    will be named *K*. Then the *S* array is scrambled using the following pseudo-code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once that is done, the S-box is all mixed up based on the seed value. That's
    the key scheduling algorithm. Pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now when keystream data is needed, the Pseudo-Random Generation Algorithm (PRGA)
    is used. This algorithm has two counters, `i` and `j`, which are both initialized
    at `0` to begin with. After that, for each byte of keystream data, the following
    pseudo-code is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The outputted byte of `S[t]` is the first byte of the keystream. This algorithm
    is repeated for additional keystream bytes.
  prefs: []
  type: TYPE_NORMAL
- en: RC4 is simple enough that it can be easily memorized and implemented on the
    fly, and it is quite secure if used properly. However, there are a few problems
    with the way RC4 is used for WEP.
  prefs: []
  type: TYPE_NORMAL
- en: WEP Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several problems with the security of WEP. In all fairness, it was
    never meant to be a strong cryptographic protocol, but rather a way to provide
    a wired equivalency, as alluded to by the acronym. Aside from the security weaknesses
    relating to association and identities, there are several problems with the cryptographic
    protocol itself. Some of these problems stem from the use of CRC32 as a checksum
    function for message integrity, and other problems stem from the way IVs are used.
  prefs: []
  type: TYPE_NORMAL
- en: Offline Brute-Force Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Brute forcing will always be a possible attack on any computationally secure
    cryptosystem. The only question that remains is whether it''s a practical attack
    or not. With WEP, the actual method of offline brute forcing is simple: Capture
    a few packets, then try to decrypt the packets using every possible key. Next,
    recalculate the checksum for the packet, and compare this with the original checksum.
    If they match, then that''s most likely the key. Usually, this needs to be done
    with at least two packets, since it''s likely that a single packet can be decrypted
    with an invalid key yet the checksum will still be valid.'
  prefs: []
  type: TYPE_NORMAL
- en: However, under the assumption of 10,000 cracks per second, brute forcing through
    the 40-bit keyspace would take over three years. Realistically, modern processors
    can achieve more than 10,000 cracks per second, but even at 200,000 cracks per
    second, this would take a few months. Depending on the resources and dedication
    of an attacker, this type of attack may or may not be feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Tim Newsham has provided an effective cracking method that attacks weaknesses
    in the password-based key-generation algorithm that is used by most 40-bit (marketed
    as 64-bit) cards and access points. His method effectively reduces the 40-bit
    keyspace down to 21 bits, which can be cracked in a matter of minutes under the
    assumption of 10,000 cracks per second (and in a matter of seconds on a modern
    processor). More information on his methods can be found at [http://www.lava.net/~newsham/wlan](http://www.lava.net/~newsham/wlan).
  prefs: []
  type: TYPE_NORMAL
- en: For 104-bit (marketed as 128-bit) WEP networks, brute-forcing just isn't feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Keystream Reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another potential problem with WEP lies in keystream reuse. If two plaintexts
    (*P* ) are XORed with the same keystream to produce two separate ciphertexts (*C*),
    XORing those ciphertexts together will cancel out the keystream, resulting in
    the two plaintexts XORed with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '| *C[1] = P[1]* ⊕ RC4(seed) |'
  prefs: []
  type: TYPE_TB
- en: '| *C[2] = P[2]* ⊕ RC4(seed) |'
  prefs: []
  type: TYPE_TB
- en: '| *C[1] ⊕ C[2] = [P[1]* ⊕ RC4(seed)] ⊕ [*P[2]* ⊕ RC4(seed)] = *P[1] ⊕ P[2]*
    |'
  prefs: []
  type: TYPE_TB
- en: From here, if one of the plaintexts is known, the other one can easily be recovered.
    In addition, since the plaintexts in this case are Internet packets with a known
    and fairly predictable structure, various techniques can be employed to recover
    both original plaintexts.
  prefs: []
  type: TYPE_NORMAL
- en: The IV is intended to prevent these types of attacks; without it, every packet
    would be encrypted with the same keystream. If a different IV is used for each
    packet, the keystreams for packets will also be different. However, if the same
    IV is reused, both packets will be encrypted with the same keystream. This is
    a condition that is easy to detect, since the IVs are included in plaintext in
    the encrypted packets. Moreover, the IVs used for WEP are only 24 bits in length,
    which nearly guarantees that IVs will be reused. Assuming that IVs are chosen
    at random, statistically there should be a case of keystream reuse after just
    5,000 packets.
  prefs: []
  type: TYPE_NORMAL
- en: This number seems surprisingly small due to a counterintuitive probabilistic
    phenomenon known as the *birthday paradox*. This paradox states that if 23 people
    are in the same room, two of these people should share a birthday. With 23 people,
    there are (23 · 22) / 2, or 253, possible pairs. Each pair has a probability of
    success of 1/365, or about 0.27 percent, which corresponds to a probability of
    failure of 1 – (1 / 365), or about 99.726 percent. By raising this probability
    to the power of 253, the overall probability of failure is shown to be about 49.95
    percent, meaning that the probability of success is just a little over 50 percent.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works the same way with IV collisions. With 5,000 packets, there are (5000
    · 4999) / 2, or 12,497,500, possible pairs. Each pair has a probability of failure
    of 1 – (1 / 2^(24)). When this is raised to the power of the number of possible
    pairs, the overall probability of failure is about 47.5 percent, meaning that
    there''s a 52.5 percent chance of an IV collision with 5,000 packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Keystream Reuse](httpatomoreillycomsourcenostarchimages254433.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After an IV collision is discovered, some educated guesses about the structure
    of the plaintexts can be used to reveal the original plaintexts by XORing the
    two ciphertexts together. Also, if one of the plaintexts is known, the other plaintext
    can be recovered with a simple XORing. One method of obtaining known plaintexts
    might be through spam email, where the attacker sends the spam and the victim
    checks mail over the encrypted wireless connection.
  prefs: []
  type: TYPE_NORMAL
- en: IV-Based Decryption Dictionary Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After plaintexts are recovered for an intercepted message, the keystream for
    that IV will also be known. This means that this keystream can be used to decrypt
    any other packet with the same IV, providing it's not longer than the recovered
    keystream. Over time, it's possible to create a table of keystreams indexed by
    every possible IV. Since there are only 2^(24) possible IVs, if 1,500 bytes of
    keystream are saved for each IV, the table would only require about 24GB of storage.
    Once a table like this is created, all subsequent encrypted packets can be easily
    decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, this method of attack would be very time consuming and tedious.
    It's an interesting idea, but there are much easier ways to defeat WEP.
  prefs: []
  type: TYPE_NORMAL
- en: IP Redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to decrypt encrypted packets is to trick the access point into doing
    all the work. Usually, wireless access points have some form of Internet connectivity,
    and if this is the case, an IP redirection attack is possible. First, an encrypted
    packet is captured, and the destination address is changed to an IP address the
    attacker controls, without decrypting the packet. Then, the modified packet is
    sent back to the wireless access point, which will decrypt the packet and send
    it right to the attacker's IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The packet modification is made possible due to the CRC32 checksum being a linear,
    unkeyed function. This means that the packet can be strategically modified and
    the checksum will still come out the same.
  prefs: []
  type: TYPE_NORMAL
- en: This attack also assumes that the source and destination IP addresses are known.
    This information is easy enough to figure out, just based on the standard internal
    network IP addressing schemes. Also, a few cases of keystream reuse due to IV
    collisions can be used to determine the addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Once the destination IP address is known, this value can be XORed with the desired
    IP address, and this whole thing can be XORed into place in the encrypted packet.
    The XORing of the destination IP address will cancel out, leaving behind the desired
    IP address XORed with the keystream. Then, to ensure that the checksum stays the
    same, the source IP address must be strategically modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume the source address is 192.168.2.57 and the destination
    address is 192.168.2.1\. The attacker controls the address 123.45.67.89 and wants
    to redirect traffic there. These IP addresses exist in the packet in the binary
    form of high- and low-order 16-bit words. The conversion is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Src IP = 192.168.2.57**'
  prefs: []
  type: TYPE_NORMAL
- en: '| *SH* = 192 · 256 + 168 = 50344 |'
  prefs: []
  type: TYPE_TB
- en: '| *SL* = 2 · 256 + 57 = 569 |'
  prefs: []
  type: TYPE_TB
- en: '**Dst IP = 192.168.2.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '| *DH* = 192 · 256 + 168 = 50344 |'
  prefs: []
  type: TYPE_TB
- en: '| *DL* = 2 · 256 + 1 = 513 |'
  prefs: []
  type: TYPE_TB
- en: '**New IP = 123.45.67.89**'
  prefs: []
  type: TYPE_NORMAL
- en: '| *NH* = 123 · 256 + 45 = 31533 |'
  prefs: []
  type: TYPE_TB
- en: '| *NL* = 67 · 256 + 89 = 17241 |'
  prefs: []
  type: TYPE_TB
- en: 'The checksum will be changed by *N[H] + N[L] – D[H] – D[L]*, so this value
    must be subtracted from somewhere else in the packet. Since the source address
    is also known and doesn''t matter too much, the low-order 16-bit word of that
    IP address makes a good target:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *S''L = SL – (NH + NL – DH – DL*) |'
  prefs: []
  type: TYPE_TB
- en: '| *S''L* = 569 – (31533 + 17241 – 50344 – 513) |'
  prefs: []
  type: TYPE_TB
- en: '| *S''L* = 2652 |'
  prefs: []
  type: TYPE_TB
- en: The new source IP address should therefore be 192.168.10.92\. The source IP
    address can be modified in the encrypted packet using the same XORing trick, and
    then the checksums should match. When the packet is sent to the wireless access
    point, the packet will be decrypted and sent to 123.45.67.89, where the attacker
    can retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: If the attacker happens to have the ability to monitor packets on an entire
    class B network, the source address doesn't even need to be modified. Assuming
    the attacker had control over the entire 123.45.*X.X* IP range, the low-order
    16-bit word of the IP address could be strategically chosen not to disturb the
    checksum. If *NL = DH + DL – NH*, the checksum won't be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *NL = DH + DL – NH* |'
  prefs: []
  type: TYPE_TB
- en: '| *NL* = 50,344 + 513 – 31,533 |'
  prefs: []
  type: TYPE_TB
- en: '| *N''L* = 82390 |'
  prefs: []
  type: TYPE_TB
- en: The new destination IP address should be 123.45.75.124.
  prefs: []
  type: TYPE_NORMAL
- en: Fluhrer, Mantin, and Shamir Attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fluhrer, Mantin, and Shamir (FMS) attack is the most commonly used attack
    against WEP, popularized by tools such as AirSnort. This attack is really quite
    amazing. It takes advantage of weaknesses in the keyscheduling algorithm of RC4
    and the use of IVs.
  prefs: []
  type: TYPE_NORMAL
- en: There are weak IV values that leak information about the secret key in the first
    byte of the keystream. Since the same key is used over and over with different
    IVs, if enough packets with weak IVs are collected, and the first byte of the
    keystream is known, the key can be determined. Luckily, the first byte of an 802.11b
    packet is the snap header, which is almost always `0xAA`. This means the first
    byte of the keystream can be easily obtained by XORing the first encrypted byte
    with `0xAA`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, weak IVs need to be located. IVs for WEP are 24 bits, which translates
    to three bytes. Weak IVs are in the form of (*A* + 3, *N* – 1, *X*), where *A*
    is the byte of the key to be attacked, *N* is 256 (since RC4 works in modulo 256),
    and *X* can be any value. So, if the zeroth byte of the keystream is being attacked,
    there would be 256 weak IVs in the form of (3, 255, *X*), where *X*ranges from
    0 to 255\. The bytes of the keystream must be attacked in order, so the first
    byte cannot be attacked until the zeroth byte is known.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm itself is pretty simple. First, it performs *A* + 3 steps of the
    Key Scheduling Algorithm (KSA). This can be done without knowing the key, since
    the IV will occupy the first three bytes of the *K* array. If the zeroth byte
    of the key is known and *A* equals 1, the KSA can be worked to the fourth step,
    since the first four bytes of the *K* array will be known.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if *S*[0] or *S*[1] have been disturbed by the last step, the
    entire attempt should be discarded. More simply stated, if *j* is less than 2,
    the attempt should be discarded. Otherwise, take the value of *j* and the value
    of *S[A* + 3], and subtract both of these from the first keystream byte (modulo
    256, of course). This value will be the correct key byte about 5 percent of the
    time and effectively random less than 95 percent of the time. If this is done
    with enough weak IVs (with varying values for *X*), the correct key byte can be
    determined. It takes about 60 IVs to bring the probability above 50 percent. After
    one key byte is determined, the whole process can be done again to determine the
    next key byte, until the entire key is revealed.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of demonstration, RC4 will be scaled back so *N* equals 16 instead
    of 256\. This means that everything is modulo 16 instead of 256, and all the arrays
    are 16 "bytes" consisting of 4 bits, instead of 256 actual bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the key is (1, 2, 3, 4, 5), and the zeroth key byte will be attacked,
    *A* equals 0\. This means the weak IVs should be in the form of (3, 15, *X*).
    In this example, *X* will equal 2, so the seed value will be (3, 15, 2, 1, 2,
    3, 4, 5). Using this seed, the first byte of keystream output will be 9.
  prefs: []
  type: TYPE_NORMAL
- en: '| output = 9 |'
  prefs: []
  type: TYPE_TB
- en: '| *A* = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| IV = 3, 15, 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Key = 1, 2, 3, 4, 5 |'
  prefs: []
  type: TYPE_TB
- en: '| Seed = IV concatenated with the key |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| S[] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 |'
  prefs: []
  type: TYPE_TB
- en: Since the key is currently unknown, the *K* array is loaded up with what currently
    is known, and the *S* array is filled with sequential values from 0 to 15\. Then,
    *j* is initialized to 0, and the first three steps of the KSA are done. Remember
    that all math is done modulo 16.
  prefs: []
  type: TYPE_NORMAL
- en: '**KSA step one**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| *j* = 0 + 0 + 3 = 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = **3** 1 2 **0** 4 5 6 7 8 9 10 11 12 13 14 15 |'
  prefs: []
  type: TYPE_TB
- en: '**KSA step two**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| *j* = 3 + 1 + 15 = 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| S[] = 3 **0** 2 **1** 4 5 6 7 8 9 10 11 12 13 14 15 |'
  prefs: []
  type: TYPE_TB
- en: '**KSA step three**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 2 |'
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| *j* = 3 + 2 + 2 = 7 |'
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| S[] = 3 0 **7** 1 4 5 6 **2** 8 9 10 11 12 13 14 15 |'
  prefs: []
  type: TYPE_TB
- en: At this point, *j* isn't less than 2, so the process can continue. *S*[3] is
    1, *j* is 7, and the first byte of keystream output was 9\. So the zeroth byte
    of the key should be 9 –7 –1 = 1.
  prefs: []
  type: TYPE_NORMAL
- en: This information can be used to determine the next byte of the key, using IVs
    in the form of (4, 15, *X*) and working the KSA through to the fourth step. Using
    the IV (4, 15, 9), the first byte of keystream is 6.
  prefs: []
  type: TYPE_NORMAL
- en: '| output = 6 |'
  prefs: []
  type: TYPE_TB
- en: '| *A* = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| IV = 4, 15, 9 |'
  prefs: []
  type: TYPE_TB
- en: '| Key = 1, 2, 3, 4, 5 |'
  prefs: []
  type: TYPE_TB
- en: '| Seed = IV concatenated with the key |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 |'
  prefs: []
  type: TYPE_TB
- en: '**KSA step one**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| *j* = 0 + 0 + 4 = 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = **4** 1 2 3 **0** 5 6 7 8 9 10 11 12 13 14 15 |'
  prefs: []
  type: TYPE_TB
- en: '**KSA step two**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| *j* = 4 + 1 + 15 = 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 4 **0** 2 3 **1** 5 6 7 8 9 10 11 12 13 14 15 |'
  prefs: []
  type: TYPE_TB
- en: '**KSA step three**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 2 |'
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| *j* = 4 + 2 + 9 = 15 |'
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 4 0 **15** 3 1 5 6 7 8 9 10 11 12 13 14 **2** |'
  prefs: []
  type: TYPE_TB
- en: '**KSA step four**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 3 |'
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| *j* = 15 + 3 + 1 = 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 4 0 **15** 3 1 5 6 7 8 9 10 11 12 13 14 **2** |'
  prefs: []
  type: TYPE_TB
- en: '| output –*j – S*[4] = key[1] |'
  prefs: []
  type: TYPE_TB
- en: '| 6 – 3 – 1 = 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Again, the correct key byte is determined. Of course, for the sake of demonstration,
    values for *X* have been strategically picked. To give you a true sense of the
    statistical nature of the attack against a full RC4 implementation, the following
    source code has been included:'
  prefs: []
  type: TYPE_NORMAL
- en: fms.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code performs the FMS attack on 128-bit WEP (104-bit key, 24-bit IV), using
    every possible value of *X*. The key byte to attack is the only argument, and
    the key is hard-coded into the `key` array. The following output shows the compilation
    and execution of the fms.c code to crack an RC4 key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This type of attack has been so successful that a new wireless protocol called
    WPA should be used if you expect any form of security. However, there are still
    an amazing number of wireless networks only protected by WEP. Nowadays, there
    are fairly robust tools to perform WEP attacks. One notable example is aircrack,
    which has been included with the LiveCD; however, it requires wireless hardware,
    which you may not have. There is plenty of documentation on how to use this tool,
    which is in constant development. The first manual page should get you started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, consult the Internet for hardware issues. This program popularized a
    clever technique for gathering IVs. Waiting to gather enough IVs from packets
    would take hours, or even days. But since wireless is still a network, there will
    be ARP traffic. Since WEP encryption doesn't modify the size of the packet, it's
    easy to pick out which ones are ARP. This attack captures an encrypted packet
    that is the size of an ARP request, and then replays it to the network thousands
    of times. Each time, the packet is decrypted and sent to the network, and a corresponding
    ARP reply is sent back out. These extra replies don't harm the network; however,
    they do generate a separate packet with a new IV. Using this technique of tickling
    the network, enough IVs to crack the WEP key can be gathered in just a few minutes.
  prefs: []
  type: TYPE_NORMAL
