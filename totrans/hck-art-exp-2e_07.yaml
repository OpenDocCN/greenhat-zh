- en: Chapter 0x700. CRYPTOLOGY
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第0x700章。密码学
- en: '*Cryptology* is defined as the study of cryptography or cryptanalysis. *Cryptography*
    is simply the process of communicating secretly through the use of ciphers, and
    *cryptanalysis* is the process of cracking or deciphering such secret communications.
    Historically, cryptology has been of particular interest during wars, when countries
    used secret codes to communicate with their troops while also trying to break
    the enemy''s codes to infiltrate their communications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学*被定义为对密码学或密码分析的研究。*密码学*简单来说就是通过使用密码进行秘密通信的过程，而*密码分析*则是破解或解密这种秘密通信的过程。历史上，在战争期间，密码学特别受到关注，当时各国使用秘密代码与他们的部队进行通信，同时试图破解敌人的代码以渗透他们的通信。'
- en: The wartime applications still exist, but the use of cryptography in civilian
    life is becoming increasingly popular as more critical transactions occur over
    the Internet. Network sniffing is so common that the paranoid assumption that
    someone is always sniffing network traffic might not be so paranoid. Passwords,
    credit card numbers, and other proprietary information can all be sniffed and
    stolen over unencrypted protocols. Encrypted communication protocols provide a
    solution to this lack of privacy and allow the Internet economy to function. Without
    Secure Sockets Layer (SSL) encryption, credit card transactions at popular websites
    would be either very inconvenient or insecure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 战时的应用仍然存在，但随着越来越多的关键交易通过互联网进行，密码学在民用生活中的使用正变得越来越流行。网络嗅探如此普遍，以至于有人总是嗅探网络流量的偏执假设可能并不那么偏执。密码、信用卡号码和其他专有信息都可以通过未加密的协议进行嗅探和窃取。加密通信协议为这种隐私缺乏问题提供了解决方案，并允许互联网经济运行。如果没有安全套接字层（SSL）加密，在热门网站上的信用卡交易将会非常不便或不安全。
- en: All of this private data is protected by cryptographic algorithms that are probably
    secure. Currently, cryptosystems that can be proven to be secure are far too unwieldy
    for practical use. So in lieu of a mathematical proof of security, cryptosystems
    that are *practically secure* are used. This means that it's possible that shortcuts
    for defeating these ciphers exist, but no one's been able to actualize them yet.
    Of course, there are also cryptosystems that aren't secure at all. This could
    be due to the implementation, key size, or simply cryptanalytic weaknesses in
    the cipher itself. In 1997, under US law, the maximum allowable key size for encryption
    in exported software was 40 bits. This limit on key size makes the corresponding
    cipher insecure, as was shown by RSA Data Security and Ian Goldberg, a graduate
    student from the University of California, Berkeley. RSA posted a challenge to
    decipher a message encrypted with a 40-bit key, and three and a half hours later,
    Ian had done just that. This was strong evidence that 40-bit keys aren't large
    enough for a secure cryptosystem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些私有数据都由可能安全的密码学算法进行保护。目前，能够被证明是安全的密码系统对于实际应用来说过于复杂。因此，在没有数学安全证明的情况下，使用的是*实际安全*的密码系统。这意味着可能存在击败这些密码的捷径，但至今没有人能够实现它们。当然，也存在完全不安全的密码系统。这可能是由于实现方式、密钥大小，或者仅仅是密码本身在密码分析中的弱点。1997年，根据美国法律，出口软件中加密的最大允许密钥大小为40位。这个密钥大小的限制使得相应的密码不安全，正如RSA数据安全和加州大学伯克利分校的研究生伊恩·戈德堡所展示的那样。RSA发布了一个挑战，要求解密使用40位密钥加密的消息，三个半小时后，伊恩就完成了这个任务。这是强有力的证据表明40位密钥对于安全的密码系统来说不够大。
- en: Cryptology is relevant to hacking in a number of ways. At the purest level,
    the challenge of solving a puzzle is enticing to the curious. At a more nefarious
    level, the secret data protected by that puzzle is perhaps even more alluring.
    Breaking or circumventing the cryptographic protections of secret data can provide
    a certain sense of satisfaction, not to mention a sense of the protected data's
    contents. In addition, strong cryptography is useful in avoiding detection. Expensive
    network intrusion detection systems designed to sniff network traffic for attack
    signatures are useless if the attacker is using an encrypted communication channel.
    Often, the encrypted Web access provided for customer security is used by attackers
    as a difficult-to-monitor attack vector.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学以多种方式与黑客攻击相关。在最纯粹的水平上，解决谜题的挑战对好奇者来说具有吸引力。在更恶劣的水平上，被谜题保护的秘密数据可能更具吸引力。破解或绕过秘密数据的密码保护可以提供一种满足感，更不用说对受保护数据内容的了解。此外，强大的密码学有助于避免检测。设计用于嗅探网络流量以寻找攻击签名的昂贵网络入侵检测系统，如果攻击者使用加密通信通道，则毫无用处。通常，为了客户安全提供的加密Web访问被攻击者用作难以监控的攻击向量。
- en: Information Theory
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息论
- en: Many of the concepts of cryptographic security stem from the mind of Claude
    Shannon. His ideas have influenced the field of cryptography greatly, especially
    the concepts of *diffusion* and *confusion*. Although the following concepts of
    unconditional security, one-time pads, quantum key distribution, and computational
    security weren't actually conceived by Shannon, his ideas on perfect secrecy and
    information theory had great influence on the definitions of security.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多密码安全的概念源于克劳德·香农的头脑。他的思想对密码学领域产生了巨大影响，特别是*扩散*和*混淆*的概念。尽管无条件安全、一次性密码、量子密钥分发和计算安全这些概念并非香农实际提出的，但他在完美保密和信息理论方面的思想对安全定义产生了巨大影响。
- en: Unconditional Security
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无条件安全
- en: A cryptographic system is considered to be unconditionally secure if it cannot
    be broken, even with infinite computational resources. This implies that cryptanalysis
    is impossible and that even if every possible key were tried in an exhaustive
    brute-force attack, it would be impossible to determine which key was the correct
    one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个密码系统即使拥有无限的计算资源也无法被破解，那么它被认为是无条件安全的。这意味着密码分析是不可能的，即使在穷举暴力攻击中尝试了所有可能的关键，也无法确定哪个是正确的一个。
- en: One-Time Pads
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性密码
- en: 'One example of an unconditionally secure cryptosystem is the *one-time pad*.
    A one-time pad is a very simple cryptosystem that uses blocks of random data called
    *pads*. The pad must be at least as long as the plaintext message that is to be
    encoded, and the random data on the pad must be truly random, in the most literal
    sense of the word. Two identical pads are made: one for the recipient and one
    for the sender. To encode a message, the sender simply XORs each bit of the plaintext
    message with the corresponding bit of the pad. After the message is encoded, the
    pad is destroyed to ensure that it is only used once. Then the encrypted message
    can be sent to the recipient without fear of cryptanalysis, since the encrypted
    message cannot be broken without the pad. When the recipient receives the encrypted
    message, he also XORs each bit of the encrypted message with the corresponding
    bit of his pad to produce the original plaintext message.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无条件安全的密码系统的例子是*一次性密码*。一次性密码是一个非常简单的密码系统，它使用称为*填充块*的随机数据。填充块必须至少与要编码的明文消息一样长，填充块上的随机数据必须是真正随机的，从最字面的意义上讲。制作两个相同的填充块：一个给接收者，一个给发送者。要编码一条消息，发送者只需将明文消息的每个比特与填充块的相应比特进行异或运算。消息编码后，填充块被销毁以确保它只使用一次。然后，可以安全地将加密消息发送给接收者，无需担心密码分析，因为如果没有填充块，加密消息是无法被破解的。当接收者收到加密消息时，他也用他的填充块的相应比特对加密消息的每个比特进行异或运算，以产生原始的明文消息。
- en: While the one-time pad is theoretically impossible to break, in reality it's
    not really all that practical to use. The security of the one-time pad hinges
    on the security of the pads. When the pads are distributed to the recipient and
    the sender, it is assumed that the pad transmission channel is secure. To be truly
    secure, this could involve a face-to-face meeting and exchange, but for convenience,
    the pad transmission may be facilitated via yet another cipher. The price of this
    convenience is that the entire system is now only as strong as the weakest link,
    which would be the cipher used to transmit the pads. Since the pad consists of
    random data of the same length as the plaintext message, and since the security
    of the whole system is only as good as the security of pad transmission, it usually
    makes more sense to just send the plaintext message encoded using the same cipher
    that would have been used to transmit the pad.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一次性密码在理论上是无法被破解的，但在现实中，它并不真正实用。一次性密码的安全性依赖于密码的安全性。当密码被分发给接收者和发送者时，假定密码传输通道是安全的。为了真正安全，这可能涉及到面对面会议和交换，但为了方便，密码传输可能通过另一个密码来辅助完成。这种便利的代价是，整个系统现在只比最薄弱的环节强，而这将是用来传输密码的密码。由于密码由与明文消息长度相同的随机数据组成，并且整个系统的安全性仅与密码传输的安全性相当，因此通常更有意义的是只发送使用与传输密码相同的密码编码的明文消息。
- en: Quantum Key Distribution
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子密钥分发
- en: The advent of quantum computation brings many interesting things to the field
    of cryptology. One of these is a practical implementation of the onetime pad,
    made possible by quantum key distribution. The mystery of quantum entanglement
    can provide a reliable and secret method of sending a random string of bits that
    can be used as a key. This is done using nonorthogonal quantum states in photons.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算的兴起为密码学领域带来了许多有趣的事物。其中之一是利用量子密钥分发实现的一次性密码的实用化。量子纠缠的神秘性可以提供一种可靠且保密的方法来发送随机位串，这些位串可以用作密钥。这是通过在光子中使用非正交量子态来实现的。
- en: Without going into too much detail, the polarization of a photon is the oscillation
    direction of its electric field, which in this case can be along the horizontal,
    vertical, or one of the two diagonals. *Nonorthogonal* simply means the states
    are separated by an angle that isn't 90 degrees. Curiously enough, it's impossible
    to determine with certainty which of these four polarizations a single photon
    has. The rectilinear basis of the horizontal and vertical polarizations is incompatible
    with the diagonal basis of the two diagonal polarizations, so, due to the Heisenberg
    uncertainty principle, these two sets of polarizations cannot both be measured.
    Filters can be used to measure the polarizations— one for the rectilinear basis
    and one for the diagonal basis. When a photon passes through the correct filter,
    its polarization won't change, but if it passes through the incorrect filter,
    its polarization will be randomly modified. This means that any eavesdropping
    attempt to measure the polarization of a photon has a good chance of scrambling
    the data, making it apparent that the channel isn't secure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节的话，光子的偏振是其电场的振荡方向，在这种情况下可以是水平、垂直或两条对角线之一。*非正交*简单来说就是状态之间相隔的角度不是90度。令人好奇的是，无法确定一个光子具有这四种偏振中的哪一种。水平和垂直偏振的直角基与两条对角线偏振的对角基不相容，因此，由于海森堡不确定性原理，这两组偏振不能同时被测量。可以使用滤波器来测量偏振——一个用于直角基，一个用于对角基。当一个光子通过正确的滤波器时，其偏振不会改变，但如果它通过错误的滤波器，其偏振将被随机修改。这意味着任何试图测量光子偏振的窃听尝试都有很大机会打乱数据，使得通道不安全的迹象变得明显。
- en: These strange aspects of quantum mechanics were put to good use by Charles Bennett
    and Gilles Brassard in the first and probably best-known quantum key distribution
    scheme, called *BB84*. First, the sender and receiver agree on bit representation
    for the four polarizations, such that each basis has both 1 and 0\. In this scheme,
    1 could be represented by both vertical photon polarization and one of the diagonal
    polarizations (positive 45 degrees), while 0 could be represented by horizontal
    polarization and the other diagonal polarization (negative 45 degrees). This way,
    1s and 0s can exist when the rectilinear polarization is measured and when the
    diagonal polarization is measured.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些量子力学的奇异方面被查尔斯·贝内特和吉勒·布拉萨德在第一个也可能是最著名的量子密钥分发方案中得到了很好的应用，该方案称为*BB84*。首先，发送者和接收者就四个偏振的比特表示达成一致，使得每个基础都有1和0。在这个方案中，1可以由垂直光子偏振和其中一个对角偏振（正45度）表示，而0可以由水平偏振和另一个对角偏振（负45度）表示。这样，当测量直角偏振时和当测量对角偏振时，1和0都可以存在。
- en: Then, the sender sends a stream of random photons, each coming from a randomly
    chosen basis (either rectilinear or diagonal), and these photons are recorded.
    When the receiver receives a photon, he also randomly chooses to measure it in
    either the rectilinear basis or the diagonal basis and records the result. Now,
    the two parties publicly compare which basis they used for each photon, and they
    keep only the data corresponding to the photons they both measured using the same
    basis. This doesn't reveal the bit values of the photons, since there are both
    1s and 0s in each basis. This makes up the key for the one-time pad.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，发送者发送一串随机光子，每个光子来自随机选择的基础（要么是直角要么是对角），这些光子被记录下来。当接收者接收到一个光子时，他也会随机选择在直角基础或对角基础中测量它，并记录结果。现在，双方公开比较他们为每个光子使用的哪个基础，并且只保留他们使用相同基础测量的光子的数据。这不会揭示光子的比特值，因为每个基础中都有1和0。这构成了一次性密码的密钥。
- en: Since an eavesdropper would ultimately end up changing the polarization of some
    of these photons and thus scramble the data, eavesdropping can be detected by
    computing the error rate of some random subset of the key. If there are too many
    errors, someone was probably eavesdropping, and the key should be thrown away.
    If not, the transmission of the key data was secure and private.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于窃听者最终可能会改变一些光子的偏振状态，从而混淆数据，因此可以通过计算密钥中某些随机子集的错误率来检测窃听。如果错误太多，那么可能有人正在窃听，密钥应该被丢弃。如果没有，那么密钥数据的传输是安全且私密的。
- en: Computational Security
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算安全性
- en: A cryptosystem is considered to be *computationally secure* if the best-known
    algorithm for breaking it requires an unreasonable amount of computational resources
    and time. This means that it is theoretically possible for an eavesdropper to
    break the encryption, but it is practically infeasible to actually do so, since
    the amount of time and resources necessary would far exceed the value of the encrypted
    information. Usually, the time needed to break a computationally secure cryptosystem
    is measured in tens of thousands of years, even with the assumption of a vast
    array of computational resources. Most modern cryptosystems fall into this category.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果破解该密码系统的最佳已知算法需要不合理数量的计算资源和时间，则认为密码系统是*计算安全的*。这意味着理论上窃听者可以破解加密，但实际上这样做是不切实际的，因为所需的时间和资源将远远超过加密信息的价值。通常，破解计算安全密码系统所需的时间以数万年来衡量，即使假设有大量的计算资源也是如此。大多数现代密码系统都属于这一类。
- en: It's important to note that the best-known algorithms for breaking cryptosystems
    are always evolving and being improved. Ideally, a cryptosystem would be defined
    as computationally secure if the *best* algorithm for breaking it requires an
    unreasonable amount of computational resources and time, but there is currently
    no way to prove that a given encryption-breaking algorithm is and always will
    be the best one. So, the *current* best-known algorithm is used instead to measure
    a cryptosystem's security.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，破解密码系统的最佳已知算法总是在不断发展和改进。理想情况下，如果破解它的*最佳*算法需要不合理数量的计算资源和时间，则可以将密码系统定义为计算安全的，但目前尚无方法证明给定的加密破解算法是并且始终是最佳算法。因此，使用*当前*的最佳已知算法来衡量密码系统的安全性。
- en: Algorithmic Run Time
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法运行时间
- en: '*Algorithmic run time* is a bit different from the run time of a program. Since
    an algorithm is simply an idea, there''s no limit to the processing speed for
    evaluating the algorithm. This means that an expression of algorithmic run time
    in minutes or seconds is meaningless.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法运行时间*与程序的运行时间略有不同。由于算法只是一个想法，评估算法的处理速度没有限制。这意味着用分钟或秒来表示算法运行时间是没有意义的。'
- en: Without factors such as processor speed and architecture, the important unknown
    for an algorithm is *input size*. A sorting algorithm running on 1,000 elements
    will certainly take longer than the same sorting algorithm running on 10 elements.
    The input size is generally denoted by *n*, and each atomic step can be expressed
    as a number. The run time of a simple algorithm, such as the one that follows,
    can be expressed in terms of *n*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有处理器速度和架构等因素的情况下，算法的重要未知因素是*输入大小*。在1,000个元素上运行的排序算法肯定比在10个元素上运行的相同排序算法花费更长的时间。输入大小通常用*n*表示，每个原子步骤都可以用一个数字来表示。一个简单算法（如以下所示）的运行时间可以用*n*来表示。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This algorithm loops *n* times, each time doing two actions, and then does one
    last action, so the *time complexity* for this algorithm would be 2*n* + 1\. A
    more complex algorithm with an additional nested loop tacked on, shown below,
    would have a time complexity of *n*² + 2*n* + 1, since the new action is executed
    *n*² times.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法循环*n*次，每次执行两个操作，然后执行最后一个操作，因此这个算法的*时间复杂度*将是2*n* + 1。一个更复杂的算法，如以下所示，附加了一个嵌套循环，其时间复杂度将是*n*²
    + 2*n* + 1，因为新的操作执行*n*²次。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But this level of detail for time complexity is still too granular. For example,
    as *n* becomes larger, the relative difference between 2*n* + 5 and 2*n* + 365
    becomes less and less. However, as *n* becomes larger, the relative difference
    between 2*n*² + 5 and 2*n* + 5 becomes larger and larger. This type of generalized
    trending is what is most important to the run time of an algorithm.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种时间复杂度的详细程度仍然过于细化。例如，当*n*变大时，2*n* + 5和2*n* + 365之间的相对差异变得越来越小。然而，当*n*变大时，2*n*²
    + 5和2*n* + 5之间的相对差异变得越来越大。这种类型的泛化趋势对于算法的运行时间来说是最重要的。
- en: Consider two algorithms, one with a time complexity of 2*n* + 365 and the other
    with 2*n*² + 5\. The 2*n*² + 5 algorithm will outperform the 2*n* + 365 algorithm
    on small values for *n*. But for *n* = 30, both algorithms perform equally, and
    for all *n* greater than 30, the 2*n* + 365 algorithm will outperform the 2*n*²
    + 5 algorithm. Since there are only 30 values for *n* in which the 2*n*² + 5 algorithm
    performs better, but an infinite number of values for *n*in which the 2*n* + 365
    algorithm performs better, the 2*n* + 365 algorithm is generally more efficient.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个算法，一个的时间复杂度为2*n* + 365，另一个为2*n*² + 5。对于小的*n*值，2*n*² + 5算法将优于2*n* + 365算法。但当*n*
    = 30时，两个算法的表现相同，对于所有大于30的*n*，2*n* + 365算法将优于2*n*² + 5算法。由于只有30个*n*值中2*n*² + 5算法表现更好，而2*n*
    + 365算法在无限多个*n*值中表现更好，因此2*n* + 365算法通常更有效率。
- en: This means that, in general, the growth rate of the time complexity of an algorithm
    with respect to input size is more important than the time complexity for any
    fixed input. While this might not always hold true for specific real-world applications,
    this type of measurement of an algorithm's efficiency tends to be true when averaged
    over all possible applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，一般来说，算法的时间复杂度相对于输入大小的增长率比任何固定输入的时间复杂度更重要。虽然这并不总是适用于特定的实际应用，但这种对算法效率的测量通常在所有可能的平均应用中是正确的。
- en: Asymptotic Notation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渐近符号
- en: '*Asymptotic notation* is a way to express an algorithm''s efficiency. It''s
    called asymptotic because it deals with the behavior of the algorithm as the input
    size approaches the asymptotic limit of infinity.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*渐近符号*是表达算法效率的一种方法。它被称为渐近符号，因为它处理算法在输入大小接近渐近极限无穷大时的行为。'
- en: Returning to the examples of the 2*n* + 365 algorithm and the 2*n*² + 5 algorithm,
    we determined that the 2*n* + 365 algorithm is generally more efficient because
    it follows the trend of *n*, while the 2*n*² + 5 algorithm follows the general
    trend of *n*². This means that 2*n* + 365 is bounded above by a positive multiple
    of *n* for all sufficiently large *n*, and 2*n*² + 5 is bounded above by a positive
    multiple of *n*² for all sufficiently large *n*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回到2*n* + 365算法和2*n*² + 5算法的例子，我们确定2*n* + 365算法通常更有效，因为它遵循*n*的趋势，而2*n*² + 5算法遵循*n*²的一般趋势。这意味着对于所有足够大的*n*，2*n*
    + 365被一个正的*n*倍数所限制，而2*n*² + 5被一个正的*n*²倍数所限制。
- en: This sounds kind of confusing, but all it really means is that there exists
    a positive constant for the trend value and a lower bound on *n*, such that the
    trend value multiplied by the constant will always be greater than the time complexity
    for all *n* greater than the lower bound. In other words, 2*n*² + 5 is in the
    order of *n*², and 2*n* + 365 is in the order of *n*. There's a convenient mathematical
    notation for this, called *big-oh notation*, which looks like O(*n*²) to describe
    an algorithm that is in the order of *n*².
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些令人困惑，但它真正意味着的是存在一个趋势值的正常数和一个*n*的下限，使得趋势值乘以这个常数将始终大于所有大于下限的*n*的时间复杂度。换句话说，2*n*²
    + 5是*n*²阶的，而2*n* + 365是*n*阶的。有一个方便的数学符号来表示这一点，称为**大O符号**，用来描述一个算法是*n*²阶的，看起来像O(*n*²)。
- en: A simple way to convert an algorithm's time complexity to big-oh notation is
    to simply look at the high-order terms, since these will be the terms that matter
    most as *n* becomes sufficiently large. So an algorithm with a time complexity
    of 3*n*⁴ + 43*n*³ + 763*n* + log *n* + 37 would be in the order of O(*n*⁴), and
    54*n*⁷ + 23*n*⁴ + 4325 would be O(*n*⁷).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将算法的时间复杂度转换为大O符号的一个简单方法就是简单地查看高阶项，因为这些项将在*n*足够大时最为重要。所以一个时间复杂度为3*n*⁴ + 43*n*³
    + 763*n* + log *n* + 37的算法将是大O(*n*⁴)阶的，而54*n*⁷ + 23*n*⁴ + 4325将是O(*n*⁷)阶的。
- en: Symmetric Encryption
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密
- en: '*Symmetric* ciphers are cryptosystems that use the same key to encrypt and
    decrypt messages. The encryption and decryption process is generally faster than
    with asymmetric encryption, but key distribution can be difficult.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**对称**密码是使用相同密钥加密和解密消息的密码系统。与不对称加密相比，加密和解密过程通常更快，但密钥分发可能很困难。'
- en: These ciphers are generally either block ciphers or stream ciphers. A *block
    cipher* operates on blocks of a fixed size, usually 64 or 128 bits. The same block
    of plaintext will always encrypt to the same ciphertext block, using the same
    key. DES, Blowfish, and AES (Rijndael) are all block ciphers. *Stream ciphers*
    generate a stream of pseudo-random bits, usually either one bit or byte at a time.
    This is called the *keystream*, and it is XORed with the plaintext. This is useful
    for encrypting continuous streams of data. RC4 and LSFR are examples of popular
    stream ciphers. RC4 will be discussed in depth in "Wireless 802.11b Encryption"
    on [Wireless 802.11b Encryption](ch07s07.html "Wireless 802.11b Encryption").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密码通常要么是分组密码，要么是流密码。一个**分组密码**在固定大小的块上操作，通常是64位或128位。相同的明文块将始终使用相同的密钥加密成相同的密文块。DES、Blowfish和AES（Rijndael）都是分组密码。**流密码**生成一个伪随机的比特流，通常每次一个比特或一个字节。这被称为**密钥流**，它与明文进行异或运算。这对于加密连续的数据流非常有用。RC4和LSFR是流行的流密码示例。RC4将在“无线802.11b加密”中深入讨论，请参阅[无线802.11b加密](ch07s07.html
    "无线802.11b加密")。
- en: DES and AES are both popular block ciphers. A lot of thought goes into the construction
    of block ciphers to make them resistant to known cryptanalytical attacks. Two
    concepts used repeatedly in block ciphers are confusion and diffusion. *Confusion*
    refers to methods used to hide relationships between the plaintext, the ciphertext,
    and the key. This means that the output bits must involve some complex transformation
    of the key and plaintext. *Diffusion*serves to spread the influence of the plaintext
    bits and the key bits over as much of the ciphertext as possible. *Product ciphers*
    combine both of these concepts by using various simple operations repeatedly.
    Both DES and AES are product ciphers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DES和AES都是流行的分组密码。在构建分组密码时，投入了大量的思考，以使其能够抵御已知的密码分析攻击。在分组密码中反复使用的两个概念是混淆和扩散。*混淆*指的是用于隐藏明文、密文和密钥之间关系的各种方法。这意味着输出位必须涉及一些复杂的密钥和明文的转换。*扩散*旨在尽可能地将明文位和密钥位的影响扩散到密文的大部分。*产品密码*通过重复使用各种简单操作来结合这两个概念。DES和AES都是产品密码。
- en: DES also uses a Feistel network. It is used in many block ciphers to ensure
    that the algorithm is invertible. Basically, each block is divided into two halves,
    left (*L*) and right (*R*). Then, in one round of operation, the new left half
    (*L[i]*) is set to be equal to the old right half (*R[i-1]*), and the new right
    half (*R[i]*) is made up of the old left half (*L[i-1]*) XORed with the output
    of a function using the old right half (*R[i-1]*) and the subkey for that round
    (*K[i]*). Usually, each round of operation has a separate subkey, which is calculated
    earlier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: DES也使用Feistel网络。它在许多分组密码中用于确保算法是可逆的。基本上，每个块被分为两个部分，左边（*L*）和右边（*R*）。然后，在一个操作轮次中，新的左边（*L[i]*）被设置为等于旧的右边（*R[i-1]*），而新的右边（*R[i]*）由旧的左边（*L[i-1]*）与使用旧的右边（*R[i-1]*）和该轮次的子密钥（*K[i]*）的函数输出的异或（⊕）运算组成。通常，每个操作轮次都有一个单独的子密钥，该子密钥在之前计算。
- en: 'The values for *L[i]* and *R[i]* are as follows (the ⊕ symbol denotes the XOR
    operation):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*L[i]* 和 *R[i]* 的值如下（⊕符号表示异或运算）：'
- en: '| *L[i] = R[i-1]* |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| *L[i] = R[i-1]* |'
- en: '| *R[i] = L[i-1] ⊕ f(R[i-1], K[i])* |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| *R[i] = L[i-1] ⊕ f(R[i-1], K[i])* |'
- en: DES uses 16 rounds of operation. This number was specifically chosen to defend
    against differential cryptanalysis. DES's only real known weakness is its key
    size. Since the key is only 56 bits, the entire keyspace can be checked in an
    exhaustive brute-force attack in a few weeks on specialized hardware.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: DES使用16轮操作。这个数字是专门选择的，以防御差分密码分析。DES的唯一真正已知的弱点是其密钥大小。由于密钥只有56位，整个密钥空间可以在几周内通过专用硬件上的穷举暴力攻击来检查。
- en: Triple-DES fixes this problem by using two DES keys concatenated together for
    a total key size of 112 bits. Encryption is done by encrypting the plaintext block
    with the first key, then decrypting with the second key, and then encrypting again
    with the first key. Decryption is done analogously, but with the encryption and
    decryption operations switched. The added key size makes a brute-force effort
    exponentially more difficult.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Triple-DES通过使用两个连接在一起的DES密钥来解决这个问题，总密钥大小为112位。加密是通过使用第一个密钥加密明文块，然后使用第二个密钥解密，最后再次使用第一个密钥加密来完成的。解密过程类似，但加密和解密操作被切换。增加的密钥大小使得暴力破解尝试指数级地更困难。
- en: Most industry-standard block ciphers are resistant to all known forms of cryptanalysis,
    and the key sizes are usually too big to attempt an exhaustive brute-force attack.
    However, quantum computation provides some interesting possibilities, which are
    generally overhyped.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数行业标准分组密码对所有已知的密码分析形式都具有抵抗力，并且密钥大小通常太大，无法尝试穷举暴力攻击。然而，量子计算提供了一些有趣的可能，但这些通常被过度炒作。
- en: Lov Grover's Quantum Search Algorithm
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lov Grover的量子搜索算法
- en: Quantum computation gives the promise of massive parallelism. A quantum computer
    can store many different states in a superposition (which can be thought of as
    an array) and perform calculations on all of them at once. This is ideal for brute
    forcing anything, including block ciphers. The superposition can be loaded up
    with every possible key, and then the encryption operation can be performed on
    all the keys at the same time. The tricky part is getting the right value out
    of the superposition. Quantum computers are weird in that when the superposition
    is looked at, the whole thing decoheres into a single state. Unfortunately, this
    decoherence is initially random, and the odds of decohering into each state in
    the superposition are equal.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算承诺了巨大的并行性。量子计算机可以在叠加态（可以想象成数组）中存储许多不同的状态，并对它们同时进行计算。这对于穷举任何东西，包括块加密，都是理想的。可以将所有可能的关键字加载到叠加态中，然后同时对所有关键字执行加密操作。棘手的部分是正确地从叠加态中获取值。量子计算机很奇怪，当叠加态被观察时，整个系统会分解成单个状态。不幸的是，这种分解最初是随机的，叠加态中每个状态的分解概率是相等的。
- en: Without some way to manipulate the odds of the superposition states, the same
    effect could be achieved by just guessing keys. Fortuitously, a man named Lov
    Grover came up with an algorithm that can manipulate the odds of the superposition
    states. This algorithm allows the odds of a certain desired state to increase
    while the others decrease. This process is repeated several times until the decohering
    of the superposition into the desired state is nearly guaranteed. This takes about
    ![](httpatomoreillycomsourcenostarchimages254340.png.jpg) steps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有某种方法来操纵叠加态的概率，只需猜测密钥就能达到相同的效果。幸运的是，一个名叫Lov Grover的人提出了一种算法，可以操纵叠加态的概率。这个算法允许在增加某些期望状态的概率的同时减少其他状态的概率。这个过程重复几次，直到将叠加态分解成期望状态几乎可以保证。这需要大约
    ![](httpatomoreillycomsourcenostarchimages254340.png.jpg) 步。
- en: Using some basic exponential math skills, you will notice that this just effectively
    halves the key size for an exhaustive brute-force attack. So, for the ultra paranoid,
    doubling the key size of a block cipher will make it resistant to even the theoretical
    possibilities of an exhaustive brute-force attack with a quantum computer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些基本的指数数学技能，你会注意到这实际上将穷举暴力攻击的密钥大小减半。因此，对于极度偏执的人来说，将块加密的密钥大小加倍将使其对量子计算机进行穷举暴力攻击的理论可能性具有抵抗力。
- en: Asymmetric Encryption
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密
- en: 'Asymmetric ciphers use two keys: a public key and a private key. The *public
    key* is made public, while the *private key* is kept private; hence the clever
    names. Any message that is encrypted with the public key can only be decrypted
    with the private key. This removes the issue of key distribution—public keys are
    public, and by using the public key, a message can be encrypted for the corresponding
    private key. Unlike symmetric ciphers, there''s no need for an out-of-band communication
    channel to transmit the secret key. However, asymmetric ciphers tend to be quite
    a bit slower than symmetric ciphers.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密使用两个密钥：一个公钥和一个私钥。*公钥*是公开的，而*私钥*是保密的；因此得名。任何用公钥加密的消息只能用私钥解密。这解决了密钥分发的问题——公钥是公开的，通过使用公钥，可以为相应的私钥加密消息。与对称加密不同，不需要额外的通信渠道来传输密钥。然而，非对称加密通常比对称加密慢得多。
- en: RSA
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSA
- en: 'RSA is one of the more popular asymmetric algorithms. The security of RSA is
    based on the difficulty of factoring large numbers. First, two prime numbers are
    chosen, *P* and *Q*, and their product, *N*, is computed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RSA是更受欢迎的非对称算法之一。RSA的安全性基于分解大数的难度。首先，选择两个质数*P*和*Q*，然后计算它们的乘积*N*：
- en: '| *N = P · Q* |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| *N = P · Q* |'
- en: Then, the number of numbers between 1 and *N* – 1 that are relatively prime
    to *N* must be calculated (two numbers are *relatively prime* if their greatest
    common divisor is 1). This is known as Euler's totient function, and it is usually
    denoted by the lowercase Greek letter phi (φ).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要计算介于1和*N* - 1之间的相对质数数量（如果两个数的最大公约数是1，则称这两个数是*相对质数*）。这被称为欧拉函数，通常用小写希腊字母φ（φ）表示。
- en: For example, φ(9) = 6, since 1, 2, 4, 5, 7, and 8 are relatively prime to 9\.
    It should be easy to notice that if *N* is prime, φ(*N* ) will be *N* –1\. A somewhat
    less obvious fact is that if *N* is the product of exactly two prime numbers,
    *P*and *Q*, then φ(*P · Q) = (P –1) · (Q* –1). This comes in handy, since φ(*N*)
    must be calculated for RSA.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，φ(9) = 6，因为 1、2、4、5、7 和 8 与 9 互质。应该很容易注意到，如果 *N* 是一个质数，那么 φ(*N*) 将是 *N* –1。一个不那么明显的事实是，如果
    *N* 是两个质数 *P* 和 *Q* 的乘积，那么 φ(*P · Q*) = (P –1) · (Q* –1)。这对于计算 RSA 中的 φ(*N*) 非常有用。
- en: 'An encryption key, *E*, that is relatively prime to φ(*N*), must be chosen
    at random. Then a decryption key must be found that satisfies the following equation,
    where *S* is any integer:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 必须随机选择一个与 φ(*N*) 互质的加密密钥 *E*。然后必须找到一个满足以下方程的解密密钥，其中 *S* 是任何整数：
- en: '| *E · D = S · φ(N*) + 1 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| *E · D = S · φ(N*) + 1 |'
- en: This can be solved with the extended Euclidean algorithm. The *Euclidean algorithm*
    is a very old algorithm that happens to be a very fast way to calculate the greatest
    common divisor (GCD) of two numbers. The larger of the two numbers is divided
    by the smaller number, paying attention only to the remainder. Then, the smaller
    number is divided by the remainder, and the process is repeated until the remainder
    is zero. The last value for the remainder before it reaches zero is the greatest
    common divisor of the two original numbers. This algorithm is quite fast, with
    a run time of O(log[10]*N*). That means that it should take about as many steps
    to find the answer as the number of digits in the larger number.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过扩展欧几里得算法来解决。欧几里得算法是一个非常古老的算法，它碰巧是一种计算两个数最大公约数（GCD）的非常快速的方法。较大的数被除以较小的数，只注意余数。然后，较小的数被除以余数，这个过程重复进行，直到余数为零。在余数达到零之前的最后一个余数是两个原始数的最大公约数。这个算法非常快，运行时间为
    O(log[10]*N*)。这意味着找到答案所需的步骤数大约与较大数的位数相同。
- en: In the table below, the GCD of 7253 and 120, written as gcd(7253, 120), will
    be calculated. The table starts by putting the two numbers in the columns A and
    B, with the larger number in column A. Then A is divided by B, and the remainder
    is put in column R. On the next line, the old B becomes the new A, and the old
    R becomes the new B. R is calculated again, and this process is repeated until
    the remainder is zero. The last value of R before zero is the greatest common
    divisor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表格中，7253 和 120 的最大公约数（写作 gcd(7253, 120)）将被计算。表格首先将两个数放在 A 和 B 列中，较大的数放在
    A 列。然后 A 被除以 B，余数放在 R 列。在下一行，旧的 B 成为新的 A，旧的 R 成为新的 B。再次计算 R，这个过程重复进行，直到余数为零。在余数为零之前的最后一个
    R 值就是最大公约数。
- en: '| gcd(7253, 120) |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| gcd(7253, 120) |  |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | B | R |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| A | B | R |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 7253 | 120 | 53 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 7253 | 120 | 53 |'
- en: '| 120 | 53 | 14 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 120 | 53 | 14 |'
- en: '| 53 | 14 | 11 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 53 | 14 | 11 |'
- en: '| 14 | 11 | 3 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 11 | 3 |'
- en: '| 11 | 3 | 2 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 3 | 2 |'
- en: '| 3 | 2 | 1 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2 | 1 |'
- en: '| 2 | 1 | 0 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 0 |'
- en: So, the greatest common divisor of 7243 and 120 is 1\. That means that 7250
    and 120 are relatively prime to each other.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，7243 和 120 的最大公约数是 1。这意味着 7250 和 120 互质。
- en: The *extended Euclidean algorithm* deals with finding two integers, *J* and
    *K*, such that
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展欧几里得算法用于找到两个整数 *J* 和 *K*，使得
- en: '| *J · A + K · B = R* |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| *J · A + K · B = R* |'
- en: when gcd(*A, B) = R*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当 gcd(*A, B) = R*.
- en: 'This is done by working the Euclidean algorithm backward. In this case, though,
    the quotients are important. Here is the math from the prior example, with the
    quotients:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过反向工作欧几里得算法来完成的。在这种情况下，尽管如此，商很重要。以下是先前示例中的数学，包括商：
- en: '| 7253 = 60 · 120 + **53** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 7253 = 60 · 120 + **53** |'
- en: '| 120 = 2 · 53 + **14** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 120 = 2 · 53 + **14** |'
- en: '| 53 = 3 · 14 + **11** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 53 = 3 · 14 + **11** |'
- en: '| 14 = 1 · 11 + **3** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 14 = 1 · 11 + **3** |'
- en: '| 11 = 3 · 3 + **2** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 11 = 3 · 3 + **2** |'
- en: '| 3 = 1 · 2 + **1** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 3 = 1 · 2 + **1** |'
- en: 'With a little bit of basic algebra, the terms can be moved around for each
    line so the remainder (shown in bold) is by itself on the left of the equal sign:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点基本的代数，可以将每一行的项移动，使得余数（以粗体显示）单独位于等号左边：
- en: '| **53** = 7253 – 60 · 120 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **53** = 7253 – 60 · 120 |'
- en: '| **14** = 120 – 2 · 53 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **14** = 120 – 2 · 53 |'
- en: '| **11** = 53 – 3 · 14 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **11** = 53 – 3 · 14 |'
- en: '| **3** = 14 – 1 · 11 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **3** = 14 – 1 · 11 |'
- en: '| **2** = 11 – 3 · 3 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **2** = 11 – 3 · 3 |'
- en: '| **1** = 3 – 1 · 2 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **1** = 3 – 1 · **2** |'
- en: 'Starting from the bottom, it''s clear that:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从底部开始，很明显：
- en: '| 1 = 3 – 1 · **2** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 1 = 3 – 1 · **2** |'
- en: 'The line above that, though, is 2 = 11 –3 · 3, which gives a substitution for
    2:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上面的那一行是 2 = 11 –3 · 3，这给出了 2 的一个替换：
- en: '| 1 = 3 – 1 · (11 – 3 · 3) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| 1 = 4 · **3** – 1 · 11 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: 'The line above that shows that 3 = 14 –1 · 11, which can also be substituted
    in for 3:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 4 · (14 – 1 · 11) – 1 · 11 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| 1 = 4 · 14 – 5 · **11** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: 'Of course, the line above that shows that 11 = 53 –3 · 14, prompting another
    substitution:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 4 · 14 – 5 · (53 – 3 · 14) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| 1 = 19 · **14** – 5 · 53 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: 'Following the pattern, we use the line that shows 14 = 120 –2 · 53, resulting
    in another substitution:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 19 · (120 – 2 · 53) – 5 · 53 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| 1 = 19 · 120 – 43 · **53** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: 'And finally, the top line shows that 53 = 7253 –60 · 120, for a final substitution:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 19 · 120 – 43 · (7253 – 60 · 120) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| 1 = 2599 · 120 – 43 · 7253 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| 2599 · 120 + – 43 · 7253 = 1 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: This shows that *J* and *K* would be 2599 and –43, respectively.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The numbers in the previous example were chosen for their relevance to RSA.
    Assuming the values for *P* and *Q* are 11 and 13, *N* would be 143\. Therefore,
    φ(*N*) = 120 = (11 –1) · (13 –1). Since 7253 is relatively prime to 120, that
    number makes an excellent value for *E*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, the goal was to find a value for *D* that satisfies the following
    equation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '| *E · D = S · φ(N) + 1* |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: 'Some basic algebra puts it in a more familiar form:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| *D · E + S · φ(N*) = 1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| *D · 7253 ± S* · 120 = 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: 'Using the values from the extended Euclidean algorithm, it''s apparent that
    *D* = –43\. The value for *S* doesn''t really matter, which means this math is
    done modulo φ(*N*), or modulo 120\. That, in turn, means that a positive equivalent
    value for *D* is 77, since 120 –43 = 77\. This can be put into the prior equation
    from above:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '| *E · D = S · φ(N*) + 1 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| 7253 · 77 = 4654 · 120 + 1 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: The values for *N* and *E* are distributed as the public key, while *D* is kept
    secret as the private key. *P* and *Q* are discarded. The encryption and decryption
    functions are fairly simple.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '| Encryption: *C* = *M^E*(mod*N*) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| Decryption: *M* = *C^D*(mod*N*) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: 'For example, if the message, *M*, is 98, encryption would be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '| 98^(7253) = 76(mod143) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: 'The ciphertext would be 76\. Then, only someone who knew the value for *D*
    could decrypt the message and recover the number 98 from the number 76, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '| 76^(77) = 98(mod143) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: Obviously, if the message, *M*, is larger than *N*, it must be broken down into
    chunks that are smaller than *N*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is made possible by Euler''s totient theorem. It states that if
    *M* and *N* are relatively prime, with *M* being the smaller number, then when
    *M* is multiplied by itself φ(*N*) times and divided by *N*, the remainder will
    always be 1:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '| If gcd(*M, N*) = 1 and *M* < *N* then *M^(φ(N))* = 1(mod*N*) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: 'Since this is all done modulo *N*, the following is also true, due to the way
    multiplication works in modulus arithmetic:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '| *M^(φ(N)) · M^(φ(N))* = 1 ·1(mod*N*) |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| *M*^(2 · φ(*N*)) = 1(mod*N*) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: 'This process could be repeated again and again *S* times to produce this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| *M^(S · φ(N))* = 1(mod*N*) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: 'If both sides are multiplied by *M*, the result is:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两边都乘以M，结果是：
- en: '| *M^(S · φ(N)) · M* = 1 ·*M*(mod*N*) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| M^(S · φ(N) · M) = 1 ·*M*(mod*N*) |'
- en: '| *M^(S · φ(N) + 1)* = *M*(mod*N*) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| M^(S · φ(N) + 1) = *M*(mod*N*) |'
- en: 'This equation is basically the core of RSA. A number, *M*, raised to a power
    modulo *N*, produces the original number *M* again. This is basically a function
    that returns its own input, which isn''t all that interesting by itself. But if
    this equation could be broken up into two separate parts, then one part could
    be used to encrypt and the other to decrypt, producing the original message again.
    This can be done by finding two numbers, *E* and *D*, that multiplied together
    equal *S* times φ(*N*) plus 1\. Then this value can be substituted into the previous
    equation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个等式基本上是RSA的核心。一个数M，在模N的幂次下，再次产生原始数M。这基本上是一个返回其自身输入的函数，本身并不那么有趣。但如果这个等式可以被分成两个独立的部分，那么一部分可以用来加密，另一部分用来解密，再次产生原始信息。这可以通过找到两个数E和D，它们相乘等于S乘以φ(N)加1来实现。然后这个值可以代入到前面的等式中：
- en: '| *E · D* = *S* ·φ(*N*) + 1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| E · D = S ·φ(N) + 1 |'
- en: '| *M^(E · D)* = *M*(mod*N*) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| M^(E · D) = *M*(mod*N*) |'
- en: 'This is equivalent to:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '| *M^(E^D) = (M*mod*N*) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| M^(E^D) = (M*mod*N*) |'
- en: 'which can be broken up into two steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以分解为两个步骤：
- en: '| *ME* = *C*(mod*N*) |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| ME = C(mod*N*) |'
- en: '| *CD* = *M*(mod*N*) |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| CD = M(mod*N*) |'
- en: And that's basically RSA. The security of the algorithm is tied to keeping*D*
    secret. But since *N* and *E* are both public values, if *N* can be factored into
    the original *P* and *Q*, then φ(*N*) can easily be calculated with (*P* –1) ·
    (*Q* –1), and then *D* can be determined with the extended Euclidean algorithm.
    Therefore, the key sizes for RSA must be chosen with the best-known factoring
    algorithm in mind to maintain computational security. Currently, the best-known
    factoring algorithm for large numbers is the number field sieve (NFS). This algorithm
    has a subexponential run time, which is pretty good, but still not fast enough
    to crack a 2,048-bit RSA key in a reasonable amount of time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是RSA。算法的安全性取决于保持D的秘密。但由于N和E都是公开值，如果N可以被分解成原始的P和Q，那么φ(N)可以很容易地通过(P –1) ·
    (Q –1)计算出来，然后使用扩展欧几里得算法确定D。因此，RSA的密钥大小必须考虑到已知的最佳分解算法，以保持计算安全。目前，已知的大数分解算法是数域筛法（NFS）。这个算法有亚指数运行时间，相当不错，但仍然不够快，无法在合理的时间内破解2048位的RSA密钥。
- en: Peter Shor's Quantum Factoring Algorithm
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 彼得·肖尔的量子分解算法
- en: Once again, quantum computation promises amazing increases in computation potential.
    Peter Shor was able to take advantage of the massive parallelism of quantum computers
    to efficiently factor numbers using an old number-theory trick.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，量子计算在计算潜力上提供了惊人的增加。彼得·肖尔能够利用量子计算机的巨大并行性，通过使用古老的数论技巧高效地分解数字。
- en: The algorithm is actually quite simple. Take a number, *N*, to factor. Choose
    a value, *A*, that is less than *N*. This value should also be relatively prime
    to *N*, but assuming that *N* is the product of two prime numbers (which will
    always be the case when trying to factor numbers to break RSA), if *A* isn't relatively
    prime to *N*, then *A* is one of *N*'s factors.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法实际上相当简单。取一个数N进行分解。选择一个小于N的值A。这个值还应该与N互质，但假设N是两个质数的乘积（在尝试分解数字以破解RSA时，这始终是情况），如果A与N不互质，那么A是N的因子之一。
- en: Next, load up the superposition with sequential numbers counting up from 1 and
    feed every one of those values through the function *f*(*x*) = *A^x*(mod*N*).
    This is all done at the same time, through the magic of quantum computation. A
    repeating pattern will emerge in the results, and the period of this repetition
    must be found. Luckily, this can be done quickly on a quantum computer with a
    Fourier transform. This period will be called *R*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用连续的数字填充叠加，从1开始计数，并将这些值中的每一个通过函数f(x) = A^x(mod*N*)传递。这一切都是通过量子计算的魔力同时完成的。结果中会出现重复的模式，并且必须找到这个重复的周期。幸运的是，这可以在量子计算机上快速完成，使用傅里叶变换。这个周期将被称为R。
- en: Then, simply calculate gcd(*A^(R/2)* + 1, *N*) and gcd(*A^(R/2)* –1, *N*). At
    least one of these values should be a factor of *N*. This is possible because
    *A*^R = 1(mod*N*) and is further explained below.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，简单地计算gcd(A^(R/2) + 1, N)和gcd(A^(R/2) –1, N)。至少这些值中的一个应该是N的因子。这是可能的，因为A^R
    = 1(mod*N*)，下面将进一步解释。
- en: '| *A^R* = 1(mod*N*) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| A^R = 1(mod*N*) |'
- en: '| (*A^(R/2)*)² = 1(mod*N*) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| (*A^(R/2)*)² = 1(mod*N*) |'
- en: '| (*A^(R/2)*)² –1 = 0(mod*N*) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| (*A^(R/2)*)² –1 = 0(mod*N*) |'
- en: '| (*A^(R/2)* –1) · (*A^(R/2)* + 1) = 0(mod*N*) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| (*A^(R/2)* –1) · (*A^(R/2)* + 1) = 0(mod*N*) |'
- en: This means that (*A^(R/2)* –1) · (*A^(R/2)* + 1) is an integer multiple of *N*.
    As long as these values don't zero themselves out, one of them will have a factor
    in common with *N*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 (*A^(R/2)* –1) · (*A^(R/2)* + 1) 是 *N* 的整数倍。只要这些值不会归零，其中之一将与 *N* 有一个共同的因子。
- en: To crack the previous RSA example, the public value *N* must be factored. In
    this case *N* equals 143\. Next, a value for *A* is chosen that is relatively
    prime to and less than *N*, so *A* equals 21\. The function will look like *f*(*x*)
    = 21*^x*(mod143). Every sequential value from 1 up to as high as the quantum computer
    will allow will be put through this function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要破解之前的RSA示例，必须分解公钥值 *N*。在这种情况下，*N* 等于143。接下来，选择一个与 *N* 互质且小于 *N* 的 *A* 值，因此
    *A* 等于21。函数看起来像 *f*(*x*) = 21*^x*(mod143)。从1开始，直到量子计算机允许的最高值，每个连续的值都将通过这个函数。
- en: To keep this brief, the assumption will be that the quantum computer has three
    quantum bits, so the superposition can hold eight values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，假设量子计算机有三个量子位，因此叠加可以保持八个值。
- en: '| *x* = 1 | 211(mod143) = 21 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 1 | 211(mod143) = 21 |'
- en: '| *x* = 2 | 212(mod143) = 12 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 2 | 212(mod143) = 12 |'
- en: '| *x* = 3 | 213(mod143) = 109 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 3 | 213(mod143) = 109 |'
- en: '| *x* = 4 | 214(mod143) = 1 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 4 | 214(mod143) = 1 |'
- en: '| *x* = 5 | 215(mod143) = 21 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 5 | 215(mod143) = 21 |'
- en: '| *x* = 6 | 216(mod143) = 12 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 6 | 216(mod143) = 12 |'
- en: '| *x* = 7 | 217(mod143) = 109 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 7 | 217(mod143) = 109 |'
- en: '| *x* = 8 | 218(mod143) = 1 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 8 | 218(mod143) = 1 |'
- en: 'Here the period is easy to determine by eye: *R* is 4\. Armed with this information,
    gcd(21² –1143) and gcd(21² + 1143) should produce at least one of the factors.
    This time, both factors actually appear, since gcd(440, 143) = 11 and gcd(442,
    142) = 13\. These factors can then be used to recalculate the private key for
    the previous RSA example.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，周期很容易通过肉眼确定：*R* 是4。有了这些信息，gcd(21² –1143) 和 gcd(21² + 1143) 应该会产生至少一个因子。这次，两个因子实际上都出现了，因为
    gcd(440, 143) = 11 和 gcd(442, 142) = 13。然后可以使用这些因子重新计算之前RSA示例的私钥。
- en: Hybrid Ciphers
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合加密
- en: A *hybrid* cryptosystem gets the best of both worlds. An asymmetric cipher is
    used to exchange a randomly generated key that is used to encrypt the remaining
    communications with a symmetric cipher. This provides the speed and efficiency
    of a symmetric cipher, while solving the dilemma of secure key exchange. Hybrid
    ciphers are used by most modern cryptographic applications, such as SSL, SSH,
    and PGP.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一种 *混合* 密码系统结合了两种加密算法的优点。使用非对称加密算法交换一个随机生成的密钥，该密钥用于使用对称加密算法加密剩余的通信。这提供了对称加密算法的速度和效率，同时解决了安全密钥交换的难题。混合加密算法被大多数现代加密应用使用，如SSL、SSH和PGP。
- en: Since most applications use ciphers that are resistant to cryptanalysis, attacking
    the cipher usually won't work. However, if an attacker can intercept communications
    between both parties and masquerade as one or the other, the key exchange algorithm
    can be attacked.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数应用都使用对密码分析具有抵抗力的加密算法，因此攻击加密算法通常不会奏效。然而，如果攻击者能够拦截双方之间的通信并伪装成其中一方或另一方，则可以攻击密钥交换算法。
- en: Man-in-the-Middle Attacks
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: A *man-in-the-middle (MitM) attack* is a clever way to circumvent encryption.
    The attacker sits between the two communicating parties, with each party believing
    they are communicating with the other party, but both are communicating with the
    attacker.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一种 *中间人攻击 (MitM)* 是一种绕过加密的巧妙方法。攻击者坐在两个通信方之间，每个通信方都相信他们正在与另一方通信，但实际上双方都在与攻击者通信。
- en: When an encrypted connection between the two parties is established, a secret
    key is generated and transmitted using an asymmetric cipher. Usually, this key
    is used to encrypt further communication between the two parties. Since the key
    is securely transmitted and the subsequent traffic is secured by the key, all
    of this traffic is unreadable by any would-be attacker sniffing these packets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立两个当事人之间的加密连接时，将生成一个密钥并使用非对称加密算法进行传输。通常，这个密钥用于加密两个当事人之间的进一步通信。由于密钥是安全传输的，并且后续流量由密钥加密，因此所有这些流量对于任何试图嗅探这些数据包的潜在攻击者来说都是不可读的。
- en: However, in an MitM attack, party A believes that she is communicating with
    B, and party B believes he is communicating with A, but in reality, both are communicating
    with the attacker. So, when A negotiates an encrypted connection with B, A is
    actually opening an encrypted connection with the attacker, which means the attacker
    securely communicates with an asymmetric cipher and learns the secret key. Then
    the attacker just needs to open another encrypted connection with B, and B will
    believe that he is communicating with A, as shown in the following illustration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254189.png.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Figure 0x700-1.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: This means that the attacker actually maintains two separate encrypted communication
    channels with two separate encryption keys. Packets from A are encrypted with
    the first key and sent to the attacker, which A believes is actually B. The attacker
    then decrypts these packets with the first key and re-encrypts them with the second
    key. Then the attacker sends the newly encrypted packets to B, and B believes
    these packets are actually being sent by A. By sitting in the middle and maintaining
    two separate keys, the attacker is able to sniff and even modify traffic between
    A and B without either side being the wiser.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: After redirecting traffic using an ARP cache poisoning tool, there are a number
    of SSH man-in-the-middle attack tools that can be used. Most of these are just
    modifications to the existing openssh source code. One notable example is the
    aptly named mitm-ssh package, by Claes Nyberg, which has been included on the
    LiveCD.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: This can all be done with the ARP redirection technique from "Active Sniffing"
    on [Active Sniffing](ch04s04.html#active_sniffing "Active Sniffing") and a modified
    openssh package aptly called mitmssh. There are other tools that do this; however,
    Claes Nyberg's mitm-ssh is publicly available and the most robust. The source
    package is on the LiveCD in /usr/src/mitm-ssh, and it has already been built and
    installed. When running, it accepts connections to a given port and then proxies
    these connections to the real destination IP address of the target SSH server.
    With the help of arpspoof to poison ARP caches, traffic to the target SSH server
    can be redirected to the attacker's machine running mitm-ssh. Since this program
    listens on localhost, some IP filtering rules are needed to redirect the traffic.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, the target SSH server is at 192.168.42.72\. When mitm-ssh
    is run, it will listen on port 2222, so it doesn't need to be run as root. The
    iptables command tells Linux to redirect all incoming TCP connections on port
    22 to localhost 2222, where mitm-ssh will be listening.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then in another terminal window on the same machine, Dug Song's arpspoof tool
    is used to poison ARP caches and redirect traffic destined for 192.168.42.72 to
    our machine, instead.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And now the MitM attack is all set up and ready for the next unsuspecting victim.
    The output below is from another machine on the network (192.168.42.250), which
    makes an SSH connection to 192.168.42.72.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间人攻击已经设置好，准备迎接下一个毫无防备的受害者。下面的输出来自网络上的另一台机器（192.168.42.250），该机器尝试连接到 192.168.42.72。
- en: On Machine 192.168.42.250 (tetsuo), Connecting to 192.168.42.72 (loki)
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在机器 192.168.42.250 (tetsuo) 上，连接到 192.168.42.72 (loki)
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Everything seems okay, and the connection appeared to be secure. However, the
    connection was secretly routed through the attacker's machine, which used a separate
    encrypted connection to back to the target server. Back on the attacker's machine,
    everything about the connection has been logged.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很正常，连接似乎很安全。然而，连接实际上是秘密地通过攻击者的机器路由的，该机器使用一个单独的加密连接返回目标服务器。在攻击者的机器上，关于连接的所有信息都已记录。
- en: On the Attacker's Machine
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在攻击者的机器上
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the authentication was actually redirected, with the attacker's machine
    acting as a proxy, the password *sP#byp%srt* could be sniffed. In addition, the
    data transmitted during the connection is captured, showing the attacker everything
    the victim did during the SSH session.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于认证实际上被重定向，攻击者的机器作为代理，密码 *sP#byp%srt* 可以被嗅探。此外，连接期间传输的数据被捕获，显示了攻击者看到了受害者在整个
    SSH 会话期间所做的一切。
- en: The attacker's ability to masquerade as either party is what makes this type
    of attack possible. SSL and SSH were designed with this in mind and have protections
    against identity spoofing. SSL uses certificates to validate identity, and SSH
    uses host fingerprints. If the attacker doesn't have the proper certificate or
    fingerprint for B when A attempts to open an encrypted communication channel with
    the attacker, the signatures won't match and A will be alerted with a warning.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者能够伪装成任一方的能力使得这种攻击成为可能。SSL 和 SSH 都是考虑到这一点而设计的，并且有防止身份欺骗的保护措施。SSL 使用证书来验证身份，而
    SSH 使用宿主指纹。如果 A 尝试与攻击者打开加密通信通道时，攻击者没有 B 的正确证书或指纹，签名将不会匹配，A 将收到一个警告。
- en: 'In the previous example, 192.168.42.250 (tetsuo) had never previously communicated
    over SSH with 192.168.42.72 (loki) and therefore didn''t have a host fingerprint.
    The host fingerprint that it accepted was actually the fingerprint generated by
    mitm-ssh. If, however, 192.168.42.250 (tetsuo) had a host fingerprint for 192.168.42.72
    (loki), the whole attack would have been detected, and the user would have been
    presented with a very blatant warning:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，192.168.42.250 (tetsuo) 从未与 192.168.42.72 (loki) 通过 SSH 进行过通信，因此没有宿主指纹。它接受的宿主指纹实际上是
    mitm-ssh 生成的指纹。但是，如果 192.168.42.250 (tetsuo) 为 192.168.42.72 (loki) 有一个宿主指纹，整个攻击就会被检测到，用户将看到一个非常明显的警告：
- en: '[PRE6]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The openssh client will actually prevent the user from connecting until the
    old host fingerprint has been removed. However, many Windows SSH clients don't
    have the same kind of strict enforcement of these rules and will present the user
    with an "Are you sure you want to continue?" dialog box. An uninformed user might
    just click right through the warning.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: openssh 客户端实际上会阻止用户连接，直到旧的宿主指纹被移除。然而，许多 Windows SSH 客户端并没有对这些规则进行同样的严格执行，而是会向用户显示一个“你确定要继续吗？”的对话框。一个不知情的使用者可能会直接点击通过警告。
- en: Differing SSH Protocol Host Fingerprints
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的 SSH 协议宿主指纹
- en: SSH host fingerprints do have a few vulnerabilities. These vulnerabilities have
    been compensated for in the most recent versions of openssh, but they still exist
    in older implementations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 宿主指纹确实存在一些漏洞。这些漏洞在最新的 openssh 版本中得到了补偿，但在旧的实施中仍然存在。
- en: 'Usually, the first time an SSH connection is made to a new host, that host''s
    fingerprint is added to a `known_hosts` file, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，第一次将 SSH 连接到新的主机时，该主机的指纹会被添加到 `known_hosts` 文件中，如下所示：
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, there are two different protocols of SSH—SSH1 and SSH2— each with separate
    host fingerprints.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SSH 有两种不同的协议——SSH1 和 SSH2——每种协议都有自己的宿主指纹。
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The banner presented by the SSH server describes which SSH protocols it understands
    (shown in bold below):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 服务器提供的标语描述了它理解哪些 SSH 协议（以下内容加粗显示）：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The banner from 192.168.42.72 (loki) includes the string `SSH-1.99`, which,
    by convention, means that the server speaks both protocols 1 and 2\. Often, the
    SSH server will be configured with a line like `Protocol 2,1`, which also means
    the server speaks both protocols and tries to use SSH2 if possible. This is to
    retain backward compatibility, so SSH1-only clients can still connect.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 192.168.42.72（loki）的 banner 包含字符串 `SSH-1.99`，按照惯例，这意味着服务器支持协议 1 和 2。通常，SSH
    服务器会被配置为包含一行如 `Protocol 2,1`，这也意味着服务器支持这两种协议，并尽可能使用 SSH2。这是为了保持向后兼容性，以便仅支持 SSH1
    的客户端仍然可以连接。
- en: In contrast, the banner from 192.168.42.1 includes the string `SSH-2.0`, which
    shows that the server only speaks protocol 2\. In this case, it's obvious that
    any clients connecting to it have only communicated with SSH2 and therefore only
    have host fingerprints for protocol 2.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，来自 192.168.42.1 的 banner 包含字符串 `SSH-2.0`，这表明服务器只支持协议 2。在这种情况下，很明显，连接到它的任何客户端都只与
    SSH2 通信，因此只有协议 2 的主机指纹。
- en: The same is true for loki (192.168.42.72); however, loki also accepts SSH1,
    which has a different set of host fingerprints. It's unlikely that a client will
    have used SSH1, and therefore doesn't have the host fingerprints for this protocol
    yet.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 loki（192.168.42.72）来说，情况也是如此；然而，loki 还接受 SSH1，它有一组不同的主机指纹。不太可能客户端会使用 SSH1，因此还没有为该协议存储主机指纹。
- en: If the modified SSH daemon being used for the MitM attack forces the client
    to communicate using the other protocol, no host fingerprint will be found. Instead
    of being presented with a lengthy warning, the user will simply be asked to add
    the new fingerprint. The mitm-sshtool uses a configuration file similar to openssh's,
    since it's built from that code. By adding the line `Protocol 1` to /usr/local/etc/mitm-ssh_config,
    the mitm-ssh daemon will claim it only speaks the SSH1 protocol.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用于 MitM 攻击的修改后的 SSH 守护进程强制客户端使用其他协议进行通信，则不会找到任何主机指纹。用户不会看到冗长的警告，而是简单地被要求添加新的指纹。mitm-sshtool
    使用与 openssh 相似的配置文件，因为它是由该代码构建的。通过在 /usr/local/etc/mitm-ssh_config 中添加 `Protocol
    1` 行，mitm-ssh 守护进程将声称它只支持 SSH1 协议。
- en: The output below shows that loki's SSH server usually speaks using both SSH1
    and SSH2 protocols, but when mitm-ssh is put in the middle using the new configuration
    file, the fake server claims it only speaks SSH1 protocol.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示，loki 的 SSH 服务器通常使用 SSH1 和 SSH2 协议进行通信，但当使用新的配置文件将 mitm-ssh 放在中间时，伪造的服务器声称它只支持
    SSH1 协议。
- en: From 192.168.42.250 (tetsuo), Just an Innocent Machine on the Network
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 192.168.42.250（tetsuo），网络上的一个无辜的机器
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On the Attacker's Machine, Setting Up mitm-ssh to Only Use SSH1 Protocol
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在攻击者的机器上，设置 mitm-ssh 以仅使用 SSH1 协议
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now Back on 192.168.42.250 (tetsuo)
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在回到 192.168.42.250（tetsuo）
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Usually, clients such as tetsuo connecting to loki at 192.168.42.72 would have
    only communicated using SSH2\. Therefore, there would only be a host fingerprint
    for SSH protocol 2 stored on the client. When protocol 1 is forced by the MitM
    attack, the attacker's fingerprint won't be compared to the stored fingerprint,
    due to the differing protocols. Older implementations will simply ask to add this
    fingerprint since, technically, no host fingerprint exists for this protocol.
    This is shown in the output below.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像 tetsuo 这样的客户端连接到 192.168.42.72 的 loki 时，只会使用 SSH2 进行通信。因此，客户端上只会存储 SSH
    协议 2 的主机指纹。当 MitM 攻击强制使用协议 1 时，由于协议不同，攻击者的指纹将不会与存储的指纹进行比较。较旧的实现将简单地要求添加此指纹，因为技术上不存在此协议的主机指纹。这在下面的输出中显示。
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since this vulnerability was made public, newer implementations of OpenSSH
    have a slightly more verbose warning:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个漏洞已被公开，OpenSSH 的新版本实现有一个稍微更详细的警告：
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This modified warning isn't as strong as the warning given when host fingerprints
    of the same protocol don't match. Also, since not all clients will be up to date,
    this technique can still prove to be useful for an MitM attack.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改后的警告不如在相同协议的主机指纹不匹配时给出的警告强烈。此外，由于并非所有客户端都会更新，这种技术仍然可以证明对中间人攻击（MitM）是有用的。
- en: Fuzzy Fingerprints
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊指纹
- en: Konrad Rieck had an interesting idea regarding SSH host fingerprints. Often,
    a user will connect to a server from several different clients. The host fingerprint
    will be displayed and added each time a new client is used, and a security-conscious
    user will tend to remember the general structure of the host fingerprint. While
    no one actually memorizes the entire fingerprint, major changes can be detected
    with little effort. Having a general idea of what the host fingerprint looks like
    when connecting from a new client greatly increases the security of that connection.
    If an MitM attack is attempted, the blatant difference in host fingerprints can
    usually be detected by eye.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Konrad Rieck关于SSH主机指纹有一个有趣的想法。通常，用户会从几个不同的客户端连接到服务器。每次使用新的客户端时，都会显示并添加主机指纹，一个有安全意识的用户往往会记住主机指纹的一般结构。虽然没有人真正记住整个指纹，但通过一点努力就可以检测到主要的变化。当从新的客户端连接时，对主机指纹的一般了解大大增加了连接的安全性。如果尝试中间人攻击，主机指纹的明显差异通常可以通过肉眼检测到。
- en: However, the eye and the brain can be tricked. Certain fingerprints will look
    very similar to others. Digits 1 and 7 look very similar, depending on the display
    font. Usually, the hex digits found at the beginning and end of the fingerprint
    are remembered with the greatest clarity, while the middle tends to be a bit hazy.
    The goal behind the fuzzy fingerprint technique is to generate a host key with
    a fingerprint that looks similar enough to the original fingerprint to fool the
    human eye.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，眼睛和大脑可能会被骗。某些指纹看起来与其他指纹非常相似。数字1和7在显示字体不同的情况下看起来非常相似。通常，指纹开头和结尾找到的十六进制数字记得最清楚，而中间部分往往有点模糊。模糊指纹技术的目标是通过生成一个指纹看起来足够接近原始指纹，以至于可以欺骗人眼的主机密钥。
- en: The openssh package provides tools to retrieve the host key from servers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: openssh软件包提供了从服务器检索主机密钥的工具。
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that the host key fingerprint format is known for 192.168.42.72 (loki),
    fuzzy fingerprints can be generated that look similar. A program that does this
    has been developed by Rieck and is available at [http://www.thc.org/thc-ffp/](http://www.thc.org/thc-ffp/).
    The following output shows the creation of some fuzzy fingerprints for 192.168.42.72
    (loki).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已知192.168.42.72（loki）的主机密钥指纹格式，可以生成看起来相似的模糊指纹。Rieck开发了一个执行此操作的程序，可在[http://www.thc.org/thc-ffp/](http://www.thc.org/thc-ffp/)找到。以下输出显示了为192.168.42.72（loki）创建的一些模糊指纹。
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This fuzzy fingerprint generation process can go on for as long as desired.
    The program keeps track of some of the best fingerprints and will display them
    periodically. All of the state information is stored in /var/tmp/ffp.state, so
    the program can be exited with a CTRL-C and then resumed again later by simply
    running `ffp` without any arguments.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模糊指纹生成过程可以持续进行，直到所需的时间。程序会跟踪一些最好的指纹，并会定期显示它们。所有状态信息都存储在/var/tmp/ffp.state中，因此程序可以通过按CTRL-C退出，然后通过简单地运行`ffp`而不带任何参数来稍后再次继续。
- en: After running for a while, SSH host key pairs can be extracted from the state
    file with the `-e` switch.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一段时间后，可以使用`-e`开关从状态文件中提取SSH主机密钥对。
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, 10 public and private host key pairs have been generated.
    Fingerprints for these key pairs can then be generated and compared with the original
    fingerprint, as seen in the following output.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，生成了10个公钥和私钥的主机密钥对。然后可以生成这些密钥对的指纹，并与原始指纹进行比较，如下面的输出所示。
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From the 10 generated key pairs, the one that seems to look the most similar
    can be determined by eye. In this case, ssh-rsa02.pub, shown in bold, was chosen.
    Regardless of which key pair is chosen, though, it will certainly look more like
    the original fingerprint than any randomly generated key would.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成的10个密钥对中，可以通过肉眼判断出看起来最相似的一个。在这种情况下，被加粗显示的ssh-rsa02.pub被选中。然而，无论选择哪个密钥对，它看起来肯定比任何随机生成的密钥更像原始指纹。
- en: This new key can be used with mitm-ssh to make for an even more effective attack.
    The location for the host key is specified in the configuration file, so using
    the new key is simply matter of adding a `HostKey` line in /usr/local/etc/mitm-ssh_config,
    as shown below. Since we need to remove the `Protocol 1` line we added earlier,
    the output below simply overwrites the configuration file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的密钥可以与mitm-ssh一起使用，以进行更有效的攻击。主机密钥的位置在配置文件中指定，因此使用新密钥只需在/usr/local/etc/mitm-ssh_config中添加一个`HostKey`行，如下所示。由于我们需要删除之前添加的`Protocol
    1`行，下面的输出只是简单地覆盖了配置文件。
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In another terminal window, arpspoof is running to redirect the traffic to mitm-ssh,
    which will use the new host key with the fuzzy fingerprint. The output below compares
    the output a client would see when connecting.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，arpspoof正在运行，以将流量重定向到使用模糊指纹的新主机密钥的mitm-ssh。下面的输出比较了客户端在连接时看到的输出。
- en: Normal Connection
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正常连接
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: MitM-Attacked Connection
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间人攻击连接
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Can you immediately tell the difference? These fingerprints look similar enough
    to trick most people into simply accepting the connection.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你能立即分辨出差异吗？这些指纹看起来足够相似，足以欺骗大多数人简单地接受连接。
- en: Password Cracking
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码破解
- en: Passwords aren't generally stored in plaintext form. A file containing all the
    passwords in plaintext form would be far too attractive a target, so instead,
    a one-way hash function is used. The best-known of these functions is based on
    DES and is called `crypt()`, which is described in the manual page shown below.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 密码通常不会以明文形式存储。包含所有密码的明文文件会是一个极具吸引力的目标，因此，相反地，使用单向散列函数。这些函数中最著名的是基于DES的，称为`crypt()`，这在下面的手册页中有描述。
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a one-way hash function that expects a plaintext password and a salt
    value for input, and then outputs a hash with the salt value prepended to it.
    This hash is mathematically irreversible, meaning that it is impossible to determine
    the original password using only the hash. Writing a quick program to experiment
    with this function will help clarify any confusion.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单向散列函数，它期望输入明文密码和盐值，然后输出一个带有盐值前缀的散列。这个散列在数学上是不可逆的，这意味着仅使用散列无法确定原始密码。编写一个快速程序来实验这个函数将有助于澄清任何混淆。
- en: Password Cracking
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码破解
- en: crypt_test.c
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`crypt_test.c`'
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When this program is compiled, the crypt library needs to be linked. This is
    shown in the following output, along with some test runs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序编译时，需要链接crypt库。这在上面的输出中显示，以及一些测试运行。
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that in the last two runs, the same password is encrypted, but using
    different salt values. The salt value is used to perturb the algorithm further,
    so there can be multiple hash values for the same plaintext value if different
    salt values are used. The hash value (including the prepended salt) is stored
    in the password file under the premise that if an attacker were to steal the password
    file, the hashes would be useless.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后两次运行中，使用了相同的密码进行加密，但使用了不同的盐值。盐值被用来进一步扰动算法，因此如果使用不同的盐值，相同的明文值可以有多个散列值。散列值（包括前缀的盐值）在密码文件中存储，前提是如果攻击者窃取了密码文件，散列值将毫无用处。
- en: When a legitimate user needs to authenticate using the password hash, that user's
    hash is looked up in the password file. The user is prompted to enter her password,
    the original salt value is extracted from the password file, and whatever the
    user types is sent through the same one-way hash function with the salt value.
    If the correct password was entered, the one-way hashing function will produce
    the same hash output as is stored in the password file. This allows authentication
    to function as expected, without ever having to store the plaintext password.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个合法用户需要使用密码散列进行身份验证时，该用户的散列值会在密码文件中进行查找。系统会提示用户输入她的密码，从密码文件中提取原始的盐值，然后将用户输入的内容通过相同的单向散列函数与盐值一起处理。如果输入了正确的密码，单向散列函数将产生与密码文件中存储的散列值相同的输出。这允许身份验证按预期工作，而无需存储明文密码。
- en: Dictionary Attacks
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典攻击
- en: It turns out, however, that the encrypted passwords in the password file aren't
    so useless after all. Sure, it's mathematically impossible to reverse the hash,
    but it is possible to just quickly hash every word in a dictionary, using the
    salt value for a specific hash, and then compare the result with that hash. If
    the hashes match, then that word from the dictionary must be the plaintext password.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事实表明，密码文件中的加密密码并非毫无用处。当然，从数学上讲，无法逆向散列，但可以使用特定的盐值快速散列字典中的每个单词，并将结果与该散列值进行比较。如果散列值匹配，那么字典中的那个单词必须是明文密码。
- en: A simple dictionary attack program can be whipped up fairly easily. It just
    needs to read words from a file, hash each one using the proper salt value, and
    display the word if there is a match. The following source code does this using
    filestream functions, which are included with stdio.h. These functions are easier
    to work with, since they wrap up the messiness of `open()` calls and file descriptors,
    using FILE structure pointers, instead. In the source below, the `fopen()` call's
    `r` argument tells it to open the file for reading. It returns NULL on failure,
    or a pointer to the open filestream. The `fgets()` call gets a string from the
    filestream, up to a maximum length or when it reaches the end of a line. In this
    case, it's used to read each line from the word-list file. This function also
    returns NULL on failure, which is used to detect then end of the file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的字典攻击程序可以很容易地制作出来。它只需要从文件中读取单词，使用适当的盐值对每个单词进行散列，并在找到匹配项时显示该单词。以下源代码使用文件流函数实现，这些函数包含在
    stdio.h 中。这些函数更容易处理，因为它们使用 FILE 结构指针封装了 `open()` 调用和文件描述符的混乱，而不是直接使用。在下面的源代码中，`fopen()`
    调用的 `r` 参数告诉它以读取模式打开文件。如果失败，它返回 NULL，或者指向打开的文件流。`fgets()` 调用从文件流中获取一个字符串，直到达到最大长度或遇到行尾。在这种情况下，它用于从单词列表文件中读取每一行。此函数在失败时也返回
    NULL，这被用来检测文件末尾。
- en: crypt_crack.c
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: crypt_crack.c
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The following output shows this program being used to crack the password hash
    *jeHEAX1m66RV.*, using the words found in /usr/share/dict/words.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了该程序被用来破解密码散列 *jeHEAX1m66RV.*，使用了位于 /usr/share/dict/words 中的单词。
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since the word *test* was the original password and this word is found in the
    words file, the password hash will eventually be cracked. This is why it's considered
    poor security practice to use passwords that are dictionary words or based on
    dictionary words.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单词 *test* 是原始密码，并且这个单词在单词文件中存在，密码散列最终会被破解。这就是为什么使用基于字典单词的密码被认为是不安全的做法。
- en: 'The downside to this attack is that if the original password isn''t a word
    found in the dictionary file, the password won''t be found. For example, if a
    non-dictionary word such as `h4R%` is used as a password, the dictionary attack
    won''t be able to find it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的缺点是，如果原始密码不是字典文件中找到的单词，密码将不会被找到。例如，如果使用像`h4R%`这样的非字典单词作为密码，字典攻击将无法找到它：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Custom dictionary files are often made using different languages, standard modifications
    of words (such as transforming letters to numbers), or simply appending numbers
    to the end of each word. While a bigger dictionary will yield more passwords,
    it will also take more time to process.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 定制的字典文件通常使用不同的语言、单词的标准修改（例如将字母转换为数字）或简单地在每个单词的末尾添加数字来创建。虽然更大的字典会产生更多的密码，但它也会花费更多的时间来处理。
- en: Exhaustive Brute-Force Attacks
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极端暴力破解攻击
- en: A dictionary attack that tries every single possible combination is an *exhaustive
    brute-force* attack. While this type of attack will technically be able to crack
    every conceivable password, it will probably take longer than your grandchildren's
    grandchildren would be willing to wait.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试每个可能组合的字典攻击是 *极端暴力破解* 攻击。虽然这种攻击在技术上能够破解每个可能的密码，但它可能需要比你的曾孙们的曾孙愿意等待的时间更长。
- en: With 95 possible input characters for `crypt()-`style passwords, there are 95⁸
    possible passwords for an exhaustive search of all eight-character passwords,
    which works out to be over seven quadrillion possible passwords. This number gets
    so big so quickly because, as another character is added to the password length,
    the number of possible passwords grows exponentially. Assuming 10,000 cracks per
    second, it would take about 22,875 years to try every password. Distributing this
    effort across many machines and processors is one possible approach; however,
    it is important to remember that this will only achieve a linear speedup. If one
    thousand machines were combined, each capable of 10,000 cracks per second, the
    effort would still take over 22 years. The linear speedup achieved by adding another
    machine is marginal compared to the growth in keyspace when another character
    is added to the password length.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`crypt()-`风格的密码，有95个可能的输入字符，对于穷举搜索所有八字符密码，有95⁸种可能的密码，这相当于超过七十万亿种可能的密码。这个数字增长得如此之快，是因为随着密码长度的增加，可能的密码数量呈指数增长。假设每秒可以破解10000次，尝试每一个密码需要大约22875年。将这个努力分散到多台机器和处理器上是一种可能的方法；然而，重要的是要记住，这只会实现线性加速。如果有一千台机器组合起来，每台机器每秒可以破解10000次，这个努力仍然需要超过22年。添加另一台机器实现的线性加速与增加一个字符到密码长度时密钥空间增长相比是微不足道的。
- en: Luckily, the inverse of the exponential growth is also true; as characters are
    removed from the password length, the number of possible passwords decreases exponentially.
    This means that a four-character password only has 95⁴ possible passwords. This
    keyspace has only about 84 million possible passwords, which can be exhaustively
    cracked (assuming 10,000 cracks per second) in a little over two hours. This means
    that, even though a password like `h4R%` isn't in any dictionary, it can be cracked
    in a reasonable amount of time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，指数增长的逆命题也是成立的；随着密码长度的减少，可能的密码数量以指数方式减少。这意味着一个四字符的密码只有95⁴种可能的密码。这个密钥空间只有大约8400万种可能的密码，在超过两小时内就可以被穷举破解（假设每秒可以破解10000次）。这意味着，即使像`h4R%`这样的密码不在任何字典中，也可以在合理的时间内被破解。
- en: This means that, in addition to avoiding dictionary words, password length is
    also important. Since the complexity scales up exponentially, doubling the length
    to produce an eight-character password should bring the level of effort required
    to crack the password into the unreasonable time frame.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，除了避免字典单词外，密码长度也很重要。由于复杂性呈指数增长，将长度加倍以生成一个八字符密码应该会将破解密码所需的工作量降低到不合理的时间范围内。
- en: Solar Designer has developed a password-cracking program called John the Ripper
    that uses first a dictionary attack and then an exhaustive brute-force attack.
    This program is probably the most popular one of its kind; it is available at
    [http://www.openwall.com/john](http://www.openwall.com/john). It has been included
    on the LiveCD.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Solar Designer 开发了一个名为John the Ripper的密码破解程序，该程序首先使用字典攻击，然后进行穷举暴力攻击。这个程序可能是这一类中最受欢迎的；它可以在[http://www.openwall.com/john](http://www.openwall.com/john)找到。它已经被包含在LiveCD中。
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this output, the account jose is shown to have the password of `testing7`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，账户jose显示的密码是`testing7`。
- en: Hash Lookup Table
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希查找表
- en: Another interesting idea for password cracking is using a giant hash lookup
    table. If all the hashes for all possible passwords were precomputed and stored
    in a searchable data structure somewhere, any password could be cracked in the
    time it takes to search. Assuming a binary search, this time would be about O(log[2]
    *N*), where *N* is the number of entries. Since *N* is 95⁸ in the case of eight-character
    passwords, this works out to about O(8 log[2] 95), which is quite fast.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的密码破解想法是使用巨大的哈希查找表。如果所有可能的密码的哈希值都预先计算并存储在某个可搜索的数据结构中，任何密码都可以在搜索所需的时间内被破解。假设使用二分搜索，这个时间将是O(log[2]
    *N*)，其中*N*是条目数。由于*N*在八字符密码的情况下是95⁸，这相当于O(8 log[2] 95)，这相当快。
- en: However, a hash lookup table like this would require about 100,000 terabytes
    of storage. In addition, the design of the password-hashing algorithm takes this
    type of attack into consideration and mitigates it with the salt value. Since
    multiple plaintext passwords will hash to different password hashes with different
    salts, a separate lookup table would have to be created for each salt. With the
    DES-based `crypt()` function, there are 4,096 possible salt values, which means
    that even for a smaller keyspace, such as all possible four-character passwords,
    a hash lookup table becomes impractical. With a fixed salt, the storage space
    needed for a single lookup table for all possible four-character passwords is
    about one gigabyte, but because of the salt values, there are 4,096 possible hashes
    for a single plaintext password, necessitating 4,096 different tables. This raises
    the needed storage space up to about 4.6 terabytes, which greatly dissuades such
    an attack.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的哈希查找表需要大约100,000太字节（TB）的存储空间。此外，密码散列算法的设计考虑了这种攻击，并通过盐值来减轻它。由于多个明文密码会散列成具有不同盐的不同密码散列，因此必须为每个盐创建一个单独的查找表。基于DES的`crypt()`函数有4,096种可能的盐值，这意味着即使对于较小的密钥空间，例如所有可能的四字符密码，哈希查找表也变得不切实际。使用固定的盐，所有可能的四字符密码的单个查找表所需的存储空间大约为1吉字节（GB），但由于盐值，单个明文密码有4,096种可能的哈希，需要4,096个不同的表。这使得所需的存储空间增加到大约4.6TB，这大大阻止了此类攻击。
- en: Password Probability Matrix
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码概率矩阵
- en: There is a trade-off between computational power and storage space that exists
    everywhere. This can be seen in the most elementary forms of computer science
    and everyday life. MP3 files use compression to store a high-quality sound file
    in a relatively small amount of space, but the demand for computational resources
    increases. Pocket calculators use this trade-off in the other direction by maintaining
    a lookup table for functions such as sine and cosine to save the calculator from
    doing heavy computations.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 计算能力和存储空间之间的权衡无处不在。这可以在计算机科学的最基本形式和日常生活中看到。MP3文件使用压缩来存储高质量的声音文件，在相对较小的空间内，但计算资源的需求增加。便携式计算器通过为正弦和余弦等函数维护查找表来使用这种权衡，以节省计算器进行繁重计算。
- en: 'This trade-off can also be applied to cryptography in what has become known
    as a time/space trade-off attack. While Hellman''s methods for this type of attack
    are probably more efficient, the following source code should be easier to understand.
    The general principle is always the same, though: Try to find the sweet spot between
    computational power and storage space, so that an exhaustive brute-force attack
    can be completed in a reasonable amount of time, using a reasonable amount of
    space. Unfortunately, the dilemma of salts will still present itself, since this
    method still requires some form of storage. However, there are only 4,096 possible
    salts with `crypt()`-style password hashes, so the effect of this problem can
    be diminished by reducing the needed storage space far enough to remain reasonable
    despite the 4,096 multiplier.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这种权衡也可以应用于密码学，被称为时间/空间权衡攻击。虽然赫尔曼（Hellman）针对此类攻击的方法可能更有效率，但以下源代码应该更容易理解。尽管如此，一般原则始终相同：尝试在计算能力和存储空间之间找到最佳平衡点，以便在合理的时间内，使用合理的空间完成穷举暴力攻击。不幸的是，盐的困境仍然存在，因为这种方法仍然需要某种形式的存储。然而，对于`crypt()`风格的密码散列，只有4,096种可能的盐，因此可以通过减少所需的存储空间来减轻这个问题的影响，尽管有4,096的乘数，但仍然保持合理。
- en: This method uses a form of lossy compression. Instead of having an exact hash
    lookup table, several thousand possible plaintext values will be returned when
    a password hash is entered. These values can be checked quickly to converge on
    the original plaintext password, and the lossy compression allows for a major
    space reduction. In the demonstration code that follows, the keyspace for all
    possible four-character passwords (with a fixed salt) is used. The storage space
    needed is reduced by 88 percent, compared to a full hash lookup table (with a
    fixed salt), and the keyspace that must be brute-forced through is reduced by
    about 1,018 times. Under the assumption of 10,000 cracks per second, this method
    can crack any four-character password (with a fixed salt) in under eight seconds,
    which is a considerable speedup when compared to the two hours needed for an exhaustive
    bruteforce attack of the same keyspace.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'This method builds a three-dimensional binary matrix that correlates parts
    of the hash values with parts of the plaintext values. On the x-axis, the plaintext
    is split into two pairs: the first two characters and the second two characters.
    The possible values are enumerated into a binary vector that is 95², or 9,025,
    bits long (about 1,129 bytes). On the y-axis, the ciphertext is split into four
    three-character chunks. These are enumerated the same way down the columns, but
    only four bits of the third character are actually used. This means there are
    64².4, or 16,384, columns. The z-axis exists simply to maintain eight different
    two-dimensional matrices, so four exist for each of the plaintext pairs.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to split the plaintext into two paired values that are enumerated
    along a vector. Every possible plaintext is hashed into ciphertext, and the ciphertext
    is used to find the appropriate column of the matrix. Then the plaintext enumeration
    bit across the row of the matrix is turned on. When the ciphertext values are
    reduced into smaller chunks, collisions are inevitable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '| Plaintext | Hash |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| test | je**HEA**X1m66RV. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| !J)h | je**HEA**38vqlkkQ |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| ".F+ | je**HEA**1Tbde5FE |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| "8,J | je**HEA**nX8kQK3I |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: In this case, the column for `HEA` would have the bits corresponding to the
    plaintext pairs `te, !J,` "., and `"8` turned on, as these plaintext/hash pairs
    are added to the matrix.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: After the matrix is completely filled out, when a hash such as `jeHEA38vqlkkQ`
    is entered, the column for `HEA` will be looked up, and the two-dimensional matrix
    will return the values `te, !J`, "., and `"8` for the first two characters of
    the plaintext. There are four matrices like this for the first two characters,
    using ciphertext substring from characters 2 through 4, 4 through 6, 6 though
    8, and 8 though 10, each with a different vector of possible first two-character
    plaintext values. Each vector is pulled, and they are combined with a bitwise
    AND. This will leave only those bits turned on that correspond to the plaintext
    pairs listed as possibilities for each substring of ciphertext. There are also
    four matrices like this for the last two characters of plaintext.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵完全填满后，当输入一个如 `jeHEA38vqlkkQ` 这样的哈希时，将查找 `HEA` 的列，二维矩阵将返回明文前两个字符的值 `te, !J`,
    "., 和 `"8`。对于前两个字符，有四个这样的矩阵，使用从字符 2 到 4、4 到 6、6 到 8 和 8 到 10 的密文子串，每个矩阵都有不同的一组可能的前两个字符明文值向量。每个向量被提取出来，并通过位与操作组合。这将仅留下与每个密文子串中列出的明文对对应的位被打开。对于明文最后两个字符也有四个这样的矩阵。
- en: 'The sizes of the matrices were determined by the pigeonhole principle. This
    is a simple principle that states: If *k* + 1 objects are put into *k* boxes,
    at least one of the boxes will contain two objects. So, to get the best results,
    the goal is for each vector to be a little bit less than half full of 1s. Since
    95⁴, or 81,450,625, entries will be put in the matrices, there need to be about
    twice as many holes to achieve 50 percent saturation. Since each vector has 9,025
    entries, there should be about (95⁴ · 2) / 9025 columns. This works out to be
    about 18,000 columns. Since ciphertext substrings of three characters are being
    used for the columns, the first two characters and four bits from the third character
    are used to provide 64² · 4, or about 16 thousand columns (there are only 64 possible
    values for each character of ciphertext hash). This should be close enough, because
    when a bit is added twice, the overlap is ignored. In practice, each vector turns
    out to be about 42 percent saturated with 1s.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的大小是由鸽巢原理确定的。这是一个简单的原理，其表述为：如果将 *k* + 1 个对象放入 *k* 个盒子中，至少有一个盒子将包含两个对象。因此，为了获得最佳结果，目标是让每个向量中的
    1s 数量略少于一半。由于矩阵中将放入 95⁴，即 81,450,625 个条目，因此需要大约两倍数量的空位来实现 50% 的饱和度。由于每个向量有 9,025
    个条目，因此应有大约 (95⁴ · 2) / 9025 列。这计算出来大约是 18,000 列。由于正在使用三个字符的密文子串作为列，因此前两个字符和第三个字符的前四个位被用来提供
    64² · 4，即大约 16,000 列（密文哈希的每个字符都有 64 种可能的值）。这应该足够接近，因为当位被添加两次时，重叠被忽略。在实践中，每个向量最终大约有
    42% 的 1s 饱和度。
- en: Since there are four vectors that are pulled for a single ciphertext, the probability
    of any one enumeration position having a 1 value in each vector is about 0.42⁴,
    or about 3.11 percent. This means that, on average, the 9,025 possibilities for
    the first two characters of plaintext are reduced by about 97 percent to 280 possibilities.
    This is also done for the last two characters, providing about 280², or 78,400,
    possible plaintext values. Under the assumption of 10,000 cracks per second, this
    reduced keyspace would take under 8 seconds to check.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于为单个密文提取了四个向量，因此每个向量中任何一位为 1 的概率大约是 0.42⁴，即大约 3.11%。这意味着，平均而言，明文前两个字符的 9,025
    种可能性减少了大约 97%，变为 280 种可能性。这也适用于最后两个字符，提供了大约 280²，即 78,400 个可能的明文值。在每秒 10,000 次破解的假设下，这个减少后的密钥空间将在
    8 秒内被检查完毕。
- en: Of course, there are downsides. First, it takes at least as long to create the
    matrix as the original brute-force attack would have taken; however, this is a
    one-time cost. Also, the salts still tend to prohibit any type of storage attack,
    even with the reduced storage-space requirements.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法也有缺点。首先，创建矩阵所需的时间至少与原始的暴力攻击所需的时间一样长；然而，这是一个一次性成本。此外，盐值仍然倾向于防止任何类型的存储攻击，即使是在减少存储空间需求的情况下。
- en: The following two source code listings can be used to create a password probability
    matrix and crack passwords with it. The first listing will generate a matrix that
    can be used to crack all possible four-character passwords salted with `je`. The
    second listing will use the generated matrix to actually do the password cracking.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个源代码列表可以用来创建密码概率矩阵并使用它破解密码。第一个列表将生成一个可以用来破解所有可能的四个字符密码（盐值为 `je`）的矩阵。第二个列表将使用生成的矩阵实际进行密码破解。
- en: ppm_gen.c
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ppm_gen.c
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first piece of code, ppm_gen.c, can be used to generate a fourcharacter
    password probability matrix, as shown in the output below. The `-O3` option passed
    to GCC tells it to optimize the code for speed when it compiles.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码，`ppm_gen.c`，可以用来生成一个四字符密码概率矩阵，如下面的输出所示。传递给GCC的`-O3`选项告诉它在编译时优化代码以提高速度。
- en: '[PRE30]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The 142MB 4char.ppm file contains loose associations between the plaintext and
    hash data for every possible four-character password. This data can then be used
    by this next program to quickly crack four-character passwords that would foil
    a dictionary attack.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 142MB的4char.ppm文件包含了每个可能的四字符密码的明文和哈希数据之间的松散关联。然后，这些数据可以由下一个程序用来快速破解那些能够阻止字典攻击的四字符密码。
- en: ppm_crack.c
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ppm_crack.c
- en: '[PRE31]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second piece of code, ppm_crack.c, can be used to crack the troublesome
    password of `h4R%` in a matter of seconds:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段代码，`ppm_crack.c`，可以在几秒钟内破解`h4R%`这个棘手的密码：
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These programs are proof-of-concept hacks, which take advantage of the bit diffusion
    provided by hash functions. There are other time-space trade-off attacks, and
    some have become quite popular. RainbowCrack is a popular tool, which has support
    for multiple algorithms. If you want to learn more, consult the Internet.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序是概念验证型黑客攻击，利用了哈希函数提供的位扩散。还有其他时间-空间权衡攻击，其中一些已经变得相当流行。RainbowCrack是一个流行的工具，它支持多种算法。如果你想了解更多，请咨询互联网。
- en: Wireless 802.11b Encryption
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线802.11b加密
- en: Wireless 802.11b security has been a big issue, primarily due to the absence
    of it. Weaknesses in *Wired Equivalent Privacy (WEP)*, the encryption method used
    for wireless, contribute greatly to the overall insecurity. There are other details,
    sometimes ignored during wireless deployments, which can also lead to major vulnerabilities.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 无线802.11b的安全性一直是一个大问题，主要是因为其缺乏安全性。用于无线的*有线等效保密（WEP）*的弱点对整体的不安全性贡献很大。还有一些其他细节，在无线部署过程中有时会被忽略，也可能导致重大漏洞。
- en: The fact that wireless networks exist on layer 2 is one of these details. If
    the wireless network isn't VLANed off or firewalled, an attacker associated to
    the wireless access point could redirect all the wired network traffic out over
    the wireless via ARP redirection. This, coupled with the tendency to hook wireless
    access points to internal private networks, can lead to some serious vulnerabilities.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 无线网络存在于第2层是这些细节之一。如果无线网络没有被VLAN隔离或防火墙保护，那么与无线接入点关联的攻击者可以通过ARP重定向将所有有线网络流量重定向到无线网络。这一点，加上将无线接入点连接到内部私有网络的倾向，可能导致一些严重的安全漏洞。
- en: Of course, if WEP is turned on, only clients with the proper WEP key will be
    allowed to associate to the access point. If WEP is secure, there shouldn't be
    any concern about rogue attackers associating and causing havoc. This begs the
    question, "How secure is WEP?"
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果启用了WEP，只有具有正确WEP密钥的客户端才能被允许与接入点关联。如果WEP是安全的，那么就不应该有任何关于恶意攻击者关联并造成混乱的担忧。这引发了一个问题：“WEP有多安全？”
- en: Wired Equivalent Privacy
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有线等效保密
- en: WEP was meant to be an encryption method providing security equivalent to a
    wired access point. It was originally designed with 40-bit keys; later, WEP2 came
    along to increase the key size to 104 bits. All of the encryption is done on a
    per-packet basis, so each packet is essentially a separate plaintext message to
    send. The packet will be called *M*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: WEP原本是一个旨在提供与有线接入点相当安全性的加密方法。它最初设计为40位密钥；后来，WEP2出现，将密钥大小增加到104位。所有的加密都是基于每个数据包进行的，因此每个数据包本质上是一个单独的明文消息，需要发送。这个数据包将被称为*M*。
- en: 'First, a checksum of message M is computed, so the message integrity can be
    checked later. This is done using a 32-bit cyclic redundancy checksum function
    aptly named CRC32\. This checksum will be called *CS*, so CS = CRC32(M). This
    value is appended to the end of the message, which makes up the plaintext message
    P:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算消息M的校验和，以便稍后可以检查消息的完整性。这是使用名为CRC32的32位循环冗余校验函数完成的。这个校验和将被称为*CS*，所以CS =
    CRC32(M)。这个值将被附加到消息的末尾，从而构成明文消息P：
- en: '![](httpatomoreillycomsourcenostarchimages254289.png.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254289.png.jpg)'
- en: Figure 0x700-2.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x700-2。
- en: Now, the plaintext message needs to be encrypted. This is done using RC4, which
    is a stream cipher. This cipher, initialized with a seed value, can generate a
    keystream, which is just an arbitrarily long stream of pseudorandom bytes. WEP
    uses an initialization vector (IV) for the seed value. The IV consists of 24 bits
    generated for each packet. Some older WEP implementations simply use sequential
    values for the IV, while others use some form of pseudo-randomizer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要加密明文消息。这是使用RC4完成的，RC4是一种流密码。这个密码，初始化时使用种子值，可以生成一个密钥流，这只是一个任意长度的伪随机字节流。WEP使用初始化向量（IV）作为种子值。IV为每个数据包生成24位。一些较老的WEP实现简单地使用IV的顺序值，而其他一些则使用某种形式的伪随机化器。
- en: Regardless of how the 24 bits of IV are chosen, they are prepended to the WEP
    key. (These 24 bits of IV are included in the WEP key size in a bit of clever
    marketing spin; when a vendor talks about 64-bit or 128-bit WEP keys, the actual
    keys are only 40 bits and 104 bits, respectively, combined with 24 bits of IV.)
    The IV and the WEP key together make up the seed value, which will be called S.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何选择24位的初始化向量（IV），它们都会被添加到WEP密钥之前。（这24位的IV包含在WEP密钥大小中，这是一种巧妙的营销策略；当供应商谈论64位或128位的WEP密钥时，实际密钥只有40位和104位，分别与24位的IV结合。）IV和WEP密钥一起构成种子值，这个值将被称为S。
- en: '![](httpatomoreillycomsourcenostarchimages254242.png.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254242.png.jpg)'
- en: Figure 0x700-3.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x700-3。
- en: Then the seed value S is fed into RC4, which will generate a keystream. This
    keystream is XORed with the plaintext message P to produce the ciphertext C. The
    IV is prepended to the ciphertext, and the whole thing is encapsulated with yet
    another header and sent out over the radio link.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将种子值S输入到RC4中，这将生成一个密钥流。这个密钥流与明文消息P进行XOR运算，以产生密文C。IV被添加到密文之前，整个内容被另一个头部封装，并通过无线电链路发送出去。
- en: '![](httpatomoreillycomsourcenostarchimages254525.png.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254525.png.jpg)'
- en: Figure 0x700-4.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x700-4。
- en: When the recipient receives a WEP-encrypted packet, the process is simply reversed.
    The recipient pulls the IV from the message and then concatenates the IV with
    his own WEP key to produce a seed value of S. If the sender and receiver both
    have the same WEP key, the seed values will be the same. This seed is fed into
    RC4 again to produce the same keystream, which is XORed with the rest of the encrypted
    message. This will produce the original plaintext message, consisting of the packet
    message M concatenated with the integrity checksum CS. The recipient then uses
    the same CRC32 function to recalculate the checksum for M and checks that the
    calculated value matches the received value of CS. If the checksums match, the
    packet is passed on. Otherwise, there were too many transmission errors or the
    WEP keys didn't match, and the packet is dropped.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收方收到一个WEP加密的数据包时，过程简单地相反。接收方从消息中提取IV，然后将IV与其自己的WEP密钥连接起来，以产生种子值S。如果发送方和接收方都有相同的WEP密钥，种子值将是相同的。这个种子值再次输入到RC4中，以产生相同的密钥流，这个密钥流与加密消息的其余部分进行XOR运算。这将产生原始的明文消息，由数据包消息M和完整性校验和CS连接而成。接收方然后使用相同的CRC32函数重新计算M的校验和，并检查计算值是否与接收到的CS值匹配。如果校验和匹配，则数据包被传递。否则，存在过多的传输错误或WEP密钥不匹配，数据包将被丢弃。
- en: That's basically WEP in a nutshell.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是WEP的精髓。
- en: RC4 Stream Cipher
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RC4流密码
- en: 'RC4 is a surprisingly simple algorithm. It consists of two algorithms: the
    Key Scheduling Algorithm (KSA) and the Pseudo-Random Generation Algorithm (PRGA).
    Both of these algorithms use an *8-by-8 S-box*, which is just an array of 256
    numbers that are both unique and range in value from 0 to 255\. Stated simply,
    all the numbers from 0 to 255 exist in the array, but they''re all just mixed
    up in different ways. The KSA does the initial scrambling of the S-box, based
    on the seed value fed into it, and the seed can be up to 256 bits long.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: RC4是一个非常简单的算法。它由两个算法组成：密钥调度算法（KSA）和伪随机生成算法（PRGA）。这两个算法都使用一个*8-by-8 S-box*，这只是一个包含256个数字的数组，这些数字都是唯一的，并且数值范围从0到255。简单来说，从0到255的所有数字都存在于这个数组中，但它们以不同的方式混合在一起。KSA根据输入的种子值对S-box进行初始打乱，种子值可以长达256位。
- en: First, the S-box array is filled with sequential values from 0 to 255\. This
    array will be aptly named *S*. Then, another 256-byte array is filled with the
    seed value, repeating as necessary until the entire array is filled. This array
    will be named *K*. Then the *S* array is scrambled using the following pseudo-code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，S盒数组用从0到255的顺序值填充。这个数组将被恰当地命名为*S*。然后，另一个256字节的数组用种子值填充，必要时重复，直到整个数组被填满。这个数组将被命名为*K*。然后使用以下伪代码对*S*数组进行打乱。
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once that is done, the S-box is all mixed up based on the seed value. That's
    the key scheduling algorithm. Pretty simple.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，S盒根据种子值进行混合。这就是密钥调度算法。相当简单。
- en: Now when keystream data is needed, the Pseudo-Random Generation Algorithm (PRGA)
    is used. This algorithm has two counters, `i` and `j`, which are both initialized
    at `0` to begin with. After that, for each byte of keystream data, the following
    pseudo-code is used.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当需要密钥流数据时，使用伪随机生成算法（PRGA）。此算法有两个计数器，`i`和`j`，最初都初始化为`0`。之后，对于每个密钥流字节，使用以下伪代码。
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The outputted byte of `S[t]` is the first byte of the keystream. This algorithm
    is repeated for additional keystream bytes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`S[t]`输出的字节是密钥流的第一个字节。此算法会重复用于生成额外的密钥流字节。'
- en: RC4 is simple enough that it can be easily memorized and implemented on the
    fly, and it is quite secure if used properly. However, there are a few problems
    with the way RC4 is used for WEP.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: RC4足够简单，可以轻松记忆并在现场实现，如果使用得当，它相当安全。然而，RC4用于WEP的方式存在一些问题。
- en: WEP Attacks
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WEP攻击
- en: There are several problems with the security of WEP. In all fairness, it was
    never meant to be a strong cryptographic protocol, but rather a way to provide
    a wired equivalency, as alluded to by the acronym. Aside from the security weaknesses
    relating to association and identities, there are several problems with the cryptographic
    protocol itself. Some of these problems stem from the use of CRC32 as a checksum
    function for message integrity, and other problems stem from the way IVs are used.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: WEP的安全问题有几个。公平地说，它从未打算成为一个强大的加密协议，而是一种提供有线等效性的方式，正如其缩写词所暗示的。除了与关联和身份相关的安全弱点外，加密协议本身也存在几个问题。其中一些问题源于使用CRC32作为消息完整性的校验和函数，而其他问题则源于IV的使用方式。
- en: Offline Brute-Force Attacks
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离线暴力破解攻击
- en: 'Brute forcing will always be a possible attack on any computationally secure
    cryptosystem. The only question that remains is whether it''s a practical attack
    or not. With WEP, the actual method of offline brute forcing is simple: Capture
    a few packets, then try to decrypt the packets using every possible key. Next,
    recalculate the checksum for the packet, and compare this with the original checksum.
    If they match, then that''s most likely the key. Usually, this needs to be done
    with at least two packets, since it''s likely that a single packet can be decrypted
    with an invalid key yet the checksum will still be valid.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力破解始终是针对任何计算安全密码系统的可能攻击。唯一剩下的问题是它是否是一种实际可行的攻击。对于WEP，实际的离线暴力破解方法很简单：捕获几个数据包，然后尝试使用每个可能的关键字解密这些数据包。接下来，重新计算数据包的校验和，并将其与原始校验和进行比较。如果它们匹配，那么这很可能是正确的密钥。通常，这至少需要两个数据包，因为很可能单个数据包可以用无效的密钥解密，但校验和仍然有效。
- en: However, under the assumption of 10,000 cracks per second, brute forcing through
    the 40-bit keyspace would take over three years. Realistically, modern processors
    can achieve more than 10,000 cracks per second, but even at 200,000 cracks per
    second, this would take a few months. Depending on the resources and dedication
    of an attacker, this type of attack may or may not be feasible.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设每秒尝试10,000次破解，通过40位密钥空间进行暴力破解将需要超过三年时间。实际上，现代处理器每秒可以完成超过10,000次破解，但即使每秒200,000次，这也需要几个月的时间。根据攻击者的资源和投入，这种攻击可能可行也可能不可行。
- en: Tim Newsham has provided an effective cracking method that attacks weaknesses
    in the password-based key-generation algorithm that is used by most 40-bit (marketed
    as 64-bit) cards and access points. His method effectively reduces the 40-bit
    keyspace down to 21 bits, which can be cracked in a matter of minutes under the
    assumption of 10,000 cracks per second (and in a matter of seconds on a modern
    processor). More information on his methods can be found at [http://www.lava.net/~newsham/wlan](http://www.lava.net/~newsham/wlan).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Tim Newsham 提供了一种有效的破解方法，该方法攻击了大多数 40 位（市场上标称为 64 位）卡和接入点使用的基于密码的密钥生成算法的弱点。他的方法有效地将
    40 位密钥空间减少到 21 位，在每秒 10,000 次破解的假设下，可以在几分钟内破解（在现代处理器上只需几秒钟）。有关他的方法的更多信息，请参阅 [http://www.lava.net/~newsham/wlan](http://www.lava.net/~newsham/wlan)。
- en: For 104-bit (marketed as 128-bit) WEP networks, brute-forcing just isn't feasible.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 104 位（市场上标称为 128 位）的 WEP 网络，暴力破解根本不可行。
- en: Keystream Reuse
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥流重复使用
- en: Another potential problem with WEP lies in keystream reuse. If two plaintexts
    (*P* ) are XORed with the same keystream to produce two separate ciphertexts (*C*),
    XORing those ciphertexts together will cancel out the keystream, resulting in
    the two plaintexts XORed with each other.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: WEP 的另一个潜在问题是密钥流的重复使用。如果两个明文（*P*）与相同的密钥流进行 XOR 操作以生成两个不同的密文（*C*），则将这些密文进行 XOR
    操作将取消密钥流，导致两个明文相互 XOR。
- en: '| *C[1] = P[1]* ⊕ RC4(seed) |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| *C[1] = P[1]* ⊕ RC4(seed) |'
- en: '| *C[2] = P[2]* ⊕ RC4(seed) |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| *C[2] = P[2]* ⊕ RC4(seed) |'
- en: '| *C[1] ⊕ C[2] = [P[1]* ⊕ RC4(seed)] ⊕ [*P[2]* ⊕ RC4(seed)] = *P[1] ⊕ P[2]*
    |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| *C[1] ⊕ C[2] = [P[1]* ⊕ RC4(seed)] ⊕ [*P[2]* ⊕ RC4(seed)] = *P[1] ⊕ P[2]*
    |'
- en: From here, if one of the plaintexts is known, the other one can easily be recovered.
    In addition, since the plaintexts in this case are Internet packets with a known
    and fairly predictable structure, various techniques can be employed to recover
    both original plaintexts.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，如果已知其中一个明文，另一个可以轻易恢复。此外，由于在这种情况下明文是具有已知且相当可预测结构的互联网数据包，可以采用各种技术来恢复原始的明文。
- en: The IV is intended to prevent these types of attacks; without it, every packet
    would be encrypted with the same keystream. If a different IV is used for each
    packet, the keystreams for packets will also be different. However, if the same
    IV is reused, both packets will be encrypted with the same keystream. This is
    a condition that is easy to detect, since the IVs are included in plaintext in
    the encrypted packets. Moreover, the IVs used for WEP are only 24 bits in length,
    which nearly guarantees that IVs will be reused. Assuming that IVs are chosen
    at random, statistically there should be a case of keystream reuse after just
    5,000 packets.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 初始向量（IV）旨在防止这类攻击；如果没有它，每个数据包都会使用相同的密钥流进行加密。如果为每个数据包使用不同的 IV，则数据包的密钥流也将不同。然而，如果重复使用相同的
    IV，则两个数据包都将使用相同的密钥流进行加密。这是一个容易检测的条件，因为 IV 包含在加密数据包的明文中。此外，用于 WEP 的 IV 长度仅为 24
    位，这几乎保证了 IV 将被重复使用。假设 IV 是随机选择的，从统计上看，在 5,000 个数据包之后应该会出现密钥流重复的情况。
- en: This number seems surprisingly small due to a counterintuitive probabilistic
    phenomenon known as the *birthday paradox*. This paradox states that if 23 people
    are in the same room, two of these people should share a birthday. With 23 people,
    there are (23 · 22) / 2, or 253, possible pairs. Each pair has a probability of
    success of 1/365, or about 0.27 percent, which corresponds to a probability of
    failure of 1 – (1 / 365), or about 99.726 percent. By raising this probability
    to the power of 253, the overall probability of failure is shown to be about 49.95
    percent, meaning that the probability of success is just a little over 50 percent.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字看起来出奇的小，是由于一个被称为 *生日悖论* 的反直觉概率现象。这个悖论表明，如果有 23 个人在同一房间里，其中两个人应该有相同的生日。在
    23 个人中，有 (23 · 22) / 2，即 253 种可能的配对。每个配对的成功概率为 1/365，或大约 0.27%，这对应于失败的概率为 1 –
    (1 / 365)，或大约 99.726%。通过将这个概率提高到 253 次幂，整体失败概率被证明约为 49.95%，这意味着成功的概率略高于 50%。
- en: 'This works the same way with IV collisions. With 5,000 packets, there are (5000
    · 4999) / 2, or 12,497,500, possible pairs. Each pair has a probability of failure
    of 1 – (1 / 2^(24)). When this is raised to the power of the number of possible
    pairs, the overall probability of failure is about 47.5 percent, meaning that
    there''s a 52.5 percent chance of an IV collision with 5,000 packets:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 与IV冲突的情况作用相同。在5,000个数据包中，有(5000 · 4999) / 2，即12,497,500，可能的配对。每一对有1 – (1 / 2^(24))的失败概率。当这个概率被提升到可能配对的数量时，整体失败概率大约是47.5%，这意味着在5,000个数据包中有52.5%的几率发生IV冲突：
- en: '![Keystream Reuse](httpatomoreillycomsourcenostarchimages254433.png.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![密钥流重用](httpatomoreillycomsourcenostarchimages254433.png.jpg)'
- en: After an IV collision is discovered, some educated guesses about the structure
    of the plaintexts can be used to reveal the original plaintexts by XORing the
    two ciphertexts together. Also, if one of the plaintexts is known, the other plaintext
    can be recovered with a simple XORing. One method of obtaining known plaintexts
    might be through spam email, where the attacker sends the spam and the victim
    checks mail over the encrypted wireless connection.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现IV冲突后，可以通过对明文结构的合理猜测，通过将两个密文进行XOR运算来揭示原始明文。此外，如果已知其中一个明文，可以通过简单的XOR运算恢复另一个明文。获取已知明文的一种方法可能是通过垃圾邮件，攻击者发送垃圾邮件，受害者通过加密无线连接检查邮件。
- en: IV-Based Decryption Dictionary Tables
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于IV的解密字典表
- en: After plaintexts are recovered for an intercepted message, the keystream for
    that IV will also be known. This means that this keystream can be used to decrypt
    any other packet with the same IV, providing it's not longer than the recovered
    keystream. Over time, it's possible to create a table of keystreams indexed by
    every possible IV. Since there are only 2^(24) possible IVs, if 1,500 bytes of
    keystream are saved for each IV, the table would only require about 24GB of storage.
    Once a table like this is created, all subsequent encrypted packets can be easily
    decrypted.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复截获消息的明文后，该IV的密钥流也将被知晓。这意味着这个密钥流可以用来解密任何具有相同IV的其他数据包，前提是它不比恢复的密钥流长。随着时间的推移，可以创建一个按每个可能的IV索引的密钥流表。由于只有2^(24)个可能的IV，如果为每个IV保存1,500字节的密钥流，该表只需要大约24GB的存储空间。一旦创建了这样的表，所有后续的加密数据包都可以轻松解密。
- en: Realistically, this method of attack would be very time consuming and tedious.
    It's an interesting idea, but there are much easier ways to defeat WEP.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种攻击方法会非常耗时且繁琐。这是一个有趣的想法，但还有更简单的方法来击败WEP。
- en: IP Redirection
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP重定向
- en: Another way to decrypt encrypted packets is to trick the access point into doing
    all the work. Usually, wireless access points have some form of Internet connectivity,
    and if this is the case, an IP redirection attack is possible. First, an encrypted
    packet is captured, and the destination address is changed to an IP address the
    attacker controls, without decrypting the packet. Then, the modified packet is
    sent back to the wireless access point, which will decrypt the packet and send
    it right to the attacker's IP address.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解密加密数据包的方法是欺骗接入点完成所有工作。通常，无线接入点都有某种形式的互联网连接，如果这种情况成立，则可以进行IP重定向攻击。首先，捕获一个加密数据包，并将目标地址更改为攻击者控制的IP地址，而不解密数据包。然后，将修改后的数据包发送回无线接入点，它将解密数据包并将其直接发送到攻击者的IP地址。
- en: The packet modification is made possible due to the CRC32 checksum being a linear,
    unkeyed function. This means that the packet can be strategically modified and
    the checksum will still come out the same.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CRC32校验和是一个线性、无密钥函数，因此可以修改数据包，而校验和仍然相同。
- en: This attack also assumes that the source and destination IP addresses are known.
    This information is easy enough to figure out, just based on the standard internal
    network IP addressing schemes. Also, a few cases of keystream reuse due to IV
    collisions can be used to determine the addresses.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击还假设已知源和目标IP地址。仅基于标准的内部网络IP寻址方案，就可以轻松地确定这些信息。此外，由于IV冲突导致的密钥流重用的一些案例，也可以用来确定地址。
- en: Once the destination IP address is known, this value can be XORed with the desired
    IP address, and this whole thing can be XORed into place in the encrypted packet.
    The XORing of the destination IP address will cancel out, leaving behind the desired
    IP address XORed with the keystream. Then, to ensure that the checksum stays the
    same, the source IP address must be strategically modified.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了目标IP地址，这个值可以与所需的IP地址进行XOR运算，然后将整个内容XOR到加密数据包中。目标IP地址的XOR运算将抵消，留下所需的IP地址与密钥流进行XOR运算。然后，为了确保校验和保持不变，必须策略性地修改源IP地址。
- en: 'For example, assume the source address is 192.168.2.57 and the destination
    address is 192.168.2.1\. The attacker controls the address 123.45.67.89 and wants
    to redirect traffic there. These IP addresses exist in the packet in the binary
    form of high- and low-order 16-bit words. The conversion is fairly simple:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设源地址是192.168.2.57，目标地址是192.168.2.1。攻击者控制着地址123.45.67.89，并希望将流量重定向到那里。这些IP地址在数据包中以高16位和低16位字的形式存在。转换相当简单：
- en: '**Src IP = 192.168.2.57**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**源IP = 192.168.2.57**'
- en: '| *SH* = 192 · 256 + 168 = 50344 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| *SH* = 192 · 256 + 168 = 50344 |'
- en: '| *SL* = 2 · 256 + 57 = 569 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| *SL* = 2 · 256 + 57 = 569 |'
- en: '**Dst IP = 192.168.2.1**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标IP = 192.168.2.1**'
- en: '| *DH* = 192 · 256 + 168 = 50344 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| *DH* = 192 · 256 + 168 = 50344 |'
- en: '| *DL* = 2 · 256 + 1 = 513 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| *DL* = 2 · 256 + 1 = 513 |'
- en: '**New IP = 123.45.67.89**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**新IP = 123.45.67.89**'
- en: '| *NH* = 123 · 256 + 45 = 31533 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| *NH* = 123 · 256 + 45 = 31533 |'
- en: '| *NL* = 67 · 256 + 89 = 17241 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| *NL* = 67 · 256 + 89 = 17241 |'
- en: 'The checksum will be changed by *N[H] + N[L] – D[H] – D[L]*, so this value
    must be subtracted from somewhere else in the packet. Since the source address
    is also known and doesn''t matter too much, the low-order 16-bit word of that
    IP address makes a good target:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和将改变为 *N[H] + N[L] – D[H] – D[L]*，因此这个值必须从数据包的其他地方减去。由于源地址也是已知的并且不是很重要，该IP地址的低16位字是一个很好的目标：
- en: '| *S''L = SL – (NH + NL – DH – DL*) |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| *S''L = SL – (NH + NL – DH – DL*) |'
- en: '| *S''L* = 569 – (31533 + 17241 – 50344 – 513) |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| *S''L* = 569 – (31533 + 17241 – 50344 – 513) |'
- en: '| *S''L* = 2652 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| *S''L* = 2652 |'
- en: The new source IP address should therefore be 192.168.10.92\. The source IP
    address can be modified in the encrypted packet using the same XORing trick, and
    then the checksums should match. When the packet is sent to the wireless access
    point, the packet will be decrypted and sent to 123.45.67.89, where the attacker
    can retrieve it.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新的源IP地址应该是192.168.10.92。可以在加密数据包中使用相同的XOR技巧修改源IP地址，然后校验和应该匹配。当数据包发送到无线接入点时，数据包将被解密并发送到123.45.67.89，攻击者可以从中检索。
- en: If the attacker happens to have the ability to monitor packets on an entire
    class B network, the source address doesn't even need to be modified. Assuming
    the attacker had control over the entire 123.45.*X.X* IP range, the low-order
    16-bit word of the IP address could be strategically chosen not to disturb the
    checksum. If *NL = DH + DL – NH*, the checksum won't be changed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者恰好有能力监控整个B类网络的包，则甚至不需要修改源地址。假设攻击者控制了整个123.45.*X.X* IP范围，IP地址的低16位字可以策略性地选择，以不干扰校验和。如果
    *NL = DH + DL – NH*，校验和将不会改变。
- en: 'Here''s an example:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '| *NL = DH + DL – NH* |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| *NL* = DH + DL – NH* |'
- en: '| *NL* = 50,344 + 513 – 31,533 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| *NL* = 50,344 + 513 – 31,533 |'
- en: '| *N''L* = 82390 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| *N''L* = 82390 |'
- en: The new destination IP address should be 123.45.75.124.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 新的目标IP地址应该是123.45.75.124。
- en: Fluhrer, Mantin, and Shamir Attack
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fluhrer, Mantin, and Shamir攻击
- en: The Fluhrer, Mantin, and Shamir (FMS) attack is the most commonly used attack
    against WEP, popularized by tools such as AirSnort. This attack is really quite
    amazing. It takes advantage of weaknesses in the keyscheduling algorithm of RC4
    and the use of IVs.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Fluhrer, Mantin, and Shamir (FMS)攻击是对WEP最常用的攻击，由AirSnort等工具普及。这种攻击实际上非常神奇。它利用了RC4密钥调度算法的弱点以及IVs的使用。
- en: There are weak IV values that leak information about the secret key in the first
    byte of the keystream. Since the same key is used over and over with different
    IVs, if enough packets with weak IVs are collected, and the first byte of the
    keystream is known, the key can be determined. Luckily, the first byte of an 802.11b
    packet is the snap header, which is almost always `0xAA`. This means the first
    byte of the keystream can be easily obtained by XORing the first encrypted byte
    with `0xAA`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着一些弱的IV值，这些值会在密钥流的第一个字节中泄露有关密钥的信息。由于相同的密钥会与不同的IV重复使用，如果收集到足够多的具有弱IV的包，并且已知密钥流的第一个字节，则可以确定密钥。幸运的是，802.11b数据包的第一个字节是snap头，这几乎总是`0xAA`。这意味着可以通过将第一个加密字节与`0xAA`进行XOR运算来轻松地获得密钥流的第一个字节。
- en: Next, weak IVs need to be located. IVs for WEP are 24 bits, which translates
    to three bytes. Weak IVs are in the form of (*A* + 3, *N* – 1, *X*), where *A*
    is the byte of the key to be attacked, *N* is 256 (since RC4 works in modulo 256),
    and *X* can be any value. So, if the zeroth byte of the keystream is being attacked,
    there would be 256 weak IVs in the form of (3, 255, *X*), where *X*ranges from
    0 to 255\. The bytes of the keystream must be attacked in order, so the first
    byte cannot be attacked until the zeroth byte is known.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要定位弱 IV。WEP 的 IV 是 24 位，这相当于三个字节。弱 IV 的形式为 (*A* + 3, *N* – 1, *X*)，其中 *A*
    是要攻击的密钥字节，*N* 是 256（因为 RC4 在模 256 下工作），*X* 可以是任何值。因此，如果正在攻击密钥流的零字节，将会有 256 个弱
    IV，形式为 (3, 255, *X*)，其中 *X* 的范围从 0 到 255。密钥流的字节必须按顺序攻击，因此第一个字节不能被攻击，直到零字节已知。
- en: The algorithm itself is pretty simple. First, it performs *A* + 3 steps of the
    Key Scheduling Algorithm (KSA). This can be done without knowing the key, since
    the IV will occupy the first three bytes of the *K* array. If the zeroth byte
    of the key is known and *A* equals 1, the KSA can be worked to the fourth step,
    since the first four bytes of the *K* array will be known.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 算法本身相当简单。首先，它执行 *A* + 3 步的密钥调度算法（KSA）。由于初始化向量（IV）将占用 *K* 数组的第一个三个字节，因此无需知道密钥即可执行此操作。如果已知密钥的零字节且
    *A* 等于 1，则 KSA 可以进行到第四步，因为 *K* 数组的第一个四个字节将已知。
- en: At this point, if *S*[0] or *S*[1] have been disturbed by the last step, the
    entire attempt should be discarded. More simply stated, if *j* is less than 2,
    the attempt should be discarded. Otherwise, take the value of *j* and the value
    of *S[A* + 3], and subtract both of these from the first keystream byte (modulo
    256, of course). This value will be the correct key byte about 5 percent of the
    time and effectively random less than 95 percent of the time. If this is done
    with enough weak IVs (with varying values for *X*), the correct key byte can be
    determined. It takes about 60 IVs to bring the probability above 50 percent. After
    one key byte is determined, the whole process can be done again to determine the
    next key byte, until the entire key is revealed.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果 *S*[0] 或 *S*[1] 在上一步被干扰，整个尝试应该被丢弃。更简单地说，如果 *j* 小于 2，则应该丢弃尝试。否则，取 *j*
    的值和 *S[A* + 3] 的值，并从第一个密钥流字节中减去这两个值（当然，模 256）。这个值大约有 5% 的时间是正确的密钥字节，并且有不到 95%
    的时间是随机的。如果使用足够多的弱 IV（*X* 的值不同），可以确定正确的密钥字节。需要大约 60 个 IV 才能使概率超过 50%。一旦确定了一个密钥字节，整个过程可以再次进行以确定下一个密钥字节，直到整个密钥被揭示。
- en: For the sake of demonstration, RC4 will be scaled back so *N* equals 16 instead
    of 256\. This means that everything is modulo 16 instead of 256, and all the arrays
    are 16 "bytes" consisting of 4 bits, instead of 256 actual bytes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，RC4 将被缩小，使 *N* 等于 16 而不是 256。这意味着所有操作都是模 16 而不是模 256，所有数组都是 16 个“字节”，由
    4 位组成，而不是 256 个实际字节。
- en: Assuming the key is (1, 2, 3, 4, 5), and the zeroth key byte will be attacked,
    *A* equals 0\. This means the weak IVs should be in the form of (3, 15, *X*).
    In this example, *X* will equal 2, so the seed value will be (3, 15, 2, 1, 2,
    3, 4, 5). Using this seed, the first byte of keystream output will be 9.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 假设密钥为 (1, 2, 3, 4, 5)，并且将攻击零字节密钥，*A* 等于 0。这意味着弱 IV 应该是 (3, 15, *X*) 的形式。在这个例子中，*X*
    将等于 2，因此种子值将是 (3, 15, 2, 1, 2, 3, 4, 5)。使用这个种子，密钥流的第一个字节将是 9。
- en: '| output = 9 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 输出 = 9 |'
- en: '| *A* = 0 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| *A* = 0 |'
- en: '| IV = 3, 15, 2 |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| IV = 3, 15, 2 |'
- en: '| Key = 1, 2, 3, 4, 5 |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 密钥 = 1, 2, 3, 4, 5 |'
- en: '| Seed = IV concatenated with the key |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 种子 = IV 与密钥连接 |'
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
- en: '| S[] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| S[] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 |'
- en: Since the key is currently unknown, the *K* array is loaded up with what currently
    is known, and the *S* array is filled with sequential values from 0 to 15\. Then,
    *j* is initialized to 0, and the first three steps of the KSA are done. Remember
    that all math is done modulo 16.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密钥目前未知，*K* 数组被加载上目前所知的内容，*S* 数组被填充为从 0 到 15 的顺序值。然后，*j* 被初始化为 0，并执行 KSA 的前三个步骤。记住，所有数学运算都是模
    16 进行的。
- en: '**KSA step one**:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**KSA 第一步**:'
- en: '| *i* = 0 |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| *i* = 0 |'
- en: '| *j = j + S[i] + K[i]* |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| *j = j + S[i] + K[i]* |'
- en: '| *j* = 0 + 0 + 3 = 3 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| *j* = 0 + 0 + 3 = 3 |'
- en: '| Swap *S[i]* and *S[j]* |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 交换 *S[i]* 和 *S[j]* |'
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
- en: '| *S*[] = **3** 1 2 **0** 4 5 6 7 8 9 10 11 12 13 14 15 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| *S*[] = **3** 1 2 **0** 4 5 6 7 8 9 10 11 12 13 14 15 |'
- en: '**KSA step two**:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**KSA 第二步**:'
- en: '| *i* = 1 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| *i* = 1 |'
- en: '| *j = j + S[i] + K[i]* |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| *j = j + S[i] + K[i]* |'
- en: '| *j* = 3 + 1 + 15 = 3 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| *j* = 3 + 1 + 15 = 3 |'
- en: '| Swap *S[i]* and *S[j]* |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| S[] = 3 **0** 2 **1** 4 5 6 7 8 9 10 11 12 13 14 15 |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '**KSA step three**:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 2 |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| *j* = 3 + 2 + 2 = 7 |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 3 15 2 *X X X X X* 3 15 2 *X X X X X* |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| S[] = 3 0 **7** 1 4 5 6 **2** 8 9 10 11 12 13 14 15 |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: At this point, *j* isn't less than 2, so the process can continue. *S*[3] is
    1, *j* is 7, and the first byte of keystream output was 9\. So the zeroth byte
    of the key should be 9 –7 –1 = 1.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: This information can be used to determine the next byte of the key, using IVs
    in the form of (4, 15, *X*) and working the KSA through to the fourth step. Using
    the IV (4, 15, 9), the first byte of keystream is 6.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '| output = 6 |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '| *A* = 0 |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| IV = 4, 15, 9 |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| Key = 1, 2, 3, 4, 5 |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| Seed = IV concatenated with the key |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '**KSA step one**:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 0 |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| *j* = 0 + 0 + 4 = 4 |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = **4** 1 2 3 **0** 5 6 7 8 9 10 11 12 13 14 15 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '**KSA step two**:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 1 |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: '| *j* = 4 + 1 + 15 = 4 |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 4 **0** 2 3 **1** 5 6 7 8 9 10 11 12 13 14 15 |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
- en: '**KSA step three**:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 2 |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| *j* = 4 + 2 + 9 = 15 |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 4 0 **15** 3 1 5 6 7 8 9 10 11 12 13 14 **2** |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '**KSA step four**:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '| *i* = 3 |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| *j = j + S[i] + K[i]* |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: '| *j* = 15 + 3 + 1 = 3 |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| Swap *S[i]* and *S[j]* |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| *K*[] = 4 15 9 1 *X X X X* 4 15 9 1 *X X X X* |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: '| *S*[] = 4 0 **15** 3 1 5 6 7 8 9 10 11 12 13 14 **2** |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
- en: '| output –*j – S*[4] = key[1] |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
- en: '| 6 – 3 – 1 = 2 |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
- en: 'Again, the correct key byte is determined. Of course, for the sake of demonstration,
    values for *X* have been strategically picked. To give you a true sense of the
    statistical nature of the attack against a full RC4 implementation, the following
    source code has been included:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: fms.c
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code performs the FMS attack on 128-bit WEP (104-bit key, 24-bit IV), using
    every possible value of *X*. The key byte to attack is the only argument, and
    the key is hard-coded into the `key` array. The following output shows the compilation
    and execution of the fms.c code to crack an RC4 key.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This type of attack has been so successful that a new wireless protocol called
    WPA should be used if you expect any form of security. However, there are still
    an amazing number of wireless networks only protected by WEP. Nowadays, there
    are fairly robust tools to perform WEP attacks. One notable example is aircrack,
    which has been included with the LiveCD; however, it requires wireless hardware,
    which you may not have. There is plenty of documentation on how to use this tool,
    which is in constant development. The first manual page should get you started.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击如此成功，以至于如果你期望任何形式的安全，就应该使用名为WPA的新无线协议。然而，仍然有大量无线网络仅由WEP保护。如今，有相当稳健的工具可以执行WEP攻击。一个值得注意的例子是aircrack，它已被包含在LiveCD中；然而，它需要无线硬件，你可能没有。关于如何使用这个工具的文档非常丰富，而且这个工具正在不断开发中。第一份手册应该能帮助你入门。
- en: '[PRE37]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Again, consult the Internet for hardware issues. This program popularized a
    clever technique for gathering IVs. Waiting to gather enough IVs from packets
    would take hours, or even days. But since wireless is still a network, there will
    be ARP traffic. Since WEP encryption doesn't modify the size of the packet, it's
    easy to pick out which ones are ARP. This attack captures an encrypted packet
    that is the size of an ARP request, and then replays it to the network thousands
    of times. Each time, the packet is decrypted and sent to the network, and a corresponding
    ARP reply is sent back out. These extra replies don't harm the network; however,
    they do generate a separate packet with a new IV. Using this technique of tickling
    the network, enough IVs to crack the WEP key can be gathered in just a few minutes.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，对于硬件问题，请咨询互联网。这个程序普及了一种用于收集IVs的巧妙技术。等待从数据包中收集足够的IVs可能需要数小时，甚至数天。但由于无线仍然是一个网络，会有ARP流量。由于WEP加密不会修改数据包的大小，因此很容易识别出哪些是ARP。这种攻击捕获了一个大小与ARP请求相同的数据包，然后将其在网络中重放数千次。每次，数据包都会被解密并发送到网络，同时发送一个相应的ARP回复。这些额外的回复不会损害网络；然而，它们确实生成了一个新的IV的新数据包。通过这种刺激网络的技术，只需几分钟就可以收集到足够破解WEP密钥的IV。
