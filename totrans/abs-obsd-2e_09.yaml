- en: Chapter 9. More Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Encrypt your hard drive?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Software RAID can save your day,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*or ruin your life.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Disk management isn’t
    complicated, but there’s enough material that it gets two chapters. Lucky you!
    In this chapter, we’ll start with how to automatically back up your vital root
    partition to a second disk. Then we’ll explore how OpenBSD can use additional
    memory as disk space via a memory filesystem and how to set that up. Next, we’ll
    access disks formatted for other operating systems, such as NTFS, ext2, and FAT.
    Removable media isn’t difficult to work with, but has its own concerns. If you
    don’t need the actual media, but can work with disk images, you can access those.
    Both topics are covered in this chapter. We’ll also discuss using NFS, as both
    a server and a client. Our final topic is OpenBSD’s disk redundancy and disk encryption
    features.'
  prefs: []
  type: TYPE_NORMAL
- en: Backing Up to the /altroot Partition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can lose most of your partitions and still hope to recover the rest of the
    system. If you lose your root filesystem, however, recovery becomes a much more
    difficult task. While you could back up critical files from */etc* and use them
    to restore your system, OpenBSD provides the */altroot* partition as an easy way
    to automatically duplicate the root partition on a second disk.
  prefs: []
  type: TYPE_NORMAL
- en: An emergency root partition on a second disk gives you an easier path to recovery
    in the event of a disk failure. Booting to the second disk lets you pull any data
    off that disk, and possibly even from undamaged partitions on the first disk,
    before replacing the failed disk. There’s no reason to back up your root partition
    to the same disk, however, as the whole disk will probably be unusable.
  prefs: []
  type: TYPE_NORMAL
- en: This backup requires a free disk partition the same size as your root partition,
    located on a different disk. The OpenBSD installer defaults assume that you have
    only one disk. If you have a second disk during installation, you need to use
    a custom install process to create the */altroot* partition, as we did in the
    multiple disk installation in [Chapter 3](ch03.html "Chapter 3. Installation Walk-Through").
    While configuring partitions is easiest during the installation, you can add more
    disks later if needed, as discussed in [Chapter 8](ch08.html "Chapter 8. Disks
    and Filesystems").
  prefs: []
  type: TYPE_NORMAL
- en: 'Your */altroot* partition needs an */etc/fstab* entry. If you created the partition
    during the install process, that */etc/fstab* entry already exists but has the
    wrong mount type. If you created this partition after installation, you’ll need
    to create an */etc/fstab* entry yourself. The /*altroot* partition needs a mount
    type of `xx`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You cannot mount this partition from its */etc/fstab* entry, as `xx` is not
    a valid mount type. (You could run, say, `mount /dev/sd1a /altroot` if you want
    to manually mount this partition.) The daily system maintenance job */etc/daily*
    uses this mount option to identify the root backup partition.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the */altroot* backup, add `ROOTBACKUP=1` to your */etc/daily.local*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to creating partitions on raw disk, OpenBSD lets you create partitions
    in system memory. A *memory filesystem* (*MFS*), or *memory disk*, lives in your
    machine’s RAM, rather than on a physical disk. Reading and writing files to and
    from such a filesystem is much faster than accessing those same files on a spinning
    disk, which makes a memory-backed filesystem a huge optimization for certain applications.
  prefs: []
  type: TYPE_NORMAL
- en: If MFSs sound too good to be true for high-performance environments, that’s
    because they are. Understand their limits before you implement them everywhere.
    First, RAM does not persist across reboots or shutdowns, so either will erase
    the contents of an MFS. While this might seem obvious, I’ve surprised myself more
    than once by losing a file stored on a filesystem I had forgotten was an MFS.
    Furthermore, if your system crashes, you’ll lose any data stored on an MFS.
  prefs: []
  type: TYPE_NORMAL
- en: You can use an MFS partition as scratch space to rapidly compile, compress,
    decompress, or otherwise manipulate temporary files. I’ve seen news server histories,
    database locks, and other application-specific files stored on MFSs.
  prefs: []
  type: TYPE_NORMAL
- en: An MFS works even in situations where the system regularly swaps. The kernel
    retains any information being actively used in memory, while transferring unused
    information to swap space. This is excellent for small partitions like */tmp*,
    in which small, frequently used files can be quickly accessed. Files that are
    less frequently accessed end up in swap space, which gives performance similar
    to accessing a physical disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last word of caution: Don’t make heavy use of MFSs if you don’t have RAM
    to spare. If you run short on combined memory and swap space, your system will
    perform very poorly.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating MFS Partitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create temporary MFS partitions with `mount_mfs(8)`. Like other `mount_` commands,
    `mount_mfs` takes two arguments: the physical device and a mount point. Unlike
    physical disks, memory doesn’t have a device node, so use the device node of the
    system swap space. If you have multiple swap partitions, pick whichever you like.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can create a memory-backed filesystem by passing a swap partition,
    */dev/sd0b*, and a desired mount point, */mnt*, as arguments to `mount_mfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The size of this partition will be limited only by the size of your swap partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create smaller memory-backed filesystems, so that you will have memory
    and/or swap space available if you fill the memory disk. Specify the size with
    the `-s` flag and a number of sectors, or with a trailing `b` (bytes), `m` (megabytes),
    or `g` (gigabytes). Here’s how to create a 128MB MFS on */mnt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you request an MFS larger than your system can support, you’ll get a warning
    like `mmap: Cannot allocate memory`. Try again, this time with a more reasonable
    size.'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting an MFS at Boot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can mount an MFS at boot by adding an */etc/fstab* entry. You only need
    a mount point and the partition size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to specify a specific swap device; OpenBSD is smart enough to
    let you say the memory disk is generically swap-backed **1**. Just as with any
    other partition, you also need to specify the mount point **2** and the filesystem
    type **3**.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with a memory disk, you can use different options than you would
    for a traditional disk **4**. Since a system crash would destroy all files on
    the MFS anyway, you can safely mount an MFS partition as asynchronous using the
    `async` option. You might also want to use `nodev` and `nosuid` mount options
    on this partition. You can specify the size with the `-s` option, but make sure
    that you put an equal sign (`=`) between the `-s` and the size. Because */etc/fstab*
    uses whitespace to separate fields, OpenBSD will think the dump level is 128m
    if you don’t use an equal sign.^([[21](#ftn.id344921)])
  prefs: []
  type: TYPE_NORMAL
- en: Data on a memory disk is by definition disposable, so don’t back it up **5**.
    Similarly, never use `fsck(8)` with a memory disk at boot **6**. The memory disk
    is created anew at each boot, so it is automatically internally consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any partition that uses a non-FFS filesystem is foreign to OpenBSD. Although
    OpenBSD can access many foreign filesystems, don’t expect it to be seamless.
  prefs: []
  type: TYPE_NORMAL
- en: Support for some filesystems is incomplete. For example, you can mount Microsoft
    NTFS partitions only as read-only. Other filesystems don’t support the full range
    of OpenBSD commands. Because FAT filesystems don’t have any concept of file ownership
    or permissions, commands like `chmod` and `chown` won’t change anything on the
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: Each supported filesystem has its own mount program to handle the vagaries of
    that filesystem. To simplify your life, `mount` can usually recognize supported
    filesystems from the on-disk format and call the correct mount program as needed.
    To mount a foreign filesystem, you need the device node and a mount point. Depending
    on the filesystem, you may also need to know the type of filesystem you’ll be
    mounting.
  prefs: []
  type: TYPE_NORMAL
- en: Inodes vs. Vnodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we talk about foreign filesystems, let’s touch on something that confused
    me for a long time: the difference between inodes and vnodes.'
  prefs: []
  type: TYPE_NORMAL
- en: The FFS uses index nodes, or *inodes*, to map blocks of disk that contain data.
    This worked just dandy when hard drives were big, expensive things that no one
    moved between computers. Over the years, however, swapping disks between machines
    has become more popular.
  prefs: []
  type: TYPE_NORMAL
- en: Although Unix-like systems think in terms of accessing files via inodes, the
    FAT32 filesystem doesn’t use inodes, ext2fs’s inodes don’t map directly onto FFS
    inodes, and CDs use a completely different layout. To access all of these filesystems
    in a consistent way, BSD needed another layer of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual node, or *vnode*, is an abstraction layer the kernel uses to access
    all filesystems. Users never manipulate vnodes directly, but you’ll see references
    to them throughout OpenBSD’s documentation. Every tool that reads or writes to
    disks does so through vnodes, which map the requests to the filesystem. When you
    write to an FFS block or inode, the kernel addresses data to a vnode, which in
    turn maps to an inode. When you write to a FAT32 filesystem, the kernel addresses
    data to a vnode mapped to a point in the FAT32 filesystem. You use inodes only
    when dealing with FFS systems, but your data will pass through a vnode when accessing
    any filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t let references to vnodes on non-FFS systems confuse you. They’re part
    of OpenBSD, not the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Common Foreign Filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common foreign filesystems include MS-DOS, NTFS, ext2fs, and CD. We’ll look
    at how to access disks formatted for those operating systems with OpenBSD.
  prefs: []
  type: TYPE_NORMAL
- en: MS-DOS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenBSD supports the FAT, FAT16, and FAT32 filesystems. These formats are commonly
    found on flash media, old Microsoft operating systems, and floppy disks.
  prefs: []
  type: TYPE_NORMAL
- en: To mount a filesystem with a FAT filesystem partition, use `mount_msdos(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Not sure which partition on the disk is the FAT filesystem? Run `disklabel(8)`
    on the drive and see. FAT filesystems are often located on the *i* partition.
    And even if you try inserting your USB drive and mounting its *i* partition, OpenBSD
    will probably figure out that it’s a FAT system.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with FAT disks often, you might investigate */usr/ports/sysutils/mtools*,
    a collection of software for working with FAT filesystems without mounting them.
    While `mount_msdos` is quite reliable, mtools offers a more elegant interface.
  prefs: []
  type: TYPE_NORMAL
- en: NTFS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To mount disks formatted for modern Microsoft operating systems, use `mount_ntfs(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As I write this, OpenBSD supports NTFS4 (from Windows NT) and NTFS5 (in Windows
    2000 and XP). Windows Vista and newer systems are not yet supported, but they
    might be by the time you read this.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to view file attributes specific to the NTFS filesystem, check the
    `mount_ntfs` man page for details.
  prefs: []
  type: TYPE_NORMAL
- en: ext2fs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To mount ext2fs and ext3fs filesystems, use `mount_ext2fs(8)`. (The one program
    mounts both types of filesystem.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Owing to their shared Unix heritage, the Linux ext2fs and ext3fs filesystems
    support many FFS-like features. Unlike with NTFS, you can safely read and write
    ext2fs and ext3fs disks in OpenBSD. You cannot, however, read ext4fs partitions
    using OpenBSD.
  prefs: []
  type: TYPE_NORMAL
- en: CD
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compact discs formatted for data use the ISO-9660 filesystem. To mount a CD,
    use `mount_cd9660(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Mount CDs using either the *a* or *c* partition on the device. If you would
    like to save yourself a few keystrokes, `mount(8)` is very good at automatically
    detecting ISO-9660 filesystems. The device node for a CD is tied to the CD drive,
    not the disk itself, so the node shouldn’t change unless you add another drive.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in burning a CD, look at `mkhybrid(8)` and `cdio(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Filesystem Ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most foreign filesystems either have no concept of file ownership or have an
    ownership scheme incompatible with that of Unix-like operating systems. (Notable
    among these filesystems are FAT and NTFS.) The programs that mount these kinds
    of filesystems thoughtfully allow you to specify the ownership of files on the
    filesystem. The `-u` flag lets you specify a file owner, and the `-g` flag lets
    you specify the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how I would mount a FAT filesystem as owned by my account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Some other filesystems use permissions schemes compatible with OpenBSD’s permissions.
    For example, all of the information OpenBSD needs to assign permissions to files
    and directories is contained within an ext2fs filesystem. That doesn’t mean that
    an ext2fs filesystem will perform seamlessly on OpenBSD, however. Though OpenBSD
    will respect the ext2fs disk’s permissions, the user ID numbers probably won’t
    match up between the operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Removable Media
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These days, the removable media you’ll most likely deal with are external hard
    drives, flash drives, and CDs. The CD is the simplest, because you know how to
    use `mount(8)` and `umount(8)`, and you know its device node and filesystem type
    will always be the same. But how do you identify the device name of a removable
    hard drive?
  prefs: []
  type: TYPE_NORMAL
- en: When you attach a drive to your machine, OpenBSD automatically assigns your
    drive a device node to your console and prints a message to the console. You can
    check the console as you attach the drive, or you can watch your messages log
    by running `tail -f /var/log/messages` before attaching the drive.
  prefs: []
  type: TYPE_NORMAL
- en: If you frequently use a particular removable disk, you can simplify your routine
    by making an */etc/fstab* entry for it. Here are some sample */etc/fstab* entries
    for a CD and a FAT flash drive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can’t use DUIDs for removable media, because the actual media might change.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can mount your CD on */cdrom* by entering `mount /cdrom`, and your FAT
    flash drive on */mnt* by entering mount `/mnt`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that OpenBSD does not create a */cdrom* directory by default; you’ll need
    to create it yourself. You could point both of these at */mnt*, but I like having
    a dedicated CD mount point on my systems, and having two devices share a mount
    point risks concealing one of the filesystems. (Remember that OpenBSD has stackable
    mounts, as discussed in [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems").)
  prefs: []
  type: TYPE_NORMAL
- en: Mounting Filesystem Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can mount a disk image and access the image just as you would a disk partition.
    This is very useful for those times you want to extract a few files from an ISO
    but don’t want to bother burning the image to physical media. The trick to mounting
    a disk image is attaching the image to a device node so that you can use the proper
    `mount` command.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD uses the `vnconfig(8)` program to attach disk images to device nodes.
    (Remember that a vnode is an abstraction layer between the kernel and a filesystem.)
    Use `vnconfig` to “wire” vnodes between a file and a device node, and then access
    them through OpenBSD’s */dev/svnd* devices. Depending on the disk image type,
    the image might have MBR partitions, disklabel partitions, or just a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The default kernel has four vnode devices. If you need to mount more than four
    disk images simultaneously, edit your kernel binary using `config(8)`’s `-e` option,
    as discussed in [Chapter 18](ch18.html "Chapter 18. Kernel Configuration").
  prefs: []
  type: TYPE_NORMAL
- en: Attaching Vnode Devices to Disk Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `vnconfig(8)` command takes two arguments: the device node you want to
    use and the disk image you want to mount.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that this example uses the *c* partition of the device. This allows you
    to treat the disk image as a whole disk.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have an ISO image named *install52.iso* that you would like to mount.
    First, use `vnconfig` to attach this image to vnode device 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can then use `mount` to attach the vnode to an */mnt* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: OpenBSD’s `mount(8)` is smart enough to recognize this as a CD filesystem and
    mount it as such. If you’re mounting a disk image that uses a less detectable
    filesystem, you need to use the specific `mount` command for that filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Detaching Vnode Devices from Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vnode devices attached to a file remain attached until specifically disconnected,
    and you can attach a vnode device to only one file at a time. To disconnect the
    vnode device from the file, use the `-u` flag with `vnconfig`. For example, to
    disconnect the vnode device located at *vnd0c*, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can now attach this vnode device to another file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the full path to the device is optional in `vnconfig`. If you know the
    device name, you can use it without the leading */dev*, as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Basic NFS Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NFS allows one machine to access files on another machine. NFS has its origins
    in UNIX, but today appears in most operating systems, including those from Microsoft
    and Apple. OpenBSD supports NFS versions 1 through 3 as both a client and a server.
  prefs: []
  type: TYPE_NORMAL
- en: Entire books can be—and have been—written about NFS. We won’t go into the intimate
    details of NFS, but rather focus on getting a basic NFS share working on OpenBSD.
    Configuring NFS the first time can be intimidating, but after setting up a file
    share or two, you’ll find it straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a complicated NFS environment—involving multiple versions of multiple
    operating systems—or if you want to share a directory among hundreds of active
    clients, you should do further research, but even a basic setup will help to simplify
    parts of your job.
  prefs: []
  type: TYPE_NORMAL
- en: NFS works on the client/server model. One computer, the server, offers filesystems
    to other computers. The server is *exporting* a filesystem, and the filesystems
    on offer are called *exports*. NFS clients can mount exports in a manner almost
    identical to that used to mount local filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to remember about NFS is that it is *stateless*, which means
    that NFS does not track the condition of a connection. You can reboot an NFS server,
    and the client won’t throw a fit. The client cannot access files on the server
    while the server is down, but once the server returns, the client will pick up
    right where things left off. Other network filesystems are not always so resilient.
    Statelessness causes its own problems as well. For example, clients cannot know
    when a file they are currently reading has been modified by another client.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re just learning NFS (or OpenBSD’s implementation of NFS), check */var/log/messages*
    for NFS-related error messages. If you’ve repeatedly reconfigured your NFS server
    as part of learning, and things just don’t work correctly, reboot your NFS server
    and/or client. NFS is complicated, and sometimes starting with a clean stack clears
    up a lot of problems. Once you understand how all the pieces fit together, a reboot
    to resolve problems should never be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NFS protocol has evolved over the years, and every operating system has
    implemented a slightly different version of NFS. Other BSDs, Illumos, Linux, Apple,
    Microsoft, and most other operating systems can work with OpenBSD’s NFS support,
    but each may require an occasional tweak for specific environments. If you’re
    having trouble getting NFS to work with OpenBSD and another operating system,
    read `mount_nfs(8)` and feed the details to your favorite search engine. The odds
    that someone else has experienced this problem before are good.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenBSD NFS Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, OpenBSD includes all the programs necessary to act as an NFS server,
    but you must turn it on. The NFS server requires three daemons:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`portmap(8)`****. Maps requests for remote procedure call (RPC) services
    to TCP/IP port numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`mountd(8)`****. Listens for incoming NFS mount requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`nfsd(8)`****. Processes requests for filesystem actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `portmap(8)` daemon has its own *rc.conf* flag, as it can be used by many
    other RPC services. The `mountd(8)` and `nfsd(8)` daemons are controlled by a
    single *rc.conf* flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following entries to *rc.conf.local* to start all three processes at
    boot time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can start these three daemons from scripts in */etc/rc.d*. If you try to
    start these daemons now, however, they won’t run. You must configure at least
    one export before the NFS server daemons will start.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting Filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To export filesystems, define which clients may mount which filesystems and/or
    directories in */etc/exports*. This file takes a separate line for each disk device
    on the server and each client or group of clients that can access that disk device.
    Each line has up to three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Directories or partitions to be exported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options on that export
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients permitted to connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of the three components of an */etc/exports* entry, only the directory is mandatory.
    The directory path cannot contain symlinks, double dots, or single dots.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to export my home directory as read-write to every host on the
    Internet, I could use an *exports* line containing only the path to my */home*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This perfectly valid (but perfectly foolish) entry contains no options and no
    host restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: To export multiple directories that reside on the same partition, separate them
    with a single space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can list any number of directories on one line, as long as they exist on
    the same partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'NFS clients can mount only exactly the directory specified in */etc/exports*.
    If you export */home/mwlucas*, clients can attach only */home/mwlucas* to a mount
    point. They cannot mount, say, */home/mwlucas/bin* instead. If you would like
    to export an entire partition, you can do that, too. If you want to let clients
    mount any directories beneath that mount point, specify the mount point and the
    `-alldirs` option. You cannot use `-alldirs` with a subdirectory; it must be the
    actual mount point. This next entry lets anyone mount any directory in */home*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To export multiple partitions, or directories from multiple partitions, specify
    them on separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Any time you change */etc/exports*, you must signal `mountd` to reread its
    configuration. You can do this by passing the `reload` argument to the `mountd`
    startup script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While these simple mounts give you an idea of how NFS works, they’re very insecure.
    To make an intelligent export, you need a few options and an access list. Let’s
    take a look at some of NFS’s more commonly used options.
  prefs: []
  type: TYPE_NORMAL
- en: Read-Only Mounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might want to share files without worrying about whether your underlings
    will delete, modify, or otherwise undo your hard work. You can share files as
    read-only by using the `-ro` option. Here, I offer my home directory to all the
    computers in the world, but as a read-only share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is slightly more intelligent than offering my NFS exports to the entire
    world read-write, but only slightly.
  prefs: []
  type: TYPE_NORMAL
- en: NFS and Users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You already know that file ownership and permissions are tied to UID numbers.
    Unlike many other file-sharing protocols, NFS also uses UIDs to identify file
    ownership. For example, on my test server, my account `mwlucas` uses the UID 1000;
    on my client, my `mwlucas` account also uses the UID 1000\. This simplifies my
    life, as I don’t need to worry too much about file ownership; files owned by `mwlucas`
    on the server are owned by `mwlucas` on the client.
  prefs: []
  type: TYPE_NORMAL
- en: On a small network with only a few users and machines,^([[22](#ftn.id330714)])
    you can probably keep UID numbers synchronized without a problem by assigning
    the same UID to the same user on all of your systems. But on a large network,
    with more than one user and where users have root on their own machines, file
    ownership can quickly become a serious problem. The best way around this is to
    maintain a central repository of authorized users via LDAP or Kerberos.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how you manage your users, NFS handles the root account differently.
    An NFS server cannot trust root on client machines to execute commands or write
    files as root on the server; if that were the case, a breach on one NFS client
    would mean a breach on the NFS server. By default, requests from root on the client
    are mapped to UID and GID 32767 (also known as `nobody`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to map root to a specific user rather than the generic UID `nobody`,
    use the `-maproot` option and specify either a username or UID. Here, we map incoming
    requests from root on the client to the user `nfsroot` on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can give the mapped root user a list of groups that the remote root account
    can access by specifying them after the username, separated by colons. Here, we
    give the client’s root user access to the server as the user `nfsroot` and the
    groups `customers` and `webmasters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to explicitly remove the mapped root user from all groups, put
    a colon after the username or UID, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want all the NFS clients, regardless of username on the client
    system, to use a single user ID on the NFS server. The `-mapall` option allows
    you to do this. This option uses the same format as the `-maproot` option. Here,
    we map all NFS users to the username `nfsuser` on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Correct control of user access will help protect your NFS server.
  prefs: []
  type: TYPE_NORMAL
- en: Permitted Clients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, every host can access your NFS server. For many reasons, that’s
    not a great idea. You can restrict the clients permitted to access your NFS server
    by listing their IP addresses at the end of the export entry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify clients by their hostname, but if the server has a DNS
    failure, it won’t allow any clients access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To permit access to an entire network, use the `-network` and `-mask` options.
    The next example permits access to the addresses 192.0.2.0 through 192.0.2.15,
    using a subnet mask. (If you’re not familiar with subnet masks, read [Chapter 11](ch11.html
    "Chapter 11. Overview of TCP/IP").)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When setting up your NFS server, I recommend you grant access to only the hosts
    who need it.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Exports for One Partition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can have only one line for each combination of partition and permitted
    clients. If */home* is a single partition, you can’t have an exports file that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If two directories are located on the same partition, NFS will not allow you
    to export them to the same host using different permissions. You can, however,
    export directories on one partition to different hosts with different permissions,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can export directories on a partition to different hosts with different
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Only by combining IP restrictions and controlling user permissions can you can
    effectively control NFS server access.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenBSD’s NFS client doesn’t need any daemons or configuration. Just `mount`
    the remote filesystem. Here, I mount my home directory from my server `treble`
    on */mnt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When mounting remote filesystems over NFS, enter the hostname or IP address,
    a colon, and the directory. Because I have the same UID on both the client and
    server, I can access, alter, remove, and add files in */mnt* exactly as if I were
    dealing with files on a local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Verify your mount with `df(1)` or `mount(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The NFS-mounted directory shows up like any other mount point.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount an NFS share automatically at boot, or just record it for future convenience,
    you may use an */etc/fstab* entry. If your system might not have DNS available
    to it at boot time, use an IP address for the NFS server. The following example
    specifies two *fstab* entries: one using a hostname and one using an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Give all NFS partitions dump and `fsck` numbers of `0`. Do not run `fsck` or
    `dump` on an NFS mount, as those programs require raw disk access that NFS doesn’t
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: Use any other mount options you like. The OpenBSD folks recommend using `noexec`,
    `nodev`, and `nosuid` “when applicable.” I recommend `noauto` on NFS partitions
    that aren’t required for normal server operation, so that an unavailable NFS server
    does not hang your machine’s boot process.
  prefs: []
  type: TYPE_NORMAL
- en: NFS performance depends a great deal on your hardware, your local network, the
    clients and servers involved, the phase of the moon, and any number of other factors.
    If you’re not happy with your NFS performance, read `mount_nfs(8)` and experiment
    with using TCP or UDP, the read and write sizes, and perhaps the timeout. If you
    need a complicated NFS environment, you should definitely invest some time in
    learning more about NFS.
  prefs: []
  type: TYPE_NORMAL
- en: Software RAID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Redundant Array of Independent Disks (RAID) technology has become the standard
    way of mirroring hard drives within a machine or combining multiple hard drives
    to form one giant partition. In many types of RAID arrays, if one disk fails,
    the system can continue to run without data loss until you replace the failed
    disk or a second disk fails.
  prefs: []
  type: TYPE_NORMAL
- en: You can get RAID from the hardware or have the operating system perform the
    RAID operations. Hardware RAID controllers seem nice, but are in reality just
    decent disk controllers that run special software. Using the `softraid(4)` driver,
    OpenBSD can do the same thing, letting you build RAID arrays out of plain disks.
    You can do just about everything you can with a hardware RAID controller with
    a bunch of disks and OpenBSD’s RAID management program `bioctl(8)` and the `softraid(4)`
    software RAID driver.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to managing software RAID, OpenBSD’s `bioctl(8)` can manage most
    sorts of hardware RAID controllers. If you’re planning to use hardware RAID, reading
    the `bioctl` manual is definitely worth your time.
  prefs: []
  type: TYPE_NORMAL
- en: RAID Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenBSD supports the following RAID configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RAID-0, or** striping'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This type is not redundant. It requires at least two disks of the same size,
    and data is shared between the disks to increase partition size and throughput.
    You can use RAID-0 to combine five 4TB disks into a 20TB virtual disk, but be
    warned: If one hard drive in the array fails, you’ll lose all your data. RAID-0
    is useful when you need a really big filesystem, but it’s more vulnerable than
    a single disk because it provides multiple points of failure (or as one of my
    quasi-literary, quasi-humorous friends once said, “RAID-0 gives a whole new meaning
    to the phrase one disk to rule them all”). The size of a RAID-0 array is the size
    of all the hard drives combined.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**RAID-1, or** mirroring'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With this type, the contents of one disk are duplicated on another. Mirroring
    requires at least two disks of the same size, and the size of a RAID-1 array is
    equal to the size of the smallest drive in the array. I use mirroring to protect
    all vital data, as it gives even a cheap desktop-chassis server some measure of
    data protection. OpenBSD’s software RAID fully supports this level.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**RAID-4, or** striping data across disks, with a dedicated parity disk'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This type requires at least three disks of the same size. Parity data lets a
    RAID array recover data on missing disks, and RAID-4 stores that parity data on
    a specific disk. This means that you can lose any one of the disks without losing
    data. As I write this, `bioctl`’s RAID-4 support is experimental. Hopefully this
    support will be complete before the book reaches you, but if not, you’ll need
    to use a hardware RAID card to get RAID-4.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**RAID-5, or** striping with parity shared across all drives'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the current industry standard for redundancy. Parity data provides data
    redundancy—the loss of a single drive doesn’t destroy any data. It requires at
    least three disks of the same size. Unlike RAID-4, RAID-5 shares the parity data
    across all the drives simultaneously. While throughput isn’t as good as that of
    RAID-0, a RAID-5 array can simultaneously serve multiple I/O requests. The size
    of your RAID-5 array is the combined size of all but one of your hard drives.
    If you have five 4TB drives, the array will be 16TB ((5 – 1) × 4TB). Like RAID-4,
    RAID-5 support in `bioctl` is incomplete and experimental. I hope it will be complete
    before you read this, but if not, you’ll need to use a hardware RAID card for
    RAID-5.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: According to the RAID standards, each of these levels requires disks of the
    same size. That said, OpenBSD’s `softraid` uses partitions rather than disks.
    You can use disks of different sizes, but your RAID array will use only an amount
    of space on each disk equal to the smallest drive. If you want to mirror a 1TB
    drive and a 2TB drive, your mirror will offer only 1TB of space. The excess space
    on the larger drive is wasted.^([[23](#ftn.id367975)])
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the standard RAID methods, `softraid` also allows you to encrypt
    your data across all disks in a RAID array (as described in [Encrypted Disk Partitions](ch09.html#encrypted_disk_partitions
    "Encrypted Disk Partitions")). It also lets you *concatenate* disks. Concatenated
    disks are just run together to create one large virtual disk. You could concatenate
    two 500GB disks and a 1TB disk to create a single 2TB partition. These disks don’t
    need to be the same size, but as with RAID-0, they are vulnerable. Damage to any
    one disk will completely wreck the virtual disk and lose all data. As the process
    for creating a concatenated disk closely resembles that of creating a RAID-0 disk,
    we’ll cover it in [Creating softraid Devices](ch09.html#creating_softraid_devices
    "Creating softraid Devices").
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Disks for softraid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `softraid` software RAID device builds its virtual disks out of disklabel
    partitions. To use a disk in a `softraid` array, prepare it just as you would
    a disk for a regular filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: On i386 and amd64, disks underlying a `softraid` device need an MBR partition.
    To mark a whole disk with a single MBR partition, run `fdisk -i` on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have five disks to use in a RAID array: `sd2`, `sd3`, `sd4`, `sd5`,
    and `sd6`. You’ll need to prepare each of them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this for every disk in your array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve added an MBR to all your disks, you’ll need to put a disklabel
    partition on each disk. I tend to use partition letter *p* (the last available
    partition letter) for `softraid` devices. Here’s how to set up a disk for `softraid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, we add a partition with `a` **1** and assign it partition letter `p`
    **2**. Instead of our usual filesystem type of 4.2BSD, we assign a filesystem
    type of `RAID` **3**. Then we quit **4** and let `disklabel` write the changes
    to the disklabel partition **5**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple identical disks, you can use `disklabel` to save this
    disk’s configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This saves the label on disk `sd2` to the file *disklabel.sd2.raid*. You can
    make `disklabel(8)` copy this partitioning to other disks, and `disklabel` will
    assign each disk a unique DUID as it copies. This saves you from needing to walk
    through the interactive editor for each disk. Let’s apply this disklabel to each
    partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Disks `sd2` through `sd6` are now ready for assimilation into `softraid`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating softraid Devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `bioctl(8)` to drag disks into a software RAID. You’ll need the disk partitions
    you want to include in the RAID. OpenBSD software RAID arrays are named `softraid`,
    followed by a number. Use the `-c` argument to give a RAID type, and `-l` to give
    the partitions, and end with the name of the `softraid` you’re creating.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have five disk partitions—`sd2p`, `sd3p`, `sd4p`, `sd5p`, and `sd6p`—to
    add to a `softraid` device. To build a RAID-5 device out of these partitions,
    run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The response indicates that we’ve successfully created a RAID-5 device **1**,
    and it’s available as device `/dev/sd7` **2**. On a blank RAID disk, which you
    need to prepare just as you would any other new disk, run `fdisk -i sd7` and `disklabel`
    to create MBR and OpenBSD partitions, use `newfs` to create a filesystem on the
    new partitions, and you’re ready to go. (See the instructions for adding a new
    disk in [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems") for details.)
  prefs: []
  type: TYPE_NORMAL
- en: You could have made this a RAID-0, RAID-1, or RAID-4 device by choosing a different
    `-c` option. The tricky one is a concatenated `softraid`. To dump all the disks
    together into a single concatenated virtual partition, use `-c c`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: softraid Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check the health of each device in a RAID array, give `bioctl` the device
    name of the `softraid` device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We see that the five drives are in use, all assembled into a RAID-5 virtual
    drive. Everything here is healthy. Anything that doesn’t look roughly like this
    indicates a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Failed softraid Volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have a RAID-1, RAID-4, or RAID-5 `softraid` volume, you can lose a drive
    and not lose your data. `bioctl` tells you if a drive fails. Here, one of the
    drives in my `softraid` volume has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Looking closely at this, I can see that drives `sd2`, `sd3`, `sd4`, and `sd6`
    are still available and in use. All my data should still be intact, but I need
    to replace `sd5` before another disk fails.
  prefs: []
  type: TYPE_NORMAL
- en: Rebuilding Failed softraid Volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of this writing, you cannot rebuild a failed `softraid` RAID-4 or RAID-5
    device. You must back up your data, replace the failed drive, delete the `softraid`
    device, re-create the filesystem, and restore from backup. You can, however, rebuild
    a RAID-1 device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at replacing a disk in a RAID-1 device. Here’s what a healthy, three-disk
    `softraid` mirror might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that this RAID device has device node `sd5` **1** and includes the partitions
    *sd2p*, *sd3p*, and *sd4p* **2**.
  prefs: []
  type: TYPE_NORMAL
- en: We replace two disks and reboot this machine. Suddenly, the *softraid* device
    looks very different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Partitions *sd3p* and *sd4p* are missing. That’s because the underlying disks
    have been replaced.^([[24](#ftn.id433352)]) Prepare the replacement disks for
    software RAID, as discussed in [Preparing Disks for softraid](ch09.html#preparing_disks_for_softraid
    "Preparing Disks for softraid"). Then run `bioctl`, using the `-R` flag to specify
    the disk to replace in the `softraid` device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you check the status of the device using `bioctl`, you’ll see the disk status
    now says “Rebuilding.”
  prefs: []
  type: TYPE_NORMAL
- en: If you have a mirror with more than two disks, you must rebuild each disk separately.
    Rebuild the first disk, and then rebuild the second disk.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting softraid Devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove a `softraid` device from your system, pass `bioctl` the `-d` flag
    and the device name for the `softraid` device. Here’s how to remove the RAID-5
    device we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you delete the RAID device, you can’t get it back unless you re-create
    it and restore your data from backup.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing softraid Disks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`softraid` writes metadata at the beginning of the disks it uses. You need
    to overwrite this metadata before you can use the disks in another `softraid`
    device. Overwrite the first megabyte or so of the disk with `dd(1)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This erases the MBR partitions, any initial disklabels, and any filesystem information
    on the disk. You can now reuse these disks in `softraid` devices as normal disks.
  prefs: []
  type: TYPE_NORMAL
- en: Booting from a softraid Device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `softraid` feature is still in development. Eventually, you’ll be able to
    use the installer to build a software RAID device, install OpenBSD on that device,
    and run a full RAID configuration out of the box. But as I write this, you’ll
    need to jump through some hoops to make that happen. Rather than document a specific
    procedure that will change as OpenBSD completes `softraid` development, I’m going
    to tell you to search the Internet and the *misc@OpenBSD.org* archives for the
    most recent instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted Disk Partitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes I can see the future. When someone says, “I’ve encrypted my hard drive!”
    I have a psychic vision of them saying “I’ve lost all my data!” While encrypting
    a hard drive partition is warranted in some cases, most of the time, it’s just
    pretentious. In this section, I will do you the courtesy of assuming that you
    understand when you truly need disk encryption if you will do me the courtesy
    of not complaining to me when you lose your data.^([[25](#ftn.id458279)])
  prefs: []
  type: TYPE_NORMAL
- en: Creating Encrypted Partitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD includes disk encryption as a `bioctl(8)` option—specifically, like
    a RAID discipline. Where disk activity would normally be passed through a RAID
    discipline, here they pass through an encryption discipline. The encrypted disk
    even shows up as a `softraid` device. Much like the support for RAID-5, support
    for encrypted filesystems is experimental. Although it *should* work, don’t be
    shocked if some features are not yet included or if it eats your entire disk.
    Keep good backups. Reread the previous paragraph. And again—*please* don’t complain
    to me when it doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under OpenBSD, an encrypted volume can include only a single partition. Use
    the RAID type `C` to specify an encrypted volume. Here’s, how to create an encrypted
    volume on the *sd4p* partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When prompted **1**, enter a passphrase twice. A good passphrase is several
    words long, and includes a mix of characters, symbols, numbers, punctuation, and
    whitespace. The passphrase is the secret code used to encrypt and decrypt data,
    so the longer and more varied it is, the better. Remember this passphrase; you
    must enter it again to recover your data. Once you’ve entered your passphrase
    twice, `bioctl` creates the encrypted disk device. In this case, it has created
    encrypted disk `softraid0` as `disk sd5`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Encrypted Partitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not mount this new disk yet! Instead, use `fdisk` to check our new, encrypted
    partition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The underlying disk is blank, and our `fdisk` output looks like garbage, but
    this disk is now an encrypted volume.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the encrypted disk exists, create an MBR partition and add disklabel
    partitions, just as when you add any other disk. Then you can mount your encrypted
    device partition using the device node—again, just as with any other disk.
  prefs: []
  type: TYPE_NORMAL
- en: To unmount the decrypted partition, destroy the `softraid` device by passing
    `bioctl` the `-d` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To anyone who doesn’t have the passphrase, this partition now looks like random
    garbage.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Decryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have an encrypted partition, presumably you don’t want OpenBSD to automatically
    decrypt and mount it when the system boots. (The whole point of an encrypted partition
    is that only a person who has the passphrase can access the encrypted data.) Still,
    I’m not one to tell you not to shoot yourself in the foot, so if you must automatically
    decrypt the partition, you can do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file containing your passphrase. Give ownership of this file
    to root and set the permissions to `600` (read-write by owner; no access by other
    users), and then give this file to `bioctl(8)` with the `-p` flag. In this example,
    the encrypted disk is created as */dev/sd5* and there is a partition on */dev/sd5a*.
    I’ve stored my passphrase in the file */etc/passphrase*, so I could run something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Adding this to */etc/rc.securelevel* will mount this encrypted partition at
    boot.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a good idea of how to manage OpenBSD disks and filesystems.
    Next, we’ll look at some of OpenBSD’s special security features.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[21](#id344921)]) I don’t know what a dump level of 128m means, other than
    “not what I want.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([[22](#id330714)]) How many users do I mean by “a few?” When synchronizing
    UIDs across all of your systems begins to really, *really* annoy you, you no longer
    have a few users.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[23](#id367975)]) You could add a non-RAID partition in the unused space
    on the larger drive, but that would do terrible things to your system’s performance.
    Just buy more hard drives, you cheapskate.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[24](#id433352)]) If you need to force an error on a hard disk, removing
    the disk from the machine will certainly do it.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[25](#id458279)]) Not that I can help you—all I can do is say “I told you
    so.” On a related note: You can get tired of anything, no matter how pleasant,
    if you have to do it often enough.'
  prefs: []
  type: TYPE_NORMAL
