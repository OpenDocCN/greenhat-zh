- en: '![](../images/171-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/171-1.jpg)'
- en: '[**BUILDING A FRONT PANEL INTERFACE**](toc.html#chapter10)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**构建前面板接口**](toc.html#chapter10)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/as.jpg)'
- en: Buttons, light-emitting diodes (LEDs), and small alphanumeric displays are so
    common that we hardly notice them anymore. Printers, microwave ovens, phones,
    and DVD and CD players all use buttons, LEDs, and LCDs as part of their user interfaces—and
    it is likely that you will want to have buttons and LEDs on the front panel of
    your appliance, as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮和发光二极管（LED）以及小型字母数字显示屏如此常见，以至于我们几乎不再注意到它们。打印机、微波炉、电话以及DVD和CD播放器都使用按钮、LED和LCD作为它们用户界面的一部分——你很可能也希望在你的设备前面板上拥有按钮和LED。
- en: In this chapter, we will describe how to build a front panel UI. First, we will
    discuss the hardware used on front panels, and we will then show you how to design
    a UI and menu system for a front panel by reviewing the requirements and design
    of Laddie’s front panel UI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述如何构建一个前面板用户界面。首先，我们将讨论前面板上使用的硬件，然后通过回顾Laddie前面板用户界面的需求和设计，向您展示如何设计一个前面板的用户界面和菜单系统。
- en: 'We divided our coverage of the front panel interface into these sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前面板界面的覆盖分为以下几部分：
- en: Buttons, LEDs, and LCDs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮、LED和LCD
- en: Designing a front panel UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计前面板用户界面
- en: The Laddie front panel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laddie前面板
- en: Improving our design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进我们的设计
- en: We’ll start by looking at the details of front panel hardware. (If you’re uncomfortable
    with hardware or wiring diagrams, feel free to just skim this chapter.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看前面板硬件的细节。（如果你对硬件或布线图感到不舒服，可以自由地浏览本章。）
- en: '[**Buttons, LEDs, and LCDs**](toc.html#chapter10.1)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[**按钮、LED和LCD**](toc.html#chapter10.1)'
- en: This section introduces the kinds of hardware that you’ll find on an appliance’s
    front panel, including buttons, LEDs, and LCDs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了你将在设备前面板上找到的硬件类型，包括按钮、LED和LCD。
- en: '[***Buttons***](toc.html#chapter10.2)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[***按钮***](toc.html#chapter10.2)'
- en: The size of your production run may determine the type of hardware you use in
    your design, especially where buttons are concerned. When your appliance is produced
    as part of a large production run, buttons will usually be built directly onto
    the printed circuit board. Small production runs or prototypes, on the other hand,
    often use either a pre-built assembly or individual switches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的生产批量大小可能会决定你在设计中使用的硬件类型，尤其是在按钮方面。当你的设备作为大量生产的一部分被生产出来时，按钮通常会被直接安装在印刷电路板上。另一方面，小批量生产或原型通常使用预组装的组件或单个开关。
- en: Electrically speaking, buttons are simply switches that are, most often, normally
    open. Each button usually requires one digital input line that can be read by
    your processor. (Chapter 5 explains how you can use an input line to read the
    state of a single switch.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从电的角度来看，按钮仅仅是通常是常开状态的开关。每个按钮通常需要一个可以被你的处理器读取的数字输入线路。（第5章解释了如何使用输入线路来读取单个开关的状态。）
- en: '**Keypads**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**键盘**'
- en: A *keypad* is an array of buttons that is scanned for a closure. Scanning for
    a closure can reduce the total number of input and output lines needed in your
    hardware. The idea behind scanning a keypad is dividing the switches into an array
    of rows and columns and then examining the switches one row at a time. Keypads
    are described as *n-by-m*, indicating a array of switches with *n* rows and *m*
    columns. Each row is assigned an output line and each column is assigned an input
    line. Sixteen switches arranged as a 4-by-4 keypad would use eight I/O lines from
    the CPU, not 16.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*键盘*是一组按钮，用于扫描闭合。扫描闭合可以减少你硬件中所需的输入和输出线路的总数。扫描键盘背后的想法是将开关分成行和列的阵列，然后逐行检查开关。键盘被描述为*n-by-m*，表示有*n*行和*m*列的开关阵列。每一行分配一个输出线路，每一列分配一个输入线路。一个4-by-4键盘上排列的16个开关将使用CPU的8个I/O线路，而不是16个。'
- en: Using a keypad becomes a viable option when you have more than five or six buttons.
    You can use a microprocessor to help with keyboard scanning and other hardware-based
    I/O, but in a cost-sensitive appliance, your Linux-based code may need to do all
    of the scanning and low-level I/O. Some system-on-chip processors, such as the
    PXA270 from Marvell, have dedicated hardware on board to do keypad scanning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有五个或六个以上的按钮时，使用键盘成为一种可行的选择。你可以使用微处理器来帮助键盘扫描和其他基于硬件的I/O，但在成本敏感的设备中，你的基于Linux的代码可能需要执行所有的扫描和低级I/O。一些片上系统处理器，如Marvell的PXA270，在板上具有专门的硬件用于键盘扫描。
- en: Consider the 2-by-2 keypad circuit shown in Figure 10-1\. The pull-up resistors
    bias the column lines to V+, or a logic one, so the two inputs will read a logic
    one when no switches are closed. The two diodes on the output lines isolate one
    row from the other row. To scan the keypad, the processor puts zero volts (a logic
    zero) on row 0 and a logic one on row 1\. The processor reads the input port,
    and if input 0 is a logic zero, then it knows button A (at row 0, column 0) is
    being pressed. If the input 1 is a zero, then it knows button B (at row 0, column
    1) is being pressed. The processor then sets output 0 to a logic one and output
    1 to a logic zero. Now if input 0 is a zero, it knows button C (at row 1, column
    0) is being pressed, and if input 1 is a zero, then it knows button D (at row
    1, column 1) is being pressed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图10-1所示的2x2键盘电路。上拉电阻将列线偏置到V+，或逻辑1，因此当没有开关关闭时，两个输入将读取逻辑1。输出线上的两个二极管将一行与另一行隔离。为了扫描键盘，处理器将0伏特（逻辑0）置于行0，并将逻辑1置于行1。处理器读取输入端口，如果输入0是逻辑0，则它知道按钮A（位于行0，列0）被按下。如果输入1是零，则它知道按钮B（位于行0，列1）被按下。然后处理器将输出0设置为逻辑1，将输出1设置为逻辑0。现在如果输入0是零，它知道按钮C（位于行1，列0）被按下，如果输入1是零，则它知道按钮D（位于行1，列1）被按下。
- en: '![](../images/173-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/173-1.jpg)'
- en: '*Figure 10-1: A 2-by-2 keypad*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：2x2键盘*'
- en: Here is some simple code to scan the above keypad.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是扫描上述键盘的简单代码。
- en: '![](../images/173-2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/173-2.jpg)'
- en: This code illustrates the sequence of events fairly well, but you’ll probably
    want to use a loop if you are scanning more than a few rows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码很好地说明了事件序列，但如果你要扫描的行数超过几行，你可能想使用循环。
- en: '**Switch Bounce**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**开关抖动**'
- en: If you drop a ball bearing onto a steel plate, it will bounce. Switch closures
    can also be thought of as two metal pieces colliding with each other. Switch contacts
    bounce when they are closed and when they are opened. If you scan the keypad too
    quickly, you can erroneously detect a bounce as a new switch closure. The duration
    of switch bounces depends on the physical properties of the switch, so they can
    vary widely. The manufacturer of your switch can give you specifications, but
    you should be sure to measure the bounce time yourself. One way to avoid switch
    bounce is to scan the keypad more slowly, but slowing the scan too much can make
    the keypad seem sluggish. You can make the keypad more responsive and still avoid
    switch bounce by keeping a history of the last few scan values and reporting a
    new closure only when the saved values are the same but are different from the
    current value. This is the technique we use in the following subroutine that waits
    for a new keypress and returns the ASCII value of the key.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将滚珠轴承扔到钢板上，它会弹起。开关的闭合也可以看作是两个金属部件相互碰撞。开关接触在闭合和打开时都会发生抖动。如果你扫描键盘太快，可能会错误地将抖动检测为新的开关闭合。开关抖动的时间取决于开关的物理特性，因此它们可能变化很大。你的开关制造商可以给你提供规格，但你应该确保自己测量抖动时间。避免开关抖动的一种方法是将键盘扫描速度放慢，但扫描速度放慢太多会使键盘显得迟钝。你可以通过保留最后几次扫描值的历史记录，并且仅在保存的值与当前值相同但不同时报告新的闭合，来使键盘更加灵敏并避免开关抖动。这是我们以下子程序中使用的技术，该子程序等待新的按键并返回键的ASCII值。
- en: '![](../images/174-1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/174-1.jpg)'
- en: 'It is important that the scan rate for a keypad be constant. It is possible
    to do keypad scanning in a user-space program, but you may find that the scan
    rate varies widely and that the program uses much more of the CPU than necessary.
    It is best to use a real-time Linux kernel to get accurate scan timing if you
    want to scan from user space, or do what we did for Laddie: Put the keypad scanning
    into a simple character device driver so that accurate scan timing is provided
    by the Linux kernel.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于键盘的扫描速率保持恒定非常重要。可以在用户空间程序中进行键盘扫描，但你可能会发现扫描速率变化很大，并且程序使用的CPU比必要的多。如果你想在用户空间进行扫描，并希望获得准确的扫描时间，最好使用实时Linux内核，或者像我们在Laddie中做的那样：将键盘扫描放入简单的字符设备驱动程序中，以便Linux内核提供准确的扫描时间。
- en: '[***LEDs***](toc.html#chapter10.3)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[***LEDs***](toc.html#chapter10.3)'
- en: Using *light-emitting diodes (LEDs)* is one of the most intuitive, easiest,
    and cheapest ways to present status information from your application or appliance
    to the user or developer. LEDs come in round or rectangular plastic packages as
    well as in the form of surface mount chips. They also come in a wide variety of
    colors, with red, yellow, and green being the most popular. Some LED packages
    have two LED chips in them and can light with more than one color; these bi-color
    LEDs are great for a go-or-no-go status indication. Consider using a bezel or
    a diffuser if your application requires that the LED be easily visible. In our
    alarm application, we use a bright LED with a bezel so that it is easy to see
    when the system is in alarm.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *发光二极管（LED）* 是从你的应用或设备向用户或开发者展示状态信息最直观、最容易、最便宜的方式之一。LED有圆形或矩形的塑料封装，也有表面贴装芯片的形式。它们还有各种各样的颜色，红色、黄色和绿色是最受欢迎的。一些LED封装包含两个LED芯片，可以发出多种颜色；这些双色LED非常适合表示是或否的状态指示。如果你的应用需要LED易于可见，考虑使用边框或扩散器。在我们的警报应用中，我们使用带有边框的明亮LED，这样当系统处于警报状态时，它就很容易被看到。
- en: Usually, each LED uses one digital output line from your hardware. If you have
    a lot of LEDs (such as the 28 segments in a four-digit, seven-segment display
    on a digital clock, for example), you can scan the LEDs similarly to how you would
    scan a keypad, as described above. If you need to scan your LEDs, especially if
    they are seven-segment displays, you should use a device driver to make the scan
    timing precise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个LED都使用你的硬件的一个数字输出线。如果你有很多LED（例如数字时钟上四位七段显示的28个段，例如），你可以像扫描键盘一样扫描LED，如上所述。如果你需要扫描你的LED，特别是如果它们是七段显示器，你应该使用设备驱动程序来确保扫描时序的精确性。
- en: The human eye is drawn toward movement, and you can use this to your advantage
    in your front panel design. A flashing LED attracts much more attention than a
    static one. Color can also give meaning to an LED, but color blindness and the
    various cultural associations of colors make it a good idea to not rely too heavily
    on color to convey meaning.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 人眼会被运动所吸引，你可以在你的前面板设计中利用这一点。闪烁的LED比静态的LED更能吸引人的注意。颜色也可以给LED赋予意义，但色盲和各种颜色的文化关联使得过分依赖颜色来传达意义不是一个好主意。
- en: 'Some popular vendors for LEDs and LED hardware include:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的LED和LED硬件供应商包括：
- en: Digi-Key, Inc. ([http://www.digi-key.com](http://www.digi-key.com/))
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Digi-Key, Inc. ([http://www.digi-key.com](http://www.digi-key.com/))
- en: Jameco Electronics, Inc. ([http://www.jameco.com](http://www.jameco.com/))
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jameco Electronics, Inc. ([http://www.jameco.com](http://www.jameco.com/))
- en: Super Bright LEDs, Inc. ([http://www.superbrightleds.com](http://www.superbrightleds.com/))
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Super Bright LEDs, Inc. ([http://www.superbrightleds.com](http://www.superbrightleds.com/))
- en: '[***LCDs***](toc.html#chapter10.4)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[***LCDs***](toc.html#chapter10.4)'
- en: 'Small *liquid crystal displays (LCDs)* are standard interfaces for consumer
    appliances. Your use of an LCD will depend on the nature of your appliance and
    your customer’s expectations, but there are several reasons to include an LCD
    in your design:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 小型 *液晶显示器（LCD）* 是消费类设备的标准接口。你使用LCD的方式将取决于你的设备性质和客户的期望，但有几个原因说明为什么在设计时要包括LCD：
- en: '**Primary UI** A text-based LCD display can be the primary UI for your appliance.
    This is often the case for audio equipment, such as satellite receivers and network-attached
    audio players.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**主要用户界面** 文本基础的LCD显示器可以是你的设备的主要用户界面。这通常是音频设备的情况，如卫星接收器和网络连接的音频播放器。'
- en: '**Reliability** Network equipment often needs fail-safe access to configuration
    and status information. While using a serial port and a CLI is common, high-end
    network appliances often provide a keypad and LCD on the front panel for configuration.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠性** 网络设备通常需要安全访问配置和状态信息。虽然使用串行端口和CLI很常见，但高端网络设备通常在前面板上提供键盘和LCD进行配置。'
- en: '**Perceived value** There is nothing like an LCD (or even better, a vacuum
    florescent display) to distinguish one beige box from its competitors and to convince
    customers that they’re buying a high-end piece of equipment.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**感知价值** 没有什么比LCD（甚至更好的真空荧光显示器）更能区分一个米色的盒子与它的竞争对手，并让客户相信他们正在购买高端设备。'
- en: There are two common architectures used to interface an LCD to an appliance.
    The first is to have the Linux processor drive the LCD directly. This architecture
    is appropriate for low-cost, low-power, and high-volume appliances that require
    a graphic display. Common uses of this architecture include PDAs and cell phones.
    Several members of the ARM processor family have on-chip support for LCD displays.
    Examples include the EP9307 from Cirrus Logic and the AT91SAM926 from Atmel. Chapter
    11 describes how to build a UI for memory-mapped graphics displays.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常见的架构用于将LCD连接到电器。第一种是将Linux处理器直接驱动LCD。这种架构适用于需要图形显示器的低成本、低功耗和高产量电器。这种架构的常见用途包括个人数字助理和手机。ARM处理器家族的几个成员都支持片上LCD显示。例如，Cirrus
    Logic的EP9307和Atmel的AT91SAM926。第11章描述了如何为内存映射图形显示器构建用户界面。
- en: The second common architecture is to have the Linux processor deal with the
    LCD through a controller chip that is attached to a serial, parallel, or USB port.
    This architecture is appropriate for small production runs and appliances based
    on personal computer motherboards.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种常见的架构是Linux处理器通过连接到串行、并行或USB端口的控制器芯片来处理LCD。这种架构适用于小批量生产和基于个人计算机主板的电器。
- en: LCDs for this architecture usually have one to four lines of text with between
    10 and 40 characters per line. The most common controller chip for these displays
    is the ubiquitous HD44780, originally from Hitachi, but now available from several
    vendors. Displays based on the HD44780 usually have parallel input, but many have
    a daughter card that offers a serial or USB input, keyboard scanning, and LED
    outputs. Some displays with a daughter card give you the ability to program flash
    memory with text to display when the unit is first powered up. Programmable power-up
    text is particularly important for an appliance since responsiveness is critical
    to a successful UI. Displays with a daughter card and flash memory usually also
    have a programmable character set, which is useful if you want to display a logo
    or other simple graphic. We’ll have much more to say about the HD44780 later in
    this chapter when we review Laddie’s front panel hardware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种架构的LCD，通常有一到四行文本，每行10到40个字符。这些显示器的最常见控制器芯片是广泛使用的HD44780，最初来自日立，但现在可以从多个供应商处获得。基于HD44780的显示器通常具有并行输入，但许多都有提供串行或USB输入、键盘扫描和LED输出的子卡。一些带有子卡的显示器允许你在设备首次通电时编程闪存中的文本以显示。可编程的启动文本对于电器尤为重要，因为响应性对于成功的用户界面至关重要。带有子卡和闪存的显示器通常也具有可编程字符集，如果你想要显示标志或其他简单图形，这很有用。在本章后面当我们回顾Laddie的前面板硬件时，我们将有更多关于HD44780的讨论。
- en: 'There are several web pages and packages that support alphanumeric LCD displays
    under Linux. Two websites that you may find of particular value are [http://lcd4linux.sourceforge.net](http://lcd4linux.sourceforge.net/)
    and [http://lcdproc.org](http://lcdproc.org/). Alphanumeric LCD displays with
    serial, parallel, or USB inputs are available from several vendors. Here are a
    few that you might want to consider:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个网页和软件包支持Linux下的字母数字LCD显示器。两个你可能特别有用的网站是[http://lcd4linux.sourceforge.net](http://lcd4linux.sourceforge.net/)和[http://lcdproc.org](http://lcdproc.org/)。提供串行、并行或USB输入的字母数字LCD显示器可以从多个供应商处获得。以下是一些你可能想要考虑的供应商：
- en: Scott Edwards Electronics, Inc. ([http://www.seetron.com](http://www.seetron.com/))
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scott Edwards Electronics, Inc. ([http://www.seetron.com](http://www.seetron.com/))
- en: Crystalfontz America, Inc. ([http://www.crystalfontz.com](http://www.crystalfontz.com/))
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Crystalfontz America, Inc. ([http://www.crystalfontz.com](http://www.crystalfontz.com/))
- en: Matrix Orbital, Inc. ([http://www.matrixorbital.com](http://www.matrixorbital.com/))
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matrix Orbital, Inc. ([http://www.matrixorbital.com](http://www.matrixorbital.com/))
- en: Cwlinux Limited ([http://www.cwlinux.com](http://www.cwlinux.com/))
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cwlinux Limited ([http://www.cwlinux.com](http://www.cwlinux.com/))
- en: Decade Engineering ([http://www.decadenet.com](http://www.decadenet.com/))
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Decade Engineering ([http://www.decadenet.com](http://www.decadenet.com/))
- en: EarthLCD ([http://store.earthlcd.com](http://store.earthlcd.com/))
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EarthLCD ([http://store.earthlcd.com](http://store.earthlcd.com/))
- en: Using a standard I/O port does not preclude having a graphic display. For example,
    Decade Engineering’s BOB-4 takes commands and characters from a serial port and
    outputs to composite sync video, and the ezLCD from EarthLCD is a color graphic
    LCD with a 240-by-160-pixel resolution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准I/O端口并不会排除拥有图形显示器的可能性。例如，Decade Engineering的BOB-4从串行端口接收命令和字符，并将输出到复合同步视频，而EarthLCD的ezLCD是一款具有240×160像素分辨率的彩色图形LCD。
- en: '[**Designing a Front Panel UI**](toc.html#chapter10.5)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[**设计前面板用户界面**](toc.html#chapter10.5)'
- en: This section gives some tips on how to build a front panel UI. We’ll discuss
    various approaches to building a menu system for LCD displays, and we’ll offer
    some ideas on how to make your front panel responsive as soon as possible after
    your user powers on the appliance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些关于如何构建前面板用户界面的技巧。我们将讨论为液晶显示屏构建菜单系统的各种方法，并提供一些想法，以便在用户开启设备后尽快使前面板响应。
- en: '[***Be Simple***](toc.html#chapter10.6)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[***保持简单***](toc.html#chapter10.6)'
- en: The primary goal of an appliance is for it to do one thing well. To call your
    product an appliance is to promise that you will not overwhelm users with functions
    and options that they do not need. Your goal is to keep the appliance simple enough
    that a new or non-technical user can install the appliance in a few minutes without
    reading the manual. You can accomplish this by having reasonable defaults and
    by designing the UIs so they are easy to navigate. You can still give technical
    and sophisticated users access to all configuration options, but you should hide
    this complexity from novice users by putting it in an “Advanced Options” sub-menu.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的主要目标是它能很好地完成一项任务。将你的产品称为设备意味着你承诺不会用用户不需要的功能和选项让他们感到不知所措。你的目标是使设备足够简单，以便新用户或非技术用户可以在几分钟内安装设备而无需阅读说明书。你可以通过设置合理的默认值并设计易于导航的UI来实现这一点。你仍然可以向技术熟练的用户提供所有配置选项，但你应该通过将其放入“高级选项”子菜单来隐藏这种复杂性。
- en: The simplest UI on your appliance should be the buttons, LEDs, and LCDs on the
    front panel. When you design your front panel, consider assigning one button or
    LED to one function or status. A one-button interface is especially useful for
    the most common functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你设备上最简单的用户界面应该是前面板上的按钮、LED和LCD。当你设计前面板时，考虑将一个按钮或LED分配给一个功能或状态。单按钮界面对于最常用的功能特别有用。
- en: '[***Try, Fail, Try Again***](toc.html#chapter10.7)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[***尝试，失败，再尝试***](toc.html#chapter10.7)'
- en: Don’t expect to get your front panel right on the first try. It is very difficult
    to accurately anticipate what kind of menu flow and button labeling will be the
    most intuitive for users. Don’t be afraid to wear out the good will of your friends
    and neighbors by giving them a mock-up of your appliance and asking them to navigate
    the menu system. You may need to build and try several front panels before choosing
    the right one for your appliance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不要期望第一次就能设计出完美的前面板。准确预测哪种菜单流程和按钮标签对用户来说最直观是非常困难的。不要害怕通过向朋友和邻居展示你的设备原型并请他们导航菜单系统来消耗他们的好意。你可能需要构建和尝试几个前面板，才能为你的设备选择正确的那个。
- en: We’ve found several tricks that help in this area. The first is to build a prototype
    display with interchangeable paper faceplates. Install the paper faceplate, and
    ask new users to perform specific tasks. How quickly and easily the new users
    can navigate the menu system is the major criteria we used to select the best
    menu layout for Laddie. Figure 10-2 shows the paper faceplates we used for prototyping
    the Laddie front panel.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了一些有助于这个领域的技巧。第一个是构建一个带有可互换纸面板的原型显示屏。安装纸面板，并请新用户执行特定任务。新用户导航菜单系统的速度和容易程度是我们选择Laddie最佳菜单布局的主要标准。图10-2显示了我们在原型设计Laddie前面板时使用的纸面板。
- en: '![](../images/177-1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图10-2：带有纸面板的前面板](../images/177-1.jpg)'
- en: '*Figure 10-2: A front panel with paper faceplates*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：带有纸面板的前面板*'
- en: Another technique is to recognize that a menu system is a state machine and
    can be stored as a table. Instead of hard coding the states and transitions in
    a program, build a table that contains the state, event, next state, and processing
    to perform. Then store the state transition table in a separate file and load
    it when the LCD UI program initializes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是认识到菜单系统是一个状态机，可以存储为表格。而不是在程序中硬编码状态和转换，构建一个包含状态、事件、下一个状态和要执行的处理过程的表格。然后将状态转换表存储在单独的文件中，并在LCD
    UI程序初始化时加载。
- en: While nothing beats the user feedback from using real front panel hardware,
    you may find that you want to start by building a working prototype of the front
    panel using a web page, Tcl/Tk, or a character interface built with the curses
    library. You’ll appreciate being able to test various front panel designs before
    specifying your front panel hardware. An advantage of a web or Tcl/Tk version
    of the front panel is that you can use it as another type of UI on the finished
    appliance. For instance, we’ve found that the curses version of the Laddie front
    panel is sometimes easier to use and more capable than the Laddie CLI, though
    both run in an xterm session.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有什么能比使用真实的前面板硬件带来的用户反馈更好，但您可能会发现，您想从使用网页、Tcl/Tk或使用curses库构建的字符界面来构建前面板的工作原型开始。您会欣赏在指定前面板硬件之前测试各种前面板设计的能力。前面板的网页或Tcl/Tk版本的一个优点是，您可以用它作为最终设备上的另一种类型的用户界面。例如，我们发现Laddie前面板的curses版本有时比Laddie
    CLI更容易使用且功能更强大，尽管两者都在xterm会话中运行。
- en: Laddie has front panel emulators written using curses, Tcl/Tk, and JavaScript
    combined with PHP. The web-based front panel uses an image map on top of a photograph
    of the front panel hardware. The Tcl/Tk version is shown in Figure 10-3.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie的前面板模拟器是用curses、Tcl/Tk和JavaScript结合PHP编写的。基于网页的前面板使用一个位于前面板硬件照片之上的图像映射。Tcl/Tk版本如图10-3所示。
- en: '![](../images/178-1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/178-1.jpg)'
- en: '*Figure 10-3: A Laddie front panel implemented in Tcl/Tk*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：使用Tcl/Tk实现的Laddie前面板*'
- en: '[***Use LCD Menus and Modes***](toc.html#chapter10.8)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用LCD菜单和模式***](toc.html#chapter10.8)'
- en: If your appliance has an LCD display, you can add menus and status to your front
    panel UI. A *menu*, in this context, is a linear list of items to select. These
    items might be commands, configuration settings, or pathways into sub-menus. The
    interface will need to have buttons that allow users to navigate the list and
    to select desired items. Common navigation buttons include next item, previous
    item, select this item, and previous menu. The best way to avoid building a menu
    system that is *a maze of twisty passages, all alike* is to map out the menu system
    with a state transition diagram. Try to keep your transition diagram orthogonal
    so that directions like up, down, left, and right have meaning. Many LCD menu
    systems treat the LCD display as a window that sees part of the state transition
    diagram. An LCD assembly from Matrix Orbital that is made for this kind of menu
    structure is shown in Figure 10-4.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备有LCD显示屏，您可以在前面板用户界面中添加菜单和状态。在这个上下文中，*菜单*是一系列要选择的线性项目。这些项目可能是命令、配置设置或进入子菜单的路径。界面需要按钮，以便用户可以导航列表并选择所需的项目。为了避免构建一个像“迷宫一样曲折的通道，所有通道都一样”的菜单系统，最好用状态转换图来绘制菜单系统。尽量保持您的转换图正交，以便像上、下、左、右这样的方向有含义。许多LCD菜单系统将LCD显示屏视为一个窗口，可以看到状态转换图的一部分。一个为这种菜单结构制作的Matrix
    Orbital LCD组件如图10-4所示。
- en: '![](../images/178-2.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/178-2.jpg)'
- en: '*Figure 10-4: A typical front panel with menu navigation buttons*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：一个典型的带有菜单导航按钮的前面板*'
- en: You can save on cost and front panel space by eliminating the Up and Left buttons
    and having the Down and Right buttons wrap from the last menu option back to the
    first. Of course, some type of Enter button would still be required.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消除向上和向左按钮，并使向下和向右按钮从最后一个菜单选项回滚到第一个，您可以节省成本和前面板空间。当然，仍然需要某种类型的Enter按钮。
- en: 'Most LCD-based UIs operate in one of two modes: They display status if no buttons
    are pressed, and they display a menu when a button is pressed. For example, some
    printers have a one-line LCD display that reports *Ready* if there is no activity,
    shows *Printing* if it is receiving or printing, and enters a configuration menu
    if any button is pressed. Laddie has three modes: one to display status, one to
    display log messages, and one to display a menu for configurations changes and
    clearing alarms.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于LCD的用户界面在两种模式之一中运行：如果没有按按钮，则显示状态；如果按按钮，则显示菜单。例如，一些打印机有一个单行LCD显示屏，如果没有活动，则显示*Ready*；如果正在接收或打印，则显示*Printing*；如果按下任何按钮，则进入配置菜单。Laddie有三种模式：一种用于显示状态，一种用于显示日志消息，一种用于显示配置更改和清除警报的菜单。
- en: '[***Be Quick!***](toc.html#chapter10.9)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[***迅速行动！***](toc.html#chapter10.9)'
- en: The rule of thumb is that the front panel UI should be functional within two
    seconds of turning on the appliance. This section discusses some common techniques
    that can help you meet this goal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则表明，在打开设备后两秒内，前面板的用户界面应该能够正常工作。本节将讨论一些可以帮助你达到这一目标的常见技术。
- en: '**Boot Linux Faster**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**加快Linux引导速度**'
- en: There is quite a bit that can be done to improve the boot time for Linux. One
    technique avoids a boot entirely by doing a suspend and resume, instead. A *suspend*
    copies the memory and state of the computer to a file or disk partition. A *resume*
    reloads the previously saved memory. To set up a suspend and resume on your system,
    build your kernel with software suspend enabled, and get your appliance into the
    state that you want your users to see after power on. Issue the suspend command
    (this may be hibernate, swsusp, or a write into /proc, depending on your system)
    to save the system state to the swap partition. Properly handled, the suspend
    image on the swap partition can actually be the software that ships on your appliance.
    There are configurable scripts that can run on suspend and resume, and you can
    modify these scripts to restart network connections and to reset the clock. See
    [http://www.suspend2.net](http://www.suspend2.net/) for more details. Be sure
    to read the HOWTO section on *Keep image mode*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以提高Linux的引导时间。一种技术是通过挂起和恢复来避免整个引导过程。一个*挂起*会将计算机的内存和状态复制到一个文件或磁盘分区。一个*恢复*会重新加载之前保存的内存。要在你的系统上设置挂起和恢复，构建一个带有软件挂起功能的内核，并将你的设备设置成你希望在开机后用户看到的那个状态。发出挂起命令（这可能是休眠、swsusp或写入/proc，具体取决于你的系统）以将系统状态保存到交换分区。如果处理得当，交换分区上的挂起镜像实际上可以是你的设备上提供的软件。有一些可配置的脚本可以在挂起和恢复时运行，你可以修改这些脚本以重新启动网络连接和重置时钟。有关更多详细信息，请参阅[http://www.suspend2.net](http://www.suspend2.net/)上的*保持镜像模式*部分。务必阅读*保持镜像模式*部分的HOWTO部分。
- en: Software suspend does not improve the load time for the kernel itself, but there
    are several techniques that do. For example, you can build your kernel with module
    support disabled and with only the minimum number of device drivers that you need.
    This reduces the time needed to load modules and should remove the need for an
    initial RAM disk (initrd). You might be able to avoid loading the kernel entirely
    if you can execute it directly from ROM or flash memory. This technique is called
    *execute in place (XIP)*. Using the kernel option quiet to disable printk messages
    during boot can save several hundred milliseconds. These and many other techniques
    are explained on the Consumer Electronics Linux Forum website at [www.celinuxforum.org](http://www.celinuxforum.org/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 软件挂起并不会提高内核本身的加载时间，但有一些技术可以实现这一点。例如，你可以构建一个没有模块支持且只包含所需的最小数量的设备驱动程序的内核。这可以减少加载模块所需的时间，并应该消除对初始RAM磁盘（initrd）的需求。如果你能够直接从ROM或闪存中执行内核，你可能甚至可以完全避免加载内核。这种技术被称为*原地执行（XIP）*。使用内核选项quiet来在引导过程中禁用printk消息可以节省几百毫秒。这些以及其他许多技术都在消费电子Linux论坛网站上进行了解释，网址为[www.celinuxforum.org](http://www.celinuxforum.org/)。
- en: After the kernel starts, the first program to run is usually /sbin/init, which
    executes the script /etc/rc.d/rc.sysinit. The rc.sysinit file sets up vital services
    and starts the other init scripts. On a consumer appliance you should probably
    replace the entire set of init scripts with one or two custom scripts. This can
    be a lot of work, but the time savings can be tremendous. A good way to start
    is to boot your system with the kernel option init=/bin/sh and manually bring
    up your appliance one command at a time. Try to get the button and LED UIs running
    as quickly as possible, deferring the non–front panel programs until the end of
    the initialization. Start programs in the background if you can, but be careful
    not to background a program if it must complete before another program you need
    can start. The InitNG package by Jimmy Wennlund is a popular init script alternative
    that is optimized for a faster boot.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 内核启动后，第一个运行的程序通常是/sbin/init，它执行/etc/rc.d/rc.sysinit脚本。rc.sysinit文件设置关键服务并启动其他init脚本。在消费类设备上，你可能需要用一到两个自定义脚本替换整个init脚本集。这可能是一项大量工作，但节省的时间可能非常可观。一个好的开始方法是使用内核选项init=/bin/sh引导系统，并逐个手动启动你的设备。尽可能快地运行按钮和LED用户界面，将非前面板程序推迟到初始化的末尾。如果可能，在后台启动程序，但要注意不要将必须在另一个程序启动之前完成的程序放入后台。Jimmy
    Wennlund的InitNG包是一个流行的init脚本替代品，它针对更快的引导进行了优化。
- en: If the above techniques are not sufficient to get your front panel working quickly,
    you may want to add a microcontroller to your design.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述技术不足以快速使前面板工作，你可能想在设计中添加一个微控制器。
- en: '**Use a Microcontroller**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用微控制器**'
- en: You can use a microcontroller to handle the buttons, LEDs, and LCD in your UI.
    Microcontrollers are single-chip computers with on-board RAM, ROM, CPU, and I/O.
    Common microcontrollers include the Microchip PIC and the Atmel AVR.¹ These controllers
    are a great way to display messages on an LCD immediately after boot and to make
    the buttons and keypad responsive immediately. Let’s consider a DVD player as
    an example. After power-on, the user will usually open the disc drawer, insert
    a disc, close the drawer, and press Play. If the drawer mechanism is tied directly
    to your Linux system, the user must wait for Linux to boot before starting the
    above process. If, on the other hand, you have a microcontroller handling the
    drawer mechanism and Open button, you can immediately display *Ready* on the LCD
    and make the button usable. By the time the user has opened the drawer, loaded
    the disc, and pressed Play, the Linux part of the DVD player will probably be
    done booting. Of course, once Linux is running, it will want to control the drawer
    mechanism directly by treating the microcontroller as one of its peripherals.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用微控制器来处理UI中的按钮、LED和LCD。微控制器是带有板上RAM、ROM、CPU和I/O的单芯片计算机。常见的微控制器包括Microchip
    PIC和Atmel AVR。¹ 这些控制器是立即在启动后显示消息在LCD上以及使按钮和键盘响应的绝佳方式。让我们以DVD播放器为例。在开机后，用户通常会打开光盘托盘，插入光盘，关闭托盘，然后按播放。如果托盘机构直接连接到你的Linux系统，用户必须等待Linux启动才能开始上述过程。另一方面，如果你有一个微控制器处理托盘机构和打开按钮，你可以在LCD上立即显示*就绪*并使按钮可用。当用户打开托盘、加载光盘并按播放时，DVD播放器的Linux部分可能已经完成了启动。当然，一旦Linux运行，它将想要直接控制托盘机构，将微控制器视为其外围设备之一。
- en: '**Use the Main CPU as a Microcontroller**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**将主CPU用作微控制器**'
- en: Adding a microcontroller increases the cost, power requirement, and printed
    circuit board space of an appliance. An alternative is to carve out a piece of
    the main CPU to use as a microcontroller while Linux is starting. You can modify
    the bootloader to set up a timer interrupt and use the interrupt handler to provide
    a front panel UI. You’ll need to modify Linux so that it does not touch the timer
    or interrupt handler while booting. Once Linux is running, it can take over the
    timer and interrupt, making the front panel hardware just another device that
    it manages. This technique describes a form of virtual machine (VM); as they become
    more popular, you may find that a VM provides all the hooks necessary to be used
    as an I/O controller.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加微控制器会增加设备的成本、功耗和印刷电路板空间。一种替代方法是，在Linux启动时，从主CPU中划分出一部分作为微控制器使用。你可以修改引导加载程序来设置定时器中断，并使用中断处理程序提供前面板用户界面。你需要修改Linux，使其在启动时不要触摸定时器或中断处理程序。一旦Linux运行，它可以接管定时器和中断，使前面板硬件只是它管理的另一个设备。这种技术描述了一种虚拟机（VM）的形式；随着它们的普及，你可能会发现VM提供了所有必要的钩子，可以作为I/O控制器使用。
- en: '**Don’t Shut Down**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要关闭**'
- en: A common technique to make an appliance more responsive is to never shut it
    down. Instead, you can build your appliance to enter a low power state when the
    user presses the Off button. A low power state might include having a slower CPU
    clock and removing power to as many peripherals as possible. However, you should
    be aware that this approach has fallen into disfavor as more and more consumers
    demand that *Off* means zero power consumption.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使设备更响应的一种常见技术是永远不要关闭它。相反，你可以构建你的设备，当用户按下关机按钮时进入低功耗状态。低功耗状态可能包括降低CPU时钟速度并尽可能多地移除电源到外围设备。然而，你应该意识到，随着越来越多的消费者要求“关闭”意味着零功耗，这种方法已经不再受欢迎。
- en: '**Give Feedback**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供反馈**'
- en: If you can’t be quick, at least try to give the user an idea of what the system
    is doing. Don’t be afraid to modify the Linux kernel to send simplified boot status
    messages to the LCD. Telling the user what is happening can help him or her tolerate
    the 10- to 20-second boot time of Linux.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能快速响应，至少尝试给用户一个系统正在做什么的印象。不要害怕修改Linux内核以向LCD发送简化的启动状态消息。告诉用户正在发生的事情可以帮助他们忍受Linux的10到20秒的启动时间。
- en: Giving feedback should not be limited to just the boot process. Give the user
    constant feedback by bringing the Ethernet activity LED to the front panel or
    having the LCD display rotate through various appliance statistics. Be sure to
    indicate error conditions clearly and unambiguously.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈不应仅限于启动过程。通过将以太网活动 LED 显示在前面板或让 LCD 显示旋转显示各种设备统计信息，为用户提供持续的反馈。务必清楚地、明确地指示错误条件。
- en: '[**The Laddie Front Panel**](toc.html#chapter10.10)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Laddie 前面板**](toc.html#chapter10.10)'
- en: 'Our requirements for the Laddie front panel UI were that we be able to view
    either system status or log messages, and that we have the minimal set of commands
    necessary to manage the system. We gave Laddie’s LCD UI three modes: Status, Logs,
    and Menu. The *Status* display reports whether there are any alarms, the *Logs*
    mode shows the last two log messages, and the *Menu* mode lets a user clear, test,
    enable, and disable an alarm zone. There are four buttons for navigating the menu
    system, and a flashing LED indicates an alarm in the system.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Laddie 前面板用户界面的要求是能够查看系统状态或日志消息，并且拥有管理系统的最小命令集。我们为 Laddie 的 LCD UI 设计了三种模式：状态、日志和菜单。*状态*显示报告是否有任何警报，*日志*模式显示最后两条日志消息，而*菜单*模式允许用户清除、测试、启用和禁用警报区域。有四个按钮用于导航菜单系统，一个闪烁的
    LED 指示系统中的警报。
- en: The Laddie LCD UI listens for log messages from logmuxd and opens a PostgreSQL/RTA
    connection to the alarm daemon (ladd). The DB connection to ladd is used for configuration
    changes and to request the current status. The diagram in Figure 10-5 illustrates
    how these daemons connect.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie LCD UI 监听来自 logmuxd 的日志消息，并打开到警报守护进程（ladd）的 PostgreSQL/RTA 连接。到 ladd
    的数据库连接用于配置更改和请求当前状态。图 10-5 中的图解说明了这些守护进程如何连接。
- en: '![](../images/181-1.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/181-1.jpg)'
- en: '*Figure 10-5: Architecture of the Laddie front panel UI*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：Laddie 前面板 UI 架构*'
- en: Our front panel uses a parallel port to control a HD44780-based LCD (with two
    lines of 16 characters each) and to scan a 4-button, 2-by-2 keypad. The frame
    is made of wood, and a paper faceplate made it easy to try different front panel
    labeling. Figure 10-6 shows a picture of the front panel showing alarms in zones
    2 and 5.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前面板使用并行端口来控制基于 HD44780 的 LCD（每行 16 个字符，共两行）和扫描一个 4 按钮、2x2 的键盘。框架由木材制成，一个纸制面板使得尝试不同的前面板标签变得容易。图
    10-6 显示了一个显示区域 2 和 5 警报的前面板图片。
- en: '![](../images/182-1.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/182-1.jpg)'
- en: '*Figure 10-6: A picture of the Laddie front panel*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：Laddie 前面板的图片*'
- en: '[***Laddie LCD Menu System***](toc.html#chapter10.11)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[***Laddie LCD 菜单系统***](toc.html#chapter10.11)'
- en: 'The menu system we chose for Laddie’s front panel is always in one of three
    modes: Status, Logs, or Menu. This description of Laddie’s menu system might make
    more sense if you can see one in action as you read. If you have a PC running
    the Laddie CD, you can use the web-based front panel emulator at [http://192.168.1.11/front_panel](http://192.168.1.11/front_panel).
    We’ll show just the text of the display and you can picture what it would look
    like on a real display. Status mode shows which, if any, zones are in alarm.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 Laddie 前面板选择的菜单系统始终处于三种模式之一：状态、日志或菜单。如果你在阅读时能看到一个实际的操作，那么对 Laddie 菜单系统的描述可能更容易理解。如果你有一个运行
    Laddie CD 的 PC，你可以使用位于 [http://192.168.1.11/front_panel](http://192.168.1.11/front_panel)
    的基于 Web 的前面板模拟器。我们将只展示显示屏的文本，你可以想象它在实际显示屏上的样子。状态模式显示哪些区域（如果有）处于警报状态。
- en: '![](../images/182-2.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/182-2.jpg)'
- en: 'Logs mode shows the last two log messages that were received. Alarm system
    log messages are rewritten and forwarded by logmuxd. They include the time that
    the event occurred, as well as a description of the event. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 日志模式显示接收到的最后两条日志消息。警报系统日志消息由 logmuxd 重写和转发。它们包括事件发生的时间以及事件的描述。例如：
- en: '![](../images/182-3.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/182-3.jpg)'
- en: The user can toggle between Status and Logs modes by pressing the Display button.
    The default mode at program start is Status.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过按 Display 按钮在状态和日志模式之间切换。程序启动时的默认模式是状态。
- en: If the user presses the Command, Zone, or Enter button, the display switches
    to Menu mode. When going into Menu mode, the system saves the previous mode (Status
    or Logs). This lets the user revert to the previous mode when he or she exits
    Menu mode.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下命令、区域或 Enter 按钮，显示屏将切换到菜单模式。进入菜单模式时，系统会保存先前的模式（状态或日志）。这使用户在退出菜单模式时可以返回到先前的模式。
- en: 'The first screen displayed in Menu mode lets the user clear all the alarms
    with one more button press. The display is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单模式下显示的第一屏允许用户通过再按一个按钮来清除所有报警。显示内容为：
- en: '![](../images/183-1.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/183-1.jpg)'
- en: 'Subsequent presses of the Command button rotate through the available commands.
    The top line of the display does not change; only the second line rotates through:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按下命令按钮的后续操作会在可用的命令之间循环。显示屏的顶部行不会改变；只有第二行会循环：
- en: '![](../images/183-2.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/183-2.jpg)'
- en: The Zone button increments the zone from one to five and then back to one.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 区域按钮将区域从1增加到5，然后回到1。
- en: 'After the user has selected a command and a zone, a press of the Enter button
    sends the SQL command to the LAD daemon to make the requested change. After sending
    the command, the menu system displays:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用户选择了一个命令和一个区域后，按下Enter按钮会将SQL命令发送到LAD守护进程以执行所需更改。发送命令后，菜单系统显示：
- en: '![](../images/183-3.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/183-3.jpg)'
- en: The *Command Sent* message is displayed for about two seconds, and then the
    display reverts to the mode (Status or Logs) it saved before it went into Menu
    mode. The user can exit Menu mode at any time by pressing the Display button,
    which recalls the previous mode (Status or Logs) and reverts to that mode. In
    addition, if the user abandons a Menu session by not pressing any button for about
    10 seconds, the system times out and reverts to the previous display (Status or
    Logs).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “命令已发送”信息显示约两秒钟，然后显示屏恢复到进入菜单模式之前保存的模式（状态或日志）。用户可以通过按显示屏按钮随时退出菜单模式，该按钮会恢复先前的模式（状态或日志）并回到该模式。此外，如果用户在约10秒内没有按任何按钮而放弃菜单会话，系统将超时并恢复到先前的显示（状态或日志）。
- en: We hope our simple menu system for Laddie gives you some ideas for what to include
    in your front panel menu.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望Laddie的简单菜单系统能给你一些关于在前面板菜单中包含什么的想法。
- en: '[***Laddie Front Panel Hardware***](toc.html#chapter10.12)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[***Laddie前面板硬件***](toc.html#chapter10.12)'
- en: The Laddie front panel uses a parallel port to scan a 2-by-2 keypad, to control
    an alarm LED, and to control an HD44780-based, two-line, 16-character LCD display.
    We provide a Linux 2.6 character device driver for the keypad, LED, and alphanumeric
    display.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie前面板使用并行端口扫描2x2键盘，控制报警LED，以及控制基于HD44780的16字符双行LCD显示屏。我们为键盘、LED和数字显示屏提供了Linux
    2.6字符设备驱动程序。
- en: '**Schematics**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**原理图**'
- en: The wiring diagram for the hardware of our prototype front panel is shown in
    Figure 10-7\. Signal frequencies in this circuit are fairly low, so either wire
    wrap or point-to-point wiring should be fine. None of the component values are
    critical, and the values shown should be taken as guides, not as requirements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件原型前面板的接线图如图10-7所示。该电路的信号频率相对较低，因此可以使用绕线或点对点接线。没有任何组件值是关键的，显示的值应被视为指南，而不是要求。
- en: '![](../images/184-1.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/184-1.jpg)'
- en: '*Figure 10-7: Schematic of the Laddie front panel*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：Laddie前面板原理图*'
- en: Our prototype uses a second parallel port for the front panel. (The first parallel
    port was used, you may recall, for the alarm system zone sensors.) We use the
    data lines of the parallel port for the character input to the display. Two of
    the parallel port’s control lines are used for the register select and write strobe.
    A third control line from the parallel port controls the alarm LED. Two data lines
    and two status lines are used for scanning the four-button keypad. From your understanding
    of how a scanned keypad works, you may be able to add the five zone switches to
    this schematic, putting all the Laddie hardware on one parallel port.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原型使用第二个并行端口作为前面板。 (你可能记得，第一个并行端口被用于报警系统区域传感器。) 我们使用并行端口的数据线向显示屏输入字符。并行端口的两条控制线用于寄存器选择和写选通。并行端口的一条控制线控制报警LED。两条数据线和两条状态线用于扫描四键键盘。根据你对扫描键盘工作原理的理解，你可能能够将五个区域开关添加到这个原理图中，将所有的Laddie硬件放在一个并行端口上。
- en: '**The HD44780 Display Controller**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**HD44780 显示控制器**'
- en: An HD44780-based alphanumeric display can be thought of as a mini-terminal.
    Like any terminal, you write ASCII characters to it and it displays them. This
    terminal’s eight-bit character set includes the printable ASCII characters, a
    subset of the Katakana character set, and 16 user-defined characters. The actual
    character set depends on which version of HD4478 you have, but the character set
    for the Samsung KS0066U shown in Figure 10-8 is fairly typical. Note that the
    character code corresponds mostly to the ASCII code. For example, the code for
    *A* is 0x41, which is also the ASCII code for *A*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 HD44780 的字母数字显示器可以被视为一个迷你终端。像任何终端一样，你向它写入 ASCII 字符，它就会显示它们。这个终端的八位字符集包括可打印的
    ASCII 字符，Katakana 字符集的一个子集，以及 16 个用户定义的字符。实际的字符集取决于你拥有的 HD4478 版本，但图 10-8 中显示的
    Samsung KS0066U 的字符集相当典型。请注意，字符代码主要对应于 ASCII 码。例如，*A* 的代码是 0x41，这也是 *A* 的 ASCII
    码。
- en: '![](../images/185-1.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/185-1.jpg)'
- en: '*Figure 10-8: A typical HD44780 character set*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：典型的 HD44780 字符集*'
- en: '**The HD44780 Command Set**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**HD44780 命令集**'
- en: An HD44780 display accepts both commands and characters. Figure 10-9 shows a
    typical command set for the HD44780\. Initialization commands can clear the display,
    turn it on or off, and specify whether the interface uses four or eight bits.
    Cursor commands control the cursor type (block or underline), whether or not the
    cursor is visible, whether the cursor or the display moves after displaying a
    character, and whether the movement is to the left or the right. Other commands
    let you move the cursor to a specific location and to read and write to the user-defined
    character generator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: HD44780 显示器接受命令和字符。图 10-9 显示了 HD44780 的典型命令集。初始化命令可以清除显示，打开或关闭显示，并指定接口使用四位或八位。光标命令控制光标类型（块或下划线），光标是否可见，显示字符后光标或显示是否移动，以及移动是向左还是向右。其他命令允许你将光标移动到特定位置，以及读取和写入用户定义的字符发生器。
- en: '![](../images/185-2.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/185-2.jpg)'
- en: '*Figure 10-9: The HD44780 command set*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：HD44780 命令集*'
- en: 'Our initialization of the HD44780 consists of the following command sequence:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 HD44780 的初始化包括以下命令序列：
- en: '![](../images/186-1.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/186-1.jpg)'
- en: We’ve found that after initialization, the only command we use is the move cursor
    command—and we only use it to move the cursor to the first column of either the
    top or bottom row.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现初始化后，我们使用的唯一命令是移动光标命令——我们只使用它将光标移动到顶部或底部行的第一列。
- en: '**Sending Commands and Characters to the Laddie Front Panel**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**向 Laddie 前面板发送命令和字符**'
- en: You can read status and configuration information from the HD44780 if you want,
    but many designs, including ours, connects the read/write pin to ground, making
    the part write only. This saves a pin (since it is not controlling the R/W line),
    and it is just as easy to maintain any necessary state information—cursor location,
    for example—in the controlling software.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以从 HD44780 读取状态和配置信息，但包括我们的设计在内的许多设计都将读/写引脚连接到地，使该部分只写。这节省了一个引脚（因为它不控制
    R/W 线），并且维护任何必要的状态信息——例如光标位置——在控制软件中同样简单。
- en: 'Our HD44780 design has 10 pins that tie to the microprocessor: eight data lines,
    a pin to specify either command or character data (RS), and a strobe pin to tell
    to tell the HD44780 that new data is available (E). The eight output lines on
    the parallel port connect directly to the eight data pins on the HD44780\. If
    your hardware design has fewer pins, you can configure the part to use a four-bit
    bus instead of an eight-bit bus. Of course, this doubles the number of steps needed
    to write a byte to the part.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的 HD44780 有 10 个引脚连接到微处理器：八个数据线，一个引脚用于指定命令或字符数据（RS），以及一个用于通知 HD44780 新数据可用的选通引脚（E）。并行端口上的八个输出线直接连接到
    HD44780 的八个数据引脚。如果你的硬件设计有更少的引脚，你可以配置该部分使用四线总线而不是八线总线。当然，这会将写入该部分所需的步骤数量加倍。
- en: Since both characters and commands are eight bits in length, we need another
    way to differentiate commands and data. Consider, for example, the byte 0x20\.
    Is this a space or a configuration command? Since both commands and characters
    are eight bits, the HD44780 uses another pin, the RS pin, to distinguish between
    the two. You can set the RS pin to a zero for commands and to a one for character
    data. One of the issues to decide in designing the device driver is how to control
    this pin.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符和命令都是8位长度，我们需要另一种方法来区分命令和数据。例如，考虑字节0x20。这是空格还是配置命令？由于命令和字符都是8位，HD44780使用另一个引脚，即RS引脚，来区分两者。你可以将RS引脚设置为0以表示命令，设置为1以表示字符数据。在设计设备驱动程序时需要决定的一个问题是如何控制这个引脚。
- en: Data is transferred to the HD44780 on the high-to-low transition of the E pin.
    The data must be valid for at least half a microsecond before the E line goes
    low. The actual setup time is a function of the brand of HD44780 and its oscillator
    frequency. In our device driver we use usleep() to delay two microseconds before
    setting E low.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在E引脚从高到低的转换时传输到HD44780。数据必须在E线变低之前至少有效半个微秒。实际的设置时间取决于HD44780的品牌及其振荡器频率。在我们的设备驱动程序中，我们使用usleep()在将E线置低之前延迟两微秒。
- en: 'Relative to the schematic given above, the sequence for writing to the HD44780
    is:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于上面给出的原理图，写入HD44780的序列如下：
- en: Output the character or command to the data register.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符或命令输出到数据寄存器。
- en: Set the RS line high or low.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RS线置高或置低。
- en: Set the E line high.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将E线置高。
- en: Wait two microseconds.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待两微秒。
- en: Set the E line low.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将E线置低。
- en: Wait at least five milliseconds before writing the next byte.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在写入下一个字节之前至少等待五毫秒。
- en: The HD44780 can take several milliseconds to execute some commands. You can
    read the status of the display to tell you when to write the next byte, or you
    can do what we did, which is just wait at least five milliseconds between writes.
    The exact time is dependent on the version of HD44780 that you use. For this book
    we used a display we bought on the surplus market, so we had to experiment a little
    to find the right delay.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: HD44780可能需要几个毫秒来执行某些命令。你可以读取显示的状态来告诉你何时写入下一个字节，或者你可以像我们一样，只需在写入之间至少等待五毫秒。确切的时间取决于你使用的HD44780版本。对于这本书，我们使用的是在二手市场上购买的显示器，因此我们不得不进行一些实验来找到正确的延迟。
- en: '**Design Notes**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计注意事项**'
- en: 'While the HD44780-based display can be thought of as a simple ASCII terminal,
    there were a couple of decisions we needed to make when we designed our API and
    device driver. The first was how to handle the RS pin. Since both commands and
    display characters are eight bits in length, we could not mix display characters
    and commands in the same byte stream. We saw three ways to get around this problem:
    We could send commands using an ioctl, we could use an escape sequence to bury
    the commands in the character stream, or we could have two different devices for
    the display, one for characters and one for commands. We chose to use an escape
    sequence. The HD44780 we used had no display characters in the range of 0x10 to
    0x1F, so we used 0x10 as the escape code for HD44780 commands and 0x11 as the
    escape code for commands to control the front panel LED.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于HD44780的显示器可以被视为一个简单的ASCII终端，但在我们设计API和设备驱动程序时，我们需要做出一些决定。第一个决定是如何处理RS引脚。由于命令和显示字符都是8位长度，我们不能在同一个字节流中混合显示字符和命令。我们看到了三种解决这个问题的方法：我们可以使用ioctl发送命令，我们可以使用转义序列将命令隐藏在字符流中，或者我们可以为显示器使用两个不同的设备，一个用于字符，一个用于命令。我们选择使用转义序列。我们使用的HD44780没有0x10到0x1F范围内的显示字符，所以我们使用0x10作为HD44780命令的转义码，使用0x11作为控制前面板LED的命令的转义码。
- en: The other consideration in our design was how to handle the five-millisecond
    delay between writes. We could have put a usleep(5000) between writes, but this
    would have been a problem when updating all 32 characters on our display. (You
    may recall that the whole reason for writing a device driver was to have a guaranteed
    scan rate for the keypad.) We handled the five-millisecond delay by writing all
    output bytes into a circular buffer and reading one byte from the buffer each
    time we scanned the keypad. This slowed the maximum rate that we can output characters
    but was simple and effective.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计中的另一个考虑是如何处理写入之间的五毫秒延迟。我们本可以在写入之间放置一个usleep(5000)，但这在更新我们显示屏上的所有32个字符时将是一个问题。（你可能还记得，编写设备驱动程序的全部原因是为了确保键盘的扫描速率。）我们通过将所有输出字节写入一个环形缓冲区，并在每次扫描键盘时从缓冲区中读取一个字节来处理五毫秒的延迟。这降低了我们输出字符的最大速率，但简单且有效。
- en: The Linux device driver that we wrote to drive our display is available on the
    CD. Look in the source files under front_panel.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的用于驱动我们显示屏的Linux设备驱动程序可在CD上找到。请在front_panel源文件下查找。
- en: '**Further Reading**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: The HD44780 came out quite some time ago and is in fact no longer available.
    Nonetheless, it set the standard for alphanumeric LCD displays, and HD44780-compatible
    parts are still available from several vendors. A web search will locate data
    sheets for several HD44780-compatible parts, including the Samsung KS0066U that
    we used.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: HD44780已经推出很长时间了，实际上已经不再可用。尽管如此，它为字母数字LCD显示屏设定了标准，并且HD44780兼容部件仍然可以从几家供应商那里获得。网络搜索将定位到几个HD44780兼容部件的数据表，包括我们使用的三星KS0066U。
- en: 'Our review of the HD44780 is very far from complete. If you are considering
    using any alphanumeric displays on your appliance, you might want to make use
    of some of the online references that we used:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对HD44780的审查远未完成。如果你在考虑在你的设备上使用任何字母数字显示屏，你可能想利用我们使用的在线参考资料：
- en: '[**http://www.epemag.wimborne.co.uk/resources.htm**](http://www.epemag.wimborne.co.uk/resources.htm)
    A simple but complete introduction to the HD44780'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[**http://www.epemag.wimborne.co.uk/resources.htm**](http://www.epemag.wimborne.co.uk/resources.htm)
    对HD44780的简单但完整的介绍'
- en: '[**http://home.iae.nl/users/pouweha/lcd/lcd.shtml**](http://home.iae.nl/users/pouweha/lcd/lcd.shtml)
    Offers details on HD44780 interfacing'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[**http://home.iae.nl/users/pouweha/lcd/lcd.shtml**](http://home.iae.nl/users/pouweha/lcd/lcd.shtml)
    提供了HD44780接口的详细信息'
- en: '[**http://www.eio.com/datashet.htm**](http://www.eio.com/datashet.htm) Data
    sheets on HD44780-compatible parts'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[**http://www.eio.com/datashet.htm**](http://www.eio.com/datashet.htm) HD44780兼容部件的数据表'
- en: '[***Laddie Front Panel UI***](toc.html#chapter10.13)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[***Laddie前面板UI***](toc.html#chapter10.13)'
- en: 'In earlier sections of this chapter we reviewed the requirements, operations,
    and hardware for the Laddie front panel. In this section we’ll look at the software
    that implements the front panel UI. We’ll break our discussion into three areas:
    the software for the front panel, the various front panel emulators, and the software
    architecture common to both. Let’s start with the common architecture.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们审查了Laddie前面板的需求、操作和硬件。在本节中，我们将查看实现前面板UI的软件。我们将讨论分为三个领域：前面板的软件、各种前面板模拟器以及两者共有的软件架构。让我们从共同的架构开始。
- en: '**UI Software Architecture**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI软件架构**'
- en: The front panel software uses an event-driven state machine. Events include
    button presses, the expiration of a timer, and arriving log messages that indicate
    a possible change of state in the alarm system. Output from the program includes
    SQL commands sent to the Laddie daemon, a flag to flash (or not flash) the LED,
    and the text displayed on the LCD.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面板软件使用事件驱动的状态机。事件包括按钮按下、定时器到期以及到达的日志消息，这些消息指示警报系统可能的状态变化。程序输出包括发送给Laddie守护进程的SQL命令、用于闪烁（或不闪烁）LED的标志以及LCD上显示的文本。
- en: '![](../images/188-1.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/188-1.jpg)'
- en: '*Figure 10-10: Laddie front panel architecture*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：Laddie前面板架构*'
- en: 'Several state variables are used. The primary state variable, unimaginatively
    called State, indicates the type of information displayed on the LCD: status,
    log, or menu. There are also states for the brief *Command Sent* message and for
    an indication that the program could not open an SQL connection to the ladd daemon.
    Another state variable, Curcmd, contains an integer that indicates which command
    to show when the user is in the menu. The *Command* button cycles Curcmd through
    the five possible front panel commands. The Zone state variable holds the zone
    number to use for the current command. The Zone button cycles Zone through the
    five possible zone numbers.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了几个状态变量。主要状态变量，命名为 State，没有想象力地表示了在 LCD 上显示的信息类型：状态、日志或菜单。还有用于简短 *命令已发送* 消息的状态，以及表示程序无法打开到
    ladd 守护进程的 SQL 连接的状态。另一个状态变量 Curcmd 包含一个整数，指示当用户在菜单中时显示哪个命令。*命令* 按钮使 Curcmd 在五个可能的前面板命令之间循环。Zone
    状态变量保存用于当前命令的区域号。Zone 按钮使 Zone 在五个可能的区域号之间循环。
- en: '![](../images/188-2.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/188-2.jpg)'
- en: '*Figure 10-11: Events and states in the front panel menu system*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：前面板菜单系统中的事件和状态*'
- en: The code to handle the state and event processing is fairly easy to read once
    you’ve reviewed the operation of the front panel. The state machine code is implemented
    twice—once in C for the hardware and several emulators, including a web-based
    emulator written in JavaScript and PHP.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你审查了前面板的操作，处理状态和事件处理的代码就相对容易阅读。状态机代码实现了两次——一次是用 C 语言为硬件和几个仿真器编写的，包括用 JavaScript
    和 PHP 编写的基于 Web 的仿真器。
- en: '**lad216**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**lad216**'
- en: 'The C code to generate the proper escape sequences is in the lad216 program.
    The program uses standard in and out, so if you build the hardware described above
    and install our /dev/lad_pad driver, you could tie the lad216 program to the hardware
    with the command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 生成正确转义序列的 C 代码在 lad216 程序中。程序使用标准输入和输出，所以如果你构建了上面描述的硬件并安装了我们的 `/dev/lad_pad`
    驱动程序，你可以使用以下命令将 lad216 程序与硬件连接起来：
- en: lad216 </dev/lad_pad >/dev/lad_pad
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: lad216 </dev/lad_pad >/dev/lad_pad
- en: 'The code is in three files: main.c which has the select loop, menu.c which
    has the state machine, and lad216.c which encodes the output for display on the
    lad_pad hardware. Using standard input and output makes it easy to connect lad216
    to the various front panel emulators described below.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分布在三个文件中：`main.c` 包含选择循环，`menu.c` 包含状态机，`lad216.c` 编码输出以在 lad_pad 硬件上显示。使用标准输入和输出使得将
    lad216 连接到下面描述的各种前面板仿真器变得容易。
- en: '**Front Panel Emulators**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**前面板仿真器**'
- en: A front panel emulator is a great way to test a front panel design without actually
    building it. Front panel emulators that ship with the finished product are particularly
    nice for end users who do not want to be burdened with learning different UIs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面板仿真器是测试前面板设计而不实际构建它的好方法。与成品一起提供的前面板仿真器对于不想学习不同 UI 的最终用户来说尤其不错。
- en: We went a little overboard building front panel emulators for Laddie, building
    one that uses C and curses, one that uses Tcl/Tk and the X Window system, and
    one that uses JavaScript and HTML. You can choose which emulator to examine based
    on your preferred programming language.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在为 Laddie 构建前面板仿真器方面有点过度，构建了一个使用 C 和 curses 的仿真器，一个使用 Tcl/Tk 和 X Window 系统的仿真器，以及一个使用
    JavaScript 和 HTML 的仿真器。你可以根据你喜欢的编程语言选择要检查的仿真器。
- en: The curses version replaces lad216.c with cur216.c, but still uses the main.c
    and menu.c files. You can try the curses front panel emulator by booting the Laddie
    CD and telnetting into the appliance. The cur216 executable is in the default
    path.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: curses 版本用 `cur216.c` 替换了 `lad216.c`，但仍然使用 `main.c` 和 `menu.c` 文件。你可以通过启动 Laddie
    CD 并通过 telnet 连接到设备来尝试 curses 前面板仿真器。`cur216` 可执行文件在默认路径中。
- en: The Tcl/Tk version, x216.tcl, is based on the lad216 executable, using Tcl/Tk
    to replace the lad_pad hardware with a Tcl equivalent. The Laddie CD does not
    include the X Window system so you can not run x216.tcl on a booted Laddie appliance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Tcl/Tk 版本，`x216.tcl`，基于 lad216 可执行文件，使用 Tcl/Tk 替换 lad_pad 硬件与 Tcl 等效。Laddie
    CD 不包括 X Window 系统，因此你无法在启动的 Laddie 设备上运行 `x216.tcl`。
- en: You can try the web-based front panel emulator by booting Laddie and pointing
    your browser to [http://192.168.1.11/front_panel](http://192.168.1.11/front_panel).
    The index.html file should open a window with a photograph of our actual front
    panel hardware. The buttons are tied to an image map and operate the same way
    the buttons do on the real system. The LED is either a static image of the LED
    in the off state, or is an animated GIF image of the flashing LED. The HTML of
    the LCD uses CSS to specify a fairly large monospaced font.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过启动Laddie并将浏览器指向[http://192.168.1.11/front_panel](http://192.168.1.11/front_panel)来尝试基于网络的用户界面模拟器。index.html文件应该打开一个窗口，显示我们实际的前端面板硬件的照片。按钮与图像映射相关联，并且以与真实系统上的按钮相同的方式操作。LED可以是关闭状态的LED的静态图像，也可以是闪烁LED的动画GIF图像。LCD的HTML使用CSS指定了一个相当大的等宽字体。
- en: The techniques used in the web emulator are simple, and you may find them of
    use if you ever build a web emulator of your own front panel. To illustrate these
    techniques, let’s look at how the LED image is controlled. In the HTML we specify
    the exact location of the image and give it a name, *led.*
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络模拟器中使用的技巧很简单，如果你自己构建一个前端面板的网络模拟器，可能会觉得它们很有用。为了说明这些技巧，让我们看看如何控制LED图像。在HTML中，我们指定图像的确切位置并给它一个名字，*led*。
- en: <div id="led" style="position:absolute; left:27; top:20;"></div>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <div id="led" style="position:absolute; left:27; top:20;"></div>
- en: The JavaScript code uses XMLHttpRequest() to request the alarm status from a
    PHP script tied to the webserver running on the appliance. The value returned
    is zero if there are no alarms. The JavaScript to control the LED image is straightforward.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码使用XMLHttpRequest()从与在设备上运行的web服务器相关联的PHP脚本请求警报状态。如果没有警报，返回的值是零。控制LED图像的JavaScript代码很简单。
- en: '![](../images/190-1.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/190-1.jpg)'
- en: The JavaScript program uses the exact same architecture and state machine as
    described above, and it uses XMLHttpRequest() instead of select() to asynchronously
    wait for log messages. After the arrival of any log message, the code queries
    ladd for the latest status and redraws the web page based on the new status information.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript程序使用与上述描述完全相同的架构和状态机，并且它使用XMLHttpRequest()而不是select()来异步等待日志消息。在收到任何日志消息后，代码查询ladd以获取最新状态，并根据新的状态信息重新绘制网页。
- en: '[**Improving Our Design**](toc.html#chapter10.14)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[**改进我们的设计**](toc.html#chapter10.14)'
- en: The Laddie front panel could be improved in several ways. The lad_pad driver
    could have been simplified had we separated the LCD data lines from the two output
    lines used for keypad scanning. Separating them would have allowed the convenient
    use of a second timer just for LCD output characters, which would have made the
    LCD more responsive to output. Another improvement in the driver would have been
    to pull more than one character from the queue if the characters were not sent
    to the LCD. For example, there is no reason to wait 20 milliseconds between characters
    if the character is an escape code or an LED command.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie的前端面板可以通过几种方式改进。如果我们把LCD数据线从用于键盘扫描的两个输出线中分离出来，lad_pad驱动程序可能会简化。分离它们将允许方便地使用一个第二定时器，专门用于LCD输出字符，这将使LCD对输出的响应更快。在驱动程序中的另一个改进是，如果字符没有发送到LCD，可以从队列中取出多个字符。例如，如果字符是转义码或LED命令，就没有理由在字符之间等待20毫秒。
- en: The photograph in the web front panel is of the hardware we built. This is a
    little backward. Normally, you would build and test the emulated web-based version
    before building the actual hardware.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 网络前端面板上的照片是我们构建的硬件。这有点反常。通常，你会在构建实际硬件之前先构建和测试基于网络模拟的版本。
- en: The web-based front panel has a more subtle problem. It uses XMLHttpRequest()
    to wait for arriving log messages, and after receiving one, it sets a timer to
    make the next request.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的用户界面有一个更微妙的问题。它使用XMLHttpRequest()等待到达的日志消息，并在收到一条消息后设置一个定时器以进行下一次请求。
- en: setTimeout("GetLogMsg()", 100);
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: setTimeout("GetLogMsg()", 100);
- en: This arrangement, no matter how short the timer, will miss log messages that
    arrive close together. You can see this in action by setting three alarms and
    clearing them all at once. The log display will capture the log of the first alarm
    being cleared, but it will miss one or both of the logs for the next two. The
    main web interface has the same problem, but solves it by numbering the log messages.
    After updating the web page, the JavaScript code in the main web UI reads the
    ID of the last message received from logmuxd. If the ID of the log in the web
    page does not include the most recent log message, the page is redrawn using the
    most recent log messages.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排，无论计时器有多短，都会错过相邻到达的日志消息。你可以通过设置三个闹钟并一次性清除它们来看到这个问题的实际效果。日志显示将捕获清除第一个闹钟的日志，但会错过下一个两个中的一个或两个日志。主Web界面也有同样的问题，但通过编号日志消息来解决。在更新网页后，主Web
    UI中的JavaScript代码读取从logmuxd接收到的最后一条消息的ID。如果网页中日志的ID不包含最新的日志消息，页面将使用最新的日志消息重新绘制。
- en: '[**Summary**](toc.html#chapter10.15)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[**摘要**](toc.html#chapter10.15)'
- en: In this chapter we’ve looked at how you can build an effective front panel using
    buttons, LEDs, and small, text-only LCDs. We saw that scanning a keypad or LED
    array can reduce the number of I/O lines you need, and that movement, such as
    a blinking LED, can draw the eye and let the user know that the appliance is running.
    We also noted that how well your appliance is accepted may depend on how quickly
    you make user interaction possible and how easily users can navigate your menu
    system.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用按钮、LED和小型纯文本LCD构建有效的面板。我们了解到扫描键盘或LED阵列可以减少所需的I/O线数量，并且移动，如闪烁的LED，可以吸引眼球并让用户知道设备正在运行。我们还注意到，你的设备被接受的程度可能取决于你多快让用户交互成为可能，以及用户如何容易地导航你的菜单系统。
- en: We reviewed Laddie’s front panel design, including its menu system, hardware,
    UI software, and various front panel emulators. Our hardware design includes an
    HD44780 display and a 2-by-2 keypad. The source for our 2.6 character device driver,
    lad_pad, is on the CD and might be a nice introduction to kernel modules.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们审查了Laddie的前面板设计，包括其菜单系统、硬件、UI软件以及各种前面板模拟器。我们的硬件设计包括一个HD44780显示屏和一个2x2键盘。我们2.6字符设备驱动程序lad_pad的源代码在CD上，可能是一个很好的内核模块的入门介绍。
- en: The UI menu system is implemented as a state machine, and is implemented twice.
    The first implementation, using C, uses standard in and out so that it can be
    tied to either a Tcl/Tk emulator or to the real front panel. The second implementation
    uses JavaScript and image maps for the front panel buttons and uses XMLHttpRequest()
    to receive the asynchronous log messages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: UI菜单系统被实现为一个状态机，并且实现了两次。第一次实现，使用C语言，使用标准输入和输出，以便它可以连接到Tcl/Tk模拟器或真实的面板。第二次实现使用JavaScript和图像映射来处理前面板按钮，并使用XMLHttpRequest()接收异步日志消息。
- en: '![](../images/192-1.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/192-1.jpg)'
- en: __________________
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: __________________
- en: ¹ You can program the Atmel AVR using C on a Linux workstation. See [www.avrfreaks.org](http://www.avrfreaks.org/)
    for more information.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 你可以使用Linux工作站上的C语言编程Atmel AVR。更多信息请见[www.avrfreaks.org](http://www.avrfreaks.org/)。
- en: ² You may need to set the terminal type, since telnet does not set it for you.
    I use xterm on my desktop, so when I telnet to the Laddie appliance, I set the
    terminal type with the command export TERM=xterm.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ² 你可能需要设置终端类型，因为telnet不会为你设置。我在我的桌面上使用xterm，所以当我telnet到Laddie设备时，我使用命令export
    TERM=xterm来设置终端类型。
