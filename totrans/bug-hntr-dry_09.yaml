- en: Appendix A. Hints for Hunting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 搜索技巧
- en: This appendix describes, in more depth than in the text, some vulnerability
    classes, exploitation techniques, and common issues that can lead to bugs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录比正文更深入地描述了一些漏洞类别、利用技术和可能导致错误的一些常见问题。
- en: A.1 Stack Buffer Overflows
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A.1 栈缓冲区溢出
- en: Buffer overflows are memory corruption vulnerabilities that can be categorized
    by *type* (also known as *generation*). Today the most relevant ones are *stack
    buffer overflows* and *heap buffer overflows*. A buffer overflow happens if more
    data is copied into a buffer or array than the buffer or array can handle. It’s
    that simple. As the name implies, stack buffer overflows are happening in the
    stack area of a process memory. The stack is a special memory area of a process
    that holds both data and metadata associated with procedure invocation. If more
    data is stuffed in a buffer declared on the stack than that buffer can handle,
    adjacent stack memory may be overwritten. If the user can control the data and
    the amount of data, it is possible to manipulate the stack data or metadata to
    gain control of the execution flow of the process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出是内存损坏漏洞，可以根据 *类型*（也称为 *生成*）进行分类。今天最相关的是 *栈缓冲区溢出* 和 *堆缓冲区溢出*。如果向缓冲区或数组中复制的数据多于缓冲区或数组能处理的，就会发生缓冲区溢出。就这么简单。正如其名所示，栈缓冲区溢出发生在进程内存的栈区域。栈是进程的一个特殊内存区域，它持有与过程调用相关的数据和元数据。如果在栈上声明的缓冲区中放入比缓冲区能处理更多的数据，相邻的栈内存可能会被覆盖。如果用户可以控制数据和数据量，那么就有可能操纵栈数据或元数据，以控制进程的执行流程。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The following descriptions of stack buffer overflows are related to the 32-bit
    Intel platform (IA-32)*.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下关于栈缓冲区溢出的描述与 32 位英特尔平台（IA-32）相关*。'
- en: Every function of a process that is executed is represented on the stack. The
    organization of this information is called a *stack frame*. A stack frame includes
    the data and metadata of the function, as well as a *return address* used to find
    the caller of the function. When a function returns to its caller, the return
    address is popped from the stack and into the instruction pointer (program counter)
    register. If you can overflow a stack buffer and then overwrite the return address
    with a value of your choosing, you get control over the instruction pointer when
    the function returns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的每个进程函数都在栈上表示。这种信息的组织称为 *栈帧*。栈帧包括函数的数据和元数据，以及一个 *返回地址*，用于找到函数的调用者。当函数返回到其调用者时，返回地址从栈中弹出并进入指令指针（程序计数器）寄存器。如果你可以溢出一个栈缓冲区，然后覆盖返回地址为你选择的一个值，当函数返回时，你将控制指令指针。
- en: There are a lot of other possible ways to take advantage of a stack buffer overflow
    for example, by manipulating function pointers, function arguments, or other important
    data and metadata on the stack.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 利用栈缓冲区溢出有很多其他可能的利用方式，例如，通过操作函数指针、函数参数或栈上的其他重要数据和元数据。
- en: 'Let’s look at an example program:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例程序：
- en: Example A-1. Example program *stackoverflow.c*
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 A-1. 示例程序 *stackoverflow.c*
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The example program in [Example A-1](apa.html#example_program_stackoverflow.c
    "Example A-1. Example program stackoverflow.c") contains a simple stack buffer
    overflow. The first command-line argument (line 15) is used as a parameter for
    the function called `overflow()`. In `overflow()`, the user-derived data is copied
    into a stack buffer with a fixed size of 12 bytes (see lines 6 and 8). If we supply
    more data than the buffer can hold (more than 12 bytes), the stack buffer will
    overflow, and the adjacent stack data will be overwritten with our input data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 A-1](apa.html#example_program_stackoverflow.c "示例 A-1. 示例程序 stackoverflow.c")
    中的示例程序包含一个简单的栈缓冲区溢出。第一个命令行参数（第 15 行）被用作调用 `overflow()` 函数的参数。在 `overflow()` 函数中，用户提供的数据被复制到一个固定大小为
    12 字节的栈缓冲区中（见第 6 和 8 行）。如果我们提供比缓冲区能容纳更多的数据（超过 12 字节），栈缓冲区将会溢出，并且相邻的栈数据将被我们的输入数据覆盖。'
- en: '[Figure A-1](apa.html#stack_frame_illustrating_a_buffer_overfl "Figure A-1. Stack
    frame illustrating a buffer overflow") illustrates the stack layout right before
    and after the buffer overflow. The stack grows downward (toward lower memory addresses),
    and the *return address (RET)* is followed by another piece of metadata called
    the *saved frame pointer (SFP)*. Below that is the buffer that is declared in
    the `overflow()` function. In contrast to the stack, which grows downward, the
    data that is filled into a stack buffer grows toward higher memory addresses.
    If we supply a sufficient amount of data for the first command-line argument,
    then our data will overwrite the buffer, the SFP, the RET, and adjacent stack
    memory. If the function then returns, we control the value of RET, which gives
    us control over the instruction pointer (`EIP` register).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图A-1](apa.html#stack_frame_illustrating_a_buffer_overfl "图A-1. 展示缓冲区溢出的栈帧")说明了缓冲区溢出前后栈的布局。栈向下增长（向较低内存地址），返回地址（RET）之后是另一块称为*保存帧指针（SFP）*的元数据。下面是`overflow()`函数中声明的缓冲区。与向下增长的栈不同，填充到栈缓冲区中的数据是向较高内存地址增长的。如果我们为第一个命令行参数提供足够的数据，那么我们的数据将覆盖缓冲区、SFP、RET以及相邻的栈内存。如果函数随后返回，我们控制RET的值，这使我们能够控制指令指针（`EIP`寄存器）。'
- en: '![Stack frame illustrating a buffer overflow](httpatomoreillycomsourcenostarchimages939337.png.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![展示缓冲区溢出的栈帧](httpatomoreillycomsourcenostarchimages939337.png.jpg)'
- en: Figure A-1. Stack frame illustrating a buffer overflow
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图A-1. 展示缓冲区溢出的栈帧
- en: 'Example: Stack Buffer Overflow Under Linux'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：Linux下的栈缓冲区溢出
- en: 'To test the program from [Example A-1](apa.html#example_program_stackoverflow.c
    "Example A-1. Example program stackoverflow.c") under Linux (Ubuntu 9.04), I compiled
    it without stack canary support (see Section C.1):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux（Ubuntu 9.04）下测试[示例A-1](apa.html#example_program_stackoverflow.c "示例A-1.
    示例程序 stackoverflow.c")，我编译时没有启用栈保护（见C.1节）：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, I started the program in the debugger (see Section B.4 for more information
    about gdb) while supplying 20 bytes of user input as a command-line argument (12
    bytes to fill the stack buffer plus 4 bytes for the SFP plus 4 bytes for the RET):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我在调试器中启动了程序（有关gdb的更多信息，见B.4节），并提供了20个字节的用户输入作为命令行参数（12个字节用于填充栈缓冲区，加上4个字节用于SFP，再加上4个字节用于RET）：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I gained control over the instruction pointer (see the `EIP` register), as
    the return address was successfully overwritten with the four `C`s supplied from
    the user input (hexadecimal value of the four `C`s: `0x43434343`).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经控制了指令指针（见`EIP`寄存器），因为返回地址被用户输入提供的四个`C`成功覆盖（四个`C`的十六进制值：`0x43434343`）。
- en: 'Example: Stack Buffer Overflow Under Windows'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：Windows下的栈缓冲区溢出
- en: 'I compiled the vulnerable program from [Example A-1](apa.html#example_program_stackoverflow.c
    "Example A-1. Example program stackoverflow.c") without security cookie (`/GS`)
    support under Windows Vista SP2 (see Section C.1):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Windows Vista SP2下编译了来自[示例A-1](apa.html#example_program_stackoverflow.c "示例A-1.
    示例程序 stackoverflow.c")的易受攻击程序，没有启用安全cookie（`/GS`）支持（见C.1节）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, I started the program in the debugger (see Section B.2 for more information
    about WinDbg) while supplying the same input data as in the Linux example above.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我在调试器中启动了程序（有关WinDbg的更多信息，见B.2节），并提供了与上面Linux示例中相同的输入数据。
- en: 'As [Figure A-2](apa.html#stack_buffer_overflow_under_windows_open "Figure A-2. Stack
    buffer overflow under Windows (WinDbg output)") shows, I got the same result as
    under Linux: control over the instruction pointer (see the `EIP` register).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图A-2](apa.html#stack_buffer_overflow_under_windows_open "图A-2. Windows下的栈缓冲区溢出（WinDbg输出）")所示，我得到了与Linux下相同的结果：控制了指令指针（见`EIP`寄存器）。
- en: '![Stack buffer overflow under Windows (WinDbg output)](httpatomoreillycomsourcenostarchimages939339.png.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Windows下的栈缓冲区溢出（WinDbg输出）](httpatomoreillycomsourcenostarchimages939339.png.jpg)'
- en: Figure A-2. Stack buffer overflow under Windows (WinDbg output)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图A-2. Windows下的栈缓冲区溢出（WinDbg输出）
- en: 'This was only a short introduction to the world of buffer overflows. Numerous
    books and white papers are available on this topic. If you want to learn more,
    I recommend Jon Erickson’s *Hacking: The Art of Exploitation*, 2nd edition (No
    Starch Press, 2008), or you can type *buffer overflows* into Google and browse
    the enormous amount of material available online.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是对缓冲区溢出世界的简要介绍。关于这个主题有大量的书籍和白皮书可供参考。如果你想了解更多，我推荐阅读乔恩·埃里克森的《Hacking: The Art
    of Exploitation》，第2版（No Starch Press，2008年），或者你可以在Google中输入*buffer overflows*并浏览在线上可用的海量资料。'
- en: A.2 NULL Pointer Dereferences
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A.2 空指针解引用
- en: Memory is divided into pages. Typically, a process, a thread, or the kernel
    cannot read from or write to a memory location on the zero page. [Example A-2](apas02.html#using_unowned_memoryman_example
    "Example A-2. Using unowned memory—an example NULL pointer dereference") shows
    a simple example of what happens if the zero page gets referenced due to a programming
    error.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 内存被分为页。通常，一个进程、线程或内核不能从零页的内存位置读取或写入。[示例 A-2](apas02.html#using_unowned_memoryman_example
    "示例 A-2. 使用未拥有的内存——一个空指针解引用的例子") 展示了由于编程错误导致引用零页会发生什么的一个简单例子。
- en: Example A-2. Using unowned memory—an example NULL pointer dereference
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 A-2. 使用未拥有的内存——一个空指针解引用的例子
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In line 10 of [Example A-2](apas02.html#using_unowned_memoryman_example "Example A-2. Using
    unowned memory—an example NULL pointer dereference") the data structure `packet`
    is initialized with `NULL`, and in line 12 a structure member gets referenced.
    Since `packet` points to `NULL`, this reference can be represented as `NULL->value`.
    This leads to a classic *NULL pointer dereference* when the program tries to read
    a value from memory page zero. If you compile this program under Microsoft Windows
    and start it in the Windows Debugger WinDbg (see Section B.2), you get the following
    result:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 A-2](apas02.html#using_unowned_memoryman_example "示例 A-2. 使用未拥有的内存——一个空指针解引用的例子")的第
    10 行，数据结构 `packet` 被初始化为 `NULL`，而在第 12 行引用了一个结构成员。由于 `packet` 指向 `NULL`，这个引用可以表示为
    `NULL->value`。当程序尝试从内存页零读取值时，这会导致经典的 *空指针解引用*。如果你在 Microsoft Windows 下编译此程序并使用
    Windows 调试器 WinDbg（见第 B.2 节）启动它，你会得到以下结果：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The access violation is caused when the value of `EAX`, which is `0x00000000`,
    gets referenced. You can get more information on the cause of the crash by using
    the debugger command `!analyze -v`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `EAX` 的值为 `0x00000000` 时，访问违规发生。你可以通过使用调试器命令 `!analyze -v` 获取有关崩溃原因的更多信息：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: NULL pointer dereferences usually lead to a crash of the vulnerable component
    (denial of service). Depending on the particular programming error, NULL pointer
    dereferences can also lead to arbitrary code execution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 空指针解引用通常会导致易受攻击组件崩溃（服务拒绝）。根据特定的编程错误，空指针解引用也可能导致任意代码执行。
- en: A.3 Type Conversions in C
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A.3 C 中的类型转换
- en: 'The C programming language is quite flexible in handling different data types.
    For example, in C it’s easy to convert a character array into a signed integer.
    There are two types of conversion: *implicit* and *explicit*. In programming languages
    like C, implicit type conversion occurs when the compiler automatically converts
    a variable to a different type. This usually happens when the initial variable
    type is incompatible with the operation you are trying to perform. Implicit type
    conversions are also referred to as *coercion*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C 编程语言在处理不同数据类型方面非常灵活。例如，在 C 中，将字符数组转换为有符号整数很容易。有两种类型的转换：*隐式* 和 *显式*。在像 C 这样的编程语言中，隐式类型转换发生在编译器自动将变量转换为不同类型时。这通常发生在初始变量类型与你要执行的操作不兼容时。隐式类型转换也被称为
    *强制转换*。
- en: Explicit type conversion, also known as *casting*, occurs when the programmer
    explicitly codes the details of the conversion. This is usually done with the
    cast operator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 显式类型转换，也称为 *类型强制转换*，发生在程序员明确编码转换的细节时。这通常使用强制转换运算符来完成。
- en: 'Here is an example of an implicit type conversion (coercion):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个隐式类型转换（强制转换）的例子：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, an implicit conversion occurs between unsigned int and signed
    int.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，unsigned int 和 signed int 之间发生了隐式转换。
- en: 'And here is an example of an explicit type conversion (casting):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显式类型转换（类型强制转换）的例子：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, an explicit conversion occurs between char and signed int.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，char 和 signed int 之间发生了显式转换。
- en: 'Type conversions can be very subtle and cause a lot of security bugs. Many
    of the vulnerabilities related to type conversion are the result of conversions
    between unsigned and signed integers. Below is an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换可能非常微妙，并可能导致许多安全漏洞。许多与类型转换相关的漏洞是整数无符号和有符号之间转换的结果。以下是一个例子：
- en: Example A-3. A signed/unsigned conversion that leads to a vulnerability (*implicit.c*)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 A-3. 导致漏洞的有符号/无符号转换 (*implicit.c*)
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The source code in [Example A-3](apas03.html#a_signed_solidus_unsigned_conversion
    "Example A-3. A signed/unsigned conversion that leads to a vulnerability (implicit.c)")
    contains a signed/unsigned conversion vulnerability that is quite similar to the
    one I found in FFmpeg (see [Chapter 4](ch04.html "Chapter 4. NULL Pointer FTW")).
    Can you spot the bug?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例A-3](apas03.html#a_signed_solidus_unsigned_conversion "示例A-3. 导致漏洞的有符号/无符号转换
    (implicit.c)")中的源代码包含一个与我在FFmpeg中找到的相当类似的有符号/无符号转换漏洞（见[第4章](ch04.html "第4章。NULL指针FTW")）。你能找到这个错误吗？'
- en: 'In line 14, a length value is read in from user input and stored in the signed
    int variable `length`. The `get_user_length()` function is a dummy that always
    returns the “user input value” `0xffffffff`. Let’s assume this is the value that
    was read from the network or from a data file. In line 18, the program checks
    whether the user-supplied value is less than 12\. If it is, the string “`argument
    length ok`” will be printed on the screen. Since `length` gets assigned the value
    `0xffffffff` and this value is much bigger than 12, it may seem obvious that the
    string will not be printed. However, let’s see what happens if we compile and
    run the program under Windows Vista SP2:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第14行，从用户输入中读取一个长度值并存储在有符号整型变量`length`中。`get_user_length()`函数是一个占位符，总是返回“用户输入值”`0xffffffff`。假设这是从网络或数据文件中读取的值。在第18行，程序检查用户提供的值是否小于12。如果是，屏幕上会打印出字符串“`参数长度正确`”。由于`length`被分配了值`0xffffffff`，而这个值远大于12，所以看起来字符串不会打印出来。然而，让我们看看在Windows
    Vista SP2下编译和运行程序会发生什么：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see from the output, line 19 was reached and executed. How did this
    happen?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，第19行被达到并执行了。这是怎么发生的？
- en: On a 32-bit machine, an unsigned int has a range of 0 to 4294967295 and a signed
    int has a range of –2147483648 to 2147483647\. The unsigned int value `0xffffffff`
    (4294967295) is represented in binary as `1111 1111 1111 1111 1111 1111 1111 1111`
    (see [Figure A-3](apas03.html#the_role_of_the_most_significant_bit_ope "Figure A-3. The
    role of the Most Significant Bit (MSB)")). If you interpret the same bit pattern
    as a signed int, there is a change in sign that results in a signed int value
    of −1\. The sign of a number is indicated by the *sign bit*, which is usually
    represented by the *Most Significant Bit (MSB)*. If the MSB is 0, the number is
    positive, and if it is set to 1, the number is negative.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位机器上，无符号整型的范围是0到4294967295，有符号整型的范围是-2147483648到2147483647。无符号整型值`0xffffffff`（4294967295）在二进制中表示为`1111
    1111 1111 1111 1111 1111 1111 1111`（见[图A-3](apas03.html#the_role_of_the_most_significant_bit_ope
    "图A-3. 最重要位（MSB）的作用")）。如果您将相同的位模式解释为有符号整型，则会在符号位发生变化，导致有符号整型值为-1。数字的符号由*符号位*表示，通常由*最高有效位（MSB）*表示。如果MSB为0，则数字为正数，如果设置为1，则数字为负数。
- en: '![The role of the Most Significant Bit (MSB)](httpatomoreillycomsourcenostarchimages939341.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![最重要位（MSB）的作用](httpatomoreillycomsourcenostarchimages939341.png.jpg)'
- en: Figure A-3. The role of the Most Significant Bit (MSB)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图A-3. 最重要位（MSB）的作用
- en: 'To summarize: If an unsigned int is converted to a signed int value, the bit
    pattern isn’t changed, but the value is interpreted in the context of the new
    type. If the unsigned int value is in the range `0x80000000` to `0xffffffff`,
    the resulting signed int will become negative (see [Figure A-4](apas03.html#integer_type_conversion_colon_unsigned_i
    "Figure A-4. Integer type conversion: unsigned int to signed int")).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：如果将无符号整型转换为有符号整型值，位模式不会改变，但值将在新类型的上下文中被解释。如果无符号整型值在`0x80000000`到`0xffffffff`的范围内，则结果的有符号整型将变为负数（见[图A-4](apas03.html#integer_type_conversion_colon_unsigned_i
    "图A-4. 整数类型转换：无符号整型到有符号整型")）。
- en: 'This was only a brief introduction to implicit and explicit type conversions
    in C/C++. For a complete description of type conversions in C/C++ and associated
    security problems, see Mark Dowd, John McDonald, and Justin Schuh’s *The Art of
    Software Security Assessment: Identifying and Avoiding Software Vulnerabilities*
    (Addison-Wesley, 2007).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对C/C++中隐式和显式类型转换的简要介绍。对于C/C++中类型转换的完整描述及其相关安全问题，请参阅Mark Dowd、John McDonald和Justin
    Schuh的《软件安全评估的艺术：识别和避免软件漏洞》（Addison-Wesley，2007年）。
- en: '![Integer type conversion: unsigned int to signed int](httpatomoreillycomsourcenostarchimages939343.png.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![整数类型转换：无符号整型到有符号整型](httpatomoreillycomsourcenostarchimages939343.png.jpg)'
- en: 'Figure A-4. Integer type conversion: unsigned int to signed int'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图A-4. 整数类型转换：无符号整型到有符号整型
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I used Debian Linux 6.0 (32-bit) as a platform for all the following steps*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*我使用Debian Linux 6.0（32位）作为以下所有步骤的平台*。'
- en: A.4 GOT Overwrites
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A.4 GOT覆盖
- en: Once you have found a memory corruption vulnerability, you can use a variety
    of techniques to gain control over the instruction pointer register of the vulnerable
    process. One of these techniques, called *GOT overwrite*, works by manipulating
    an entry in the so-called *Global Offset Table (GOT)* of an *Executable and Linkable
    Format (ELF)*^([[90](apas04.html#ftn.APP-A-FN-1)]) object to gain control over
    the instruction pointer. Since this technique relies on the ELF file format, it
    works only on platforms supporting this format (such as Linux, Solaris, or BSD).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到内存损坏漏洞，可以使用各种技术来控制易受攻击进程的指令指针寄存器。其中一种技术称为*GOT覆盖*，通过操纵所谓的*全局偏移表（GOT）*中的一个条目来控制指令指针。由于这种技术依赖于ELF文件格式，它仅在支持此格式的平台上工作（如Linux、Solaris或BSD）。
- en: The GOT is located in an ELF-internal data section called `.got`. Its purpose
    is to redirect position-independent address calculations to an absolute location,
    so it stores the absolute location of function-call symbols used in dynamically
    linked code. When a program calls a library function for the first time, the *runtime
    link editor* (`rtld`) locates the appropriate symbol and relocates it to the GOT.
    Every new call to that function passes the control directly to that location,
    so `rtld` isn’t called for that function anymore. [Example A-4](apas04.html#example_code_used_to_demonstrate_the
    "Example A-4. Example code used to demonstrate the function of the Global Offset
    Table (got.c)") illustrates this process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GOT位于名为`.got`的ELF内部数据段中。它的目的是将位置无关的地址计算重定向到绝对位置，因此它存储了动态链接代码中使用的函数调用符号的绝对位置。当程序第一次调用库函数时，*运行时链接编辑器*（`rtld`）定位适当的符号并将其重定位到GOT。每次对该函数的新调用都直接将控制权传递到该位置，因此不再调用`rtld`来处理该函数。[示例A-4](apas04.html#example_code_used_to_demonstrate_the
    "示例A-4. 用于演示全局偏移表（GOT）功能的示例代码（got.c）")说明了这个过程。
- en: Example A-4. Example code used to demonstrate the function of the Global Offset
    Table (*got.c*)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-4. 用于演示全局偏移表（GOT）功能的示例代码（got.c*）
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The program in [Example A-4](apas04.html#example_code_used_to_demonstrate_the
    "Example A-4. Example code used to demonstrate the function of the Global Offset
    Table (got.c)") calls the `printf()` library function two times. I compiled the
    program with debugging symbols and started it in the debugger (see Section B.4
    for a description of the following debugger commands):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例A-4](apas04.html#example_code_used_to_demonstrate_the "示例A-4. 用于演示全局偏移表（GOT）功能的示例代码（got.c）")中的程序调用了`printf()`库函数两次。我用调试符号编译了程序，并在调试器中启动了它（有关以下调试器命令的描述，请参阅第B.4节）：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The disassembly of the `main()` function shows the address of `printf()` in
    the *Procedure Linkage Table (PLT)*. Much as the GOT redirects position-independent
    address calculations to absolute locations, the PLT redirects position-independent
    function calls to absolute locations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的反汇编显示了*程序链接表（PLT）*中`printf()`的地址。与GOT将位置无关的地址计算重定向到绝对位置类似，PLT将位置无关的函数调用重定向到绝对位置。'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The PLT entry jumps immediately into the GOT:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PLT条目立即跳转回GOT：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the library function wasn’t called before, the GOT entry points back into
    the PLT. In the PLT, a relocation offset gets pushed onto the stack, and execution
    is redirected to the `_init()` function. This is where `rtld` gets called to locate
    the referenced `printf()` symbol.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在之前没有调用库函数，GOT条目会回退到PLT。在PLT中，重定位偏移量被推送到堆栈，并且执行被重定向到`_init()`函数。这是`rtld`被调用以定位引用的`printf()`符号的地方。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let’s see what happens if `printf()` gets called a second time. First,
    I defined a breakpoint just before the second call to `printf()`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果`printf()`被第二次调用会发生什么。首先，我在第二次调用`printf()`之前设置了一个断点：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I then started the program:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我开始运行程序：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the breakpoint triggered, I disassembled the `main` function again to
    see if the same PLT address was called:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点触发后，我再次反汇编了`main`函数，以查看是否调用了相同的PLT地址：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The same address in the PLT was indeed called:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PLT中的相同地址确实被调用了：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The called PLT entry jumps immediately into the GOT again:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的PLT条目立即跳转回GOT：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But this time, the GOT entry of `printf()` has changed: It now points directly
    to the `printf()` library function in `libc`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次，`printf()`的GOT条目已更改：它现在直接指向`libc`中的`printf()`库函数。
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now if we change the value of the GOT entry for `printf()`, it’s possible to
    control the execution flow of the program when `printf()` is called:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们改变 `printf()` 的 GOT 条目值，那么在调用 `printf()` 时就可以控制程序的执行流程：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have achieved `EIP` control. For a real-life example of this exploitation
    technique, see [Chapter 4](ch04.html "Chapter 4. NULL Pointer FTW").
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了 `EIP` 控制。关于这种利用技术的实际例子，请参阅 [第 4 章](ch04.html "第 4 章。空指针 FTW")。
- en: 'To determine the GOT address of a library function, you can either use the
    debugger, as in the previous example, or you can use the `objdump` or `readelf`
    command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定库函数的 GOT 地址，你可以使用调试器，如前例所示，或者使用 `objdump` 或 `readelf` 命令：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notes
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意事项
- en: ^([[90](#ftn.APP-A-FN-1)])
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[90](#ftn.APP-A-FN-1)])
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[90](#APP-A-FN-1)]) For a description of ELF, see TIS Committee, *Tool Interface
    Standard (TIS) Executable and Linking Format (ELF) Specification*, Version 1.2,
    1995, at [http://refspecs.freestandards.org/elf/elf.pdf](http://refspecs.freestandards.org/elf/elf.pdf).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[90](#APP-A-FN-1)]) 关于 ELF 的描述，请参阅 TIS 委员会编写的 *《工具接口标准 (TIS) 可执行和链接格式 (ELF)
    规范》*，版本 1.2，1995 年，见 [http://refspecs.freestandards.org/elf/elf.pdf](http://refspecs.freestandards.org/elf/elf.pdf)。
