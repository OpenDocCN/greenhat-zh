<html><head></head><body><div class="chapter" title="Chapter&#xA0;20.&#xA0;Dynamic Programming"><div class="titlepage"><div><div><h1 class="title"><a id="dynamic_programming"/>Chapter 20. Dynamic Programming</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id28"/><div class="mediaobject"><a id="I_mediaobject20_d1e23911"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>In the past 19 chapters, I’ve covered a huge range of features of the Ruby language. One thing I haven’t covered in any detail is Ruby’s dynamic programming capability.<a id="IDX-CHP-20-0001" class="indexterm"/></p><p>If you have used only a nondynamic language (say one of the languages from the C or Pascal family), it is likely that dynamism in programming may take a little getting used to. Before going any further, I’ll clarify what I mean by a <span class="emphasis"><em>dynamic</em></span> language. The definition is, in fact, a bit vague, and not all languages that lay claim to being dynamic share all the same features. In a general sense, however, a language that provides some means by which programs may be modified at runtime can be considered to be dynamic. Another quality of a dynamic language is its ability to change the type of a given variable—something you have done countless times in the examples throughout this book.</p><p>A further distinction may also be made between a <span class="emphasis"><em>dynamically typed</em></span> language such as Ruby and a <span class="emphasis"><em>statically typed</em></span> language (one in which the type of a variable is predeclared and fixed) such as C, Java, or Pascal. In this chapter, I will concentrate on the self-modifying capabilities of Ruby.<a id="IDX-CHP-20-0002" class="indexterm"/><a id="IDX-CHP-20-0003" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In formal computer science, the term <span class="emphasis"><em>dynamic programming</em></span> is sometimes used to describe an analytic approach to solving complex problems. That is not the sense in which the term is used in this chapter.</p></div><div class="sect1" title="Self-Modifying Programs"><div class="titlepage"><div><div><h1 class="title"><a id="self-modifying_programs"/>Self-Modifying Programs</h1></div></div></div><p>In most compiled languages and many interpreted languages, writing programs and running programs are two completely distinct operations: The code you write is fixed, and it is beyond any possibility of further alteration by the time the program is run.</p><p>That is not the case with Ruby. A program—by which I mean <span class="emphasis"><em>the Ruby code itself</em></span>—can be modified while the program is running. It is even possible to enter new Ruby code at runtime and execute the new code without restarting the program.</p><p>The ability to treat data as executable code is called <span class="emphasis"><em>metaprogramming</em></span>. You’ve been doing metaprogramming, albeit of a rather simple sort, throughout this book. Every time you embed an expression inside a double-quoted string, you are doing metaprogramming. After all, the embedded expression is not really program code—it is a string—and yet Ruby clearly has to “turn it into” program code in order to be able to evaluate it.<a id="IDX-CHP-20-0004" class="indexterm"/></p><p>Most of the time you will probably embed rather simple bits of code between the <code class="literal">#{</code> and <code class="literal">}</code> delimiters in double-quoted strings. Often you might embed variable names, say, or mathematical expressions:</p><p><span class="emphasis"><em>str_eval.rb</em></span></p><a id="I_programlisting20_d1e23979"/><pre class="programlisting">aStr = 'hello world'
puts( "#{aStr}" )
puts( "#{2*10}" )</pre><p>But you aren’t limited to such simple expressions. You could, if you wanted, embed just about anything into a double-quoted string. You could, in fact, write an entire program in a string. You don’t even need to display the end result using <code class="literal">print</code> or <code class="literal">puts</code>. Just placing a double-quoted string into your program will cause Ruby to evaluate it:</p><a id="I_programlisting20_d1e23989"/><pre class="programlisting">"#{def x(s)
        puts(s.reverse)
    end;
(1..3).each{x(aStr)}}"</pre><p>Even though the previous code fragment is a string, the Ruby interpreter will evaluate its embedded code and display the result, shown here:<a id="IDX-CHP-20-0005" class="indexterm"/><a id="IDX-CHP-20-0006" class="indexterm"/></p><a id="I_programlisting20_d1e24001"/><pre class="programlisting">dlrow olleh
dlrow olleh
dlrow olleh</pre><p>Interesting as this may be, writing a whole program inside a string would probably be a pretty pointless endeavor. However, there are other occasions when this, and similar, features can be used much more productively. For example, you might use metaprogramming to explore artificial intelligence and “machine learning.” In fact, any application that would benefit from having a program’s behavior modified in response to user interaction is a prime candidate for metaprogramming.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Dynamic (metaprogramming) features are ubiquitous in Ruby. Consider, for example, attribute accessors: Passing a symbol (such as <code class="literal">:aValue</code>) to the <code class="literal">attr_accessor</code> method causes two methods (<code class="literal">aValue</code> and <code class="literal">aValue=</code>) to be created.<a id="IDX-CHP-20-0007" class="indexterm"/></p></div></div></div>
<div class="sect1" title="eval"><div class="titlepage"><div><div><h1 class="title"><a id="eval"/>eval</h1></div></div></div><p>The <code class="literal">eval</code> method provides a simple way of evaluating a Ruby expression in a string. At first sight, <code class="literal">eval</code> may appear to do the same job as the <code class="literal">#{ }</code> delimiters in a double-quoted string. These two lines of code produce identical results:</p><p><span class="emphasis"><em>eval.rb</em></span></p><a id="I_programlisting20_d1e24041"/><pre class="programlisting">puts( eval("1 + 2" ) )    #=&gt; 3
puts( "#{1 + 2}" )        #=&gt; 3</pre><p>Sometimes, however, the results may not be what you are expecting. Look at the following, for instance:</p><p><span class="emphasis"><em>eval_string.rb</em></span></p><a id="I_programlisting20_d1e24048"/><pre class="programlisting">exp = gets().chomp()    #&lt;= User enters 2*4
puts( eval( exp ))      #=&gt; 8
puts( "#{exp}" )        #=&gt; 2*4</pre><p>Let’s suppose you enter <code class="literal">2 * 4</code>, and this is assigned to <code class="literal">exp</code>. When you evaluate <code class="literal">exp</code> with <code class="literal">eval</code>, the result is 8, but when you evaluate <code class="literal">exp</code> in a double-quoted string, the result is <code class="literal">"2*4"</code>. This is because anything read in by <code class="literal">gets()</code> is a string and <code class="literal">"#{exp}"</code> evaluates it <span class="emphasis"><em>as a string</em></span> and not as an expression, whereas <code class="literal">eval( exp )</code> evaluates a string <span class="emphasis"><em>as an expression</em></span>. To force evaluation inside a string, you could place <code class="literal">eval</code> in the string (though that, admittedly, might defeat the object of the exercise):</p><a id="I_programlisting20_d1e24090"/><pre class="programlisting">puts( "#{eval(exp)}" )</pre><p>Here is another example. Try it, and follow the instructions when prompted:<a id="IDX-CHP-20-0008" class="indexterm"/></p><p><span class="emphasis"><em>eval2.rb</em></span></p><a id="I_programlisting20_d1e24103"/><pre class="programlisting">print("Enter a string method name (e.g. reverse or upcase):")
                                   # user enters: upcase
methodname = gets().chomp()
exp2 = "'Hello world'."&lt;&lt; methodname
puts( eval( exp2 ) )               #=&gt; HELLO WORLD
puts( "#{exp2}" )                  #=&gt; 'Hello world'.upcase
puts( "#{eval(exp2)}" )            #=&gt; HELLO WORLD</pre><p>The <code class="literal">eval</code> method can evaluate strings spanning many lines, making it possible to execute an entire program embedded in a string:</p><p><span class="emphasis"><em>eval3.rb</em></span></p><a id="I_programlisting20_d1e24113"/><pre class="programlisting">eval( 'def aMethod( x )
    return( x * 2 )
end

num = 100
puts( "This is the result of the calculation:" )
puts( aMethod( num ))' )</pre><p>Look carefully at the previous code. It contains just one executable expression, which is a call to the <code class="literal">eval()</code> method. Everything else, which at first sight <span class="emphasis"><em>looks</em></span> like code, is in fact a single-quoted string that is passed as an argument to <code class="literal">eval()</code>. The <code class="literal">eval()</code> method “unpacks” the contents of the string and turns it into real Ruby code that is then executed. This is displayed:</p><a id="I_programlisting20_d1e24129"/><pre class="programlisting">This is the result of the calculation:
200</pre><p>With all this <code class="literal">eval</code> cleverness, let’s now see how easy it is to write a program that can itself write programs. Here it is:</p><p><span class="emphasis"><em>eval4.rb</em></span></p><a id="I_programlisting20_d1e24139"/><pre class="programlisting">input = ""
until input == "q"
    input = gets().chomp()
    if input != "q" then eval( input ) end
end</pre><p>This may not look like much, and yet this little program lets you both create and execute Ruby code from a prompt. Try it. Run the program, and enter the two methods shown here one line at a time (but <span class="emphasis"><em>don’t hit</em></span><span class="keycap">q</span> <span class="emphasis"><em>to quit yet</em></span>—you’ll be writing some more code in a moment):</p><a id="I_programlisting20_d1e24151"/><pre class="programlisting">def x(aStr); puts(aStr.upcase);end
def y(aStr); puts(aStr.reverse);end</pre><p>Note that you have to enter each whole method on a single line since the program evaluates every line as it is entered. I’ll explain how to get around that limitation later. Thanks to <code class="literal">eval</code>, each method is turned into real, workable Ruby code. You can prove this by entering the following:</p><a id="I_programlisting20_d1e24159"/><pre class="programlisting">x("hello world")
y("hello world")</pre><p>Now, when you press <span class="keycap">enter</span> after each line in the previous code, the expressions are evaluated, and they call the two methods, <code class="literal">x()</code> and y<code class="literal">()</code>, which you wrote a moment ago, resulting in this output:</p><a id="I_programlisting20_d1e24172"/><pre class="programlisting">HELLO WORLD
dlrow olleh</pre><p>That’s not bad for just five lines of code!</p></div>
<div class="sect1" title="Special Types of eval"><div class="titlepage"><div><div><h1 class="title"><a id="special_types_of_eval"/>Special Types of eval</h1></div></div></div><p>There are some variations on the <code class="literal">eval</code> theme in the form of the methods named <code class="literal">instance_eval</code>, <code class="literal">module_eval</code>, and <code class="literal">class_eval</code>. The <code class="literal">instance_eval</code> method can be called from a specific object, and it provides access to the instance variables of that object. It can be called either with a block or with a string:<a id="IDX-CHP-20-0009" class="indexterm"/><a id="IDX-CHP-20-0010" class="indexterm"/><a id="IDX-CHP-20-0011" class="indexterm"/></p><p><span class="emphasis"><em>instance_eval.rb</em></span></p><a id="I_programlisting20_d1e24209"/><pre class="programlisting">class MyClass
 def initialize
   @aVar = "Hello world"
 end
end

ob = MyClass.new
p( ob.instance_eval { @aVar } )         #=&gt; "Hello world"
p( ob.instance_eval( "@aVar" ) )        #=&gt; "Hello world"</pre><p>The <code class="literal">eval</code> method, on the other hand, cannot be called from an object in this way because it is a private method of Object (whereas <code class="literal">instance_eval</code> is public):</p><a id="I_programlisting20_d1e24219"/><pre class="programlisting">p( ob.eval( "@aVar" )  )    # This won't work!</pre><p>In fact, you could explicitly change the visibility of <code class="literal">eval</code> by sending its name (the symbol <code class="literal">:eval</code>) to the <code class="literal">public</code> method. Here I am adding <code class="literal">eval</code> as a public method of the Object class:</p><a id="I_programlisting20_d1e24235"/><pre class="programlisting">class Object
    public :eval
end</pre><p>Indeed, bearing in mind that when you write “free-standing” code you are actually working within the scope of Object, simply entering the following code (without the Object class “wrapper”) would have the same effect:<a id="IDX-CHP-20-0012" class="indexterm"/><a id="IDX-CHP-20-0013" class="indexterm"/></p><a id="I_programlisting20_d1e24245"/><pre class="programlisting">public :eval</pre><p>Now you can use <code class="literal">eval</code> as a method of the <code class="literal">ob</code> variable:</p><a id="I_programlisting20_d1e24256"/><pre class="programlisting">p( ob.eval( "@aVar" ) )        #=&gt; "Hello world"</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Strictly speaking, <code class="literal">eval</code> is a method of the <code class="literal">Kernel</code> module that is mixed into the Object class. In fact, it is the <code class="literal">Kernel</code> module that provides most of the functions available as methods of Object.<a id="IDX-CHP-20-0014" class="indexterm"/></p></div><p>The modification of class definitions at runtime is sometimes called <span class="emphasis"><em>monkey patching</em></span>. This may have a part to play in certain highly specialized types of programming, but as a general principle, gratuitous messing about with standard Ruby classes is definitely <span class="emphasis"><em>not</em></span> recommended. Changing the visibility of methods and adding new behavior to base classes are excellent ways of creating inscrutable code dependencies (in which, for example, your own programs work because you happen to know how you’ve changed a base class, but your colleagues’ programs don’t work because they don’t know how the classes have been changed).<a id="IDX-CHP-20-0015" class="indexterm"/></p><p>The <code class="literal">module_eval</code> and <code class="literal">class_eval</code> methods operate on modules and classes rather than on objects. For example, the code shown next adds the <code class="literal">xyz</code> method to the <code class="literal">X</code> module (here <code class="literal">xyz</code> is defined in a block and added as an instance method of the receiver by <code class="literal">define_method</code>, which is a method of the Module class), and it adds the <code class="literal">abc</code> method to the Y class:<a id="IDX-CHP-20-0016" class="indexterm"/></p><p><span class="emphasis"><em>module_eval.rb</em></span></p><a id="I_programlisting20_d1e24316"/><pre class="programlisting">module X
end

class Y
    @@x = 10
    include X
end

X::module_eval{ define_method(:xyz){ puts("hello" ) } }
Y::class_eval{ define_method(:abc){ puts("hello, hello" ) } }</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>When accessing class and module methods, you can use the scope resolution operator <code class="literal">::</code> or a single dot. The scope resolution operator is obligatory when accessing constants and optional when accessing methods.</p></div><p>So, now an object that is an instance of Y will have access to both the <code class="literal">abc</code> method of the Y class and the <code class="literal">xyz</code> method of the <code class="literal">X</code> module that has been mixed into the Y class:</p><a id="I_programlisting20_d1e24335"/><pre class="programlisting">ob = Y.new
ob.xyz        #=&gt; hello
ob.abc        #=&gt; hello, hello</pre><p>In spite of their names, <code class="literal">module_eval</code> and <code class="literal">class_eval</code> are functionally identical, and each can be used with either a module or a class:</p><a id="I_programlisting20_d1e24345"/><pre class="programlisting">X::class_eval{ define_method(:xyz2){ puts("hello again" ) } }
Y::module_eval{ define_method(:abc2){ puts("hello, hello again") }}</pre><p>You can also add methods into Ruby’s standard classes in the same way:</p><a id="I_programlisting20_d1e24350"/><pre class="programlisting">String::class_eval{ define_method(:bye){ puts("goodbye" ) } }
"Hello".bye        #=&gt; goodbye</pre></div>
<div class="sect1" title="Adding Variables and Methods"><div class="titlepage"><div><div><h1 class="title"><a id="adding_variables_and_methods"/>Adding Variables and Methods</h1></div></div></div><p>You can also use the <code class="literal">module_eval</code> and <code class="literal">class_eval</code> methods to retrieve the values of class variables (but bear in mind that the more you do this, the more your code becomes dependent on the implementation details of a class, thereby compromising encapsulation):</p><a id="I_programlisting20_d1e24363"/><pre class="programlisting">Y.class_eval( "@@x" )</pre><p>In fact, <code class="literal">class_eval</code> can evaluate expressions of arbitrary complexity. You could, for example, use it to add new methods to a class by evaluating a string:</p><a id="I_programlisting20_d1e24370"/><pre class="programlisting">ob = X.new
X.class_eval( 'def hi;puts("hello");end' )
ob.hi        #=&gt; hello</pre><p>Returning to the earlier example of adding and retrieving class variables from <span class="emphasis"><em>outside</em></span> a class (using <code class="literal">class_eval</code>), it turns out that there are also methods designed to do this from <span class="emphasis"><em>inside</em></span> a class. The methods are called <code class="literal">class_variable_get</code> (this takes a symbol argument representing the variable name, and it returns the variable’s value) and <code class="literal">class_variable_set</code> (this takes a symbol argument representing a variable name and a second argument that is the value to be assigned to the variable).<a id="IDX-CHP-20-0017" class="indexterm"/><a id="IDX-CHP-20-0018" class="indexterm"/></p><p>Here is an example of these methods in use:<a id="IDX-CHP-20-0019" class="indexterm"/><a id="IDX-CHP-20-0020" class="indexterm"/></p><p><span class="emphasis"><em>classvar_getset.rb</em></span></p><a id="I_programlisting20_d1e24411"/><pre class="programlisting">class X
    def self.addvar( aSymbol, aValue )
        class_variable_set( aSymbol, aValue )
    end

    def self.getvar( aSymbol )
        return class_variable_get( aSymbol )
    end
end

X.addvar( :@@newvar, 2000 )
puts( X.getvar( :@@newvar ) )    #=&gt; 2000</pre><p>To obtain a list of class variable names as an array of strings, use the <code class="literal">class_variables</code> method:<a id="IDX-CHP-20-0021" class="indexterm"/></p><a id="I_programlisting20_d1e24421"/><pre class="programlisting">p( X.class_variables )    #=&gt; ["@@abc", "@@newvar"]</pre><p>You can also add instance variables to classes and objects after they have been created using <code class="literal">instance_variable_set</code>:<a id="IDX-CHP-20-0022" class="indexterm"/></p><p><span class="emphasis"><em>dynamic.rb</em></span></p><a id="I_programlisting20_d1e24435"/><pre class="programlisting">ob = X.new
ob.instance_variable_set("@aname", "Bert")</pre><p>By combining this with the ability to add methods, the bold (or maybe reckless?) programmer can completely alter the internals of a class “from the outside.” Here I have implemented this in the form of a method called <code class="literal">addMethod</code> in class X, which uses the <code class="literal">send</code> method to create the new method <code class="literal">m</code> using <code class="literal">define_method</code> with the method body, defined by <code class="literal">&amp;block</code>:<a id="IDX-CHP-20-0023" class="indexterm"/></p><a id="I_programlisting20_d1e24458"/><pre class="programlisting">def addMethod( m, &amp;block )
    self.class.send( :define_method, m , &amp;block )
end</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">send</code> method invokes the method identified by the first argument (a symbol), passing to it any arguments specified.</p></div><p>Now, an X object can call <code class="literal">addMethod</code> to insert a new method into the X class:</p><a id="I_programlisting20_d1e24471"/><pre class="programlisting">ob.addMethod( :xyz ) { puts("My name is #{@aname}") }</pre><p>Although this method is called from a specific instance of the class (here <code class="literal">ob</code>), it affects the class itself, so the newly defined method will also be available to any subsequent instances (here <code class="literal">ob2</code>) created from the X class:</p><a id="I_programlisting20_d1e24481"/><pre class="programlisting">ob2 = X.new
ob2.instance_variable_set("@aname", "Mary")
ob2.xyz</pre><p>If you don’t care about the encapsulation of data in your objects (my definition of <span class="emphasis"><em>encapsulation</em></span> assumes the hiding of internal data, though some people have less rigorous definitions), you can also retrieve the value of instance variables using the <code class="literal">instance_variable_get</code> method:<a id="IDX-CHP-20-0024" class="indexterm"/><a id="IDX-CHP-20-0025" class="indexterm"/><a id="IDX-CHP-20-0026" class="indexterm"/><a id="IDX-CHP-20-0027" class="indexterm"/></p><a id="I_programlisting20_d1e24510"/><pre class="programlisting">ob2.instance_variable_get( :@aname )</pre><p>You can similarly <span class="emphasis"><em>set</em></span> and <span class="emphasis"><em>get</em></span> constants:</p><a id="I_programlisting20_d1e24520"/><pre class="programlisting">X::const_set( :NUM, 500 )
puts( X::const_get( :NUM ) )</pre><p>Because <code class="literal">const_get</code> returns the value of a constant, you could use this method to get the value of a class name, which is itself a constant, and then append the <code class="literal">new</code> method to create a new object from that class. This could even give you a way of creating objects at runtime by prompting the user to enter class names and method names. Try this by running this program:<a id="IDX-CHP-20-0028" class="indexterm"/><a id="IDX-CHP-20-0029" class="indexterm"/></p><p><span class="emphasis"><em>dynamic2.rb</em></span></p><a id="I_programlisting20_d1e24541"/><pre class="programlisting">class X
    def y
        puts( "ymethod" )
   end
end

print( "Enter a class name: ")                  #&lt;= Enter: X
cname = gets().chomp
ob = Object.const_get(cname).new
p( ob )                                         #=&gt; #&lt;X:0x2bafdc0&gt;
print( "Enter a method to be called: " )        #&lt;= Enter: y
mname = gets().chomp
ob.method(mname).call                           #=&gt; ymethod</pre></div>
<div class="sect1" title="Creating Classes at Runtime"><div class="titlepage"><div><div><h1 class="title"><a id="creating_classes_at_runtime"/>Creating Classes at Runtime</h1></div></div></div><p>So far, you have modified classes and created new objects from existing classes. But how would you go about creating a completely new class at runtime? Well, just as you can use <code class="literal">const_get</code> to access an existing class, you can use <code class="literal">const_set</code> to create a new class. Here’s an example of how to prompt the user for the name of a new class before creating that class, adding a method (<code class="literal">myname</code>) to it, creating an instance (<code class="literal">x</code>) of that class, and calling its <code class="literal">myname</code> method:<a id="IDX-CHP-20-0030" class="indexterm"/></p><p><span class="emphasis"><em>create_class.rb</em></span></p><a id="I_programlisting20_d1e24570"/><pre class="programlisting">puts("What shall we call this class? ")
className = gets.strip().capitalize()
Object.const_set(className,Class.new)
puts("I'll give it a method called 'myname'" )
className = Object.const_get(className)
className::module_eval{ define_method(:myname){
        puts("The name of my class is '#{self.class}'" ) }
    }

x = className.new
x.myname</pre><p>If you run this program and enter <code class="literal">Xxx</code> when prompted for the name of a new class, the code will use <code class="literal">const_set</code> to create the constant <code class="literal">Xxx</code> as a new class; then <code class="literal">module_eval</code> is called on this class, and <code class="literal">define_method</code> is used to create a method whose name matches the symbol <code class="literal">:myname</code> and whose contents are given by the code in the curly brace-delimited block; here this happens to be a single <code class="literal">puts</code> statement that displays the class name.<a id="IDX-CHP-20-0031" class="indexterm"/></p><p>Run this code, and enter <code class="literal">Xxx</code> when prompted. An object, <code class="literal">x</code>, is created from the <code class="literal">Xxx</code> class; its <code class="literal">myname()</code> method is called; and, sure enough, it displays the class name:</p><a id="I_programlisting20_d1e24613"/><pre class="programlisting">The name of my class is 'Xxx'</pre></div>
<div class="sect1" title="Bindings"><div class="titlepage"><div><div><h1 class="title"><a id="bindings"/>Bindings</h1></div></div></div><p>The <code class="literal">eval</code> method may take an optional “binding” argument that, if provided, causes the evaluation to be done within a specific scope or “context.” It probably won’t come as any surprise to discover that, in Ruby, a binding is an object that is an instance of the Binding class. You can return a binding using the <code class="literal">binding</code> method. The documentation of <code class="literal">eval</code> in the Ruby class library provides this example:</p><p><span class="emphasis"><em>binding.rb</em></span></p><a id="I_programlisting20_d1e24633"/><pre class="programlisting">def getBinding(str)
    return binding()
end
str = "hello"
puts( eval( "str + ' Fred'" ) )                    #=&gt; "hello Fred"
puts( eval( "str + ' Fred'", getBinding("bye") ) ) #=&gt; "bye Fred"</pre><p>Simple as it may look, this example may take a bit of thinking about in order to understand what’s going on. Essentially, the first call to <code class="literal">puts</code> evaluates <code class="literal">str</code> in the current scope where it has a “hello” value. The second call to <code class="literal">puts</code> evaluates <code class="literal">str</code> in the scope of the <code class="literal">getBinding()</code> method where it has a “bye” value. In this example, <code class="literal">str</code> happens to be passed as an argument, but this is not a requirement. In the rewritten version here, I’ve made <code class="literal">str</code> a local variable inside <code class="literal">getBinding()</code>. The effect is the same:</p><p><span class="emphasis"><em>binding2.rb</em></span></p><a id="I_programlisting20_d1e24665"/><pre class="programlisting">def getBinding()
    str = "bye"
    return binding()
end
str = "hello"
puts( eval( "str + ' Fred'" )   )                  #=&gt; "hello Fred"
puts( eval( "str + ' Fred'", getBinding() ) )      #=&gt; "bye Fred"
puts( eval( "str + ' Fred'" )   )                  #=&gt; "hello Fred"</pre><p>Note that <code class="literal">binding</code> is a private method of Kernel. The <code class="literal">getBinding</code> method is able to call <code class="literal">binding</code> within the current context and return the current value of <code class="literal">str</code>. At the time of the first call to <code class="literal">eval</code>, the context is the <span class="emphasis"><em>main</em></span> object, and the value of the local variable, <code class="literal">str</code>, is used; in the second call, the context moves inside the <code class="literal">getBinding</code> method, and the local value of <code class="literal">str</code> is now that of the <code class="literal">str</code> argument or variable within that method. The context may also be defined by a class. In <span class="emphasis"><em>binding3.rb</em></span>, you can see that the values of the instance variable <code class="literal">@mystr</code> varies according to the class. So, what happens when you <code class="literal">eval</code> those variables with different bindings?<a id="IDX-CHP-20-0032" class="indexterm"/></p><p><span class="emphasis"><em>binding3.rb</em></span></p><a id="I_programlisting20_d1e24718"/><pre class="programlisting">class MyClass
   @@x = " x"
   def initialize(s)
      @mystr = s
   end
   def getBinding
      return binding()
   end
end

class MyOtherClass
   @@x = " y"
   def initialize(s)
      @mystr = s
   end
   def getBinding
      return binding()
   end
end

@mystr = self.inspect
@@x = " some other value"

ob1 = MyClass.new("ob1 string")
ob2 = MyClass.new("ob2 string")
ob3 = MyOtherClass.new("ob3 string")

puts(eval("@mystr &lt;&lt; @@x", ob1.getBinding))
puts(eval("@mystr &lt;&lt; @@x", ob2.getBinding))
puts(eval("@mystr &lt;&lt; @@x", ob3.getBinding))
puts(eval("@mystr &lt;&lt; @@x", binding))</pre><p>In Ruby 1.8, you see the following output, showing that the bindings for both the instance variable, <code class="literal">@mystr</code>, and the class variable, <code class="literal">@@x</code>, are applied:</p><a id="I_programlisting20_d1e24729"/><pre class="programlisting">ob1 string x
ob2 string x
ob3 string y
main some other value</pre><p>But in Ruby 1.9, only the binding of the instance variable is applied; the class variable in the current (<span class="emphasis"><em>main</em></span>) context is always used:<a id="IDX-CHP-20-0033" class="indexterm"/></p><a id="I_programlisting20_d1e24741"/><pre class="programlisting">ob1 string some other value
ob2 string some other value
ob3 string some other value
main some other value</pre><p>Does this mean class variables in given bindings are ignored? Let’s try an experiment. Just comment out the assignment to <code class="literal">@@x</code> in the main context:</p><a id="I_programlisting20_d1e24748"/><pre class="programlisting"># @@x = " some other value"</pre><p>Now run the program again. This time, Ruby 1.9 displays this:</p><a id="I_programlisting20_d1e24752"/><pre class="programlisting">ob1 string x
ob2 string x
ob3 string y
...uninitialized class variable @@x in Object (NameError)</pre><p>Clearly, Ruby 1.9 <span class="emphasis"><em>does</em></span> evaluate class variables within a binding. However, it gives preference to class variables, if they exist, in the <span class="emphasis"><em>current</em></span> binding. You need to be aware of this difference if you are migrating Ruby 1.8 programs to Ruby 1.9 or newer.</p></div>
<div class="sect1" title="send"><div class="titlepage"><div><div><h1 class="title"><a id="send"/>send</h1></div></div></div><p>You can use the <code class="literal">send</code> method to call a method with the same name as the specified symbol:<a id="IDX-CHP-20-0034" class="indexterm"/></p><p><span class="emphasis"><em>send1.rb</em></span></p><a id="I_programlisting20_d1e24776"/><pre class="programlisting">name = "Fred"
puts( name.send( :reverse ) )    #=&gt; derF
puts( name.send( :upcase ) )     #=&gt; FRED</pre><p>Although the <code class="literal">send</code> method is documented as requiring a symbol argument, you can also use a string argument. Or, for consistency, you could use <code class="literal">to_sym</code> to transform the string to a symbol and then call the method with the same name as that symbol:</p><a id="I_programlisting20_d1e24786"/><pre class="programlisting">name = MyString.new( gets() )
methodname = gets().chomp.to_sym #&lt;= to_sym is not strictly necessary
name.send(methodname)</pre><p>Here is a working example of using <code class="literal">send</code> to execute a named method entered at runtime:<a id="IDX-CHP-20-0035" class="indexterm"/><a id="IDX-CHP-20-0036" class="indexterm"/><a id="IDX-CHP-20-0037" class="indexterm"/><a id="IDX-CHP-20-0038" class="indexterm"/><a id="IDX-CHP-20-0039" class="indexterm"/></p><p><span class="emphasis"><em>send2.rb</em></span></p><a id="I_programlisting20_d1e24821"/><pre class="programlisting">class MyString &lt; String
    def initialize( aStr )
        super aStr
    end

    def show
        puts self
    end

    def rev
        puts self.reverse
    end
end

print("Enter your name: ")          #&lt;= Enter: Fred
name = MyString.new( gets() )
print("Enter a method name: " )     #&lt;= Enter: rev
methodname = gets().chomp.to_sym
puts( name.send(methodname) )       #=&gt; derF</pre></div>
<div class="sect1" title="Removing Methods"><div class="titlepage"><div><div><h1 class="title"><a id="removing_methods"/>Removing Methods</h1></div></div></div><p>Recall you created a new method earlier (<span class="emphasis"><em>dynamic.rb</em></span>) using <code class="literal">send</code> to call <code class="literal">define_method</code> and passed to it the name, <code class="literal">m</code>, of the method to be created plus a block, <code class="literal">&amp;block</code>, containing the code of the new method:<a id="IDX-CHP-20-0040" class="indexterm"/></p><p><span class="emphasis"><em>dynamic.rb</em></span></p><a id="I_programlisting20_d1e24850"/><pre class="programlisting">def addMethod( m, &amp;block )
    self.class.send( :define_method, m , &amp;block )
end</pre><p>In addition to creating new methods, sometimes you may want to remove existing methods. You can do this using <code class="literal">remove_method</code> within the scope of a given class. This removes the method specified by a symbol from a specific class:<a id="IDX-CHP-20-0041" class="indexterm"/></p><p><span class="emphasis"><em>rem_methods1.rb</em></span></p><a id="I_programlisting20_d1e24863"/><pre class="programlisting">puts( "hello".reverse )  #=&gt; olleh
class String
    remove_method( :reverse )
end
puts( "hello".reverse )  #=&gt; undefined method error!</pre><p>If a method with the same name is defined for an ancestor of that class, the ancestor class method is <span class="emphasis"><em>not</em></span> removed:<a id="IDX-CHP-20-0042" class="indexterm"/></p><p><span class="emphasis"><em>rem_methods2.rb</em></span></p><a id="I_programlisting20_d1e24878"/><pre class="programlisting">class Y
    def somemethod
        puts("Y's somemethod")
    end
end

class Z &lt; Y
    def somemethod
        puts("Z's somemethod")
    end
end

zob = Z.new
zob.somemethod                     #=&gt; Z's somemethod
class Z
     remove_method( :somemethod )  # Remove somemethod from Z class
end

zob.somemethod                     #=&gt; Y's somemethod</pre><p>In this example, <code class="literal">somemethod</code> is removed from the Z class, so when <code class="literal">zob.somemethod</code> is subsequently called on a Z object, Ruby executes the first method with that name in the <span class="emphasis"><em>ancestor</em></span> classes of Z. Here, Y is the ancestor of Z, so its <code class="literal">somemethod</code> method is used.</p><p>The <code class="literal">undef_method</code>, by contrast, prevents the specified class from responding to a method call even if a method with the same name is defined in one of its ancestors. The following example uses the same Y and Z classes used in the previous example. The only difference is that this time <code class="literal">somemethod</code> is <span class="emphasis"><em>undefined</em></span> using <code class="literal">undef_method</code> rather than merely <span class="emphasis"><em>removed</em></span> from the current class using <code class="literal">remove_method</code>:<a id="IDX-CHP-20-0043" class="indexterm"/></p><p><span class="emphasis"><em>undef_methods.rb</em></span></p><a id="I_programlisting20_d1e24922"/><pre class="programlisting">zob = Z.new
zob.somemethod                       #=&gt; Z's somemethod

class Z
   undef_method( :somemethod )       #=&gt; undefine somemethod
end

zob.somemethod                       #=&gt; undefined method error</pre></div>
<div class="sect1" title="Handling Missing Methods"><div class="titlepage"><div><div><h1 class="title"><a id="handling_missing_methods"/>Handling Missing Methods</h1></div></div></div><p>When Ruby tries to execute an undefined method (or, in object-oriented terms, when an object is sent a message that it cannot handle), the error causes the program to exit. You may prefer your program to recover from such an error. You can do this by writing a method named <code class="literal">method_missing</code>, with an argument to which the missing method’s name is assigned. This will execute when a nonexistent method is called:<a id="IDX-CHP-20-0044" class="indexterm"/></p><p><span class="emphasis"><em>nomethod1.rb</em></span></p><a id="I_programlisting20_d1e24938"/><pre class="programlisting">def method_missing( methodname )
   puts( "Sorry, #{methodname} does not exist" )
end
xxx        #=&gt; Sorry, xxx does not exist</pre><p>The <code class="literal">method_missing</code> method can also take a list of incoming arguments (<code class="literal">*args</code>) after the missing method name:</p><p><span class="emphasis"><em>nomethod2.rb</em></span></p><a id="I_programlisting20_d1e24951"/><pre class="programlisting">def method_missing( methodname, *args )
      puts( "Class #{self.class} does not understand:
                   #{methodname}( #{args.inspect} )" )
end</pre><p>Assuming the previous <code class="literal">method_missing</code> method were written into a class called X, you could now attempt to call any method on an X object, whether or not that method exists and whether or not it is passed any arguments. If, for example, you were to attempt to call a nonexistent method called <code class="literal">aaa</code>, first with no arguments and then with three integer arguments, the <code class="literal">method_missing</code> method would respond to the invalid method call and display an appropriate error message:</p><a id="I_programlisting20_d1e24964"/><pre class="programlisting">ob = X.new
ob.aaa            #=&gt; Class X does not understand: aaa( [] )
ob.aaa( 1,2,3 )   #=&gt; Class X does not understand: aaa( [1, 2, 3] )</pre><p>The <code class="literal">method_missing</code> method could even create an undefined method dynamically so that a call to a nonexistent method automatically brings that method into existence:</p><a id="I_programlisting20_d1e24971"/><pre class="programlisting">def method_missing( methodname, *args )
       self.class.send( :define_method, methodname,
            lambda{ |*args| puts( args.inspect) } )
end</pre><p>Remember that the <code class="literal">lambda</code> method turns a block (here the code between curly brackets) into a Proc object. This is explained in <a class="xref" href="ch10.html" title="Chapter 10. Blocks, Procs, and Lambdas">Chapter 10</a>. The code is then able to pass this object as an argument to <code class="literal">send</code>, defining a new method with the same name as the <code class="literal">methodname</code> argument passed to <code class="literal">method_missing</code>. The effect is that when an unknown method is called on a Z object, a method with that name is created. Run the <span class="emphasis"><em>nomethod2.rb</em></span> program, which contains this code:</p><a id="I_programlisting20_d1e24994"/><pre class="programlisting">ob3 = Z.new
ob3.ddd( 1,2,3)
ob3.ddd( 4,5,6 )</pre><p>This gives the following output:<a id="IDX-CHP-20-0045" class="indexterm"/></p><a id="I_programlisting20_d1e25003"/><pre class="programlisting">Class Z does not understand: ddd( [1, 2, 3] )
Now creating method ddd( )
[4, 5, 6]</pre></div>
<div class="sect1" title="Writing Programs at Runtime"><div class="titlepage"><div><div><h1 class="title"><a id="writing_programs_at_runtime"/>Writing Programs at Runtime</h1></div></div></div><p>Finally, let’s return to the program you looked at earlier: <span class="emphasis"><em>eval4.rb</em></span>. This, you may recall, prompts the user to enter strings to define code at runtime, evaluates those strings, and creates new runnable methods from them.</p><p>One drawback of that program was that it insists that each method be entered on a single line. It is, in fact, pretty simple to write a program that allows the user to enter methods spanning many lines. Here, for example, is a program that evaluates all the code entered up until a blank line is entered:</p><p><span class="emphasis"><em>writeprog.rb</em></span></p><a id="I_programlisting20_d1e25018"/><pre class="programlisting">program = ""
input = ""
line = ""
until line.strip() == "q"
    print( "?- " )
    line = gets()
    case( line.strip() )
    when ''
        puts( "Evaluating..." )
        eval( input )
        program += input
        input = ""
    when '1'
        puts( "Program Listing..." )
        puts( program )
   else
        input += line
    end
end</pre><p>You can try this by entering whole methods followed by blank lines, like this (just enter the code, of course, not the comments):</p><a id="I_programlisting20_d1e25022"/><pre class="programlisting">def a(s)             # &lt;= press Enter after each line
return s.reverse     # &lt;= press enter (and so on...)
end
                     # &lt;- Enter a blank line here to eval these two methods
def b(s)
return a(s).upcase
end
                     # &lt;- Enter a blank line here to eval these two methods
puts( a("hello" ) )

                     # &lt;- Enter a blank line to eval
                     #=&gt; olleh
puts( b("goodbye" ) )
                     # &lt;- Enter a blank line to eval
                     #=&gt; EYBDOOG</pre><p>After each line entered, a prompt (<code class="literal">?-</code>) appears except when the program is in the process of evaluating code, in which case it displays “Evaluating,” or when it shows the result of an evaluation, such as <code class="literal">olleh</code>.</p><p>If you enter the text exactly as indicated earlier, this is what you should see:</p><a id="I_programlisting20_d1e25034"/><pre class="programlisting">Write a program interactively.
Enter a blank line to evaluate.
Enter 'q' to quit.
?- def a(s)
?- return s.reverse
?- end
?-
Evaluating...
?- def b(s)
?- return a(s).upcase
?- end
?-
Evaluating...
?- puts(a("hello"))
?-
Evaluating...
olleh
?- b("goodbye")
?-
Evaluating...
EYBDOOG</pre><p>This program is still very simple. It doesn’t even have any basic error recovery let alone fancy stuff such as file saving and loading. Even so, this small example demonstrates just how easy it is to write self-modifying programs in Ruby.</p></div>
<div class="sect1" title="Exploring Further"><div class="titlepage"><div><div><h1 class="title"><a id="exploring_further"/>Exploring Further</h1></div></div></div><p>Using the techniques outlined in this chapter, you could create anything from a natural-language parser that can be taught rules of grammar to an adventure game that can learn new puzzles.</p><p>In this book I’ve covered a lot of ground—from “hello world” to dynamic programming. You’ve explored most of the important and powerful features of the Ruby language. The rest is up to you.</p><p>This is where the adventure really begins.</p><div class="sidebar"><a id="digging_deeper-id19"/><p class="title">Digging Deeper</p><p>There may be times when you want to make sure that your Ruby objects cannot be modified in the ways described in this chapter. Here you will learn how to do this.<a id="IDX-CHP-20-0046" class="indexterm"/><a id="IDX-CHP-20-0047" class="indexterm"/><a id="IDX-CHP-20-0048" class="indexterm"/></p><p><span class="bolditalic">Freezing Objects</span></p><p>With all these ways of modifying objects at your disposal, you may be concerned that objects are at risk of being modified unintentionally. In fact, you can specifically fix the state of an object by “freezing” it using the <code class="literal">freeze</code> method, which you first encountered in <a class="xref" href="ch12.html" title="Chapter 12. Modules and Mixins">Chapter 12</a>. Once frozen, the data contained by an object cannot be modified, and if an attempt is made to do so, a TypeError exception will be raised. Take care when freezing an object, however, because, once frozen, it cannot be “unfrozen.”<a id="IDX-CHP-20-0049" class="indexterm"/><a id="IDX-CHP-20-0050" class="indexterm"/></p><p><span class="emphasis"><em>freeze.rb</em></span></p><a id="I_programlisting20_d1e25088"/><pre class="programlisting">s = "Hello"
s &lt;&lt; " world"
s.freeze
s &lt;&lt; " !!!"   # Error: "can't modify frozen string"</pre><p>You can specifically check whether an object is frozen using the <code class="literal">frozen?</code> method:<a id="IDX-CHP-20-0051" class="indexterm"/></p><a id="I_programlisting20_d1e25098"/><pre class="programlisting">a = [1,2,3]
a.freeze
if !(a.frozen?) then
    a &lt;&lt; [4,5,6]
end</pre><p>Be aware that although the data of a frozen object cannot be modified, the class from which it is defined can be modified. Let’s suppose you have a class X that contains the method <code class="literal">addMethod</code>, which can create new methods with the name given by the symbol <code class="literal">m</code>:</p><p><span class="emphasis"><em>cant_freeze.rb</em></span></p><a id="I_programlisting20_d1e25111"/><pre class="programlisting">def addMethod( m, &amp;block )
    self.class.send( :define_method, m , &amp;block )
end</pre><p>Now, if you have an object, <code class="literal">ob</code>, created from the M class, then it is perfectly legitimate to call <code class="literal">addMethod</code> to add a new method to class M:</p><a id="I_programlisting20_d1e25122"/><pre class="programlisting">ob.freeze
ob.addMethod( :abc ) { puts("This is the abc method") }</pre><p>If you want to prevent a frozen object from modifying its class, you could, of course, test its state using the <code class="literal">frozen?</code> method:</p><a id="I_programlisting20_d1e25129"/><pre class="programlisting">if not( ob.frozen? ) then
  ob.addMethod(:def){puts("'def' is not a good name for a method")}
end</pre><p>You can also freeze the class itself (remember, a class is also an object):</p><p><span class="emphasis"><em>freeze_class.rb</em></span></p><a id="I_programlisting20_d1e25136"/><pre class="programlisting">X.freeze
if not( X.frozen? ) then
  ob.addMethod(:def){puts("'def' is not a good name for a method")}
end</pre></div></div></body></html>