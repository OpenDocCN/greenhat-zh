<html><head></head><body><div class="part" title="Part&#xA0;III-7.&#xA0;TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_electronic_mail_system_concepts_an"/>Part III-7. TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND PROTOCOLS</h1></div></div></div><div class="partintro" id="id3352350" title="TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND PROTOCOLS"><div/><p><a class="xref" href="ch74.html" title="Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS">Chapter 74</a></p><p><a class="xref" href="ch75.html" title="Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING">Chapter 75</a></p><p><a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a></p><p><a class="xref" href="ch77.html" title="Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)">Chapter 77</a></p><p><a class="xref" href="ch78.html" title="Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS">Chapter 78</a></p><p>It is common for human beings to create systems that are reminiscent of ones with which they are already familiar. We are all accustomed to using the regular mail system to send letters and other documents from our location to recipients anywhere that the postal system serves. Naturally, one of the first applications of internetworks was to create an electronic version of this conventional mail system that would allow messages to be sent in a similar manner, but more quickly and easily. Over the course of many years, an <span class="emphasis"><em>electronic mail system</em></span> for TCP/IP was created and refined. It is now the most widely used means of electronic messaging in the world.</p><p>In this part, I describe TCP/IP electronic mail (email) in detail, in five chapters that discuss electronic mail concepts and the various components and protocols that comprise the overall TCP/IP email system. The first chapter provides an overview of TCP/IP email and discusses the way that it is used and the different protocols and methods that make up the system. The second chapter discusses how email messages are addressed, and the third chapter covers standard and special formats for email messages. The fourth and fifth chapters describe the TCP/IP protocols that implement email functionality. These include the Simple Mail Transfer Protocol (SMTP), which is responsible for the delivery of email, and several protocols and methods used for mailbox access and mail retrieval, including the Post Office Protocol version 3 (POP3) and the Internet Message Access Protocol (IMAP).</p><p>This discussion focuses primarily on the mechanisms used for email composition, delivery, and access in modern internetworks. In the email overview in <a class="xref" href="ch74.html" title="Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS">Chapter 74</a>, I mention some techniques used in the past for TCP/IP email, but only briefly for historical completeness and to contrast these methods to the ones presently used.</p></div></div>
<div class="chapter" title="Chapter&#xA0;74.&#xA0;TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_electronic_mail_system_overview_an"/>Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e80224"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Electronic mail (email) in the TCP/IP protocol suite is not implemented as just a single protocol or technology. Rather, it is a complete system that contains a number of related components that work together. These include standards defining methods for addressing and message formatting and a number of protocols that play different functions in implementing email messaging. Before proceeding to examine each of these pieces, it makes sense to start with an overview of the system as a whole.</p><p>In this chapter, I provide an introductory look at TCP/IP email to help you understand the system, how it works, and how different components fit into it. I begin with an overview and history of email and its implementation in TCP/IP. I provide a general overview of the steps involved in the email communication process, concluding with a more specific discussion of the communication model used in TCP/IP and the roles played by various TCP/IP devices and protocols in the sending and receiving of email.</p><div class="sect1" title="TCP/IP Electronic Mail System Overview and History"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_electronic_mail_system_overv-id001"/>TCP/IP Electronic Mail System Overview and History</h1></div></div></div><p>The need to communicate is as old as humanity itself. Thousands of years ago, communication was of necessity almost exclusively local. Messages were primarily oral, and even when in writing, they were rarely delivered a great distance. Most people never traveled far from their homes and rarely communicated with those distant from themselves. But even in ancient times, leaders used messengers to send short pieces of critical information from place to place. It was slow and unreliable, but some messages were important enough that an effort to communicate often had to be made despite the difficulties.</p><p>Advances in transportation led to advances in communication capability, eventually resulting in the creation of physical mail systems. Today, these systems have evolved to the point at which anyone in the developed world can send a letter or package to just about anyone else. Reliability has vastly improved, despite all the jokes people make about the postal service. Speed is also much better than it used to be, with messages now taking days to reach their destination instead of weeks or months.</p><p>Waiting even days for a message to get from one place to another is pretty slow by the standards of our modern world. For this reason, one of the most natural applications of networks was to use them as a replacement for the physical transportation of messages from one place to another. Transforming mail from a physical process to an electronic one yields enormous benefits, including greatly increased communication speed, the ability to send one message to multiple recipients instantly, and the ability to get nearly instantaneous feedback upon receipt of a message.</p><div class="sect2" title="The Early Days of Email"><div class="titlepage"><div><div><h2 class="title"><a id="the_early_days_of_email"/>The Early Days of Email</h2></div></div></div><p><a class="indexterm" id="idx-CHP-74-2630"/>The idea behind email is not only as old as computer networks, but it actually predates internetworking. The first email systems were implemented on traditional mainframe computers. These were single large computers accessed by many users simultaneously through connected terminals. An email system on a mainframe consisted of a set of software running on the mainframe that implemented the entire email system. Each user simply had a mailbox that resided on this machine, and mail was delivered by moving messages from one mailbox to the next. Users sent and received mail through a user-interface program.</p><p>Such an early email system was useful for local communication but not for sending messages to a person in another organization. Mainframe email is somewhat analogous to local mail being sent by one resident of a town to another. There is no way to send mail to a person in a distant town without the infrastructure in place for delivery.</p><p>The power of internetworking is what really enables email to become a universal method of communication. Internetworks link together systems the way the postal service's fleet of airplanes and vehicles link together post offices. Mail is sent from user to user over the underlying technology of the internetwork. Since TCP/IP is the most commonly used internetworking protocol suite, and the modern Internet uses TCP/IP to tie together systems across the globe, it is the vehicle used for sending email.</p></div><div class="sect2" title="History of TCP/IP Email"><div class="titlepage"><div><div><h2 class="title"><a id="history_of_tcpip_email"/>History of TCP/IP Email</h2></div></div></div><p>As with some other file and message transfer protocols, email on TCP/IP actually goes back to before TCP/IP and the Internet formally existed. The first protocols for email were developed during the days of the ARPAnet. Prior to the creation of email, several Internet RFCs, such as RFC 95 (yes 95, two digits—we are going back a long way here) and RFC 155, describe physical mailing lists that were used for distributing documents in the early 1970s. It was this need to send documents that likely made TCP/IP pioneers realize the usefulness of an electronic messaging <a class="indexterm" id="idx-CHP-74-2631"/>system, using the technology they were themselves creating.</p><p>The first Internet document describing email was probably RFC 196, published in 1971. It describes the <a class="indexterm" id="idx-CHP-74-2632"/><span class="emphasis"><em>Mail Box Protocol</em></span>, a very rudimentary message transfer method using the predecessors of TCP/IP. This protocol was designed for the specific purpose of sending documents for remote printing. In those days, it was not as common for people to use computers at interactive terminals as it is today, but the idea of electronically mailing documents was the same. The Mail Box Protocol was revised several times in 1971.</p><p>In the mid-1970s, developers began working on a more comprehensive method of implementing email on the fledgling Internet. The technique was originally described using a number of existing application layer transfer protocols, including the File Transfer Protocol (FTP). In 1980 the "Mail Transfer Protocol (MTP)" was published in RFC 772. This was the first precursor of today's TCP/IP <a class="indexterm" id="idx-CHP-74-2633"/>email and was defined using principles from the Telnet Protocol as well as FTP.</p><p>During the time that email protocols were being developed in the 1970s, mail was being exchanged between host systems using a variety of techniques. One of the most common used was the <a class="indexterm" id="idx-CHP-74-2634"/><span class="emphasis"><em>Unix-to-Unix Copy Protocol (UUCP)</em></span>, which was designed to allow files to be transferred between UNIX systems, moving them from one connected system to the next. UUCP was also used for communicating Usenet newsgroup articles and other files.</p><p>In 1981, the modern TCP/IP email era came into being with the definition of the <span class="emphasis"><em>Simple Mail Transfer Protocol (SMTP)</em></span>. SMTP described in detail how mail could be moved directly or indirectly from one TCP/IP host to another without the need to use FTP or another file transfer method. (SMTP has its own detailed <a class="indexterm" id="idx-CHP-74-2635"/>history and discussion in <a class="xref" href="ch77.html" title="Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)">Chapter 77</a>.) Other complementary specifications were created at around the same time, which formalized or defined other components and elements of the system. We'll explore these pieces of the puzzle throughout the rest of this chapter.</p></div><div class="sect2" title="Overview of the TCP/IP Email System"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_the_tcpip_email_system"/>Overview of the TCP/IP Email System</h2></div></div></div><p>One of the most important general concepts in the modern email system is that a distinction is made between protocols that deliver email between SMTP hosts on the internetwork and those that let users access received mail on their local hosts. To continue the postal mail analogy, different protocols are used for sending mail between post offices and for home delivery. As you'll see, this was done intentionally to make it possible to send mail to users, even if they are not connected to the Internet when the mail is sent. This decoupling is critical, as it enables delayed <a class="indexterm" id="idx-CHP-74-2636"/>communication, where mail can be sent when the sender wants to transmit it and received when the recipient wants to read it.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-437"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One of the most important TCP/IP applications is the internetworking equivalent of the real-world postal delivery system, commonly called <span class="emphasis"><em>electronic mail</em></span> or <span class="emphasis"><em>email</em></span>. The history of email goes back to the very earliest days of TCP/IP's development. Today, it is used by millions of people every day to send both simple and complex messages around the world. TCP/IP email is not a single application, but rather a complete system that includes several protocols, software elements, and components.</p></div><p>Over the years, the basic components defined in the early 1980s have not changed substantially, but how they are used has evolved and improved. Early email delivery involved the use of route specifications by one SMTP host to dictate how mail was to be delivered through intermediate systems; today, the Domain Name System (DNS) makes much of that obsolete, facilitating nearly immediate direct mail delivery in most cases. Early email supported only simple text, but we can now send graphical images, programs, and other file attachments in email. Modern high-speed Internet connections and updated access protocols allow email to be the realization of the ultimate goal of nearly instantaneous communication, even across continents.</p></div></div></div>
<div class="sect1" title="TCP/IP Email Communication Overview"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_communication_overview"/>TCP/IP Email Communication Overview</h1></div></div></div><p>You've just seen that TCP/IP email is implemented as a complete system, with a number of elements that perform different portions of the complete job of email communication. These included a standard message format, a specific syntax for recipient addressing, and protocols to both deliver mail and allow access to mailboxes from intermittently connected TCP/IP clients.</p><p>To help set the groundwork for examining these components, here, I provide an overview of the complete end-to-end process of email communication, so you can see how everything works. I will show the basic steps in simplified form and continue the analogy to the regular mail system for comparison.</p><p>The modern TCP/IP email communication process consists of five basic steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Mail Composition</strong></span> A user begins the email journey by creating an email message. The message contains two sections: the <span class="emphasis"><em>body</em></span> and the <span class="emphasis"><em>header</em></span>. The body of the message is the actual information to be communicated. The header contains data that describes the message and controls how it is delivered and processed. The message must be created so that it matches the standard message format for the email system so that it can be processed (see <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>). It must also specify the email addresses of the intended recipients for the message (see <a class="xref" href="ch75.html" title="Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING">Chapter 75</a>). By way of analogy to "snail mail," the body of the message is like a letter, and the header is like the addressed and stamped envelope into which the letter is placed.</p></li><li class="listitem"><p><span class="strong"><strong>Mail Submission</strong></span> Email is different from many other internetworking applications in that the sender and receiver of a message do not necessarily need to be connected to the network simultaneously, nor even continuously, to use it. The system is designed so that after composing the message, the user decides when to submit it to the email system so it can be delivered. This is done using SMTP (see <a class="xref" href="ch77.html" title="Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)">Chapter 77</a>). This is analogous to dropping off an envelope at the post office or to a postal worker picking up an envelope from a mailbox and carrying it to the local post office to insert into the mail delivery stream.</p></li><li class="listitem"><p><span class="strong"><strong>Mail Delivery</strong></span> The email message is accepted by the sender's local SMTP system for delivery through the mail system to the destination user. Today, this is accomplished by performing a DNS lookup of the intended recipient's host system and establishing an SMTP connection to that system. SMTP also supports the ability to specify a sequence of SMTP servers through which a message must be passed to reach a destination. Eventually, the message arrives at the recipient's local SMTP system. This is like the transportation of the envelope through the postal system's internal "internetwork" of trucks, airplanes, and other equipment to the intended recipient's local post office.</p></li><li class="listitem"><p><span class="strong"><strong>Mail Receipt and Processing</strong></span> The local SMTP server accepts the email message and processes it. It places the mail into the intended recipient's mailbox, where it waits for the user to retrieve it. In our physical analogy, this is the step at which the recipient's local post office sorts mail coming in from the postal delivery system and puts the mail into individual post office boxes or bins for delivery.</p></li><li class="listitem"><p><span class="strong"><strong>Mail Access and Retrieval</strong></span> The intended recipient periodically checks with its local SMTP server to determine whether any mail has arrived. If so, the recipient retrieves the mail, opens it, and reads its content. This is done using a special mail access protocol or method (see <a class="xref" href="ch78.html" title="Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS">Chapter 78</a>). To save time, the access protocol and client email software may allow the user to scan the headers of received mail (such as the subject and sender's identity) to decide which mail messages to download. This is analogous to the step where mail is physically picked up at the post office or delivered to the home.</p></li></ol></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-438"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> TCP/IP email communication normally involves a sequence of five steps, each of which is analogous to a portion of the journey taken by a regular letter through the postal system. First, email is <span class="emphasis"><em>composed</em></span> (written); second, it is <span class="emphasis"><em>submitted</em></span> to the email system; third, it is <span class="emphasis"><em>delivered</em></span> to recipient's server; fourth, it is <span class="emphasis"><em>received and processed</em></span>; and fifth, it is <span class="emphasis"><em>accessed and retrieved</em></span> by its recipient.</p></div><p>In some cases, not all of these steps are performed. If a user is sending email from a device that is already an SMTP server, then step 2 can be omitted. If the recipient is logged in to a device that is also an SMTP server, step 5 will be skipped, as the user can read mail directly on the server. Thus, in the simplest case, all that occurs is composition, delivery, and receipt; this occurs when one user of a dial-up UNIX host sends mail to another. In most cases today, however, all five steps occur.</p></div>
<div class="sect1" title="TCP/IP Email Message Communication Model"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_message_communication_model"/>TCP/IP Email Message Communication Model</h1></div></div></div><p>The purpose of the email system as a whole is to accomplish the transmission of messages from a user of a TCP/IP internetwork to one or more recipients. To accomplish this, a special method of communication is required that makes the email system quite different from that used by most other protocols. To understand what I mean by this, just consider the difference in communication between sending a letter and making a phone call.</p><p>Most TCP/IP protocols are analogous to making a phone call in this respect: The sender and the receiver must both be on the network at the same time. You can't call someone and talk to him if he isn't around to answer the phone. (I'm ignoring answering machines and voice mail of course!) Most TCP/IP protocols are like this. To send a file using FTP, for example, you must make a direct connection from the sender's machine to the recipient's machine. If the recipient's machine is not on the network at the exact time that the sender's machine is, no communication is possible. For email, immediate communication of this sort is simply unacceptable.</p><p>As with real-world snail mail, Joe wants to be able to put a message into the system at a time that is convenient for him, and Ellen wants to be able to receive Joe's mail at a time that works for her. For this to work, email must use a "send and forget" <a class="indexterm" id="idx-CHP-74-2637"/>model, just like real mail, where Joe drops the "envelope" into the email system and it eventually arrives at its destination.</p><p>This <a class="indexterm" id="idx-CHP-74-2638"/><span class="emphasis"><em>decoupling</em></span> of the <a class="indexterm" id="idx-CHP-74-2639"/>sender and receiver is critical to the design of the email system. This is especially true because many of the users of Internet email are not on the Internet all the time. Just as you wouldn't want real mail to be rejected if it arrived when you are not home, you wouldn't want email to not be delivered if you are not on the Internet when it arrives. Similarly, you may not want to be connected to the Internet for the entire time it takes to write a message, especially if you have access to the Internet for only a limited amount of time each day.</p><p>Also critical to the entire email system is that idea that communication is between specific <span class="emphasis"><em>users</em></span>, not between particular machines. This makes email inherently different from many other types of communication on TCP/IP internetworks. You'll see more of why this is important when we look at email addressing in <a class="xref" href="ch75.html" title="Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING">Chapter 75</a>.</p><p>To allow the type of communication needed for email, the entire system is designed to facilitate the <a class="indexterm" id="idx-CHP-74-2640"/><span class="emphasis"><em>delayed delivery</em></span> of email messages from one user to another. To see how this works, let's look again at the example communication we discussed earlier—but this time, consider the roles of the different devices in the exchange (as shown in <a class="xref" href="ch74s03.html#email_communication_model_this_diagram_s" title="Figure 74-1. Email communication model This diagram shows the four devices that are involved in a typical email communication between two users. Each device consists of a number of different elements, which communicate as indicated by the black arrows. Note the inherent asymmetry, because the method used to send an email from a user is not the same as that used to retrieve it from the server. The large, shaded arrows show a typical transaction: the sender composes mail and it goes to her local email spool. It is sent to the sender's local SMTP server using SMTP, and then to the recipient's SMTP server, where it goes into that user's inbox. It is then retrieved, usually using a protocol such as POP or IMAP.">Figure 74-1</a>):</p><p><span class="strong"><strong>Sender's Client Host</strong></span> The sender composes an email message, generally using a mail client program on her local machine. The mail, once composed, is not immediately sent out over the Internet; it is held in a buffer area called a <span class="emphasis"><em>spool</em></span>. This allows the user to be "unattached" for the entire time that a number of outgoing messages are created. When the user is done, all of the messages can be sent at once.</p><p><span class="strong"><strong>Sender's Local SMTP Server</strong></span> When the user's mail is ready to be sent, she connects to the internetwork. The messages are then communicated to the user's designated local SMTP server, normally run by the user's Internet service provider (ISP). The mail is sent from the client machine to the local SMTP server using SMTP. (It is possible for the sender to be working directly on a device with a local SMTP server, in which case sending is simplified.)</p><p><span class="strong"><strong>Recipient's Local SMTP Server</strong></span> The sender's SMTP server sends the email using SMTP to the recipient's local SMTP server over the internetwork. There, the email is placed into the recipient's incoming mailbox (or inbox). This is comparable to the outgoing spool that existed on the sender's client machine. It allows the recipient to accumulate mail from many sources over a period of time and retrieve them when it is convenient.</p><p><span class="strong"><strong>Recipient's Client Host</strong></span> In certain cases, the recipient may access her mailbox directly on the local SMTP server. More often, however, a mail access and retrieval protocol, such as Post Office Protocol (POP3) or Internet Message Access Protocol (IMAP), is used to read the mail from the SMTP server and display it on the recipient's local machine. There, it is displayed using an email client program, similar to the one the sender used to compose the message in the first place.</p><div class="figure"><a id="email_communication_model_this_diagram_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e80471"/><img alt="Email communication model This diagram shows the four devices that are involved in a typical email communication between two users. Each device consists of a number of different elements, which communicate as indicated by the black arrows. Note the inherent asymmetry, because the method used to send an email from a user is not the same as that used to retrieve it from the server. The large, shaded arrows show a typical transaction: the sender composes mail and it goes to her local email spool. It is sent to the sender's local SMTP server using SMTP, and then to the recipient's SMTP server, where it goes into that user's inbox. It is then retrieved, usually using a protocol such as POP or IMAP." src="httpatomoreillycomsourcenostarchimages288287.png.jpg"/></div></div><p class="title">Figure 74-1. Email communication model This diagram shows the four devices that are involved in a typical email communication between two users. Each device consists of a number of different elements, which communicate as indicated by the black arrows. Note the inherent asymmetry, because the method used to send an email from a user is not the same as that used to retrieve it from the server. The large, shaded arrows show a typical transaction: the sender composes mail and it goes to her local email spool. It is sent to the sender's local SMTP server using SMTP, and then to the recipient's SMTP server, where it goes into that user's inbox. It is then retrieved, usually using a protocol such as POP or IMAP.</p></div></div>
<div class="sect1" title="Protocol Roles in Email Communication"><div class="titlepage"><div><div><h1 class="title"><a id="protocol_roles_in_email_communication"/>Protocol Roles in Email Communication</h1></div></div></div><p><a class="indexterm" id="idx-CHP-74-2641"/>You may have noticed that SMTP is used for most of this communication process. In fact, if the recipient uses a machine that runs SMTP software, which is common for those using dial-up UNIX shell Internet access, the process of sending email uses SMTP exclusively. SMTP servers must, however, always be available on the Internet and ready to accept mail. Most people access the Internet using devices that aren't always online or that don't run SMTP software. That is why the last step, email access and retrieval, is usually required.</p><p>It might have been possible to define the email system so that this last step of communication was carried out using SMTP as well, which would mean the entire system used the same protocol. However, SMTP was tailored for the specific purpose of transporting and delivering email, not for remote mailbox access. It made more sense to leave the function of mailbox access to dedicated, separate protocols. This not only allows these protocols to be tailored to the needs of email recipients, but it also provides flexibility by giving users more than one option for how email is retrieved. I discuss email access protocols and methods in <a class="xref" href="ch78.html" title="Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS">Chapter 78</a>, highlighting the two most common protocols: POP and IMAP.</p><p>The three protocols discussed here—SMTP, POP3, and IMAP—get lead billing on the TCP/IP email stage, but they rely on two other elements to play supporting roles. The first is a method of addressing email messages to ensure that they arrive at their destinations. The second is the set of message formats used to encode messages and control how they are delivered and used. These elements don't usually get as much attention as they deserve, but they do here, as I have devoted the next two chapters to them.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-439"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One of the critical requirements of an email system is that the sender and receiver of a message are not required to be on the system at the time mail is sent. TCP/IP therefore uses a communication model with several devices that allow the sender and recipient to be <span class="emphasis"><em>decoupled</em></span>. The sender's client device spools mail and moves it to the sender's local SMTP server when it is ready for transmission; the email is then transmitted to the receiver's SMTP server using SMTP. The email can remain on the recipient's server for an indefinite period of time. When the recipient is ready to read it, he retrieves it using one or more of a set of mail access protocols and methods, the two most popular of which are POP and IMAP.</p></div></div>
<div class="chapter" title="Chapter&#xA0;75.&#xA0;TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_electronic_mail_addresses_and_addr"/>Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e80508"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The entire concept of electronic mail (email) is based on an analogy: sending electronic messages is like sending paper messages. The analogy works well, because email was indeed intended to be like regular mail, only with the advantages of the technological era: speed and flexibility.</p><p>One of the many similarities between email and regular mail is the need for <span class="emphasis"><em>addressing</em></span>. For a message to be delivered, it is necessary for the sender to specify the recipient and provide a reasonable amount of information to indicate how and where the recipient can be reached. In TCP/IP email, a standard <span class="emphasis"><em>electronic mail address</em></span> format is used for this, and support is also provided for alternative addressing schemes that may be used in special cases.</p><p>In this chapter, I describe how email messages are addressed. I begin with a discussion of standard email addressing in TCP/IP and how those addresses are used to determine where email should be sent. I then provide a brief discussion of historical and special email addresses that you may encounter from time to time. I also discuss the use of email address books (aliases) and how multiple recipients may be addressed, and I provide an overview of electronic mailing lists, one of the earliest ways in which electronic group communication was implemented.</p><div class="sect1" title="TCP/IP Email Addressing and Address Resolution"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_addressing_and_address_resol"/>TCP/IP Email Addressing and Address Resolution</h1></div></div></div><p><a class="indexterm" id="idx-CHP-75-2642"/>All communication on an internetwork requires some way of specifying the identity of the intended recipient of the communication. Most application protocols, such as the File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP), use conventional TCP/IP constructs—IP addresses and port numbers—to specify the destination of information to be sent. The IP address normally identifies a particular host computer, and the port number indicates a software process or application running on that computer.</p><p>Email, however, uses a model for communication that differs from most applications. As you saw in the discussion of the email model in the previous chapter, one element that sets email apart from many other systems is that communication is <span class="emphasis"><em>user-oriented</em></span>. Email is not sent from one machine to another, as a file is transferred using FTP. Instead, it is sent from one user to another. This is critical to the operation of the entire system. For one thing, it allows someone to retrieve email that has been sent from any number of different client computers. This allows the recipient to receive email even when traveling, for example.</p><p>Since email messaging is user-based, the <a class="indexterm" id="idx-CHP-75-2643"/>addressing scheme must also be user-based. We cannot use conventional IP addresses and ports, so we need a distinct system that specifies two primary pieces of information: who the user is and where the user is located. These are, of course, analogous to a name and address on a regular mail envelope.</p><p>The idea of a user name is relatively straightforward, but identifying the location of the user is not. In regular mail, an address refers to a physical place. It would have been possible to define email addresses in the same way; that is, to have an email address refer to the user's client machine. However, recall the other important characteristic of email delivery: it is indirect and based on the concept of a user's local Simple Mail Transfer Protocol (SMTP) server holding received messages until they can be retrieved. The machine that the user employs to access his email may not even routinely be connected to the Internet, and it may thus not be easy to identify. And we also want a user to be able to access email from multiple machines.</p><p>For all of these reasons, we want addresses to identify not the user's specific location at any particular time, but the place where the user's permanent mailbox lives—on the user's SMTP server, which is permanently connected to the Internet.</p><div class="sect2" title="Standard DNS-Based Email Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="standard_dns-based_email_addresses"/>Standard DNS-Based Email Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-75-2644"/>In TCP/IP, the system used for identifying servers (and other machines) is the <span class="emphasis"><em>Domain Name System (DNS)</em></span>. DNS is a big system and is described in <a class="xref" href="pt12.html" title="Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION">Part III-1</a> of this book, which you should read if you want to learn more. For now, it is important that you realize that in DNS, all devices on the Internet are arranged into a device-naming hierarchy, and any device can be identified using a <span class="emphasis"><em>domain name</em></span> consisting of a series of text labels separated by dots.</p><p>The complete TCP/IP address consists of two components: a user name specification and a domain name specification. The two are connected together using the at symbol (@) to form the TCP/IP email address syntax that most of us are familiar with today: <span class="emphasis"><em>&lt;username&gt;</em></span>@<span class="emphasis"><em>&lt;domainname&gt;</em></span>.</p><p>The format of <span class="emphasis"><em>&lt;domainname&gt;</em></span> follows the syntax rules of DNS (see <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>), which specify that it can contain only numbers and digits for each label, and periods to separate the labels. The format of <span class="emphasis"><em>&lt;username&gt;</em></span> is slightly less restrictive, allowing special characters such as the underscore (_). Other special characters and spaces are also allowed in the <span class="emphasis"><em>&lt;username&gt;</em></span> if they are surrounded by quotation marks (or otherwise marked as being part the name, such as through the use of an escape character). Domain names are case-insensitive; user names may be case-sensitive, depending on the system.</p><p>An example of a valid email address is <span class="email"><a class="email" href="mailto:cmk@athena.mit.edu">cmk@athena.mit.edu</a></span> (an address I used when I was in school many years ago). Here, <span class="emphasis"><em>cmk</em></span> is my user name (my initials); <span class="emphasis"><em>athena.mit.edu</em></span> is the name of the host where I was receiving mail; and <span class="emphasis"><em>athena</em></span> is a particular system at Massachusetts Institute of Technology <span class="emphasis"><em>(mit)</em></span>, an educational institution that uses the <span class="emphasis"><em>.edu</em></span> top-level domain.</p><p>It is also possible to specify an email address using an Internet-standard Uniform Resource Locator (URL). This allows a link to be embedded in a hypertext (Web) document; when clicked, it invokes an email client to send mail to a user. Email URLs are created by preceding the address by the special URL scheme string <span class="emphasis"><em>mailto:</em></span>, like this: mailto:<span class="email"><a class="email" href="mailto:cmk@athena.mit.edu">cmk@athena.mit.edu</a></span>.</p></div><div class="sect2" title="Special Requirements of Email Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="special_requirements_of_email_addresses"/>Special Requirements of Email Addresses</h2></div></div></div><p><a class="indexterm" id="idx-CHP-75-2645"/>Having an email address refer to a user's local <a class="indexterm" id="idx-CHP-75-2646"/>SMTP server provides a great deal of flexibility compared to having the address mention a specific client computer. But this doesn't provide enough flexibility to handle the following situations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An organization may want to use generic addresses that do not specify the name of the SMTP server to handle email, to make it easier for senders or clients to remember an email address. For example, if someone knew my real name and that I was at MIT, it would be easier for him to remember my email address as <span class="email"><a class="email" href="mailto:cmk@mit.edu">cmk@mit.edu</a></span> than to remember <span class="email"><a class="email" href="mailto:cmk@athena.mit.edu">cmk@athena.mit.edu</a></span>.</p></li><li class="listitem"><p>An administrator may change which machines handle mail over a period of time. This would mean all the users' email addresses would have to be changed, too—and most of us know what a pain that is. For example, if I moved from the athena machine to the jabberwocky machine, my old address would need to be changed to <span class="email"><a class="email" href="mailto:cmk@jabberwocky.mit.edu">cmk@jabberwocky.mit.edu</a></span>. But if the address were just <span class="email"><a class="email" href="mailto:cmk@mit.edu">cmk@mit.edu</a></span>, a server change would not affect the address.</p></li><li class="listitem"><p>In larger organizations, it might be desirable to have multiple servers share the load of handling incoming email.</p></li></ul></div><p>To address all of these requirements, the DNS system includes a feature that was specifically designed to support email addressing. A special <span class="emphasis"><em>mail exchange (MX)</em></span><a class="indexterm" id="idx-CHP-75-2647"/> record can be set up that specifies which SMTP server should be used for mail arriving at a particular domain name. If properly configured, this allows considerable flexibility to handle the cases described above, and more. For more details, please see the description of the MX record and DNS electronic mail support in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-440"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Some form of addressing is required for all network communication; since email is <span class="emphasis"><em>user-oriented</em></span>, email addresses are also based on users. In modern TCP/IP email, standard addresses consist of a <span class="emphasis"><em>user name</em></span>, which specifies the recipient, and a <span class="emphasis"><em>domain name</em></span>, which specifies the DNS domain where the user is located. A special DNS <span class="emphasis"><em>mail exchange (MX)</em></span> record is set up for each domain that accepts email, so a sending SMTP server can determine what SMTP server it should use to send mail to a particular recipient.</p></div><p>Suppose, for example, that I am the owner of the pcguide.com domain name. Email can be sent to me at pcguide.com, but the mail is not actually stored on any server by that name. Instead, it is redirected to the real server where my inbox is located. This allows me to handle all incoming mail to pcguide.com, regardless of where my mailbox is actually located.</p><p>DNS is also significant in that its MX resource records eliminate the need to relay email from one SMTP server to the next to deliver it. In modern TCP/IP, it is possible to send email directly from the sender's SMTP server to the recipient's server, making communication faster and more efficient. This is also discussed in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>.</p></div></div></div>
<div class="sect1" title="TCP/IP Historical and Special Email Addressing"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_historical_and_special_email_addre"/>TCP/IP Historical and Special Email Addressing</h1></div></div></div><p><a class="indexterm" id="idx-CHP-75-2648"/>TCP/IP email has been so successful that it is arguably the most important worldwide standard for electronic messaging. The widespread acceptance of email is tied inextricably to that of TCP/IP and the Internet as a whole. Since most organizations want to be part of the Internet, they connect to it and use its technologies, including DNS, which is the basis for TCP/IP email addresses. In turn, the use of simple DNS-style email addresses (<span class="emphasis"><em>user</em></span>@<span class="emphasis"><em>domain</em></span>) encourages further use of email because people find it conceptually easy to decide how to send messages.</p><p>TCP/IP is not, however, the only email system around. Over the years, several other networks have developed email systems. Due to the fact that the Internet is the largest internetwork in the world, TCP/IP email has often been used as a clearinghouse of sorts to link together some of these different email mechanisms. This is called <a class="indexterm" id="idx-CHP-75-2649"/><span class="emphasis"><em>gatewaying</em></span>, and it allows someone using a non-SMTP email system to interact with someone using TCP/IP, and vice versa. Gatewaying is complex, in part because email systems use different ways of addressing mail. Let's take a look at a couple of these systems and how they interact with TCP/IP.</p><div class="sect2" title="FidoNet Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="fidonet_addressing"/>FidoNet Addressing</h2></div></div></div><p><a class="indexterm" id="idx-CHP-75-2650"/>One of the earliest independent email systems was the <span class="emphasis"><em>FidoNet</em></span>, which has been around for a long time and is still in use today. FidoNet is a worldwide network connected using modems and proprietary protocols; it is, in essence, a "competitor" to the global TCP/IP Internet. I put <span class="emphasis"><em>competitor</em></span> in quotes because FidoNet and the TCP/IP Internet are not really comparable in terms of number of users and the kinds of applications they support, but they are similar in overall objectives: worldwide electronic communication.</p><p>FidoNet users are identified using four numbers that specify the FidoNet <span class="emphasis"><em>zone, net, node</em></span>, and <span class="emphasis"><em>point (connection point)</em></span>. These addressing elements are used for sending mail on this system, which again is completely distinct from TCP/IP. However, to allow communication between TCP/IP and FidoNet, the FidoNet administrators have set up a gateway system that allows mail to be sent to FidoNet using TCP/IP-style domain names. This style of mapping was also used by other systems with proprietary mail address formats to allow them to interface with the Internet.</p><p>For example, if a user was on machine 4, node 205, net 141, zone 1 (North America), the FidoNet address would be 1:141/205:4. The equivalent domain name would be p4.f205.n141.z1.fidonet.org and could be used for TCP/IP-style <span class="emphasis"><em>user</em></span>@<span class="emphasis"><em>domain</em></span> addressing.</p></div><div class="sect2" title="UUCP-Style Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="uucp-style_addressing"/>UUCP-Style Addressing</h2></div></div></div><p><a class="indexterm" id="idx-CHP-75-2651"/>An older address style commonly associated with email was the <a class="indexterm" id="idx-CHP-75-2652"/>UUCP-style address. The <span class="emphasis"><em>Unix-to-Unix Copy Protocol (UUCP)</em></span> was commonly used years ago to route mail before SMTP became widely deployed (again, it is still used, just not as much as before). The addresses in this system are specified as a path of hosts separated by exclamation marks (!). The path dictates the route that mail takes to get to a particular user, passing through a series of intermediate machines running UUCP. For example, if mail to joe at the host joesplace had to go through three hosts—host1, host2, and host3, the address would be host1!host2!host3!joesplace!joe. Since the slang term for an exclamation mark is <span class="emphasis"><em>bang</em></span>, this came to be called <span class="emphasis"><em>bang path</em></span> notation.</p><p>The use of UUCP-style notation was sometimes mixed with TCP/IP-style domain name address notation when DNS came into use. So you might have seen something like host1!user@domain. There was some confusion in how exactly to interpret such an address: Does it mean to send mail first to host1 and then to user@domain? Or does it mean to first send it to the domain, which then goes to user at host1? There was no universal answer to this. The problem was mostly resolved both by the decrease in use of UUCP and the move on the part of UUCP systems to TCP/IP-style domain name addressing.</p></div><div class="sect2" title="Addressing for Gatewaying"><div class="titlepage"><div><div><h2 class="title"><a id="addressing_for_gatewaying"/>Addressing for Gatewaying</h2></div></div></div><p><a class="indexterm" id="idx-CHP-75-2653"/>You may encounter email addresses that appear as if multiple TCP/IP addresses have been nested using unusual punctuation. For example, you may see something like this: user%domain1.com@subdomain.domain2.edu. This is a way of addressing sometimes seen when email gateways are used; it will cause the mail to be sent to user%domain1.com at subdomain.domain2.edu. The address then is interpreted as user@domain1.com. However, again, not all systems are guaranteed to interpret this the same way.</p><p>Email gatewaying is not a simple matter in general, and as you can see, one reason is the use of different email address styles and the problems of consistency in how complex hybrid addresses are interpreted. However, as the Internet expands and TCP/IP becomes more widespread, it is becoming less and less common to see these older special address formats in use. They are becoming more and more a historical curiosity (unless you happen to use one of them).</p></div></div>
<div class="sect1" title="TCP/IP Email Aliases and Address Books"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_aliases_and_address_books"/>TCP/IP Email Aliases and Address Books</h1></div></div></div><p><a class="indexterm" id="idx-CHP-75-2654"/><a class="indexterm" id="idx-CHP-75-2655"/>Email is analogous to regular mail but superior to it due to two main advantages of digital and electronic communication. One advantage is <span class="emphasis"><em>speed</em></span>, which is why modern Internet users have come up with the slang term <span class="emphasis"><em>snail mail</em></span> to refer to the regular postal service. But the other advantage, <span class="emphasis"><em>flexibility</em></span>, is also essential. Email allows you to send messages easily in ways that would be cumbersome with regular mail. And one of the ways this flexibility can be seen is in addressing.</p><p>The first way that email addressing is flexible is that most email clients support advanced features that allow users to specify the identity of recipients in convenient ways. While TCP/IP addressing is fairly straightforward, remembering the addresses of everyone you know is difficult. In the real world, we use <a class="indexterm" id="idx-CHP-75-2656"/>address books to help us remember addresses. With email, we can do the same by allowing email software to associate a name with an email address.</p><p>This is usually done in one of two ways. In old-fashioned, text-based email such as that used on many UNIX systems, name and address association is performed using <a class="indexterm" id="idx-CHP-75-2657"/><span class="emphasis"><em>aliases</em></span>. These are short forms for email addresses that save typing. For example, I often send email to my wife, Robyn, but I'm too lazy to type in her complete address all the time. So I have defined an alias for her in my email program called simply <span class="emphasis"><em>r</em></span>. I enter the mail command and specify the alias <span class="emphasis"><em>r</em></span> as the intended recipient, and it expands her email address for me.</p><p>In modern graphical email systems, aliases aren't used. Instead, an <span class="emphasis"><em>electronic address book</em></span> is usually implemented, which is the equivalent of the paper address book. The difference is that there is no manual copying; you just choose the name from the list using your mouse.</p></div>
<div class="sect1" title="Multiple Recipient Addressing"><div class="titlepage"><div><div><h1 class="title"><a id="multiple_recipient_addressing"/>Multiple Recipient Addressing</h1></div></div></div><p>Another advantage of email addressing is that it allows the easy specification of <a class="indexterm" id="idx-CHP-75-2658"/>multiple recipients. With paper mail, sending a message to ten people means you need ten copies of the message, ten envelopes, and ten stamps. With email, you just list the recipient addresses separated by a comma in the recipient list: &lt;user1@domain1&gt;,&lt;user2@domain2&gt;,&lt;user3@domain3&gt;. A separate copy is mailed to each recipient. Of course, aliases and/or address books can be used to specify each recipient here as well, making this even simpler.</p><p>Since email makes it so easy for one person to send information to a set of others, so-called <span class="emphasis"><em>one-to-many</em></span> messaging, it was also one of the first ways in which electronic group communication was implemented. Prior to email, sharing information in a group setting required either a face-to-face meeting or a telephone conference call. In both cases, all parties must be present simultaneously, and a cost is involved, especially when the parties are geographically distant.</p><p>With email, a group of individuals can share information without needing to meet or even be available at the same time. Suppose a group comprises four individuals: Ellen, Joe, Jane, and Tom. Ellen has a proposal that she wants to discuss. She sends it to Joe, Jane, and Tom. Each recipient will read it at a time convenient for him or her. Each person can then reply back to the group. For example, Tom might have a comment on the proposal, so he just sends it to Ellen, Joe, and Jane. Most email clients include a <span class="emphasis"><em>group reply</em></span> feature for this purpose.</p></div>
<div class="sect1" title="Mailing Lists"><div class="titlepage"><div><div><h1 class="title"><a id="mailing_lists"/>Mailing Lists</h1></div></div></div><p><a class="indexterm" id="idx-CHP-75-2659"/>In larger groups, communication by typing the addresses of each recipient becomes cumbersome. Instead, a <a class="indexterm" id="idx-CHP-75-2660"/><span class="emphasis"><em>mailing list</em></span> is used. The list is created by an individual termed the <span class="emphasis"><em>list owner</em></span> and contains the email addresses of all the members of the group. A special <span class="emphasis"><em>list address</em></span> is created, which functions just like a regular email address. However, when anyone sends mail to this special address, it is not simply deposited into a mailbox. It is instead intercepted by special software that processes the message and sends it out automatically to all recipients on the list. Any recipient can reply to the list address, and all members will receive the reply.</p><p>Many other ways can be used by groups to share information today, such as using World Wide Web bulletin boards, Usenet newsgroups, Internet Relay Chat (IRC), and so forth. Some of these have a lot of features that make mailing lists seem unsophisticated by comparison. Despite this, electronic mailing lists are still very popular, largely because email is the most universal Internet communication method and one of the easiest methods to use.</p><p>Many thousands of mailing lists are in use on the Internet, covering every subject imaginable. Each list differs in a number of regards, including the following five aspects:</p><p><span class="strong"><strong>Implementation</strong></span> Usually, some sort of special software is used to allow the list owner to manage it, add and remove users, and set parameters that control how the list operates. These programs are commonly called <a class="indexterm" id="idx-CHP-75-2661"/><span class="emphasis"><em>robots</em></span> or <a class="indexterm" id="idx-CHP-75-2662"/><span class="emphasis"><em>listservs (list servers)</em></span>. One of the more common listservs is named <a class="indexterm" id="idx-CHP-75-2663"/><span class="emphasis"><em>Majordomo</em></span>. Some mailing lists are actually implemented and managed using the Web. (The line between Internet applications continues to get more and more blurry.)</p><p><span class="strong"><strong>Subscription Rules and Technique</strong></span> Some mailing lists are open to anyone who wishes to join; others are by invitation only. Most allow a new subscriber to join automatically using software; others require the list owner to add new members.</p><p><span class="strong"><strong>Management Method and Style</strong></span> The list owner decides what is acceptable for discussion on the list. Some lists are <a class="indexterm" id="idx-CHP-75-2664"/><span class="emphasis"><em>moderated</em></span>, meaning that all submissions to the list must be approved by the list owner before they are sent to list members. Some lists allow mail to the list from nonmembers, and some do not.</p><p><span class="strong"><strong>Culture</strong></span> Like all groups, groups of people on mailing lists have their own culture, interesting personalities, and other unique traits. New members of a list are often encouraged to read the list and not send to it for a while until they become accustomed to it and how it works. This is similar to the acclimation process for Usenet newbies (Usenet is covered in <a class="xref" href="ch85.html" title="Chapter 85. USENET (NETWORK NEWS) AND THE TCP/IP NETWORK NEWS TRANSFER PROTOCOL (NNTP)">Chapter 85</a>).</p><p><span class="strong"><strong>Special Features</strong></span> Some lists support special features, such as the ability to subscribe in <span class="emphasis"><em>digest mode</em></span> (where messages are collected into large digests to reduce the number of individual messages sent) or to access messages on the Web.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-441"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One of the many benefits of email is that it is easy to send a message to many people at once, simply by specifying several recipient addresses. This permits easy and simple <span class="emphasis"><em>group communication</em></span>, because each recipient can then send a group reply to respond to each of the people who were sent the original message. Electronic <span class="emphasis"><em>mailing lists</em></span> provide a more formalized way for groups to exchange ideas and information; many thousands of such lists are in use on the Internet.</p></div></div>
<div class="chapter" title="Chapter&#xA0;76.&#xA0;TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_electronic_mail_message_formats_an"/>Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e80955"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The advantages of using computers for communication are obvious, but some limitations are also imposed by the use of computer technology. When I compare electronic mail (email) to regular mail, I always point out that email is much faster <a class="indexterm" id="idx-CHP-76-2665"/>and more flexible in how it can be delivered, and this is true. An email message can reach its destination in seconds, while a conventional letter can take days.</p><p>However, one significant drawback of using computers to communicate is that they are not very flexible in figuring out how to understand messages. Consider that anyone can put any type of letter, memorandum, or other communication in an envelope and send it to you, and assuming you know the language in which it is written, you can open the envelope and probably understand it. You can figure out how to deal with a date that appears in an unusual place in the letter, or your name appearing at the top compared to the bottom, or the body of the message being structured in different ways. You can read notes that are typed or handwritten in pen, pencil, or crayon—as long as the letters are decipherable, you can understand what is being said.</p><p>Computers are not good at deciphering such subtleties. It is for that reason that email systems must rely on standard message formats to ensure that all messages have the same form and structure. This then makes it possible for all devices in the email system to read and understand one another's messages, to enable TCP/IP email to work on many different types of computers.</p><p>In this chapter, I describe the two formats used for TCP/IP email messages: the main TCP/IP email standard, which is called the <a class="indexterm" id="idx-CHP-76-2666"/>RFC 822 format after the standard that defines it, and the Multipurpose Internet Mail Extensions (MIME) standard, which greatly expands the ability of email to support the communication of different types of information by defining methods of encoding various media and non-English-language text into the standard <a class="indexterm" id="idx-CHP-76-2667"/>RFC 822 format.</p><div class="sect1" title="TCP/IP Email RFC 822 Standard Message Format Overview"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_rfc_822_standard_message_for"/>TCP/IP Email RFC 822 Standard Message Format Overview</h1></div></div></div><p>One of the most astute observations I have read about internetworking applications asserts that their usefulness is proportional to the number of people who use them. TCP/IP email is a great example. It is a powerful communication method in large part because almost everyone with a computer today participates in the system. The more people who sign on to use email, the more powerful it becomes.</p><p>The creators of TCP/IP email realized that people who use the system would employ many different types of hardware and software. To ensure that everyone was able to understand all email messages, regardless of who sent them, they specified a common message format for email messages. This format doesn't have an official fancy name; it is simply known by the name of the standard that defines it: the RFC 822 message format.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-442"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>This discussion will make certain references to the discussion of the Simple Mail Transfer Protocol (SMTP; see <a class="xref" href="ch77.html" title="Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)">Chapter 77</a>) but was designed so that you could read it prior to learning about SMTP without getting confused</em></span>.</p></div><p>The primary protocol for delivering email is Simple Mail Transfer Protocol (SMTP). For this reason, the message format used for TCP/IP email could be considered SMTP's protocol message format, not unlike the special message formats discussed for other protocols, such as the Internet Protocol (IP) and the Transmission Control Protocol (TCP). However, the TCP/IP email message format is used not only by SMTP, but by all protocols and applications that deal with email. This includes the mail-access protocols Post Office Protocol (POP3) and Internet Message Access Protocol (IMAP), as well as others. It was also intended to be potentially usable by other non-TCP/IP mail delivery protocols. Perhaps for this reason, the TCP/IP email format was not specified as part of the SMTP itself, RFC 821, but was specified in a companion document, RFC 822. Both were published in 1982.</p><div class="sect2" title="Development of the RFC 822 Message Format Standard"><div class="titlepage"><div><div><h2 class="title"><a id="development_of_the_rfc_822_message_forma"/>Development of the RFC 822 Message Format Standard</h2></div></div></div><p>The history <a class="indexterm" id="idx-CHP-76-2668"/>of the <a class="indexterm" id="idx-CHP-76-2669"/>message format used in TCP/IP starts long before 1982. It was originally defined as the format for passing text messages on the Internet's precursor, the ARPAnet, in the early 1970s. The format was refined several times, leading to the publication in 1977 of the important email standard RFC 733, "Standard for the Format of ARPA Network Text Messages." RFC 822 later streamlined the contents of RFC 733, removing some of the features described in the earlier standard that failed to gain acceptance and simplifying the specification.</p><p>In 2001, both SMTP and the RFC 822 message format were revised; SMTP is now described in RFC 2821 and the message format in RFC 2822. This newer standard makes relatively small changes to the RFC 822 message format to reflect modern use of TCP/IP email. Even though RFC 2822 is the current standard, the original name is still the one most commonly used. I will respect that convention in this discussion, describing the message format based on RFC 2822 while still calling it the RFC 822 message format.</p><p>The RFC 822 format describes the form, structure, and content of TCP/IP email messages. It is, as I said, analogous to the message formats used for other protocols in TCP/IP. Like those other formats, the RFC 822 format can be logically divided into two main sections: the <span class="emphasis"><em>message header</em></span>, which contains important control and descriptive information, and the <span class="emphasis"><em>message body</em></span> or <span class="emphasis"><em>payload</em></span>, which carries the data.</p></div><div class="sect2" title="Overview of RFC 822 Messages"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_rfc_822_messages"/>Overview of RFC 822 Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2670"/>Where RFC 822 differs from the field formats of other protocols is in expression. Most TCP/IP protocols encode header information into a compact set of bytes that are read and understood based on their location in the message and the semantic meaning assigned to them. Consider IP, for example. The ninth byte of every IP datagram is the Time to Live (TTL) field, which is encoded as a value from 0 to 255. A device reading an IP datagram simply knows that byte number 9 contains the TTL value. If it sees the binary value 00010011 there, it knows the TTL value for this datagram is the decimal value 19.</p><p>In contrast, RFC 822 messages do not use a binary format. They are composed entirely of lines of regular ASCII text (as used in the United States, called <a class="indexterm" id="idx-CHP-76-2671"/><span class="emphasis"><em>US-ASCII</em></span> by the standard), even the headers. Each line ends with an ASCII <a class="indexterm" id="idx-CHP-76-2672"/><span class="emphasis"><em>carriage return (CR)</em></span> character, followed by a <a class="indexterm" id="idx-CHP-76-2673"/><span class="emphasis"><em>line feed (LF)</em></span> character; the combination is collectively termed <span class="emphasis"><em>CRLF</em></span>. Each line of text should be 78 or fewer characters (not including the terminating CRLF) and must not be more than 998 characters (again, excluding the CRLF). Also, the CR and LF characters must not appear by themselves within the text.</p><p>The RFC 822 message begins with a set of lines of text that collectively make up the message header. Each <span class="emphasis"><em>header field</em></span> is expressed in the following form, in text: <span class="emphasis"><em>&lt;header name&gt;: &lt;header value&gt;</em></span>. So, for example, if a <span class="emphasis"><em>TTL</em></span> field were in an RFC 822 message (which it isn't, as that concept is not particular to email) and a value of 19 needed to be expressed, the header field would appear like this: <span class="emphasis"><em>Time to Live: 19</em></span>.</p><p>This expressing of all fields as simple text means each header takes up more space in each message; the string <span class="emphasis"><em>Time To Live: 19</em></span> takes up 18 bytes including the terminating CRLF, whereas the binary-encoded TTL field in the IP header takes only a single byte. What we gain from this are two important benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Any user can easily check the headers and immediately understand what headers are present and what their values are, which makes RFC 822 messages very readable.</p></li><li class="listitem"><p>Since each header is explicitly labeled, RFC 822 messages can vary in terms of the number of headers they contain and even in what order they appear, making them flexible.</p></li></ul></div></div><div class="sect2" title="General RFC 822 Message Structure"><div class="titlepage"><div><div><h2 class="title"><a id="general_rfc_822_message_structure"/>General RFC 822 Message Structure</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2674"/>The RFC 822 message always starts with a set of header fields (as described in the next section). After all the headers, an empty line must occur. This consists simply of the characters CRLF alone, immediately following the CRLF at the end of the final header field line. Seeing two CRLF character pairs in sequence tells the device reading the message that the end of the headers has been reached. All the remaining lines are considered the body of the message. Like the header lines, body lines are composed of ASCII text and must be no more than 998 characters, with 78 characters or fewer recommended (for easier reading on standard 80-character terminal displays).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-443"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> To ensure that every device on a TCP/IP internetwork can read email sent by every other device, all messages are required to adhere to a specific structure. The standard that first specified the form of modern TCP/IP email messages was RFC 822, and as a result, this is now called the <span class="emphasis"><em>RFC 822 message format</em></span>. An RFC 822 message consists of a set of <span class="emphasis"><em>message headers</em></span> and a <span class="emphasis"><em>message body</em></span>, which are separated by a blank line. RFC 822 messages must contain only plain ASCII text characters. Each line must be no more than 1,000 characters in length, and the last two characters must be the ASCII CR and LF characters to mark the end of the line.</p></div><p>Since both the header and body of email messages are simply ASCII text, the entire message is just a text file, so these messages are very readable and also easy to create. You can use a simple text editor to create a complete email message, including headers, and it can be read with a simple text display utility. This contributes to email's universal appeal.</p><p>The drawback is that the decision to make messages entirely ASCII means that no native support is available in RFC 822 messages for anything that requires more complex structuring or that cannot be expressed using the limited number of ASCII characters. So, you cannot express pictures, binary files, spreadsheets, sound clips, and similar types of files directly using ASCII. Also, the use of ASCII makes RFC 822 well suited to expressing messages in English but not in many other languages that use characters that ASCII cannot represent. All of these limitations eventually prompted the creation of the enhanced MIME message format, which we will explore in detail later in this chapter.</p></div></div></div>
<div class="sect1" title="TCP/IP Email RFC 822 Standard Message Format Header Fields and Groups"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_rfc_822_standard_messa-id001"/>TCP/IP Email RFC 822 Standard Message Format Header Fields and Groups</h1></div></div></div><p>The RFC 822 message format describes the <a class="indexterm" id="idx-CHP-76-2675"/>structure and content of TCP/IP email messages. The structure is intentionally designed to be simple and easy to create and understand. Each message begins with a set of headers that describe the message and its contents. An empty line marks the end of the headers, and then the message body follows.</p><p>The message body contains the actual text that the sender is communicating to the recipient(s), while the message header contains information that serves various purposes. The header helps control how the message is processed by specifying who the recipients are, describing the contents of the message, and providing information to a recipient of a message about processing that occurred on the message as it was delivered.</p><div class="sect2" title="Header Field Structure"><div class="titlepage"><div><div><h2 class="title"><a id="header_field_structure"/>Header Field Structure</h2></div></div></div><p>As mentioned earlier, the <span class="emphasis"><em>&lt;header name&gt;</em></span> field is the name of the header, and the <span class="emphasis"><em>&lt;header value&gt;</em></span> is the value associated with that header, which depends on the header type. Like all RFC 822 lines, headers must be no more than 998 characters long and are recommended to be no more than 78 characters in length, for easier readability. The RFC 822 and 2822 standards support a special syntax for allowing headers to be folded onto multiple lines if they are very lengthy. This is done by continuing a header value onto a new line, which must begin with at least one white-space character, such as white space or a tab character, like this:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="emphasis"><em>&lt;header name&gt;: &lt;header value part 1&gt;</em></span></td></tr><tr><td><span class="emphasis"><em>&lt;white space&gt; &lt;header value part 2&gt;</em></span></td></tr><tr><td><span class="emphasis"><em>&lt;white space&gt; &lt;header value part 3&gt;</em></span></td></tr></table><p>The tab character is most often used for this purpose. So, for example, if we wanted to specify a large number of recipients for a message, we could do it as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>To:<span class="emphasis"><em>&lt;tab&gt;person1@domain1.org, person2@domain2.com</em></span>,</td></tr><tr><td><span class="emphasis"><em>&lt;tab&gt;person3@domain3.net, person4@domain4.edu</em></span></td></tr></table></div><div class="sect2" title="Header Field Groups"><div class="titlepage"><div><div><h2 class="title"><a id="header_field_groups"/>Header Field Groups</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2676"/>The RFC 822 message format specifies many types of headers that can be included in email messages. A small number of headers are mandatory, meaning they must be included in all messages. Some are not mandatory but are usually present, because they are fundamental to describing the message. Other optional headers are included only when needed.</p><p>To help organize the many headers, the RFC 2822 standard categorizes them into <a class="indexterm" id="idx-CHP-76-2677"/>header field <a class="indexterm" id="idx-CHP-76-2678"/>groups (as did RFC 822, though the groups are a little different in the older standard):</p><p><span class="strong"><strong>Origination Date Field</strong></span> Specifies the date and time that the message was made ready for delivery; see the next section for details. (This field is in its own group for reasons that are unclear to me; perhaps just because it is so important.)</p><p><span class="strong"><strong>Originator Fields</strong></span> Contain information about the sender of the message.</p><p><span class="strong"><strong>Destination Address Fields</strong></span> Specify the recipient(s) of the message, which may be in one of three different recipient classes: the primary recipients ("To"), copied recipients ("Cc"), and blind-copied recipients ("Bcc").</p><p><span class="strong"><strong>Identification Fields</strong></span> Contain information to help identify the message.</p><p><span class="strong"><strong>Informational Fields</strong></span> Contain optional information to help make clear to the recipient what the message is about.</p><p><span class="strong"><strong>Resent Fields</strong></span> Preserve the original originator, destination, and other fields when a message is resent.</p><p><span class="strong"><strong>Trace Fields</strong></span> Show the path taken by mail as it was transported.</p><p>In addition, the format allows other user-defined fields to be specified, as long as they correspond to the standard <span class="emphasis"><em>&lt;header name&gt;: &lt;header value&gt;</em></span> syntax. This can be used to provide additional information of various sorts. For example, sometimes the email client software will include a header line indicating the name and version of the software used to compose and send the message. As you'll see later in this chapter, MIME uses new header lines to encode information about MIME messages.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-444"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each RFC 822 message begins with a set of <span class="emphasis"><em>headers</em></span> that carry essential information about the message. These headers are used to manage how the message is processed and interpreted, and they also describe the contents of the message body. Each header consists of a <span class="emphasis"><em>header name</em></span> and a <span class="emphasis"><em>header value</em></span>. More than a dozen different standard RFC 822 headers are available for use and organized into groups. It is also possible to define custom user headers.</p></div></div><div class="sect2" title="Common Header Field Groups and Header Fields"><div class="titlepage"><div><div><h2 class="title"><a id="common_header_field_groups_and_header_fi"/>Common Header Field Groups and Header Fields</h2></div></div></div><p><a class="xref" href="ch76s02.html#rfc__email_header_field_groups_and_field" title="Table 76-1. RFC 822 Email Header Field Groups and Fields">Table 76-1</a> describes the header fields in TCP/IP email messages and how they are used.</p><div class="table"><a id="rfc__email_header_field_groups_and_field"/><p class="title">Table 76-1. RFC 822 Email Header Field Groups and Fields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="RFC 822 Email Header Field Groups and Fields"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Group</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Appearance</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Number of Occurrences Per Message</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Origination Date</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mandatory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates date and time that the message was made available for delivery by the mail transport system. This is commonly the date/time that the user tells her email client to send the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Originator Fields</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>From:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mandatory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Email address of the user sending the message, who should be the person who is the source of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sender:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Email address of the person sending the email, if different from the message originator. For example, if person B is sending an email containing a message from person A on A's behalf, person A's address goes in the From: header and person B's in the Sender: header. If the originator and the sender are the same (commonly the case), this field is not present.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reply-To:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the recipient of the message the address the originator would like the recipient to use for replies. If absent, replies are normally sent back to the From: address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Destination Address Field</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Normally present</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>A list of primary recipients of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Cc:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>A list of recipients to receive a copy of the message (<span class="emphasis"><em>cc</em></span> stands for carbon copy, as used in old typewriters). There is no technical difference between how a message is sent to someone listed in the Cc: header and someone in the To: header. The difference is only in how the recipient interprets the message. The person in the To: list is usually the main recipient of the message, while the person in the Cc: list is being copied on the message for informational purposes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bcc:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains a list of recipients to receive a "blind" copy of the message without other recipients knowing they have received it. For example, if person X is specified in the <span class="emphasis"><em>To</em></span>: line, person Y is in the <span class="emphasis"><em>Cc</em></span>: line, and person Z is in the <span class="emphasis"><em>Bcc</em></span>: line, all three would get a copy of the message, but X and Y would not know Z had received a copy. This is done by either removing the <span class="emphasis"><em>Bcc</em></span>: line before message delivery or altering its contents.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Identification Fields</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message-ID:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Should be present</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides a unique code for identifying a message; normally generated when a message is sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>In-Reply-To:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional, normally present for replies</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>When a message is sent in reply to another, the Message-ID: field of the original message is specified in this field, to tell the recipient of the reply to what original message the reply pertains.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>References:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies other documents related to this message, such as other email messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Informational Fields</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subject:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Normally present</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes the subject or topic of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Comments:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unlimited</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains summarized comments about the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Keywords:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unlimited</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains a list of comma-separated keywords that may be useful to the recipient. May be used optionally when searching for messages on a particular subject matter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Resent Fields</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Resent-Date:</p>
<p>Resent-From:</p>
<p>Resent-Sender:</p>
<p>Resent-To:</p>
<p>Resent-Cc:</p>
<p>Resent-Bcc:</p>
<p>Resent-Message-ID:</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Each time a message is resent, a resent block is required</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>For each resent block, Resent-Date: and Resent-Sender: are required; others are optional</p></td><td style="border-bottom: 0.5pt solid ; "><p>Special fields used only when a message is resent by the original recipient to someone else, called forwarding. For example, person X may send a message to Y, who forwards it to Z. In that case, the original Date:, From:, and other headers are as they were when person X sent the message. The Resent-Date:, Resent-From:, and other resent headers are used to indicate the date, originator, recipient, and other characteristics of the resent message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Trace Fields</p></td><td style="border-right: 0.5pt solid ; "><p>Received: Return-Path:</p></td><td style="border-right: 0.5pt solid ; "><p>Inserted by email system</p></td><td style="border-right: 0.5pt solid ; "><p>Unlimited</p></td><td style=""><p>Inserted by computers as they process a message and transport it from the originator to the recipient. Can be used to trace the path a message took through the email system.</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="TCP/IP Email RFC 822 Standard Message Format Processing and Interpretation"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_rfc_822_standard_messa-id002"/>TCP/IP Email RFC 822 Standard Message Format Processing and Interpretation</h1></div></div></div><p>The standards that define SMTP describe the protocol as being responsible for transporting <span class="emphasis"><em>mail objects</em></span>. A mail object is described as consisting of two components: a <span class="emphasis"><em>message</em></span> and an <span class="emphasis"><em>envelope</em></span>. The message is everything in the email message, including both message header and body; the envelope contains all the information necessary to accomplish transport of the message.</p><p>The distinction <a class="indexterm" id="idx-CHP-76-2679"/>between these objects is important technically. Just as the postal service looks only at the envelope and not its contents in determining what to do with a letter, SMTP likewise looks only at the envelope in deciding how to send a message. It does not rely on the information in the actual message itself for basic transport purposes.</p><p>So the envelope is not the same as the message headers. However, as you can tell by looking at the list of email headers, each message includes the recipients and other information needed for mail transport. For this reason, it is typical for an email message to be specified with enough header information to accomplish its own delivery. Email software can process and interpret the message to construct the necessary envelope for SMTP to transport the message to its destination mailbox. The distinction between an email message and its envelope is discussed in more detail in the section describing SMTP mail transfers, in <a class="xref" href="ch77.html" title="Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)">Chapter 77</a>.</p><p>The <a class="indexterm" id="idx-CHP-76-2680"/>processing of RFC 822 messages is relatively straightforward, due again to the simple RFC 822 message format. The creation of the complete email message begins with the creation of a message body and certain headers by the user creating the message. Whenever a message is "handled" by a software program, the headers are examined so the program can determine what to do with it. Additional headers are also added and changed as needed.</p><p>The following is the sequence of events that occur during the lifetime of a message's headers.</p><p><span class="strong"><strong>Composition</strong></span> The human composer of the message writes the message body and tells the email client program the values to use for certain important header fields. These include the intended recipients, the message subject, other informational fields, and certain optional headers such as the Reply-To field.</p><p><span class="strong"><strong>Sender Client <a class="indexterm" id="idx-CHP-76-2681"/>Processing</strong></span> The email client processes the message, puts the information the human provided into the appropriate header form, and creates the initial email message. At this time, it inserts certain headers into the message, such as the origination date. The client also parses the intended recipient list to create the envelope for transmission of the message using SMTP.</p><p><span class="strong"><strong>SMTP Server Processing</strong></span> SMTP servers do not pay attention to most of the fields in a message as they forward it. They will, however, add certain headers, especially trace headers such as Received and Return-Path, as they transport the message. These are generally prepended to the beginning of the message to ensure that existing headers are not rearranged or modified. Note, however, that when gatewaying occurs between email systems (as described in <a class="xref" href="ch75.html" title="Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING">Chapter 75</a>), certain headers must actually be changed to ensure that the message is compatible with non-TCP/IP email software.</p><p><span class="strong"><strong>Recipient Client Processing</strong></span> When the message arrives at its destination, the recipient's SMTP server may add headers to indicate the date and time the message was received.</p><p><span class="strong"><strong>Recipient Access</strong></span> When the recipient of a message uses client software, optionally via an email access protocol such as POP3 or IMAP, the software analyzes each message in the mailbox. This enables the software to display the messages in a way that's meaningful to the human user and may also permit the selection of particular messages to be retrieved. For example, most of us like to see a summary list of newly received mail, showing the originator, message subject, and the date and time the message was received, so we can decide what mail we want to read first, what mail to defer to a later time, and what to delete without reading (such as spam).</p></div>
<div class="sect1" title="MIME Overview"><div class="titlepage"><div><div><h1 class="title"><a id="mime_overview"/>MIME Overview</h1></div></div></div><p><a class="indexterm" id="idx-CHP-76-2682"/>The RFC 822 email message format is the standard for the exchange of email in TCP/IP internetworks. Its use of simple ASCII text makes it easy to create, process, and read email messages, which has contributed to the success of email as a worldwide communication method.</p><p>Unfortunately, while ASCII text is great for writing simple memorandums and other short messages, it provides no flexibility to support other types of communication. To allow email to carry multimedia information, arbitrary files, and messages in languages using character sets other than ASCII, the MIME standard was created.</p><div class="note" title="Note"><h3 class="title"><a id="note-158"/>Note</h3><p><span class="emphasis"><em>While MIME was developed specifically for email, its encoding and data representation methods have proven so useful that it has been adopted by other application protocols as well. One of the best known of these is the Hypertext Transfer Protocol (HTTP), which uses MIME headers for indicating the characteristics of data being transferred. Some elements of MIME were in fact developed not for email but for use by HTTP or other protocols, and I indicate this where appropriate. Be aware that HTTP only uses some elements of MIME; HTTP messages are not MIME-compliant</em></span>.</p></div><p>Most protocols become successful specifically because they are based on open standards that are widely accepted. The RFC 822 email message format standard is an excellent example; it is used by millions of people every day to send and receive TCP/IP email.</p><p>However, success of standards comes at a price: <span class="emphasis"><em>reliance</em></span> on those standards. Once a standard is in wide use, it is very difficult to modify it, even when times change and the standard is no longer sufficient for the requirements of modern computing. Again, unfortunately, the RFC 822 email message format is an excellent example.</p><div class="sect2" title="The Motivation for MIME"><div class="titlepage"><div><div><h2 class="title"><a id="the_motivation_for_mime"/>The Motivation for MIME</h2></div></div></div><div class="sect3" title="The Motivation for MIME"><div class="titlepage"><div><div><h3 class="title"><a id="the_motivation_for_mime-id001"/>The Motivation for MIME</h3></div></div></div><p><a class="indexterm" id="idx-CHP-76-2683"/>TCP/IP email was developed in the 1960s and 1970s. Compared to the way the world of computers and networking is today, almost everything back then was <span class="emphasis"><em>small</em></span>. The networks were small; the number of users was small; the computing capabilities of networked hosts was small; the capacity of network connections was small; the number of network applications was small. (The only thing that wasn't small back then was the size of the computers themselves!)</p><p>As a result of this, the requirements for electronic mail messaging were also rather … small. Most computer input and output back then was text-based, and it was therefore natural that the creators of SMTP and the RFC 822 standard would have envisioned email as being strictly a text medium. Accordingly, they specified RFC 822 to carry text messages.</p><p>The fledgling Internet was also developed within the United States, and at first, the entire internetwork was within American borders. Most people in the United States speak English, a language that as you may know uses a relatively small number of characters that is well-represented using the ASCII character set. Defining the email message format to support United States ASCII (US-ASCII) also made sense at the time.</p><p>However, as computers developed, they moved away from a strict text model toward graphical operating systems. And predictably, users became interested in sending more than just text. They wanted to be able to transmit diagrams, non-ASCII text documents (such as Microsoft Word files), binary program files, and eventually multimedia information: digital photographs, MP3 audio clips, slide presentations, movie files and much more. Also, as the Internet grew and became global, other countries came "online," some of which used languages that simply could not be expressed with the US-ASCII character set.</p><p>Unfortunately, by this point, the die was cast. RFC 822 was in wide use and changing it would have also meant changes to how protocols such as SMTP, POP and IMAP worked, protocols that ran on millions of machines. Yet by the late 1980s, it was quite clear that the limitations of plain ASCII email were a big problem that had to be resolved. A solution was needed, and it came in the form of the Multipurpose Internet Mail Extensions (MIME).</p><div class="note" title="Note"><h3 class="title"><a id="note-159"/>Note</h3><p><span class="emphasis"><em>MIME is usually referred to in the singular, as I will do from here forward, even though it is an abbreviation of a plural term</em></span>.</p></div></div></div><div class="sect2" title="MIME Capabilities"><div class="titlepage"><div><div><h2 class="title"><a id="mime_capabilities"/>MIME Capabilities</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2684"/>The idea behind MIME is both clever and elegant: RFC 822 restricts email messages to ASCII text, but that doesn't mean that we can't define a more specific structure for how that ASCII text is created. Instead of just letting the user type an ASCII text message, we can use ASCII text characters to encode nontext data parcels (commonly called <a class="indexterm" id="idx-CHP-76-2685"/><span class="emphasis"><em>attachments</em></span>). Using this technique, MIME allows regular RFC 822 email messages to carry the following:</p><p><span class="strong"><strong>Nontext Information</strong></span> Includes graphics files, multimedia clips, and all the other nontext data examples listed earlier.</p><p><span class="strong"><strong>Arbitrary Binary Files</strong></span> Includes executable programs and files stored in proprietary formats (for example, AutoCAD files, Adobe Acrobat PDF files, and so forth).</p><p><span class="strong"><strong>Text Messages That Use Character Sets Other Than ASCII</strong></span> Includes the ability to use non-ASCII characters in the headers of RFC 822 email messages.</p><p>MIME even goes one step beyond this, by actually defining a structure that allows multiple files to be encoded into a single email message, including files of different types. For example, someone working on a budget analysis could send one email message that includes a text message, a PowerPoint presentation, and a spreadsheet containing the budget figures. This capability has greatly expanded email's usefulness in TCP/IP.</p><p>All of this is accomplished through special encoding rules that transform non-ASCII files and information into an ASCII form. Headers are added to the message to indicate how the information is encoded. The encoded message can then be sent through the system like any other message. SMTP and the other protocols that handle mail pay no attention to the message body, so they don't even know MIME has been used.</p><p>The only change required to the email software is adding support for MIME to email client programs. Both the sender and receiver must support MIME to encode and decode the messages. Support for MIME was not widespread when MIME was first developed, but the value of the technique is so significant that it is present in nearly all email client software today. Furthermore, most clients today can also use the information in MIME headers to not only decode nontext information but pass it to the appropriate application for presentation to the user.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-445"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The use of the RFC 822 message format ensures that all devices are able to read one another's email messages, but it has a critical limitation: It supports only plain ASCII text. This is insufficient for the needs of modern internetworks, yet reliance on the RFC 822 standard would have made replacing it difficult. <span class="emphasis"><em>MIME</em></span> specifies several methods that allow email messages to contain multimedia content, binary files, and text files using non-ASCII character sets, all while still adhering to the RFC 822 message format. MIME also further expands email's flexibility by allowing multiple files or pieces of content to be sent in a single message.</p></div></div><div class="sect2" title="MIME Standards"><div class="titlepage"><div><div><h2 class="title"><a id="mime_standards"/>MIME Standards</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2686"/>MIME was first described in a set of two standards, RFC 1341 and RFC 1342, published in June 1992. These were updated by RFCs 1521 and 1522 in September 1993. In March 1994, a supplemental standard was published, RFC 1590, which specified the procedure for defining new MIME media types.</p><p>Work continued on MIME through the mid-1990s, and in November 1996, the standards were revised again. This time, the documents were completely restructured to improve the readability of the information and published as a set of five individual standards. These standards are shown in <a class="xref" href="ch76s04.html#mime_standards-id001" title="Table 76-2. MIME Standards">Table 76-2</a>.</p><p>Since the time that these five primary MIME standards were released, numerous additional RFCs have been published that have defined various extensions to MIME itself, including additional MIME header types and new media types. Notable examples are RFCs 2183 and 2557, which define the MIME Content-Disposition and Content-Location headers, respectively. Some other MIME capabilities are actually defined as part of other technologies that use MIME; for example, the first HTTP standard, RFC 1945 defines the Content-Length header. Other RFCs define new media types and subtypes (too many to list here).</p><div class="table"><a id="mime_standards-id001"/><p class="title">Table 76-2. MIME Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME Standards"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2045</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes the fundamental concepts behind MIME and the structure of MIME messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2046</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</p></td><td style="border-bottom: 0.5pt solid ; "><p>Explains the concept of MIME media types and subtypes and describes some of the kinds of media whose encoding is defined in the MIME <a class="indexterm" id="idx-CHP-76-2687"/>standards.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2047</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes how RFC 822 headers can be modified to carry non-ASCII text.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2048</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures</p></td><td style="border-bottom: 0.5pt solid ; "><p>Discusses how organizations can register additional media types for use with MIME.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>2049</p></td><td style="border-right: 0.5pt solid ; "><p>Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</p></td><td style=""><p>Provides additional implementation information and examples of how MIME can be used.</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="MIME Basic Structures and Headers"><div class="titlepage"><div><div><h1 class="title"><a id="mime_basic_structures_and_headers"/>MIME Basic Structures and Headers</h1></div></div></div><p>The creators of the MIME standard had a difficult challenge on their hands: how to bring flexibility in the types of data contained in email messages, when RFC 822 said that messages could contain only ASCII text. To accomplish this, MIME creators had to exploit the areas of flexibility that had already been put into the existing RFC 822.</p><p>Two such opportunities were available: The first was the fact that RFC 822 message bodies are allowed to contain any type of ASCII text, as long as lines don't exceed 998 text characters and each line ends with a CRLF control code combination. Even though the creators of RFC 822 naturally assumed this ASCII text would be human-readable, there was nothing stopping it from being machine-readable code. The second opportunity was the facility built into RFC 822 (and the protocols that use it, such as SMTP) that allowed custom user-defined header fields to be added to any email message.</p><p>The nonspecific nature of RFC 822 message bodies forms the basis for how MIME itself works. An email client that supports the MIME standard uses special encoding algorithms that transform non-ASCII information into ASCII form. It then places this set of encoded ASCII characters into the body of the message, as if it had been typed by a user, using one of two special structures.</p><p>The ability to add new headers to RFC 822 is used to communicate information about the use of MIME from the sender to the recipient. The devices transporting a MIME message don't care that MIME was used, because they don't pay attention to the contents of the message body. However, when the message reaches its destination, the recipient's email client program must have some way of knowing that MIME was used and must also be told how the information in the message was encoded. Otherwise, it might just present the encoded non-ASCII data to the user as ASCII text (which would look like random gibberish).</p><div class="sect2" title="Basic Structures"><div class="titlepage"><div><div><h2 class="title"><a id="basic_structures"/>Basic Structures</h2></div></div></div><p>The exact method by which data is encoded in the message body and <a class="indexterm" id="idx-CHP-76-2688"/>MIME headers are included depends on the overall structure of the <a class="indexterm" id="idx-CHP-76-2689"/>MIME message. Two <a class="indexterm" id="idx-CHP-76-2690"/>basic structure types are described, based on the kind of media the message carries:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2691"/>Simple Structure (<a class="indexterm" id="idx-CHP-76-2692"/>Discrete Media)</strong></span> MIME messages carrying a single <a class="indexterm" id="idx-CHP-76-2693"/>discrete media type, such as a text message or a graphical image, use a simple structure. Only one encoding of information is present in the body of the message.</p><p><span class="strong"><strong>Complex Structure (Composite Media)</strong></span> Some MIME messages carry a composite media type, which allows multiple different media to be contained in a single message, such as a text message and a graphical image, or which allows the email to encapsulate another email message in its entirety. Many of these messages use a more complex structure, where the body of the message contains several MIME body parts.</p></div><div class="sect2" title="MIME Entities"><div class="titlepage"><div><div><h2 class="title"><a id="mime_entities"/>MIME Entities</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2694"/>Collectively, both whole MIME messages and individual body parts are called <span class="emphasis"><em>MIME entities</em></span>. Each set of MIME headers provides information about either type of MIME entity: a MIME message as a whole or a body part in a composite message. When a MIME message is received, the recipient first examines the headers in the message as a whole (the RFC 822 headers) to determine the overall message type. This then indicates whether the message uses a simple or complex structure. If the latter is used, the body of the message is parsed and each individual body part is individually interpreted, including its individualized headers. The section "MIME Composite Media Types," later in this chapter, provides more details on how these body parts are formatted.</p></div><div class="sect2" title="Primary MIME Headers"><div class="titlepage"><div><div><h2 class="title"><a id="primary_mime_headers"/>Primary MIME Headers</h2></div></div></div><p>The first of the five main MIME standards, RFC 2045, describes a set of five primary MIME headers that communicate basic information about the content of each MIME entity (message or body part).</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2695"/>MIME-Version</strong></span> Each MIME message is required to have a MIME-Version header, which serves two purposes. First, it identifies the email message as being MIME-encoded. Second, even though only one version of MIME has been defined so far, having a version number header provides future proofing in case a new version is created later that may have some incompatibilities with the present one. Currently, all MIME messages use version 1.0. This is the only MIME header that applies to an entire message; it is not used to label individual MIME body parts. This is easy to remember, as it is the only header whose name does not begin with Content-.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2696"/>Content-Type</strong></span> Describes the nature of the data that is encoded in the MIME entity. This header specifies a content type and a content subtype, which are separated by a slash character. It may optionally also contain certain parameters that convey additional information about the type and subtype. In a message body, this header tells the recipient of the email message what sort of media it contains and whether the body uses a simple or complex structure. In a body part, it describes the media type the body part contains. For example, a message containing an HTML document might have a Content-Type header of <code class="literal">text/html</code>, where a message containing a JPEG graphical file might be specified as image/jpeg. For a composite MIME type, the Content-Type header of the whole message will contain something like <code class="literal">multipart/mixed</code> or <code class="literal">multipart/alternative</code>, and each body part will contain individual Content-Type headers such as <code class="literal">text/html</code> or <code class="literal">image/jpeg</code>. These are all discussed in detail in the next two sections. This header is optional. When not present, the default of a regular US-ASCII text message is assumed (the media type of regular RFC 822 messages).</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2697"/>Content-Transfer-Encoding</strong></span> For a message using simple structure, specifies the method used to encode the data in the message body; for a composite message, identifies the encoding method for each MIME body part. For data that is already in ASCII form, no special encoding is needed, but other types of data must be converted to ASCII for transmission. This header tells the recipient how to decode the data back into its normal representation. (MIME encoding methods are described later in this chapter.) This header is optional; the default value, if it is not present, is 7-bit encoding, which again is the encoding of regular ASCII.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2698"/>Content-ID</strong></span> Allows the MIME content to be assigned a specific identification code. This header is analogous to the RFC 822 Message-ID header field but is specific to the MIME content itself. It is optional and is most often used for body parts in multipart MIME messages.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2699"/>Content-Description</strong></span> This optional header allows an arbitrary additional text description to be associated with the MIME entity. In a multipart message, each body part might be given a description header to make clear to the recipient what the parts represent.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-446"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> MIME provides flexibility in the information that can be carried in email messages, by encoding non-ASCII data in ASCII form, and by adding special headers that describe this data and how it is to be interpreted. The most important MIME headers are <span class="emphasis"><em>Content-Type</em></span>, which describes what sort of data is in the message, and <a class="indexterm" id="idx-CHP-76-2700"/><span class="emphasis"><em>Content-Transfer-Encoding</em></span>, which specifies how the data is encoded. MIME supports two basic overall formats: <span class="emphasis"><em>simple structure</em></span>, in which a single type of <span class="emphasis"><em>discrete media</em></span> is encoded in a message, and <span class="emphasis"><em>complex structure</em></span>, which encodes a <span class="emphasis"><em>composite media</em></span> type that can carry multiple kinds of information.</p></div></div><div class="sect2" title="Additional MIME Headers"><div class="titlepage"><div><div><h2 class="title"><a id="additional_mime_headers"/>Additional MIME Headers</h2></div></div></div><p>In addition to the five basic headers, the MIME standard allows additional headers to be defined. The only restriction is that they all must start with the word <span class="emphasis"><em>Content</em></span>-, which clearly labels them as describing content of a MIME entity (message or body part). Both the sender and recipient must support a custom header for it to be useful.</p><p>Several new <a class="indexterm" id="idx-CHP-76-2701"/>MIME headers have in fact been created and documented in various Internet RFCs. Some are actually designed not specifically for use by email messages, but for use by other protocols that make use of MIME technology, such as HTTP. Three are notable:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2702"/>Content-Disposition</strong></span> In multipart MIME messages, this header may be given to MIME body parts to control how information is presented to the user. The two most common values are <span class="emphasis"><em>inline</em></span>, which says the content is intended to be displayed automatically along with other body parts, and <span class="emphasis"><em>attachment</em></span>, which indicates that the content is separate from the main document. This header is defined in RFC 2183.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2703"/>Content-Location</strong></span> Allows the location of a MIME body part to be identified using a Uniform Resource Locator (URL). This is sometimes used when encoding HTML and other <a class="indexterm" id="idx-CHP-76-2704"/>multimedia-enabled document formats into email using MIME multipart messages. It is defined in RFC 2557.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-76-2705"/>Content-Length</strong></span> Specifies the length of a MIME entity in bytes. This header is not commonly used in email applications of MIME but is an important header in HTTP. It is described in the HTTP standards, first appearing in RFC 1945.</p></div></div>
<div class="sect1" title="MIME Content-Type Header and Discrete Media"><div class="titlepage"><div><div><h1 class="title"><a id="mime_content-type_header_and_discrete_me"/>MIME Content-Type Header and Discrete Media</h1></div></div></div><p><a class="indexterm" id="idx-CHP-76-2706"/><a class="indexterm" id="idx-CHP-76-2707"/>MIME uses special techniques to encode various kinds of information into ASCII text form, such as graphical images, sound files, video clips, application programs, compressed data files, and many others. We commonly refer to these as different types of <span class="emphasis"><em>media</em></span>, and MIME uses the same term to describe them.</p><p>Since MIME supports so many kinds of media, it is necessary that each message contain information that describes what it contains to permit accurate decoding of message contents. This is the function of the important MIME Content-Type header.</p><div class="sect2" title="Content-Type Header Syntax"><div class="titlepage"><div><div><h2 class="title"><a id="content-type_header_syntax"/>Content-Type Header Syntax</h2></div></div></div><p>The syntax of the Content-Type header is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="emphasis"><em>Content-Type: &lt;type&gt;/&lt;subtype&gt; [; parameter1 ; parameter2 .. ; parameterN ]</em></span></td></tr></table><p>The purpose of these different elements is to describe the media in the MIME entity in a way that proceeds from the general to the specific. The first element, <span class="emphasis"><em>&lt;type&gt;</em></span>, is called the <span class="emphasis"><em>top-level media type</em></span> and describes the overall form of the data. For example, it indicates whether the MIME entity contains text, an image, audio, and so forth. The second element, <span class="emphasis"><em>&lt;subtype&gt;</em></span>, provides specific information about the form or format of the data. For example, a JPEG image and a GIF image are both images, but they are in a different format. Both <span class="emphasis"><em>&lt;type&gt;</em></span> and <span class="emphasis"><em>&lt;subtype&gt;</em></span> are mandatory in the Content-Type header.</p><p>Following these elements may appear one or more <span class="emphasis"><em>parameters</em></span>, which are usually optional but may be required for some media types. These provide still more details about the nature of the data, when it is required. Each parameter is preceded by a semicolon and is expressed as an attribute/value pair, separated by an equal (=) sign, like this: <span class="emphasis"><em>; attribute=value</em></span>.</p><p>One example of how parameters may be used is in specifying the character set in a text message. The representation of regular RFC 822 ASCII text is as follows:</p><a id="I_programlisting3_d1e82067"/><pre class="programlisting">Content-type: text/plain; charset="us-ascii"</pre><p>The top-level media type is <code class="literal">text</code>, and the subtype is <code class="literal">plain</code>, so this indicates a plain-text message. The parameter <code class="literal">charset</code> specifies that the message uses the US-ASCII character set. Another common use for parameters is to specify the name of an attached file, like this:</p><a id="I_programlisting3_d1e82080"/><pre class="programlisting">Content-type: image/jpeg; name="ryanpicture.jpg"</pre></div><div class="sect2" title="Discrete Media Types and Subtypes"><div class="titlepage"><div><div><h2 class="title"><a id="discrete_media_types_and_subtypes"/>Discrete Media Types and Subtypes</h2></div></div></div><p>As I mentioned earlier, MIME supports two basic structures: simple and complex. A simple message carries only one media type, such as a piece of text, a picture, or an executable file. These are called <span class="emphasis"><em>discrete media types</em></span> in MIME. A complex message carries a <span class="emphasis"><em>composite media type</em></span>, which may incorporate multiple body parts. Each body part in turn carries data corresponding to one of the discrete media types. The top-level media type indicates whether the whole message carries a discrete media type or a composite type.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-447"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The MIME <span class="emphasis"><em>Content-Type</em></span> header specifies what sort of data is encoded in a MIME message. The header indicates the general form of the message's content through a <span class="emphasis"><em>top-level media type</em></span>, and the more specific nature of the data through the specification of a <span class="emphasis"><em>subtype</em></span>. It may also contain optional <span class="emphasis"><em>parameters</em></span> that provide still more information about the content.</p></div><p>The RFC 2046 standard (part two of the set of five standards that describes MIME) defines five discrete top-level media types: <code class="literal">text</code>, <code class="literal">image</code>, <code class="literal">audio</code>, <code class="literal">video</code>, and <code class="literal">application</code>. They each represent one of the major classes of data commonly transmitted over TCP/IP. Each of these has one or more subtypes, and some also have parameters that are used to provide more information about them.</p><p>The creators of MIME recognized that the standard could not describe every media type and that new ones would be created in the future. RFC 2048 (part four of the MIME set) describes the process by which new media types, subtypes, and parameters can be described and registered with the Internet Assigned Numbers Authority (IANA).</p><p>Thus far, only one new top-level media type has been created; this is the <code class="literal">model</code> top-level type, defined for CAD modeling files and similar uses, as described in RFC 2077. However, many dozens of new subtypes have been created over the years, some specified in RFCs and others just registered directly with IANA. This includes many vendor-specific subtypes, which are usually identified by either the prefix <span class="emphasis"><em>x-</em></span> or <span class="emphasis"><em>vnd</em></span>. in the subtype name.</p><p>Literally hundreds of type/subtype combinations now exist, and I will not list them all. You can find a complete list of MIME media organized by top-level <a class="indexterm" id="idx-CHP-76-2708"/>media type on IANA's website: <a class="ulink" href="http://www.iana.org/assignments/media-types/index.html">http://www.iana.org/assignments/media-types/index.html</a>.</p><p>Here, I will briefly describe the six MIME discrete top-level <a class="indexterm" id="idx-CHP-76-2709"/>media types. For each, I've provided a table showing some of the more commonly encountered MIME subtypes to give you an idea of what is out there.</p><div class="sect3" title="Text Media Type (text)"><div class="titlepage"><div><div><h3 class="title"><a id="text_media_type_text"/>Text Media Type (text)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-76-2710"/><a class="indexterm" id="idx-CHP-76-2711"/>The <a class="indexterm" id="idx-CHP-76-2712"/><code class="literal">text</code> media type is used for sending data that is primarily in <a class="indexterm" id="idx-CHP-76-2713"/>textual form. <a class="xref" href="ch76s06.html#mime_text_media_type_subtypes" title="Table 76-3. MIME text Media Type Subtypes">Table 76-3</a> describes shows the subtypes.</p><div class="table"><a id="mime_text_media_type_subtypes"/><p class="title">Table 76-3. MIME text Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME text Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">text/plain</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Plain text, used for regular messages such as those corresponding to the initial RFC 822 standard</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">text/enriched</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Text that includes formatting information or other enrichment that makes it no longer plain</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 1896</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">text/html</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A document expressed in HTML, commonly used for the World Wide Web</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2854</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">text/css</code></p></td><td style="border-right: 0.5pt solid ; "><p>Cascading style sheet information for the World Wide Web</p></td><td style=""><p>RFC 2318</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Image Media Type (image)"><div class="titlepage"><div><div><h3 class="title"><a id="image_media_type_image"/>Image Media Type (image)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-76-2714"/>The <code class="literal">image</code> <a class="indexterm" id="idx-CHP-76-2715"/>media type indicates graphical image files, such as pictures. The subtype normally indicates the specific format to allow the recipient to decode and present the file properly. Some of the more common subtypes are shown in <a class="xref" href="ch76s06.html#mime_image_media_type_subtypes" title="Table 76-4. MIME image Media Type Subtypes">Table 76-4</a>.</p><div class="table"><a id="mime_image_media_type_subtypes"/><p class="title">Table 76-4. MIME image Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME image Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-76-2716"/>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">image/jpeg</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>An image in JPEG format</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">image/gif</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Graphical Interchange Format (GIF) image</p></td><td style="border-bottom: 0.5pt solid ; "><p>IANA says RFC 2046, but it's not there.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">image/tiff</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Tagged Image File Format (TIFF) image</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2302</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>
<a id="I_programlisting3_d1e82326"/></p><pre class="programlisting">image/vnd.dwg,
image/vnd.dxf,
image/vnd.svf</pre></td><td style="border-right: 0.5pt solid ; "><p>Vector images used in AutoCAD</p></td><td style=""><p>Registration with IANA</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Audio Media Type (audio)"><div class="titlepage"><div><div><h3 class="title"><a id="audio_media_type_audio"/>Audio Media Type (audio)</h3></div></div></div><p>The <code class="literal">audio</code> media type is used for sending audio information. The subtype normally indicates the specific format. <a class="xref" href="ch76s06.html#mime_audio_media_type_subtypes" title="Table 76-5. MIME audio Media Type Subtypes">Table 76-5</a> shows a couple of common values.</p><div class="table"><a id="mime_audio_media_type_subtypes"/><p class="title">Table 76-5. MIME audio Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME audio Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">audio/basic</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A basic audio type defined in the main MIME standards that describes single-channel audio encoded using 8-bit ISDN mu-law pulse code modulation at 8,000 Hz</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">audio/mpeg</code></p></td><td style="border-right: 0.5pt solid ; "><p>MPEG standard audio (including the popular MP3 file format)</p></td><td style=""><p>RFC 3003</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Video Media Type (video)"><div class="titlepage"><div><div><h3 class="title"><a id="video_media_type_video"/>Video Media Type (video)</h3></div></div></div><p>The <code class="literal">video</code> media type is used for sending video information. Again, the subtype normally indicates the specific format, as shown in <a class="xref" href="ch76s06.html#mime_video_media_type_subtypes" title="Table 76-6. MIME video Media Type Subtypes">Table 76-6</a>.</p><div class="table"><a id="mime_video_media_type_subtypes"/><p class="title">Table 76-6. MIME video Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME video Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">video/mpeg</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Video encoded to the MPEG digital video standard</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">video/dv</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Digital video corresponding to several popular standards including SD-VCR, HD-VCR, and DVB, as used by various types of video equipment</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 3189</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">video/quicktime</code></p></td><td style="border-right: 0.5pt solid ; "><p>Apple's QuickTime movie format</p></td><td style=""><p>Registration with IANA</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Model Media Type (model)"><div class="titlepage"><div><div><h3 class="title"><a id="model_media_type_model"/>Model Media Type (model)</h3></div></div></div><p>The <code class="literal">model</code> media type describes a model representation, such as a two-dimensional or three-dimension physical model. Its subtypes are described in <a class="xref" href="ch76s06.html#mime_model_media_type_subtypes" title="Table 76-7. MIME model Media Type Subtypes">Table 76-7</a>.</p><div class="table"><a id="mime_model_media_type_subtypes"/><p class="title">Table 76-7. MIME model Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME model Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">model/mesh</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A mesh, as used in modeling</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2077</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">model/vrml</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Virtual Reality Modeling Language (VRML) model</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2077</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">model/iges</code></p></td><td style="border-right: 0.5pt solid ; "><p>A model file corresponding to the Initial Graphics Exchange Specification (IGES)</p></td><td style=""><p>Registration with IANA</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Application Media Type (application)"><div class="titlepage"><div><div><h3 class="title"><a id="application_media_type_application"/>Application Media Type (application)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-76-2717"/>The <code class="literal">application</code> media type is a catchall for any kind of data that doesn't fit into one of the preceding categories or that is inherently application-specific. The subtype describes the data by indicating the kind of application that uses it. This can be used to guide the recipient's email program in choosing an appropriate application program to display it, just as a file extension in Windows tells the operating system how to open different kinds of files.</p><p>For example, if you have Microsoft Excel installed on your PC, clicking a filename ending with .XLS will launch Excel automatically. Similarly, an Excel spreadsheet will normally be sent using MIME with a media type of <code class="literal">application/vnd.ms-excel</code>. This tells the recipient's email program to launch Excel to read this file.<code class="literal"/></p><p>Since so many applications are out there, more than 100 different subtypes exist within this top-level type. <a class="xref" href="ch76s06.html#mime_application_media_type_subtypes" title="Table 76-8. MIME application Media Type Subtypes">Table 76-8</a> contains a few representative samples.</p><div class="table"><a id="mime_application_media_type_subtypes"/><p class="title">Table 76-8. MIME application Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME application Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/octet-stream</code><a class="indexterm" id="idx-CHP-76-2718"/></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>An arbitrary set of binary data octets (see the discussion following this table for more details)</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/postscript</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A PostScript file, used for printing and for generating Adobe Acrobat (PDF) files</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/applefile</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Resource file information for representing Apple Macintosh files</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/msword</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Microsoft Word document (note that this does not have the vnd prefix like most other Microsoft file types)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/pdf</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Portable Document Format (PDF) file, as created by Adobe Acrobat</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/vnd.framemaker</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>An Adobe FrameMaker file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/vnd.lotus-1-2-3</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Lotus 1-2-3 file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/vnd.lotus-notes</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Lotus Notes file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/vnd.ms-excel</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Microsoft Excel spreadsheet file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/vnd.ms-powerpoint</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Microsoft PowerPoint presentation file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">application/vnd.ms-project</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Microsoft Project file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Registration with IANA</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">application/zip</code></p></td><td style="border-right: 0.5pt solid ; "><p>A compressed archive file containing one or more other files, using the ZIP/PKZIP compression format</p></td><td style=""><p>Registration with IANA</p></td></tr></tbody></table></div></div><p>Of these application subtypes, a special one is worth further mention: the <a class="indexterm" id="idx-CHP-76-2719"/><code class="literal">application/octet-stream</code> subtype. This is the catchall within the catchall of the application type, which just means the file is a sequence of arbitrary binary data. It is usually used when the sender is unsure of what form the data takes or cannot identify it as belonging to a particular application. When this type is used, the recipient will usually be prompted to save the data to a file. He must then figure out what application to use to read it.</p><p>The <code class="literal">application/octet-stream</code> MIME type/subtype may even be used for images, audio, or video in unknown formats. If you try to send a multimedia document that your sending program does not understand, it will generally encode it as <code class="literal">application/octet-stream</code> for transmission. This is your email program's way of saying to the recipient, "I am sending you this file as-is; you figure out what to do with it."</p><p>This <code class="literal">application/octet-stream</code> type is also often used for transmitting executable files (programs) especially on Windows systems. Unfortunately, while convenient, this can be a serious security hazard. In recent years, the Internet has been subject to a steady stream of viruses and worms that spread by sending themselves to other users through executable file attachments in email. This makes opening and running any unknown <code class="literal">application/octet-stream</code> attachment potentially dangerous.</p></div></div></div>
<div class="sect1" title="MIME Composite Media Types: Multipart and Encapsulated Message Structures"><div class="titlepage"><div><div><h1 class="title"><a id="mime_composite_media_types_multipart_and"/>MIME Composite Media Types: Multipart and Encapsulated Message Structures</h1></div></div></div><p>MIME discrete media types allow MIME to represent hundreds of different kinds of data in email messages. This alone would make MIME an incredibly useful technology, but the MIME standard goes one step further by defining <span class="emphasis"><em>composite</em></span> media types. These allow MIME to perform even more spectacular feats, such as sending many types of data at once or encapsulating other messages or information into email.</p><p>The use of a MIME composite media type is indicated via the Content-Type header of an RFC 822 message. Instead of one of the six discrete media types (<code class="literal">text</code>, <code class="literal">image</code>, <code class="literal">audio</code>, <code class="literal">video</code>, <code class="literal">model</code>, or <code class="literal">application</code>), one of these two <a class="indexterm" id="idx-CHP-76-2720"/>composite media types is used: <a class="indexterm" id="idx-CHP-76-2721"/><code class="literal">multipart</code>, which allows one or more sets of data to be sent in a single MIME message, and <code class="literal">message</code>, which allows a message to encapsulate another message.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-448"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Two MIME <a class="indexterm" id="idx-CHP-76-2722"/>composite media types exist: <code class="literal">message</code>, which allows one message to encapsulate another, and <a class="indexterm" id="idx-CHP-76-2723"/><code class="literal">multipart</code>, which allows multiple individual media types to be encoded into a single email message.</p></div><div class="sect2" title="MIME Multipart Message Type"><div class="titlepage"><div><div><h2 class="title"><a id="mime_multipart_message_type"/>MIME Multipart Message Type</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2724"/>The <code class="literal">multipart</code> media type is the more common of the two types, and for good reason: It is an <span class="emphasis"><em>incredibly</em></span> powerful mechanism. It allows one message to contain many different kinds of information that can be used in different ways. Each piece of data is encoded separately as a MIME body part, and the parts are combined into a single email message. How these parts are used depends on the semantics of the message, indicated by the MIME subtype. RFC 2046 describes several of these, and a few new ones have also been defined by the IANA registration scheme described earlier.</p><div class="sect3" title="MIME Multipart Message Subtypes"><div class="titlepage"><div><div><h3 class="title"><a id="mime_multipart_message_subtypes"/>MIME Multipart Message Subtypes</h3></div></div></div><p><a class="indexterm" id="idx-CHP-76-2725"/>Table 78-9 shows the most common multipart media subtypes and how they are used. The first four are defined in RFC 2046.</p><div class="table"><a id="common_mime_multipart_media_type_subtype"/><p class="title">Table 76-9. Common MIME multipart Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common MIME multipart Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-76-2726"/>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">multipart/mixed</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Indicates that the body parts are not really related, but they have been bundled for transport in a single message for convenience. For example, this might be used by someone to send an office memo along with a vacation snapshot just for fun. This subtype is also sometimes used when the parts are related but the relationship is communicated to the recipient in some other way (such as via a description in a distinct body part).</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-76-2727"/><code class="literal">multipart/alternative</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Specifies that the body parts are alternative representations of the same information. The recipient decodes the parts and chooses the one that is best suited to her needs. A common use of this is in sending Hypertext Markup Language (HTML)-encoded email. Some email clients can't display HTML, so it is courteous to send a <span class="emphasis"><em>multipart/alternative</em></span> message containing the message in both HTML and plain text forms. The alternatives should be placed in the message in increasing order of preference, meaning that the preferred format goes last. In the case of a document that includes plain text and rich text alternatives—such as the preceding example with plain text and HTML versions of a document—the plainest format should go first and the fanciest last.</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">multipart/parallel</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Tells the recipient that the body parts should all be displayed at the same time (in parallel). For example, someone sends an audio clip along with explanatory text to be displayed alongside it as it plays.</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">multipart/digest</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows a message to carry a digest, such as a collection of other email messages.</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">multipart/related</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Indicates specifically that the body parts are related to each other. Special parameters are used to provide more information on how they are to be interpreted.</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2387</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">multipart/encrypted</code></p></td><td style="border-right: 0.5pt solid ; "><p>Used for encrypted data. The first body part contains information on how the data is to be decrypted, and the second contains the data itself.</p></td><td style=""><p>RFC 1847</p></td></tr></tbody></table></div></div></div></div><div class="sect2" title="Multipart Message Encoding"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_message_encoding"/>Multipart Message Encoding</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2728"/>You can see just from the different subtypes shown in Table 78-9 how much flexibility the multipart type provides to MIME, and there are other subtypes. In all cases, the same syntax is used to encode the constituent body parts into a single message. The basic process is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Each individual piece of data is processed as if it were to be transmitted as the body of a discrete media type MIME message. This includes the specification of appropriate headers, such as Content-Type, Content-ID, and Content-Transfer-Encoding, as needed.</p></li><li class="listitem"><p>A special <span class="emphasis"><em>boundary delimiter</em></span> is chosen to separate the body parts. It must be selected so that it will not appear in any of the body parts; a random string is sometimes used. It is prepended with two dashes (—) when placed in the message to reduce the chance of it being mistaken for data.</p></li><li class="listitem"><p>The multipart message is assembled. It consists of a <span class="emphasis"><em>preamble</em></span> text area, then a boundary line, followed by the first body part. Each subsequent body part is separated from the previous one with another boundary line. After the last body part, another boundary line appears, followed by an <span class="emphasis"><em>epilogue</em></span> text area.</p></li><li class="listitem"><p>The special parameter <span class="emphasis"><em>boundary</em></span> is included in the Content-Type header of the message as a whole, to tell the recipient what pattern separates the body parts.</p></li></ol></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-449"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> MIME <a class="indexterm" id="idx-CHP-76-2729"/>multipart messages are formed by first processing each individual data component to create a MIME <span class="emphasis"><em>body part</em></span>. Each can have a distinct encoding method and set of headers, as if it were a separate MIME message. These body parts are then combined into a single multipart message and separated with a <span class="emphasis"><em>boundary delimiter</em></span>. The identity of the delimiter is inserted into the <span class="emphasis"><em>boundary</em></span> parameter of the <span class="emphasis"><em>Content-Type</em></span> header, so the recipient can easily separate the individual body parts upon receipt of the message.</p></div><p>These rules may seem rather complicated, but once you've seen a couple of multipart messages, the structure will make sense. To help clarify multipart message encoding, <a class="xref" href="ch76s07.html#mime_multipart_message_structure_a_mime_" title="Figure 76-1. MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called &quot;Delimiter.&quot; This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively.">Figure 76-1</a> shows graphically the overall structure of a multipart MIME message.</p><p><a class="xref" href="ch76s07.html#example_of_a_mime_multipart_message" title="Example 76-1. Example of a MIME multipart message">Example 76-1</a> contains a specific example of a multipart message (with portions abbreviated to keep the length down), so you can see what one looks like in text form. (If you want to see more, you probably have several in your own email inbox right now!)</p><div class="example"><a id="example_of_a_mime_multipart_message"/><p class="title">Example 76-1. Example of a MIME multipart message</p><div class="example-contents"><pre class="programlisting">From: Joe Sender &lt;joe@someplace.org&gt;
To: Jane Receiver &lt;jane@somewhereelse.com&gt;
Date: Sun, 1 Jun 2003 13:28:19 —0800
Subject: Photo and discussion
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="exampledelimtext123"

This is a multipart message in MIME format

-exampledelimtext123
Content-Type: text/plain

Jane, here is the photo you wanted from me for the new client.
Here are some notes on how it was processed.
(Blah blah blah...)
Talk to you soon,
Joe.

-exampledelimtext123

Content-Type: image/jpeg; name="clientphoto.jpg"
Content-Transfer-Encoding: base64

SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs
...
zv/wAARCADIARoDASIAAhEBAxEB/8QAHAAAAQUBA

-exampledelimtext123

(Epilogue)</pre></div></div><div class="figure"><a id="mime_multipart_message_structure_a_mime_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e82988"/><img alt="MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called &quot;Delimiter.&quot; This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively." src="httpatomoreillycomsourcenostarchimages288289.png"/></div></div><p class="title">Figure 76-1. MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called "Delimiter." This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively.</p></div><p>In this example, Joe is sending Jane a <a class="indexterm" id="idx-CHP-76-2730"/>multipart message containing a JPEG photograph and some explanatory text. The main header of the message specifies the <a class="indexterm" id="idx-CHP-76-2731"/><code class="literal">multipart/mixed</code> type and a boundary string of <code class="literal">exampledelimtext123</code>. The message begins with the preamble, which is ignored by the recipient email client but can be seen by the human reader. It is common to put a string here such as the one given in this example. That way, if a person using a client that does not support MIME receives the message, the recipient will know what it is.<a class="indexterm" id="I_indexterm3_d1e83014"/></p><p>The first delimiter string is then placed in the message, followed by the first body part, the text Joe is sending Jane. This is preceded by whatever headers are needed by the body part, in this case <code class="literal">Content-Type: text/plain</code>. (Note, however, that this is the default in MIME, so it could be omitted here.) After the text message is another delimiter, and then the encoded JPEG photo in the second body part, with its own headers. Finally, there is one more delimiter, and then a space for the epilogue. This is ignored if present and is often not used at all.</p><p>It is possible to send a multipart <a class="indexterm" id="idx-CHP-76-2732"/>message that has only a single body part. This is sometimes done to take advantage of the preamble area to provide information about how to decode a nontext <a class="indexterm" id="idx-CHP-76-2733"/>media type. Of course, this can also be done by including such text decoding instructions as a body part.</p></div><div class="sect2" title="MIME Encapsulated Message Type"><div class="titlepage"><div><div><h2 class="title"><a id="mime_encapsulated_message_type"/>MIME Encapsulated Message Type</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2734"/>The other composite media type is the <code class="literal">message</code> type, which is devoted to the special purpose of encapsulating existing email messages within the body of a new message, or encapsulating other types of messages. This may be another email message previously sent or a message of some other kind. This media type also provides flexibility for sending partial messages and other special types of communication. <a class="xref" href="ch76s07.html#common_mime_message_media_type_subtypes" title="Table 76-10. Common MIME message Media Type Subtypes">Table 76-10</a> shows the three subtypes defined in RFC 2046.</p><div class="table"><a id="common_mime_message_media_type_subtypes"/><p class="title">Table 76-10. Common MIME message Media Type Subtypes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common MIME message Media Type Subtypes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type/Subtype</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>Defining Source</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">message/rfc822</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Indicates that the body contains an <a class="indexterm" id="idx-CHP-76-2735"/>encapsulated email, itself formatted according to the RFC 822 standard. Note that this doesn't necessarily mean it is a plain text email message; it could be a MIME message (though encapsulating MIME within MIME must be done carefully).</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">message/partial</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows the fragmentation of larger messages into pieces that can later be reassembled.</p></td><td style="border-bottom: 0.5pt solid ; "><p>RFC 2046</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">message/external-body</code></p></td><td style="border-right: 0.5pt solid ; "><p>Indicates that the body of the message is not actually contained in the message itself; instead, a reference is provided to where the body is located. Sufficient information to locate the real message body must be provided.</p></td><td style=""><p>RFC 2046</p></td></tr></tbody></table></div></div></div><div class="sect2" title="MIME Content-Transfer-Encoding Header and Encoding Methods"><div class="titlepage"><div><div><h2 class="title"><a id="mime_content-transfer-encoding_header_an"/>MIME Content-Transfer-Encoding Header and Encoding Methods</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2736"/><a class="indexterm" id="idx-CHP-76-2737"/>One of the main reasons why MIME was created was the significant restrictions that the RFC 822 standard places on how data in email messages must be formatted. To follow the rules, messages must be encoded in US-ASCII, a 7-bit data representation. This means that even though each byte can theoretically have any of 256 values, in ASCII only 128 values are valid. Furthermore, lines can be no longer than 1,000 characters including the carriage return and line feed (CRLF) characters at the end, and those two characters cannot appear elsewhere.</p><p>For some types of data, such as text files, this is no big deal; but for others it is a serious problem. This is especially the case with binary data. If you look at the data in a video clip, MP3 file, or executable program, it will appear to be random gibberish. In fact, such data is not random; it is represented using specific rules, but the data is expressed in raw binary form, where any 8-bit byte can contain any value from 0 to 255, which is why it looks like junk to humans. More important, this means that this data does not follow the rules for RFC 822 files and cannot be sent directly in this form.</p><p>To send non-ASCII data in MIME, it must be encoded. The Content-Transfer-Encoding header is used to specify how a MIME message or body part has been encoded, so that it can be decoded by its recipient. Four types of encoding are defined: <code class="literal">7bit, 8bit</code>/<a class="indexterm" id="idx-CHP-76-2738"/><code class="literal">binary, quoted-printable</code>, and <a class="indexterm" id="idx-CHP-76-2739"/><code class="literal">base64</code>. The quoted-printable and <a class="indexterm" id="idx-CHP-76-2740"/>base64 encodings are the most interesting ones, because they are what allow non-RFC-822 data to be sent using RFC 822.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-450"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> MIME supports four encoding methods: <code class="literal">7bit</code>, <code class="literal">8bit</code> (<code class="literal">binary</code>), <code class="literal">quoted-printable</code>, and <code class="literal">base64</code>. <code class="literal">7bit</code> encoding is standard ASCII and is used for text. <code class="literal">quoted-printable</code> encoding is for output that is mostly text but has some special characters that must be encoded. <code class="literal">base64</code> is used for arbitrary binary files. The 8-bit encoding method is defined in MIME but not used for RFC 822 messages.</p></div></div><div class="sect2" title="7-Bit and 8-Bit Encoding"><div class="titlepage"><div><div><h2 class="title"><a id="bit_and_8-bit_encoding"/>7-Bit and 8-Bit Encoding</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2741"/><code class="literal">7bit</code> encoding indicates that the message is already in ASCII form compatible with RFC 822. It is the default and is what is assumed if no Content-Transfer-Encoding header is present.</p><p>The <code class="literal">8bit</code> and <code class="literal">binary</code> values are synonymous. They mean the message has been encoded directly in 8-bit binary form. Yes, I did just say that this would violate the rules of RFC 822. These options appear to have been included to support future mechanisms for transporting binary data directly. RFC 1652 describes an SMTP extension that discusses this in part: "SMTP Service Extension for 8bit-MIMEtransport" (there is no space between <span class="emphasis"><em>MIME</em></span> and <span class="emphasis"><em>transport</em></span>). However, the standard clearly states that this still does not allow the transfer of raw binary data using SMTP and RFC 822.</p></div><div class="sect2" title="Quoted-Printable Encoding"><div class="titlepage"><div><div><h2 class="title"><a id="quoted-printable_encoding"/>Quoted-Printable Encoding</h2></div></div></div><p><a class="indexterm" id="idx-CHP-76-2742"/>Quotable-printable encoding is a special type that is used when most of the data is ASCII text, but it contains certain violations of the rules of RFC 822. These illegal sections are converted using special encoding rules so the data as a whole is consistent with RFC 822; only the problem bytes are encoded. The result is that RFC 822 compatibility is achieved while maintaining most of the data as regular text so it can still be easily understood by a human.</p><p>An example would be letters with tildes or accents, such as those used in French or Spanish. Another would be a text message formed using an editor that inserts carriage return characters in the middle of a line. Most of the message is still text. The <code class="literal">quoted-printable</code> encoding can be used here, with the carriage return characters represented as =0D (the hexadecimal value of the character prepended by an equal sign). RFC 2046 contains more details on how this is done.</p></div><div class="sect2" title="Base64 Encoding"><div class="titlepage"><div><div><h2 class="title"><a id="base64_encoding"/>Base64 Encoding</h2></div></div></div><p>In contrast, <code class="literal">base64</code> encoding is more often used for raw binary data that is not in human-readable form anyway, such as graphical image, audio, video, and application files. This encoding is used to allow arbitrary binary data to be represented in ASCII form. The data is then sent as ASCII and decoded back into binary form by the recipient. The idea behind this type of encoding is simple: The data that needs to be sent can have any value for each 8-bit byte, which is not allowed. So why not rearrange the bits so the data fits into the 7-bit ASCII limits of RFC 822?</p><p>This is done by processing the data to be sent three bytes at a time. There are 24 bits in each three-byte block, which are carved into four sets of 6 bits each. Each 6-bit group has a value from 0 to 63 and is represented by a single ASCII character, as presented in <a class="xref" href="ch76s07.html#mime_base_encoding_groups" title="Table 76-11. MIME base64 Encoding Groups">Table 76-11</a>.</p><div class="table"><a id="mime_base_encoding_groups"/><p class="title">Table 76-11. MIME base64 Encoding Groups</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="MIME base64 Encoding Groups"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-76-2743"/>6-Bit Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Encoding</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6-Bit Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Encoding</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6-Bit Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Encoding</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6-Bit Value</p></th><th style="border-bottom: 0.5pt solid ; "><p>Encoding</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Q</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>g</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>48</p></td><td style="border-bottom: 0.5pt solid ; "><p>w</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>B</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>33</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>h</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>49</p></td><td style="border-bottom: 0.5pt solid ; "><p>x</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>S</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>34</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>i</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>50</p></td><td style="border-bottom: 0.5pt solid ; "><p>y</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>19</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>T</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>35</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>j</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>51</p></td><td style="border-bottom: 0.5pt solid ; "><p>z</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>E</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>20</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>U</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>36</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>k</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>52</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>F</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>21</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>V</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>37</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>l</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>53</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>G</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>22</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>W</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>38</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>m</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>54</p></td><td style="border-bottom: 0.5pt solid ; "><p>2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>H</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>23</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>X</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>39</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>n</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>55</p></td><td style="border-bottom: 0.5pt solid ; "><p>3</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>I</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Y</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>40</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>o</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>56</p></td><td style="border-bottom: 0.5pt solid ; "><p>4</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>J</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>25</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>41</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>p</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>57</p></td><td style="border-bottom: 0.5pt solid ; "><p>5</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>K</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>26</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>42</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>q</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>58</p></td><td style="border-bottom: 0.5pt solid ; "><p>6</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>L</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>27</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>b</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>43</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>r</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>59</p></td><td style="border-bottom: 0.5pt solid ; "><p>7</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>28</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>c</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>44</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>s</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>60</p></td><td style="border-bottom: 0.5pt solid ; "><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>29</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>d</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>45</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>t</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>61</p></td><td style="border-bottom: 0.5pt solid ; "><p>9</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>O</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>e</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>46</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>u</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>62</p></td><td style="border-bottom: 0.5pt solid ; "><p>+</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; "><p>P</p></td><td style="border-right: 0.5pt solid ; "><p>31</p></td><td style="border-right: 0.5pt solid ; "><p>f</p></td><td style="border-right: 0.5pt solid ; "><p>47</p></td><td style="border-right: 0.5pt solid ; "><p>v</p></td><td style="border-right: 0.5pt solid ; "><p>63</p></td><td style=""><p>/</p></td></tr></tbody></table></div></div><p>For example, suppose the first three bytes of the data to be sent were the decimal values 212, 39, and 247. These cannot all be expressed in 7-bit ASCII. In binary form, they are expressed like so:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>11010100 00100111 11110111</td></tr></table><p>We can divide these into four 6-bit groups:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>110101 - 00 0010 - 0111 11 - 110111</td></tr></table><p>Which yields the four values 53, 2, 31, and 55. Thus, the values 214, 39, and 247 would be encoded as the three ASCII characters 1Cf3. The conceptual steps of this process are shown in <a class="xref" href="ch76s07.html#mime_base64_encoding_in_this_simplified_" title="Figure 76-2. MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent.">Figure 76-2</a>.</p><div class="note" title="Note"><h3 class="title"><a id="note-160"/>Note</h3><p><span class="emphasis"><em>The sequence of steps for the encoding are intended to help you understand the process. Computers inherently deal directly with bits and would not bother with converting to decimal before encoding the 6-bit groups into ASCII characters</em></span>.</p></div><div class="figure"><a id="mime_base64_encoding_in_this_simplified_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e83699"/><img alt="MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent." src="httpatomoreillycomsourcenostarchimages288291.png.jpg"/></div></div><p class="title">Figure 76-2. MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent.</p></div><p><a class="indexterm" id="idx-CHP-76-2744"/>This 3-to-4 encoding is done for all the data. The converted ASCII characters are then placed into the body of the entity instead of the raw binary data, 76 characters to a line. I showed how this is done in the second body part in the example in <a class="xref" href="ch76s07.html#example_of_a_mime_multipart_message" title="Example 76-1. Example of a MIME multipart message">Example 76-1</a> (except I didn't use 76 characters per line, to keep the line lengths short). One final character is involved in this scheme, the equal sign (=), which is used as a padding character when needed.</p><p>Since base64 characters are regular ASCII, they appear to SMTP like a regular text message. Of course, the data looks like gibberish to us, but that's not a problem since it will be converted back to its regular form and displayed to the recipient as an image, movie, audio, or whatever.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-451"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> MIME uses <span class="emphasis"><em>base64</em></span> encoding to transform arbitrary 8-bit files into a form that is acceptable for communication in email. Each set of three 8-bit bytes is divided into four 6-bit groups, and each 6-bit group is represented by an ASCII character. Since the data is ASCII, it conforms to the RFC 822 message format standard, even if it is not human-readable. The receiving device reverses the encoding, changing each four-character block back into three 8-bit bytes.</p></div><p>The main drawback of the base64 method is that it is about 33 percent less efficient than sending binary data directly, using a protocol like the File Transfer Protocol (FTP). The reason is that three 8-bit bytes of binary data are sent as four ASCII characters, but of course, each ASCII character is represented using 8 bits itself. So there is one-third more overhead when using base64. In most cases, this is not a big deal, but it can be significant if downloading very large email files over a slow Internet connection.</p><p>Note that RFC 2046 also defines two other encodings: <code class="literal">ietf-token</code> and <code class="literal">x-token</code>. These are included to allow new encoding types to be defined in the future.</p></div></div>
<div class="sect1" title="MIME Extension for non-ASCII Mail Message Headers"><div class="titlepage"><div><div><h1 class="title"><a id="mime_extension_for_non-ascii_mail_messag"/>MIME Extension for non-ASCII Mail Message Headers</h1></div></div></div><p>All of the MIME mechanisms discussed up to this point deal with ways of encoding different kinds of ASCII and <a class="indexterm" id="idx-CHP-76-2745"/>non-ASCII data into the <span class="emphasis"><em>body</em></span> of an RFC 822 message. In addition to these capabilities, MIME also includes a way in which non-ASCII data can be encoded into <span class="emphasis"><em>headers</em></span> of an RFC 822 message.</p><p>At this point, you might be wondering why anyone would want to do this. Sure, it makes sense to be able to use MIME to encode binary data such as an image into an email, but why do it in a header? Well, if you can't see the need <a class="indexterm" id="idx-CHP-76-2746"/>for this, chances are that you are a native English speaker. ASCII does a great job of representing English, but isn't so good with many other languages. With RFC 822, speakers of languages that use non-ASCII characters were unable to use descriptive headers fully, such as the Subject and Comments headers. Some could not even properly express their own names!</p><p>The solution to this problem is the subject of RFC 2047, the third of the five main MIME standards. It describes how to encode non-ASCII text into ASCII RFC 822 message headers. The idea is straightforward: As with message bodies, the non-ASCII text is replaced with ASCII, and information is provided to describe how this was done.</p><p>With this technique, the value of a regular header is replaced by a MIME <span class="emphasis"><em>encoded-word</em></span> that has the following syntax:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>=?<span class="emphasis"><em>&lt;charset&gt;</em></span>?<span class="emphasis"><em>&lt;encoding&gt;</em></span>?<span class="emphasis"><em>&lt;encoded-text&gt;</em></span>?=</td></tr></table><p>The strings <code class="literal">=?</code> and <code class="literal">?=</code> are used to <span class="emphasis"><em>bracket</em></span> the non-ASCII header, which flags it as a MIME encoded header to the recipient's email client. The other elements, separated by <code class="literal">?</code>, indicate how the non-ASCII text is encoded, as follows:</p><p><span class="strong"><strong>&lt;charset&gt;</strong></span> The character set used, such as <code class="literal">iso-8859-1</code>.</p><p><span class="strong"><strong>&lt;encoding&gt;</strong></span> Two different encoding types are defined, each represented by a single letter for brevity: <code class="literal">B</code> indicates base64 encoding, and <code class="literal">Q</code> indicates quoted-printable encoding (these encoding types are discussed in the previous section.</p><p><span class="strong"><strong>&lt;encoded-text&gt;</strong></span> The non-ASCII text that has been encoded as ASCII using the encoding type indicated.</p><p>As you can see, this method is analogous to how a non-ASCII message body or body part would be encoded, but the information about the encoding has been condensed so everything can fit in a single header line. The <span class="emphasis"><em>&lt;charset&gt;</em></span> parameter is somewhat analogous to the Content-Type header for a message body, but since headers can contain only text, it specifies what kind of text it is. The <span class="emphasis"><em>&lt;encoding&gt;</em></span> parameter is clearly equivalent to the Content-Transfer-Encoding header.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-452"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In addition to its many functions for encoding a variety of data in email message bodies, MIME provides a feature that allows non-ASCII information to be placed into email headers. This is done by encoding the data using either <span class="emphasis"><em>quoted-printable or base64</em></span> encoding, and then using a special format for the header value that specifies its encoding and character set. This technique is especially useful for email sent in languages that cannot be represented easily in standard ASCII, such as many Asian languages.</p></div><p>Here's an example of a non-ASCII header, using the GB2312 character set (for Chinese characters) and base64 encoding:</p><a id="I_programlisting3_d1e83834"/><pre class="programlisting">Subject: =?GB2312?B?u7bTrbLOvNPDwLn61bm74Q==?=</pre><p>I hope that doesn't say anything inappropriate; I took it from a piece of spam email I received once!</p></div>
<div class="chapter" title="Chapter&#xA0;77.&#xA0;TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_electronic_mail_delivery_protocol"/>Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e83844"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> I emphasized in my overall description of TCP/IP email that communication using email requires the interaction of various protocols and elements. One mistake that some people make is to equate the method used for delivering email with the entire system. This is, however, an understandable mistake—just as the postal service is only a part of the whole system of mailing a letter, it is nonetheless a very big part. Likewise, the delivery of email from sender to recipient is arguably the most important part of email as a whole. In modern TCP/IP, this task is the responsibility of the <span class="emphasis"><em>Simple Mail Transfer Protocol (SMTP)</em></span><a class="indexterm" id="idx-CHP-77-2747"/>.</p><p>In this chapter, I describe in detail the operation of SMTP. I begin with an overview and history of the protocol and a discussion of the standards that define it. I then examine the way that SMTP client/server communication and message transport work. I explain the way that SMTP servers establish connections and transaction sessions, and then the process by which mail is transferred from one server to another. I describe some of the special features implemented in SMTP and discuss SMTP security issues. I conclude with a reference summary of SMTP commands and replies.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-453"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>My discussion of SMTP assumes that you already have a basic understanding of the general concepts of TCP/IP email, as well as familiarity with TCP/IP email addressing and message formatting. These topics are discussed in Chapters <a class="xref" href="ch74.html" title="Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS">Chapter 74</a>, <a class="xref" href="ch75.html" title="Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING">Chapter 75</a>, and <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>, respectively</em></span><a class="indexterm" id="idx-CHP-77-2748"/>.</p></div><div class="sect1" title="SMTP Overview, History, and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="smtp_overview_history_and_standards"/>SMTP Overview, History, and Standards</h1></div></div></div><p><a class="indexterm" id="idx-CHP-77-2749"/><a class="indexterm" id="idx-CHP-77-2750"/>The overview and history of the TCP/IP email system in <a class="xref" href="ch74.html" title="Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS">Chapter 74</a> describes how TCP/IP evolved from its early beginnings to its current form. Since the mechanism used to deliver email is such a big part of the system as a whole, any overview of the system must of necessity discuss how delivery mechanisms have changed as well. In the case of TCP/IP, the delivery of mail evolved through many forms during the 1970s, as developers sought to find effective ways of communicating email messages between systems. Most of these efforts involved attempts to transmit mail using existing protocols; this makes sense, since it is easier to adapt a technology than design one from scratch.</p><div class="sect2" title="SMTP Standards"><div class="titlepage"><div><div><h2 class="title"><a id="smtp_standards"/>SMTP Standards</h2></div></div></div><p>One important achievement in the development of a mail system was the publishing of the <a class="indexterm" id="idx-CHP-77-2751"/><span class="emphasis"><em>Mail Transfer Protocol (MTP)</em></span>, which was first defined in RFC 772 in September 1980, and then updated in RFC 780 in May 1981. MTP describes a set of commands and procedures by which two devices can connect using TCP to exchange email messages. Its operation is described largely using elements borrowed from two early TCP/IP application protocols that were already in use at that time: Telnet and the File Transfer Protocol (FTP). The commands of MTP are actually based directly on those of FTP.</p><p>Although there was nothing inherently wrong with basing email delivery on FTP, defining it this way made MTP somewhat of a hack. It was also restricted to the capabilities defined by FTP, a general file transfer protocol, so it was not possible to include features in MTP that were specific to sending and receiving mail. Due to the importance of email, a specific protocol designed for the purpose of delivering email was warranted. SMTP was first defined in RFC 788 and published in November 1981.</p><p>The name suggests that SMTP is simpler than the protocol that it replaced. Whether or not this is true is somewhat a matter of opinion; I do note that RFC 788 is 61 pages long, while the earlier RFC 780 was only 43 pages. What SMTP definitely has over MTP is <span class="emphasis"><em>elegance</em></span>; the protocol is designed specifically for the transport of email. While it retains certain similarities to FTP, it is an independent protocol running over the Transmission Control Protocol (TCP). So, from a conceptual standpoint, it can be considered simpler than MTP. In terms of mechanics, the process SMTP uses to transfer an email message is indeed rather simple, especially compared to some other protocols.</p><p>RFC 788 described the operation of SMTP carrying email messages corresponding to the ARPAnet text message standard as described in RFC 733. Development of both email messages and SMTP continued, and in August 1982, a milestone in TCP/IP email was achieved when RFCs 821 and 822 were published. RFC 821 revised SMTP and became the defining standard for the protocol for the next two decades. RFC 822, its companion standard, became the standard for TCP/IP email messages carried by SMTP.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-454"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The most important component of the TCP/IP email system is the <span class="emphasis"><em>Simple Mail Transfer Protocol (SMTP)</em></span>. SMTP was derived from the earlier Mail Transfer Protocol (MTP) and is the mechanism used for the delivery of mail between TCP/IP systems and users. The only part of the email system for which SMTP is not used is the final retrieval step by an email recipient.</p></div><p>As the 1980s progressed, and TCP/IP and the Internet both grew in popularity, SMTP gradually overtook other methods to become the dominant method of email message delivery. For a number of years, the protocol was used mostly as is, with no new RFCs published to define new versions or formally change its behavior. This changed in February 1993, when RFC 1425, "SMTP Service Extensions," was published. As the name suggests, this standard describes a process for adding new capabilities to extend how SMTP works, while maintaining backward compatibility with existing systems. SMTP with these extensions is sometimes called <span class="emphasis"><em>Extended SMTP</em></span> or <span class="emphasis"><em>ESMTP</em></span> (though use of this term seems not to be entirely universal).</p><p>As development of SMTP continued, RFC 1425 was revised in RFC 1651 in July 1994, and then in RFC 1869 in November 1995. Along with these revisions, a number of other RFCs defining particular SMTP extensions, such as pipelining and message size declaration, were defined.</p><p>In April 2001, another major milestone in TCP/IP email was reached when revisions of RFC 821 and RFC 822 were published, as RFCs 2821 and 2822, respectively. Both documents are consolidations of updates and changes that had been made to RFCs 821 and 822 between 1982 and 2001. And, no, I don't think it is a coincidence that the old and new RFC numbers are exactly 2,000 apart. RFCs 2820 and 2823 were both published in May 2000, so it looks like 2821 and 2822 were reserved for the email standards. I think this naming was a great idea, as it makes it clear that the new RFCs are revisions of the old ones.</p><p>RFC 2821 is the current base standard for SMTP. It incorporates the base protocol description from RFC 821 and the latest SMTP extensions as defined in RFC 1869. It updates the description of the email communication model to reflect the realities of modern TCP/IP networks, especially the email features built into the Domain Name System (DNS). We'll examine this in more detail in the next section.</p></div><div class="sect2" title="SMTP Communication and Message Transport Methods"><div class="titlepage"><div><div><h2 class="title"><a id="smtp_communication_and_message_transport"/>SMTP Communication and Message Transport Methods</h2></div></div></div><p><a class="indexterm" id="idx-CHP-77-2752"/>The TCP/IP email communication model describes the way email messages are conveyed from the sender to the recipient. In most cases, this involves the sender's client machine sending the email to its local SMTP server, which sends it to the recipient's local SMTP server, which then sends it to the recipient's local host. SMTP handles the transport between SMTP servers. In fact, the overall email communication model is largely described by the RFC 821 and 2821 SMTP standards.</p><p>The initial communication takes place between the sender's client machine and a local SMTP server that the sender is allowed to access. After submission of the email message, that SMTP server becomes responsible for delivering the message to the SMTP server responsible for the recipient's mailbox.</p><div class="sect3" title="Early Email Communication Using Relaying"><div class="titlepage"><div><div><h3 class="title"><a id="early_email_communication_using_relaying"/>Early Email Communication Using Relaying</h3></div></div></div><p>In the <a class="indexterm" id="idx-CHP-77-2753"/>early days of <a class="indexterm" id="idx-CHP-77-2754"/>email, when RFC 821 and its predecessors were first defined, the Internet was very different from what it is today. There was no DNS, and this made email delivery complex, because there was no way to map a mailbox address to the IP address of the SMTP server that managed that mailbox. Also, many proprietary networks were connected to the Internet, which meant that it was not always possible for any particular system to communicate with any other.</p><p>Given this, how could email be delivered? The most common way in the early days of SMTP was through a process called <span class="emphasis"><em>relaying</em></span>. SMTP routing information was included along with the email address, to specify a sequence of SMTP servers that the mail should be relayed through to get to its destination. For example, if a sender using SMTP Server A wanted to send email to someone whose mailbox was on SMTP Server Z, the sender might have needed to specify that the mail be sent through intermediate SMTP Servers D, P, and U to get there. An SMTP connection would be established from Server A to Server D to send the message on one leg of its journey; then it would go from Server D to P, Server P to U, and then Server U to Z. The process is analogous to how Internet Protocol (IP) routing works, but at the application layer (actually using IP routing at a lower level).</p><p>You can probably see the problems with this quite easily: It's cumbersome, requires many devices to handle the mail, results in delays in <a class="indexterm" id="idx-CHP-77-2755"/>communication, and requires the communication of source routes between SMTP servers. It was certainly functional, but it was far from ideal.</p></div><div class="sect3" title="Modern Email Communication Using DNS and Direct Delivery"><div class="titlepage"><div><div><h3 class="title"><a id="modern_email_communication_using_dns_and"/>Modern Email Communication Using DNS and Direct Delivery</h3></div></div></div><p><a class="indexterm" id="idx-CHP-77-2756"/>The creation of DNS radically changed how email delivery worked. DNS includes support for a special <span class="emphasis"><em>mail exchange (MX)</em></span> record that allows easy mapping from the domain name in an email address to the IP address of the SMTP server that handles mail for that domain. I explain this in the description of the regular email address format in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>, as well as the section about DNS email support in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>.</p><p>In the new system, SMTP communication is much simpler and more direct. The sending SMTP server uses DNS to find the MX record of the domain to which the email is addressed. This gives the sender the DNS name of the recipient's SMTP server. This is resolved to an IP address, and a connection can be made directly from the sender's SMTP server to the recipient's server to deliver the email. While SMTP still supports relaying, direct email delivery using MX records is faster and more efficient, and RFC 2821 makes clear that this is now the preferred method.</p><p>In this new system, SMTP is generally used only for two transfers: first, from the sender's client machine to the sender's local SMTP server, and then from that server to the recipient's local SMTP server, as shown in <a class="xref" href="ch74s03.html#email_communication_model_this_diagram_s" title="Figure 74-1. Email communication model This diagram shows the four devices that are involved in a typical email communication between two users. Each device consists of a number of different elements, which communicate as indicated by the black arrows. Note the inherent asymmetry, because the method used to send an email from a user is not the same as that used to retrieve it from the server. The large, shaded arrows show a typical transaction: the sender composes mail and it goes to her local email spool. It is sent to the sender's local SMTP server using SMTP, and then to the recipient's SMTP server, where it goes into that user's inbox. It is then retrieved, usually using a protocol such as POP or IMAP.">Figure 74-1</a> in <a class="xref" href="ch74.html" title="Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS">Chapter 74</a>. (A distinct mail access protocol or method is used by the recipient for the last leg of the journey.) Each transfer of an email message between SMTP servers involves the establishment of a TCP connection, and then the transfer of the email headers and body using the SMTP mail transfer process. The following sections describe in detail how this occurs.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-455"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the early days of SMTP, mail was delivered using the relatively inefficient process of relaying from server to server across the internetwork. Today, when an SMTP server has mail to deliver to a user, it determines the server that handles the user's mail using the Domain Name System (DNS) and sends the mail directly to that server.</p></div></div></div><div class="sect2" title="Terminology: Client/Server and Sender/Receiver"><div class="titlepage"><div><div><h2 class="title"><a id="terminology_clientserver_and_senderrecei"/>Terminology: Client/Server and Sender/Receiver</h2></div></div></div><p><a class="indexterm" id="idx-CHP-77-2757"/>The original RFC 821 standard referred to the device that initiates an SMTP email transfer as the <span class="emphasis"><em>sender</em></span> and the device that responds to it as the <span class="emphasis"><em>receiver</em></span>. These terms were changed to <span class="emphasis"><em>client</em></span> and <span class="emphasis"><em>server</em></span> in RFC 2821 to "reflect current industry terminology." Strictly speaking, this is correct, but in some ways, the more current terminology is significantly <span class="emphasis"><em>less</em></span> clear.</p><p>As I explained in the general discussion of TCP/IP client/server operation in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>, the terms <span class="emphasis"><em>client</em></span> and <span class="emphasis"><em>server</em></span> are used in many different senses in networking, which often leads to confusion. In common parlance, the computers that handle email on the Internet are usually all called <span class="emphasis"><em>SMTP servers</em></span>. This is because they run SMTP server software to provide SMTP services to client machines, such as end-user PCs. In addition, these devices are usually dedicated hardware servers running in network centers, typically managed by Internet service providers (ISPs).</p><p>However, the terms <span class="emphasis"><em>client</em></span> and <span class="emphasis"><em>server</em></span> are now used to refer to the roles in a particular SMTP communication as well. Since all SMTP servers both send and receive email, they all act as both clients and servers at different times. An SMTP server that is relaying an email will act as both server and client for that message, receiving it as a server, and then sending it to the next server as a client. Adding to this potential confusion is the fact that the initial stage in sending an email is from the sender's client machine to the sender's local SMTP server. Thus, the client role in an SMTP transaction may not be an actual SMTP server, but the server role will always be a server.</p><p>For all of these reasons, the old terms <span class="emphasis"><em>sender</em></span> and <span class="emphasis"><em>receiver</em></span> are still used in places in RFC 2821, where needed for clarity. I consider them much more straightforward and use them in the rest of this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-456"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SMTP servers both send and receive email. The device sending mail acts as a client for that transaction, and the one receiving it acts as a server. To avoid confusion, it is easier to refer to the device sending email as the <span class="emphasis"><em>SMTP sender</em></span> and the one receiving as the <span class="emphasis"><em>SMTP receiver</em></span>; these terms were used when SMTP was originally created.</p></div></div></div></div>
<div class="sect1" title="SMTP Connection and Session Establishment and Termination"><div class="titlepage"><div><div><h1 class="title"><a id="smtp_connection_and_session_establishmen"/>SMTP Connection and Session Establishment and Termination</h1></div></div></div><p>The delivery of email using SMTP involves the regular exchange of email messages among SMTP servers. SMTP servers are responsible for sending email that users of the server submit for delivery. They also receive email intended for local recipients, or for forwarding or relaying to other servers.</p><div class="sect2" title="Overview of Connection Establishment and Termination"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_connection_establishment_and"/>Overview of Connection Establishment and Termination</h2></div></div></div><p>All SMTP communication is done using TCP. This allows SMTP servers to make use of TCP's many features that ensure efficient and reliable communication. SMTP servers generally must be kept running and connected to the Internet 24 hours a day, seven days a week, to ensure that mail can be delivered at any time. (This is a big reason why most end users employ access protocols such as the Post Office Protocol to access their received email rather than running their own SMTP servers.) The server listens continuously on the SMTP server port, well-known port number 25, for any TCP connection requests from other SMTP servers.</p><p>An SMTP server that wishes to send email normally begins with a DNS lookup of the MX record corresponding to the domain name of the intended recipient's email address to get the name of the appropriate SMTP server. This name is then resolved to an IP address; for efficiency, this IP address is often included as an <span class="emphasis"><em>additional</em></span> record in the response to the MX request to save the sending server from needing to perform two explicit DNS resolutions.</p><p>The SMTP sender then establishes an SMTP session with the SMTP receiver. Once the session is established, mail transactions can be performed to allow mail to be sent between the devices. When the SMTP sender is finished sending mail, it terminates the connection. All of these processes involve specific exchanges of commands and replies, which are illustrated in <a class="xref" href="ch77s02.html#smtp_transaction_session_establishment_a" title="Figure 77-1. SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session.">Figure 77-1</a>.</p><p>Let's take a look at these processes in more detail, starting with SMTP session establishment.</p></div><div class="sect2" title="Connection Establishment and Greeting Exchange"><div class="titlepage"><div><div><h2 class="title"><a id="connection_establishment_and_greeting_ex"/>Connection Establishment and Greeting Exchange</h2></div></div></div><p><a class="indexterm" id="idx-CHP-77-2758"/>The SMTP sender begins by initiating a TCP connection to the SMTP receiver. The sending SMTP server uses an ephemeral port number, since it is playing the role of the client in the transaction. Assuming that the server is willing to accept a connection, it will indicate that it is ready to receive instructions from the client by sending reply code 220. This is called the <span class="emphasis"><em>greeting</em></span> or <span class="emphasis"><em>service ready</em></span> response. It commonly includes the full domain name of the server machine, the version of the SMTP server software it is running, and possibly other information.</p><p>Now, it would be rude for the server acting as a client to start sending commands to the responding server without saying hello first, wouldn't it? So that's exactly what comes next: the client says, "Hello." In the original SMTP protocol, this is done by issuing a <a class="indexterm" id="idx-CHP-77-2759"/>HELO command, which includes the domain name of the sending (client) SMTP server as a courtesy. The receiving device then responds back with a return hello message using an SMTP reply code 250.</p><p>For example, if the SMTP server smtp.sendersite.org was making a connection to the SMTP server <a class="ulink" href="http://mail.receiversplace.com">mail.receiversplace.com</a>, it would say:</p><a id="I_programlisting4_d1e84123"/><pre class="programlisting">HELO smtp.sendersite.org.</pre><p>After receiving this greeting, <a class="ulink" href="http://mail.receiversplace.com">mail.receiversplace.com</a> would respond back with a <code class="literal">hello</code> message of its own, something like this:</p><a id="I_programlisting4_d1e84133"/><pre class="programlisting">250 mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you.</pre><div class="figure"><a id="smtp_transaction_session_establishment_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e84138"/><img alt="SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session." src="httpatomoreillycomsourcenostarchimages288293.png.jpg"/></div></div><p class="title">Figure 77-1. SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session.</p></div><p>(The chatty text is of course purely optional; most of the time, SMTP communication is between software programs, so the pleasantries are usually written by programmers who have a sense of humor.)</p></div><div class="sect2" title="Connection Establishment Using SMTP Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="connection_establishment_using_smtp_exte"/>Connection Establishment Using SMTP Extensions</h2></div></div></div><p><a class="indexterm" id="idx-CHP-77-2760"/>The SMTP extensions first defined in RFC 1425, and then in subsequent standards up to RFC 2821, define an alternative hello message for the client to use: <a class="indexterm" id="idx-CHP-77-2761"/>EHLO (extended hello). An SMTP sender supporting SMTP extensions (and most do) uses EHLO instead of HELO in response to the 220 greeting. This serves both to say hello to the SMTP receiver and to tell it that the sender supports SMTP extensions.</p><p>If the SMTP receiver supports the extensions, it replies with the usual 250 reply, as well as a series of extra 250 responses. Each of these lists an EHLO<span class="emphasis"><em> keyword</em></span> that indicates a particular SMTP extension the receiver supports. If the receiving server doesn't support the extensions, it will reject the EHLO command with a 500 reply code ("syntax error, command not recognized"). This tells the SMTP sender that it cannot use extensions. It will then issue a conventional HELO command, or it will QUIT the connection if it requires the SMTP extension to be present. (In practice, it is rare for a server to <span class="emphasis"><em>require</em></span> the use of SMTP extensions.)</p><p>Here's the same example used earlier, but using EHLO. The sender says:</p><a id="I_programlisting4_d1e84171"/><pre class="programlisting">EHLO smtp.sendersite.org.</pre><p>Assuming <a class="ulink" href="http://mail.receiversplace.com">mail.receiversplace.com</a> supports the SMTP extensions, a typical reply might look like this:</p><a id="I_programlisting4_d1e84178"/><pre class="programlisting">250-mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you.
250-SIZE
250-DSN
250 PIPELINING</pre><p>Each of these additional replies identifies a particular SMTP extension supported by <a class="ulink" href="http://mail.receiversplace.com">mail.receiversplace.com</a>; in this case, message size declaration (SIZE), delivery status notification (DSN), and command pipelining. (The dashes after the 250 indicate a multiple-line response to a command; this is discussed in the "SMTP Multiple-Line Text Replies" section later in the chapter.)</p><p>Once the HELO or EHLO command has been sent and the receiving device has responded, the session is initiated. Further commands can be sent by the sending SMTP server to the responding server. These usually take the form of email message transfer transactions using the process described in the upcoming "SMTP Mail Transaction Process" section, and other command/reply exchanges as needed.</p></div><div class="sect2" title="Connection Termination"><div class="titlepage"><div><div><h2 class="title"><a id="connection_termination"/>Connection Termination</h2></div></div></div><p><a class="indexterm" id="idx-CHP-77-2762"/>When the sending device is finished sending all the email it has to transfer to the receiving device, and it has completed all its other activities, it terminates the session by issuing the QUIT command. This normally results in a 221 "goodbye" message from the SMTP receiver, which says something like "closing transmission channel." The TCP connection is then terminated.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-457"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> An SMTP session consists of three basic phases. The session is first <span class="emphasis"><em>established</em></span> through the creation of a TCP connection and the exchange of identity information between the SMTP sender and receiver using the HELO command. Once established, <span class="emphasis"><em>mail transactions</em></span> can be performed. When the SMTP sender is finished with the session, it <span class="emphasis"><em>terminates</em></span> it using the QUIT command. If <span class="emphasis"><em>SMTP extensions</em></span> are supported, the SMTP sender uses the <span class="emphasis"><em>EHLO (extended hello)</em></span> command instead of <span class="emphasis"><em>HELO</em></span>, and the SMTP receiver replies with a list of extensions it will allow the SMTP sender to use.</p></div><p>A server may also terminate prematurely in special cases. If it is given a local command to shut down (for example, due to imminent rebooting of the hardware server on which it is running), it may respond to any routine command with a 421 response ("Service not available, closing transmission channel"). A server is not supposed to terminate a session simply due to receipt of an invalid command, however; this should happen only in special cases where session termination cannot be avoided.</p></div></div>
<div class="sect1" title="SMTP Mail Transaction Process"><div class="titlepage"><div><div><h1 class="title"><a id="smtp_mail_transaction_process"/>SMTP Mail Transaction Process</h1></div></div></div><p><a class="indexterm" id="idx-CHP-77-2763"/>As described in the previous section, the delivery of an email message begins with the establishment of an SMTP session between the devices sending and receiving the message. The SMTP sender initiates a TCP connection to the SMTP receiver and then sends a HELO or an EHLO command, to which the receiver responds. Assuming no problems ensue, the session is then established and ready for actual email message transactions.</p><div class="sect2" title="Overview of SMTP Mail Transaction"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_smtp_mail_transaction"/>Overview of SMTP Mail Transaction</h2></div></div></div><p>The SMTP mail transaction process itself consists of three steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Transaction Initiation and Sender Identification</strong></span> The SMTP sender tells the SMTP receiver that it wants to start sending a message and gives the receiver the email address of the message's originator.</p></li><li class="listitem"><p><span class="strong"><strong>Recipient Identification</strong></span> The sender tells the receiver the email address(es) of the intended recipients of the message.</p></li><li class="listitem"><p><span class="strong"><strong>Mail Transfer</strong></span> The sender transfers the email message to the receiver. This is a complete email message meeting the RFC 822 specification (which may be in MIME format as well).</p></li></ul></div><p>That's it! So you can see that the word <span class="emphasis"><em>Simple</em></span> in <span class="emphasis"><em>Simple Mail Transfer Protocol</em></span> definitely has at least <span class="emphasis"><em>some</em></span> merit. In fact, one question that sometimes comes up when examining SMTP is "Why couldn't this process be even simpler?" The first two steps identify the sender of the email and the intended recipient(s). But all of this information is already contained in headers in the message itself. Why doesn't SMTP just read that information from the message, which would make the mail transaction a <span class="emphasis"><em>one-step</em></span> process?</p><p>The explanation isn't specifically addressed in the SMTP standards, but I believe there are several reasons for this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Specifying the sender and recipients separately is more efficient, as it gives the SMTP receiver the information it needs up front before the message itself is transmitted. In fact, the SMTP receiver can decide whether or not to accept the message based on the source and destination email addresses.</p></li><li class="listitem"><p>Having this information specified separately gives greater control on how email is distributed. For example, an email message may be addressed to two recipients, but they may be on totally different systems; the SMTP sender might wish to deliver the mail using two separate SMTP sessions to two different SMTP receivers.</p></li><li class="listitem"><p>In a similar vein, there is the matter of delivering blind carbon copies. Someone who is BCC'ed a message must receive it without being mentioned in the message itself.</p></li><li class="listitem"><p>Having this information separate makes implementing security on SMTP much easier.</p></li></ul></div><p>For these reasons, SMTP draws a distinction between the message itself, which it calls the <span class="emphasis"><em>content</em></span>, and the sender and recipient identification, which it calls the <span class="emphasis"><em>envelope</em></span>. This is consistent with our running analogy between regular mail and email. Just as the postal service delivers a piece of mail using only the information written on the envelope, SMTP delivers email using the envelope information, not the content of the message. It's not quite the case that the SMTP server doesn't look at the message itself, just that this is not the information it uses to manage delivery.</p><div class="note" title="Note"><h3 class="title"><a id="note-161"/>Note</h3><p><span class="emphasis"><em>It is possible for the sender of a message to generate envelope information based on the contents of the message, but this is somewhat external to SMTP itself. It is described in the standard, but caution is urged in exactly how this is implemented</em></span>.</p></div></div><div class="sect2" title="SMTP Mail Transaction Details"><div class="titlepage"><div><div><h2 class="title"><a id="smtp_mail_transaction_details"/>SMTP Mail Transaction Details</h2></div></div></div><p>Let's take a more detailed look at the SMTP mail transaction process, using as aids the process diagram in <a class="xref" href="ch77s03.html#smtp_mail_transaction_process_once_an_sm" title="Figure 77-2. SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received.">Figure 77-2</a> and the sample transaction of <a class="xref" href="ch77s03.html#example_of_an_smtp_mail_transaction" title="Example 77-1. Example of an SMTP mail transaction">Example 77-1</a> (which has commands highlighted in bold and replies in italics).</p><div class="example"><a id="example_of_an_smtp_mail_transaction"/><p class="title">Example 77-1. Example of an SMTP mail transaction</p><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>MAIL FROM:&lt;joe@someplace.org&gt;</code></strong>
<em class="replaceable"><code>250 &lt;joe@someplace.org&gt; . . . Sender ok</code></em>
<strong class="userinput"><code>RCPT TO:&lt;jane@somewhereelse.com&gt;</code></strong>
<em class="replaceable"><code>250 &lt;jane@somewhereelse.com&gt; . . . Recipient ok</code></em>
<strong class="userinput"><code>DATA</code></strong>
<em class="replaceable"><code>354 Enter mail, end with "." on a line by itself</code></em>
<strong class="userinput"><code>From: Joe Sender &lt;joe@someplace.org&gt;</code></strong>
<strong class="userinput"><code>To: Jane Receiver &lt;jane@somewhereelse.com&gt;</code></strong>
<strong class="userinput"><code>Date: Sun, 1 Jun 2003 14:17:31 --0800</code></strong>
<strong class="userinput"><code>Subject: Lunch tomorrow</code></strong>

<strong class="userinput"><code>Hey Jane,</code></strong>

<strong class="userinput"><code>It's my turn for lunch tomorrow. I was thinking we could</code></strong>
<strong class="userinput"><code>[rest of message]</code></strong>
<strong class="userinput"><code>Hope you are free. Send me a reply back when you get a chance.</code></strong>
<strong class="userinput"><code>Joe.</code></strong>
<strong class="userinput"><code>.</code></strong>
<em class="replaceable"><code>250 OK</code></em></pre></div></div><div class="figure"><a id="smtp_mail_transaction_process_once_an_sm"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e84364"/><img alt="SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received." src="httpatomoreillycomsourcenostarchimages288295.png.jpg"/></div></div><p class="title">Figure 77-2. SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received.</p></div><p>The first two steps in the <a class="indexterm" id="idx-CHP-77-2764"/>mail transaction are responsible for providing the receiving SMTP server with the envelope information just discussed. The transaction begins by the SMTP sender issuing a MAIL command. This serves to inform the receiver that a new transaction is commencing and also to tell it the <span class="emphasis"><em>from</em></span> information on the envelope. Here's an example:</p><a id="I_programlisting4_d1e84380"/><pre class="programlisting">MAIL FROM:&lt;joe@someplace.org&gt;</pre><p>The email address of the originator is always enclosed in angle brackets (&lt; and &gt;). The SMTP receiver acknowledges the command with a 250 ("OK") reply message, sometimes sending back the address as a confirmation. Here's an example:</p><a id="I_programlisting4_d1e84384"/><pre class="programlisting">250 &lt;joe@someplace.org&gt; . . . Sender ok</pre><p>Next, the SMTP sender uses RCPT commands to specify the intended recipients of the email that is being sent. Each RCPT line can contain only one recipient, so if multiple recipients are indicated, two or more RCPT commands must be issued. Each one normally specifies an email address, but if relaying is being used, the command may contain routing information as well. (As described earlier in the "SMTP Communication and Message Transport Methods" section, this is not as commonly done as it was in the past.) Here's an example:</p><a id="I_programlisting4_d1e84388"/><pre class="programlisting">RCPT TO:&lt;jane@somewhereelse.com&gt;</pre><p>Assuming the server accepts the email, it will give a 250 "OK" reply again, like so:</p><a id="I_programlisting4_d1e84393"/><pre class="programlisting">250 &lt;jane@somewhereelse.com&gt; . . . Recipient ok</pre><p>The SMTP sender then issues the DATA command, which tells the SMTP receiver that the message is coming:</p><a id="I_programlisting4_d1e84397"/><pre class="programlisting">DATA</pre><p>The SMTP receiver responds with a 354 "intermediate" reply message, such as this:</p><a id="I_programlisting4_d1e84401"/><pre class="programlisting">354 Enter mail, end with "." on a line by itself</pre><p>The SMTP sender then sends the email message, one line at a time, with a single dot (.) on a line to terminate it. The server confirms the receipt of the message with another 250 "OK" reply, and the transaction is finished.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-458"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> After an SMTP session is established, email messages are sent using the SMTP <span class="emphasis"><em>mail transaction process</em></span>. The SMTP sender starts the transaction by identifying the sender of the email and then specifying one or more recipients. The email message itself is then transmitted to the SMTP receiver. Each email to be sent is a separate transaction.</p></div><p>While this indeed is quite simple, notice that I have shown an email transfer from a sender to one recipient, one in which there were no problems or complications in the transaction. Due either to command syntax or server issues, it is possible for various types of errors to occur at different stages of the process, which may result in the transaction failing. As you'll see shortly, security concerns may come also into play, leading to restrictions in what transactions a server may allow.</p></div></div>
<div class="sect1" title="SMTP Special Features, Capabilities, and Extensions"><div class="titlepage"><div><div><h1 class="title"><a id="smtp_special_features_capabilities_and_e"/>SMTP Special Features, Capabilities, and Extensions</h1></div></div></div><p>The primary job of the SMTP is to implement the TCP/IP email delivery system. Whenever the user of an SMTP server gives it an email message addressed to a remote mailbox, the server will attempt to transfer it to the appropriate destination server, using the SMTP mail transaction process. Many billions of such transfers are performed every day on the Internet, allowing email to reach its destination quickly anywhere around the world.</p><div class="sect2" title="SMTP Special Features and Capabilities"><div class="titlepage"><div><div><h2 class="title"><a id="smtp_special_features_and_capabilities"/>SMTP Special Features and Capabilities</h2></div></div></div><p>In addition to this basic transfer mechanism, SMTP includes a number of other features and capabilities. These allow SMTP to support special requirements and auxiliary needs of the mail system, as described in detail in RFC 2821. It would take many pages to describe them all in detail, so I will provide a quick summary of the more important ones here so you know a bit about them.</p><p>The following are some of SMTP's <a class="indexterm" id="idx-CHP-77-2765"/>special features:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-77-2766"/>Mail Relaying</strong></span> As discussed in the "SMTP Communication and Message Transport Methods" section earlier in this chapter, the protocol was once widely used in a relaying mode, where email was routed from one SMTP server to another to reach its destination. Today, the more efficient, normal method of email transfer on the Internet is directly from the sender's SMTP server to the recipient's server, using DNS MX records to determine the recipient SMTP server address. SMTP still includes the ability to relay mail from one server to another, provided certain conditions are met. Note that many servers won't relay mail because this feature has been abused for spamming and malicious hacking.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-77-2767"/>Mail Forwarding</strong></span> Under certain conditions, an SMTP server may agree to accept email for a remote mailbox and forward it to the appropriate destination. This sounds similar to relaying but is used in a different way. A common example is when users change their email address. For example, if you have worked at XYZ Industries for years and then retire, the company may no longer wish to let you receive email at the company's SMTP server. As a courtesy, however, they may forward email sent to you there, so that you receive it at your new company.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-77-2768"/>Mail Gatewaying</strong></span> Certain SMTP servers may be configured as email gateways. These devices translate TCP/IP email into a form suitable for another email system, and vice versa. Gatewaying is a complex topic because email systems can be so different. One of the more important problems is the inconsistency of addressing methods of different email systems.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-77-2769"/>Address Debugging</strong></span> SMTP includes a VRFY (verify) command that can be used to check the validity of an email address without actually sending mail to it.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-77-2770"/>Mailing List Expansion</strong></span> The SMTP command EXPN (expand) can be used to determine the individual email addresses associated with a mailing list. (Note, however, that this has nothing directly to do with mailing list software like <span class="emphasis"><em>Majordomo</em></span>.)</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-77-2771"/>Turning</strong></span> The original SMTP included a command that allows the SMTP sender and SMTP receiver to change roles. This could be used to allow SMTP Server A to send email to Server B, and then have Server B send email it has queued for Server A in the same session. In practice, this capability was not widely used for a variety of reasons, including security considerations. It is now officially not recommended but may still be implemented in some SMTP software.</p><p>These are just a few of the features that are mentioned in the <a class="indexterm" id="idx-CHP-77-2772"/>SMTP standards. In addition, developers of a particular type of SMTP server software may give it other features as well. The HELP command is one way of determining what commands are supported by a particular SMTP server.</p><p>SMTP servers also must perform a great deal of background processing that doesn't get a great deal of attention. This includes managing connections, checking for errors in commands and email messages, and reacting accordingly. They must also be on the lookout for problem conditions, such as looping that may result in an email message being passed back and forth between two SMTP servers, each thinking the other is the intended recipient. In the event of an initial failure to deliver mail, an SMTP server is also required to retry communication periodically with the destination device and return a failure message to the sender if it cannot deliver the message after a certain period of time. RFC 2821 contains more details.</p></div><div class="sect2" title="SMTP Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="smtp_extensions"/>SMTP Extensions</h2></div></div></div><p><a class="indexterm" id="idx-CHP-77-2773"/>As discussed earlier in this chapter, during the 1990s, many <a class="indexterm" id="idx-CHP-77-2774"/>extensions to the basic operation of SMTP were defined. These are enabled when two SMTP servers supporting the extension set up a session using the EHLO command and appropriate extension response codes. <a class="xref" href="ch77s04.html#smtp_extensions-id001" title="Table 77-1. SMTP Extensions">Table 77-1</a> summarizes some of the more interesting SMTP extensions that have been defined and gives the RFC number where each is described. You can find the full current set of SMTP extensions at <a class="ulink" href="http://www.iana.org/assignments/mail-parameters">http://www.iana.org/assignments/mail-parameters</a>.</p><div class="table"><a id="smtp_extensions-id001"/><p class="title">Table 77-1. SMTP Extensions</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SMTP Extensions"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extension Keyword</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extension</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Defining Document</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8BITMIME</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8-bit MIME support</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC 1652</p></td><td style="border-bottom: 0.5pt solid ; "><p>Theoretically defines support for the 8-bit content transfer encoding type in MIME, but complications associated with this. See the discussion of content encoding in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a> for details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AUTH</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Authorization</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC 2554</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to implement an authorization mechanism for servers requiring enhanced security.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DSN</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Delivery status notification</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC 1891</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows an SMTP sender to request that the SMTP receiver notify it if a problem occurs in delivering a message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ENHANCEDSTATUSCODES</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Enhanced status codes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC 2034, RFC 1893</p></td><td style="border-bottom: 0.5pt solid ; "><p>Extends the traditional three-digit SMTP reply code format with extra codes that provide more information. See the "SMTP Replies and Reply Codes" section later in this chapter for more information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PIPELINING</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command pipelining</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC 2920</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows multiple commands to be transmitted in batches from the SMTP sender to the receiver, rather than sending one command at a time and waiting for a response code.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>SIZE</p></td><td style="border-right: 0.5pt solid ; "><p>Message size declaration</p></td><td style="border-right: 0.5pt solid ; "><p>RFC 1870</p></td><td style=""><p>Allows information about the size of a message to be declared by an SMTP sender prior to transmitting it, so the SMTP receiver can decide if it wants the message or not.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-162"/>Note</h3><p><span class="emphasis"><em>Certain commands in the basic SMTP description that are considered optional are also sometimes considered extensions, such as the EXPN and HELP commands; I have not listed these here, since they are not true SMTP extensions</em></span><a class="indexterm" id="idx-CHP-77-2775"/>.</p></div></div></div>
<div class="sect1" title="SMTP Security Issues"><div class="titlepage"><div><div><h1 class="title"><a id="smtp_security_issues"/>SMTP Security Issues</h1></div></div></div><p><a class="indexterm" id="idx-CHP-77-2776"/>When it comes to security and SMTP, the theme is a common one in TCP/IP: A lack of security in how the protocol is implemented, because it was developed when the Internet was just a small group of machines controlled by individuals who mostly knew and trusted each other or who were able to use physical security. Developers never imagined TCP/IP being used by millions of anonymous average Joes around the world, which necessitates far more attention to security than a small research internetwork like the ARPAnet.</p><p>With SMTP, security matters are, if anything, <span class="emphasis"><em>worse</em></span> than they are with some of the other protocols. Not only does SMTP not have any real security mechanism, the original relaying model of SMTP communication is entirely designed around the idea of cooperation and trust among servers. Since most SMTP servers would be asked to handle a certain number of intermediate transfers, each server was required to accept mail from any originator to be delivered to any destination.</p><p>The basic assumption in this model is that users of SMTP servers would all be well behaved and not abuse the system by flooding intermediate servers with a lot of mail to be delivered or sending bogus messages to cause problems. This all changed as the Internet exploded in popularity in the 1990s. Con artists, malicious hackers, and disreputable salespeople discovered that email could be used for free delivery of messages simply by submitting them to an SMTP server for delivery. The result was overloaded servers, primarily due to the sending of large quantities of unwanted email, which Internet users commonly call <span class="emphasis"><em>spam</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="note-163"/>Note</h3><p><span class="emphasis"><em>The term spam, in this context, has nothing directly to do with the Hormel processed meat product. Its use in reference to massive amounts of email comes from a Monty Python comedy sketch in which that word is repeated in phrases over and over again</em></span>.</p></div><p>It is actually very easy to impersonate an SMTP server. You can use the Telnet Protocol to connect directly to an SMTP server on port 25. SMTP commands are all sent as text, and so are SMTP replies, so you can have a conversation with a server, and even manually perform a mail transaction. This is useful for debugging, but it also makes abuse of a wide-open SMTP server trivially easy. Since spammers often don't want to be identified, they employ spoofing techniques to make it more difficult to identify them, so resolving these problems is even more difficult.</p><p>Despite this obvious dilemma, efforts to implement a general security mechanism in SMTP have been resisted for two main reasons. First, there is no foolproof way to retrofit a new security mechanism onto something as widely used as SMTP without creating incompatibilities between newer and older systems. Second, many administrators were reluctant to do away completely with the general notion of cooperation among sites that has helped make the Internet so successful.</p><p>Still, something had to be done. The compromise was for system administrators to tighten up their SMTP servers through the imposition of both technical and policy changes. Naturally, these vary from one organization to another. Some of the more common SMTP security provisions include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Checking the IP address of a device attempting connection and refusing even to start an SMTP session unless it is in a list of authorized client devices.</p></li><li class="listitem"><p>Restricting certain commands or features, such as email relaying, to authorized users or client servers. This is sometimes done by requiring authentication via the SMTP extension AUTH before the command will be accepted.</p></li><li class="listitem"><p>Limiting the use of commands such as EXPN to prevent unauthorized users from determining the email addresses of users on mailing lists.</p></li><li class="listitem"><p>Checking the validity of envelope information before accepting a message for delivery. Some servers will first verify that the originator's email address is valid before agreeing to accept the MAIL command. Many will check the recipient's address and refuse the message if delivery is not to a local mailbox. Others use even more advanced techniques.</p></li><li class="listitem"><p>Limiting the size of email messages that may be sent or the number that may be sent in a given period of time.</p></li><li class="listitem"><p>Logging all access to the server to keep records of server use and check for abuse.</p></li></ul></div><p>Because of all the abuse in recent years, you will find that most SMTP servers implement these or other features, even though most of those features are not formally defined by the SMTP standards. Rather, they are enhancements built into individual SMTP server software packages.</p><p>SMTP was designed during an era in which Internet security was not much of an issue; as a result, the base protocol includes no security mechanism at all. Since email is so often abused today, most modern SMTP servers incorporate one or more security features to avoid problems.</p><p>Some of these measures can actually be quite sophisticated. For example, the SMTP server run by pair Networks, the great web-hosting company I have used for years, uses <a class="indexterm" id="idx-CHP-77-2777"/><span class="emphasis"><em>POP-before-SMTP authentication</em></span>. This means that before the server will accept outgoing mail from the user via SMTP, the user must first log in to check incoming mail using the Post Office Protocol (POP). Since POP includes authentication, a successful POP login tells the server the user is authorized. This "flips a switch" in the server that allows the user to access the SMTP service after that login for a limited period of time. If this seems convoluted, then you're starting to get an idea of the hassle that spammers and malicious hackers have created for ISPs today.</p><p>It's also worth noting that SMTP does not include any mechanism for encryption to ensure the privacy of email transmissions. Users requiring security to control who sees their messages must use a separate encryption scheme to encode the body of the message prior to submission.</p></div>
<div class="sect1" title="SMTP Commands"><div class="titlepage"><div><div><h1 class="title"><a id="smtp_commands"/>SMTP Commands</h1></div></div></div><p>Early TCP/IP email mechanisms were developed by borrowing techniques and elements from existing application protocols, especially <a class="indexterm" id="idx-CHP-77-2778"/>Telnet and FTP. SMTP is an independent protocol, but its heritage can still be seen clearly in a few areas. One of the more obvious of these is in the method by which <a class="indexterm" id="idx-CHP-77-2779"/>commands are issued by an SMTP sender and replies returned by an SMTP receiver.</p><p>Like FTP, all SMTP <a class="indexterm" id="idx-CHP-77-2780"/>commands are sent as plain ASCII text over the TCP connection established between the client and server in an SMTP connection. These commands must end with the two-character CRLF sequence that normally terminates ASCII text as required for the Telnet Network Virtual Terminal (NVT; see <a class="xref" href="ch87.html" title="Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS">Chapter 87</a>). In fact, you can check the function of an SMTP server and even issue commands to it yourself simply by using Telnet to connect to it on port 25.</p><p>All SMTP commands are specified using a four-letter command code. Some commands also either allow or require parameters to be specified. The basic syntax of a command is</p><a id="I_programlisting4_d1e84727"/><pre class="programlisting">&lt;command-code&gt; &lt;parameters&gt;</pre><p>When parameters are used, they follow the command code and are separated from it by one or more space characters. For example, the HELO and EHLO commands are specified with the command code, a space character, and then the domain name of the SMTP sender, as you saw earlier in the discussion of SMTP connection establishment.</p><p><a class="xref" href="ch77s06.html#smtp_commands-id001" title="Table 77-2. SMTP Commands">Table 77-2</a> lists the commands currently used in modern SMTP in the order they are described in RFC 2821, with a brief description of each.</p><div class="table"><a id="smtp_commands-id001"/><p class="title">Table 77-2. SMTP Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SMTP Commands"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>HELO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hello</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The domain name of the sender</p></td><td style="border-bottom: 0.5pt solid ; "><p>The conventional instruction sent by an SMTP sender to an SMTP receiver to initiate the SMTP session.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>EHLO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extended Hello</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The domain name of the sender</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent by an SMTP sender that supports SMTP extensions to greet an SMTP receiver and ask it to return a list of SMTP extensions the receiver supports. The domain name of the sender is supplied as a parameter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MAIL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Initiate Mail Transaction</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must include a FROM: parameter specifying the originator of the message, and may contain other parameters as well</p></td><td style="border-bottom: 0.5pt solid ; "><p>Begins a mail transaction from the sender to the receiver.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RCPT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Recipient</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must include a TO: parameter specifying the recipient mailbox, and may also incorporate other optional parameters</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies one recipient of the email message being conveyed in the current transaction.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DATA</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mail Message Data</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the SMTP receiver that the SMTP sender is ready to transmit the email message. The receiver normally replies with an intermediate "go ahead" message, and the sender then transmits the message one line at a time, indicating the end of the message by a single period on a line by itself.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RSET</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reset</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Aborts a mail transaction in progress. This may be used if an error is received upon issuing a MAIL or RCPT command, if the SMTP sender cannot continue the transfer as a result.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>VRFY</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Verify</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Email address of mailbox to be verified</p></td><td style="border-bottom: 0.5pt solid ; "><p>Asks the SMTP receiver to verify the validity of a mailbox.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>EXPN</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Expand</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Email address of mailing list</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests that the SMTP server confirm that the address specifies a mailing list, and return a list of the addresses on the list.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>HELP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Help</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional command name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests general help information if no parameter is supplied; otherwise, information specific to the command code supplied.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NOOP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No Operation</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Does nothing except for verifying communication with the SMTP receiver.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>QUIT</p></td><td style="border-right: 0.5pt solid ; "><p>Quit</p></td><td style="border-right: 0.5pt solid ; "><p>None</p></td><td style=""><p>Terminates the SMTP session.</p></td></tr></tbody></table></div></div><p>Like FTP commands, SMTP commands are not case-sensitive.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-459"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The SMTP sender performs operations using a set of <span class="emphasis"><em>SMTP commands</em></span>. Each command is identifies using a four-letter code. Since SMTP supports only a limited number of functions, it has a small command set.</p></div><p>The commands in <a class="xref" href="ch77s06.html#smtp_commands-id001" title="Table 77-2. SMTP Commands">Table 77-2</a> are those most commonly used in SMTP today. Certain other commands were also originally defined in RFC 821 but have since become obsolete. These include the following:</p><p><span class="strong"><strong>SEND, SAML (Send and Mail), and SOML (Send or Mail)</strong></span> RFC 821 defined a distinct mechanism for delivering mail directly to a user's terminal as opposed to a mailbox, optionally in combination with conventional email delivery. These were rarely implemented and obsoleted in RFC 2821.</p><p><span class="strong"><strong>TURN</strong></span> Reverses the role of the SMTP sender and receiver as described earlier in the SMTP special features discussion. This had a number of implementation and security issues and was removed from the standard in RFC 2821.</p><p>Finally, note that certain <a class="indexterm" id="idx-CHP-77-2781"/>SMTP extensions make changes to the basic SMTP command set. For example, the <a class="indexterm" id="idx-CHP-77-2782"/><span class="emphasis"><em>AUTH</em></span> extension specifies a new command (also called <a class="indexterm" id="idx-CHP-77-2783"/>AUTH) that specifies an authentication method the SMTP client wants to use. Other extensions define new parameters for existing commands. For example, the <a class="indexterm" id="idx-CHP-77-2784"/>SIZE extension defines a <span class="emphasis"><em>SIZE</em></span> parameter that can be added to a <span class="emphasis"><em>MAIL</em></span> command to tell the SMTP receiver the size of the message to be transferred.</p></div>
<div class="sect1" title="SMTP Replies and Reply Codes"><div class="titlepage"><div><div><h1 class="title"><a id="smtp_replies_and_reply_codes"/>SMTP Replies and Reply Codes</h1></div></div></div><p><a class="indexterm" id="idx-CHP-77-2785"/>All SMTP protocol operations consist of the plain ASCII text SMTP commands you saw in <a class="xref" href="ch77s06.html#smtp_commands-id001" title="Table 77-2. SMTP Commands">Table 77-2</a>, issued by the sender to the receiver. The receiver analyzes each command, carries out the instruction requested by the sender if possible, and then sends a reply to the sender. The reply serves several functions: confirming command receipt, indicating whether or not the command was accepted, and communicating the result of processing the command.</p><p>Just as SMTP commands are sent in a manner reminiscent of how FTP internal commands work, SMTP replies are formatted and interpreted in a way almost identical to that of FTP replies. As with FTP, the reply consists of not just a string of reply text, but a combination of reply text and a numerical <span class="emphasis"><em>reply code</em></span>. And as with FTP, these reply codes use three digits to encode various information about the reply, with each digit having a particular significance. The reply code is really the key part of the reply, with the reply text being merely descriptive.</p><div class="note" title="Note"><h3 class="title"><a id="note-164"/>Note</h3><p><span class="emphasis"><em>The discussion of FTP reply codes in <a class="xref" href="ch72.html" title="Chapter 72. FILE TRANSFER PROTOCOL (FTP)">Chapter 72</a> contains a thorough explanation of the benefits of using these structured numeric reply codes</em></span>.</p></div><div class="sect2" title="Reply Code Structure and Digit Interpretation"><div class="titlepage"><div><div><h2 class="title"><a id="reply_code_structure_and_digit_int-id001"/>Reply Code Structure and Digit Interpretation</h2></div></div></div><p>SMTP reply codes can be considered to be of the form <span class="emphasis"><em>xyz</em></span>, where <span class="emphasis"><em>x</em></span> is the first digit, <span class="emphasis"><em>y</em></span> is the second, and <span class="emphasis"><em>z</em></span> is the third.</p><p>The first reply code digit (<span class="emphasis"><em>x</em></span>) indicates the success or failure of the command in general terms, whether a successful command is complete or incomplete, and whether an unsuccessful command should be tried again or not. This particular digit is interpreted in exactly the same way as it is in FTP, as shown in <a class="xref" href="ch77s07.html#smtp_reply_code_format_first_digit_inter" title="Table 77-3. SMTP Reply Code Format: First Digit Interpretation">Table 77-3</a>.</p><div class="table"><a id="smtp_reply_code_format_first_digit_inter"/><p class="title">Table 77-3. SMTP Reply Code Format: First Digit Interpretation</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SMTP Reply Code Format: First Digit Interpretation"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reply Code Format</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Meaning</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Positive Preliminary Reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>An initial response indicating that the command has been accepted and processing of it is still in progress. The SMTP sender should expect another reply before a new command may be sent. Note that while this first digit type is formally defined in the SMTP specification for completeness, it is not currently used by any of the SMTP commands; that is, no reply codes between 100 and 199 exist in SMTP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Positive Completion Reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>The command has been successfully processed and completed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Positive Intermediate Reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>The command was accepted but processing it has been delayed, pending receipt of additional information. For example, this type of reply is often made after receipt of a DATA command to prompt the SMTP sender to send the actual email message to be transferred.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4yz</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Transient Negative Completion Reply</p></td><td style="border-bottom: 0.5pt solid ; "><p>The command was not accepted and no action was taken, but the error is temporary and the command may be tried again. This is used for errors that may be a result of temporary glitches or conditions that may change, such as a resource on the SMTP server being temporarily busy.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>5yz</p></td><td style="border-right: 0.5pt solid ; "><p>Permanent Negative Completion Reply</p></td><td style=""><p>The command was not accepted and no action was taken. Trying the same command again is likely to result in another error. An example would be sending an invalid command.</p></td></tr></tbody></table></div></div><p>The second reply code digit (<span class="emphasis"><em>y</em></span>) is used to categorize messages into functional groups. This digit is used in the same general way as in FTP, but some of the functional groups are different in SMTP, as you can see in <a class="xref" href="ch77s07.html#smtp_reply_code_format_second_digit_inte" title="Table 77-4. SMTP Reply Code Format: Second Digit Interpretation">Table 77-4</a>.</p><div class="table"><a id="smtp_reply_code_format_second_digit_inte"/><p class="title">Table 77-4. SMTP Reply Code Format: Second Digit Interpretation</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SMTP Reply Code Format: Second Digit Interpretation"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reply Code Format</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Meaning</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x0z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></td><td style="border-bottom: 0.5pt solid ; "><p>Syntax errors or miscellaneous messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x1z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Information</p></td><td style="border-bottom: 0.5pt solid ; "><p>Replies to requests for information, such as status requests.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x2z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Connections</p></td><td style="border-bottom: 0.5pt solid ; "><p>Replies related to the connection between the SMTP sender and SMTP receiver.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x3z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unspecified</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not defined.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x4z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unspecified</p></td><td style="border-bottom: 0.5pt solid ; "><p>Not defined.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>x5z</p></td><td style="border-right: 0.5pt solid ; "><p>Mail System</p></td><td style=""><p>Replies related to the SMTP mail service itself.</p></td></tr></tbody></table></div></div><p>The third reply code digit (<span class="emphasis"><em>z</em></span>) indicates a specific type of message within each of the functional groups described by the second digit. The third digit allows each functional group to have ten different reply codes for each reply type given by the first code digit (preliminary success, transient failure, and so on).</p><p>Again, as in FTP, these <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> digit meanings are combined to make specific reply codes. For example, the reply code 250 is a positive reply indicating command completion, related to the mail system. It is usually used to indicate that a requested mail command was completed successfully.</p><p><a class="xref" href="ch77s07.html#smtp_reply_codes" title="Table 77-5. SMTP Reply Codes">Table 77-5</a> contains a list of some of the more common SMTP reply codes taken from RFC 2821, in numerical order. For each, I have shown the typical reply text specified in the standard and provided additional descriptive information when needed.</p><p>As mentioned earlier, the actual text string for each reply code is implementation-specific. While the standard specifies dry response text such as "Requested action completed" for a 250 message, some servers will customize this code or even give different replies to different 250 messages, depending on the context.</p><div class="table"><a id="smtp_reply_codes"/><p class="title">Table 77-5. SMTP Reply Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SMTP Reply Codes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-77-2786"/>Reply Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reply Text</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>211</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>System status or system help reply.</p></td><td style="border-bottom: 0.5pt solid ; "><p/></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>214</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>&lt;Help message…&gt;</em></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Used for text sent in reply to the HELP command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>220</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>&lt;servername&gt;</em></span> Service ready.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Greeting message sent when TCP connection is first established to an SMTP server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>221</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>&lt;servername&gt;</em></span> closing transmission channel.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Goodbye message sent in response to a QUIT message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>250</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested mail action ok, completed</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates successful execution of a variety of commands.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>251</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User not local; will forward to <span class="emphasis"><em>&lt;forward-path&gt;</em></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Used when the SMTP receiver agrees to forward a message to a remote user.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>252</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Cannot VRFY user, but will accept message and attempt delivery</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates that a server tried to verify an email address, but was not able to do so completely. Usually means the address appears to be valid but it was not possible to ascertain this to be positively true.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>354</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;</p></td><td style="border-bottom: 0.5pt solid ; "><p>Intermediate reply to a DATA command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>421</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>&lt;servername&gt;</em></span> Service not available, closing transmission channel</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent in response to any command when the SMTP receiver prematurely terminates the connection. A common reason for this is receipt of a local shutdown command, due to a hardware reboot, for example.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>450</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested mail action not taken: mailbox unavailable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sent when a mailbox is busy due to another process accessing it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>451</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action aborted: local error in processing</p></td><td style="border-bottom: 0.5pt solid ; "><p>Local processing problem on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>452</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action not taken: insufficient system storage.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Time to clean out the server's hard disk!</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>500</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax error, command unrecognized</p></td><td style="border-bottom: 0.5pt solid ; "><p>Response to a bad command or one that was too long.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>501</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax error in parameters or arguments</p></td><td style="border-bottom: 0.5pt solid ; "><p/></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>502</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command not implemented</p></td><td style="border-bottom: 0.5pt solid ; "><p>Command is valid for SMTP in general but not supported by this particular server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>503</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad sequence of commands</p></td><td style="border-bottom: 0.5pt solid ; "><p>Commands were not sent in the correct order, such as sending the DATA command before the MAIL command.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>504</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command parameter not implemented.</p></td><td style="border-bottom: 0.5pt solid ; "><p/></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>550</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action not taken: mailbox unavailable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Generic response given due to a problem with a specified mailbox. This includes trying to send mail to an invalid address, refusal to relay to a remote mailbox, and so forth.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>551</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User not local; please try <span class="emphasis"><em>&lt;forward-path&gt;</em></span></p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the SMTP sender to try a different path; may be used to support mailbox forwarding.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>552</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested mail action aborted: exceeded storage allocation</p></td><td style="border-bottom: 0.5pt solid ; "><p>User's mailbox is full.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>553</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested action not taken: mailbox name not allowed</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specification of an invalid mailbox address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>554</p></td><td style="border-right: 0.5pt solid ; "><p>Transaction failed.</p></td><td style=""><p>General failure of a transaction.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="SMTP Multiple-Line Text Replies"><div class="titlepage"><div><div><h2 class="title"><a id="smtp_multiple-line_text_replies"/>SMTP Multiple-Line Text Replies</h2></div></div></div><p>As in FTP, it is possible for an SMTP reply to contain more than one line of text. In this case, each line starts with the reply code, and all lines but the last have a hyphen between the reply code and the reply text to indicate that the reply continues. The last line has a space between the reply code and reply text, just like a single-line reply. See the "Connection Establishment Using SMTP Extensions" section earlier in this chapter for an example of a multiple-line response to an EHLO command.</p></div><div class="sect2" title="Enhanced Status Code Replies"><div class="titlepage"><div><div><h2 class="title"><a id="enhanced_status_code_replies"/>Enhanced Status Code Replies</h2></div></div></div><p>When the ENHANCEDSTATUSCODES SMTP extension is enabled, this causes supplemental reply codes to be issued by the SMTP receiver in response to each command. These codes are similar in some respects to the standard reply codes; they also use three digits, but the digits are separated by periods. These enhanced codes provide more information about the results of operations, especially errors.</p><p>For example, if you try to issue a RCPT command specifying a remote mailbox on a server that does not support this feature, it will send back a 550 reply, which is a generic error meaning "requested action not taken: mailbox unavailable." When enhanced status codes are active, the response will be 550 5.7.1, which is the more specific message "delivery not authorized, request refused." A full description of these enhanced codes can be found in RFC 1893.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-460"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each time the SMTP sender issues a command, it receives a <span class="emphasis"><em>reply</em></span> from the SMTP receiver. SMTP replies are similar to FTP replies, using both a three-digit reply code and a descriptive text line. A special <span class="emphasis"><em>enhanced status codes</em></span> SMTP extension is also defined; when enabled, this causes the SMTP receiver to return more detailed result information after processing a command.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;78.&#xA0;TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_electronic_mail_access_and_retrie"/>Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e85462"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The Simple Mail Transfer Protocol (SMTP) is responsible for most of the process of sending an electronic mail (<a class="indexterm" id="idx-CHP-78-2787"/>email) message from the originator to the recipient. SMTP's job ends when the message has been successfully deposited into the recipient's mailbox on his local SMTP server.</p><p>In some cases, this mailbox is the end of the message's travels through cyberspace. More often, however, it is only a "rest stop"—the last step of the journey is for the message to be accessed and read by the user to whom it was sent. This may require that it be retrieved from the mailbox and transferred to another client machine. For a variety of reasons, SMTP is not used for the process of accessing a mailbox; instead, a special set of protocols and methods is designed specifically for email <a class="indexterm" id="idx-CHP-78-2788"/>access and retrieval.</p><p>In this chapter, I describe some of the more common techniques used for TCP/IP email access and retrieval. I begin with an overview of the subject that describes in general the different paradigms used for email access and gives an overview of the protocols.</p><p>I then describe the operation of the very popular Post Office Protocol (POP), focusing on version 3 (POP3). I look at the protocol in general terms, discussing its history, the various versions of the protocol, and the standards that define them. I describe POP3's general operation and the communication between a client and server, concentrating on the three main states through which the session transitions. I then describe each of these states in sequence: the <span class="emphasis"><em>Authorization</em></span> state, <span class="emphasis"><em>Transaction</em></span> state, and <span class="emphasis"><em>Update</em></span> state.</p><p>Following this, I discuss the other common mail access protocol: the Internet Message Access Protocol (IMAP). This includes a description of its benefits compared to the simpler POP3, a discussion of its operation, and a look at how client and server devices communicate, showing how the IMAP session moves through a series of four states.</p><p>Finally, I conclude with a discussion of two alternative methods of email access and retrieval. The first I call <span class="emphasis"><em>direct server access</em></span>, which describes several ways that mailboxes are accessed without the use of special remote-access protocols such as POP and IMAP. The second is email access using a web browser. This is the newest email access method and is growing in popularity every year.</p><div class="sect1" title="TCP/IP Email Mailbox Access Model, Method, and Protocol Overview"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_email_mailbox_access_model_method_"/>TCP/IP Email Mailbox Access Model, Method, and Protocol Overview</h1></div></div></div><p>In an ideal world, every device on the Internet would run SMTP server software, and that one protocol would be sufficient to implement the entire TCP/IP email system. You would compose email on your machine, your SMTP software would send it to a recipient's machine, and she would read it.</p><p>Here in the real world, however, this is not possible in general terms. An SMTP server must be connected to the Internet and available around the clock to receive email sent at any time by any of the millions of other computers in the world. Most of us either cannot or do not want to run machines continuously connected to the Internet, nor do we want to configure and maintain potentially complex SMTP software. For these reasons, a complete email exchange normally involves not two devices but four: A message is composed on the sender's client machine, and then transferred to the sender's SMTP server, then to the recipient's SMTP server, and finally to the recipient's machine.</p><p>The communication between SMTP servers is done with SMTP; so is the initial step of sending the email from the sender's machine to the sender's SMTP server. However, SMTP is not used for the last part of the process, which is accessing the recipient's mailbox. Instead, specific mailbox access and retrieval protocols and methods were devised.</p><p>Why not simply have mail wait on the recipient's SMTP server, and then have the mail sent to the recipient client device when it comes online, using SMTP? This isn't possible for two main reasons. First, SMTP was designed for the specific purpose of transporting only email. Having it responsible for client mailbox access would require adding more functionality, making it difficult to keep SMTP <span class="emphasis"><em>simple</em></span>. In the same vein, SMTP works on a <span class="emphasis"><em>push</em></span> model, with transactions being initiated by the sender. It would need changes to allow it to respond to requests from a client device that is only online intermittently.</p><p>The second reason is probably more important, because the current protocol configuration allows <span class="emphasis"><em>flexibility</em></span> in how email is accessed. If we used SMTP, all we would be able to do is transfer email to the recipient's client machine. This would be functional, but it would greatly limit the capabilities of how email is used, especially, for example, for users who wish to access mail directly on the server and manipulate it there. Also consider the problem of people with special requirements, such as those who travel and may need to access email from a number of different client devices. There is thus an advantage to providing more than one way to access a mailbox.</p><div class="sect2" title="Email Access and Retrieval Models"><div class="titlepage"><div><div><h2 class="title"><a id="email_access_and_retrieval_models"/>Email Access and Retrieval Models</h2></div></div></div><p><a class="indexterm" id="idx-CHP-78-2789"/>RFC 1733, "Distributed Electronic Mail Models in IMAP4," describes three different paradigms, or models, for mail access and retrieval:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-78-2790"/>Online Access Model</strong></span> We would all be using this mode of access in my ideal world scenario, where every machine was always connected to the Internet running an SMTP server. We would have constant, direct online access to our mailboxes. In the real world, this model is still used by some Internet users, especially those who have UNIX accounts or run their own SMTP servers. I call this <span class="emphasis"><em>direct server access</em></span>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-78-2791"/>Offline Access Model</strong></span> In this paradigm, a user establishes a connection to a server where his mailbox is located. The user downloads received messages to the client device and then deletes them from the server mailbox. All reading and other activity performed on the mail can be done offline once the mail has been retrieved.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-78-2792"/>Disconnected Access Model</strong></span> This is a hybrid of online and offline access. The user downloads messages from the server, so she can read or otherwise manipulate them without requiring a continuous connection to the server. However, the mail is not deleted from the server, as in the offline model. At some time in the future, the user connects back with the server and synchronizes any changes made on the local device with the mailbox on the server. What sort of changes can be made? Examples include marking whether or not a message has been read to keep track of read and unread mail, and marking messages to which the user has already replied. These are important tools to help those with busy mailboxes keep track of what they need to do.</p><p>None of the three models is entirely better than the others. Each has advantages and disadvantages, which is why it is good that we have these options rather than the single SMTP protocol for mail access.</p><p>Direct server access has the main benefits of instant speed and universal access from any location. As for disadvantages, you must be online to read mail, and it usually requires that you use UNIX email clients, which with most people are not familiar. However, IMAP can also be used for online access.</p><p>Offline access has the main advantages of simplicity and short connection time requirements; you can easily connect to the mailbox, download messages, and then read them locally. But that makes this method somewhat inflexible and poorly suited to access from different machines. Still, it is currently the most popular access method because simplicity is important; it is best typified by POP.</p><p>Disconnected access attempts to combine the advantages of offline and online access without combining their disadvantages, and it does a pretty good job. The advantages are significant: the ability to access mail quickly and use it offline, while retaining and updating the mailbox on the server to allow access from different client machines. IMAP is <a class="indexterm" id="idx-CHP-78-2793"/>popularly used for disconnected access. In the IMAP overview later in this chapter, I explore its advantages over offline access as well as its main disadvantages, which are complexity and far less universal support than POP (though acceptance of IMAP is slowly increasing).</p><p>Finally, in recent years, a somewhat new mailbox access method has become popular: email access using the World Wide Web. This technique allows a user to access his mailbox from any computer with an Internet connection and a web browser. It is a good example of line blurring, not only between the access models discussed here, but between TCP/IP applications—in this case, the Web and email.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-461"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> For flexibility, TCP/IP uses a variety of mailbox access and retrieval protocols and methods to allow users to read email. Three different models describe how these different methods work: the <span class="emphasis"><em>online model</em></span>, in which email is accessed and read on the server; the <span class="emphasis"><em>offline model</em></span>, in which mail is transferred to the client device and used there; and the <span class="emphasis"><em>disconnected model</em></span>, in which mail is retrieved and read offline but remains on the server with changes synchronized for consistency.</p></div></div></div></div>
<div class="sect1" title="TCP/IP Post Office Protocol (POP/POP3)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_post_office_protocol_poppop3"/>TCP/IP Post Office Protocol (POP/POP3)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-78-2794"/>The overall communication model used for TCP/IP email provides many options to an email user for accessing her electronic mailbox. The most popular access method today is the simple offline access model, in which a client device accesses a server, retrieves mail, and deletes it from the server. POP was designed for quick, simple, and efficient mail access; it is used by millions of people to access billions of email messages every day.</p><div class="sect2" title="POP Overview, History, Versions, and Standards"><div class="titlepage"><div><div><h2 class="title"><a id="pop_overview_history_versions_and_standa"/>POP Overview, History, Versions, and Standards</h2></div></div></div><p>Of the three mailbox access paradigms—online, offline, and disconnected—the offline model is probably the least capable in terms of features. And it is also the most popular. This may seem counterintuitive, but it is in fact a pattern that repeats itself over and over in the worlds of computing and networking. The reason is that <span class="emphasis"><em>simplicity</em></span> and <span class="emphasis"><em>ease of implementation</em></span> are keys to the success of any technology, and the offline mail access model beats the other two in these areas.</p><p>The history of offline email access goes back farther than one might expect—to the early 1980s. Two decades ago, not everyone and his brother were accessing the Internet to check email the way we do today. In fact, only a relatively small number of machines were connected using TCP/IP, and most users of these machines could access their email on a server, using the online access model.</p><p>However, even back then, developers recognized the advantages of being able to retrieve email from a server directly to a client computer, rather than accessing the mailbox on the server using Telnet or Network File System (NFS). In 1984, RFC 918 was published, defining POP. This protocol provided a simple way for a client computer to retrieve email from a mailbox on an SMTP server so it could be used locally.</p><p>The emphasis was on <span class="emphasis"><em>simple</em></span>. The RFC for this first version of POP is only five pages long, and the standard it defined is extremely rudimentary. It describes a simple sequence of operations in which a user provides a name and password for authentication and then downloads the entire contents of a mailbox. Simple is good, but simple has limits.</p><p>RFC 937, "Post Office Protocol - Version 2" was published in February 1985. POP2 expanded the capabilities of POP by defining a much richer set of commands and replies. This included the ability to read only certain messages, rather than dumping a whole mailbox. Of course, this came at the cost of a slight increase in protocol complexity, but POP2 was still quite simple as protocols go.</p><p>These two early versions of POP were used in the mid-1980s, but not very widely. Again, this is simply because the need for an offline email access protocol was limited at that time; most people were not using the Internet before the 1990s.</p><p>In 1988, RFC 1081 was published, describing POP3. By this time, the personal computer (PC) was transitioning from a curiosity to a place of importance in the worlds of computing and networking. POP3 was based closely on POP2, but the new version was refined and enhanced with the idea of providing a simple and efficient way for PCs and other clients not normally connected to the Internet to access and retrieve email.</p><p>Development on POP3 continued through the 1990s, with several new RFCs published every couple of years. RFC 1081 was made obsolete by, in turn, RFCs 1225, 1460, 1725, and 1939. Despite the large number of revisions, the protocol itself has not changed a great deal since 1988; these RFCs contain only relatively minor tweaks to the original description of the protocol. RFC 1939 was published in 1996, and POP3 has not been revised since that time, though a few subsequent RFCs define optional extensions and additions to the basic protocol, such as alternative authentication mechanisms.</p><p>While POP3 has been enhanced and refined, its developers have remained true to the basic idea of a very simple protocol for quick and efficient email transfer. POP3 is a straightforward state-based protocol, with a client and server proceeding through three stages during a session. A very small number of commands is defined to perform simple tasks, and even after all its changes and revisions, the protocol has a minimum of fluff.</p><p>For reasons that are unclear to me, almost everyone refers to POP with its version number—that is, they say <span class="emphasis"><em>POP3</em></span> instead of <span class="emphasis"><em>POP</em></span>. This is true despite most people not using version numbers with many other protocols, and almost no one using any other version of POP. But it is the convention, and I will follow it in the rest of this discussion.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-462"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> POP is currently the most popular TCP/IP email access and retrieval protocol. It implements the offline access model, allowing users to retrieve mail from their SMTP server and use it on their local client computers. It is specifically designed to be a simple protocol and has only a small number of commands. The current revision of POP is version 3, and the protocol is usually abbreviated <span class="emphasis"><em>POP3</em></span>.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-165"/>Note</h3><p><span class="emphasis"><em>Some implementations of POP attempt to implement the disconnected access model, with limited success. More often, however, IMAP is used for this purpose, since it is better suited to that access model. See the overview of IMAP later in this chapter for more details</em></span>.</p></div></div><div class="sect2" title="POP3 General Operation"><div class="titlepage"><div><div><h2 class="title"><a id="pop3_general_operation"/>POP3 General Operation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-78-2795"/><a class="indexterm" id="idx-CHP-78-2796"/>POP3 is a regular TCP/IP client/server protocol. In order to provide access to mailboxes, POP3 server software must be installed and continuously running on the server on which the mailboxes are located. This does not necessarily have to be the same physical hardware device that runs the SMTP server software that receives mail for those boxes—a mechanism such as NFS may be used to allow both the POP3 and SMTP servers to "see" mailboxes locally. POP3 clients are regular end-user email programs that make connections to POP3 servers to get mail; examples include Microsoft Outlook and Eudora Email.</p><p>POP3 uses TCP for communication, to ensure the reliable transfer of commands, <a class="indexterm" id="idx-CHP-78-2797"/>responses, and message data. POP3 servers listen on well-known port number 110 for incoming connection requests from POP3 clients. After a TCP connection is established, the POP3 session is activated. The client sends commands to the server, which replies with responses and/or email message contents.</p><p>POP3 commands are three or four letters long and are case-insensitive. They are all sent in plain ASCII text and terminated with a CRLF sequence, just as with FTP and SMTP commands. POP3 replies are also textual, but the protocol does not use the complex three-digit reply code mechanism of FTP (and SMTP). In fact, it defines only two basic responses:</p><p><span class="strong"><strong>+OK</strong></span> A positive response, sent when a command or action is successful</p><p><span class="strong"><strong>-ERR</strong></span> A negative response, sent to indicate that an error has occurred</p><p>These messages may be accompanied by explanatory text, especially in the case of an ERR response, to provide more information about the nature of the error.</p></div><div class="sect2" title="POP3 Session States"><div class="titlepage"><div><div><h2 class="title"><a id="pop3_session_states"/>POP3 Session States</h2></div></div></div><p><a class="indexterm" id="idx-CHP-78-2798"/>POP3 is described in terms of a <a class="indexterm" id="idx-CHP-78-2799"/><span class="emphasis"><em>finite state machine (FSM)</em></span>, with a session transitioning through three states during the course of its lifetime, as shown in <a class="xref" href="ch78s02.html#pop3_finite_state_machine_pop_uses_a_fin" title="Figure 78-1. POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.">Figure 78-1</a>. (I describe the concepts behind using FSM as a descriptive tool in <a class="xref" href="ch47.html" title="Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION">Chapter 47</a>.) Fortunately, unlike the FSMs of protocols like TCP, this one really is simple, because it is <span class="emphasis"><em>linear</em></span>. The session goes through each state once and only once, in the following sequence:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-78-2800"/>Authorization State</strong></span> The server provides a greeting to the client to indicate that it is ready for commands. The client then provides authentication information to allow access to the user's mailbox.</p></li><li class="listitem"><p><span class="strong"><strong>Transaction State</strong></span> The client is allowed to perform various operations on the mailbox. These include listing and retrieving messages and marking retrieved messages for deletion.</p></li><li class="listitem"><p><span class="strong"><strong>Update State</strong></span> When the client is finished with all of its tasks and issues the QUIT command, the <a class="indexterm" id="idx-CHP-78-2801"/>session enters this state automatically, where the server actually deletes the messages marked for deletion in the Transaction state. The session is then concluded, and the TCP connection between the two is terminated.</p></li></ol></div><div class="figure"><a id="pop3_finite_state_machine_pop_uses_a_fin"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e85736"/><img alt="POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated." src="httpatomoreillycomsourcenostarchimages288297.png.jpg"/></div></div><p class="title">Figure 78-1. POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.</p></div><p><a class="indexterm" id="idx-CHP-78-2802"/>POP3 is designed so that only certain <a class="indexterm" id="idx-CHP-78-2803"/>commands may be sent in each of these states. Here, I will describe the activities that take place in these three states, including the commands that are issued by the client in each.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-463"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> POP3 is a client/server protocol that is described using a simple linear sequence of states. A POP3 session begins with a POP3 client making a TCP connection to a POP3 server, at which point the session is in the <span class="emphasis"><em>Authorization</em></span> state. After successful authentication, the session moves to the <span class="emphasis"><em>Transaction</em></span> state, where the client can perform mail access transactions. When it is finished, the client ends the session and the <span class="emphasis"><em>Update</em></span> state is entered automatically, where cleanup functions are performed and the POP3 session ended.</p></div><div class="sect3" title="POP3 Authorization State: User Authentication Process and Commands"><div class="titlepage"><div><div><h3 class="title"><a id="pop3_authorization_state_user_authentica"/>POP3 Authorization State: User Authentication Process and Commands</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2804"/>A session between a POP3 client and a POP3 server begins when the client sends a TCP connection request to the server. The connection is established using the standard TCP three-way handshake, and the POP3 session commences. The first of the three states of a POP3 session, the Authorization state, is responsible for authenticating the POP3 client with the server.</p><p>When the session first enters this state, the server sends a greeting message to the client. This tells the client that the connection is alive and ready for the client to send the first command. An example of such a greeting follows:</p><a id="I_programlisting5_d1e85780"/><pre class="programlisting">+OK POP3 server ready</pre><p>The client is now required to authenticate the user who is trying to access a mailbox. This proves that the user has the right to access the server and identifies the user so the server knows which mailbox is being requested.</p><p>The normal method of authorization in POP3 is a standard user name/password login. This is pretty much identical to how a login is performed in FTP; even the commands are the same. First the client issues a USER command along with the user's mailbox name (his user name or email address). The server responds with an intermediate acknowledgment. The client then uses the PASS command to send the user's password. Assuming the login is valid, the server responds to the client with an acknowledgment that indicates successful authentication. The response will also typically specify the number of messages waiting for the user in the mailbox. This process is illustrated in <a class="xref" href="ch78s02.html#pop3_user_authentication_process_once_th" title="Figure 78-2. POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access.">Figure 78-2</a>.</p><div class="figure"><a id="pop3_user_authentication_process_once_th"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e85791"/><img alt="POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access." src="httpatomoreillycomsourcenostarchimages288299.png.jpg"/></div></div><p class="title">Figure 78-2. POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access.</p></div><p><a class="indexterm" id="idx-CHP-78-2805"/><a class="xref" href="ch78s02.html#example_of_pop3_authorization" title="Example 78-1. Example of POP3 authorization">Example 78-1</a> shows an example POP3 authorization, with the client's commands in boldface and the server's responses in italics.</p><div class="note" title="Note"><h3 class="title"><a id="note-166"/>Note</h3><p><span class="emphasis"><em>Some servers may require only the name of the user</em></span> (jane), <span class="emphasis"><em>while others require the full email address, as shown in <a class="xref" href="ch78s02.html#example_of_pop3_authorization" title="Example 78-1. Example of POP3 authorization">Example 78-1</a></em></span>.</p></div><div class="example"><a id="example_of_pop3_authorization"/><p class="title">Example 78-1. Example of POP3 authorization</p><div class="example-contents"><pre class="programlisting"><em class="replaceable"><code>+OK POP3 server ready</code></em>
<strong class="userinput"><code>USER jane@somewhereelse.com</code></strong>
<em class="replaceable"><code>+OK</code></em>
<strong class="userinput"><code>PASS *******</code></strong>
<em class="replaceable"><code>+OK jane@somewhereelse.com has 3 messages</code></em></pre></div></div><p>If authorization is successful, the POP3 session transitions to the Transaction state, where <a class="indexterm" id="idx-CHP-78-2806"/>mail-access commands can be performed. If the user name or password is incorrect, an error response is given, and the session cannot proceed. The authorization may also fail due to technical problems, such as an inability by the server to lock the mailbox (perhaps due to new mail arriving via SMTP).</p><p>Since user name/password authorization is considered by many people to be insufficient for the security needs of modern internetworks, the POP3 standard also defines an alternative authentication method using the APOP command. This is a more sophisticated technique based on the Message Digest 5 (MD5) encryption algorithm. If the server supports this technique, in its opening greeting it provides a string indicating a <span class="emphasis"><em>timestamp</em></span> that is unique for each POP3 session. The client then performs an MD5 calculation using this timestamp value and a shared secret known by the server and client. The result of this calculation is included in the client's APOP command. If it matches the server's calculation, authentication is successful; otherwise, the session remains in the Authorization state.</p><p>POP was also designed to be extendable through the addition of other authentication mechanisms. This process is based on the use of the optional AUTH command, as described in RFC 1734.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-464"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A POP3 session begins in the Authorization state, where the client device is expected to authenticate with the server. By default, POP3 uses only a simple user name/password authentication method. Optional authentication methods are also defined for applications requiring more security.</p></div></div><div class="sect3" title="POP3 Transaction State: Mail and Information Exchange Process and Commands"><div class="titlepage"><div><div><h3 class="title"><a id="pop3_transaction_state_mail_and_informat"/>POP3 Transaction State: Mail and Information Exchange Process and Commands</h3></div></div></div><p>Once the POP3 client has successfully authenticated the user who is performing mailbox access, the session transitions from the Authorization state to the Transaction state. There's no real mystery as to what this phase of the connection is all about: The POP3 client issues the commands that perform mailbox access and message retrieval transactions.</p><p>Most of the commands defined in POP3 are valid only in the Transaction state. <a class="xref" href="ch78s02.html#pop_transaction_commands" title="Table 78-1. POP3 Transaction Commands">Table 78-1</a> lists each of them, in the order in which they appear in RFC 1939.</p><div class="table"><a id="pop_transaction_commands"/><p class="title">Table 78-1. POP3 Transaction Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="POP3 Transaction Commands"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STAT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Status</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests status information for the mailbox. The server will normally respond, telling the client the number of messages in the mailbox and the number of bytes of data it contains. Optionally, more information may also be returned.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LIST</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>List Messages</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional message number</p></td><td style="border-bottom: 0.5pt solid ; "><p>Lists information for the messages in a mailbox; generally this means showing the message number and its size. If a message number is given, only that message's information is provided; otherwise, the full contents of the mailbox are described, one line at a time, with a line containing just a single period at the end.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RETR</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Retrieve</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message number</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retrieves a particular message from the mailbox. The server responds with a standard +OK message and then immediately sends the message in RFC 822 format, one line at a time. A line with a single period is sent after the last line.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DELE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Delete</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message number</p></td><td style="border-bottom: 0.5pt solid ; "><p>Marks a message as deleted. Once deleted, any further attempt to access a message (using LIST or RETR, for example) results in an error.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NOOP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No Operation</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Does nothing; the server just returns an +OK reply.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RSET</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reset</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Resets the session to the state it was in upon entry to the Transaction state. This includes undeleting any messages already marked for deletion.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TOP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Retrieve Message Top</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message number and number of lines</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows a client to retrieve only the beginning of a message. The server returns the headers of the message and only the first <span class="emphasis"><em>N</em></span> lines, where <span class="emphasis"><em>N</em></span> is the number of lines specified. This command is optional and may not be supported by all servers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>UIDL</p></td><td style="border-right: 0.5pt solid ; "><p>Unique ID Listing</p></td><td style="border-right: 0.5pt solid ; "><p>Optional message number</p></td><td style=""><p>If a message number was specified, returns a unique identification code for that message; otherwise, returns an identification code for each message in the mailbox. This command is optional and may not be supported by all servers.</p></td></tr></tbody></table></div></div><p>The Transaction state is relatively unstructured in that commands do not need to be issued in any particular order to meet the requirements of the standard. However, there is a natural progression to how a mailbox is retrieved, and that means the commands are usually used in the following order:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The client issues a STAT command to see the number of messages in the mailbox.</p></li><li class="listitem"><p>The client issues a LIST command, and the server tells it the number of each message to be retrieved.</p></li><li class="listitem"><p>The client issues a RETR command to get the first message and, if successful, marks it for deletion with DELE. The client uses RETR/DELE for each successive message.</p></li></ol></div><p><a class="xref" href="ch78s02.html#example_of_the_pop3_mail_exchange_proces" title="Example 78-2. Example of the POP3 mail exchange process">Example 78-2</a> and <a class="xref" href="ch78s02.html#pop3_mail_exchange_process_this_diagram_" title="Figure 78-3. POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)">Figure 78-3</a> show a sample access sequence for a mailbox containing two messages that total 574 bytes; the client's commands are in boldface and the server's responses are in italics.</p><div class="example"><a id="example_of_the_pop3_mail_exchange_proces"/><p class="title">Example 78-2. Example of the POP3 mail exchange process</p><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>STAT</code></strong>
<em class="replaceable"><code>+OK 2 574</code></em>
<strong class="userinput"><code>LIST</code></strong>
<em class="replaceable"><code>+OK</code></em>
<em class="replaceable"><code>1 414</code></em>
<em class="replaceable"><code>2 160</code></em>
<em class="replaceable"><code>.</code></em>
<strong class="userinput"><code>RETR 1</code></strong>
<em class="replaceable"><code>+OK</code></em>
<em class="replaceable"><code>(Message 1 is sent)</code></em>
<em class="replaceable"><code>.</code></em>
<strong class="userinput"><code>DELE 1</code></strong>
<em class="replaceable"><code>+OK message 1 deleted</code></em>
<strong class="userinput"><code>RETR 2</code></strong>
<em class="replaceable"><code>+OK</code></em>
<em class="replaceable"><code>(Message 2 is sent)</code></em>
<em class="replaceable"><code>.</code></em>
<strong class="userinput"><code>DELE 2</code></strong>
<em class="replaceable"><code>+OK message 2 deleted</code></em>
<strong class="userinput"><code>QUIT</code></strong></pre></div></div><p><a class="indexterm" id="idx-CHP-78-2807"/>The exact message sent in reply to each command is server-dependent; some say +OK, while others provide more descriptive text, as I have done here for the responses to the DELE command.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-465"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> After successful authorization, the POP3 session transitions to the Transaction state, where the client actually accesses email messages on the server. The client normally begins by first retrieving statistics about the mailbox from the server and obtaining a list of the messages in the mailbox. The client then retrieves each message one at a time, marking each retrieved message for deletion on the server.</p></div><p>In some cases, a POP3 client may be configured to <span class="emphasis"><em>not</em></span> delete messages after retrieving them. This is useful, for example, when Web-based access is being combined with a conventional email client program.</p></div><div class="sect3" title="POP3 Update State: Mailbox Update and Session Termination Process and Commands"><div class="titlepage"><div><div><h3 class="title"><a id="pop3_update_state_mailbox_update_and_ses"/>POP3 Update State: Mailbox Update and Session Termination Process and Commands</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2808"/>Once the POP3 client has completed all the email message access and retrieval transactions that it needs to perform, it isn't quite finished yet. The POP3 standard defines a final session state, the Update state, to perform various housekeeping functions, after which both the POP3 session and the underlying TCP connection are terminated.</p><p>The transition from the Transaction state to the Update state occurs when the POP3 client issues the QUIT command. This command has no parameters and serves to tell the POP3 server that the client is finished and wishes to end the session. The POP3 standard lists this command as part of its description of the Update state, though it is actually issued from the Transaction state.</p><div class="figure"><a id="pop3_mail_exchange_process_this_diagram_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e86109"/><img alt="POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)" src="httpatomoreillycomsourcenostarchimages288301.png.jpg"/></div></div><p class="title">Figure 78-3. POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)</p></div><p>After the POP3 server receives the QUIT command, it deletes any messages that were previously marked for deletion by the DELE command in the Transaction state. It's interesting to note that POP chose to implement this two-stage deletion process. The standard doesn't describe specifically why this was done, but it seems likely that it is a precaution to insure against accidental deletion and loss of <a class="indexterm" id="idx-CHP-78-2809"/>mail.</p><p>By delaying actual deletion until the Update state, the server can verify that it has received and processed all commands prior to the move to the Update state. This also allows the deletion of messages to be undone if necessary, using the RSET command, if the user changes her mind about the deletion prior to exiting the Transaction state. Finally, if any problem occurs with communication between the client and server that causes the TCP connection to be interrupted prematurely before the QUIT command is issued, no messages will be removed from the mailbox, giving the client a second chance to retrieve them in case they were not received properly.</p><p>Once the deleted messages have been removed, the server returns an acknowledgment to the client: +OK if the update was successful, or -ERR if there was a problem removing one or more of the deleted messages. Assuming no problems occurred, the +OK response will also contain a goodbye message of some sort, indicating that the session is about to be closed. The TCP connection between the client and server is then torn down and the session is done.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-466"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> When the POP3 client is done with its email transactions, it issues the QUIT command. This causes the Update state to be entered automatically, where the server performs necessary cleanup operations, including deleting any messages marked for deletion in the Transaction state.</p></div><p>A POP3 mail-retrieval session normally lasts a few seconds or minutes, but it can take many minutes if the mailbox is large and the connection between the client and server is slow. There is no limit on how long the client and server can be connected, as long as commands continue to be sent by the client. A POP3 server will normally implement an inactivity timer, however, which is customizable but must have a duration of no less than ten minutes. If the connection is idle for the full duration of the inactivity timer, the server assumes that the client has experienced some sort of a problem and shuts down the connection. If this occurs, the server does not delete any messages marked for deletion—again, this is to give the client another chance to retrieve those messages if a problem occurred getting them the first time.</p></div></div></div>
<div class="sect1" title="TCP/IP Internet Message Access Protocol (IMAP/IMAP4)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_internet_message_access_protocol_i"/>TCP/IP Internet Message Access Protocol (IMAP/IMAP4)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-78-2810"/>The offline mailbox access model provides the basic mail access functions that most users need. Using the popular POP3, a user can access her mailbox and retrieve messages so she can read them on her local machine. This model has the advantage of simplicity, but it does not provide many features that are increasingly in demand today, such as keeping track of the status of messages and allowing access from many client devices simultaneously. To provide better control over how mail is accessed and managed, we must use either the online or disconnected access models. IMAP was created to allow these access models to be used; it provides rich functionality and flexibility for the TCP/IP email user.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-467"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>The main price that IMAP pays for having a much richer set of functionality than POP is much more complexity. In this section, I have described IMAP in approximately the same level of detail that I did earlier for POP. Please see the appropriate RFC documents for the full description of the protocol and more discussion of some of its nuances, particularly the syntax of the many commands and parameters, which would take dozens of pages to cover fully here</em></span>.</p></div><div class="sect2" title="IMAP Overview, History, Versions, and Standards"><div class="titlepage"><div><div><h2 class="title"><a id="imap_overview_history_versions_and_stand"/>IMAP Overview, History, Versions, and Standards</h2></div></div></div><p>POP3 has become the most popular protocol for accessing TCP/IP mailboxes, not because of its rich functionality, but in spite of its lack of functionality. POP implements the offline mail access model, where mail is retrieved and then deleted from the server where the mailbox resides, so it can be used on a local machine. Millions of people use POP3 every day to access incoming mail. Unfortunately, due to the way the offline access model works, POP3 cannot be used for much else.</p><p>The online model is the one we would use in an ideal world, in which we all would be always connected to the Internet all the time. Offline access is a necessity, however, because most user client machines are connected to the Internet only periodically. The transfer of mail from the server to a client machine removes the requirement that we be online to perform mail functions, but it costs us the benefits of central mail storage on the server.</p><p>This may seem counterintuitive: how can it be better to have mail stored on some remote server rather than on our local computer? The main reason for this is flexibility of access. One of the biggest problems with offline access using POP3 is that mail is transferred permanently from a central server to one client machine. This is fine as long as an individual uses only that one machine, but what if the person has separate work and home computers or travels a great deal? And what about a mailbox shared by many users? These concerns have become more and more important in recent years.</p><p>Another issue is data security and safety. Mail servers run by Internet service providers (ISPs) are usually located in professionally managed data centers. They are carefully controlled and monitored, and backups occur on a routine basis. Most people do not take this sort of care with their own PCs and Macs, nor do they back up their data routinely. So, it's less likely that people will lose mail that on the server.</p><p>Of course, we still have the problem of not wanting to force users to be online all the time to access their mail. The solution is the disconnected mailbox access model, which marries the benefits of online and offline access. Mail is retrieved for local use as in the offline model, so the user does not need to be connected to the server continuously. However, changes made to the mailbox are synchronized between the client and the server. The mail remains on the server, where it can be accessed from a different client in the future, and the server acts as a permanent home base for the user's mail.</p><p>Recognizing these benefits, developers made some attempts to implement POP using the disconnected access model. Typically, this was done by using POP commands to retrieve mail but still leave it on the server, which is an option in many client programs. This works, but only to a limited extent; for example, keeping track of which messages are new or old becomes an issue when they are both retrieved and left on the server. POP simply lacks the features required for proper disconnected access because it was not designed for it.</p><p>In the mid-1980s, development began at <a class="indexterm" id="idx-CHP-78-2811"/>Stanford University on a new protocol that would provide a more capable way of accessing user mailboxes. The result was the Interactive Mail Access Protocol, later renamed the Internet Message Access Protocol (<a class="indexterm" id="idx-CHP-78-2812"/>IMAP).</p><div class="sect3" title="IMAP Features"><div class="titlepage"><div><div><h3 class="title"><a id="imap_features"/>IMAP Features</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2813"/>IMAP was designed for the specific purpose of providing flexibility in how users access email messages. It, in fact, can operate in all three of the access modes: online, offline, and disconnected access. Of these, the online and disconnected access modes are of interest to most users of the protocol; offline access is similar to how POP works.</p><p>IMAP allows a user to do all of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Access and retrieve mail from a remote server so it can be used locally while retaining it on the server.</p></li><li class="listitem"><p>Set message flags so that the user can keep track of which messages he has already seen, already answered, and so on.</p></li><li class="listitem"><p>Manage multiple mailboxes and transfer messages from one mailbox to another. You can organize mail into categories, which is useful for those working on multiple projects or those who are on various mailing lists.</p></li><li class="listitem"><p>Determine information about a message prior to downloading it, to decide whether or not to retrieve it.</p></li><li class="listitem"><p>Download only portions of a message, such as one body part from a MIME multipart message. This can be quite helpful in cases where large multimedia files are combined with short text elements in a single message.</p></li><li class="listitem"><p>Manage documents other than email. For example, IMAP can be used to access Usenet messages.</p></li></ul></div><p>Of course, there are some disadvantages to IMAP, but not many. One disadvantage is that it is more complex, but it's really not that complex, and the protocol has been around for enough years that this is not a big issue. The most important sticking point with IMAP is simply that it is used less commonly than POP, so providers that support it are not as easy to find as those that support POP. This is changing, however, as more people discover IMAP's benefits.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-468"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> POP is popular because of its simplicity and long <a class="indexterm" id="idx-CHP-78-2814"/>history, but it has few features and normally supports only the rather limited offline mail access method. To provide more flexibility for users in how they access, retrieve, and work with email messages, IMAP was developed. IMAP is used primarily in the online and disconnected access models. It allows users to access mail from many different devices, manage multiple mailboxes, select only certain messages for downloading, and much more. Due to its many capabilities, it is growing in popularity.</p></div></div><div class="sect3" title="IMAP History and Standards"><div class="titlepage"><div><div><h3 class="title"><a id="imap_history_and_standards"/>IMAP History and Standards</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2815"/>IMAP has had a rather interesting history—interesting in the sense that the normal orderly development process that is used for most TCP/IP protocols broke down. The result wasn't quite as bad as the chaos that occurred in the development of SNMP version 2 (see <a class="xref" href="ch65.html" title="Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW">Chapter 65</a>), but it was still unusual.<a class="indexterm" id="I_indexterm5_d1e86228"/></p><p>The first version of IMAP formally documented as an Internet standard was IMAP version 2 (IMAP2) in RFC 1064, published in July 1988. This was updated in RFC 1176, August 1990, retaining the same version number. However, it seems that some of the people involved with <a class="indexterm" id="idx-CHP-78-2816"/>IMAP were not pleased with RFC 1176, so they created a new document defining version 3 of IMAP (IMAP3): RFC 1203, published in February 1991. This is described by its authors as a "counter proposal."</p><p>For whatever reason, however, IMAP3 was never accepted by the marketplace. Instead, people kept using IMAP2 for a while. An extension to the protocol was later created, called IMAP2<a class="indexterm" id="idx-CHP-78-2817"/>bis, which added support for Multipurpose Internet Mail Extensions (MIME) to IMAP. This was an important development due to the usefulness of MIME, and many implementations of IMAP2bis were created. Despite this, for some reason IMAP2bis was never published as an RFC. This may have been due to the problems associated with the publishing of IMAP3.</p><div class="note" title="Note"><h3 class="title"><a id="note-167"/>Note</h3><p><span class="emphasis"><em>bis is a Latin word meaning again. It is sometimes used to differentiate changed technical documents from their previous versions when no official new version number is allocated</em></span>.</p></div><p>In December 1994, IMAP version 4 (IMAP4) was published in two RFCs: RFC 1730 describing the main protocol, and RFC 1731 describing authentication mechanisms for IMAP4. IMAP4 is the current version of IMAP that is widely used today. It continues to be refined; the latest specific version is actually called version 4rev1 (IMAP4rev1), defined in RFC 2060, and then most recently by RFC 3501. Most people still just call this <span class="emphasis"><em>IMAP4</em></span>, and that's what I will do in the rest of this section.</p></div></div><div class="sect2" title="IMAP General Operation"><div class="titlepage"><div><div><h2 class="title"><a id="imap_general_operation"/>IMAP General Operation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-78-2818"/>IMAP4 is a standard client/server protocol like POP3 and most other TCP/IP application protocols. For the protocol to function, an IMAP4 server must be operating on the server where user mailboxes are located. Again, as with POP3, this does not necessarily need to be the same physical server that provides SMTP service. The mailbox must in some way be made accessible to both SMTP for incoming mail, and to IMAP4 for message retrieval and modification. A mechanism for ensuring exclusive access to avoid interference between the various protocols is also needed.</p><p>IMAP4 uses the Transmission Control Protocol (TCP) for communication. This ensures that all commands and data are sent reliably and received in the correct order. IMAP4 servers listen on well-known port number 143 for incoming connection requests from IMAP4 clients. After a TCP connection is established, the IMAP4 session begins.</p></div><div class="sect2" title="IMAP Session States"><div class="titlepage"><div><div><h2 class="title"><a id="imap_session_states"/>IMAP Session States</h2></div></div></div><p><a class="indexterm" id="idx-CHP-78-2819"/>The session between an IMAP4 client and server is described in the IMAP standards using an <a class="indexterm" id="idx-CHP-78-2820"/>FSM. Again, this is similar to how POP3 operates, except that IMAP4 is a bit more complex. Its FSM defines four states instead of three, and where a POP3 session is linear (going through each state only once) in IMAP4 the session is not. However, the state flow is still fairly straightforward, mostly following a logical sequence from one state to the next. The IMAP FSM is illustrated in <a class="xref" href="ch78s03.html#imap_fsm_the_imap_fsm_is_slightly_more_c" title="Figure 78-4. IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in Figure 78-1) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.">Figure 78-4</a>.</p><div class="figure"><a id="imap_fsm_the_imap_fsm_is_slightly_more_c"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e86290"/><img alt="IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in ) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state." src="httpatomoreillycomsourcenostarchimages288303.png.jpg"/></div></div><p class="title">Figure 78-4. IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in <a class="xref" href="ch78s02.html#pop3_finite_state_machine_pop_uses_a_fin" title="Figure 78-1. POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.">Figure 78-1</a>) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.</p></div><p>The following are the <a class="indexterm" id="idx-CHP-78-2821"/>IMAP states, in the usual sequence in which they occur for a session:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Not <a class="indexterm" id="idx-CHP-78-2822"/>Authenticated State</strong></span> The session normally begins in this state after a TCP connection is established, unless the special IMAP <span class="emphasis"><em>preauthentication</em></span> feature has been used (we'll get to this feature shortly). At this point, the client cannot really do much aside from providing authentication information so it can move to the next state.</p></li><li class="listitem"><p><span class="strong"><strong>Authenticated State</strong></span> The client has completed authentication, either through an authentication process in the prior state or through preauthentication. The client is now allowed to perform operations on whole mailboxes. The client must select a mailbox before individual message operations are permitted.</p></li><li class="listitem"><p><span class="strong"><strong>Selected State</strong></span> After a mailbox has been chosen, the client is allowed to access and manipulate individual messages within the mailbox. When the client is finished with the current mailbox, it can close it and return to the Authenticated state to select a new one to work with, or it can log out to end the session.</p></li><li class="listitem"><p><span class="strong"><strong>Logout State</strong></span> The client may issue a Logout command from any of the other states to request that the IMAP session be ended. The session may also enter this state if the session inactivity timer expires. The server sends a response, and the connection is terminated.</p></li></ol></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-469"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IMAP is a client/server application, and an IMAP session begins with the client making a TCP connection to the server. The session then normally starts in the Not Authenticated state and remains there until successful authentication. In the Authenticated state, the client may perform operations on whole mailboxes, but a mailbox must be selected to transition to the Selected state, where individual messages can be manipulated. The client can work with many mailboxes by selecting each one in turn; it then logs out from the server.</p></div><p>Of the four IMAP states, only the first three are <span class="emphasis"><em>interactive</em></span>, meaning states in which commands are actively issued by the client and responses provided by the server. Some IMAP commands can be used while the session is in any state; others are state-specific.</p><div class="sect3" title="Session Establishment and Greeting"><div class="titlepage"><div><div><h3 class="title"><a id="session_establishment_and_greeting"/>Session Establishment and Greeting</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2823"/>The server determines in which state the IMAP session begins and sends a <span class="emphasis"><em>greeting</em></span> message to tell the client the session is established and indicate which state it is in. Normally, the server will begin the session in the Not Authenticated state. This is conveyed to the client with the normal OK greeting message, such as this:</p><a id="I_programlisting5_d1e86354"/><pre class="programlisting">* OK &lt;<em class="replaceable"><code>server-name</code></em>&gt; server ready</pre></div><div class="sect3" title="Preauthentication"><div class="titlepage"><div><div><h3 class="title"><a id="preauthentication"/>Preauthentication</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2824"/>In certain circumstances, a server may already know the identity of the client, perhaps as a result of some external authentication mechanism not part of the IMAP protocol. In this case, a special greeting is used:</p><a id="I_programlisting5_d1e86367"/><pre class="programlisting">* PREAUTH &lt;<em class="replaceable"><code>server-name</code></em>&gt; server ready, logged in as &lt;<em class="replaceable"><code>user-name</code></em>&gt;</pre><p>This tells the client that it is already in the Authenticated state.</p><p>If the server decides for whatever reason not to accept a new session from the client, it can respond with a BYE response, instead of OK or PREAUTH, and close the TCP connection.</p></div></div><div class="sect2" title="IMAP Commands, Results, and Responses"><div class="titlepage"><div><div><h2 class="title"><a id="imap_commands_results_and_responses"/>IMAP Commands, Results, and Responses</h2></div></div></div><p>Once an IMAP session is established, all communication between the client and server takes place in the form of <span class="emphasis"><em>commands</em></span> sent by the client and <span class="emphasis"><em>responses</em></span> returned by the server. Like POP3, commands and responses are sent as strings of ASCII text and terminated with a CRLF sequence, making them compatible with the way data is sent using the Telnet Protocol. However, IMAP has a few differences from POP and many other TCP/IP application protocols.</p><p>The first interesting thing about IMAP commands is that most are not abbreviated into codes of three or four letters—they are spelled out in full. So where POP3 has a STAT command, the command in IMAP is called STATUS. Commands are normally shown in uppercase, as I do in this book, but they are case-insensitive.</p><p>IMAP also uses an interesting system of <a class="indexterm" id="idx-CHP-78-2825"/><span class="emphasis"><em>command tagging</em></span> to match client commands explicitly with certain server responses. Each time a client sends a command, it prefixes it with a tag that is unique for the particular session. The tags are usually short strings with a monotonically increasing number in them; the examples in the IMAP standards have the first command tagged a0001, the second a0002, and so on. That said, as long as each command is uniquely labeled, it doesn't matter what tagging scheme is used. When the server needs to send a response that is specific to a command, it tags the reply with the appropriate command tag. Not all replies are tagged, however.</p><p>The standard doesn't state explicitly why this tagging scheme is needed, but I believe it is probably related to IMAP's multiple command feature. IMAP clients are allowed to send a sequence of commands to the server to be processed, rather than sending commands only one at a time. This can improve performance when certain commands would take a long time to complete. The only restriction is that the commands must be independent enough that the result of executing them all would be the same, regardless of the order in which they were processed. For example, sending a command to read a particular entity in combination with a command to store a value into the same entity is not allowed.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-470"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IMAP tags its commands with a unique identifier. These tags can then be used in replies by the server to match replies with the commands to which they correspond. This enables multiple commands to be sent to an IMAP server in succession.</p></div><div class="sect3" title="Command Groups"><div class="titlepage"><div><div><h3 class="title"><a id="command_groups"/>Command Groups</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2826"/>IMAP commands are organized into groups based on which session states the IMAP session may be in when they are used:</p><p><span class="strong"><strong>"Any State" Commands</strong></span> A small number of commands that can be used at any time during an IMAP session.</p><p><span class="strong"><strong>Not Authenticated State Commands</strong></span> Commands that can be used only in the Not Authenticated state. They are usually used for authentication, of course.</p><p><span class="strong"><strong>Authenticated State Commands</strong></span> Commands used to perform various actions on mailboxes. (Note that despite the name, these commands can also be used in the Selected state.)</p><p><span class="strong"><strong>Selected State</strong></span> A set of commands for accessing and manipulating individual messages that can be used only in the Selected state.</p><p>The reason for having the distinct Authenticated and Selected states and command groups is that IMAP is designed specifically to enable the manipulation of multiple mailboxes. After the session starts and the client is authenticated, the client is allowed to issue commands that work with entire mailboxes. However, it may not issue commands that manipulate individual messages until it tells the server which mailbox it wants to work with, which puts it in the Selected state. The client can also issue mailbox commands from the Selected state.</p><div class="note" title="Note"><h3 class="title"><a id="note-168"/>Note</h3><p><span class="emphasis"><em>In addition to these four state groups, the standard also defines an extension mechanism that allows new commands to be defined. These must begin with the letter X</em></span>.</p></div></div><div class="sect3" title="&quot;Any State&quot; Commands"><div class="titlepage"><div><div><h3 class="title"><a id="any_state_commands"/>"Any State" Commands</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2827"/><a class="xref" href="ch78s03.html#imap_any_state_commands" title="Table 78-2. IMAP &quot;Any State&quot; Commands">Table 78-2</a> describes the IMAP "any state" commands, which can be used whenever needed.</p><div class="table"><a id="imap_any_state_commands"/><p class="title">Table 78-2. IMAP "Any State" Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IMAP &quot;Any State&quot; Commands"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>CAPABILITY</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Asks the server to tell the client what capabilities and features it supports.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NOOP (No Operation)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Does nothing. May be used to reset the inactivity timer or to prompt the server periodically to send notification if new messages arrive.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>LOGOUT</p></td><td style="border-right: 0.5pt solid ; "><p>None</p></td><td style=""><p>Tells the server that the client is done and ready to end the session, which transitions to the Logout state for termination.</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Results and Responses"><div class="titlepage"><div><div><h3 class="title"><a id="results_and_responses"/>Results and Responses</h3></div></div></div><p>Each command sent by the IMAP client elicits some sort of reaction from the IMAP server. The server takes action based on what the client requested and then returns one or more text strings to indicate what occurred. The server can send two types of replies after a command is received:</p><p><span class="strong"><strong>Result</strong></span> A reply usually indicating the status or disposition of a command. It may be tagged with the command tag of the command whose result it is communicating, or it may be a general message that is not tagged.</p><p><span class="strong"><strong>Response</strong></span> Any type of information that is being sent by the server to the client. It is usually not tagged with a command tag and is not specifically intended to indicate server status.</p><div class="note" title="Note"><h3 class="title"><a id="note-169"/>Note</h3><p><span class="emphasis"><em>The IMAP standards sometimes use the terms result, response, and reply in a manner that I find to be inconsistent. Watch out for this if you examine the IMAP RFCs</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-471"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IMAP servers issue two basic types of replies to client commands: <span class="emphasis"><em>results</em></span> are replies that indicate the success, failure, or status of a command; <span class="emphasis"><em>responses</em></span> are general replies containing many different types of information that the server needs to send to the client.</p></div></div><div class="sect3" title="Result Codes"><div class="titlepage"><div><div><h3 class="title"><a id="result_codes"/>Result Codes</h3></div></div></div><p>Three main <a class="indexterm" id="idx-CHP-78-2828"/>result codes are sent in reply to a command, and two special ones are used in certain circumstances:</p><p><span class="strong"><strong>OK</strong></span> A positive result to a command, usually sent with the tag of the command that was successful. May be sent untagged in the server's initial greeting when a session starts.</p><p><span class="strong"><strong>NO</strong></span> A negative result to a command. When tagged, indicates the command failed; when untagged, serves as a general warning message about some situation on the server.</p><p><span class="strong"><strong>BAD</strong></span> Indicates an error message. It is tagged when the error is directly related to a command that has been sent and otherwise is untagged.</p><p><span class="strong"><strong>PREAUTH</strong></span> An untagged message sent at the start of a session to indicate that no authentication is required; the session goes directly to the Authenticated state.</p><p><span class="strong"><strong>BYE</strong></span> Sent when the server is about to close the connection. It is always untagged and is sent in reply to a Logout command or when the connection is to be closed for any other reason.</p></div><div class="sect3" title="Response Codes"><div class="titlepage"><div><div><h3 class="title"><a id="response_codes"/>Response Codes</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2829"/>In contrast to results, responses are used to communicate a wide variety of information to the client device. Responses normally include descriptive text that provides details about what is being communicated. They may be sent either directly in reply to a command or incidentally to one. An example of the latter case would be if a new message arrives in a mailbox during a session. In this case, the server will convey this information unilaterally at its first opportunity, regardless of what command was recently sent.</p><p>The following are the response codes defined by the IMAP standard:</p><p><span class="strong"><strong>ALERT</strong></span> An alert message to be sent to the human user of the IMAP client to inform him of something important.</p><p><span class="strong"><strong>BADCHARSET</strong></span> Sent when a search fails due to use of an unsupported character set.</p><p><span class="strong"><strong>CAPABILITY</strong></span> A list of server capabilities may be sent as part of the initial server greeting so the CAPABILITY command does not need to be used.</p><p><span class="strong"><strong>PARSE</strong></span> Sent when an error occurs parsing the headers or MIME content of an email message.</p><p><span class="strong"><strong>PERMANENTFLAGS</strong></span> Communicates a list of message status flags that the client is allowed to manipulate.</p><p><span class="strong"><strong>READ-ONLY</strong></span> Tells the client that the mailbox is accessible only in a read-only mode.</p><p><span class="strong"><strong>READ-WRITE</strong></span> Tells the client that the mailbox is accessible in read-write mode.</p><p><span class="strong"><strong>TRYCREATE</strong></span> Sent when an APPEND or COPY command fails due to the target mailbox not existing, to suggest to the client that it try creating the mailbox first.</p><p><span class="strong"><strong>UIDNEXT</strong></span> Sent with a decimal number that specifies the next unique identifier value to use in an operation. These identifiers allow each message to be uniquely identified.</p><p><span class="strong"><strong>UIDVALIDITY</strong></span> Sent with a decimal number that specifies the unique identifier validity value, used to confirm unique message identification.</p><p><span class="strong"><strong>UNSEEN</strong></span> Sent with a decimal number that tells the client the message that is flagged as not yet seen (a new message).</p></div></div><div class="sect2" title="IMAP Not Authenticated State: User Authentication Process and Commands"><div class="titlepage"><div><div><h2 class="title"><a id="imap_not_authenticated_state_user_authen"/>IMAP Not Authenticated State: User Authentication Process and Commands</h2></div></div></div><p><a class="indexterm" id="idx-CHP-78-2830"/>An IMAP4 session begins with an IMAP4 client establishing a TCP connection with an IMAP4 server. Under normal circumstances, the IMAP4 server has no idea who the client is, and therefore starts the session in the Not Authenticated state. For security reasons, the client is not allowed to do anything until it is authenticated. Thus, the only purpose of this state is to allow the client to present valid credentials so the session can move on to the Authenticated state.</p><div class="sect3" title="IMAP Authentication Methods"><div class="titlepage"><div><div><h3 class="title"><a id="imap_authentication_methods"/>IMAP Authentication Methods</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2831"/>The IMAP4 standard defines three different mechanisms by which a client may authenticate itself. These are implemented using one or more of the three different commands allowed only in the Not Authenticated state, which are shown in <a class="xref" href="ch78s03.html#imap_not_authenticated_state_commands" title="Table 78-3. IMAP Not Authenticated State Commands">Table 78-3</a>.</p><div class="table"><a id="imap_not_authenticated_state_commands"/><p class="title">Table 78-3. IMAP Not Authenticated State Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IMAP Not Authenticated State Commands"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-78-2832"/>Command</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LOGIN</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User name and password</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies a user name and password to use for authentication.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AUTHENTICATE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Authentication mechanism name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tells the server that the client wants to use a particular authentication mechanism and prompts the client and server to exchange authentication information appropriate for that mechanism.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>STARTTLS</p></td><td style="border-right: 0.5pt solid ; "><p>None</p></td><td style=""><p>Tells the IMAP4 server to use the Transport Layer Security (TLS) protocol for authentication, and prompts TLS negotiation to begin.</p></td></tr></tbody></table></div></div><p>In response to a LOGIN or AUTHENTICATE command, the server will send an OK message if the authentication was successful, and then transition to the Authenticated state. It will send a NO response if authentication failed due to incorrect information. The client can then try another method of authenticating or terminate the session with the LOGOUT command.</p><p>The three authentication methods are as follows:</p><p><span class="strong"><strong>Plain Login</strong></span> This is the typical user name/password technique, using the LOGIN command by itself. This is similar to the simple scheme used in POP3, except that in IMAP4 one command is used to send both the user name and password. Since the command and parameters are sent in plain text, this is by far the least secure method of authentication and is not recommended by the standard unless some other means is used in conjunction.</p><p><span class="strong"><strong>TLS Login</strong></span> This is a secure login where the Transport Layer Security (TLS) protocol is first enabled with the STARTTLS command, and then the LOGIN command can be used securely. Note that STARTTLS only causes the TLS negotiation to begin and does not itself cause the IMAP client to be authenticated. Either LOGIN or AUTHENTICATE must still be used.</p><p><span class="strong"><strong>Negotiated Authentication Method</strong></span> The AUTHENTICATE command allows the client and server to use any authentication scheme that they both support. The server may indicate which schemes it supports in response to a CAPABILITY command. After specifying the authentication mechanism to be used, the server and client exchange authentication information as required by the mechanism specified. This may require one or more additional lines of data to be sent.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-472"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> IMAP supports three basic types of authentication: a plain user name/password login, authentication using the Transport Layer Security (TLS) protocol, or the negotiation of some other authentication method between the client and server. In some cases, the IMAP server may choose to preauthenticate clients that it is able to identify reliably; in which case, the Not Authenticated state is skipped entirely.</p></div></div></div><div class="sect2" title="IMAP Authenticated State: Mailbox Manipulation/Selection Process and Commands"><div class="titlepage"><div><div><h2 class="title"><a id="imap_authenticated_state_mailbox_manipul"/>IMAP Authenticated State: Mailbox Manipulation/Selection Process and Commands</h2></div></div></div><p><a class="indexterm" id="idx-CHP-78-2833"/>In the normal progression of an IMAP session, the Authenticated state is the first state in which the IMAP client is able to perform useful work on behalf of its user. This state will normally be reached from the Not Authenticated state after successful authentication using the LOGIN or AUTHENTICATE command. Alternately, a server may preauthenticate a client and begin the session in this state directly.</p><p>Once in the Authenticated state, the client is considered authorized to issue commands to the server. However, it may issue only commands that deal with <span class="emphasis"><em>whole mailboxes</em></span>. As mentioned in the general operation overview, IMAP was created to allow access to, and manipulation of, multiple mailboxes. For this reason, the client must specify dynamically which mailbox it wants to use before commands dealing with individual messages may be given. This is done in this state using the SELECT or EXAMINE command, which both cause a transition to the Selected state.</p><p>It is also possible that the Authenticated state can be reentered during the course of a session. If the CLOSE command is used from the Selected state to close a particular mailbox, the server will consider that mailbox deselected, and the session will transition back to the Authenticated state until a new selection is made. The same can occur if a new SELECT or EXAMINE command is given from the Selected state but fails.</p><div class="sect3" title="Authenticated State Commands"><div class="titlepage"><div><div><h3 class="title"><a id="authenticated_state_commands"/>Authenticated State Commands</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2834"/><a class="xref" href="ch78s03.html#imap_authenticated_state_commands" title="Table 78-4. IMAP Authenticated State Commands">Table 78-4</a> provides a brief description of the mailbox-manipulation commands that can be used in the Authenticated state.</p><div class="table"><a id="imap_authenticated_state_commands"/><p class="title">Table 78-4. IMAP Authenticated State Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IMAP Authenticated State Commands"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SELECT</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Selects a particular mailbox so that messages within it can be accessed. If the command is successful, the session transitions to the Selected state. The server will also normally respond with information for the client about the selected mailbox, as described after this table.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>EXAMINE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>The same as the SELECT command, except that the mailbox is opened read-only; no changes are allowed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>CREATE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a mailbox with the given name.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DELETE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes the specified mailbox.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RENAME</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Current and new mailbox names</p></td><td style="border-bottom: 0.5pt solid ; "><p>Renames a mailbox.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SUBSCRIBE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Adds the mailbox to the server's set of active mailboxes. This is sometimes used when IMAP4 is employed for Usenet message access.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>UNSUBSCRIBE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes the mailbox from the active list.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LIST</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name or reference string</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests a partial list of available mailbox names, based on the parameter provided.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LSUB</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name or reference string</p></td><td style="border-bottom: 0.5pt solid ; "><p>The same as LIST but returns only names from the active list.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STATUS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Requests the status of the specified mailbox. The server responds providing information such as the number of messages in the box and the number of recently arrived and unseen messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>APPEND</p></td><td style="border-right: 0.5pt solid ; "><p>Mailbox name, message, optional flags, and date/time</p></td><td style=""><p>Adds a message to a mailbox.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-170"/>Note</h3><p><span class="emphasis"><em>All of the commands in <a class="xref" href="ch78s03.html#imap_authenticated_state_commands" title="Table 78-4. IMAP Authenticated State Commands">Table 78-4</a> may also be used in the Selected state; they should really be called Authenticated+Selected state commands</em></span><a class="indexterm" id="idx-CHP-78-2835"/>.</p></div><p>When either the SELECT or EXAMINE command is successfully issued, the server will return to the client a set of useful information about the mailbox, which can be used to guide commands issued from the Selected state. This information includes the following three mandatory responses:</p><p><span class="strong"><strong>&lt;<span class="emphasis"><em>n</em></span>&gt; EXISTS</strong></span> Tells the client the number of messages in the mailbox.</p><p><span class="strong"><strong>&lt;<span class="emphasis"><em>n</em></span>&gt; RECENT</strong></span> Tells the client the number of recently arrived (new) messages.</p><p><span class="strong"><strong>FLAGS (&lt;<span class="emphasis"><em>flag-list</em></span>&gt;)</strong></span> Tells the client which flags are supported in the mailbox. These include the following: <code class="literal">\Seen</code>, <code class="literal">\Answered</code>, <code class="literal">\Flagged</code> (marked for special attention), <code class="literal">\Deleted</code>, <code class="literal">\Draft</code>, and <code class="literal">\Recent</code>. (The backslashes are part of the flag names.)</p><p>The reply from the server may also contain these optional replies:</p><p><span class="strong"><strong>UNSEEN &lt;<span class="emphasis"><em>n</em></span>&gt;</strong></span> The message number of the first unseen message.</p><p><span class="strong"><strong>PERMANENTFLAGS (&lt;<span class="emphasis"><em>flag-list</em></span>&gt;)</strong></span> A list of flags (as for the FLAGS response above) that the client is allowed to change.</p><p><span class="strong"><strong>UIDNEXT &lt;<span class="emphasis"><em>n</em></span>&gt;</strong></span> The next unique identifier value. This is used to check for changes made to the mailbox since the client last accessed it.</p><p><span class="strong"><strong>UIDVALIDITY &lt;<span class="emphasis"><em>n</em></span>&gt;</strong></span> The unique identifier validity value, used to confirm valid UID values.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-473"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the Authenticated state, the IMAP client can perform operations on whole mailboxes, such as creating, renaming, or deleting mailboxes, or listing mailbox contents. The SELECT and EXAMINE commands are used to tell the IMAP server which mailbox the client wants to open for message-specific access. Successful execution of either command causes the server to provide the client with several pieces of important information about the mailbox, after which the session transitions to the <a class="indexterm" id="idx-CHP-78-2836"/>Selected state.</p></div></div></div><div class="sect2" title="IMAP Selected State: Message Manipulation Process and Commands"><div class="titlepage"><div><div><h2 class="title"><a id="imap_selected_state_message_manipulation"/>IMAP Selected State: Message Manipulation Process and Commands</h2></div></div></div><p>Once the IMAP client has been authorized to access the server, it enters the Authenticated state, where it is allowed to execute tasks on whole mailboxes. Since IMAP allows multiple mailboxes to be manipulated, message-specific commands cannot be used until the client tells the server which mailbox in wants to work with. Only one mailbox can be accessed at a time in a given session.</p><p>After the SELECT or EXAMINE command is successfully issued, the session enters the Selected state. In this state, the full palette of message and mailbox commands is available to the client. This includes the message-specific commands in <a class="xref" href="ch78s03.html#imap_selected_state_commands" title="Table 78-5. IMAP Selected State Commands">Table 78-5</a> as the mailbox commands defined for the Authenticated state. Most of IMAP's message-specific commands do not include a mailbox name as a parameters, since the server knows automatically that the commands apply to whatever mailbox was selected in the Authenticated state.</p><p>The session remains in the Selected state for as long as the client continues to have work to do with the particular selected (or examined) mailbox. Three different actions can cause a transition out of the Selected state:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the client has nothing more to do when it is done with the current mailbox, it can use the LOGOUT command to end the session.</p></li><li class="listitem"><p>The client can use the CLOSE command to tell the server it is finished with the current mailbox but keep the session active. The server will close the mailbox, and the session will go back to the Authenticated state.</p></li><li class="listitem"><p>The client can issue a new SELECT or EXAMINE command, which will implicitly close the current mailbox and then open the new one. The transition in this case is from the Selected state back to the Selected state, but with a new current mailbox.</p></li></ul></div><div class="sect3" title="Selected State Commands"><div class="titlepage"><div><div><h3 class="title"><a id="selected_state_commands"/>Selected State Commands</h3></div></div></div><p><a class="indexterm" id="idx-CHP-78-2837"/><a class="xref" href="ch78s03.html#imap_selected_state_commands" title="Table 78-5. IMAP Selected State Commands">Table 78-5</a> lists the message-specific commands that can be used only in the Selected state.</p><div class="table"><a id="imap_selected_state_commands"/><p class="title">Table 78-5. IMAP Selected State Commands</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="IMAP Selected State Commands"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>CHECK</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets a checkpoint for the current mailbox. This is used to mark when a certain sequence of operations has been completed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>CLOSE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Explicitly closes the current mailbox and returns the session to the Authenticated <a class="indexterm" id="idx-CHP-78-2838"/>state. When this command is issued, the server will also implicitly perform an EXPUNGE operation on the mailbox.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>EXPUNGE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>None</p></td><td style="border-bottom: 0.5pt solid ; "><p>Permanently removes any messages that were flagged for deletion by the client. This is done automatically when a mailbox is closed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SEARCH</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Search criteria and an optional character set specification</p></td><td style="border-bottom: 0.5pt solid ; "><p>Searches the current mailbox for messages matching the specified search criteria. The server response lists the message numbers meeting the criteria.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>FETCH</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of message numbers and a list of message data items (or a macro)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retrieves information about a message or set of messages from the current mailbox.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>STORE</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of message numbers, message data item name, and value</p></td><td style="border-bottom: 0.5pt solid ; "><p>Stores a value for a particular message data item for a set of messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>COPY</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of message numbers and a mailbox name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Copies the set of messages specified to the end of the specified mailbox.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>UID</p></td><td style="border-right: 0.5pt solid ; "><p>Command name and arguments</p></td><td style=""><p>Used to allow one of the other commands above to be performed using unique identifier numbers for specifying the messages to be operated on, rather than the usual message sequence numbers.</p></td></tr></tbody></table></div></div><p>The list in <a class="xref" href="ch78s03.html#imap_selected_state_commands" title="Table 78-5. IMAP Selected State Commands">Table 78-5</a> might seem surprisingly short. You might wonder, for example, where the specific commands are to read a message header or body, delete a message, mark a message as read, and so forth. The answer is that these (and much more) are all implemented as part of the powerful and flexible FETCH and STORE commands.</p><p>The FETCH command can be used to read a number of specific elements from either one message or a sequence of messages. The list of message data items specifies what information is to be read. The data items that can be read include the headers of the message, the message body, flags that are set for the message, the date of the message, and much more. The FETCH command can even be used to retrieve part of a message, such as one body part of a MIME multipart message, making it very useful indeed. Special macros are also defined for convenience. For example, the client can specify the message data item FULL to get all the data associated with a message.</p><p>The complement to FETCH, the STORE command, is used to make changes to a message. However, this command does not modify the basic message information such as the content of headers and the message body. Rather, it exists for changing the message's status flags. For example, after replying to a particular message, the client may set the <code class="literal">\Answered</code> flag for that message using the STORE command.</p><p>Message deletion in IMAP is done in two stages for safety, as in POP and many other protocols. The client sets the <code class="literal">\Deleted</code> flag for whichever messages are to be removed, using the STORE command. The messages are deleted only when the mailbox is expunged, typically when it is closed.</p><p>The search facility in IMAP4 is also surprisingly quite sophisticated, allowing the client to look for messages based on multiple criteria simultaneously. For example, with the appropriate syntax, you could search for "all posts that are flagged as having been answered that were sent by Jane Jones before April 1, 2004." Users of IMAP clients can thus easily locate specific messages even in very large mailboxes without needing to download and hunt through hundreds of messages.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-474"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> After the client opens a specific mailbox, the IMAP session enters the Selected state, where operations such as reading and copying individual email messages may be performed. The two most important commands used in this state are FETCH, which can be used to retrieve a whole message, part of a message, or only certain message headers or flags; and STORE, which sets a message's status information. IMAP also includes a powerful search facility, providing users with great flexibility in finding messages in a mailbox. When the client is finished working with a particular mailbox, it may choose a different one and reenter the Selected state, close the mailbox and return to the Authenticated state, or log out, automatically entering the Logout state.</p></div></div></div></div>
<div class="sect1" title="TCP/IP Direct Server Email Access"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_direct_server_email_access"/>TCP/IP Direct Server Email Access</h1></div></div></div><p><a class="indexterm" id="idx-CHP-78-2839"/>This final portion of the journey of a TCP/IP email message is usually the job of an email access and retrieval protocol like POP3 or IMAP4. These are <span class="emphasis"><em>customized</em></span> protocols, by which I mean that they were created specifically for the last step of the email communication process. However, there are also several <span class="emphasis"><em>generic</em></span> methods by which an email client can gain access to a mailbox, without the use of a special protocol.</p><p>These methods are all variations of the online email access model. They generally work by establishing <span class="emphasis"><em>direct access</em></span> to the server where the mailbox is located. The mailbox itself is just a file on a server somewhere, so if that file can be made available, it can be viewed and manipulated like any other file using an email client program that reads and writes the mailbox file. The following are some of the ways in which this can be done:</p><p><span class="strong"><strong>Using the SMTP Server Directly</strong></span> The simplest method for gaining access to the mailbox is to log on to the server itself. This is not an option for most people, and even in years gone by, it was not often done, for security and other reasons. However, some people do run their own SMTP servers, giving them considerable control over access to their email.</p><p><span class="strong"><strong>File Sharing Access</strong></span> Using a protocol such as NFS, it is possible to have a mailbox mounted on a user's client machine where it can be accessed as if it were a local file. The mail is still on the server and not the client machine, but the communication between the client and the server occurs transparently to both the user and the email client software.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-78-2840"/>Dial-Up Remote Server Access</strong></span> A user on a client machine dials up a server where her mailbox is located and logs in to it. The user then can issue commands to access mail on that server as if she were logged in to it directly.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-78-2841"/>Telnet <a class="indexterm" id="idx-CHP-78-2842"/>Remote Server Access</strong></span> Instead of dialing in to the server, a user can connect to it for remote access using the Telnet Protocol.</p><p>These techniques are much more commonly associated with timesharing systems, which commonly use the UNIX family of operating systems more than others. They are also often combined; for example, remote access is often provided for UNIX users, but most companies don't want users logging in directly to the SMTP server. Instead, an ISP might run an SMTP server on one machine called <span class="emphasis"><em>mail.companyname.com</em></span> and also operate a different server that is designed for client access called <span class="emphasis"><em>users.companyname.com</em></span>. A user could access email by dialing into the users machine, which would employ NFS to access user mailboxes on the mail machine.</p><p>Direct server access is a method that has been around for decades. At one time, this was how the majority of people accessed email, for two main reasons. First, if you go back far enough, protocols like POP or IMAP had not yet been developed; the TCP/IP email system as a whole predates them by many years, and direct access was the only option back then. Second, the general way that email and networks were used years ago was different from what it is today. Most individuals did not have PCs at home, and no Internet as we know it existed. Remotely accessing a UNIX server using a modem or Telnet for email and other services was just the way it was done.</p><p>I got started using direct server access for email more than ten years ago, and I still use it today. I Telnet in to a client machine and use a UNIX email program called <code class="literal">elm</code> to access and manipulate my mailbox. To me, this provides numerous advantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Most important, I can access my email using Telnet from any machine on the Internet, anywhere around the world.</p></li><li class="listitem"><p>Since I am logged in directly, I get immediate notification when new mail arrives, without needing to check routinely for new mail.</p></li><li class="listitem"><p>My mailbox is always accessible, and all my mail is always on a secure server in a professionally managed data center.</p></li><li class="listitem"><p>I have complete control over my mailbox and can edit it, split it into folders, write custom spam filters, or do anything else I need to do.</p></li></ul></div><p>This probably sounds good, but most people today do not use direct server access because of the disadvantages of this method. One big issue is that you must be logged in to the Internet to access your email. Another one, perhaps even larger, is the need to be familiar with UNIX and a UNIX email program. UNIX is simply not as user-friendly as a graphical operating systems such as Windows or the Mac. For example, my UNIX email program doesn't support color and cannot show me attached graphic images. I must extract images and other files from MIME messages and transfer them to my own PC for viewing.</p><p>Most ordinary computer users today don't know UNIX and don't want to know it. They are much happier using a fancy graphical email program based on POP3 or IMAP4. However, a number of us old UNIX dinosaurs are still around and believe the benefits of direct access outweigh the drawbacks. (Oh, one other benefit that I forgot to mention is that it's very hard to get a computer virus in email when you use UNIX!)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-475"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Instead of using a dedicated protocol like POP3 or IMAP4 to retrieve mail, on some systems it is possible for a user to have direct server access to email. This is most commonly done on UNIX systems, where protocols like Telnet or NFS can give a user shared access to mailboxes on a server. This is the oldest method of <a class="indexterm" id="idx-CHP-78-2843"/>email access. It provides the user with the most control over his mailbox and is well suited to those who must access mail from many locations. The main drawback is that it means the user must be on the Internet to read email, and it also usually requires familiarity with the UNIX operating system, which few people use today.</p></div></div>
<div class="sect1" title="TCP/IP World Wide Web Email Access"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_world_wide_web_email_access"/>TCP/IP World Wide Web Email Access</h1></div></div></div><p><a class="indexterm" id="idx-CHP-78-2844"/>Most email users like the advantages of online access, especially the ability to read mail from a variety of different machines. What they don't care for is direct server access using protocols like Telnet, UNIX, and nonintuitive, character-based email programs. They want online access, but they want it to be simple and easy to use.</p><p>In the 1990s, the World Wide Web was developed and grew in popularity very rapidly, due in large part to its ease of use. Millions of people became accustomed to firing up a web browser to perform a variety of tasks, to the point at which using the Web has become almost second nature. It didn't take very long before someone figured out that using the Web would be a natural way of providing easy access to email on a server.</p><p>This technique is straightforward. It exploits the flexibility of the Hypertext Transfer Protocol (HTTP) to tunnel email from a mailbox server to the client. A web browser (client) is opened and given a URL for a special web server document that accesses the user's mailbox. The web server reads information from the mailbox and sends it to the web browser, where it is displayed to the user.</p><p>This method uses the online access model like direct server access, because requests must be sent to the web server, and this requires the user to be online. The mail also remains on the server, as when NFS or Telnet are used. The big difference between Web-based mail and the UNIX methods is that the former is much easier for nonexperts to use.</p><p>Since the idea was first developed, many companies have jumped on the Web-mail bandwagon, and the number of people using this technique has exploded into the millions in just a few years. Many free services even popped up in the late 1990s as part of the dot-com bubble, allowing any Internet user to send and receive email using the Web at no charge (except perhaps for tolerating advertising). Many ISPs now offer Web access as an option in additional to conventional POP/IMAP access, which is useful for those who travel.</p><p>There are drawbacks to the technique, however, which as you might imagine are directly related to its advantages. Web-based mail is easy to use, but inflexible; the user does not have direct access to her mailbox and can use only whatever features the provider's website implements. For example, suppose the user wants to search for a particular string in her mailbox; this requires that the Web interface provide this function. If it doesn't, the user is out of luck.</p><p>Web-based mail also has a disadvantage that is an issue for some people: performance. Using conventional UNIX direct access, it is quick and easy to read through a mailbox; the same is true of access using POP3, once the mail is downloaded. In contrast, Web-based mail services mean each request requires another HTTP request/response cycle. The fact that many Web-based services are free often means server overload that exacerbates the speed issue.</p><p>Note that when Web-based mail is combined with other methods such as POP3, care must be taken to avoid strange results. If the Web interface doesn't provide all the features of the conventional email client, certain changes made by the client may not show up when Web-based access is used. Also, mail retrieval using POP3 by default removes the mail from the server. If you use POP3 to read your mailbox and then later try to use the Web to access those messages from elsewhere, you will find that the mail is gone—it's on the client machine where you used the POP3 client. Many email client programs now allow you to specify that you want the mail left on the server after retrieving it using POP3.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-476"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the past few years, a new method has been developed to allow email access using the World Wide Web. This technique is rapidly growing in popularity, because it provides many of the benefits of direct server access, such as the ability to receive email anywhere around the world, while being much simpler and easier than the older methods of direct access such as making a Telnet connection to a server. In some cases, Web-based email can be used in combination with other methods or protocols, such as POP3, giving users great flexibility in how they read their mail.</p></div></div></body></html>