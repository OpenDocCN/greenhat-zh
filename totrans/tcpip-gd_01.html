<html><head></head><body><div class="part" title="Part&#xA0;I-1.&#xA0;NETWORKING FUNDAMENTALS"><div class="titlepage"><div><div><h1 class="title"><a id="networking_fundamentals"/>Part I-1. NETWORKING FUNDAMENTALS</h1></div></div></div><div class="partintro" id="id3150212" title="NETWORKING FUNDAMENTALS"><div/><p>TCP/IP OVERVIEW AND BACKGROUND INFORMATION</p><p>They say the best place to start is at the beginning, and that's exactly where you are now. This initial section contains background information that will help you to understand what networking is about and where TCP/IP fits into the grand scheme of things. This introductory information will help ease you into your studies of TCP/IP, and it is particularly valuable to those who are new to the world of networking.</p><p>This section contains three parts. The first part covers a number of important fundamental aspects of networks, discussing how they are used, the standards that define them, the terminology that describes them, and much more. The second part describes the important OSI Reference Model, which is an essential tool to comprehending the function and organization of networking technologies. The third part contains a high-level overview of the TCP/IP protocol suite, which will frame the more complete discussions of individual TCP/IP protocols that follow in the latter two sections of this book.</p><p>Let's get started!</p><p><a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a></p><p><a class="xref" href="ch02.html" title="Chapter 2. NETWORK PERFORMANCE ISSUES AND CONCEPTS">Chapter 2</a></p><p><a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a></p><p><a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a></p><p>Unlike authors of many other TCP/IP-related resources, I do not assume that readers already know what networking is all about. After all, that's why you are reading this book!</p><p>This part provides an overview of some of the basic issues related to networking. It includes discussions of some of the most fundamental networking concepts and ideas. It serves not only to provide you with useful background material, but also as a repository for general information, so that I don't need to repeat it in many different places elsewhere in the book (and if you already know about these basics, you don't need to skip over them in many other locations). The topics covered here are useful for understanding certain TCP/IP concepts. However, some of the material is very broadly oriented toward networking as a whole and is not specific to TCP/IP internetworking.</p><p>This part consists of four chapters. The first chapter in this part introduces networking in broad terms, describes its fundamental characteristics, and differentiates between network sizes and types. The second chapter talks about many different matters related to network performance. The third chapter explains the importance of networking standards and standards organizations. Finally, the fourth chapter provides background information about how data is stored and manipulated in computers; if you are new to computing, you may find this information useful when reading some other parts of this book. If you are experienced in networking and related technologies, you may wish to skip this part of the book. Or, you can scan the headings in the chapters; if you understand the terminology mentioned in a heading, you can probably skip the discussion. Cross-references in other areas of the book refer to information in this part as appropriate, so if you need to fill in your knowledge of a particular fundamental on the fly, you can do so rather easily.</p></div></div>
<div class="chapter" title="Chapter&#xA0;1.&#xA0;NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES"><div class="titlepage"><div><div><h1 class="title"><a id="networking_introduction_characteristics_"/>Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e313"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Someone new to networking will usually have some pretty important questions. What is networking all about? What are the most important attributes that describe networks? And what sort of networks exist? The obvious place to begin discussing networking fundamentals is to answer those questions using a high-level introduction to networking as a whole.</p><p>This chapter is divided into three sections. The first provides a quick introduction to networking. I define networking in the most basic terms, then place networking in an overall context by describing some of its advantages and benefits, as well as some of its disadvantages and costs.</p><p>The second section discusses key concepts that describe and differentiate between types of networks and networking technologies. This is where I'll define terms and "buzzwords" that you cannot avoid if you are going to learn about networks. The topics here include explanations of protocols, switching methods, types of network messages, message formatting, and ways of addressing messages. I also discuss the differences between client-server and peer-to-peer networking.</p><p>In the final section, I describe the major types of networks by drawing distinctions between them based on their size and scope, and I also show you how to use each type and size. I discuss LANs, WLANs, and WANs, and a few variations on these three main categories. I also explore the many terms that are related to the various sizes of networks and how they are used, including segments, subnetworks, internetworks, intranets, and extranets.</p><div class="sect1" title="Introduction to Networking"><div class="titlepage"><div><div><h1 class="title"><a id="introduction_to_networking"/>Introduction to Networking</h1></div></div></div><p>In this day and age, networks are everywhere, especially in the form of the Internet. The Internet, the ultimate network, has revolutionized not only the computer world, but the lives of millions. We tend to take for granted that computers should be connected together. In fact, these days, whenever I have two computers in the same room, I have a difficult time <span class="emphasis"><em>not</em></span> connecting them!</p><p>Given the ubiquitousness of networking, it's hard to believe that the field is still a relatively young one, especially when it comes to hooking up PCs. In approaching any discussion of networking, it is very useful to take a step back and look at networking from a higher level. What is it, exactly, and why is it now considered so important that it is just assumed that most PCs and other devices will be networked?</p><div class="sect2" title="What Is Networking?"><div class="titlepage"><div><div><h2 class="title"><a id="what_is_networking"/>What Is Networking?</h2></div></div></div><p>For such an extensive and involved subject that includes so many different technologies, hardware devices, and protocols, networking is actually quite simple. A <span class="emphasis"><em>network</em></span> is simply a collection of computers or other hardware devices that are connected together, either physically or logically, using special hardware and software that allows the devices to exchange information and cooperate. <span class="emphasis"><em>Networking</em></span> is the term that describes the processes involved in designing, implementing, upgrading, managing, and otherwise working with networks and network technologies.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-1"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A network is a set of hardware devices connected together, either physically or logically. This allows them to exchange information.</p></div><p>Networks are used for an incredible array of purposes. Most people learning about networking think about networking as interconnecting PCs and other "true" computers, but you use a variety of types of networks every day. Each time you pick up a phone, use a credit card at a store, get cash from an ATM machine, or even plug in an electrical appliance, you are using some type of network.</p><p>In fact, the definition can even be expanded beyond the world of technology. I'm sure you've heard the term <span class="emphasis"><em>networking</em></span> used to describe the process of finding an employer or employee through friends and associates. Similarly, the idea here is that independent units are connected together to share information and cooperate.</p><p>The widespread networking of personal computers is a relatively new phenomenon. For the first decade or so of their existence, PCs were very much "islands unto themselves," and were rarely connected together. In the early 1990s, PC networking began to grow in popularity as businesses realized the advantages that networking could provide. By the late 1990s, networking in homes with two or more PCs really started to take off as well.</p><p>This interconnection of small devices represents, in a way, a return to the good old days of mainframe computers. Before computers were small and personal, they were large and centralized machines that many users operating remote terminals shared. Although having all of that computer power in one place had many disadvantages, one benefit was that all users were connected because they shared the central computer.</p><p>Individualized PCs took away that advantage. Networking attempts to move computing to a middle ground. It provides PC users with the best of both worlds: the independence and flexibility of personal computers, and the connectivity and resource sharing of mainframes. In fact, networking today is considered so vital that it's hard to conceive of an organization with two or more computers that would not want to connect them together!</p></div><div class="sect2" title="The Advantages and Benefits of Networking"><div class="titlepage"><div><div><h2 class="title"><a id="the_advantages_and_benefits_of_networkin"/>The Advantages and Benefits of Networking</h2></div></div></div><p>You have undoubtedly heard the expression "The whole is greater than the sum of its parts." This phrase describes networking very well and explains why it has become so popular. A network isn't just a bunch of computers with wires running between them. Properly implemented, a network is a system that provides its users with unique capabilities, above and beyond what the individual machines and their software applications can provide.</p><p>Most of the benefits of networking can be divided into two basic categories: <span class="emphasis"><em>connectivity</em></span> and <span class="emphasis"><em>sharing</em></span>. Networks allow computers, and hence their users, to connect to each other. They also allow for the easy sharing of information and resources, and for the simple cooperation between the devices in other ways. Since modern business depends so much on the intelligent flow and management of information, this ease of use tells you a lot about why networking is so valuable.</p><p>Here, in no particular order, are some of the specific advantages generally associated with networking:</p><p><span class="strong"><strong>Connectivity and Communication</strong></span> Networks connect computers and the users of those computers. Individuals within a building or workgroup can be connected through <span class="emphasis"><em>local area networks (LANs)</em></span>; LANs in distant locations can be interconnected to form larger, <span class="emphasis"><em>wide area networks (WANs)</em></span>. Once computers are connected, it is possible for network users to communicate with each other using technologies such as electronic mail. This makes the transmission of business (or nonbusiness) information easier, more efficient, and less expensive than it would be without the network.</p><p><span class="strong"><strong>Data Sharing</strong></span> One of the most important uses of networking is to allow the sharing of data. Before networking was common, an accounting employee who wanted to prepare a report for her manager would have to produce it on her PC, put it on a floppy disk, and then walk it over to the manager, who would transfer the data to her PC's hard disk. (This sort of "shoe-based network" was sometimes sarcastically called a <span class="emphasis"><em>sneakernet</em></span>.)</p><p>True networking allows thousands of employees to share data much more easily and quickly than this. It also makes possible applications that enable many people to access and share the same data, such as databases, group software development, and much more.</p><p><span class="strong"><strong>Hardware Sharing</strong></span> Networks facilitate the sharing of hardware devices. For example, instead of giving each employee in a department an expensive color printer (or resorting to the sneakernet again), you can place one printer on the network for everyone to share.</p><p><span class="strong"><strong>Internet Access</strong></span> The Internet is itself an enormous network, so whenever you access the Internet, you are using a network. The significance of the Internet today is hard to exaggerate!</p><p><span class="strong"><strong>Internet Access Sharing</strong></span> Small computer networks allow multiple users to share a single Internet connection. Special hardware devices allow the bandwidth of the connection to be easily allocated to various individuals as they need it, and these devices permit an organization to purchase one high-speed connection instead of many slower ones.</p><p><span class="strong"><strong>Data Security and Management</strong></span> In a business environment, a network allows the administrators to manage the company's critical data better. Instead of spreading data over dozens or even hundreds of small computers in a haphazard fashion as users create it, administrators can centralize data on shared servers. This makes it easy for everyone to find the data and makes it possible for the administrators to ensure that the data is regularly backed up. Administrators can also implement security measures to control who can read or change various pieces of critical information.</p><p><span class="strong"><strong>Performance Enhancement and Balancing</strong></span> Under some circumstances, you can use a network to enhance the overall performance of some applications by distributing the computation tasks to various computers on the network.</p><p><span class="strong"><strong>Entertainment</strong></span> Networks facilitate many types of games and entertainment. The Internet itself offers many sources of entertainment. In addition, many multiplayer games operate over a LAN. Many home networks are set up for this reason, and gaming across WANs (including the Internet) has also become quite popular. Of course, if you are running a business and have employees who are easily amused, you might insist that this is really a <span class="emphasis"><em>disadvantage</em></span> of networking rather than an advantage!</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-2"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> At a high level, networks are advantageous because they allow computers and people to be connected together so that they can share resources. Some of the specific benefits of networking include communication, data sharing, Internet access, data security and management, application performance enhancement, and entertainment.</p></div></div><div class="sect2" title="The Disadvantages and Costs of Networking"><div class="titlepage"><div><div><h2 class="title"><a id="the_disadvantages_and_costs_of_networkin"/>The Disadvantages and Costs of Networking</h2></div></div></div><p>Now that I have discussed the great value and many useful benefits of networking, I must bring you crashing back to Earth with that old nemesis of the realistic: TANSTAAFL. For those who are not Heinlein fans, this acronym stands for "There ain't no such thing as a free lunch." Even though networking really does represent a whole that is greater than the sum of its parts, it does have some real and significant costs and drawbacks associated with it.</p><p>Here are a few disadvantages of networking:</p><p><span class="strong"><strong>Network Hardware, Software, and Setup Costs</strong></span> Computers don't just magically network themselves, of course. Setting up a network requires an investment in hardware and software, as well as funds for planning, designing, and implementing the network. For a home with a small network of two or three PCs, this is relatively inexpensive. It amounts to more or less a hundred dollars with today's low prices for network hardware, and practically no setup costs considering that the operating systems have already been designed for networks. For a large company, however, costs can easily run into tens of thousands of dollars or more.</p><p><span class="strong"><strong>Hardware and Software Management and Administration Costs</strong></span> In all but the smallest of implementations, ongoing maintenance and management of the network requires the care and attention of an IT professional. In a smaller organization that already has a system administrator, a network may fall within this person's job responsibilities, but it will take time away from other tasks. In more substantial organizations, a network administrator may need to be hired, and in large companies an entire department may be necessary.</p><p><span class="strong"><strong>Undesirable Sharing</strong></span> With the good comes the bad; though networking allows the easy sharing of useful information, it also allows the sharing of undesirable data. One significant sharing problem in this regard has to do with viruses, which are easily spread over networks and the Internet. Mitigating these effects costs time, money, and administrative effort.</p><p><span class="strong"><strong>Illegal or Undesirable Behavior</strong></span> Similar to the previous point, networking facilitates useful connectivity and communication, but also brings difficulties with it. Typical problems include the abuse of company resources, distractions that reduce productivity, the downloading of illegal or illicit materials, and even software piracy. In larger organizations, these issues must be managed through explicit policies and monitoring, which, again, further increases management costs.</p><p><span class="strong"><strong>Data Security Concerns</strong></span> If a network is implemented properly, it is possible to greatly improve the security of important data. In contrast, a poorly secured network puts critical data at risk, exposing it to the potential problems associated with hackers, unauthorized access, and even sabotage.</p><p>Most of these costs and potential problems can be managed by those who set up and run networks. In the end, the choice of whether to use a network is a matter of weighing the advantages against the disadvantages. Today, nearly everyone decides that networking is worthwhile.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-3"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Networking has a few drawbacks that you can weigh against its many positive aspects. Setting up a network has costs in hardware, software, maintenance, and administration. It is also necessary to manage a network to keep it running smoothly and to address possible misuse or abuse issues. Data security also becomes a much bigger concern when computers are connected together.</p></div></div></div></div>
<div class="sect1" title="Fundamental Network Characteristics"><div class="titlepage"><div><div><h1 class="title"><a id="fundamental_network_characteristics"/>Fundamental Network Characteristics</h1></div></div></div><p>There are many different kinds of <a class="indexterm" id="idx-CHP-1-0001"/>networks and network technologies that are used to create them. The proliferation of networking methods has generally occurred for a very good reason: Different needs require different solutions. The drawback of this is that there are so many different types of protocols and technologies for the networking student to understand!</p><p>Before you can really compare these approaches, you need to understand some of the basic <a class="indexterm" id="idx-CHP-1-0002"/>characteristics that make networks what they are. Although network types may be quite dissimilar, they are often described and even contrasted on the basis of a number of common attributes, which I'll discuss in the following sections.</p><div class="sect2" title="Networking Layers, Models, and Architectures"><div class="titlepage"><div><div><h2 class="title"><a id="networking_layers_models_and_architectur"/>Networking Layers, Models, and Architectures</h2></div></div></div><p>One of the reasons why many people find networking difficult to learn is that it can be a very complicated subject. One of the chief reasons for this complexity is that networks consist of so many hardware and software elements. While a network user may perceive that he is using only one computer program (like a web browser) and one piece of hardware (like a PC), these are parts of a much larger puzzle. In order for even the simplest task to be accomplished on a network, dozens of different components must cooperate by passing control information and data to accomplish the overall goal of network communication.<a class="indexterm" id="idx-CHP-1-0003"/></p><p>The best way to understand any complex system is to break it down into pieces and then analyze what those pieces do and how they interact. The most logical approach is to divide the overall set of functions into modular components, each of which is responsible for a particular function. At the same time, you also need to define interfaces between these components, which describe how they fit together. This enables you to simplify the complexity of networking by approaching it in digestible chunks.</p><p>Networking technologies are most often compartmentalized in this manner by dividing their functions into <span class="emphasis"><em>layers</em></span>, each of which contains hardware and software elements. Each layer is responsible for performing a particular type of task and interacts with the layers above and below it. Layers are conceptually arranged into a vertical <span class="emphasis"><em>stack</em></span>. Lower layers are charged with more concrete tasks such as hardware signaling and low-level communication; they provide services to the higher layers. The higher layers, in turn, use these services to implement more abstract functions such as implementing user applications.</p><p>Dividing networks into layers this way is somewhat like the division of labor in a manufacturing facility, and it yields similar benefits. Each hardware device or software program can be specialized to perform the function needed by that layer, like a well-trained specialist on an assembly line. The different modules can be combined in different ways as needed. This way, it's also easier to understand how a network functions overall.</p><p>One other important benefit of layering is that makes it possible for technologies defined by different groups to interoperate. For this to be possible, it is necessary for everyone to agree on how layers will be defined and used. The most common tool for this purpose is a <span class="emphasis"><em>networking model</em></span>. The model describes what the different layers are in the network, what each is responsible for doing, and how they interact. A univerally accepted model ensures that everyone is on the same page when creating hardware and software.</p><p>The most common general model in use today is the Open Systems Interconnection (OSI) Reference Model, which consists of seven stacked layers. These range from the physical layer (layer 1) at the bottom, which is responsible for low-level signaling, to the application layer (layer 7) at the top, where application software is implemented. Understanding the OSI model is essential to understanding networking as a whole. I explain models and layers in more detail, and provide a complete description of the OSI Reference Model, in <a class="xref" href="pt02.html" title="Part I-2. THE OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL">Part I-2</a> of this book.</p><p>Closely related to the concept of a model is the concept of an <span class="emphasis"><em>architecture</em></span>. An architecture is essentially a set of rules that describes the function of some portion of the hardware and software that constitutes a stack of layers. Such a ruleset usually takes the form of a specification or standard that describes how equipment and programs using the technology must behave. A networking architecture is designed to implement the functions associated with a particular contiguous set of layers of the OSI Reference Model, either formally or informally.</p><p>In this book, I discuss TCP/IP, the <a class="indexterm" id="idx-CHP-1-0004"/>protocol suite that runs the Internet. TCP/IP is a complex set of technologies that spans many layers of the OSI model. By examining the various components of TCP/IP and how they implement different OSI model layers, you will really learn how TCP/IP works. For starters, the name of the suite, TCP/IP, comes from the Transmission Control Protocol (TCP), which operates at layer 4 of the OSI model, and the Internet Protocol (IP), which runs at OSI model layer 3. IP provides services to layer 4 and uses services from layer 2 below it. TCP uses IP's functions and provides functions to the layers above it.</p><p>I'll start a more complete examination of TCP/IP by looking at its architecture, and by looking at a second, special model that was developed specifically to make sense of TCP/IP. Both are explored in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>.</p></div><div class="sect2" title="Protocols: What Are They, Anyway?"><div class="titlepage"><div><div><h2 class="title"><a id="protocols_what_are_they_anyway"/>Protocols: What Are They, Anyway?</h2></div></div></div><p>If there's one word you will get used to seeing a lot as you go through this book, it is <span class="emphasis"><em>protocol</em></span>. You will see references to networking protocols, internetworking protocols, high-level protocols, low-level protocols, protocol stacks, protocol suites, subprotocols, and so on. Clearly, protocols are important, yet many reference works and standards use the term over and over again without ever explaining it. One reason for this may be because the term is somewhat vague and can have many meanings.</p><p>In some cases, understanding a technical term is easier if you go back to look at how the term is used in plain English. In the real world, a protocol often refers to a code of conduct or a form of etiquette observed by diplomats. These people must follow certain rules of ceremony and formality to ensure that they communicate effectively without causing conflict. They also must understand what is expected of them when they interact with representatives from other nations, making sure that, for example, they do not offend anyone due to an unfamiliarity with local customs. In fact, most people follow various protocols; they are sort of the unwritten rules of society.</p><p>This may seem to have little to do with networking, but in fact, this is a pretty good high-level description of what networking protocols are about. They define a language and a set of rules and procedures that enable devices and systems to communicate. Obviously, computers do not have local customs, and they hardly have to worry about committing a faux pas that might cause another computer to take offense. Networking protocols concern themselves with ensuring that all the devices on a network or internetwork are in agreement about how various actions must be performed in the total communication process.</p><p>A protocol is thus basically a way of ensuring that devices are able to talk to each other effectively. In most cases, an individual protocol describes how communication is accomplished between one particular software or hardware element in two or more devices.</p><p>In the context of the OSI Reference Model, a protocol is formally defined as a set of rules governing communication between entities at the same layer. For example, TCP is responsible for a specific set of functions on TCP/IP networks. Each host on a TCP/IP network has a TCP implementation, and those hosts all communicate with each other logically at layer 4 of the OSI model.</p><div class="note" title="Note"><h3 class="title"><a id="note-1"/>Note</h3><p><span class="emphasis"><em>The formalized OSI Reference Model meaning of the word</em></span> protocol <span class="emphasis"><em>is covered in the OSI Reference Model topic on horizontal layer communication (discussed in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>, in the section titled "Protocols: Horizontal (Corresponding Layer) Communication")</em></span>.</p></div><p>While OSI Reference Model definitions are sometimes overly theoretical in nature, this definition of protocol is rather accurate in assessing protocols in real-world networking. If something doesn't specify a means of communication, it arguably isn't a protocol.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-4"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A networking protocol defines a set of rules, algorithms, messages, and other mechanisms that enables software and hardware in networked devices to communicate effectively. A protocol usually describes a means for communication between corresponding entities at the same OSI Reference Model layer in two or more devices.</p></div><p>Despite this, the term <span class="emphasis"><em>protocol</em></span> is often used colloquially to refer to many different concepts in networking. Some of the more common alternative uses of the word are listed here:</p><p><span class="strong"><strong>Protocol <a class="indexterm" id="idx-CHP-1-0005"/>Suites</strong></span> It is very common to hear the word <span class="emphasis"><em>protocol</em></span> used to refer to sets of protocols that are more properly called <span class="emphasis"><em>protocol suites</em></span> (or <span class="emphasis"><em>stacks</em></span>, in reference to a stack of layers). For example, TCP/IP is often called just a protocol when it is really a (large) set of protocols.<a class="indexterm" id="idx-CHP-1-0006"/></p><p><span class="strong"><strong>Microsoft <a class="indexterm" id="idx-CHP-1-0007"/>Windows Protocols</strong></span> One important example of the issue of referring to protocol suites as single protocols is the networking software in Microsoft Windows. It usually calls a full networking stack like TCP/IP or IPX/SPX  just a protocol. When you install one of these so-called protocols, however, you actually get a software module that supports a full protocol suite.</p><p><span class="strong"><strong>Other Technologies</strong></span> Sometimes technologies that are not protocols at all are called protocols, either out of convention or perhaps because people think it sounds good. For example, TCP/IP Remote Network Monitoring (RMON) is often called a protocol when it is really just an enhancement to the Simple Network Management Protocol (SNMP), which is a protocol! (See <a class="xref" href="pt15.html" title="Part III-4. TCP/IP NETWORK MANAGEMENT FRAMEWORK AND PROTOCOLS">Part III-4</a> for details on SNMP and RMON.)</p><p>So, does it really matter whether a protocol is a "true" protocol or not? Well, the networking hardware devices and software programs sure don't care. But hopefully, having read about the term and what it means, you will be able to better understand the word when you encounter it in your studies—especially in the places where it may not always be used in a way that's entirely consistent with its formal definition.</p></div><div class="sect2" title="Circuit-Switching and Packet-Switching Networks"><div class="titlepage"><div><div><h2 class="title"><a id="circuit-switching_and_packet-switching_n"/>Circuit-Switching and Packet-Switching Networks</h2></div></div></div><p>Networks are devices that are connected together using special hardware and software that allows them to exchange information. The most important word in that sentence is the final one: <span class="emphasis"><em>information</em></span>. As you will see in your exploration of this book, there are many methods for exchanging information between networked devices. There are also a number of ways of categorizing and describing these methods and the types of networks that use them.<a class="indexterm" id="idx-CHP-1-0008"/></p><p>One fundamental way to differentiate between networking technologies is on the basis of the method used to determine the path between devices over which information will flow. In highly simplified terms, there are two approaches: a path can be set up between the devices in advance, or the data can be sent as individual data elements over a variable path.</p><div class="sect3" title="Circuit Switching"><div class="titlepage"><div><div><h3 class="title"><a id="circuit_switching"/>Circuit Switching</h3></div></div></div><p>In the <span class="emphasis"><em>circuit-switching</em></span> networking method, a connection called a <span class="emphasis"><em>circuit</em></span>, which is used for the whole communication, is set up between two devices. Information about the nature of the circuit is maintained by the network. The circuit may be either a fixed one that is always present or one that is created on an as-needed basis. Even if many potential paths through intermediate devices may exist between the two devices that are communicating, only one will be used for any given dialogue, as shown in <a class="xref" href="ch01s02.html#circuit_switching_in_a_circuit-switched_" title="Figure 1-1. Circuit switching In a circuit-switched network, before communication can occur between two devices, a circuit is established between them. This is shown as a darker line for the conduit of data from Device A to Device B, and a matching lighter line from B back to A. Once it's set up, all communication between these devices takes place over this circuit, even though there are other possible ways that data could conceivably be passed over the network of devices between them. Contrast this diagram to Figure 1-2.">Figure 1-1</a>.</p><p>The classic example of a circuit-switched network is the telephone system. When you call someone and she answers, you establish a circuit connection and can pass data in a steady stream. That circuit functions the same way, regardless of how many intermediate devices are used to carry your voice. You use it for as long as you need it and then terminate the circuit. The next time you call, you get a new circuit, which may (probably will) use different hardware than the first circuit did, depending on what's available at that time in the network.</p><div class="figure"><a id="circuit_switching_in_a_circuit-switched_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e638"/><img alt="Circuit switching In a circuit-switched network, before communication can occur between two devices, a circuit is established between them. This is shown as a darker line for the conduit of data from Device A to Device B, and a matching lighter line from B back to A. Once it's set up, all communication between these devices takes place over this circuit, even though there are other possible ways that data could conceivably be passed over the network of devices between them. Contrast this diagram to ." src="httpatomoreillycomsourcenostarchimages287683.png.jpg"/></div></div><p class="title">Figure 1-1. Circuit switching In a circuit-switched network, before communication can occur between two devices, a circuit is established between them. This is shown as a darker line for the conduit of data from Device A to Device B, and a matching lighter line from B back to A. Once it's set up, all communication between these devices takes place over this circuit, even though there are other possible ways that data could conceivably be passed over the network of devices between them. Contrast this diagram to <a class="xref" href="ch01s02.html#packet_switching_in_a_packet-switched_ne" title="Figure 1-2. Packet switching In a packet-switched network, no circuit is set up prior to sending data between devices. Blocks of data, even from the same file or communication, may take any number of paths as they journey from one device to another. Compare this to Figure 1-1.">Figure 1-2</a>.</p></div></div><div class="sect3" title="Packet Switching"><div class="titlepage"><div><div><h3 class="title"><a id="packet_switching"/>Packet Switching</h3></div></div></div><p>In the <span class="emphasis"><em>packet-switching</em></span> network type, no specific path is used for data transfer. Instead, the data is chopped up into small pieces called <span class="emphasis"><em>packets</em></span> and sent over the network. You can route, combine, or fragment the packets as required to get them to their eventual destination. On the receiving end, the process is reversed—the data is read from the packets and reassembled to form the original data. A packet-switched network is more analogous to the postal system than it is to the telephone system (though the comparison isn't perfect). An example is shown in <a class="xref" href="ch01s02.html#packet_switching_in_a_packet-switched_ne" title="Figure 1-2. Packet switching In a packet-switched network, no circuit is set up prior to sending data between devices. Blocks of data, even from the same file or communication, may take any number of paths as they journey from one device to another. Compare this to Figure 1-1.">Figure 1-2</a>.<a class="indexterm" id="idx-CHP-1-0009"/></p><div class="figure"><a id="packet_switching_in_a_packet-switched_ne"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e664"/><img alt="Packet switching In a packet-switched network, no circuit is set up prior to sending data between devices. Blocks of data, even from the same file or communication, may take any number of paths as they journey from one device to another. Compare this to ." src="httpatomoreillycomsourcenostarchimages287685.png.jpg"/></div></div><p class="title">Figure 1-2. Packet switching In a packet-switched network, no circuit is set up prior to sending data between devices. Blocks of data, even from the same file or communication, may take any number of paths as they journey from one device to another. Compare this to <a class="xref" href="ch01s02.html#circuit_switching_in_a_circuit-switched_" title="Figure 1-1. Circuit switching In a circuit-switched network, before communication can occur between two devices, a circuit is established between them. This is shown as a darker line for the conduit of data from Device A to Device B, and a matching lighter line from B back to A. Once it's set up, all communication between these devices takes place over this circuit, even though there are other possible ways that data could conceivably be passed over the network of devices between them. Contrast this diagram to Figure 1-2.">Figure 1-1</a>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-5"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One way that networking technologies are categorized is based on the path used to carry data between devices. In <a class="indexterm" id="idx-CHP-1-0010"/>circuit switching, a circuit is first established and then used to carry all data between devices. In packet switching, no fixed path is created between devices that communicate; it is broken into packets, each of which may take a separate path from sender to recipient.<a class="indexterm" id="idx-CHP-1-0011"/></p></div></div><div class="sect3" title="Which Switching Method to Choose?"><div class="titlepage"><div><div><h3 class="title"><a id="which_switching_method_to_choose"/>Which Switching Method to Choose?</h3></div></div></div><p>A common temptation when considering alternatives such as these is to ask which is better; the answer is neither. There are places for which one is more suited than the other, but if one were clearly superior, both methods wouldn't be used.</p><p>One important issue in selecting a switching method is whether the network medium is <span class="emphasis"><em>shared</em></span> or <span class="emphasis"><em>dedicated</em></span>. Your phone line can be used for establishing a circuit because you are the only one who can use it—assuming you can keep that pesky wife/husband/child/sister/brother/father/mother off it. However, this doesn't work well with LANs, which typically use a single shared medium and baseband signaling. If two devices were to establish a connection, they would lock out all the other devices for a long period of time. It makes more sense to chop the data into small pieces and send them one at a time. Then, if two other devices want to communicate, <span class="emphasis"><em>their</em></span> packets can be interspersed, and everyone can share the network.<a class="indexterm" id="idx-CHP-1-0012"/></p><p>The ability to have many devices communicate simultaneously without dedicated data paths is one reason why packet switching is becoming predominant today. However, there are some disadvantages of packet switching compared to circuit switching. One is that since all data does not take the same predictable path between devices, it is possible that some pieces of data may get lost in transit or show up in the incorrect order. In some situations this does not matter, but in others it is very important indeed.</p><p>Although the theoretical difference between circuit and packet switching is pretty clear-cut, understanding how to use them is a bit more complicated. One of the major issues is that in modern networks, they are often combined.</p><p>For example, suppose you connect to the Internet using a dial-up modem. You will be using IP datagrams (packets) to carry higher-layer data, but it will be over the circuit-switched telephone network. Yet the data may be sent over the telephone system in digital packetized form. So in some ways, both circuit switching and packet switching are being used concurrently.</p><p>Another issue is the relationship between circuit and packet switching, and whether a technology is <a class="indexterm" id="idx-CHP-1-0013"/>connection-oriented or <a class="indexterm" id="idx-CHP-1-0014"/>connectionless. The two concepts are related but not the same, as you will see in a moment.</p><div class="note" title="Note"><h3 class="title"><a id="note-2"/>Note</h3><p><span class="emphasis"><em>The word</em></span> packet <span class="emphasis"><em>is only one of several terms that are used to refer to messages that are sent over a network. Other terms that you will encounter include frame, datagram, cell, and segment. You will learn more about these terms later in this chapter</em></span>.</p></div></div></div><div class="sect2" title="Connection-Oriented and Connectionless Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="connection-oriented_and_connectionless_p"/>Connection-Oriented and Connectionless Protocols</h2></div></div></div><p>I just compared networking technologies based on whether or not they use a dedicated path or <span class="emphasis"><em>circuit</em></span> over which they send data. Another way in which technologies and protocols are differentiated has to do with whether or not they use <span class="emphasis"><em>connections</em></span> between devices. This issue is closely related to the matter of packet versus circuit switching.<a class="indexterm" id="idx-CHP-1-0015"/></p><p>Protocols are divided into the following two categories based on their use of connections:</p><p><span class="strong"><strong>Connection-Oriented Protocols</strong></span> These protocols require you to establish a logical connection between two devices before transferring data. This is generally accomplished by following a specific set of rules that specify how a connection should be initiated, negotiated, managed, and eventually terminated. Usually, one device begins by sending a request to open a connection, and the other responds. The devices pass control information to determine if and how the connection should be set up. If this is successful, data is sent between the devices. When they are finished, the connection is broken.</p><p><span class="strong"><strong>Connectionless Protocols</strong></span> These protocols do not establish a connection between devices. As soon as a device has data to send to another, it just sends it.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-6"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A connection-oriented protocol is one in which a logical connection is first established between devices prior to data being sent. In a connectionless protocol, data is just sent without a connection being created.</p></div><p>You can probably immediately see the relationship between the concepts of circuits and connections. Obviously, in order to establish a circuit between two devices, you must connect them. For this reason, circuit-switched networks are inherently based on connections. This has led to the interchangeable use of the terms <span class="emphasis"><em>circuit-switched</em></span> and <span class="emphasis"><em>connection-oriented</em></span>.</p><p>However, this is an oversimplification that results from a common logical fallacy—people make the mistake of thinking that if A implies B, then B implies A, which is like saying that since all apples are fruit, then all fruit are apples! A connection is needed for a circuit, but a circuit is <span class="emphasis"><em>not</em></span> a prerequisite for a connection. There are, therefore, protocols that are connection-oriented, even though they aren't predicated on the use of circuit-based networks at all.</p><p>These connection-oriented protocols are important because they enable the implementation of applications that require connections over packet-switched networks that have no inherent sense of a connection. For example, to use the TCP/IP File Transfer Protocol (FTP), you want to be able to connect to a server, enter a login and password, and then execute commands to change directories, send or retrieve files, and so on. This requires the establishment of a connection over which commands, replies, and data can be passed. Similarly, the Telnet Protocol (TP) involves establishing a connection—it lets you remotely use another machine. Yet, both of these work (indirectly) over IP, which is based on the use of packets, through the important principle of layering (see <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-7"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Circuit-switched networking technologies are inherently connection-oriented, but not all connection-oriented technologies use circuit switching. Logical connection-oriented protocols can be implemented on top of packet-switching networks to provide higher-layer services to applications that require connections.</p></div><p>To comprehend the relationship <a class="indexterm" id="idx-CHP-1-0016"/>between connections and circuits, you must recall the layered nature of modern networking architecture (as I discuss in some detail in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>). Even though packets may be used at lower layers for the mechanics of sending data, a higher-layer protocol can create logical connections through the use of messages sent in those packets.</p><p>TCP/IP has two main protocols that operate at the transport layer of the OSI Reference Model. One is TCP, which is connection-oriented; the other, the User Datagram Protocol (UDP), is connectionless. TCP is used for applications that require the establishment of connections (as well as TCP's other service features), such as FTP; it works using a set of rules, as described earlier, by which a logical connection is negotiated prior to sending data. UDP is used by other applications that don't need connections or other features, but do need the faster performance that UDP can offer by not needing to make such connections before sending data.</p><p>Some people consider the layering of a connection-oriented protocol over a connectionless protocol to be like a simulation of circuit switching at higher network layers; this is perhaps a dubious analogy. Even though you can use a TCP connection to send data back and forth between devices, all that data is indeed still being sent as packets; there is no real circuit between the devices. This means that TCP must deal with all the potential pitfalls of packet-switched communication, such as the potential for data loss or receipt of data pieces in the incorrect order. Certainly, the existence of connection-oriented protocols like TCP doesn't obviate the need for circuit-switching technologies, though you will get some arguments about that one too.</p><p>The principle of layering also means that there are other ways that connection-oriented and connectionless protocols can be combined at different levels of an internetwork. Just as a connection-oriented protocol can be implemented over an inherently connectionless protocol, the reverse is also true: a connectionless protocol can be implemented over a connection-oriented protocol at a lower level. In a preceding example, I talked about Telnet (which requires a connection) running over IP (which is connectionless). In turn, IP can run over a connection-oriented protocol like Asynchronous Transfer Mode (ATM).</p></div></div>
<div class="sect1" title="Messages: Packets, Frames, Datagrams, and Cells"><div class="titlepage"><div><div><h1 class="title"><a id="messages_packets_frames_datagrams_and_ce"/>Messages: Packets, Frames, Datagrams, and Cells</h1></div></div></div><p>Many networking technologies are based on packet switching, which involves the creation of small chunks of data to be sent over a network. Even though <span class="emphasis"><em>packet</em></span> appears in the name of this method, the data items sent between networked devices are most generically called <span class="emphasis"><em>messages</em></span>. <span class="emphasis"><em>Packet</em></span> is one of a variety of similar words that are used in different contexts to refer to messages sent from one device to another.</p><p>In some cases, the different terms can be very useful, because the name used to refer to a particular message can tell you something about what the message contains, as you will see shortly. In particular, different message names are usually associated with protocols and technologies operating at specific layers of the OSI Reference Model. Thus, the use of these different names can help clarify discussions that involve multiple protocols operating at different layers.</p><p>Unfortunately, these terms can also cause confusion, because they are not always applied in a universal or even consistent manner. Some people are strict about applying particular message designations only to the appropriate technologies where they are normally used, while others use the different terms completely interchangeably. This means that you should be familiar with the different message types and how they are normally used, but you should still be prepared for the unexpected.</p><p>The most common terms used for messages are the following:</p><p><span class="strong"><strong>Packet</strong></span> This term is considered by many to correctly refer to a message sent by protocols operating at the network layer of the OSI Reference Model. So you will commonly see people refer to <span class="emphasis"><em>IP packets</em></span>. However, this term is commonly also used to refer generically to any type of message, as I mentioned earlier.<a class="indexterm" id="idx-CHP-1-0017"/></p><p><span class="strong"><strong>Datagram</strong></span> This term is basically synonymous with <span class="emphasis"><em>packet</em></span> and is also used to refer to network layer technologies. It is also often used to refer to a message that is sent at a higher level of the OSI Reference Model (more often than <span class="emphasis"><em>packet</em></span> is).</p><p><span class="strong"><strong>Frame</strong></span> This term is most commonly associated with messages that travel at low levels of the OSI Reference Model. In particular, it is most commonly seen used in reference to data link layer messages. It is occasionally also used to refer to physical layer messages, when message formatting is performed by a layer 1 technology. A frame gets its name from the fact that it is created by taking higher-level packets or datagrams and "framing" them with additional header information needed at the lower level.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0018"/>Cell</strong></span> Frames and packets, in general, can be of variable length, depending on their contents; in contrast, a <span class="emphasis"><em>cell</em></span> is most often a message that is fixed in size. For example, the fixed-length, 53-byte messages sent in ATM are called cells. Like frames, cells are usually used by technologies operating at the lower layers of the OSI model.</p><p><span class="strong"><strong>Protocol Data Unit (PDU) and Service Data Unit (SDU)</strong></span> These are the formal terms used in the OSI Reference Model to describe protocol messages. A PDU at layer N is a message sent between protocols at layer N. It consists of layer N header information and an encapsulated message from layer N+1, which is called both the <span class="emphasis"><em>layer N SDU</em></span> and the <span class="emphasis"><em>layer N+1 PDU</em></span>. After you stop scratching your head, see the "Data Encapsulation, Protocol Data Units (PDUs), and Service Data Units (SDUs)" section in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a> for a discussion of this.</p><p>I should also point out that there are certain protocols that use unusual names, which aren't used elsewhere in the world of networking, to refer to their messages. One prominent example is TCP, which calls its messages <span class="emphasis"><em>segments</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-8"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Communication between devices on packet-switched networks is based on items most generically called messages. These pieces of information also go by other names such as packets, datagrams, frames, and cells, which often correspond to protocols at particular layers of the OSI Reference Model. The formal OSI terms for messages are <span class="emphasis"><em>protocol data unit (PDU)</em></span> and <span class="emphasis"><em>service data unit (SDU)</em></span>.</p></div><p>In this book, I have made a specific effort not to imply anything about the nature of a message solely based on the name it uses, but I do follow the most common name used for a particular technology. For example, messages sent over <a class="indexterm" id="idx-CHP-1-0019"/>Ethernet are almost always called Ethernet <a class="indexterm" id="idx-CHP-1-0020"/>frames—they are not generally called Ethernet <a class="indexterm" id="idx-CHP-1-0021"/>datagrams, for example. However, I do not structure discussions so that the type of name used for a <a class="indexterm" id="idx-CHP-1-0022"/>message is the only way to determine what sort of <a class="indexterm" id="idx-CHP-1-0023"/>message it is.</p><div class="sect2" title="Message Formatting: Headers, Payloads, and Footers"><div class="titlepage"><div><div><h2 class="title"><a id="message_formatting_headers_payloads_and_"/>Message Formatting: Headers, Payloads, and Footers</h2></div></div></div><p><span class="emphasis"><em>Messages</em></span> are the structures used to send information over networks. They vary greatly from one protocol or technology to the next in how they are used, and as just described, they are also called by many different names. Shakespeare had the right idea about names, however. The most important way that messages differ is not in what they are called but in terms of their <span class="emphasis"><em>content</em></span>.<a class="indexterm" id="idx-CHP-1-0024"/><a class="indexterm" id="idx-CHP-1-0025"/><a class="indexterm" id="idx-CHP-1-0026"/></p><p>Every protocol uses a special <span class="emphasis"><em>formatting method</em></span> that determines the structure of the messages it employs. Obviously, a message that is intended to connect a web server and a web browser is going to be quite different from one that connects two Ethernet cards at a low level. This is why I separately describe the formats of dozens of different protocol messages in various areas of this book.<a class="indexterm" id="idx-CHP-1-0027"/></p><p>While the format of a particular message type depends entirely on the nature of the technology that uses it, messages on the whole tend to follow a fairly uniform overall structure. In generic terms, each message contains the following three elements (see <a class="xref" href="ch01s03.html#network_message_formatting_in_the_most_g" title="Figure 1-3. Network message formatting In the most general of terms, a message consists of a data payload that will be communicated, bracketed by a set of header and footer fields. The data of any particular message sent in a networking protocol will itself contain an encapsulated higher-layer message containing a header, data, and a footer. This &quot;nesting&quot; can occur many times as data is passed down a protocol stack. The header is found in most protocol messages; the footer only in some.">Figure 1-3</a>):</p><p><span class="strong"><strong>Header</strong></span> Information that is placed before the actual data. The header normally contains a small number of control-information bytes, which are used to communicate important facts about the data that the message contains and how it is to be interpreted and used. It serves as the communication and control link between protocol elements on different devices.</p><p><span class="strong"><strong>Data</strong></span> The actual data to be transmitted, often called the <span class="emphasis"><em>payload</em></span> of the message (metaphorically borrowing a term from the space industry!). Most messages contain some data of one form or another, but some messages actually contain none. They are used for only control and communication purposes. For example, these may be used to set up or terminate a logical connection before data is sent.</p><p><span class="strong"><strong>Footer</strong></span> Information that is placed after the data. There is no real difference between the header and the footer, as both generally contain control fields. The term <span class="emphasis"><em>trailer</em></span> is also sometimes used.</p><div class="figure"><a id="network_message_formatting_in_the_most_g"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e967"/><img alt="Network message formatting In the most general of terms, a message consists of a data payload that will be communicated, bracketed by a set of header and footer fields. The data of any particular message sent in a networking protocol will itself contain an encapsulated higher-layer message containing a header, data, and a footer. This &quot;nesting&quot; can occur many times as data is passed down a protocol stack. The header is found in most protocol messages; the footer only in some." src="httpatomoreillycomsourcenostarchimages287687.png"/></div></div><p class="title">Figure 1-3. Network message formatting In the most general of terms, a message consists of a data payload that will be communicated, bracketed by a set of header and footer fields. The data of any particular message sent in a networking protocol will itself contain an encapsulated higher-layer message containing a header, data, and a footer. This "nesting" can occur many times as data is passed down a protocol stack. The header is found in most protocol messages; the footer only in some.</p></div><p>Since the header and footer can contain both control and information fields, you might rightly wonder what the point is of having a separate footer anyway. One reason is that some types of control information are calculated using the values of the data itself. In some cases, it is more efficient to perform this computation as the data payload is being sent, and then transmit the result after the payload in a footer. A good example of a field often found in a footer is redundancy data such as cyclic redundancy check (CRC) code, which can be used for error detection by the receiving device. Footers are most often associated with lower-layer protocols, especially at the data link layer of the OSI Reference Model.<a class="indexterm" id="idx-CHP-1-0028"/><a class="indexterm" id="idx-CHP-1-0029"/></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-9"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The general format of a networking message consists of a <span class="emphasis"><em>header</em></span>, followed by the <span class="emphasis"><em>data</em></span> or <span class="emphasis"><em>payload</em></span> of the message, followed optionally by a <span class="emphasis"><em>footer</em></span>. Header and footer information is functionally the same except for its position in the message; footer fields are only sometimes used, especially in cases where the data in the field is calculated based on the values of the data being transmitted.</p></div><p>Generally speaking, any particular protocol is concerned with only its <span class="emphasis"><em>own</em></span> header (and footer, if present). It doesn't care much about what is in the data portion of the message, just as a delivery person worries only about driving the truck and not so much about what it contains. At the beginning of that data will normally be the headers of other protocols that were used higher up in the protocol stack; this, too, is shown in <a class="xref" href="ch01s03.html#network_message_formatting_in_the_most_g" title="Figure 1-3. Network message formatting In the most general of terms, a message consists of a data payload that will be communicated, bracketed by a set of header and footer fields. The data of any particular message sent in a networking protocol will itself contain an encapsulated higher-layer message containing a header, data, and a footer. This &quot;nesting&quot; can occur many times as data is passed down a protocol stack. The header is found in most protocol messages; the footer only in some.">Figure 1-3</a>. In the OSI Reference Model, a message handled by a particular protocol is said to be its PDU; the data it carries in its payload is its SDU. The SDU of a lower-layer protocol is usually a PDU of a higher-layer protocol. The discussion of data encapsulation in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a> contains a full explanation of this important concept.</p></div><div class="sect2" title="Message Addressing and Transmission Methods: Unicast, Broadcast, and Multicast"><div class="titlepage"><div><div><h2 class="title"><a id="message_addressing_and_transmission_meth"/>Message Addressing and Transmission Methods: Unicast, Broadcast, and Multicast</h2></div></div></div><p>In a networking technology that uses messages to send data, you must undertake a number of tasks in order to successfully transmit the data from one place to another. One is simply <span class="emphasis"><em>addressing</em></span> the message—putting an address on it so that the system knows where it is supposed to go. Another is <span class="emphasis"><em>transmitting</em></span> the message, which is sending it to its intended recipient.<a class="indexterm" id="idx-CHP-1-0030"/><a class="indexterm" id="idx-CHP-1-0031"/></p><p>There are several different ways of addressing and transmitting a message over a network. One way in which messages are differentiated is in how they are addressed and how many recipients will receive them. The method used depends on the function of the message and also on whether or not the sender knows specifically or generally whom they are trying to contact.</p><p>To help explain these different methods, I will use a real-world analogy. Consider a social function with 300 people that is being held in a large hall. These people are mingling and having different conversations. There are different kinds of messages that you may need to send in this setting, as is the case with networks.</p><div class="figure"><a id="unicast_multicast_and_broadcast_message_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1034"/><img alt="Unicast, multicast, and broadcast message addressing and transmission The three basic types of addressing and message delivery in networking are illustrated in this simplified LAN. Device 6 is sending a unicast message to Device 2, shown as the dark, heavy arrow. Device 4 is sending a multicast message to multicast group X, shown as the medium-weight arrows. In this case, that group includes Devices 1 and 3, which are highlighted. Finally, Device 5 is sending a broadcast message, which goes to all other devices on the LAN, shown as the thin, faint arrows." src="httpatomoreillycomsourcenostarchimages287689.png.jpg"/></div></div><p class="title">Figure 1-4. Unicast, multicast, and broadcast message addressing and transmission The three basic types of addressing and message delivery in networking are illustrated in this simplified LAN. Device 6 is sending a unicast message to Device 2, shown as the dark, heavy arrow. Device 4 is sending a multicast message to multicast group X, shown as the medium-weight arrows. In this case, that group includes Devices 1 and 3, which are highlighted. Finally, Device 5 is sending a broadcast message, which goes to all other devices on the LAN, shown as the thin, faint arrows.</p></div><p>Bearing this analogy in mind, consider these three kinds of message <a class="indexterm" id="idx-CHP-1-0032"/>transmissions, which are illustrated in <a class="xref" href="ch01s03.html#unicast_multicast_and_broadcast_message_" title="Figure 1-4. Unicast, multicast, and broadcast message addressing and transmission The three basic types of addressing and message delivery in networking are illustrated in this simplified LAN. Device 6 is sending a unicast message to Device 2, shown as the dark, heavy arrow. Device 4 is sending a multicast message to multicast group X, shown as the medium-weight arrows. In this case, that group includes Devices 1 and 3, which are highlighted. Finally, Device 5 is sending a broadcast message, which goes to all other devices on the LAN, shown as the thin, faint arrows.">Figure 1-4</a>:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0033"/>Unicast Messages</strong></span> These are messages that are sent from one device to another device; they are not intended for others. If you have a friend at this social event, this is the equivalent of pulling him aside for a private conversation. Of course, there is still the possibility of someone else at the event overhearing your conversation—or even eavesdropping on it. The same is true in networking as well—<a class="indexterm" id="idx-CHP-1-0034"/>addressing a message to a particular computer doesn't guarantee that others won't also read it; it's just that they normally will not do so.</p><p><span class="strong"><strong>Broadcast Messages</strong></span> As the name suggests, these messages are sent to every device on a network. You use them when you need to communicate a piece of information to everyone on the network, or when the sending station needs to send it to just one recipient, but doesn't know its address. For example, suppose a new arrival at the social gathering saw in the parking lot a blue sedan with its lights left on. She does not know who the car belongs to. The best way to communicate this information is to broadcast it by having the host make an announcement that will be heard by all, including the vehicle's owner. In networks, broadcast <a class="indexterm" id="idx-CHP-1-0035"/>messages are used for a variety of purposes, including finding the locations of particular stations or the devices that manage different services.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0036"/>Multicast Messages</strong></span> These are a compromise between the previous two types. Multicast messages are sent to a <a class="indexterm" id="idx-CHP-1-0037"/>group of stations that meet a particular set of criteria. These stations are usually related to each other in some way. For example, they serve a common function or are set up into a particular <span class="emphasis"><em>multicast group</em></span>. (Note that you can also consider broadcast messages to be a special case of multicast in which the group is "everyone.")</p><p>Back to our analogy: This would be somewhat like a group of friends who go to this large social hall and then stay together in a small discussion group—or perhaps use radios to talk to each other from a distance. Multicasting requires special techniques that make clear who is in the intended group of recipients.</p><p>Since these transmission methods differ based on how many and which devices receive the transmission, they are tied directly to the methods used for addressing, as follows:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0038"/>Unicast Addressing</strong></span> <a class="indexterm" id="idx-CHP-1-0039"/>Unicast delivery requires that a message should be addressed to a specific recipient. This is the most common type of messaging, so this addressing capability is present in almost all protocols.</p><p><span class="strong"><strong>Broadcast Addressing</strong></span> Broadcasts are normally implemented via a special address that is reserved for that function. Whenever devices see a message sent to that address, they all interpret it as "This message goes to everyone."</p><p><span class="strong"><strong>Multicast Addressing</strong></span> Multicasts are the most complex type of message because they require a means of identifying a set of specific devices that will receive a message. It is often necessary to create several such groups, which may or may not partially overlap in their membership. Some mechanism is needed to manage which devices are in which groups.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-10"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Three basic methods are used to address and transmit data between networked devices. A <span class="emphasis"><em>unicast</em></span> transmission goes from one device to exactly one other; this is the most common method used for most message transactions. A <span class="emphasis"><em>broadcast</em></span> transmission is sent from one device to all connected devices on a network. A <span class="emphasis"><em>multicast</em></span> transmission is addressed and sent to a select group of devices.</p></div><p>Finally, one special case in the field of addressing is worth mentioning. In some networks or links, only two devices are connected together, forming what is often called a <span class="emphasis"><em>point-to-point network</em></span>. In this situation, everything sent by one device is implicitly intended for the other, and vice versa. Thus, no addressing of messages on a point-to-point link is strictly necessary.</p><div class="note" title="Note"><h3 class="title"><a id="note-3"/>Note</h3><p><span class="emphasis"><em>A new type of message-addressing method was defined as part of IP version 6 (IPv6): the anycast message. This term identifies a message that should be sent to the closest member of a group of devices. <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a> describes this type of addressing and transmission</em></span>.</p></div></div></div>
<div class="sect1" title="Network Structural Models and Client-Server and Peer-to-Peer Networking"><div class="titlepage"><div><div><h1 class="title"><a id="network_structural_models_and_client-ser"/>Network Structural Models and Client-Server and Peer-to-Peer Networking</h1></div></div></div><p>I mentioned in my discussion of the advantages of <a class="indexterm" id="idx-CHP-1-0040"/>networking that networks are normally set up for two primary purposes: <span class="emphasis"><em>connectivity</em></span> and <span class="emphasis"><em>sharing</em></span>. If you have a network with a number of different machines on it, each computer can interact with another's hardware and <a class="indexterm" id="idx-CHP-1-0041"/>software, which enables you to perform a variety of tasks. How this is actually done depends to a large degree on the overall design of the network.</p><p>One very important issue in network design is how to configure the network for the sharing of resources. Specifically, the network designer must decide whether or not to dedicate resource management functions to the devices that constitute it. In some networks, all devices are treated equally in this regard, while in others, each computer is responsible for a particular job in the overall function of providing services. In this latter arrangement, the devices are sometimes said to have <span class="emphasis"><em>roles</em></span>, somewhat like actors in a play.<a class="indexterm" id="idx-CHP-1-0042"/></p><p>The following two common terms are used to describe these different approaches to setting up a network:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0043"/>Peer-to-Peer Networking</strong></span> In a strict <a class="indexterm" id="idx-CHP-1-0044"/>peer-to-peer networking setup, every computer is an equal, a <span class="emphasis"><em>peer</em></span> in the network. Each machine can have resources that are shared with any other machine. There is no assigned role for any particular device, and each of the devices usually runs similar software. Any device can and will send requests to any other, as illustrated in <a class="xref" href="ch01s04.html#peer-to-peer_networking_in_this_model_ea" title="Figure 1-5. Peer-to-peer networking In this model, each device on the network is treated as a peer, or equal. Each device can send requests and responses, and none are specifically designated as performing a particular role. This model is more often used in very small networks. Contrast this with Figure 1-6.">Figure 1-5</a>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0045"/>Client-<a class="indexterm" id="idx-CHP-1-0046"/>Server Networking</strong></span> In this design, a small number of computers are designated as centralized <span class="emphasis"><em>servers</em></span> and are given the task of providing services to a larger number of user machines called <span class="emphasis"><em>clients</em></span>, as shown in <a class="xref" href="ch01s04.html#client-server_networking_in_the_client-s" title="Figure 1-6. Client-server networking In the client-server model, a small number of devices are designated as servers and equipped with special hardware and software that allows them to interact efficiently and simultaneously with multiple client machines. Though the clients can still interact with each other, most of the time they send requests of various sorts to the server, and the server sends back responses to them. Contrast this with the peer-to-peer networking example in Figure 1-5.">Figure 1-6</a>. The servers are usually powerful computers with a lot of memory and storage space, and fast network connections. The clients are typically smaller, regular computers like PCs; they are optimized for human use.<a class="indexterm" id="idx-CHP-1-0047"/></p><p>The term <span class="emphasis"><em>client-server</em></span> also frequently refers to protocols and software, which are designed with matching, complementary components. Usually, server software runs on server hardware, and <a class="indexterm" id="idx-CHP-1-0048"/>client software is used on client computers that connect to those servers. Most of the interaction on the network is between <a class="indexterm" id="idx-CHP-1-0049"/>client and server, not between clients. Server software is designed to efficiently respond to requests, while client software provides the interface to the human users of the network.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-11"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Networks are usually configured to share resources using one of two basic <span class="emphasis"><em>structural models</em></span>. In a <span class="emphasis"><em>peer-to-peer network</em></span>, each device is an equal, and none are assigned particular jobs. In a <span class="emphasis"><em>client-server network</em></span>, however, devices are assigned particular roles—a small number of powerful computers are set up as <span class="emphasis"><em>servers</em></span> and respond to requests from the other devices, which are <span class="emphasis"><em>clients</em></span>. Client-server computing also refers to the interaction between complementary protocol elements and software programs. It's rising in popularity due to its prevalence in TCP/IP and Internet applications.<a class="indexterm" id="idx-CHP-1-0050"/></p></div><div class="figure"><a id="peer-to-peer_networking_in_this_model_ea"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1263"/><img alt="Peer-to-peer networking In this model, each device on the network is treated as a peer, or equal. Each device can send requests and responses, and none are specifically designated as performing a particular role. This model is more often used in very small networks. Contrast this with ." src="httpatomoreillycomsourcenostarchimages287691.png.jpg"/></div></div><p class="title">Figure 1-5. Peer-to-peer networking In this model, each device on the network is treated as a peer, or equal. Each device can send requests and responses, and none are specifically designated as performing a particular role. This model is more often used in very small networks. Contrast this with <a class="xref" href="ch01s04.html#client-server_networking_in_the_client-s" title="Figure 1-6. Client-server networking In the client-server model, a small number of devices are designated as servers and equipped with special hardware and software that allows them to interact efficiently and simultaneously with multiple client machines. Though the clients can still interact with each other, most of the time they send requests of various sorts to the server, and the server sends back responses to them. Contrast this with the peer-to-peer networking example in Figure 1-5.">Figure 1-6</a>.</p></div><p>The choice of client-server or peer-to-peer is sometimes called choosing a <span class="emphasis"><em>structural model</em></span> for the network. As with most situations in which two different schemes are used, there is no right answer in this regard. Your choice depends entirely on the needs of the particular network.</p><p><a class="indexterm" id="idx-CHP-1-0051"/>Peer-to-peer networking has primary advantages of simplicity and low cost, meaning that it has traditionally been used on small networks. Client-server networking provides advantages in the areas of performance, scalability, security, and reliability, but is more complicated and expensive to set up. This makes it better suited to larger networks. Over time, however, there has been a steady evolution toward client-server networking, even on smaller networks. Many years ago, it was common to see even networks with 20 to 50 machines using the peer-to-peer model; today, even networks with only a half-dozen machines are sometimes set up in a client-server mode because of the advantages of centralized resource serving.</p><p>The rise in popularity of client-server networking is ironic because, in some ways, it is actually a throwback to the days of large mainframes decades ago. A mainframe with attached terminals can be thought of as a client-server network, with the mainframe itself being the server and the terminals being clients. This analogy is not perfect, of course, because modern client computers do a lot more work than dumb terminals on mainframes.</p><p>One of the reasons why the client-server structural model is becoming dominant is that it is the primary model used by the world's largest network: the Internet. Client-server architecture is the basis for most TCP/IP protocols and services. For example, the term <span class="emphasis"><em>web browser</em></span> is really another name for a web client, and a <span class="emphasis"><em>website</em></span> is really a web server.</p><div class="note" title="Note"><h3 class="title"><a id="note-4"/>Note</h3><p><span class="emphasis"><em>For more information on client-server computing, I recommend that you read the section "TCP/IP Services and Client/Server Operation" in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>. That topic also contains a very relevant exposition on the different meanings of the terms client and server in hardware, software, and transactional contexts</em></span>.<a class="indexterm" id="idx-CHP-1-0052"/></p></div><div class="figure"><a id="client-server_networking_in_the_client-s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e1306"/><img alt="Client-server networking In the client-server model, a small number of devices are designated as servers and equipped with special hardware and software that allows them to interact efficiently and simultaneously with multiple client machines. Though the clients can still interact with each other, most of the time they send requests of various sorts to the server, and the server sends back responses to them. Contrast this with the peer-to-peer networking example in ." src="httpatomoreillycomsourcenostarchimages287693.png.jpg"/></div></div><p class="title">Figure 1-6. Client-server networking In the client-server model, a small number of devices are designated as servers and equipped with special hardware and software that allows them to interact efficiently and simultaneously with multiple client machines. Though the clients can still interact with each other, most of the time they send requests of various sorts to the server, and the server sends back responses to them. Contrast this with the peer-to-peer networking example in <a class="xref" href="ch01s04.html#peer-to-peer_networking_in_this_model_ea" title="Figure 1-5. Peer-to-peer networking In this model, each device on the network is treated as a peer, or equal. Each device can send requests and responses, and none are specifically designated as performing a particular role. This model is more often used in very small networks. Contrast this with Figure 1-6.">Figure 1-5</a>.</p></div></div>
<div class="sect1" title="Types and Sizes of Networks"><div class="titlepage"><div><div><h1 class="title"><a id="types_and_sizes_of_networks"/>Types and Sizes of Networks</h1></div></div></div><p>One of the reasons that understanding networks can be difficult at times is that there are so many different types! When someone talks about a network, she can mean anything from two computers hooked together in an apartment to a globe-spanning entity with millions of nodes. Every network is unique, and each one has an important role to play in filling the communication and data-sharing needs of different individuals and organizations. In fact, the great diversity and flexibility of networking is one of its most important strengths.<a class="indexterm" id="idx-CHP-1-0053"/><a class="indexterm" id="idx-CHP-1-0054"/></p><p>Two of the most basic ways that you can distinguish and contrast various networks are the relative distances between the devices that they connect and the general mechanisms used to communicate between them. The reason for making these distinctions is that the technological needs of a network differ greatly depending on the amount of ground you are trying to cover, and also by the overall way that you <a class="indexterm" id="idx-CHP-1-0055"/>want to transmit and receive information.</p><p>Many people, including me, like to divide the many kinds of networks in existence into three general classes, as follows:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0056"/>Local Area Networks (<a class="indexterm" id="idx-CHP-1-0057"/>LANs)</strong></span> Networks that connect computers that are relatively close to each other—generally, within the same room or building. When most people think about networking PCs and other small computers, this is what they usually have in mind. The vast majority of regular LANs connect using cables, so the term <span class="emphasis"><em>LAN</em></span> by itself usually implies a wired LAN, but not always.</p><p><span class="strong"><strong>Wireless <a class="indexterm" id="idx-CHP-1-0058"/>LANs (WLANs)</strong></span> LANs that connect devices without wires, using radio frequencies or light. WLANs can be entirely wireless, but most are not. They usually connect wireless devices to each other as well as to the wired portion of the network. Due to the limits of most wireless technologies, WLANs usually connect devices that are very close to each other, generally within a few hundred feet at most.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0059"/>Wide Area Networks (<a class="indexterm" id="idx-CHP-1-0060"/>WANs)</strong></span> Networks that connect devices or other networks over a greater distance than that which is practical for LANs. If the distance between devices can be measured in miles, you will generally use WAN and not LAN technology to link them.</p><p>More often than not, WANs are used to link physically distant LANs. For example, a company with locations in two different cities would normally set up a LAN in each building and then connect them together in a WAN. I also consider most Internet access technologies to be a form of WAN, though some might not agree with that. There is also the term <span class="emphasis"><em>wireless WAN (WWAN)</em></span>, which just refers to a WAN that uses wireless technology.</p><p>As with most other distinctions and categorizations in the world of networking, the lines between these various definitions are not very concrete. As I mentioned already, WLANs are usually not entirely wireless because they contained wired elements. Similarly, trying to say absolutely when a network is "local" and when it is "wide" is difficult.</p><p>It's also somewhat pointless to spend too much energy on differentiating these network classes precisely. In some cases it's not the definitions that decide what technology to use, but rather the technology that indicates what kind of network you have! Since some protocols are designed for WANs, if you are using them, many would say you have a WAN, even if all the devices in that technology are near each other. On the other hand, some LAN technologies allow for the use of cables that can run for many miles; most would still consider a mile-long Ethernet fiber link to be a LAN connection, even though it may span WAN distances.</p><p>There are <a class="indexterm" id="idx-CHP-1-0061"/>many dimensions in which LAN and WAN technologies differ; two of the most important are <span class="emphasis"><em>cost</em></span> and <span class="emphasis"><em>performance</em></span>. It's easy to establish a high-speed conduit for data between two systems that are in the same room, but it's much more difficult if the two are in different states. This means that in the world of WAN, one either pays a lot more or gets a lot less throughput—often it's both.</p><p>The gray area between LAN and WAN is becoming more muddled every year. One reason is the emergence of intermediate network types that straddle the line between these more familiar terms. Two of the more common ones are as follows:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0062"/>Campus Area Networks (CANs)</strong></span> A <span class="emphasis"><em>CAN</em></span> is one created to span multiple buildings in the same location, such as the campus of a university. Campus area networking is a gray area, since neither LANs nor WANs alone are always well suited for this type of application. Often, a mix of LAN and WAN techniques is used for campus networking, depending on the characteristics of the campus and the needs of the organization.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0063"/>Metropolitan Area Networks (MANs)</strong></span> Another intermediate term that you may see sometimes is the <span class="emphasis"><em>MAN</em></span>. As the name implies, this refers to a network that <a class="indexterm" id="idx-CHP-1-0064"/>spans a particular small region or a city. <a class="indexterm" id="idx-CHP-1-0065"/>MANs can be considered small WANs that cover a limited geographical area, or large LANs that cover an area greater than what is normally associated with a local network. Wireless MANs are sometimes called <span class="emphasis"><em>WMANs</em></span>; IEEE 802.16 is an example of a WMAN standard.</p><p>Finally, there is one other term occasionally used that I should mention: the <span class="emphasis"><em>personal area network (PAN)</em></span>. This type of network generally means a very small LAN with a range of only a few feet. PANs mostly connect devices used by a single person (or very small group). The term is most commonly used in reference to Bluetooth/IEEE 802.15 wireless technology, so you will sometimes see the terms <span class="emphasis"><em>wireless PAN (WPAN)</em></span> and <span class="emphasis"><em>PAN</em></span> used interchangeably.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-12"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Networks are often divided by size and general communication method into three classes. <span class="emphasis"><em>Local area networks (LANs)</em></span> generally connect proximate devices, usually using cables. <span class="emphasis"><em>Wireless LANs (WLANs)</em></span> are like cabled LANs but use radio frequency or light technology to connect devices without wires. <span class="emphasis"><em>Wide area networks (WANs)</em></span> connect distant devices or LANs to each other. <span class="emphasis"><em>Campus area networks (CANs)</em></span> and <span class="emphasis"><em>metropolitan area networks (MANs)</em></span> fall between LANs and WANs in terms of overall size. <span class="emphasis"><em>Personal area networks (PANs)</em></span> are like very small LANs and often appear as <span class="emphasis"><em>wireless PANs (WPANs)</em></span>.<a class="indexterm" id="idx-CHP-1-0066"/></p></div></div>
<div class="sect1" title="Segments, Networks, Subnetworks, and Internetworks"><div class="titlepage"><div><div><h1 class="title"><a id="segments_networks_subnetworks_and_intern"/>Segments, Networks, Subnetworks, and Internetworks</h1></div></div></div><p>One of the reasons that networks are so powerful is that they can be used to connect not only individual computers, but also groups of computers. Thus, network connections can exist at multiple levels; one network can be attached to another network, and that entire network can be attached to another set of networks, and so on. The ultimate example of this is, of course, the Internet, which is a huge collection of networks that have been interconnected into…dare I say, a web?</p><p>This means that a larger <a class="indexterm" id="idx-CHP-1-0067"/>network can be described as consisting of several smaller <a class="indexterm" id="idx-CHP-1-0068"/>networks or even parts of networks that are linked together. Conversely, we can talk about taking individual networks or network portions and assembling them into larger structures. The reason why this concept is important is that certain technologies are best explained when looking at an entire large network at a high level, while others really require that you drill down to the detailed level of how constituent network pieces work.</p><p>Over time, a collection of terms has evolved in the networking world to describe the relative sizes of larger and smaller networks. Some of the most common ones are as follows:</p><p><span class="strong"><strong>Network</strong></span> This is the least specific of the terms mentioned here. Basically, a <span class="emphasis"><em>network</em></span> can be pretty much any size, from two devices to thousands. When networks get very large, however, and are clearly comprised of smaller networks connected together, they are often no longer called networks but <span class="emphasis"><em>internetworks</em></span>, as you will see momentarily. Despite this, it is fairly common to hear someone refer to something like "Microsoft's corporate network," which obviously contains thousands or even tens of thousands of machines.<a class="indexterm" id="idx-CHP-1-0069"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-1-0070"/>Subnetwork (Subnet)</strong></span> A <span class="emphasis"><em>subnetwork</em></span> is a portion of a network, or a network that is part of a larger <a class="indexterm" id="idx-CHP-1-0071"/>internetwork. This term is also a rather subjective one; subnetworks can be rather large when they are part of a network that is very large.<a class="indexterm" id="idx-CHP-1-0072"/></p><p>The abbreviated term <span class="emphasis"><em>subnet</em></span> can refer generically to a subnetwork, but also has a specific meaning in the context of TCP/IP addressing (see <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>).</p><p><span class="strong"><strong>Segment (<a class="indexterm" id="idx-CHP-1-0073"/>Network Segment)</strong></span> A <span class="emphasis"><em>segment</em></span> is a small section of a network. In some contexts, a segment is the same as a subnetwork and the terms are used interchangeably. More often, however, the term <span class="emphasis"><em>segment</em></span> implies something smaller than a subnetwork. Networks are often designed so that, for the sake of efficiency, computers that are related to each other or that are used by the same groups of people are put on the same network segment.</p><p>Some LAN technologies—including Ethernet—use the term <span class="emphasis"><em>segment</em></span> to refer specifically to a collection of geographically proximate machines that are connected directly to each other, either by a single cable or single device such as a hub. Such technologies have specific rules about how many devices can be on a segment, how many segments can be connected together, and so on, depending on what sort of network interconnection devices you are using.</p><p><span class="strong"><strong>Internetwork (or Internet)</strong></span> Most often, this refers to a larger networking structure that is formed by connecting smaller ones. Again, the term can have either a generic or a specific meaning, depending on context. In some technologies, an internetwork is just a very large network that has networks as components. In others, a network is differentiated from an internetwork based on how the devices are connected together.</p><p>An important <a class="indexterm" id="idx-CHP-1-0074"/>example of the latter definition is TCP/IP, in which a <span class="emphasis"><em>network</em></span> usually refers to a collection of machines that are linked at layer 2 of the OSI Reference Model, using technologies like Ethernet or <a class="indexterm" id="idx-CHP-1-0075"/>Token Ring, as well as interconnection devices such as hubs and switches. An internetwork is formed when these networks are linked together at layer 3, using routers that pass IP datagrams between networks. Naturally, this is highly simplified, but in studying TCP/IP, you should keep this in mind when you encounter the terms <span class="emphasis"><em>network</em></span> and <span class="emphasis"><em>internetwork</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="note-5"/>Note</h3><p><span class="emphasis"><em>The shorter form of the word internetwork</em></span> (internet) <span class="emphasis"><em>is often avoided by people who wish to avoid confusion with the proper noun form</em></span> (Internet). <span class="emphasis"><em>The latter, of course, refers only to the well-known global internetwork of computers and all the services it provides. I personally try to use the word</em></span> internetwork <span class="emphasis"><em>most of the time in this book instead of</em></span> internet, <span class="emphasis"><em>for this very reason</em></span>.</p></div><p>Understanding these different terms is important not only for helping you comprehend what you read about networks, but also because they are important concepts in network design. This is particularly true for LANs in which decisions regarding how to set up segments and how to connect them to each other have an important impact on the overall performance and usability of the network.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-13"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Several terms are often used to describe the relative sizes of networks and parts of networks. The most basic term is <span class="emphasis"><em>network</em></span> itself, which can refer to most anything, but often means a set of devices connected using an OSI layer 2 technology. A <span class="emphasis"><em>subnetwork</em></span> is a part of a network (or internetwork), as is a <span class="emphasis"><em>segment</em></span>, though the latter often has a more specific meaning in certain technologies. An <span class="emphasis"><em>internetwork</em></span> refers either generically to a very large network, or specifically, to a set of layer 2 networks connected using routers at layer 3.</p></div><p>The term <span class="emphasis"><em>segment</em></span> is notably problematic because it is routinely used in two different ways, especially in discussions related to Ethernet. Traditionally, a <span class="emphasis"><em>segment</em></span> referred to a specific cable. The earliest forms of Ethernet used <a class="indexterm" id="idx-CHP-1-0076"/>coaxial cables, and the coaxial <a class="indexterm" id="idx-CHP-1-0077"/>cable segment was shared and became the <a class="indexterm" id="idx-CHP-1-0078"/>collision domain for the network. <span class="emphasis"><em>Collision domain</em></span> is a term that refers generally to a collection of hardware devices in which only one can transmit at a time. Devices such as hubs and repeaters were used to extend collision domains by connecting together these segments of cable into wider networks. Over time, the terms <span class="emphasis"><em>collision domain</em></span> and <span class="emphasis"><em>segment</em></span> started to be used interchangeably. Thus today a segment can refer either to a specific piece of cable or to a collection of cables connected electrically that represent a single collision domain.</p><div class="note" title="Note"><h3 class="title"><a id="note-6"/>Note</h3><p><span class="emphasis"><em>As if that potential ambiguity in the use of the word</em></span> segment <span class="emphasis"><em>isn't bad enough, it also has another, totally unrelated meaning: It is the name of the messages sent in TCP!</em></span></p></div></div>
<div class="sect1" title="The Internet, Intranets, and Extranets"><div class="titlepage"><div><div><h1 class="title"><a id="the_internet_intranets_and_extranets"/>The Internet, Intranets, and Extranets</h1></div></div></div><p>I mentioned in the preceding discussion of segments, networks, subnetworks, and internetworks that the Internet is really the king of internetworks. After all, you don't get to be called "the" something unless you pretty much define it!</p><p>In fact, the Internet is not just a large internetwork, but substantially more. The Internet is defined not just as the computers that are connected to each other around the world, but as the set of services and features that it offers. More than that, the Internet defines a specific way of doing things, of sharing information and resources between people and companies. And though it might be a bit melodramatic to say so, to many people, the Internet is a way of life.</p><p>As Internet use exploded in the 1990s, many people realized that the techniques and technologies used on the Internet would be useful if applied to internal company networks as well. The term <span class="emphasis"><em>intranet</em></span> was coined to refer to an internal network that functioned like a private Internet. It comes from the prefix <span class="emphasis"><em>intra</em></span>, which means within. Of course, <span class="emphasis"><em>inter</em></span> is the opposite of intra, so this makes some people think that an intranet is the opposite of an internet. In fact, most intranets <span class="emphasis"><em>are</em></span> internetworks as well!</p><p>As if that weren't bad enough from a jargon standpoint, the buzzword buzzards then decided to take matters a step further. If an intranet is extended to allow access to it not only by people or groups strictly from within the organization, but also by people or groups outside the main company, this is sometimes called an <span class="emphasis"><em>extranet</em></span>. <span class="emphasis"><em>Extra</em></span>, of course, is a prefix that means outside, or beyond.</p><p>So, an extranet is a type of internal, private Internet that, well, isn't entirely internal. An extranet is an extended intranet, which is really a type of internet that works like the Internet. (You can start to see why I am not a big fan of these fancy terms. But then, I don't get to choose them; I just have to help you understand them!) An extranet isn't public and open to all—it is controlled by a private organization. At the same time, it isn't entirely private either.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-14"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The generic noun <span class="emphasis"><em>internet</em></span> is a short form for the word internetwork, while the proper noun <span class="emphasis"><em>Internet</em></span> refers to the global internetwork of TCP/IP networks that we all know and use. The term <span class="emphasis"><em>intranet</em></span> refers to an internal network that uses TCP/IP technologies as the Internet does. An <span class="emphasis"><em>extranet</em></span> is like an intranet that is extended to individuals or organizations outside the company. All these terms can be used ambiguously, so you must take care to determine exactly what they mean in any given context.</p></div><p>As you can see, the lines between the Internet, intranets, and extranets were pretty blurry from the start, and the concepts are rapidly blending into a diffuse gray mass as the whole computing world becomes more tightly integrated. For example, even if you have an entirely private intranet, you will want to connect it to the Internet to communicate with the outside world and to allow access to Internet resources. And an extranet may be implemented, in part, through the public Internet infrastructure, using technologies such as virtual private networking (VPN). I think you get the picture.</p><p>The key that binds all of these concepts together is that they all use <span class="emphasis"><em>Internet technologies</em></span>, which is a term that is also somewhat vague. This usually refers to the use of the TCP/IP protocol suite, which is the defining technology of the Internet as well as the set of services that are available on the Internet.</p><p>The bottom line is that being told that a company has an intranet or an extranet—as opposed to a plain old boring network—doesn't tell you much at all. It is best not to rely on the slogans and instead look at the underlying characteristics of the network or internetwork itself. Furthermore, when designing such a network, you should focus on using the technologies and protocols that make sense—let the marketing people decide what to call it later.</p></div>
<div class="chapter" title="Chapter&#xA0;2.&#xA0;NETWORK PERFORMANCE ISSUES AND CONCEPTS"><div class="titlepage"><div><div><h1 class="title"><a id="network_performance_issues_and_concepts"/>Chapter 2. NETWORK PERFORMANCE ISSUES AND CONCEPTS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e1706"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Networking is largely about connecting together devices so that information can be shared between them. Since the idea is to send data from one place to another, a very important characteristic of any network is its <span class="emphasis"><em>speed</em></span>: How fast can data be transmitted and received? This matter of speed turns out to be only one of several issues that determine the overall <span class="emphasis"><em>performance</em></span> of a network.<a class="indexterm" id="idx-CHP-2-0079"/></p><p>In the computing world, performance is, in general, one of the most discussed but least understood characteristics of any system or hardware device. This is true of networking as well. For example, most people know the raw throughput rating of their network hardware, and they may even start to draw conclusions about its capabilities based on those numbers. Many, however, don't realize that they will never actually achieve that rated amount of performance in the real world.</p><p>Most of the other subtle issues related to <a class="indexterm" id="idx-CHP-2-0080"/>performance are also typically ignored or misunderstood, such as the impact of software drivers on hardware <a class="indexterm" id="idx-CHP-2-0081"/>performance, and the fact that certain applications need more than just raw bit speed—they need <span class="emphasis"><em>reliable</em></span> delivery of data. But even beyond all of this, one of the most important issues related to network performance is understanding what your needs are, because then you can make sure you don't spend too much money for performance you don't need—or worse, create a network that can't meet your requirements.</p><p>In this chapter, I discuss various performance issues and concepts that are related to networking in one way or another. First and foremost, I try to put performance in context and also contrast it with nonperformance issues. Then I talk about several key performance terms and metrics: speed, bandwidth, throughput, and latency. I also discuss some of the units used to measure network performance. I then explain how the real-world performance of a network differs from its theoretical performance and talk about factors that have an impact on network performance. I conclude by contrasting full-duplex and half-duplex network operation, and talking about quality of service, which is a concept that is especially important in the use of networks for real-time applications such as streaming multimedia.</p><div class="sect1" title="Putting Network Performance in Perspective"><div class="titlepage"><div><div><h1 class="title"><a id="putting_network_performance_in_perspecti"/>Putting Network Performance in Perspective</h1></div></div></div><p><span class="emphasis"><em>Performance</em></span> is probably the mother of all buzzwords in the computer industry. There are many people who consider it the ultimate goal of any computer or computer system, and by extension, any network. A lot of people spend many dollars and hours of time trying to maximize it. There's good reason for this: Performance <span class="emphasis"><em>is</em></span> very important. A network that does not offer adequate performance simply will not get the job done for those that rely on it. However, it is very important to keep performance in perspective. Successfully maximizing performance requires that you first take a step back and look at the big picture.</p><p>The first question you must ask yourself is also the most essential one: How important is performance to you? Before you answer this question, recall the old auto racing adage: "Speed costs money—how fast do you want to go?" While there are some situations in which you can get much better performance in a network by spending just a little more money, in general, you don't get more performance without paying for it in some way. That may mean a higher cost for the network, or it may mean a trade-off of some nonperformance feature.</p><p>If you are designing or specifying a network, it's very important to keep in mind that your goal is to come up with a system that will meet the needs that were determined for it during requirements analysis. This means coming up with a network that has a level of performance that matches the requirements and leaves some room for expansion. Unless you have an unlimited budget—and who does, right?—your objective is not "performance at any cost." It is to create a network that meets <span class="emphasis"><em>all</em></span> of your users' needs, including balancing performance and nonperformance characteristics, as you will see shortly.</p><div class="note" title="Note"><h3 class="title"><a id="note-7"/>Note</h3><p><span class="emphasis"><em>Buyer beware. Companies are constantly coming out with the "latest and greatest" high-performance networking technologies. They usually try to sell their technologies by attempting to convince you that you just cannot live without this latest advance; that you "need" to upgrade—immediately, if not sooner! Well, it's simply not the case. For example, even though you can find Ethernet hardware that runs with a theoretical throughput of 10,000 megabits per second, there are many older networks that continue to work just fine at one 1/100th that speed—or even 1/1,000th!</em></span></p></div><p>Finally, remember that designing a network is usually not an irreversible, permanent decision. Networks can be upgraded and expanded. While it is prudent to build some slack into any network to allow for growth, it is not wise to spend too much time and money planning for the future when changes can be made later. This is especially true given that network hardware prices drop over time. Again, this is a matter of drawing an appropriate balance between future performance planning and budget.</p></div></div>
<div class="sect1" title="Balancing Network Performance with Key Nonperformance Characteristics"><div class="titlepage"><div><div><h1 class="title"><a id="balancing_network_performance_with_key_n"/>Balancing Network Performance with Key Nonperformance Characteristics</h1></div></div></div><p>We all know that performance is very important to any network. However, anyone putting together a network must also be concerned with many different <a class="indexterm" id="idx-CHP-2-0082"/>nonperformance characteristics as well. Depending on the network, these can be just as essential to the users of the network as performance, and possibly even more critical. More than this, nonperformance issues often <span class="emphasis"><em>trade off</em></span> against performance, and in fact, more often than not they have to be reduced to get performance to increase.<a class="indexterm" id="idx-CHP-2-0083"/></p><p>Before you can create a very high-performance network, you must understand the key nonperformance network characteristics that you may need to compromise. The following are a few of these issues:</p><p><span class="strong"><strong>Design and Implementation Cost</strong></span> Unless you have bottomless pockets, you must be concerned with the network's costs. As mentioned earlier, cost is the main trade-off with performance. Going faster usually costs more money.</p><p><span class="strong"><strong>Quality</strong></span> The quality of the network is a function of the quality of the components used and how they are installed. Quality is important because it impacts all of the other factors, such as reliability and ease of administration, as well as performance. Quality doesn't trade off <span class="emphasis"><em>directly</em></span> with performance—you can design high-quality, high-performance networks—but it does <span class="emphasis"><em>compete</em></span> with performance for resources in the budget. All else being equal, it costs a great deal more to implement a high-quality, high-performance network than a high-quality, low-speed one.</p><p><span class="strong"><strong>Standardization</strong></span> Network protocols and hardware can be designed to meet either universally accepted standards or nonstandard, proprietary ones. Standard designs are almost always preferable, because they make interoperability, upgrading, support, and training easier. Proprietary standards may include enhancements that improve performance, but may increase cost or make management more difficult.</p><p><span class="strong"><strong>Reliability</strong></span> This is related to several other issues, especially quality and performance. Faster networks aren't necessarily less reliable, but they are more difficult and expensive to make run reliably than slower ones.</p><p><span class="strong"><strong>Expandability and Upgradability</strong></span> It's very important to always plan for the future when creating a <a class="indexterm" id="idx-CHP-2-0084"/>network. Higher-performance networks can be more difficult to expand, and they are certainly more expensive to expand. Once again, the matter of implementing a network with a capacity for future needs now, as opposed to upgrading later if it becomes necessary, is an important network design decision.</p><p><span class="strong"><strong>Ease of Administration and Maintenance</strong></span> Higher-performance networks require more work and resources to administer and maintain, and they are more likely to require troubleshooting than slower ones.</p><p><span class="strong"><strong>Premises and Utility Issues</strong></span> Implementation of high-<a class="indexterm" id="idx-CHP-2-0085"/>speed networks may be limited by the physical premises or may have an impact on how they are laid out. Choosing a higher-speed option may require more infrastructure to be put in place, thus increasing cost. The classic example of this is choosing between wired and wireless options for a home or small office network. You can go much faster with wires, but do you really want to run them?</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-15"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> While performance is one of the most important characteristics of any network, there are others that are equally important. In many cases, you must weigh the cost, quality, reliability, expandability, maintainability, and other attributes of a network against overall performance. The faster you want your network to go, the more difficult it is to ensure that these other attributes are kept at sufficiently high levels.</p></div></div>
<div class="sect1" title="Performance Measurements: Speed, Bandwidth, Throughput, and Latency"><div class="titlepage"><div><div><h1 class="title"><a id="performance_measurements_speed_bandwidth"/>Performance Measurements: Speed, Bandwidth, Throughput, and Latency</h1></div></div></div><p>A number of terms are commonly used to refer to various aspects of network performance. Some of them are quite similar to each other, and you will often see them used—and in many cases, misused or even <span class="emphasis"><em>ab</em></span>used! I'll examine each of them to see how they are commonly used and what they really mean.</p><div class="note" title="Note"><h3 class="title"><a id="note-8"/>Note</h3><p><span class="emphasis"><em>More than just the issue of different terms related to performance, however, is the more important reality that there are multiple</em></span> facets <span class="emphasis"><em>to performance. Depending on the application, the manner in which data is sent across the network may be more important than the raw speed at which it is transported. In particular, many multimedia applications require real-time performance; they need data sent in such a manner that it will be delivered steadily. For these purposes, raw speed isn't as important as</em></span> consistent <span class="emphasis"><em>speed. This is an issue that is often not properly recognized</em></span>.</p></div><div class="sect2" title="Speed"><div class="titlepage"><div><div><h2 class="title"><a id="speed"/>Speed</h2></div></div></div><p><span class="emphasis"><em>Speed</em></span> is the most generic performance term used in networking. As such, it can mean just about <span class="emphasis"><em>anything</em></span>. Most commonly, however, it refers to the <span class="emphasis"><em>rated</em></span> or <span class="emphasis"><em>nominal</em></span> speed of a particular networking technology. For example, <a class="indexterm" id="idx-CHP-2-0086"/>Fast Ethernet has a nominal speed of 100 Mbps (megabits per second); for that reason, it is often called 100 Mbps Ethernet, or given a designation such as <a class="indexterm" id="idx-CHP-2-0087"/>100BASE-TX.<a class="indexterm" id="idx-CHP-2-0088"/><a class="indexterm" id="idx-CHP-2-0089"/></p><p>Rated speed is the biggest performance magic number in networking—you see it used to label hardware devices, and many people bandy the numbers about as if those numbers actually represented the network's real speed. The problem with using nominal speed ratings is that they are only <span class="emphasis"><em>theoretical</em></span>, and as such, tell an incomplete story. No networking technology can run at its full-rated speed, and many run <span class="emphasis"><em>substantially</em></span> below it, due to real-world performance factors.</p><p>Speed ratings such as 100 Mbps Ethernet are also often referred to as the <span class="emphasis"><em>throughput</em></span> of a technology, even though the maximum theoretical speed of a technology is more analogous to <a class="indexterm" id="idx-CHP-2-0090"/>bandwidth than throughput, and the two are not identical.<a class="indexterm" id="idx-CHP-2-0091"/></p></div><div class="sect2" title="Bandwidth"><div class="titlepage"><div><div><h2 class="title"><a id="bandwidth"/>Bandwidth</h2></div></div></div><p>Bandwidth is a widely used term that usually refers to the data-carrying capacity of a network or data-transmission medium. It indicates the maximum amount of data that can pass from one point to another in a unit of time. The term comes from the study of electromagnetic radiation, where it refers to the width of a band of frequencies used to carry data. It is usually given in a theoretical context, though not always.</p><p>Bandwidth is still used in these two senses: frequency bandwidth and data capacity. For example, radio frequencies are used for wireless technologies, and the bandwidth of such technologies can refer to how wide the radio frequency band is. More commonly, though, bandwidth refers to how much data can be sent down a network, and it is often used in relative terms. For example, for Internet access, a cable or xDSL connection is considered high-bandwidth access; using a regular analog modem is low-bandwidth access.</p></div><div class="sect2" title="Throughput"><div class="titlepage"><div><div><h2 class="title"><a id="throughput"/>Throughput</h2></div></div></div><p>Throughput is a measure of how much actual data can be sent per unit of time across a network, channel, or interface. While throughput can be a theoretical term like bandwidth, it is more often used in a practical sense—for example, to measure the amount of data actually sent across a network in the real world. Throughput is limited by bandwidth, or by rated speed: If an Ethernet network is rated at 100 Mbps, that's the absolute upper limit on throughput, even though you will normally get quite a bit less. So, you may see someone say that they are using a 100 Mbps Ethernet connection but getting throughput of, say, 71.9 Mbps on their network.</p><p>The terms <span class="emphasis"><em>bandwidth</em></span> and <span class="emphasis"><em>throughput</em></span> are often used interchangeably, even though they are really not exactly the same.</p></div><div class="sect2" title="Latency"><div class="titlepage"><div><div><h2 class="title"><a id="latency"/>Latency</h2></div></div></div><p><span class="emphasis"><em>Latency</em></span> is a very important, often overlooked term, which refers to the <span class="emphasis"><em>timing</em></span> of data transfers on a communications channel or network. One important aspect of latency is how long it takes from the time a request for data is made until it starts to arrive. Another aspect is how much control a device has over the timing of the data that is sent, and whether the network can be arranged to allow for the consistent delivery of data over a period of time. Low latency is considered better than high latency.<a class="indexterm" id="idx-CHP-2-0092"/></p></div><div class="sect2" title="Summary of Performance Measurements"><div class="titlepage"><div><div><h2 class="title"><a id="summary_of_performance_measurements"/>Summary of Performance Measurements</h2></div></div></div><p>As with all networking terms, there are no hard-and-fast rules; many people are rather loose with their use of terms relating to performance measurement. You will even see terms such as <span class="emphasis"><em>throughput bandwidth</em></span>, <span class="emphasis"><em>bandwidth throughput</em></span>, and other charming inventions from the department of redundancy department. More often, you will just see a lot of mishmashed term usage, and especially, spurious conclusions being drawn about what data streams a network can handle based on its rated speed. Making matters worse is that speed ratings are usually specified in bits per second, but throughput may be given in bits or bytes per second.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-16"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The three terms used most often to refer to the overall performance of a network are <span class="emphasis"><em>speed, bandwidth</em></span>, and <span class="emphasis"><em>throughput</em></span>. These are related and often used interchangeably, but are not identical. The term <span class="emphasis"><em>speed</em></span> is the most generic and often refers to the rated or nominal speed of a networking technology. <span class="emphasis"><em>Bandwidth</em></span> can mean either the width of a frequency band used by a technology or more generally, data capacity, where it's used as more of a theoretical measure. <span class="emphasis"><em>Throughput</em></span> is a specific measure of how much data flows over a channel in a given period of time. It is usually a practical measurement.</p></div><p>In general, <span class="emphasis"><em>speed</em></span>, <span class="emphasis"><em>bandwidth</em></span>, and <span class="emphasis"><em>throughput</em></span> get a lot of attention, while <span class="emphasis"><em>latency</em></span> gets little. Yet latency considerations are very important for many real-time applications such as streaming audio and video and interactive gaming. In fact, they are often more important than raw bandwidth.</p><p>For example, suppose you move to a rural home, and your choices for Internet access are a regular 28.8 Kbps modem connection or fancy satellite Internet. The companies selling satellite connectivity call it "broadband" and advertise very high rated speeds—400 Kbps or more. They make a big deal about it being "over ten times as fast as dial-up," and they certainly charge a lot for this very high-tech service. This is a slam dunk, right?</p><p>Wrong. The satellite connection has high bandwidth, but very poor (high) latency due to the time it takes for the signals to travel to and from the satellite. It is definitely much better than the modem for downloading that nice little 150 MB patch from Microsoft. However, it is much <span class="emphasis"><em>worse</em></span> than the modem for playing the latest online video game with your buddy over the Internet, because of the latency, or <span class="emphasis"><em>lag</em></span>, in transmissions. Every move you make in your game will be delayed for over half a second as the signal bounces around between the satellite and the earth, making online gaming nearly impossible. Thus, whether satellite Internet is worth the extra money depends entirely on what you plan to use it for.<a class="indexterm" id="idx-CHP-2-0093"/></p><div class="note" title="Note"><h3 class="title"><a id="note-9"/>Note</h3><p><span class="emphasis"><em>An important issue closely related to latency is</em></span> quality of service, <span class="emphasis"><em>a general term that refers (among other things) to the ability of networks to deliver necessary bandwidth and reliable data transfer for applications that need it. See the section "Quality of Service (QoS)" later in the chapter</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-17"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Where bandwidth and throughput indicate how fast data moves across a network, <span class="emphasis"><em>latency</em></span> describes the nature of how it is conveyed. It is most often used to describe the delay between the time that data is requested and the time when it arrives. A networking technology with very high throughput and bad (high) latency can be worse for some applications than one with relatively low throughput but good (low) latency.</p></div></div></div>
<div class="sect1" title="Understanding Performance Measurement Units"><div class="titlepage"><div><div><h1 class="title"><a id="understanding_performance_measurement_un"/>Understanding Performance Measurement Units</h1></div></div></div><p>People who make networking hardware, or write materials that try to tell you how to operate it, use many terms to describe <a class="indexterm" id="idx-CHP-2-0094"/>performance, such as <span class="emphasis"><em>throughput</em></span> and <span class="emphasis"><em>bandwidth</em></span>. (These terms are explained in the previous section.) In addition, they also use several different <span class="emphasis"><em>units</em></span> to measure performance. Unfortunately, these units are often used incorrectly, and they are also very similar to each other in name. Worse, they also have overlapping abbreviations, and lots of people use these abbreviations without making clear what the heck they are talking about. Isn't that great?</p><div class="sect2" title="Bits and Bytes"><div class="titlepage"><div><div><h2 class="title"><a id="bits_and_bytes"/>Bits and Bytes</h2></div></div></div><p>The first issue is the infamous letter <span class="emphasis"><em>B</em></span>. Or rather, I should say, the matter of the big <span class="emphasis"><em>B</em></span> and the little <span class="emphasis"><em>b</em></span>. By popular convention, the capitalized <span class="emphasis"><em>B</em></span> is supposed to be used for byte, and the lowercase <span class="emphasis"><em>b</em></span> for bit—this is the way these abbreviations are always used in this book.<a class="indexterm" id="idx-CHP-2-0095"/></p><div class="note" title="Note"><h3 class="title"><a id="note-10"/>Note</h3><p><span class="emphasis"><em>A byte is normally eight bits; sometimes the term</em></span> octet <span class="emphasis"><em>is used instead. If you aren't familiar with these terms, refer to <a class="xref" href="ch04.html" title="Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING">Chapter 4</a> for a primer on binary basics, where you will also find a discussion of the small controversy related to bytes and octets</em></span>.</p></div><p>Unfortunately, this convention is not followed strictly by everyone. As a result, you may on occasion see <span class="emphasis"><em>b</em></span> being used to refer to bytes, and <span class="emphasis"><em>B</em></span> used for bits. This <span class="emphasis"><em>b</em></span> and <span class="emphasis"><em>B</em></span> business causes a tremendous amount of confusion sometimes, with people mistaking bits for bytes and accidentally thinking that networks are running eight times faster or slower than they really are.</p><p>Bear in mind when looking at speed ratings that they are almost always given in terms of bits, not bytes. The 56K in a modem rating means 56,000 bits, not 56,000 bytes of theoretical transfer speed. (This is true even if someone calls it a "56K" modem.) Similarly, Fast Ethernet operates at 100 mega<span class="emphasis"><em>bits</em></span> per second, not megabytes, and a 1.544 Mbps T1 link sends a theoretical maximum of 1,544,000 bits each second. This, at least, is usually pretty consistent.</p><p>When it comes to throughput measurements, however, both bits and bytes are used, so you have to be careful. Raw throughput values are normally given in bits per second, but many software applications report transfer rates in bytes per second, including many web browsers and FTP client programs. This often leads to users wondering why they are only getting one-eighth of their expected download or transfer speeds.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-18"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In most cases in discussions of networking performance, the lowercase letter <span class="emphasis"><em>b</em></span> refers to bits and the uppercase <span class="emphasis"><em>B</em></span> to bytes. However, these conventions are not always universally followed, so context must be used to interpret a particular measurement.</p></div><p>The standard unit for bit throughput is the bit per second, which is commonly abbreviated bit/s, bps, or b/s. The byte unit is byte per second, abbreviated bytes/s, Bps or B/s—unless some cruel author decides to use a lowercase <span class="emphasis"><em>b</em></span> just to confuse you! This means that the maximum theoretical throughput of 100BASE-TX (100 <a class="indexterm" id="idx-CHP-2-0096"/>Mbps) Ethernet is about 12 MB/s. Where the context is unclear, it is better to spell out the <a class="indexterm" id="idx-CHP-2-0097"/>unit as 100 Mbits/s or 12 Mbytes/s, which, of course, I try to do in this book.</p><p>You will also occasionally, especially when dealing in the realm of communications, see throughput measured in characters per second, or cps. In most computer systems (including PCs), each character takes up one byte, so cps is equivalent to bytes/s, B/s, or Bps.</p><p>Of course, most networking technologies don't move just a few bits and bytes around every second; they move, thousands, millions, or even billions. Thus, most speed ratings are not in <a class="indexterm" id="idx-CHP-2-0098"/>bits per second, but rather <span class="emphasis"><em>kilo</em></span>bits (Kb), <span class="emphasis"><em>mega</em></span>bits (Mb), or <span class="emphasis"><em>giga</em></span>bits (Gb) per second, and the same thing can be done for bytes. Thus, you find terms such as 100 Mbps Ethernet or 700 kb/s ADSL.<a class="indexterm" id="idx-CHP-2-0099"/><a class="indexterm" id="idx-CHP-2-0100"/><a class="indexterm" id="idx-CHP-2-0101"/></p><p>Here, you run into another problem: the existence of both <a class="indexterm" id="idx-CHP-2-0102"/>decimal and binary versions of the terms <span class="emphasis"><em>kilo</em></span>, <span class="emphasis"><em>mega</em></span>, and <span class="emphasis"><em>giga</em></span>. For example, the decimal form of the prefix for a million (mega) is 10<sup>6</sup> or 1,000,000, while the binary form is 2<sup>20</sup> or 1,048,576. This differential of about 5 percent leads to all sorts of confusion. When you see these abbreviations, bear in mind that in networking, they almost always refer to the decimal form. Thus, 100 Mbps Ethernet is <a class="indexterm" id="idx-CHP-2-0103"/>rated at 100,000,000 bits per second, not 104,857,600 bits per second.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-19"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The unit most often used to express networking throughput is <span class="emphasis"><em>bits per second</em></span> or <span class="emphasis"><em>bps</em></span>. This term is often expressed in thousands, millions, or billions as <span class="emphasis"><em>Kbps</em></span>, <span class="emphasis"><em>Mbps</em></span>, or <span class="emphasis"><em>Gbps</em></span>. It almost always uses the decimal, not binary, versions of the kilo, mega, or giga multipliers.</p></div></div><div class="sect2" title="Baud"><div class="titlepage"><div><div><h2 class="title"><a id="baud"/>Baud</h2></div></div></div><p>Finally, there's another term that you will encounter frequently in discussions of modems and some other technologies: the <span class="emphasis"><em>baud</em></span>. Named for telegraphy pioneer Jean-Maurice-Émile <a class="indexterm" id="idx-CHP-2-0104"/>Baudot (1845–1903), this unit measures the number of changes, or transitions, that occur in a signal in each second. So, if the signal changes from a one value to a zero value (or vice versa) one hundred times per second, that is a rate of 100 baud.<a class="indexterm" id="idx-CHP-2-0105"/></p><p>In the early days of very slow modems, each bit transition encoded a single bit of data. Thus, 300 baud modems sent a theoretical maximum of 300 bits per second of data. This led to people confusing the terms <span class="emphasis"><em>baud</em></span> and <span class="emphasis"><em>bits per second</em></span>—and the terms are still used interchangeably <span class="emphasis"><em>far</em></span> too often. You will commonly hear people refer to a 28.8 Kbps modem, for example, as running at 28,800 baud.</p><p>But the two <a class="indexterm" id="idx-CHP-2-0106"/>units are in fact not the same; one measures data (the throughput of a channel), and the other measures transitions (called the <span class="emphasis"><em>signaling rate</em></span>). Modern modems use advanced modulation techniques that encode more than one bit of data into each transition. A 28,800 bps modem typically encodes nine bits into each transition; it runs at 3,200 baud, not 28,800 baud (the latter number being the product of 3,200 and 9). In fact, there's no way to operate a modem on a conventional phone line at 28,800 baud—it exceeds the frequency bandwidth of the phone line. That's the reason why advanced modulation is used to encode more data into each transition.<a class="indexterm" id="idx-CHP-2-0107"/></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-20"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>baud</em></span> and <span class="emphasis"><em>bps</em></span> units are often treated equivalently, but are not the same. <span class="emphasis"><em>Baud</em></span> measures not the throughput of a network but its signaling rate, meaning the number of times that the signal changes value in each second. Since modern encoding and modulation techniques often encode either greater or less than one bit value into each such transition, the throughput and baud rate of network technologies are usually different.</p></div></div></div>
<div class="sect1" title="Theoretical and Real-World Throughput, and Factors Affecting Network Performance"><div class="titlepage"><div><div><h1 class="title"><a id="theoretical_and_real-world_throughput_an"/>Theoretical and Real-World Throughput, and Factors Affecting Network Performance</h1></div></div></div><p>When assessing the performance of networks, keep in mind that there is always a difference between theoretical speed ratings and real-world throughput. If your network is set up well, this difference is relatively small but still significant. Otherwise, the difference can be extremely large. (Notice that the difference between theoretical and practical performance can never be negligible.)</p><p>There are many reasons for the difference between what a network or communications method is supposed to be able to do and what it actually can do. The reasons generally fall into three categories: normal network overhead, external performance limiters, and network configuration problems.</p><div class="note" title="Note"><h3 class="title"><a id="note-11"/>Note</h3><p><span class="emphasis"><em>There are many different ways of measuring and assessing performance. Synthetic benchmark programs are often used to measure throughput, and can produce impressive performance scores, which usually have little to do with how a network will actually operate. Such metrics are best used for comparison purposes by showing that one network or system is faster than another, rather than by paying too much attention to the actual number the metrics produce. Even when doing comparisons, however, caution is wise</em></span>.</p></div><div class="sect2" title="Normal Network Overhead"><div class="titlepage"><div><div><h2 class="title"><a id="normal_network_overhead"/>Normal Network Overhead</h2></div></div></div><p>Every network has some degree of normal network overhead, which guarantees that you will never be able to use all of the bandwidth of any connection for data. Take as an example 10 Mbps Ethernet. Sure, the line may be able to transmit 10,000,000 bits every second, but not all of those bits are data! Some are used to package and address the data—data can't just be thrown onto the network in raw form. Also, many of those bits are used for general overhead activities, and they deal with collisions on transmissions and other issues. There are natural inefficiencies in any networking technology.</p><p>Even beyond this, there are other overhead issues. Any network transaction involves a number of different hardware and software layers, and overhead exists at each of them, from the application and operating system down to the hardware. These overheads mean that you generally lose at least 20 percent of the rated speed of a local area network (LAN) technology off the top, and sometimes even more. For example, 7 Mbps user data throughput on a regular 10 Mbps Ethernet network is actually very good.</p></div><div class="sect2" title="External Performance Limiters"><div class="titlepage"><div><div><h2 class="title"><a id="external_performance_limiters"/>External Performance Limiters</h2></div></div></div><p>There are <a class="indexterm" id="idx-CHP-2-0108"/>external factors that limit the performance of a network. Important issues here include the ability of the hardware to process the data and also any bandwidth limitations that exist in the chain of data transmission between two nodes. Hardware issues most often show up with very fast networking technologies.</p><p>Consider a <a class="indexterm" id="idx-CHP-2-0109"/>gigabit (1,000 Mbps) Ethernet connection between two regular PCs. In theory, this connection should allow the transmission of 1 GB of data every second. Even beyond the matter of overhead mentioned earlier, no regular PC is capable of pumping this much data per second. Only high-end servers have this capacity—and even they would have problems sustaining this unless they were doing nothing else. An older PC's hard disk probably can't even stream data fast enough to keep a 100 Mbps Ethernet connection busy. Thus, upgrading a 100 Mbps Ethernet card in an older machine to gigabit is not likely to help as much as you might expect.</p><p>Bandwidth limitations cause network throughput issues because the entire network can run only as fast as its slowest link. These <a class="indexterm" id="idx-CHP-2-0110"/>bottlenecks create reduced performance. As a common example, suppose you have a cable modem connection to the Internet that is rated at 1 Mbps for downloads. It may be very fast most of the time, but if the website you are accessing is totally bogged down or it is having connectivity problems itself, you are not going to download from that site at 1 Mbps. In fact, your download probably won't even get close to that speed.</p><p>Finally, it's also important to remember that there are many technologies that simply do not always operate at a constant fixed speed, though they may change speeds based on physical network characteristics. A good example is an analog modem, which can vary greatly in performance depending on the quality of the line over which it operates.</p></div><div class="sect2" title="Network Configuration Problems"><div class="titlepage"><div><div><h2 class="title"><a id="network_configuration_problems"/>Network Configuration Problems</h2></div></div></div><p>The issues I mentioned earlier are usually ones that you cannot do anything about; they are just the nature of the networking beast. The third category of performance limiters, <span class="emphasis"><em>misconfiguration</em></span>, is different. This refers to network slowdowns that occur because hardware or software has not been set up correctly. Poor cabling, misconfigured interface cards, or bad drivers can <span class="emphasis"><em>seriously</em></span> reduce the performance of a network—by 90 percent or even more.</p><p>These problems can usually be corrected, but only if you are looking for them. Driver problems are particularly insidious because the natural tendency is for people to blame hardware when slowdowns occur. However, you cannot get the most of your hardware devices without proper software to run it. These issues are much more significant with bleeding-edge hardware than with established products, incidentally.</p><p>Also included in this category of issues are problems that occur due to poor design. For example, putting 30 busy workstations on a shared 10 Mbps Ethernet segment is likely to result in poor performance—using a switch would be much better. Another common mistake is not providing a "fatter pipe" (higher bandwidth connection) to servers in a client/server setup. These issues can be avoided or ameliorated by reconfiguring the network—or even better, by designing it properly in the first place, right?</p></div><div class="sect2" title="Asymmetry"><div class="titlepage"><div><div><h2 class="title"><a id="asymmetry"/>Asymmetry</h2></div></div></div><p>Bear in mind that many networking technologies, especially ones used for Internet access, are <span class="emphasis"><em>asymmetric</em></span>, meaning that they offer much higher bandwidth in one direction than the other. Usually, this is arranged so that more bandwidth goes down to the user than from the user to the network, since most Internet users download far more than they upload. However, it's always important to find out if a speed rating is for both directions, or for only one direction, and if so, what the other direction's speed is. Common technologies with asymmetric performance include 56K modems, <a class="indexterm" id="idx-CHP-2-0111"/>Asymmetric Digital Subscriber Line (<a class="indexterm" id="idx-CHP-2-0112"/>ADSL), <a class="indexterm" id="idx-CHP-2-0113"/>cable modems, and satellite Internet access. Beware, because the marketing people who sell these technologies will often try to hide the asymmetry of their services, usually highlighting only the bigger download figure and avoiding mention of the slower uploads.<a class="indexterm" id="idx-CHP-2-0114"/></p><p>Asymmetry can also have unexpected effects on network performance, because most communications, even if they seem unidirectional, are not. The most common case is when an Internet access technology has much higher download bandwidth than upload bandwidth. When using TCP/IP to download data, acknowledgments must be sent regularly. If the upstream bandwidth is too low, this may make it impossible to fully exploit the download bandwidth of the link.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-21"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The theoretical rated speed of a network is never achieved in practice for a number of reasons. <span class="emphasis"><em>Overhead</em></span> issues mean that not all of the possible capacity of a network can be used for data. <span class="emphasis"><em>External factors</em></span> such as hardware bandwidth limitations restrict data input and output. <span class="emphasis"><em>Configuration problems</em></span> can also greatly reduce real-world performance. Finally, it is important to remember that many technologies are asymmetric, offering higher speed in one direction than the other, and often, the larger number is the one that is advertised.</p></div></div></div>
<div class="sect1" title="Simplex, Full-Duplex, and Half-Duplex Operation"><div class="titlepage"><div><div><h1 class="title"><a id="simplex_full-duplex_and_half-duplex_oper"/>Simplex, Full-Duplex, and Half-Duplex Operation</h1></div></div></div><p>Another aspect of performance that is worthy of some attention is the mode of operation of the network or connection. Obviously, whenever we connect together Device A and Device B, there must be some way for Device A to send to Device B and Device B to send to Device A. Many people don't realize, however, that networking technologies can differ in terms of how these two directions of communication are handled. Depending on how the network is set up and the characteristics of the technologies used, you may be able to improve performance through the selection of performance-enhancing modes.<a class="indexterm" id="idx-CHP-2-0115"/></p><p>Let's begin with a look at the three basic modes of operation that can exist for any network connection, communications channel, or interface.</p><div class="sect2" title="Simplex Operation"><div class="titlepage"><div><div><h2 class="title"><a id="simplex_operation"/>Simplex Operation</h2></div></div></div><p>In <span class="emphasis"><em>simplex</em></span> <a class="indexterm" id="idx-CHP-2-0116"/>operation, a network cable or communications channel can send information in only one direction; it's a one-way street. This may seem counterintuitive: What's the point of communications that travel in only one direction? In fact, there are at least two different places in which simplex operation is encountered in modern networking.</p><p>The first is when two distinct channels are used for communication: one transmits from A to B and the other from B to A. This is surprisingly common, even though it isn't always obvious. For example, most, if not all, <a class="indexterm" id="idx-CHP-2-0117"/>fiber-optic communication is simplex, meaning that it uses one strand to send data in each direction. But this may not be obvious if the pair of fiber strands are combined into one cable.</p><p>Simplex operation is also used in special types of technologies, especially ones that are asymmetric. For example, one type of satellite Internet access sends data over the satellite only for downloads, while a regular dial-up modem is used for upload to the service provider. In this case, both the satellite link and the dial-up connection are operating in a simplex mode.</p></div><div class="sect2" title="Half-Duplex Operation"><div class="titlepage"><div><div><h2 class="title"><a id="half-duplex_operation"/>Half-Duplex Operation</h2></div></div></div><p>Technologies that employ <span class="emphasis"><em>half-duplex</em></span> operation are capable of sending information in both directions between two nodes, but only one direction or the other can be utilized at a time. This is a fairly common mode of operation when there is only a single network medium (cable, radio frequency, and so forth) between devices.</p><p>While this term is often used to describe the behavior of a pair of devices, it can refer more generally to any number of connected devices that take turns transmitting information. For example, in conventional Ethernet networks, any device can transmit, but only one may do so at a time. For this reason, regular (unswitched) Ethernet networks are often said to be half-duplex, even though it may seem strange to describe a LAN that way.</p></div><div class="sect2" title="Full-Duplex Operation"><div class="titlepage"><div><div><h2 class="title"><a id="full-duplex_operation"/>Full-Duplex Operation</h2></div></div></div><p>In <span class="emphasis"><em>full-duplex</em></span> operation, a connection between two devices is capable of sending data in both directions simultaneously. Full-duplex channels can be constructed either as a pair of simplex links (as described earlier) or by using one channel that's designed to permit bidirectional simultaneous transmissions. A full-duplex link can connect only two devices, so many such links are required if multiple devices are to be connected together.<a class="indexterm" id="idx-CHP-2-0118"/></p><div class="note" title="Note"><h3 class="title"><a id="note-12"/>Note</h3><p><span class="emphasis"><em>The term</em></span> full-duplex <span class="emphasis"><em>is somewhat redundant;</em></span> duplex <span class="emphasis"><em>would suffice, but everyone still says full-duplex (likely, to differentiate this mode from half-duplex)</em></span>.</p></div><p>Of these three options, full-duplex is obviously the one that yields the highest performance. Full-duplex operation doubles the theoretical bandwidth of the connection. If a link normally runs at 1 Mbps but can work in full-duplex mode, it really has 2 Mbps of bandwidth (1 Mbps in each direction). Remember the key word <span class="emphasis"><em>theoretical</em></span>, however—you do not really get double the performance in real life, because communications usually do not involve sending a lot of data in both directions at once. However, you certainly get better throughput than you do in a half-duplex mode.</p><p>In some cases, the mode of operation is a function of the technology and cannot be changed. In others, however, full-duplex mode is a matter of the correct hardware settings, and also whether the software supports full-duplex operation. Thus, getting higher performance in this area is sometimes simply a matter of ensuring proper configuration.</p><p>Full-duplex operation has been pretty much taken for granted in communications for years. The more interesting development has been the rise in the significance of full-duplex operation for local area networking. Traditionally, LANs have always used half-duplex operation on a shared access medium. As the use of switches has increased, thereby allowing dedicated bandwidth to each computer, full-duplex operation has become very popular. Full-duplex operation in Ethernet not only allows the simultaneous transmission of data in both directions, but also eliminates contention for the formerly shared access medium—thus, no more collisions. The combination of these two effects improves performance, sometimes substantially.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-22"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> There are three basic operating modes that describe how data is sent between connected devices on a network. In a <span class="emphasis"><em>simplex</em></span> operation, data can flow in only one direction between two devices. <span class="emphasis"><em>Half-duplex</em></span> networks allow any device to transmit, but only one may do so at a time. <span class="emphasis"><em>Full-duplex</em></span> operation means two attached devices can each transmit and receive simultaneously. The latter offers the greatest potential performance, because forcing one device to wait for another before sending data does not decrease throughput.</p></div></div></div>
<div class="sect1" title="Quality of Service (QoS)"><div class="titlepage"><div><div><h1 class="title"><a id="quality_of_service_qos"/>Quality of Service (QoS)</h1></div></div></div><p>In my discussion of common network performance measurements earlier in this chapter, I mentioned that there are many different aspects to network performance. I also introduced the concept of <span class="emphasis"><em>latency</em></span>, which measures how long it takes for data to travel across a network. Latency is one important part of a larger issue in networking that is sometimes called <span class="emphasis"><em>quality of service</em></span> or <span class="emphasis"><em>QoS</em></span>.<a class="indexterm" id="idx-CHP-2-0119"/><a class="indexterm" id="idx-CHP-2-0120"/><a class="indexterm" id="idx-CHP-2-0121"/></p><p>The inherent nature of most networking technologies is that they are more concerned with pumping data from one place to another as fast as possible than they are with how the data is sent. For example, the Internet is designed on top of the Internet Protocol (IP), a packet-switching technology (described in <a class="xref" href="ch01.html" title="Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS, AND TYPES">Chapter 1</a>) that is designed to get packets from point A to point B in the most effective way, without requiring the user to have any knowledge about what route will be taken. In fact, some packets in the same data stream may be sent along different routes. Packets may be stored for a while before being forwarded to their destination, or even dropped and retransmitted.</p><p>For most applications, such as simple file or message transfers, this is perfectly fine. However, there are applications for which this sort of service represents low quality. In these cases, the nature of how the data is delivered is more important than merely how fast it is, and there is a need for technologies or protocols that offer QoS. This general term can encompass a number of related features such as the following:</p><p><span class="strong"><strong>Bandwidth Reservation</strong></span> The ability to reserve a portion of bandwidth in a network or interface for a period of time so that two devices can count on having that bandwidth for a particular operation. This is used for multimedia applications for which data must be streamed in real time, and packet rerouting and retransmission would result in problems. This is also called <span class="emphasis"><em>resource reservation</em></span>.</p><p><span class="strong"><strong>Latency Management</strong></span> A feature that limits the latency between two devices in any data transfer to a known value.</p><p><span class="strong"><strong>Traffic Prioritization</strong></span> In conventional networks, all packets are created equal. A useful QoS feature is the ability to handle packets so that more important connections receive priority over less important ones.</p><p><span class="strong"><strong>Traffic Shaping</strong></span> This refers to the use of buffers and limits, both of which restrict traffic across a connection to a value below a predetermined maximum.</p><p><span class="strong"><strong>Network Congestion Avoidance</strong></span> This QoS feature refers to monitoring particular connections in a network and rerouting data when a particular part of the network is becoming congested.</p><p>So, in essence, QoS in the networking context is analogous to QoS in the real world. It is the difference between getting take-out and sit-down service at a nice French restaurant—both cure the hunger pangs, but they meet very different needs. Some applications, especially multimedia applications such as voice, music, and video, are time dependent and require a constant flow of information more than raw bandwidth.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-23"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The generic term <span class="emphasis"><em>quality of service (QoS)</em></span> describes the characteristics of how data is transmitted between devices, rather than how quickly it is sent. QoS features seek to provide more predictable streams of data rather than faster ones. Examples of such features include bandwidth reservation, latency minimums, traffic prioritization and shaping, and congestion limitation. QoS is more important for specialty applications, such as multimedia, than for routine applications, such as those that transfer files or messages.</p></div><p>To support QoS requirements, many newer technologies have been developed or enhanced to add QoS features to them. This includes the ability to support <span class="emphasis"><em>isochronous transmissions</em></span> that can reserve a specific amount of bandwidth over time to support applications that must send data in real time. One technology that has received a lot of attention for its QoS features is Asynchronous Transfer Mode (ATM). ATM is designed to support traffic-management features that are not generally available on networks that haven't been optimized to provide QoS features (such as Ethernet).</p><p>QoS has become a big buzzword lately. By itself, this term conveys about as much useful information about what the technology offers as being told that it is high performance. You have to dig past the marketing-speak and find out exactly what QoS features are being offered.</p></div>
<div class="chapter" title="Chapter&#xA0;3.&#xA0;NETWORK STANDARDS AND STANDARDS ORGANIZATIONS"><div class="titlepage"><div><div><h1 class="title"><a id="network_standards_and_standards_organiza"/>Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2498"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> You can't study networking and its related technologies without very quickly encountering a whole host of standards that are related to the subject, as well as the organizations that create these standards. Network standards facilitate the interoperability of network technologies and are extremely important. It may be an exaggeration to say that networking would not exist without standards, but it isn't an exaggeration to say that networking <span class="emphasis"><em>as we know it</em></span> would not exist without them. Networks are literally everywhere, and every hardware device or protocol is governed by at least one standard and usually many.</p><p>In this chapter, I briefly examine the often overlooked subject of <a class="indexterm" id="idx-CHP-3-0122"/>network standards and standards organizations. I begin with a background discussion of why standards are important, highlighting the differences between proprietary, de facto, and open standards. I give an overview of networking standards in general terms and then describe the most important international standards organizations and industry groups related to networking. I then describe the structure of the organizations responsible for Internet standards, including the registration authorities and registries that manage resources such as addresses, domain names, and protocol values. I conclude with a discussion of the Request for Comment (RFC) process used for creating Internet standards.</p><div class="sect1" title="Proprietary, Open, and De Facto Standards"><div class="titlepage"><div><div><h1 class="title"><a id="proprietary_open_and_de_facto_standards"/>Proprietary, Open, and De Facto Standards</h1></div></div></div><p>Why are standards important? An old saw in the computer world says, "The beauty of standards is that there are so many to choose from." This little joke reflects the frustration that technicians often feel at the thousands of standards that are found in the industry. Aside from differing in terms of content—what technologies and protocols they describe—standards also often differ in terms of their type and how they came about. In fact, part of the reason why there are sometimes so many to choose from in a particular area is <span class="emphasis"><em>because</em></span> of how they come about.<a class="indexterm" id="idx-CHP-3-0123"/></p><div class="sect2" title="Proprietary Standards"><div class="titlepage"><div><div><h2 class="title"><a id="proprietary_standards"/>Proprietary Standards</h2></div></div></div><p>In the early days of computing, many people didn't quite understand just how important universal standards were. Most companies were run by skilled inventors, who came up with great ideas for new technologies, but who weren't particularly interested in sharing them. It wasn't considered a smart business move to share information about new inventions with other companies—the competition! Oh sure, companies believed that standards were important, but they thought it was even more important that <span class="emphasis"><em>they</em></span> be the ones to control those standards.<a class="indexterm" id="idx-CHP-3-0124"/></p><p>For example, imagine that it's 1985, and I have just come up with a great networking technology, which I have incorporated into a fancy new local area networking (LAN) product called SooperDooperNet. SooperDooperNet is <span class="emphasis"><em>my</em></span> product. I have patents on the technology, I control its design and manufacture, and I sure as heck don't tell anyone else how it works, because if I did, someone would copy me.</p><p>I could sell interface cards, cables, and accessories for SooperDooperNet, and companies that wanted to use it could install the cards in all of their PCs and be assured that those computers would be able to talk to each other. This solves the interoperability problem for this company by creating a "SooperDooperNet standard." This would be an example of a <span class="emphasis"><em>proprietary</em></span> standard—it's owned by one company or person.</p><p>The problem with proprietary standards is that other companies are excluded from the standard development process, and therefore have little incentive to cooperate with the standard owner. In fact, just the opposite: They have a strong motivation to develop a competing proprietary standard, even if it doesn't improve on the existing one.</p><p>So when my competition sees what I am doing, he is not going to also create network interface cards that can work with SooperDooperNet, which would require paying me a royalty. Instead, he is going to develop a new line of networking hardware called MegaAwesomeNet, which is very similar to SooperDooperNet in operation but uses different connectors, cable, and logic. He, too, will try to sell bunches of cards and cables to my customers.</p><p>The problem here is that the market ends up with different companies using different products that don't work together. If you install SooperDooperNet, you <span class="emphasis"><em>have</em></span> to come to me for any upgrades or changes—you have no choice. Worse, what happens if Acme Manufacturing, which has 50 PCs running SooperDooperNet, merges with Emca Manufacturing, which has 40 PCs running MegaAwesomeNet? The IT people have a problem. Sure, there would be ways to solve it, but wouldn't everyone be better off avoiding these difficulties in the first place? And how could you create something like the Internet if everyone's networks use different "standards"?</p></div><div class="sect2" title="Open Standards"><div class="titlepage"><div><div><h2 class="title"><a id="open_standards"/>Open Standards</h2></div></div></div><p>Eventually, companies learned that they would be better off with standards that everyone agreed on. This is particularly true of networking, where devices need to talk to each other. If many companies get together and agree to cooperate, they can create an <span class="emphasis"><em>open standard</em></span> instead of a bunch of proprietary ones. The name is rather self-explanatory; rather than being the closely guarded secret of one organization, an open standard is available to anyone who is interested in using it.<a class="indexterm" id="idx-CHP-3-0125"/><a class="indexterm" id="idx-CHP-3-0126"/></p><p>One key to the success of an open standard is a steering organization to promote it. Usually, a neutral, nonprofit trade association or working group is established to develop the standard, and the various for-profit hardware and software companies join this group and support it financially. These groups also work with standards approval bodies like the International Telecommunication Union (ITU) and International Organization for Standardization (ISO) to gain acceptance for their standards. These and other standards organizations are described in the "International Networking Standards Organizations" section later in this chapter.</p><p>Of course, the companies aren't doing this just to be nice to their customers. In creating <a class="indexterm" id="idx-CHP-3-0127"/>open standards, they split the market-share pie among them, but they make the pie grow much larger by attracting more customers. Customers like open standards more than proprietary ones, because those standards give them more choices and increase their ability to interact with other companies, troubleshoot problems, hire skilled workers, and expand in the future. As for the companies, they still compete with their specific offerings, so it's not like they all end up making the same products. For all of these reasons, open standards are now far more common than proprietary ones.</p><p>However, the process involved in creating these standards is often a difficult one. In some cases, the standards organization will draft the standard from the ground up, but in others, it may select one technology as the basis for the standard from several that are submitted in what is commonly called a "technology bake-off." Thus, many different companies may come to the table with different approaches, each of them vying for selection as the standard for use by the group. Politics can cause groups to get bogged down for years fighting over various options, or even to split into multiple groups. Good examples are what occurred in the conflict between supporters of <a class="indexterm" id="idx-CHP-3-0128"/>100VG-AnyLAN and Fast Ethernet, and the problems with standards politics that have plagued the world of powerline networking.</p><p>Furthermore, there are still some companies that believe strongly in proprietary <a class="indexterm" id="idx-CHP-3-0129"/>standards, because they really want to control and direct the market. One of the most famous (infamous) in this regard is Sony, a company that makes excellent hardware but frequently refuses to accept established standards. For this reason, some people avoid Sony's products, even though they are good, because they want to stick to industry standards.</p></div><div class="sect2" title="De Facto Standards"><div class="titlepage"><div><div><h2 class="title"><a id="de_facto_standards"/>De Facto Standards</h2></div></div></div><p>This brings me to the third type of standard that is often <a class="indexterm" id="idx-CHP-3-0130"/>seen in the computer world: the <span class="emphasis"><em>de facto standard</em></span>. "De facto" is Latin for "in fact." A de facto standard is one that is used as a universal standard just because, over time, it has been widely used, and not because the standard was developed and approved by a standards committee.<a class="indexterm" id="idx-CHP-3-0131"/></p><p>A good example of a de facto standard is the AT command set used by modems. Virtually all modems use it, but this acceptance didn't result from an industry group agreeing to adopt and deploy it. Rather, it was developed unilaterally by Hayes, the pioneering modem company, and then adopted by virtually every other modem maker until it became a standard.</p><p>One reason why proprietary standards are still sometimes seen is that some companies want to produce a standard that will become so universally used that it becomes the de facto standard, thus giving them a leadership position in that market. Again, in my estimation, Sony falls into this category—the developers often want to do things their way and create proprietary standards that they try to promote using their powerful market presence.</p><p>Sometimes this succeeds, but often it does not, resulting in a fragmented market of incompatible products. An excellent example is when Sony created a new format for a digital camera's flash memory (the Memory Stick) rather than using the CompactFlash format used by other camera manufacturers. The end result was that not everyone used memory sticks as Sony had hoped, and there were now two incompatible standards that increased confusion and yielded no real benefit to the customer.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-24"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <a class="indexterm" id="idx-CHP-3-0132"/>Networking standards can be classified as <span class="emphasis"><em>proprietary, open</em></span>, or <span class="emphasis"><em>de facto</em></span>. Proprietary standards are owned by one particular organization. If that organization has sufficient market clout and the industry lacks alternatives to its standard, it may be adopted by the whole industry, becoming a de facto standard. Usually, however, differing proprietary standards compete with each other, resulting in a fragmented market. In contrast, open standards are not owned by anyone—they are created by neutral organizations to ensure that compatible products can be designed and developed by many different companies. This makes life easier for the customer and also promotes the market as a whole.</p></div></div></div></div>
<div class="sect1" title="Networking Standards"><div class="titlepage"><div><div><h1 class="title"><a id="networking_standards"/>Networking Standards</h1></div></div></div><p>All networking technologies have standards associated with them. These are usually highly technical documents, and they often presume that the reader has a fair bit of knowledge about networking. If you aren't an expert, you will probably have some difficulty understanding networking standards.</p><p>In fact, many technologies have quite a number of standards associated with them. A networking technology may have more than one standard for any or all of the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The original standard has been revised or updated.</p></li><li class="listitem"><p>The technology is sufficiently complex that it needs to be described in more than one document.</p></li><li class="listitem"><p>The technology borrows from or builds on documents used in related technologies.</p></li><li class="listitem"><p>More than one organization has been involved in developing the technology.</p></li></ul></div><p>Standards documents created in the United States are usually developed in English, but are also routinely translated into other languages. European standards are often published simultaneously in English, French, German, and perhaps other languages as well.</p><p>Today, virtually all networking standards are open standards, administered by a standards organization or industry group. As I explained in the previous section, open standards are more popular than proprietary ones in the computer industry, and that's especially true when it comes to networking. In fact, the few technologies for which there is no universally accepted open standard have been losing ground to those with open standards, particularly in the areas of wireless LANs and home networking. This pretty much proves how important an open process really is.</p><div class="note" title="Note"><h3 class="title"><a id="note-13"/>Note</h3><p><span class="emphasis"><em>You'll find discussions of various standards throughout this book. These can usually be found in an overview chapter introducing each technology type, though the discussions of more complex protocols include a section discussing relevant standards</em></span>.</p></div></div>
<div class="sect1" title="International Networking Standards Organizations"><div class="titlepage"><div><div><h1 class="title"><a id="international_networking_standards_organ"/>International Networking Standards Organizations</h1></div></div></div><p>The rise of open standards has been a great boon to customers of computer and networking products, as well as to the manufacturers that sell to them. In order to facilitate the development of open standards, however, we need <a class="indexterm" id="idx-CHP-3-0133"/>organizations that will coordinate the creation and publishing of these documents. Generally, these are nonprofit organizations that specifically take a neutral stance regarding technologies and work for the betterment of the industry as a whole.<a class="indexterm" id="idx-CHP-3-0134"/></p><p>Here is a selective list of some of the standards organizations that you are likely to encounter when reading about networking and the Internet:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0135"/>International Organization for Standardization (ISO)</strong></span> Probably the biggest standards organization in the world, the <a class="indexterm" id="idx-CHP-3-0136"/>ISO is really a federation of standards organizations from dozens of nations. In the networking world, the ISO is best known for its OSI Reference Model, which is discussed in <a class="xref" href="pt02.html" title="Part I-2. THE OPEN SYSTEMS INTERCONNECTION (OSI) REFERENCE MODEL">Part I-2</a> of this book.</p><div class="note" title="Note"><h3 class="title"><a id="note-14"/>Note</h3><p><span class="emphasis"><em>The shortened name of the International Organization for Standardization is indeed ISO, not IOS, as you might imagine. In fact, it is not an acronym at all. Since the full name of the body differs from one language the next, any acronym for that name would differ as well. Instead, the organization chose the name ISO from the Greek word</em></span> isos, <span class="emphasis"><em>meaning equal. Many people, especially in the United States, think ISO is short for International Standards Organization, but this is incorrect</em></span>.</p></div><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0137"/>American National Standards Institute (ANSI)</strong></span> <a class="indexterm" id="idx-CHP-3-0138"/>ANSI is the main organization responsible for coordinating and publishing computer and <a class="indexterm" id="idx-CHP-3-0139"/>information technology standards in the United States. Although many people think that this organization develops and maintains standards, it does neither. Instead, it oversees and accredits the organizations that actually create the standards, qualifying them as <span class="emphasis"><em>Standards Developing Organizations</em></span> or <span class="emphasis"><em>SDOs</em></span>. ANSI also publishes the standards documents created by the SDOs and serves as the United States' representative to the ISO.<a class="indexterm" id="idx-CHP-3-0140"/><a class="indexterm" id="idx-CHP-3-0141"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0142"/>Information Technology Industry Council (ITIC)</strong></span> <a class="indexterm" id="idx-CHP-3-0143"/>ITIC is a group of several dozen companies in the information technology (computer) industry. ITIC is the SDO approved by ANSI to develop and process standards related to many computer-related topics. It was formerly known as the <span class="emphasis"><em>Computer and Business Equipment Manufacturers Association (CBEMA)</em></span>.<a class="indexterm" id="idx-CHP-3-0144"/><a class="indexterm" id="idx-CHP-3-0145"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0146"/>National Committee for Information Technology (NCITS)</strong></span> <a class="indexterm" id="idx-CHP-3-0147"/>NCITS is a committee established by the ITIC to develop and maintain standards related to the information-technology world. NCITS was formerly known by the name <span class="emphasis"><em>Accredited Standards Committee X3, Information Technology</em></span>, or more commonly, just <span class="emphasis"><em>X3</em></span>. It maintains several subcommittees that develop and maintain standards for various technical subjects.<a class="indexterm" id="idx-CHP-3-0148"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0149"/>Institute of Electrical and Electronics Engineers (<a class="indexterm" id="idx-CHP-3-0150"/>IEEE)</strong></span> The IEEE (pronounced "eye-triple-ee") is a well-known professional organization for those in the electrical or electronics fields, including computers and networking. IEEE's main claim to fame in the networking industry is the IEEE 802 Project, which encompasses many popular networking technologies, including Ethernet.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0151"/>Electronic Industries Alliance (<a class="indexterm" id="idx-CHP-3-0152"/>EIA)</strong></span> The EIA is an international industry association that is best known for publishing electrical wiring and transmission standards.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0153"/>Telecommunications Industry Association (TIA)</strong></span> The <a class="indexterm" id="idx-CHP-3-0154"/>TIA is the communications sector of the EIA, and it is responsible for developing communications standards. Since communications, wiring, and transmission are all related, and since the TIA and EIA organizations are also related, standards produced by the EIA or TIA are often labeled with the combined prefixes EIA/TIA or TIA/EIA.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0155"/>International Telecommunication Union—Telecommunication Standardization Sector (<a class="indexterm" id="idx-CHP-3-0156"/>ITU-T)</strong></span> ITU-T is another large international body that develops standards for the telecommunications industry. The ITU-T was formerly named the International Telephone and Telegraph Consultative Committee (<a class="indexterm" id="idx-CHP-3-0157"/>CCITT; the abbreviation comes from the French version of the organization's name: <span class="emphasis"><em>Comité Consultatif International Téléphonique et Télégraphique</em></span>).</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0158"/>European Telecommunications Standards Institute (<a class="indexterm" id="idx-CHP-3-0159"/>ETSI)</strong></span> An organization with members from dozens of countries both within and outside Europe that is dedicated to developing telecommunications standards for the European market (and elsewhere). ETSI is known for, among other things, regulating the use of radio bandwidth in Europe and developing standards such as HiperLAN.</p><p>Many of these organizations do not actually develop the various standards. Generally, these are oversight organizations—high-level management, if you will—that work with many other smaller groups who actually develop the standards. Also, in many cases, a particular standard may be published by more than one standards organization, so it may be labeled with more than one name.</p><div class="note" title="Note"><h3 class="title"><a id="note-15"/>Note</h3><p><span class="emphasis"><em>The set of related organizations responsible for creating Internet standards is not shown in this list because I have elected to cover them in two dedicated sections later in this chapter, on Internet standards organizations and registration authorities</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-25"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> There are a number of well-known international organizations that play important roles in the development of open networking standards. Some of the most important of these are ISO, ANSI, ITIC, IEEE, EIA/TIA, ITU-T, and ETSI. These are oversight organizations, responsible for overall management of the standards development process, rather than for the particulars of creating individual standards.</p></div></div>
<div class="sect1" title="Networking Industry Groups"><div class="titlepage"><div><div><h1 class="title"><a id="networking_industry_groups"/>Networking Industry Groups</h1></div></div></div><p>While most open standards are coordinated and published by a small number of large, often international, standards organizations, these are not the only groups involved in the development of standards for networking and Internet technologies. Many different networking <span class="emphasis"><em>industry groups</em></span> play an important role in the standard creation process.<a class="indexterm" id="idx-CHP-3-0160"/><a class="indexterm" id="idx-CHP-3-0161"/></p><p>Networking industry groups differ in a few ways from standards organizations. They are typically dedicated to the promotion of a specific technology, whereas standards organizations are more generic and oversee hundreds of different ones. Industry groups are also generally smaller than standards organizations, with members drawn primarily from the field of developers and manufacturers that create products for the particular technology the group promotes.</p><p>Perhaps most important, industry groups often actually write and maintain the standards, whereas standards organizations generally act as supervisors who ensure that the standards are clear enough to be implemented. Some industry groups, however, are concerned only with marketing and promotion activities.</p><p>Obviously, these industry groups work closely together with the standards organizations. In some cases, they may even be part of the same overall organization, and all of the different groups are related in some way. For example, the IEEE 802 <a class="indexterm" id="idx-CHP-3-0162"/>Project consists of a number of working groups charged with maintaining and developing specific technology standards, which the larger IEEE organization approves and publishes.</p><p>One of these working groups is the 802.11 working group, which develops wireless Ethernet technology. At the same time that this group does its thing, there is an industry group called the <span class="emphasis"><em>Wireless Ethernet Compatibility Alliance (WECA)</em></span>. This group works to ensure the cross-vendor compatibility of 802.11b wireless networking hardware and software.<a class="indexterm" id="idx-CHP-3-0163"/><a class="indexterm" id="idx-CHP-3-0164"/></p><p>Other industry groups are formed specifically to develop independent standards that are not approved through a formal standardization process. Examples include groups such as HomePNA, IrDA, and HomeRF.</p><p>One of the problems with these groups is that they usually do not make their standards open to the public. This is undoubtedly due to some sort of security concern or desire to keep the inner workings of their technology secret. Unfortunately for these groups, this policy harms the ability of regular people to learn how their technologies work.</p><div class="note" title="Note"><h3 class="title"><a id="note-16"/>Note</h3><p><span class="emphasis"><em>As an example of what I mean about these closed standards, I can point to my own experience in writing this and other reference works. I was almost always unable to obtain specifications from most of the private industry groups. They either refused to allow me to get the document at all or wanted to charge me a great deal of money for the privilege (well into the thousands of dollars in some cases). In doing this, these groups harm their own cause, thereby making it more difficult for those interested in their technologies to learn about them. This is another key advantage of having open standards managed by public organizations such as ANSI or the IEEE</em></span>.</p></div></div>
<div class="sect1" title="Internet Standards Organizations (ISOC, IAB, IESG, IETF, IRSG, and IRTF)"><div class="titlepage"><div><div><h1 class="title"><a id="internet_standards_organizations_isoc_ia"/>Internet Standards Organizations (ISOC, IAB, IESG, IETF, IRSG, and IRTF)</h1></div></div></div><p>High-quality, widely accepted open standards become more important as the number of people that use a network grows. The largest network of all is of course the <span class="emphasis"><em>Internet</em></span>, which connects millions of people on thousands of individual networks into a globe-spanning internetwork. The Internet has revolutionized not only networking and computing, but also communication, business, and even society as a whole. One of the critical factors in the success of the Internet has been its development using open standards.<a class="indexterm" id="idx-CHP-3-0165"/><a class="indexterm" id="idx-CHP-3-0166"/></p><p>Of course, nobody sat down one day and said, "Hey, let's create the Internet!" (No, not even Al Gore.) It began as a small research network, and was developed over time concurrently with the technology set that implemented it: TCP/IP. At first, a relatively small organization was sufficient for managing the development of Internet standards and overseeing its activities, but as the Internet continued to grow, this organization became inadequate. Eventually, a more formalized structure of organizations was required in order to manage the Internet development process and other activities. This ensured the continued success and growth of the Internet and the TCP/IP technologies that powered it.</p><p>Today, six organizations are responsible for the development of the Internet's architecture, standards and policies, and related activities. They are closely related, with certain organizations responsible for overseeing others. These organizations perform many tasks and can be somewhat confusing to understand, since many have similar-sounding names and responsibilities. Therefore, I will concentrate mostly on their role in the development of Internet standards, since that is the primary interest in this discussion.</p><p>Here are brief descriptions, rather simplified, of the key Internet standards organizations:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0167"/>Internet Society (ISOC)</strong></span> A professional society responsible for general, high-level activities related to the management, development, and promotion of the Internet. ISOC has thousands of individual and organizational members that engage in activities such as research, education, public policy development, and standardization. It is responsible for providing financial and administrative support to the other organizations listed in this chapter. From the standpoint of standards development, ISOC's key role is its responsibility for oversight of the <a class="indexterm" id="idx-CHP-3-0168"/>IAB.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0169"/>Internet Architecture Board (IAB)</strong></span> Formerly the <span class="emphasis"><em>Internet Activities Board</em></span>, the IAB is charged with the overall management of the development of Internet standards. It makes "big-picture" policy decisions related to how Internet technologies and structures should work. This ensures that various standardization efforts are coordinated and consistent with overall development of the Internet. It is responsible for publishing Internet standards (RFCs), as described in the "Internet Standards and the Request for Comment (RFC) Process" section at the end of this chapter. It advises the ISOC and oversees the <a class="indexterm" id="idx-CHP-3-0170"/>IETF and <a class="indexterm" id="idx-CHP-3-0171"/>IRTF; it also acts as an appeals body for complaints about the standardization activities performed by the IETF. The charter of the IAB is described in RFC 2850.<a class="indexterm" id="idx-CHP-3-0172"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0173"/>Internet Engineering Task Force (IETF)</strong></span> The IETF focuses on issues related to the development of current Internet and TCP/IP technologies. It is divided into a number of <span class="emphasis"><em>working groups</em></span>, each of which is responsible for developing standards and technologies in a particular area, such as routing or security. Each area is managed by an <span class="emphasis"><em>area director</em></span>, who serves on the <a class="indexterm" id="idx-CHP-3-0174"/>IESG. The IETF is overseen directly by the IESG and in turn by the IAB; it is described in RFC 3160.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0175"/>Internet Engineering Steering Group (IESG)</strong></span> The IESG is directly responsible for managing the IETF and the Internet standards development process. It consists of each of the IETF <a class="indexterm" id="idx-CHP-3-0176"/>area directors, who make final decisions about the approval of proposed standards, and works to resolve any issues that may arise in the standardization process. The IESG is technically considered part of the IETF and is also described in RFC 3160.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0177"/>Internet Research Task Force (IRTF)</strong></span> Where the IETF is focused primarily on short-term development issues, the IRTF is responsible for longer-term research related to the Internet and TCP/IP technologies. It is a much smaller organization than the IETF, consisting of a set of <span class="emphasis"><em>research groups</em></span>, which are analogous to the IETF's working groups. The IRTF is overseen by the <a class="indexterm" id="idx-CHP-3-0178"/>IRSG and IAB. It is described in RFC 2014.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0179"/>Internet Research Steering Group (IRSG)</strong></span> The IRSG manages the IRTF in a similar way to how the IESG manages the IETF. It consists of the chairs of each of the IRTF research groups and works with the chair of the whole IRTF to make appropriate decisions on research activities. It is also discussed in RFC 2014.</p><p><a class="xref" href="ch03s05.html#internet_standards_organizations_the_iso" title="Figure 3-1. Internet standards organizations The ISOC is responsible for overseeing the IAB, which in turn is responsible for the two task forces, the IETF and IRTF, which are headed by the IESG and IRSG, respectively.">Figure 3-1</a> shows the relationship between the Internet standards associations. The ISOC oversees the IAB, which in turn directs the IETF and IRTF. The IETF develops current Internet and TCP/IP standards and is headed by the IESG, which manages IETF working groups. The IRTF is the IETF's research counterpart, containing <span class="emphasis"><em>research groups</em></span> led by the IRSG.</p><div class="figure"><a id="internet_standards_organizations_the_iso"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e3006"/><img alt="Internet standards organizations The ISOC is responsible for overseeing the IAB, which in turn is responsible for the two task forces, the IETF and IRTF, which are headed by the IESG and IRSG, respectively." src="httpatomoreillycomsourcenostarchimages287695.png.jpg"/></div></div><p class="title">Figure 3-1. Internet standards organizations The ISOC is responsible for overseeing the IAB, which in turn is responsible for the two task forces, the IETF and IRTF, which are headed by the IESG and IRSG, respectively.</p></div><p>Of these <a class="indexterm" id="idx-CHP-3-0180"/>organizations, the IETF is the one that you will most often hear referenced, because it is directly responsible for the development of the majority of Internet standards. Thus, whenever I mention Internet standards development efforts in this book, I'm referring to the IETF as the organization doing the work. This is, of course, a bit of an oversimplification, since all of these organizations play a role in the standards development process, as described later in this chapter, in the discussion of the RFC process.</p><p>Many of these organizations are responsible for a great deal more than just standards development. This is especially true of the ISOC, for which standardization is just one of many activities. The IAB also performs a number of functions not strictly associated with standards development, including managing the assignment of protocol values done by the Internet Assigned Numbers Authority and acting as a liaison between the <a class="indexterm" id="idx-CHP-3-0181"/>Internet standards organizations and other standards bodies.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-26"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A group of related organizations is responsible for the development of TCP/IP standards and Internet technologies. The <span class="emphasis"><em>Internet Society (ISOC)</em></span> has overall responsibility for many Internet activities, including standards development. It oversees the <span class="emphasis"><em>Internet Architecture Board (IAB)</em></span>, which makes high-level decisions about Internet technology development. Most of the actual work of creating current Internet standards is performed by the <span class="emphasis"><em>Internet Engineering Task Force (IETF)</em></span>, which is managed by the <span class="emphasis"><em>Internet Engineering Steering Group (IESG)</em></span>. Longer-term research is done by the IETF's sibling organization, the <span class="emphasis"><em>Internet Research Task Force (IRTF)</em></span>, which is led by the <span class="emphasis"><em>Internet Research Steering Group (IRSG)</em></span>.</p></div></div>
<div class="sect1" title="Internet Registration Authorities and Registries (IANA, ICANN, APNIC, ARIN, LACNIC, and RIPE NCC)"><div class="titlepage"><div><div><h1 class="title"><a id="internet_registration_authorities_and_re"/>Internet Registration Authorities and Registries (IANA, ICANN, APNIC, ARIN, LACNIC, and RIPE NCC)</h1></div></div></div><p>The success of the global <a class="indexterm" id="idx-CHP-3-0182"/>Internet relies on the development of universally accepted standards for protocols and other technologies. Internet standards organizations such as the IETF are thus critically important. They manage the standards development process, which ensures that everyone agrees on how to create hardware and software that will work together to communicate worldwide.</p><p>While the need to standardize protocols seems obvious, there are a couple of other aspects to Internet standardization that are equally important but perhaps not quite as well understood:</p><p><span class="strong"><strong>Parameter Standardization</strong></span> Most protocols rely on the use of parameters that control how they function. As just two of many, many examples, the IP has a set of numbers that define different IP options, and the Address Resolution Protocol (ARP) has an Operation Code field that can take on many different values. Just as it is essential for devices to agree on what protocols to use, so they must also agree on what parameters to use for those protocols, if communication is to be successful.</p><p><span class="strong"><strong>Global Resource Allocation and Identifier Uniqueness</strong></span> There are a number of resources that are used on the Internet that must be allocated from a fixed set of values. Uniqueness in assignment is essential for these values. The most obvious example is that each TCP/IP host must have a unique IP address. Another important example is ensuring that only one organization uses a given Domain Name System (DNS) domain name. If two devices have the same IP address or two organizations try to use the same domain name, the results would be unpredictable, but almost certainly bad!</p><p>In both of these cases, some sort of centralized organization is required. We need a group to take responsibility for managing parameters. It must ensure that everyone uses the same parameters, and the same protocols. We also need to coordinate the assignment of identifiers such as addresses and names. This ensures that the identifiers are created and allocated in a way that is acceptable to all. In the world of the Internet, these are sometimes called <span class="emphasis"><em>management authorities</em></span> or <span class="emphasis"><em>registration authorities</em></span>.<a class="indexterm" id="idx-CHP-3-0183"/></p><div class="sect2" title="Internet Centralized Registration Authorities"><div class="titlepage"><div><div><h2 class="title"><a id="internet_centralized_registration_author"/>Internet Centralized Registration Authorities</h2></div></div></div><p>The organization originally responsible for managing parameters and identifiers was the Internet Assigned Numbers Authority (<a class="indexterm" id="idx-CHP-3-0184"/>IANA). Amazingly, while the name makes it sound like the IANA was a huge bureaucracy, it was effectively one man: Jonathan B. (Jon) <a class="indexterm" id="idx-CHP-3-0185"/>Postel, one of the most important pioneers of Internet and TCP/IP technologies. Jon Postel ran IANA until his untimely death in 1998.<a class="indexterm" id="idx-CHP-3-0186"/></p><p>IANA was originally charged with managing which IP address blocks had been assigned to different companies and groups, and it maintained lists of periodically published Internet parameters such as UDP and TCP port numbers. It also was in charge of the registrations of DNS domain names, which were more directly handled by the <a class="indexterm" id="idx-CHP-3-0187"/>Internet Network Information Center (InterNIC), a service managed by the United States government. <a class="indexterm" id="idx-CHP-3-0188"/>Network Solutions, Inc. (NSI) was later granted the contract to manage the <a class="indexterm" id="idx-CHP-3-0189"/>InterNIC and was eventually purchased by VeriSign.</p><p>As the Internet continued to grow, an effort commenced in the mid-1990s to define a new organization that would be responsible for the central registration of Internet addresses and names. This took the form of a new private, nonprofit company called the Internet Corporation for Assigned Names and Numbers (<a class="indexterm" id="idx-CHP-3-0190"/>ICANN). ICANN is officially charged with all of the centralized registration tasks I have mentioned so far, including IP address assignment, DNS domain name assignment, and protocol parameters management.</p><p>In a simpler world, this development would have meant that ICANN would have replaced IANA, which would no longer exist. Instead, ICANN kept IANA around, leaving that organization in charge of overseeing IP address registration and Internet parameters. ICANN is now in charge of IANA, so both organizations are responsible for IP addresses and parameters. This often leads to confusion, and to make things worse, it is common to see IANA and ICANN mentioned in conjunction as IANA/ICANN or ICANN/IANA.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-27"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Internet registration authorities are centralized organizations responsible for coordinating protocol parameters and globally assigned resources such as IP addresses. The first such organization was the <span class="emphasis"><em>Internet Assigned Numbers Authority (IANA)</em></span>, which was initially in charge of IP address assignment, DNS domain name management, and protocol parameters. Today, the <span class="emphasis"><em>Internet Corporation for Assigned Names and Numbers (ICANN)</em></span> has overall responsibility for these activities; the IANA operates under the auspices of ICANN and is still responsible for IP address assignment and parameter coordination.</p></div></div><div class="sect2" title="Modern Hierarchy of Registration Authorities"><div class="titlepage"><div><div><h2 class="title"><a id="modern_hierarchy_of_registration_authori"/>Modern Hierarchy of Registration Authorities</h2></div></div></div><p>In the original "classful" IP addressing scheme, addresses were assigned to organizations directly by IANA in address blocks: Class A, Class B, and Class C. Today, a hierarchical, classless addressing system called <span class="emphasis"><em>Classless Inter-Domain Routing (CIDR)</em></span> is used instead. Address assignment in CIDR involves the hierarchical allocation of blocks of addresses, starting with large blocks that are given to big organizations, which split them to assign to smaller groups. (Much more detail on these methods can be found in Chapters <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a> through <a class="xref" href="ch20.html" title="Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING">Chapter 20</a>, which cover IP addressing.)</p><p>IANA, as the organization in charge of all IP addresses, assigns the largest blocks of addresses to <span class="emphasis"><em>regional Internet registries (RIRs)</em></span> that are responsible for further allocation activities. Each RIR manages IP addresses and other Internet number resources (such as autonomous system numbers) for a particular region. The four regional registries are as follows:<a class="indexterm" id="idx-CHP-3-0191"/></p><p><span class="strong"><strong>Asia Pacific Network Information Centre (APNIC)</strong></span> Covers the Asia/Pacific region.</p><p><span class="strong"><strong>American Registry for Internet <a class="indexterm" id="idx-CHP-3-0192"/>Numbers (ARIN)</strong></span> Manages North America, part of the Caribbean, and subequatorial Africa.</p><p><span class="strong"><strong>Latin American and Caribbean Internet Addresses Registry (LACNIC)</strong></span> Responsible for Latin America and part of the Caribbean.</p><p><span class="strong"><strong>Réseaux <a class="indexterm" id="idx-CHP-3-0193"/>IP Européens Network Coordination Center (<a class="indexterm" id="idx-CHP-3-0194"/>RIPE NCC)</strong></span> Takes care of Europe, the Middle East, Central Asia, and Africa north of the equator.</p><p>Each registry may assign address blocks to Internet service providers (ISPs) directly or further delegate them to <span class="emphasis"><em>national Internet registries</em></span> or smaller <span class="emphasis"><em>local Internet registries</em></span>. (See <a class="xref" href="ch16.html" title="Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES">Chapter 16</a>, which covers IP address allocation issues, for more details.)<a class="indexterm" id="idx-CHP-3-0195"/><a class="indexterm" id="idx-CHP-3-0196"/></p><p>Name registration has changed over the last several years. It is no longer part of IANA's responsibilities, and ICANN has opened up the name registration business, so it is no longer the province of a single organization such as <a class="indexterm" id="idx-CHP-3-0197"/>InterNIC/NSI/VeriSign. Now, many different accredited registrars can be used for name registration in many of the popular top-level domains. This is discussed in <a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a>, which covers DNS public registration. The complete list of documents containing Internet and TCP/IP parameters can be found on the IANA's website at <a class="ulink" href="http://www.iana.org/numbers.html">http://www.iana.org/numbers.html</a>.</p></div></div>
<div class="sect1" title="Internet Standards and the Request for Comment (RFC) Process"><div class="titlepage"><div><div><h1 class="title"><a id="internet_standards_and_the_request_for_c"/>Internet Standards and the Request for Comment (RFC) Process</h1></div></div></div><p>The precursors of the modern Internet were diminutive networks developed and run by a small group of computer <a class="indexterm" id="idx-CHP-3-0198"/>scientists and engineers. These technologists knew that developing open, widely adopted standards would be essential to the eventual growth of the Internet and the TCP/IP protocol suite. But there was no formalized standards development mechanism back then.<a class="indexterm" id="idx-CHP-3-0199"/></p><p>Standardization was achieved largely through building consensus through discussion about new technologies and protocols. If someone had a proposal for a new protocol or technology, or an idea for a change to an existing one, that person would create a memorandum describing it and circulate it to others. Since the goal was to solicit comments on the proposal, these memos were called <span class="emphasis"><em>Requests for Comments (RFCs)</em></span>. Not all RFCs described formalized standards; many were just descriptive documents, clarifications, or contained miscellaneous information.<a class="indexterm" id="idx-CHP-3-0200"/></p><div class="note" title="Note"><h3 class="title"><a id="note-17"/>Note</h3><p><span class="emphasis"><em>The documents defining early standards were originally called</em></span> <a class="indexterm" id="idx-CHP-3-0201"/>Internet Engineering Notes (IENs) <span class="emphasis"><em>before they were called RFCs</em></span>.</p></div><p>Today, of course, the Internet is enormous, and there is an official structure of Internet standards organizations that is responsible for creating new Internet and TCP/IP standards. Due to the many thousands of people who play an active role in developing Internet technologies, an informal system where anyone could just write an RFC would lead to chaos. Thus, Internet and TCP/IP standards are still called RFCs, but the process of creating one is much more formal and organized today.</p><p>The IETF is the standards body that is most directly responsible for the creation of Internet standards. The IETF's working groups, overseen by the IESG and the IAB, develop new protocols and technologies continuously, and these developments are formalized in RFCs.</p><p>The office of the RFC <a class="indexterm" id="idx-CHP-3-0202"/>Editor handles the publishing of RFCs. For nearly 30 years, beginning in 1969, the <a class="indexterm" id="idx-CHP-3-0203"/>RFC Editor was Internet pioneer Jon Postel. After his death in 1998, the function was assigned to the networking division of the USC <a class="indexterm" id="idx-CHP-3-0204"/>Information Sciences Institute (ISI), where Jon Postel was once director. The function of the RFC Editor is to publish and archive <a class="indexterm" id="idx-CHP-3-0205"/>RFCs, and to maintain an online repository of these documents so that they can be accessed and used by the Internet community.</p><p>The open and free access to RFCs has greatly contributed to the Internet's success. Even today, if you consider that standards bodies charge thousands of dollars for access to a single standard, the ability to log on and immediately retrieve any of the thousands of RFCs is noteworthy.</p><div class="note" title="Note"><h3 class="title"><a id="note-18"/>Note</h3><p><span class="emphasis"><em>An up-to-date list of RFCs with hyperlinks to each document (except for some of the early ones) can be found at the office of the RFC Editor. Go to</em></span> <a class="ulink" href="http://www.rfc-editor.org/rfc-index.html">http://www.rfc-editor.org/rfc-index.html</a>.<a class="indexterm" id="idx-CHP-3-0206"/></p></div><div class="sect2" title="RFC Categories"><div class="titlepage"><div><div><h2 class="title"><a id="rfc_categories"/>RFC Categories</h2></div></div></div><p>As I mentioned, not all RFCs are official Internet standards. This is important to remember. Each RFC has a <span class="emphasis"><em>category</em></span> or <span class="emphasis"><em>status</em></span> associated with it that indicates its disposition:<a class="indexterm" id="idx-CHP-3-0207"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0208"/>Proposed Standard/Draft Standard/Standard</strong></span> These documents describe technologies that are on the standards <a class="indexterm" id="idx-CHP-3-0209"/>track. That means they are either already formally approved as standards, or they are likely to become standards in the future. In many cases, the document is just listed as "standards track," rather than one of those three precise labels.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0210"/>Best Current Practice</strong></span> A document providing guideline information or recommendations from the IETF that is not a formal standard.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0211"/>Informational</strong></span> A document that provides general information or commentary.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0212"/>Experimental</strong></span> A proposal for an experimental standard that is not on the standards track. In some cases, protocols or proposed changes to existing protocols that are not accepted as formal standards are changed to experimental status.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-3-0213"/>Historic</strong></span> Former standards that have been made obsolete.</p></div><div class="sect2" title="The Internet Standardization Process"><div class="titlepage"><div><div><h2 class="title"><a id="the_internet_standardization_process"/>The Internet Standardization Process</h2></div></div></div><p>Before a proposal will be considered for the Internet <a class="indexterm" id="idx-CHP-3-0214"/>standardization process, it must be published as an <span class="emphasis"><em>Internet Draft (ID)</em></span>. The IETF publishes a set of guidelines that specify how IDs must be created and submitted. Members of working groups within the IETF who are involved in specific projects write most IDs. However, because the standards process is open, any member of the public can independently submit a standard for review by creating an ID for consideration by the IETF and IESG. IDs are usually revised many times based on feedback from other working groups within the IETF.<a class="indexterm" id="idx-CHP-3-0215"/><a class="indexterm" id="idx-CHP-3-0216"/></p><p>If an ID has been reviewed and is considered valuable, well understood, and stable (meaning that it is not being rapidly updated with new revisions), it may become a candidate for standardization. The IESG can place the ID on the Internet standards track by changing its status to <span class="emphasis"><em>proposed standard</em></span>. Documents of this status are considered mostly complete, but may still be revised based on further review, testing, and experimentation with the technology.</p><p>Once the specification is sufficiently mature and widely accepted, it may be elevated from proposed standard to <span class="emphasis"><em>draft standard</em></span>. A key requirement for such advancement is that the technology must be demonstrated to be functional on at least two independent and interoperable implementations. This proves that the standard has been cleared and completed, and that at least two different groups have been able to implement it compatibly.</p><p>A document only reaches draft standard when the IETF community believes it is technically mature and the specification is complete. Changes are usually only made to draft standards to correct problems encountered in testing or resolve new issues that arise.</p><p>The final station on the Internet standards track is <span class="emphasis"><em>Internet standard</em></span>. This designation is applied to only very mature specifications that are popular and that have been widely implemented. A document that reaches this status often describes a technology that is or will become universally implemented, and is assigned an STD (standard) number.</p><p>The RFC development process can take months or even years, depending on how complex the technology is, how many changes are required to the documents, and whether or not the proposal is considered important or interesting. Many RFCs never make it officially to Internet standard status; draft standard status is generally considered stable enough that the technology is often just implemented by companies when that level is reached. Some RFCs never even make it to draft standard status, and the technologies they describe are still used in products.</p><p>Once an RFC is published, it cannot be changed. This is a specific policy decision intended to avoid the confusion that would otherwise result from the fact that there were multiple versions of the same RFC. The RFC publication process incorporates a number of steps at which RFC authors can revise their documents and check for editorial omissions and errors.</p><p>This need for a new document whenever a change is made is also why proposals are typically published with a category designation of standards track rather than proposed standard, draft standard, and Internet standard. This eliminates the need to publish a new RFC when a proposal advances down the standards track without requiring any real changes aside from a different category designation.</p><p>I've just outlined the process for creating and publishing an Internet standard here. The full details of the standards process can be found in RFC 2026 (where else but an RFC?).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-28"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Internet standards are described in a series of documents called <span class="emphasis"><em>Requests for Comments (RFCs)</em></span>. The RFC process describes how an Internet standard is usually created. An idea for a new technology or enhancement begins with the creation of an <span class="emphasis"><em>Internet Draft (ID)</em></span>. After review and feedback, if the proposal has support, it may be placed on the Internet standards track, and its status will be changed to <span class="emphasis"><em>proposed standard</em></span>. As the fledgling standard matures, its status may advance to <span class="emphasis"><em>draft standard</em></span> and eventually, <span class="emphasis"><em>Internet standard</em></span>. However, many RFCs are implemented in products without reaching Internet standard status. There are also other RFCs that define experimental technologies or provide information without describing official Internet standards.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;4.&#xA0;A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING"><div class="titlepage"><div><div><h1 class="title"><a id="a_review_of_data_representation_and_the_"/>Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e3413"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> <a class="indexterm" id="idx-CHP-4-0217"/>We use decimal (base 10) numbers to represent numeric information, and we use various alphabets and symbol systems to represent other types <a class="indexterm" id="idx-CHP-4-0218"/>of information. In contrast, computers understand only one basic type of information: ones and zeros, which themselves are representative of either an on or off electrical state within the hardware of the device. These ones and zeros are combined in various ways to form more common data elements that we are used to finding in computers: regular numbers, characters, and files. However, all of these are really only abstractions; the ones and zeros are always underneath whatever logical structures are used within the computer.</p><p>This same basic foundation of ones and zeros applies to networking as well. Even though most of the information in a network is exchanged in a logical fashion between higher-layer protocols, ones and zeros sent over the network medium underlie all networking structures. Understanding how data is represented and manipulated in computer systems is important because it will help you comprehend many of the different technologies. Computer data representation and mathematics are important for explaining how low-level physical layer modulation and encoding techniques work. Those two elements come into play even for higher-level concepts, such as how IP addresses are set up and used on the Internet.</p><p>In this chapter, I provide some general background <a class="indexterm" id="idx-CHP-4-0219"/>information on how numerical data is represented, stored, and manipulated within computers and networking hardware. I begin with a description of binary numbers and the different terms used to refer to collections of binary <a class="indexterm" id="idx-CHP-4-0220"/>information of various sizes. I describe the different types of numbering systems used in computer systems, such as octal, decimal, and hexadecimal, and how data can be converted between these different types. I explain how arithmetic is performed on binary and hexadecimal numbers. I then discuss boolean logic and how logical functions are used to manipulate binary data.</p><p>These explanations then form the basis for a discussion of how logical functions are used for setting, clearing, inverting, and masking bits. These operations are employed extensively in certain networking technologies and protocols. Masking operations especially are often used in IP addressing, so even though this section seems rather low-level, it is quite relevant to the world of TCP/IP.</p><div class="note" title="Note"><h3 class="title"><a id="note-19"/>Note</h3><p><span class="emphasis"><em>Needless to say, you may know most or all of the information in this chapter, so feel free to skip (or just skim) those topics that you already know. I provide this background detail for the sake of those new to computing or those needing a refresher. However, even those of you who know what a bit and a byte are, and know the difference between binary and decimal numbers, may find the discussion of bit masking worth perusing</em></span>.<a class="indexterm" id="idx-CHP-4-0221"/></p></div><div class="sect1" title="Binary Information and Representation: Bits, Bytes, Nibbles, Octets, and Characters"><div class="titlepage"><div><div><h1 class="title"><a id="binary_information_and_representation_bi"/>Binary Information and Representation: Bits, Bytes, Nibbles, Octets, and Characters</h1></div></div></div><p>The essence of computing is <span class="emphasis"><em>information</em></span>. Computer hardware and software are designed to allow the input, storage, transfer, and expression of various types of information. One primary way by which types of information are differentiated is as either <span class="emphasis"><em>analog</em></span> or <span class="emphasis"><em>digital</em></span>.</p><p>Consider, for example, a light switch and a dimmer. A light switch allows a light to be turned on or off; there are no in-between states. These discrete states, on or off, represent <a class="indexterm" id="idx-CHP-4-0222"/>digital information. In contrast, a dimmer allows you to fine-tune the light output from fully on to fully off, with an infinite number of intermediate states in between; that's <a class="indexterm" id="idx-CHP-4-0223"/>analog information.</p><div class="sect2" title="Binary Information"><div class="titlepage"><div><div><h2 class="title"><a id="binary_information"/>Binary Information</h2></div></div></div><p>Modern digital computers store information digitally. In the same way a light bulb has only an on or off value, so do the components that store and manipulate information within computers. Millions of <span class="emphasis"><em>transistors</em></span> compose computer processors and other circuits, and are, in highly simplified form, digital switches. Thus, all information in computers is manipulated as collections of information pieces that can be only on or off, like a switch.<a class="indexterm" id="idx-CHP-4-0224"/></p><p>Since there are only two possible states—on or off—this is called <span class="emphasis"><em>binary</em></span> information (the prefix <span class="emphasis"><em>bi</em></span> means two). There are several advantages to using binary representation for information. It is a simple way to represent many types of information, whether a light switch is on or off or a file has been successfully copied. It is also possible to combine binary values to represent more complex information.</p><p>Perhaps most important, <a class="indexterm" id="idx-CHP-4-0225"/>binary information is <span class="emphasis"><em>unambiguous</em></span>: On is always on, and off is always off. This property is important because it allows devices to detect clearly the value of a particular piece of information. Computers like black and white; they are not particularly good at dealing with shades of gray. (This becomes especially important in the field of networking, in which transmission of data can cause signals to become polluted by noise.)</p><p>The on or off condition of a binary value can be expressed in a number of different ways. In logical expressions, we may consider the value to be true or false. When representing mathematical values, the most common representation is one (on) or zero (off).</p></div><div class="sect2" title="Binary Information Representation and Groups"><div class="titlepage"><div><div><h2 class="title"><a id="binary_information_representation_and_gr"/>Binary Information Representation and Groups</h2></div></div></div><p>The fundamental building block of computer information is the <span class="emphasis"><em>bit</em></span> (a contraction of <span class="emphasis"><em>binary digit</em></span>). Every bit can be either 0 or 1. Making the value of a bit 1 is commonly called <span class="emphasis"><em>setting</em></span> the bit; changing it to 0 is <span class="emphasis"><em>resetting</em></span> or <span class="emphasis"><em>clearing</em></span> it.<a class="indexterm" id="idx-CHP-4-0226"/><a class="indexterm" id="idx-CHP-4-0227"/><a class="indexterm" id="idx-CHP-4-0228"/><a class="indexterm" id="idx-CHP-4-0229"/><a class="indexterm" id="idx-CHP-4-0230"/></p><p>Of course, <a class="indexterm" id="idx-CHP-4-0231"/>bits represent only a very small amount of information: a single fact or value. We must make collections of these bits so that we can use them to store large amounts of information and more complex data types. The most common grouping is to take 8 bits and reference them as a single unit. A collection of 8 bits is technically called an <span class="emphasis"><em>octet</em></span>, but is more commonly called a <span class="emphasis"><em>byte</em></span> (more on that in a moment).</p><p><span class="emphasis"><em>Byte</em></span> is a jocular play on the term <span class="emphasis"><em>bit</em></span>. Over time, various sizes of bit collections have been defined. Some geek comedian decided that if 8 bits made a byte, then 4 bits must be a <span class="emphasis"><em>nybble</em></span> (or "<a class="indexterm" id="idx-CHP-4-0232"/>nibble"). Hilarious, no? Larger collections have also been defined and given various names. <a class="xref" href="ch04.html#binary_information_group_representations" title="Table 4-1. Binary Information Group Representations and Terms">Table 4-1</a> summarizes the most common representations of groups of bits and the terms used for them; their relative sizes are also shown graphically in <a class="xref" href="ch04.html#binary_information_representations_and_t" title="Figure 4-1. Binary Information Representations and Terms This diagram shows the relative sizes of the most commonly sized collections of binary information.">Figure 4-1</a>.<a class="indexterm" id="idx-CHP-4-0233"/></p><div class="table"><a id="binary_information_group_representations"/><p class="title">Table 4-1. Binary Information Group Representations and Terms</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Binary Information Group Representations and Terms"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Number of Bits</p></th><th style="border-bottom: 0.5pt solid ; "><p>Common Representation Terms</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Bit/Digit/<a class="indexterm" id="idx-CHP-4-0234"/>Flag</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Nybble/Nibble</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Byte/Octet/Character</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Double Byte/Word</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-bottom: 0.5pt solid ; "><p>Double Word/Long Word</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>64</p></td><td style=""><p>Very Long Word</p></td></tr></tbody></table></div></div><p>A few of the new terms that appear in <a class="xref" href="ch04.html#binary_information_group_representations" title="Table 4-1. Binary Information Group Representations and Terms">Table 4-1</a> are worth special mention. A bit is also sometimes called a <span class="emphasis"><em>flag</em></span>; this term is most often heard when a bit is used by itself to represent a particular information state. For example, a computer might use a Changed flag to represent whether a particular file has been modified; this is an analogy to a flag either being raised or lowered to indicate a condition. These flags are often seen in networking message formats.<a class="indexterm" id="idx-CHP-4-0235"/></p><p>The term <span class="emphasis"><em>character</em></span> is also used to express a set of 8 bits. This use comes from the fact that computers often store alphanumeric characters, such as letters and numbers, one to a <a class="indexterm" id="idx-CHP-4-0236"/>byte. The 16-bit <span class="emphasis"><em>word</em></span> is used fairly often, but not nearly as much as <span class="emphasis"><em>byte</em></span>. The larger collections of bits, such as <a class="indexterm" id="idx-CHP-4-0237"/>double word and so on, are not often encountered in everyday parlance; they are used to represent chunks of data in technical fields such as hardware design or programming.<a class="indexterm" id="idx-CHP-4-0238"/><a class="indexterm" id="idx-CHP-4-0239"/></p><div class="figure"><a id="binary_information_representations_and_t"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3683"/><img alt="Binary Information Representations and Terms This diagram shows the relative sizes of the most commonly sized collections of binary information." src="httpatomoreillycomsourcenostarchimages287697.png"/></div></div><p class="title">Figure 4-1. Binary Information Representations and Terms This diagram shows the relative sizes of the most commonly sized collections of binary information.</p></div><p>Notice that the number of bits used for each of these terms is a power of two. As you will see later in this section, this occurs because when bits come in sets that are a power of two in size, they are easier to represent and manipulate.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-29"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Computers store all information in <span class="emphasis"><em>binary digital form</em></span>. This means that all data—whether it's text, photographs, audio, or whatever else—is composed of only collections of ones and zeros. The fundamental building block of digital information is the <span class="emphasis"><em>binary digit</em></span> or <span class="emphasis"><em>bit</em></span>, which represents a single zero or one state. To represent larger amounts of information, bits can be collected into <a class="indexterm" id="idx-CHP-4-0240"/>groups of 4, 8, 16, 32, or 64, called <span class="emphasis"><em>nybbles, bytes, words, long words</em></span>, and <span class="emphasis"><em>very long words</em></span>, respectively.</p></div></div><div class="sect2" title="Byte Versus Octet"><div class="titlepage"><div><div><h2 class="title"><a id="byte_versus_octet"/>Byte Versus Octet</h2></div></div></div><p>There has been some disagreement, and even controversy, surrounding the use of the words <span class="emphasis"><em>byte</em></span> and <span class="emphasis"><em>octet</em></span>. The word <span class="emphasis"><em>byte</em></span> has traditionally been the most commonly used term for a set of 8 bits, especially in North America. However, it is <span class="emphasis"><em>technically</em></span> not the correct term.<a class="indexterm" id="idx-CHP-4-0241"/></p><p>A byte is, formally, the smallest unit of data that can be read from or written to at one time in a computer system. In almost all cases today, that is indeed 8 bits, but there have been some systems in which a byte was not 8 bits. Some older 36-bit computers used 9-bit bytes, and others had byte sizes of 6 or 7 bits, or even variable-sized bytes. For this reason, many people, especially techie professionals, prefer the term <span class="emphasis"><em>octet</em></span>, which clearly and unambiguously implies 8. This term is much more common outside North America.</p><div class="note" title="Note"><h3 class="title"><a id="note-20"/>Note</h3><p><span class="emphasis"><em>This matter of</em></span> octets <span class="emphasis"><em>and</em></span> bytes <span class="emphasis"><em>is the kind of tempest in a teapot that computer people love so much. The bottom line in modern computer systems, however, is that an octet is a byte and a byte is an octet, and the terms can generally be used interchangeably without too much danger. You will more often see</em></span> octets <span class="emphasis"><em>used in technical standards. In this book, I use the term</em></span> bytes <span class="emphasis"><em>because it is the term that most people are familiar with</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-30"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Formally, an <span class="emphasis"><em>octet</em></span> is the correct term for exactly 8 bits, while a <span class="emphasis"><em>byte</em></span> is the smallest number of bits that can be accessed in a computer system, which may or may not equal 8. In practice, modern computers use 8-bit bytes, and the terms are used interchangeably (with <span class="emphasis"><em>byte</em></span> being more common in North America, and octet often being preferred in Europe).</p></div></div></div></div>
<div class="sect1" title="Decimal, Binary, Octal, and Hexadecimal Numbers"><div class="titlepage"><div><div><h1 class="title"><a id="decimal_binary_octal_and_hexadecimal_num"/>Decimal, Binary, Octal, and Hexadecimal Numbers</h1></div></div></div><p>The numbers we are accustomed to using in everyday life are called <span class="emphasis"><em>decimal numbers</em></span>. The word <span class="emphasis"><em>decimal</em></span> refers to the number 10. Every digit can take on one of ten values: 0 to 9. Arithmetic performed on decimal numbers is also called <span class="emphasis"><em>base 10</em></span> mathematics, because of this orientation around the number 10. (Why is the number 10 the foundation of our normal mathematical system? Hold both hands up and count!)<a class="indexterm" id="idx-CHP-4-0242"/><a class="indexterm" id="idx-CHP-4-0243"/><a class="indexterm" id="idx-CHP-4-0244"/><a class="indexterm" id="idx-CHP-4-0245"/><a class="indexterm" id="idx-CHP-4-0246"/></p><p>Computer systems, however, don't have fingers or toes; they deal only with binary numbers, which have just two values. Each bit can represent only a 0 or a 1. A single 0 or 1 value is sufficient for encoding a single fact, such as whether something is true or false, or whether the answer is yes or no. But a bit is not enough to hold more complex information, such as your bank account balance, a text document, or a picture of the Yellowstone Canyon.</p><div class="sect2" title="Binary Numbers and Their Decimal Equivalents"><div class="titlepage"><div><div><h2 class="title"><a id="binary_numbers_and_their_decimal_equival"/>Binary Numbers and Their Decimal Equivalents</h2></div></div></div><p>For this reason, larger collections of bits have been created by computer scientists, such as bytes (octets), words, and so forth. When individual bits are collected into sets in this way, they can represent larger integers, called <span class="emphasis"><em>binary numbers</em></span>. Since there are only two possible values for each digit in a binary number (0 or 1), binary numbers are also called <span class="emphasis"><em>base 2</em></span> numbers.<a class="indexterm" id="idx-CHP-4-0247"/></p><p>The key to understanding binary numbers is to realize that they are exactly the same as decimal numbers, except that each digit has a value in the range of 0 to 1, instead of 0 to 9. For example, when you count in decimals, you go up to 9 in the ones place, and then you need a second place for tens. If you go above 99, you need a third place for hundreds. Each additional place added on the left is a higher power of ten.</p><p><a class="indexterm" id="idx-CHP-4-0248"/>Binary is the same, except the limit for each place is 1 instead of 9. So, in binary, you go up to 1 in the ones place, and then need a second place for twos (instead of tens). If you go above 3, you need a third place for fours (instead of hundreds). Each added digit is a subsequent higher power of two, rather than ten.</p><p>Thus, where counting in decimal goes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, and so on, counting in binary goes 0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101. For example, the number 13 in decimal is the same as 1101 in binary. How? Well, in decimal, we have a 3 in the ones place, plus a 1 in the tens place, which has a value of 10. This is 3 + 10, or 13. In binary, we start with a 1 in the ones place, add a 1 in the fours place (for a value of 4), plus a 1 in the eights place, for a value of 8. This is 1 + 4 + 8, or 13.</p><p>To take a more complex example, 211 in decimal is 11010011 in binary. <a class="xref" href="ch04s02.html#binary_and_decimal_number_equivalents" title="Table 4-2. Binary and Decimal Number Equivalents">Table 4-2</a> shows how the two are equivalent, by adding the values for each binary digit place where there is a 1. Read it from left to right, going top to bottom. Starting in the leftmost column, you can see that the example number has a 1 in the 128s place. So you start with a sum of 128. In the next column there is a 1 in the 64s place, so you add 64 for a running sum of 192. But in the 32s place, the binary digit value is 0, so you don't add 32 to the sum. If you continue down to the ones place, you'll get the decimal equivalent of the binary number.</p><div class="table"><a id="binary_and_decimal_number_equivalents"/><p class="title">Table 4-2. Binary and Decimal Number Equivalents</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Binary and Decimal Number Equivalents"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Binary Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Power of Two</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>7</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>6</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>5</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>4</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>3</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>2</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>1</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p>2<sup>0</sup></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value of Digit Place</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value for This Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Running Sum (from Left to Right)</p></td><td style="border-right: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; "><p>128+64 = 192</p></td><td style="border-right: 0.5pt solid ; "><p>192</p></td><td style="border-right: 0.5pt solid ; "><p>192+16 = 208</p></td><td style="border-right: 0.5pt solid ; "><p>208</p></td><td style="border-right: 0.5pt solid ; "><p>208</p></td><td style="border-right: 0.5pt solid ; "><p>208+2 = 210</p></td><td style=""><p>210+1 = 211</p></td></tr></tbody></table></div></div><p>As you can see, a binary number with <span class="emphasis"><em>N</em></span> digits can hold up to 2<sup><span class="emphasis"><em>N</em></span></sup> values. So a byte with 8 bits can hold 2<sup>8</sup>, or 256 different values, which are numbered from 0 to 255. A 16-bit word can hold 2<sup>16</sup>, or 65,536 values.</p></div><div class="sect2" title="Making Binary Numbers Easier to Use by Grouping Bits"><div class="titlepage"><div><div><h2 class="title"><a id="making_binary_numbers_easier_to_use_by_g"/>Making Binary Numbers Easier to Use by Grouping Bits</h2></div></div></div><p>One problem with binary numbers is that although computers love them, people have trouble with them because they quickly become long and cumbersome to deal with. For example, 1,000,000 in the decimal system is 11110100001001000000 in the binary system. To make binary numbers easier to work with, two different shorthand notations have been defined. In both of these, instead of working with each bit individually, the numbers are collected into subgroups, each of which is assigned a single digit in an alternative numbering system.<a class="indexterm" id="idx-CHP-4-0249"/></p></div><div class="sect2" title="Octal Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="octal_numbers"/>Octal Numbers</h2></div></div></div><p>Consider the binary number 11110100, which is 244 in decimal. Instead of looking at each bit individually, chop them into groups of three, starting from the right: 11110100 becomes (11)(110)(100). Each of those groups has three bits, so each can have 23 values: from 0 to 7. In this case, (11)(110)(100) = (3)(6)(4), or 364 in the <span class="emphasis"><em>octal</em></span> or <span class="emphasis"><em>base 8</em></span> numbering system (see <a class="xref" href="ch04s02.html#binary_octal_and_hexadecimal_number_repr" title="Figure 4-2. Binary, octal, and hexadecimal number representations A binary number can be represented in octal form by grouping its bits into sets of three, or in hexadecimal by using sets of four bits. These base 8 and base 16 numbers are far shorter than binary numbers, and hence much easier to work with.">Figure 4-2</a>). As with binary, octal <a class="indexterm" id="idx-CHP-4-0250"/>numbers are the same as decimal numbers, except that they use <a class="indexterm" id="idx-CHP-4-0251"/>base 8 instead of base 10. So 364 in octal is just 3 x 64 + 6 x 8 + 4, or 244. As you can see, octal is a lot less cumbersome than binary, especially when dealing with larger numbers. In the decimal system, 1,000,000 is 3641100 in octal. Compare that with 11110100001001000000 in binary.<a class="indexterm" id="idx-CHP-4-0252"/><a class="indexterm" id="idx-CHP-4-0253"/></p><div class="figure"><a id="binary_octal_and_hexadecimal_number_repr"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4076"/><img alt="Binary, octal, and hexadecimal number representations A binary number can be represented in octal form by grouping its bits into sets of three, or in hexadecimal by using sets of four bits. These base 8 and base 16 numbers are far shorter than binary numbers, and hence much easier to work with." src="httpatomoreillycomsourcenostarchimages287699.png.jpg"/></div></div><p class="title">Figure 4-2. Binary, octal, and hexadecimal number representations A binary number can be represented in octal form by grouping its bits into sets of three, or in hexadecimal by using sets of four bits. These base 8 and base 16 numbers are far shorter than binary numbers, and hence much easier to work with.</p></div></div><div class="sect2" title="Hexadecimal Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="hexadecimal_numbers"/>Hexadecimal Numbers</h2></div></div></div><p>Octal numbers were at one time quite commonly used, but are much less popular today. The problem with octal is that it divides bits into groups of three, but sets of binary numbers typically use a number of bits that is a multiple of <span class="emphasis"><em>four</em></span>.<a class="indexterm" id="idx-CHP-4-0254"/><a class="indexterm" id="idx-CHP-4-0255"/></p><p><span class="emphasis"><em>Hexadecimal</em></span> or the <span class="emphasis"><em>base 16</em></span> numbering system is an alternative method that works like octal, but uses groups of four. Since there are 4 bits in each group, each can have one of 16 values. Hexadecimal is commonly called <span class="emphasis"><em>hex</em></span> for short.<a class="indexterm" id="idx-CHP-4-0256"/></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-31"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Regular numbers are called <span class="emphasis"><em>decimal numbers</em></span> because they are built upon the base 10 system of mathematics. Computers use collections of one or zero bits called <span class="emphasis"><em>binary numbers</em></span>, which can be treated just like regular numbers except that each digit can only be 0 or 1 instead of 0 to 9. Bits in a binary number can be expressed as <span class="emphasis"><em>octal numbers</em></span> by grouping three bits into an <span class="emphasis"><em>octal</em></span> digit that ranges from 0 to 7, or taking sets of four bits to create a single <span class="emphasis"><em>hexadecimal</em></span> digit from 0 to 15. To represent the values 10 through 15 in hexadecimal numbers using a single character, you use the letters A through F.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-21"/>Note</h3><p><span class="emphasis"><em>The term</em></span> hexadecimal <span class="emphasis"><em>was not the first name used for base 16 numbers in computing. Originally, these were called</em></span> sexadecimal <span class="emphasis"><em>numbers. This is actually the correct term, since Latin prefixes</em></span> (sexa-) <span class="emphasis"><em>are normally used for numbers, not Greek ones</em></span> (hexa-). <span class="emphasis"><em>However, in the early 1950s, IBM decided that the word</em></span> sexadecimal <span class="emphasis"><em>was just a little too provocative for their tastes, so they changed it to</em></span> hexadecimal. <span class="emphasis"><em>IBM being IBM—especially back then—meant everyone else followed suit</em></span>.<a class="indexterm" id="idx-CHP-4-0257"/></p></div><p>Now back to the previous example: 11110100 in binary, 244 in decimal. Next you divide this into groups of four to get (1111)(0100). The binary value 1111 is 15, and 0100 is 4, so you have (15)(4). You need to be able to represent 15, but you only have ten numerals. To solve this problem, the values 10, 11, 12, 13, 14, or 15 in hexadecimal are represented by the letters A, B, C, D, E, and F, respectively. So 11110100 in binary is (15)(4), or F4 in hexadecimal (also shown in <a class="xref" href="ch04s02.html#binary_octal_and_hexadecimal_number_repr" title="Figure 4-2. Binary, octal, and hexadecimal number representations A binary number can be represented in octal form by grouping its bits into sets of three, or in hexadecimal by using sets of four bits. These base 8 and base 16 numbers are far shorter than binary numbers, and hence much easier to work with.">Figure 4-2</a>).</p><p>Hexadecimal numbers are in some ways even less intuitive than binary ones (it takes some practice to get used to thinking of letters as numbers). Still, hexadecimal is particularly useful as a way to compactly represent binary information. Where 1,000,000 in decimal numbers is 11110100001001000000 in binary, it is only F4240 in hexadecimal numbers—even shorter than the decimal number, since 16 is larger than 10. Also, a single byte has 8 bits, so it can be represented using only two hexadecimal digits. This is why hexadecimal numbers are widely used in computing and networking. For example, you will often see hexadecimal numbers used as network addresses or representing different types of information in frame or packet formats.</p><div class="note" title="Note"><h3 class="title"><a id="note-22"/>Note</h3><p><span class="emphasis"><em>If you see a number that has a letter from A to F in it, you know it is a hex number, but not all hex numbers use these letters. Hex numbers are usually displayed in a special notation, to avoid confusing them with decimal numbers. That notation is either a prefix of</em></span> 0x <span class="emphasis"><em>or a suffix of</em></span> h <span class="emphasis"><em>(sometimes both). Thus, the number 54 is just 54, but 0x54 is 54 in hexadecimal numbers, which is 5 x 16 + 4, or 84 in decimal numbers. Be sure to watch for these representations</em></span>.<a class="indexterm" id="idx-CHP-4-0258"/></p></div></div></div>
<div class="sect1" title="Decimal, Binary, Octal, and Hexadecimal Number Conversion"><div class="titlepage"><div><div><h1 class="title"><a id="decimal_binary_octal_and_hexadecim-id001"/>Decimal, Binary, Octal, and Hexadecimal Number Conversion</h1></div></div></div><p>Because people and computers speak different number languages, it is often necessary to convert numbers from one system to another. The easiest way to perform the conversion is with a scientific calculator. However, there will be cases for which you need to perform the conversion by hand.<a class="indexterm" id="idx-CHP-4-0259"/></p><div class="note" title="Note"><h3 class="title"><a id="note-23"/>Note</h3><p><span class="emphasis"><em>If you don't have a scientific calculator, the Windows Calculator program is a reasonable facsimile. Open it, go to the View menu, and change the setting from Standard to Scientific. Click the button next to a numbering system. Then enter a number, and if you click a button next to a different numbering type, the number will be converted for you. There are similar tools for UNIX and Mac OS</em></span>.<a class="indexterm" id="idx-CHP-4-0260"/><a class="indexterm" id="idx-CHP-4-0261"/></p></div><div class="sect2" title="Binary, Octal, and Hexadecimal Conversions"><div class="titlepage"><div><div><h2 class="title"><a id="binary_octal_and_hexadecimal_conversions"/>Binary, Octal, and Hexadecimal Conversions</h2></div></div></div><p>To convert between binary, octal, and hex, remember that each octal digit is three binary digits, and each hexadecimal digit is four binary digits. To perform the conversion, group the digits, and convert each group into an octal or hex digit. To convert from hex or octal to binary, convert each hex or octal digit into a set of bits. <a class="xref" href="ch04s03.html#binary_octal_and_hexadecimal_digit_conve" title="Table 4-3. Binary, Octal, and Hexadecimal Digit Conversion">Table 4-3</a> shows the conversions from each of the <a class="indexterm" id="idx-CHP-4-0262"/>octal and hexadecimal single-digit values to binary (with decimal digits thrown in for convenience).</p><div class="table"><a id="binary_octal_and_hexadecimal_digit_conve"/><p class="title">Table 4-3. Binary, Octal, and Hexadecimal Digit Conversion</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Binary, Octal, and Hexadecimal Digit Conversion"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Binary Digits</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octal Digit</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hexadecimal Digit</p></th><th style="border-bottom: 0.5pt solid ; "><p>Decimal Digit</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0000</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0001</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0010</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0011</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>3</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0100</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>4</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0101</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>5</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>6</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0111</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-bottom: 0.5pt solid ; "><p>7</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1000</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1001</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-bottom: 0.5pt solid ; "><p>9</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1010</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A</p></td><td style="border-bottom: 0.5pt solid ; "><p>-</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1011</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>B</p></td><td style="border-bottom: 0.5pt solid ; "><p>-</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1100</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-bottom: 0.5pt solid ; "><p>-</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1101</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-bottom: 0.5pt solid ; "><p>-</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>E</p></td><td style="border-bottom: 0.5pt solid ; "><p>-</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1111</p></td><td style="border-right: 0.5pt solid ; "><p>-</p></td><td style="border-right: 0.5pt solid ; "><p>F</p></td><td style=""><p>-</p></td></tr></tbody></table></div></div><p>Here are some examples:</p><p><span class="strong"><strong>Binary to Octal</strong></span> Start with the binary number 110101001010. Divide this into groups of three: (110)(101)(001)(010), and then convert each group to a number from 0 to 7 (which is easy to do in your head if you practice a bit). The result is (6)(5)(1)(2), or 6512 octal.</p><p><span class="strong"><strong>Hexadecimal to Binary</strong></span> Start with the hex number 0x4D1B. Convert each digit as given in <a class="xref" href="ch04s03.html#binary_octal_and_hexadecimal_digit_conve" title="Table 4-3. Binary, Octal, and Hexadecimal Digit Conversion">Table 4-3</a>. Now you have 0x4D1B = (0100)(1101)(0001)(1011), or 0100110100011011.</p></div><div class="sect2" title="Conversion from Binary, Octal, or Hexadecimal to Decimal"><div class="titlepage"><div><div><h2 class="title"><a id="conversion_from_binary_octal_or_hexadeci"/>Conversion from Binary, Octal, or Hexadecimal to Decimal</h2></div></div></div><p><a class="indexterm" id="idx-CHP-4-0263"/>Conversions to and from decimal are more complicated, because 2, 8, and 16 are powers of two but ten is not. Of the two directions, <a class="indexterm" id="idx-CHP-4-0264"/>conversions <span class="emphasis"><em>to</em></span> decimal are easier: You take the value of each binary, octal, or hexadecimal digit, convert it to decimal, and then multiply it by the power of 2, 8, or 16 represented by the digit's place in the number. Then you add all the numbers together. I did this with the example of the decimal number 211 (see <a class="xref" href="ch04s02.html#binary_and_decimal_number_equivalents" title="Table 4-2. Binary and Decimal Number Equivalents">Table 4-2</a>).<a class="indexterm" id="idx-CHP-4-0265"/></p><p><a class="xref" href="ch04s03.html#hexadecimal_to_decimal_number_conversion" title="Table 4-4. Hexadecimal to Decimal Number Conversion">Table 4-4</a> shows the hexadecimal number 0x830C converted to decimal (octal uses a similar process). Read the table from left to right, top to bottom; each digit's value is multiplied by the appropriate power of 16 and added together, yielding the decimal result of 33,548.</p><div class="table"><a id="hexadecimal_to_decimal_number_conversion"/><p class="title">Table 4-4. Hexadecimal to Decimal Number Conversion</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Hexadecimal to Decimal Number Conversion"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Hexadecimal Number</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>8</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>3</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>0</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>C</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Decimal Value of Digit</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>12</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Power of 16</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16<sup>3</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16<sup>2</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16<sup>1</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p>16<sup>0</sup></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Value of Digit Place</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4096</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>256</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Value for This Number</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8 x 4096 = 32768</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3 x 256 = 768</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0 x 16 = 0</p></td><td style="border-bottom: 0.5pt solid ; "><p>12 x 1 = 12</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Running Sum (from left to right)</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>32768</p></td><td style="border-right: 0.5pt solid ; "><p>32768+768 = 33536</p></td><td style="border-right: 0.5pt solid ; "><p>33536</p></td><td style=""><p>33536+12 = 33548</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Conversion from Decimal to Binary, Octal, or Hexadecimal"><div class="titlepage"><div><div><h2 class="title"><a id="conversion_from_decimal_to_binary_octal_"/>Conversion from Decimal to Binary, Octal, or Hexadecimal</h2></div></div></div><p><a class="indexterm" id="idx-CHP-4-0266"/>Conversions <span class="emphasis"><em>from</em></span> decimal requires you to perform the opposite of the previous calculation: You divide and subtract instead of multiply and add.</p><div class="sect3" title="Conversion from Decimal to Binary"><div class="titlepage"><div><div><h3 class="title"><a id="conversion_from_decimal_to_binary"/>Conversion from Decimal to Binary</h3></div></div></div><p>The easiest of the three <a class="indexterm" id="idx-CHP-4-0267"/>conversions from decimal is to binary. Because the maximum value of each digit is 1, there is no dividing, just subtraction. To perform the conversion, do the following:<a class="indexterm" id="idx-CHP-4-0268"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Find the largest power of two that is smaller than the number.</p></li><li class="listitem"><p>Put a 1 in the digit place for that power of two and subtract that power of two from the decimal number.</p></li><li class="listitem"><p>Repeat steps 1 and 2 until you are reduced to zero.</p></li></ol></div><p>This is easier to explain using an example and a table. Let's convert the decimal number 689, as shown in <a class="xref" href="ch04s03.html#decimal_to_binary_number_conversion" title="Table 4-5. Decimal to Binary Number Conversion">Table 4-5</a>. Again, read the table starting from the upper left, and going down and then across. You start by noticing that 1024 is not less than or equal to 689, so the 1024s place gets a 0. In the next place, 512 is less than 689, so you make the 512s place a 1 and subtract 512 from 689 to leave 177. The calculation continues, before it eventually shows that the 689 decimal is 1010110001 binary.</p><div class="table"><a id="decimal_to_binary_number_conversion"/><p class="title">Table 4-5. Decimal to Binary Number Conversion</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Decimal to Binary Number Conversion"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Decimal Value Before Considering This Digit Place</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>689</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>689</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>177</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>177</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>49</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>49</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Power of Two</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>10</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>9</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>8</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>7</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>6</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>5</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>4</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>3</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>2</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2<sup>1</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p>2<sup>0</sup></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value of Digit Place</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1024</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>512</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>256</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>64</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value of Digit Place Equal to or Less Than Current Decimal Number?</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subtraction Step</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>689 - 512 = 177</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>177 - 128 = 49</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>49 - 32 = 17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17 - 16 = 1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-bottom: 0.5pt solid ; "><p>1 - 1 = 0</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Binary Digits</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style=""><p>1</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Conversion from Decimal to Octal or Hexadecimal"><div class="titlepage"><div><div><h3 class="title"><a id="conversion_from_decimal_to_octal_or_hexa"/>Conversion from Decimal to Octal or Hexadecimal</h3></div></div></div><p>The process for octal and hexadecimal is almost the same, except that you must divide by powers of two instead of just subtracting, as shown here:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Start with the highest power of 16 (hexadecimal) or 8 (octal) that is smaller than the number.</p></li><li class="listitem"><p>Divide the decimal number by that power, keeping only the integer part of the result.</p></li><li class="listitem"><p>Keep the remainder after the division is done.</p></li><li class="listitem"><p>Repeat steps 1 through 3 until you get to the ones place, and then enter whatever is left after the higher digits were done.</p></li></ol></div><p><a class="xref" href="ch04s03.html#decimal_to_hexadecimal_number_conversion" title="Table 4-6. Decimal to Hexadecimal Number Conversion">Table 4-6</a> shows the same example as <a class="xref" href="ch04s03.html#decimal_to_binary_number_conversion" title="Table 4-5. Decimal to Binary Number Conversion">Table 4-5</a>, but goes from decimal to hexadecimal instead of decimal to binary: 689 in decimal is 0x2B1 in hexadecimal.</p><div class="table"><a id="decimal_to_hexadecimal_number_conversion"/><p class="title">Table 4-6. Decimal to Hexadecimal Number Conversion</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Decimal to Hexadecimal Number Conversion"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Decimal Value Before Considering This Digit Place</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>689</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>689</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>177</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Power of 16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16<sup>3</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16<sup>2</sup></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16<sup>1</sup></p></td><td style="border-bottom: 0.5pt solid ; "><p>16<sup>0</sup></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value of Digit Place</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4096</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>256</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Value of Digit Place Smaller Than Current Decimal Number?</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-bottom: 0.5pt solid ; "><p>n/a</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Division Step</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>689/256 = 2.691 (use 2 for this digit)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>177/16 = 11.0625 (use B for this digit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>n/a</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remainder After Division</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>177</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>n/a</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Hexadecimal Digits</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; "><p>B</p></td><td style=""><p>1</p></td></tr></tbody></table></div></div></div></div></div>
<div class="sect1" title="Binary, Octal, and Hexadecimal Arithmetic"><div class="titlepage"><div><div><h1 class="title"><a id="binary_octal_and_hexadecimal_arithmetic"/>Binary, Octal, and Hexadecimal Arithmetic</h1></div></div></div><p>We use arithmetic every day to give us the information we need to make decisions. Like us, computers perform arithmetic operations constantly as part of their normal operation, except that computers use binary numbers to perform their calculations incredibly fast.<a class="indexterm" id="idx-CHP-4-0269"/></p><p>Binary, octal, and hexadecimal numbers are essentially different representations of numbers, and as such they are not really much different than decimal numbers; they simply have a different number of values per digit. In a similar vein, doing arithmetic with binary, octal, or hexadecimal numbers is not that different from the equivalent operations with decimal numbers. You just have to keep in mind that you are working with powers of 2, 8, or 16, instead of 10, which isn't always easy.</p><p>As with number system conversions, calculators are usually the way to go if you need to do math with binary, octal, or hexadecimal numbers. If your calculator does math with only decimal numbers, you can use the trick of converting the numbers to decimal, and then performing the operation and converting the result. However, you can fairly easily do the same addition, subtraction, multiplication, and division on binary, octal, or hexadecimal numbers that you would with decimal numbers by using the Windows Calculator program.</p><p>Computers often need to perform multiplication and division operations on binary numbers, but people working with computers don't often perform these operations. Addition and subtraction are much more common operations (especially addition), and they have the added bonus of being much easier to explain. You probably won't need to do this type of arithmetic that often, but it's good to understand it. I'll provide a couple of examples to give you the general idea.</p><div class="sect2" title="Binary Arithmetic"><div class="titlepage"><div><div><h2 class="title"><a id="binary_arithmetic"/>Binary Arithmetic</h2></div></div></div><p>Let's start with binary. Adding binary numbers is the same as adding decimal ones, except that you end up doing <span class="emphasis"><em>a lot</em></span> of the carrying of ones since there are so few values allowed per digit. <a class="xref" href="ch04s04.html#binary_addition" title="Table 4-7. Binary Addition">Table 4-7</a> shows an example, with one digit in each column; read it from right to left and top to bottom, just as you would usually do with a manual <a class="indexterm" id="idx-CHP-4-0270"/>addition. You start by adding the 1 in the ones place from the first number with the 1 in that place from the second number, thereby yielding a raw digit sum of 2. This means the result for the ones digit is 1, and you carry a 1 to the twos place. You continue with this process until you have added all the digits.</p><div class="table"><a id="binary_addition"/><p class="title">Table 4-7. Binary Addition</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Binary Addition"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Carry</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>—</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>First Binary Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Second Binary Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Raw Digit Sum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Result</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Carry to Next Higher Digit</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>1</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Octal and Hexadecimal Arithmetic"><div class="titlepage"><div><div><h2 class="title"><a id="octal_and_hexadecimal_arithmetic"/>Octal and Hexadecimal Arithmetic</h2></div></div></div><p>Octal and hexadecimal are pretty much the same, except that you carry the number if the sum in a particular digit exceeds either 8 or 16, respectively. Hexadecimal is more common, and more interesting, so let's examine how to add two hexadecimal numbers. While performing the operation, you will need to convert single-digit hexadecimal numbers to decimal and back again, but this isn't too difficult.<a class="indexterm" id="idx-CHP-4-0271"/></p><p>The example shown in <a class="xref" href="ch04s04.html#hexadecimal_addition" title="Table 4-8. Hexadecimal Addition">Table 4-8</a> should be read from right to left. You start by adding 8 (decimal 8) to A (decimal 10) in the ones place. This yields a raw sum of 18, from which you carry 16 as a 1 to the 16s place and leave a result of 2. You add this 1 to the D (value 13) and E (14 value) of the 16s place. This is a total of 28, leaving 12 (C in hexadecimal), and you carry a 1 to the 256s place. This continues until you are left with a sum of 6DC2h.</p><div class="table"><a id="hexadecimal_addition"/><p class="title">Table 4-8. Hexadecimal Addition</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Hexadecimal Addition"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Carry</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>First Hex Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-bottom: 0.5pt solid ; "><p>8</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Second Hex Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>E</p></td><td style="border-bottom: 0.5pt solid ; "><p>A</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Raw Digit Sum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2+4 = 6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1+12+0 = 13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1+13+14 = 28</p></td><td style="border-bottom: 0.5pt solid ; "><p>8+10 = 18</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Result</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>D</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="border-bottom: 0.5pt solid ; "><p>2</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Carry to Next Higher Digit</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>1</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="Boolean Logic and Logical Functions"><div class="titlepage"><div><div><h1 class="title"><a id="boolean_logic_and_logical_functions"/>Boolean Logic and Logical Functions</h1></div></div></div><p>You'll recall that every bit in a computer system can hold a value of either 1 or 0, representing the basic on or off states inherent in a binary digital system, and that you can interpret these on or off values as true or false states, respectively. These values can represent various logical conditions within a system, and you can use various logical operations to manipulate and combine these values to represent more complex logical states.</p><p>British mathematician George Boole (1815–1864) was one of the pioneering users of binary values in logical equations, and in recognition of his contribution we call this <span class="emphasis"><em>boolean logic</em></span>.</p><div class="sect2" title="Boolean Logical Functions"><div class="titlepage"><div><div><h2 class="title"><a id="boolean_logical_functions"/>Boolean Logical Functions</h2></div></div></div><p>Boolean logic defines a number of <span class="emphasis"><em>boolean logical functions</em></span>, which are sometimes called <span class="emphasis"><em>operators</em></span>. Each of these functions uses a logical algorithm to compute an output value based on the value of one or more inputs. The algorithm determines when the output is true, based on the combination of <a class="indexterm" id="idx-CHP-4-0272"/>true and false values the inputs take. Thus, the table that shows the inputs and outputs for a logical function is called a <span class="emphasis"><em>truth table</em></span>. Each of the logical functions is analogous to a real-world logical operation that you can use to define various logical situations (as you will soon see).<a class="indexterm" id="idx-CHP-4-0273"/><a class="indexterm" id="idx-CHP-4-0274"/><a class="indexterm" id="idx-CHP-4-0275"/></p><div class="sect3" title="NOT"><div class="titlepage"><div><div><h3 class="title"><a id="not"/>NOT</h3></div></div></div><p>Consider the simplest function: <span class="emphasis"><em>NOT</em></span>. As you might expect, this is a just a negation; the output is the opposite of the input. The NOT function takes only one input, so it is called a <span class="emphasis"><em>unary</em></span> function or operator. The truth table for NOT is shown in <a class="xref" href="ch04s05.html#not_operator_truth_table" title="Table 4-9. NOT Operator Truth Table">Table 4-9</a>. As you can see, the output is true when the input is false, and vice versa.<a class="indexterm" id="idx-CHP-4-0276"/><a class="indexterm" id="idx-CHP-4-0277"/><a class="indexterm" id="idx-CHP-4-0278"/></p><div class="table"><a id="not_operator_truth_table"/><p class="title">Table 4-9. NOT Operator Truth Table</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="NOT Operator Truth Table"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input</p></th><th style="border-bottom: 0.5pt solid ; "><p>Output</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>False</p></td><td style="border-bottom: 0.5pt solid ; "><p>True</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>True</p></td><td style=""><p>False</p></td></tr></tbody></table></div></div><p>The NOT function logically represents the opposite of a condition. For example, suppose you have a bit called B1 whose logical meaning is that when the bit is true, a particular pixel on a screen is lit up. Then the <span class="emphasis"><em>boolean expression</em></span> NOT B1 would be the opposite: It would be false when the pixel is lit up, and thus true only when the pixel is <span class="emphasis"><em>not</em></span> lit up.</p><p>Since <a class="indexterm" id="idx-CHP-4-0279"/>true and false values are represented in computers by 1 or 0 values, boolean logic is often expressed in terms of ones and zeros, instead of true and false. The circuits inside computer processors and other devices manipulate one and zero bits directly using these functions. In some (but not all) cases, they interpret one and zero as true and false, but in either case, the two representations are functionally equivalent.</p><p><a class="xref" href="ch04s05.html#not_operator_truth_table_using_bit_value" title="Table 4-10. NOT Operator Truth Table (Using Bit Values)">Table 4-10</a> shows the same <a class="indexterm" id="idx-CHP-4-0280"/>truth table as <a class="xref" href="ch04s05.html#not_operator_truth_table" title="Table 4-9. NOT Operator Truth Table">Table 4-9</a>, but using bit values. Each true is represented as a 1, <a class="indexterm" id="idx-CHP-4-0281"/>and each false is represented as a 0.</p><div class="table"><a id="not_operator_truth_table_using_bit_value"/><p class="title">Table 4-10. NOT Operator Truth Table (Using Bit Values)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="NOT Operator Truth Table (Using Bit Values)"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input</p></th><th style="border-bottom: 0.5pt solid ; "><p>Output</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>0</p></td></tr></tbody></table></div></div></div><div class="sect3" title="AND and OR"><div class="titlepage"><div><div><h3 class="title"><a id="and_and_or"/>AND and OR</h3></div></div></div><p>The two other primary boolean functions that are widely used are <span class="emphasis"><em>AND</em></span> and <span class="emphasis"><em>OR</em></span>. The output of an AND function is true only if its first, and second, and third inputs and so on are true. The output of an OR function is true if the first input is true <span class="emphasis"><em>or</em></span> the second input is true, and so on.<a class="indexterm" id="idx-CHP-4-0282"/><a class="indexterm" id="idx-CHP-4-0283"/></p><p>Both <a class="indexterm" id="idx-CHP-4-0284"/>AND and OR can have any number of inputs, with a minimum of two. <a class="xref" href="ch04s05.html#and_operator_truth_table" title="Table 4-11. AND Operator Truth Table">Table 4-11</a> shows the truth table for the AND function, with two inputs. You can see that the output is a 1 only when both inputs are 1, but it's 0 otherwise.</p><div class="table"><a id="and_operator_truth_table"/><p class="title">Table 4-11. AND Operator Truth Table</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="AND Operator Truth Table"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input 1</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input 2</p></th><th style="border-bottom: 0.5pt solid ; "><p>Output</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>1</p></td></tr></tbody></table></div></div><p>Like NOT, AND represents a logical operation similar to how we use the word <span class="emphasis"><em>and</em></span> in our everyday speech. For example, at lunchtime, I might say to a colleague, "Let's go out for lunch <span class="emphasis"><em>and</em></span> stop at the post office."</p><p>The truth table for the OR function (again with two inputs) is shown in <a class="xref" href="ch04s05.html#or_operator_truth_table" title="Table 4-12. OR Operator Truth Table">Table 4-12</a>. Here, the output is 1 whenever a 1 appears in at least one input, not necessarily both as in the previous table.</p><div class="table"><a id="or_operator_truth_table"/><p class="title">Table 4-12. OR Operator Truth Table</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OR Operator Truth Table"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input 1</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input 2</p></th><th style="border-bottom: 0.5pt solid ; "><p>Output</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>1</p></td></tr></tbody></table></div></div><p>Interestingly, unlike AND, the OR function does <span class="emphasis"><em>not</em></span> have the same meaning as what we take the word <span class="emphasis"><em>or</em></span> to mean in everyday English. In boolean, the word OR means that the output is true as long as <span class="emphasis"><em>any</em></span> of the inputs is true.</p></div><div class="sect3" title="Exclusive-OR (XOR or EOR)"><div class="titlepage"><div><div><h3 class="title"><a id="exclusive-or_xor_or_eor"/>Exclusive-OR (XOR or EOR)</h3></div></div></div><p>A modification of OR called <span class="emphasis"><em>Exclusive-OR</em></span> (abbreviated either <span class="emphasis"><em>XOR</em></span> or <span class="emphasis"><em>EOR</em></span>) represents the way we normally use <span class="emphasis"><em>or</em></span> in the real world. Its output is only true if one input or the other is true, but <span class="emphasis"><em>not both</em></span>. The <a class="indexterm" id="idx-CHP-4-0285"/>truth table for XOR is as shown in <a class="xref" href="ch04s05.html#exclusive_or_xor_operator_truth_table" title="Table 4-13. Exclusive OR (XOR) Operator Truth Table">Table 4-13</a>. Notice the difference between this table and <a class="xref" href="ch04s05.html#or_operator_truth_table" title="Table 4-12. OR Operator Truth Table">Table 4-12</a>: The output is 0 in the case where both inputs are 1.<a class="indexterm" id="idx-CHP-4-0286"/><a class="indexterm" id="idx-CHP-4-0287"/></p><div class="table"><a id="exclusive_or_xor_operator_truth_table"/><p class="title">Table 4-13. Exclusive OR (XOR) Operator Truth Table</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Exclusive OR (XOR) Operator Truth Table"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input 1</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input 2</p></th><th style="border-bottom: 0.5pt solid ; "><p>Output</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>0</p></td></tr></tbody></table></div></div></div></div><div class="sect2" title="Combining Boolean Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="combining_boolean_expressions"/>Combining Boolean Expressions</h2></div></div></div><p>The functions described earlier can also be combined arbitrarily to produce more complex <a class="indexterm" id="idx-CHP-4-0288"/>logical conditions. For example, when searching the Web, you might enter "cheese AND (cheddar OR swiss) NOT wisconsin" into a search engine. In response, the search engine might return pages that contain the word <span class="emphasis"><em>cheese</em></span> and the word <span class="emphasis"><em>cheddar</em></span> or <span class="emphasis"><em>swiss</em></span> (or both), but pages that do <span class="emphasis"><em>not</em></span> contain the word <span class="emphasis"><em>wisconsin</em></span>.<a class="indexterm" id="idx-CHP-4-0289"/></p><p>Boolean functions are important because they are the building blocks of much of the circuitry within computer hardware. The functions are implemented as tiny <span class="emphasis"><em>gates</em></span> that are designed to allow electrical energy to flow only to the output based on certain combinations of inputs as described by the truth tables for functions like NOT, AND, OR, and others. In networking, boolean logic is important for describing certain conditions and functions in the operation of networks. Boolean functions are also very important because they are used to set, clear, and mask strings of binary digits, which I will explore in the next section.<a class="indexterm" id="idx-CHP-4-0290"/></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-32"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Boolean logic</em></span> is a system that uses boolean functions to produce output based on varying conditions in input data. The most common boolean functions are as follows: <span class="emphasis"><em>NOT</em></span>, which produces output that is the opposite of its input; <span class="emphasis"><em>AND</em></span>, which is true only if all of its inputs are true; <span class="emphasis"><em>OR</em></span>, which is true if any of its input is true; and <span class="emphasis"><em>XOR</em></span>, which is true only if exactly one of its inputs is true (that is, if the inputs are different). These functions can be used in boolean logic expressions that represent conditional states for making decisions, and they can also be used for bit manipulation.</p></div></div></div>
<div class="sect1" title="Bit Masking (Setting, Clearing, and Inverting) Using Boolean Logical Functions"><div class="titlepage"><div><div><h1 class="title"><a id="bit_masking_setting_clearing_and_inverti"/>Bit Masking (Setting, Clearing, and Inverting) Using Boolean Logical Functions</h1></div></div></div><p>The boolean functions NOT, AND, OR, and XOR describe different ways that logical expressions can be used to manipulate true and false values to represent both simple and complex decisions or conditions. However, these functions can also be used in a more mundane manner to allow the direct manipulation of binary data. This use of boolean logic is very important in a number of different applications in networking.<a class="indexterm" id="idx-CHP-4-0291"/></p><p>You should recall that when you give a <a class="indexterm" id="idx-CHP-4-0292"/>bit a value you <span class="emphasis"><em>set</em></span> the bit, and when you give it a value of 0, you <span class="emphasis"><em>reset</em></span> or <span class="emphasis"><em>clear</em></span> it. In some situations <a class="indexterm" id="idx-CHP-4-0293"/>bits are handled individually and are set or cleared simply by assigning a 0 or 1 value to each bit. However, it is common to have large groups of bits that are used collectively to represent a great deal of information, whenever many bits need to be set or cleared at once. In this situation, the boolean functions come to the rescue.</p><div class="sect2" title="Setting Groups of Bits with OR"><div class="titlepage"><div><div><h2 class="title"><a id="setting_groups_of_bits_with_or"/>Setting Groups of Bits with OR</h2></div></div></div><p>You can set bits en masse with the OR function. Recall that an OR's output is true (equal to 1) if any of its inputs are true (equal to 1). Thus, if you OR a bit with a value known to be 1, the result will always be 1, no matter what the other value is. In contrast, if you OR with a 0, the original value, 1 or 0, is not changed.<a class="indexterm" id="idx-CHP-4-0294"/></p><p>By using a string with 0s and 1s in particular spots, you can set certain bits to 1 while leaving others unchanged. This procedure is comparable to how a painter <span class="emphasis"><em>masks</em></span> areas that he does not want to be painted, using plastic or perhaps masking tape. Thus, the process is called <span class="emphasis"><em>masking</em></span>. The string of digits used in the operation is called the <span class="emphasis"><em>bit mask</em></span>, or simply the <span class="emphasis"><em>mask</em></span>.<a class="indexterm" id="idx-CHP-4-0295"/></p><p>For example, suppose you have the 12-bit binary input number 101001011010, and you want to set the middle six bits to be all ones. To do this, you OR the number with the 12-bit mask 000111111000. <a class="xref" href="ch04s06.html#setting_bits_using_an_or_bit_mask" title="Table 4-14. Setting Bits Using an OR Bit Mask">Table 4-14</a> shows how this works with the changed bits in the result in bold—you simply OR each bit in the input with its corresponding bit in the mask:</p><div class="table"><a id="setting_bits_using_an_or_bit_mask"/><p class="title">Table 4-14. Setting Bits Using an OR Bit Mask</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Setting Bits Using an OR Bit Mask"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mask</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Result of OR Operation</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>0</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Clearing Bits with AND"><div class="titlepage"><div><div><h2 class="title"><a id="clearing_bits_with_and"/>Clearing Bits with AND</h2></div></div></div><p>To clear a certain pattern of bits, you perform a similar masking operation, but using the AND function instead. If you AND a bit with 0, it will clear it to 0, regardless of what the bit was before, while ANDing with 1 will leave the bit unchanged. For example, to clear the middle six bits in <a class="xref" href="ch04s06.html#setting_bits_using_an_or_bit_mask" title="Table 4-14. Setting Bits Using an OR Bit Mask">Table 4-14</a>, you AND with the reverse bit mask, 111000000111.<a class="indexterm" id="idx-CHP-4-0296"/><a class="indexterm" id="idx-CHP-4-0297"/></p><p><a class="xref" href="ch04s06.html#clearing_bits_using_an_and_bit_mask" title="Table 4-15. Clearing Bits Using an AND Bit Mask">Table 4-15</a> and <a class="xref" href="ch04s06.html#clearing_bits_using_an_and_bit_mask_appl" title="Figure 4-3. Clearing Bits Using an AND Bit Mask Applying a bit mask to an input binary number using the AND function clears to 0 all bits where the mask bit was 0 and leaves alone bits where the mask was 1.">Figure 4-3</a> show how a bit mask can be used to clear certain bits in a binary number while preserving others. Each 1 represents a "transparent" area that keeps the corresponding input bit value, while each 0 is a bit where the original value is to be cleared. After performing an AND on each bit pair, the first three and last three bits are preserved, while the middle six, since they were each ANDed with 0, are forced to 0 in the output.</p><div class="figure"><a id="clearing_bits_using_an_and_bit_mask_appl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e6100"/><img alt="Clearing Bits Using an AND Bit Mask Applying a bit mask to an input binary number using the AND function clears to 0 all bits where the mask bit was 0 and leaves alone bits where the mask was 1." src="httpatomoreillycomsourcenostarchimages287701.png"/></div></div><p class="title">Figure 4-3. Clearing Bits Using an AND Bit Mask Applying a bit mask to an input binary number using the AND function clears to 0 all bits where the mask bit was 0 and leaves alone bits where the mask was 1.</p></div><div class="table"><a id="clearing_bits_using_an_and_bit_mask"/><p class="title">Table 4-15. Clearing Bits Using an AND Bit Mask</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Clearing Bits Using an AND Bit Mask"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mask</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>1</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Result of AND Operation</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>0</p></td></tr></tbody></table></div></div><p>You can also look at this <a class="indexterm" id="idx-CHP-4-0298"/>clearing function a different way. You are clearing the bits where the mask is a 0, and in so doing selecting the bits where the mask is a 1. Thus, ANDing with a bit mask essentially means that you keep the bits where the mask is a 1 and remove the bits where it is a 0.<a class="indexterm" id="idx-CHP-4-0299"/></p></div><div class="sect2" title="Inverting Bits with XOR"><div class="titlepage"><div><div><h2 class="title"><a id="inverting_bits_with_xor"/>Inverting Bits with XOR</h2></div></div></div><p>There are also situations in which you want to <span class="emphasis"><em>invert</em></span> some bits; that is, change a 1 value to a 0, or a 0 value to a 1. To do this, you use the XOR function. While this is not as intuitive as masking, if you refer to the XOR truth table (<a class="xref" href="ch04s05.html#exclusive_or_xor_operator_truth_table" title="Table 4-13. Exclusive OR (XOR) Operator Truth Table">Table 4-13</a>) you will see that if you XOR with a 1, the input value is flipped, while XORing with a 0 causes the input to be unchanged. To see how this works, use the same input example and invert the middle six bits, as shown in <a class="xref" href="ch04s06.html#inverting_bits_using_an_xor_bit_mask" title="Table 4-16. Inverting Bits Using an XOR Bit Mask">Table 4-16</a>.<a class="indexterm" id="idx-CHP-4-0300"/></p><div class="table"><a id="inverting_bits_using_an_xor_bit_mask"/><p class="title">Table 4-16. Inverting Bits Using an XOR Bit Mask</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Inverting Bits Using an XOR Bit Mask"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Input</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mask</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Result of XOR Operation</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>0</p></td></tr></tbody></table></div></div><p>In the world of networking, bit masking is most commonly used to manipulate addresses. In particular, masking is perhaps best known for its use in differentiating between the host and subnetwork (subnet) portions of Internet Protocol (IP) addresses, a process called <span class="emphasis"><em>subnet masking</em></span> (see <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>, which discusses IP subnet addressing).<a class="indexterm" id="idx-CHP-4-0301"/></p><div class="note" title="Note"><h3 class="title"><a id="note-24"/>Note</h3><p><span class="emphasis"><em>Masks are often expressed in either hexadecimal or decimal notation for simplicity, as shown in the IP subnetting summary tables in <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>. However, the masks are always applied in binary, as described previously. You should convert the mask to binary if you want to see exactly how the masking operation will work</em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-33"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The properties of the <span class="emphasis"><em>OR</em></span> and <span class="emphasis"><em>AND</em></span> boolean functions make them useful when certain bits of a data item need to be set (changed to 1) or cleared (changed to 0). This process is called <span class="emphasis"><em>bit masking</em></span>. To set bits to 1, a mask is created and used in a bit-by-bit OR function with the input. When the mask has a value of 1, the bit is forced to a 1, while each 0 bit leaves the corresponding original bit unchanged. Similarly, a mask used with the AND function clears certain bits; each 1 bit in the mask leaves the original bit alone, while each 0 forces the output to 0. Finally, <span class="emphasis"><em>XOR</em></span> can be used to invert selected bits using a mask.</p></div></div></div></body></html>