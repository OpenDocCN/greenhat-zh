<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;DATA FORMATS"><div class="titlepage"><div><div><h1 class="title"><a id="data_formats"/>Chapter 8. DATA FORMATS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e8707"/><img src="httpatomoreillycomsourcenostarchimages671943.png.jpg" alt="image with no caption"/></div></div><p>Working with maps usually means interacting with a lot of geographic data. Along with descriptive information, you need to know where a place is so you can plot it on your map. Chances are good that most of the time you'll need to get data from someone else. You might also need to share your data with someone.</p><p>Several standard formats have been adopted to make passing around geographic data even easier. In this chapter, I'll go over a few ways to share the basic pieces of geography you'd put on a map: points, lines, and shapes.</p><p>We'll also go over a couple formats that are popular on the web for exchanging information. More and more, your sources will be websites that make their data available with an API. In most cases, the format you'll need is covered in this chapter.</p><p>Let's get started and learn some data formats.<a id="IDX-CHP-8-0001" class="indexterm"/></p><div class="sect1" title="#52: Use XML"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_52_colon_use_xml"/>#52: Use XML</h1></div></div></div><p>The <span class="emphasis"><em>Extensible Markup Language (XML)</em></span> is the building block of much of the Web's data and of several other formats discussed in this chapter. It looks a lot like HTML, because some HTML actually <span class="emphasis"><em>is</em></span> XML. This section will stay away from specific flavors of XML, however, as I'll be covering some in their own sections. Here, I'll focus on how to recognize and use generic XML.<a id="IDX-CHP-8-0002" class="indexterm"/><a id="IDX-CHP-8-0003" class="indexterm"/><a id="IDX-CHP-8-0004" class="indexterm"/><a id="IDX-CHP-8-0005" class="indexterm"/><a id="IDX-CHP-8-0006" class="indexterm"/><a id="IDX-CHP-8-0007" class="indexterm"/><a id="IDX-CHP-8-0008" class="indexterm"/><a id="IDX-CHP-8-0009" class="indexterm"/><a id="IDX-CHP-8-0010" class="indexterm"/><a id="IDX-CHP-8-0011" class="indexterm"/><a id="IDX-CHP-8-0012" class="indexterm"/></p><p>First, what does it look like? XML is made up of tags, which are words inside pointed greater-than and less-than brackets, <code class="literal">&lt;</code> and <code class="literal">&gt;</code>. Understanding what the words inside the brackets stand for is usually easy, but sometimes they are abbreviations or acronyms. Tags can contain other tags, as well as <em class="replaceable"><code>key</code></em><code class="literal">=</code><em class="replaceable"><code>value</code></em> pairs, which are called <span class="emphasis"><em>attributes</em></span>. Tags containing other tags or text end with a matching closing tag that includes a <code class="literal">/</code> before the tag name.</p><p>Consider this short example XML file:</p><a id="I_programlisting8_d1e8798"/><pre class="programlisting">❶ ?xml version="1.0" encoding="UTF-8"?&gt;
❷ root&gt;
    &lt;child ❸name="first"&gt;
      ❹&lt;grandchild&gt;text could go here&lt;/grandchild&gt;
    &lt;/child&gt;
    &lt;child name="second" ❺/&gt;
  &lt;/root&gt;</pre><p>XML files usually start off in a similar way, with a processing instruction declaring it as XML ❶ and providing version and encoding information. This special tag does not have a corresponding end tag. With this header out of the way, we get straight to the data.</p><p>The root element ❷ can be named anything, but you can only have one. For example, HTML only has one <code class="literal">&lt;html&gt;</code> tag. Within the starting and ending root tags comes the real XML content. In this case, the XML has two child elements. Again, the tags can be named anything, but I've used names that help describe XML terms in this example.</p><p>XML is hierarchical, and accessing the data requires understanding its structure. The first child element has a single attribute ❸ and a child element ❹ of its own. The second child element also has an attribute, but it contains no children. When this is the case, we can abbreviate the closing tag ❺.</p><p>Now we want to get at this data inside the XML. Reading in the tags and converting them to a structure the computer can understand is called <span class="emphasis"><em>parsing</em></span>. Most languages have some built-in way to parse XML. Next I'll show two JavaScript examples and one using PHP, a server-side programming language.</p><div class="sect2" title="Parse XML with JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="parse_xml_with_javascript"/>Parse XML with JavaScript</h2></div></div></div><p>Every modern browser comes with a way to read in XML content, which makes sense seeing as so much of the Web is built upon the technology. Unfortunately, the various browsers have their differences. Also, getting at deeply nested elements can be a pain.</p><p>Before showing an easier way, we'll give it a go in this section using the XML example just described. Rather than loading in an XML file (which I'll get to in the next section), we'll use XML that is stored as a string of text.</p><p>Because we are using JavaScript, the file needs to live inside a web page. Everything we'll be doing will be in the JavaScript portion, so the web page will otherwise be blank. Add these lines into a new file:</p><a id="I_programlisting8_d1e8823"/><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
  &lt;script&gt;
❶   var xmltxt = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n";
        xmltxt += "&lt;root&gt;\n";
        xmltxt += " &lt;child name=\"first\" /&gt;\n";
        xmltxt += " &lt;child name=\"second\"&gt;\n";
        xmltxt += " &lt;grandchild&gt;text goes here&lt;/grandchild&gt;\n";
        xmltxt += " &lt;/child&gt;\n";
        xmltxt += "&lt;/root&gt;\n";
    var x = null;
    var output = "";

❷   if (window.ActiveXObject) { // Internet Explorer
      x = new ActiveXObject("Microsoft.XMLDOM");
      x.async = false;
      x.loadXML(xmltxt);
    }
❸   else if (window.DOMParser) { // Other browsers
      var p = new DOMParser();
      x = p.parseFromString(xmltxt, "text/xml");
    }
    else {
        // Can't load XML
    }

    if (x) {
❹     <strong class="userinput"><code>var children = x.getElementsByTagName("child");</code></strong>
❺     <strong class="userinput"><code>for (i=0; i&lt;children.length; i++) {</code></strong>
❻       <strong class="userinput"><code>output += children[i].getAttribute("name") + "\n";</code></strong>
      <strong class="userinput"><code>}</code></strong>
    }
    alert(output);
  &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
  &lt;/html&gt;</pre><p>The bold lines are the ones that get at the data. Everything else is pure setup. To be fair, getting the XML text ready ❶ does take seven lines. We could reduce this to a single line, but I've expanded it for clarity.</p><p>Parsing the XML requires a multistep approach. First, we need to try the Internet Explorer way ❷. This method will fail if we are using another browser. Then, we get to the use the more widely adopted method ❸. Hopefully this one works, because if it doesn't, we can't parse the XML.<a id="IDX-CHP-8-0013" class="indexterm"/><a id="IDX-CHP-8-0014" class="indexterm"/><a id="IDX-CHP-8-0015" class="indexterm"/><a id="IDX-CHP-8-0016" class="indexterm"/><a id="IDX-CHP-8-0017" class="indexterm"/><a id="IDX-CHP-8-0018" class="indexterm"/><a id="IDX-CHP-8-0019" class="indexterm"/></p><p>The <code class="literal">x</code> variable should contain an XML object after those two tries. This variable is used by the bold section to extract the names of the children. First, we look through the XML for all the child tags ❹. Then, we loop through all of those tags ❺. We can tell which step we're on by the <code class="literal">i</code> variable, which starts at zero and counts up each step. Each time through the loop, we add the name of the current child to the text we will output ❻.</p><p>If you load this file into a web browser, you should see a JavaScript alert with the names "first" and "second." You've successfully parsed XML with plain ol' JavaScript. Now let's check out how you parse it with the JavaScript library jQuery.</p></div><div class="sect2" title="Parse XML with jQuery JavaScript Library"><div class="titlepage"><div><div><h2 class="title"><a id="parse_xml_with_jquery_javascript_library"/>Parse XML with jQuery JavaScript Library</h2></div></div></div><p>The single principle behind jQuery is to write less code. The hard work is left to the library, which itself is very small (currently less than 20K). When it comes to fetching and parsing XML, jQuery keeps things predictably simple.</p><p>Like the plain JavaScript example, we'll be parsing the XML in an otherwise empty HTML file. However, in this case, we'll load our XML straight from a file, which is a common situation. Make sure you have a file named <span class="emphasis"><em>example.xml</em></span> containing the XML from earlier, and then add these lines to a new file in the same directory:</p><a id="I_programlisting8_d1e8890"/><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
❶   &lt;script src="http://ajax.googleapis.com/ajax/libs/
jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    var output = "";
❷   $.get("example.xml", {}, ❸function(xml) {
❹     $("child", xml).❺each(function(i) {
        output += ❻this.getAttribute("name") + "\n";
    });
    alert(output);
  });
  &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
  &lt;/html&gt;</pre><p>The first thing you'll notice is that we need to load the jQuery JavaScript file ❶. You can download it to your own server from <a class="ulink" href="http://jquery.com/">http://jquery.com/</a> or reference a version hosted by Google, as I did in this example. In either case, we get access to the library's many features, which include using Ajax to load files with JavaScript and parsing XML.</p><p>The jQuery library makes use of many techniques to decrease the amount of JavaScript you need to write. Among them is the <span class="emphasis"><em>dollar sign object</em></span>, which allows you to access much of jQuery's functionality with very simple syntax. For example, loading an XML file is accomplished by calling the <code class="literal">$.get</code> function ❷.<a id="IDX-CHP-8-0020" class="indexterm"/><a id="IDX-CHP-8-0021" class="indexterm"/><a id="IDX-CHP-8-0022" class="indexterm"/><a id="IDX-CHP-8-0023" class="indexterm"/><a id="IDX-CHP-8-0024" class="indexterm"/><a id="IDX-CHP-8-0025" class="indexterm"/><a id="IDX-CHP-8-0026" class="indexterm"/></p><p>To implement an Ajax call without jQuery requires trying different methods depending on the browser, much like our XML parsing example in the previous section. Instead, jQuery does the work to ensure we can get at the data.</p><p>Loading the XML also shows an example of another technique for decreasing code: inline, <span class="emphasis"><em>anonymous functions</em></span>. These functions are part of the standard JavaScript language but become especially useful with the way jQuery simplifies code. When performing an Ajax call, such as the one we use to load our XML file, JavaScript needs a callback function. Rather than creating a named function just to receive the XML results, we can write one inline ❸.<a id="IDX-CHP-8-0027" class="indexterm"/><a id="IDX-CHP-8-0028" class="indexterm"/></p><p>Inside the anonymous function (so named because it doesn't have a name), we use another jQuery shorthand to parse the XML. The parsing happens so fast, you might not even realize it's happening. The dollar sign function is passed the tag name we want, along with the XML variable that holds the content we got back from the Ajax call ❹. Then we chain the jQuery <code class="literal">each</code> function to the result, and we can loop through all the child elements ❺. We don't have to use an explicit <code class="literal">for</code> loop, nor do we need to determine the number of children. That happens within jQuery.</p><p>What we do each time through the jQuery loop is determined by another anonymous function. Again, we just keep everything inline because having a named function for one line of code doesn't make sense. Of course, the code is only one line because we're using jQuery. The <code class="literal">this</code> variable holds the current child element, and then we use the same <code class="literal">getAttribute</code> function we used in the non-jQuery example to grab the name attribute ❻.</p><p>In about half the lines as the previous example, we achieved the same result. If you load the file in your web browser, a JavaScript alert will print the names of the child tags, "first" and "second." jQuery makes it easy to do the stuff you'll do often as you work with APIs and parse data formats, many of which use XML.</p></div><div class="sect2" title="Parse XML with PHP"><div class="titlepage"><div><div><h2 class="title"><a id="parse_xml_with_php"/>Parse XML with PHP</h2></div></div></div><p>In many cases, you'll want to retrieve XML on your server. To do this, you won't use JavaScript, because you usually write JavaScript inside a web browser; you'll use PHP. PHP is a popular programming language for coding server-side applications. For more about PHP and making sure you have it available on your server, be sure to read <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a>.</p><p>Let's parse the example XML from the previous sections using PHP. Make sure you have a file named <span class="emphasis"><em>example.xml</em></span> on your server. Create a new PHP file in the same directory and add these lines:</p><a id="I_programlisting8_d1e8978"/><pre class="programlisting">&lt;?
❶ $xmltxt = join("\n", file("example.xml"));
❷ $xmlobj = simplexml_load_string($xmltxt);
  foreach (❸$xmlobj-&gt;child as $childobj) {
    print($childobj-&gt;❹attributes()-&gt;name . "\n");
  }
  ?&gt;</pre><p>The first thing we do is load our example XML file into the <code class="literal">$xmltxt</code> variable ❶. In many cases, we'll actually be loading the XML from an API. Either way, the XML content ends up in a variable, ready to be parsed.<a id="IDX-CHP-8-0029" class="indexterm"/><a id="IDX-CHP-8-0030" class="indexterm"/><a id="IDX-CHP-8-0031" class="indexterm"/><a id="IDX-CHP-8-0032" class="indexterm"/></p><p>We pass the work of going through the XML to PHP's <code class="literal">SimpleXML</code> class, which is included automatically in PHP 5. The <code class="literal">simplexml_load_string</code> function converts the textual XML into a useful object ❷ for accessing the data inside the XML. A <code class="literal">simplexml_load_file</code> function is also available, but again, most of the time you'll be converting a string that you retrieved from an API.</p><p>Once the XML is in object form, we can look for the name attribute within the child elements. We need to loop through all the child elements ❸, placing the current child inside its own object. Then, we get the attributes ❹ and find the one called name.</p><p>The code to query the XML will make more sense if you see what the object that PHP creates looks like. Use <code class="literal">print_r($xmlobj)</code> to see a textual representation of the hierarchical object:</p><a id="I_programlisting8_d1e9017"/><pre class="programlisting">SimpleXMLElement Object (
❶   [child] =&gt; Array (
      [0] =&gt; SimpleXMLElement Object (
❷       [@attributes] =&gt; Array (
          [name] =&gt; first
        )
      )
      [1] =&gt; SimpleXMLElement Object
        [@attributes] =&gt; Array (
          [name] =&gt; second
        )
❸       [grandchild] =&gt; text goes here
      )
    )
  )</pre><p>First of all, everything is inside a single <code class="literal">SimpleXMLElement</code> object, just as all the XML is within the root tag. Additional <code class="literal">SimpleXMLElement</code> objects are included as well, which is similar to having tags within tags. The SimpleXML class essentially converts XML into a series of arrays.</p><p>To begin, a numerical array of all the child elements ❶ is created. In this case, only two child elements are included, numbered 0 and 1, because, as with JavaScript, array indexes in PHP start at zero. Each child has an attributes array ❷, which is associative, meaning it ctontains key and value pairs. The key is the attribute name, in this case <code class="literal">name</code>.</p><p>Finally, if tags within the tag exist, they're listed. In this case, the second child tag contains a grandchild tag ❸. This tag contains only text, so it's represented as a key and value pair, too. If it contained tags or attributes underneath it, we'd have yet another <code class="literal">SimpleXMLElement</code>. Again, the <code class="literal">SimpleXML</code> class is all about finding a way to represent XML inside a PHP object.<a id="IDX-CHP-8-0033" class="indexterm"/></p><div class="sect3" title="Even Simpler XML with XPath"><div class="titlepage"><div><div><h3 class="title"><a id="even_simpler_xml_with_xpath"/>Even Simpler XML with XPath</h3></div></div></div><p>Traversing the <code class="literal">SimpleXML</code> object works fine in basic cases where the XML file is short and does not include a deep nesting of tags within tags. If you are swamped with XML content, you might find querying with XPath simpler.<a id="IDX-CHP-8-0034" class="indexterm"/></p><p>Like XML, XPath is a web standard. You can use XPath to traverse down through the XML to the data you want. All you need to do is call the <code class="literal">xpath</code> function on the <code class="literal">SimpleXML</code> object and tell it the "path" you want to access.</p><p>All three of the following examples find the same element, the grandchild tag, which is nested within two levels of hierarchy.</p><p>You can use the full path to the element:</p><a id="I_programlisting8_d1e9069"/><pre class="programlisting">$xmlobj-&gt;xpath("/root/child/grandchild")</pre><p>Or prepend a double slash to get every grandchild tag, regardless of what tags surround it:</p><a id="I_programlisting8_d1e9073"/><pre class="programlisting">$xmlobj-&gt;xpath("//grandchild")</pre><p>Or mix and match. Here, we grab any grandchild tag that exists below a child tag:</p><a id="I_programlisting8_d1e9077"/><pre class="programlisting">$xmlobj-&gt;xpath("//child/grandchild")</pre><p>XPath can help you quickly access XML in even more ways, such as querying for specific values, but I won't cover them here. You can find out more about XPath and <code class="literal">SimpleXML</code>, in general, at <a class="ulink" href="http://php.net/simplexml">http://php.net/simplexml</a>.</p><p>I've shown you several methods for accessing XML: JavaScript, the jQuery library, and PHP. What you use depends on where you're getting your XML, how complicated the XML is, and what languages you're already using.</p><p>Alternatively, you may grow weary of parsing XML and porting it to your JavaScript maps. Many programmers prefer working directly with a format called JSON that is closer to true JavaScript. Read on to learn about that format, and see <a class="xref" href="ch08s06.html" title="#57: Convert from XML to JSON">#57: Convert from XML to JSON</a> in <a class="xref" href="ch08s06.html" title="#57: Convert from XML to JSON">#57: Convert from XML to JSON</a> to learn about turning XML into the easier-to-use JSON.</p></div></div></div></div>
<div class="sect1" title="#53: Use JSON"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_53_colon_use_json"/>#53: Use JSON</h1></div></div></div><p>With JavaScript's ever-increasing popularity on the Web, JSON is quickly becoming the preferred data format for developers. That's because JSON stands for <span class="emphasis"><em>JavaScript Object Notation</em></span> and almost no parsing is necessary to use it in JavaScript. Plus, JSON takes fewer characters than XML to express the same data because it has no closing tags<a id="IDX-CHP-8-0035" class="indexterm"/></p><p>You aren't restricted to any one language. You can parse JSON in many server-side programming languages. I'll give an example using PHP later. Most modern languages have a data structure that makes converting JSON easy. This, along with JavaScript's popularity, have made this format widely used for interchanging data.</p><p>Enough about JSON's usefulness: Let's see an example of what JSON looks like. The following shows how the XML in the previous project might be expressed in JSON:</p><a id="I_programlisting8_d1e9110"/><pre class="programlisting">❶ {"child": [
❷   {"attributes": {"name": "first"}},
❸   {"attributes": {"name": "second"}, "grandchild": "text goes here"}
  ]}</pre><p>This basic example is a bit more complex than it needs to be, but it showcases many of the ways data can be organized in JSON. The building blocks are a series of key and value pairs inside braces, a structure called an object in JavaScript. The fun comes with the definition of a value.</p><p>In this example, our main object ❶ has only one key, <code class="literal">child</code>. The value is an array, declared by the brackets. An array can itself contain a list of values. In this case, the values are yet more objects.</p><p>The first object in the array ❷ contains a single key, <code class="literal">attributes</code>, and yet another object within it. Finally, the new object, which is three levels deep now, contains a key <code class="literal">name</code> and value of <code class="literal">first</code>. The second object in the array ❸ has a similar first key-value pair and then a second key, <code class="literal">grandchild</code>, which has a textual value.</p><p>So, a value can be an array, another object, or plain text. It could also be a number, a boolean, or a null, though I haven't shown that in this example.</p><p>Are you confused by the circular definition of what makes a value? That complication is intentional, but it actually ends up being an easy way to express many types of data. Because an object can contain arrays, objects, or even arrays of other objects, many types of hierarchical data can be expressed with JSON in a very small amount of space.</p><p>Now that you have an idea of how JSON looks, let's start using it.</p><div class="sect2" title="Parse JSON with JavaScript and jQuery"><div class="titlepage"><div><div><h2 class="title"><a id="parse_json_with_javascript_and_jquery"/>Parse JSON with JavaScript and jQuery</h2></div></div></div><p>Remember what JSON stands for? JavaScript Object Notation. This data format was not only made <span class="emphasis"><em>for</em></span> JavaScript but also made <span class="emphasis"><em>from</em></span> it.<a id="IDX-CHP-8-0036" class="indexterm"/><a id="IDX-CHP-8-0037" class="indexterm"/><a id="IDX-CHP-8-0038" class="indexterm"/><a id="IDX-CHP-8-0039" class="indexterm"/><a id="IDX-CHP-8-0040" class="indexterm"/></p><p>If you are hard-coding JSON into JavaScript, you don't need to do anything to use the data inside it. It is ready to go as written. Here, we access the first child in the example JSON using JavaScript:</p><a id="I_programlisting8_d1e9178"/><pre class="programlisting"><strong class="userinput"><code>var obj =</code></strong> {"child": [
  {"attributes": {"name": "first"}},
  {"attributes": {"name": "second"}, "grandchild": "text goes here"}
]}<strong class="userinput"><code>;</code></strong>
<strong class="userinput"><code>alert(obj.child[0].attributes.name);</code></strong></pre><p>I added the portion of the code in bold. Otherwise, this code is the exact JSON from earlier. All I did was assign it to a variable (<code class="literal">obj</code>), end the declaration with a semicolon (<code class="literal">;</code>), and then alert a specific value from the object.</p><p>Of course, JSON is not likely to be written directly into JavaScript. Instead, you'll probably receive it as output from an API. In other words, you might have JSON in text form.</p><p>If you trust the data, you can use the JavaScript <code class="literal">eval</code> function to convert JSON from text to object. Ensuring you have good data is a smart idea, however, because <code class="literal">eval</code> will execute any JavaScript text, not just text in the JSON format.</p><p>To avoid potentially large security issues, the <code class="literal">parseJSON</code> function has been added in some browsers. But this function is only really useful if it works in every browser. You can use a JavaScript file available at <a class="ulink" href="http://json.org/">http://json.org/</a> to fill the gaps while waiting for every browser to support the latest JavaScript version.</p><p>Another option is use the jQuery JavaScript library, which has an easy way to fetch data with Ajax. In fact, you can retrieve and parse JSON within a single line of jQuery.</p><p>Add these lines to a new HTML file:</p><a id="I_programlisting8_d1e9216"/><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
❶ &lt;script src="http://ajax.googleapis.com/ajax/libs/
jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script&gt;
  $.getJSON(❷"example.json", ❸function(jobj) {
      alert(❹jobj.child[0].attributes.name);
    });
  &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
  &lt;/html&gt;</pre><p>To access the many useful jQuery functions, we need to include the jQuery JavaScript file ❶. Although you can download this file to your server from <a class="ulink" href="http://jquery.com/">http://jquery.com/</a>, you can also reference a Google-hosted version, as I've done here.<a id="IDX-CHP-8-0041" class="indexterm"/><a id="IDX-CHP-8-0042" class="indexterm"/></p><p>jQuery does much of the difficult work for you and makes writing very short JavaScript that performs advanced functions possible. One of its more apparent ways of reducing code is to introduce the dollar sign object. Much of what happens in jQuery goes through <code class="literal">$</code>.</p><p>For example, we use the <code class="literal">$.getJSON</code> jQuery function to create an Ajax call to download and parse a JSON file. The most important information we need to provide is the JSON URL ❷. This URL can be a local file or a call to an external API.</p><p>Next, jQuery requires a function reference. In this case, we use an inline, anonymous function ❸ to describe what we want to do with the JSON result. Again, jQuery is about reducing code, but understanding what is happening here is still important. Ajax fetches our JSON, which is then parsed into an object. That object is returned to the anonymous function, where we can do whatever we want with it. In this case, I create an alert ❹ with the first child's name, just as I did when the data was hard-coded.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you are calling an external API that returns JSON, for security reasons, that API will need to accept a callback function name. To see an example of this in action, check out how I retrieve JSON from Yahoo! Pipes in <a class="xref" href="ch10s02.html" title="#69: Create a Weather Map">#69: Create a Weather Map</a> in <a class="xref" href="ch10s02.html" title="#69: Create a Weather Map">#69: Create a Weather Map</a>.</p></div><p>Building on top of jQuery can save you time and allow you to focus on higher-level issues with your mapping projects. You also get an added layer of complexity because you have one more piece of JavaScript to include in your HTML. Hopefully its benefits make up for this minor cost in loading time.</p></div><div class="sect2" title="Parse JSON with PHP"><div class="titlepage"><div><div><h2 class="title"><a id="parse_json_with_php"/>Parse JSON with PHP</h2></div></div></div><p>Sometimes you just need the data on the server. If the data is in JSON format, you won't be able to use JavaScript because it's almost always written inside a web browser. Most languages can easily read JSON though, so you'll find it's a reasonable format to use on a server, as well as on a client.</p><p>I'll use PHP again as an example server-side programming language because of its availability on most web hosts. If you're new to PHP, I provide an introduction to using PHP for geo projects in <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a>.</p><p>At the beginning of this project, I said that most languages have a JSON-like data structure. The JavaScript object, with its key-value pairs, is represented as an associative array in PHP. Similarly, PHP also has standard arrays, in addition to strings of text and numbers. In other words, all the pieces are here to represent JSON fully.</p><p>Here is some sample PHP that declares the exact same data I used in the sample JSON file:<a id="IDX-CHP-8-0043" class="indexterm"/><a id="IDX-CHP-8-0044" class="indexterm"/></p><a id="I_programlisting8_d1e9273"/><pre class="programlisting">&lt;?
$obj = array("child" =&gt; array(
  array("attributes" =&gt; array("name" =&gt; "first")),
  array(
  "attributes" =&gt; array("name" =&gt; "second"),
  "grandchild" =&gt; "text goes here")
));
?&gt;</pre><p>Now that we know representing JSON in PHP is possible, how do we go about parsing from text to associative array? Beginning with PHP 5, you can parse JSON with a single call.</p><p>Here's an example accessing the name of the first child, with the JSON text hard-coded. Yours will likely come from an API, or possibly a file, instead:</p><a id="I_programlisting8_d1e9279"/><pre class="programlisting">&lt;?
$jtxt = "{\"child\":[" .
        "{\"attributes\":{\"name\":\"first\"}}," .
        "{\"attributes\":{\"name\":\"second\"}," .
        "\"grandchild\":\"text goes here\"}]}";
$jobj = ❶json_decode($jtxt);
print ($jobj-&gt;❷child[0]-&gt;attributes-&gt;name);
?&gt;</pre><p>Yes, all the work is passed off for the internal PHP function ❶ to perform. Instead of using associative arrays, as we did previously, <code class="literal">json_decode</code> uses a PHP object. This object is slightly different but has a similar way of expressing data.</p><p>The keys, such as <code class="literal">child</code> ❷, are instance variables of the object and are referenced with the <code class="literal">-&gt;</code> arrow. All other types of data, including regular arrays, go through as-is. Just as with all other examples, the name of the first child can be found three levels down.</p><p>The curious reader might be wondering if another function exists to create JSON text from PHP data structures. Of course! The opposite of <code class="literal">json_decode</code> is <code class="literal">json_encode</code>. You could pass the <code class="literal">$obj</code> variable from the first example or the <code class="literal">$jobj</code> variable from the second example, and the result would be identical to the JSON text stored in the <code class="literal">$jtxt</code> variable.</p><p>You will likely need to decode JSON more often than encode it. That said, you'll be glad that function exists when you need it. For an example of encoding JSON, check out <a class="xref" href="ch10s04.html" title="#71: Search Music Events by Location">#71: Search Music Events by Location</a> in <a class="xref" href="ch10s04.html" title="#71: Search Music Events by Location">#71: Search Music Events by Location</a>.</p><p>Though my most recent examples have used PHP, JSON is a rising star of data formats because it incorporates so easily with JavaScript—JSON essentially <span class="emphasis"><em>is</em></span> JavaScript. Now that you know how to read in JSON data securely, you may find yourself on the lookout for APIs that use the format. JSON makes moving on from data parsing easy, so you can do what you really want to do: create awesome, data-filled web maps.<a id="IDX-CHP-8-0045" class="indexterm"/><a id="IDX-CHP-8-0046" class="indexterm"/></p></div></div>
<div class="sect1" title="#54: Use GeoRSS"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_54_colon_use_georss"/>#54: Use GeoRSS</h1></div></div></div><p>Location is only one tiny piece of information being pushed around the Web. A list of points is much more useful if you include context for what they mean. GeoRSS is a way to add location and other geographic information to content feeds, creating geo-tagged content.<a id="IDX-CHP-8-0047" class="indexterm"/><a id="IDX-CHP-8-0048" class="indexterm"/><a id="IDX-CHP-8-0049" class="indexterm"/></p><p>The content itself is commonly blog posts or photos, though it can be anything. Blogs are prime candidates for geo-tagging because most are already syndicated with an RSS feed, a way to get the latest posts without visiting the website.</p><p>Although named after RSS, GeoRSS can be used inside formats other than RSS. For example, the United States Geological Survey publishes an Atom feed of recent earthquakes, including the location and depth of each quake. GeoRSS can be added to any XML feed to attach geographic data to other content.<a id="IDX-CHP-8-0050" class="indexterm"/></p><p>Let's see an example of GeoRSS inside an RSS feed:</p><a id="I_programlisting8_d1e9354"/><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rss version="2.0" <strong class="userinput"><code/></strong>&gt;
  &lt;channel&gt;
    &lt;link&gt;http://mapscripting.com&lt;/link&gt;
    &lt;title&gt;Feed Title&lt;/title&gt;
    &lt;description&gt;Feed Description&lt;/description&gt;
    &lt;item&gt;
      &lt;pubDate&gt;Thu, 01 Jan 2010 00:01:23 +0000&lt;/pubDate&gt;
      &lt;title&gt;Item Title&lt;/title&gt;
      &lt;description&gt;Item Description&lt;/description&gt;
      &lt;author&gt;Item Author&lt;/author&gt;
      <strong class="userinput"><code>&lt;georss:point&gt;45.256 −71.92&lt;/georss:point&gt;</code></strong>
    &lt;/item&gt;
    ...
  &lt;/channel&gt;
&lt;/rss&gt;</pre><p>Most of the text is standard RSS. The bold sections are the GeoRSS hooks that add location data to the feed. At the top, you need to include the GeoRSS namespace, which allows you to use the <code class="literal">georss:</code> prefix for tags.</p><p>In this example, we've declared a point, which is a geographic coordinate. Inside the tag, we put the latitude first, followed by a space, and then the longitude. Sometimes you may see a comma between the numbers. Both are permissible.</p><p>GeoRSS has several ways to declare shapes, as well. These shapes are made up of multiple points and often represent a route, border, or other boundary. GeoRSS refers to them as lines, polygons, and boxes.<a id="IDX-CHP-8-0051" class="indexterm"/><a id="IDX-CHP-8-0052" class="indexterm"/><a id="IDX-CHP-8-0053" class="indexterm"/><a id="IDX-CHP-8-0054" class="indexterm"/><a id="IDX-CHP-8-0055" class="indexterm"/></p><p>Lines and polygons are both declared as a sequence of latitude and longitude points:</p><a id="I_programlisting8_d1e9394"/><pre class="programlisting">&lt;georss:line&gt;45.256 −110.45 46.46 −109.48 43.84 −109.86&lt;/georss:line&gt;
&lt;georss:polygon&gt;
  45.256 −110.45 46.46 −109.48 43.84 −109.86 45.256 −110.45
&lt;/georss:polygon&gt;</pre><p>As in this example, a line is at least two coordinates, but it can be many more. In this way, a line could describe a route.</p><p>A polygon is declared similarly, but the final point must be the same as the first point. In other words, a polygon is a circular route. It could, for example, be used to describe the outside walls of a house or the border of a country.</p><p>A box, on the other hand, will always create a rectangular shape and is declared with only two coordinates:</p><a id="I_programlisting8_d1e9403"/><pre class="programlisting">&lt;georss:box&gt;42.943 −71.032 43.039 −69.856&lt;/georss:box&gt;</pre><p>If you're confused, that's okay. A rectangle has four corners, so shouldn't a box have four coordinates? It's just like Mapstraction's <code class="literal">BoundingBox</code>, covered in <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a> in <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a>. GeoRSS uses only two corners to determine the box's location. The minimum data you need is the southwest and northeast corners. From those two points, you can extrapolate the northwest and southeast points.</p><p>Now that you are a little familiar with GeoRSS, let's use it in a different type of feed. Here is an example of GeoRSS inside the Atom format:</p><a id="I_programlisting8_d1e9416"/><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;feed 
      <strong class="userinput"><code/></strong>&gt;
  &lt;title&gt;Feed Title&lt;/title&gt;
  &lt;updated&gt;2010-01-01T00:01:23Z&lt;/updated&gt;
  &lt;author&gt;
    &lt;name&gt;Feed Author&lt;/name&gt;
    &lt;email&gt;feedemail@example.com&lt;/email&gt;
  &lt;/author&gt;
  &lt;id&gt;tag:mapscripting.com,2009-01-01:feedid&lt;/id&gt;
  &lt;entry&gt;
    &lt;title&gt;Entry title&lt;/title&gt;
    &lt;link href="http://example.org/entry_link"/&gt;
    &lt;updated&gt;2010-01-01T00:01:23Z&lt;/updated&gt;
    &lt;summary&gt;Entry summary&lt;/summary&gt;
    <strong class="userinput"><code>&lt;georss:point&gt;45.256 −71.92&lt;/georss:point&gt;</code></strong>
  &lt;/entry&gt;
  ...
&lt;/feed&gt;</pre><p>Atom is an alternative to RSS and is a widely supported format. As you can see, for our purposes, it is very similar to RSS. Again, the GeoRSS portions are bold.<a id="IDX-CHP-8-0056" class="indexterm"/><a id="IDX-CHP-8-0057" class="indexterm"/><a id="IDX-CHP-8-0058" class="indexterm"/><a id="IDX-CHP-8-0059" class="indexterm"/><a id="IDX-CHP-8-0060" class="indexterm"/><a id="IDX-CHP-8-0061" class="indexterm"/><a id="IDX-CHP-8-0062" class="indexterm"/></p><p>You will see GeoRSS most often in RSS and Atom formats. The examples I've shown, however, are the simple version of GeoRSS. The format sometimes looks a bit different, yet it is still GeoRSS. Read on for some examples of alternate GeoRSS encodings.</p><div class="sect2" title="Use Alternate GeoRSS Encodings"><div class="titlepage"><div><div><h2 class="title"><a id="use_alternate_georss_encodings"/>Use Alternate GeoRSS Encodings</h2></div></div></div><p>The GeoRSS demonstrated in the previous section is sufficient for most needs and is likely the most common encoding you'll run across. Understanding its shortcomings and recognizing other ways of representing location data is important, however.</p><p><span class="emphasis"><em>GML</em></span> is the <span class="emphasis"><em>Geography Markup Language</em></span> and is a superset of GeoRSS. GML was created to express any form of geographic information, including topology and coordinate systems other than the latitude/longitude system we've been using (called WGS84).</p><p>To make your GeoRSS compatible with GML, you need additional tags. For example, the single tag required to declare a point becomes three tags:</p><a id="I_programlisting8_d1e9467"/><pre class="programlisting">&lt;georss:where&gt;
  &lt;gml:Point&gt;
    &lt;gml:pos&gt;45.256 −71.92&lt;/gml:pos&gt;
  &lt;/gml:Point&gt;
&lt;/georss:where&gt;</pre><p>The data communicated with these tags is the same as the simple GeoRSS example. The additional tags are not extraneous, but included because GML allows for more specific uses. For example, the <code class="literal">&lt;gml:Point&gt;</code> tag is where you would declare another coordinate system.</p><p>GML equivalents of the geometric objects used in the simple GeoRSS are available. The method for polygons, lines, and boxes is similar to points. The GML code is wrapped in <code class="literal">&lt;georss:where&gt;</code> tags. You can find out more about all the options at <a class="ulink" href="http://www.georss.org/gml">http://www.georss.org/gml</a>.</p><p>Whenever you write XML that includes tags with a colon in the name, you'll need to make sure the word before the colon (the namespace) is declared at the top of your XML. Because this example uses both GeoRSS and GML, we need to include both namespaces:</p><a id="I_programlisting8_d1e9483"/><pre class="programlisting">
</pre><p>Add this code inside the root tag of your XML. For RSS, the root is <code class="literal">&lt;rss&gt;</code>, and for Atom, it is <code class="literal">&lt;feed&gt;</code>. Both are necessary because the GML version of GeoRSS uses <code class="literal">georss:</code> and <code class="literal">gml:</code> tags.</p><p>The two forms of GeoRSS shown so far are the most likely encoding methods you'll run into with new data feeds. An old version is still in somewhat wide use, however.<a id="IDX-CHP-8-0063" class="indexterm"/><a id="IDX-CHP-8-0064" class="indexterm"/></p><p>The Basic Geo Vocabulary is an encoding developed by the Worldwide Web Consortium (W3C), an organization that watches over the development of HTML and CSS, among other standards. The development of GeoRSS made the W3C's geo-tags obsolete, but you'll run into them often enough to need to recognize them.<a id="IDX-CHP-8-0065" class="indexterm"/></p><a id="I_programlisting8_d1e9515"/><pre class="programlisting">&lt;geo:lat&gt;55.701&lt;/geo:lat&gt;
&lt;geo:long&gt;12.552&lt;/geo:long&gt;</pre><p>The biggest difference between the W3C geo-tags and the ones shown earlier is that the latitude and longitude is declared separately. Because this encoding is popular, this method is yet another allowed to write GeoRSS. You'll need a different namespace to be able to use the <code class="literal">geo:</code> tags, however:</p><a id="I_programlisting8_d1e9522"/><pre class="programlisting"/><p>Now that you know about the many encodings of GeoRSS, let's see how to use GeoRSS directly with your map.</p></div><div class="sect2" title="Display GeoRSS on a Map"><div class="titlepage"><div><div><h2 class="title"><a id="display_georss_on_a_map"/>Display GeoRSS on a Map</h2></div></div></div><p>Mapstraction makes adding GeoRSS to your map easy. Through a single function, you can layer the GeoRSS without having to parse the XML yourself.<a id="IDX-CHP-8-0066" class="indexterm"/></p><p>To display GeoRSS, all you need is a publicly accessible feed and a map on which to display it. Toss these lines into a new HTML file to see GeoRSS in action:</p><a id="I_programlisting8_d1e9538"/><pre class="programlisting">&lt;html &gt;
    &lt;head&gt;
      &lt;title&gt;Example GeoRSS Map&lt;/title&gt;
      &lt;script src="<em class="replaceable"><code>http://maps.google.com/maps/api/js?</code></em>
<em class="replaceable"><code>sensor=false</code></em>" type="text/javascript"&gt;&lt;/script&gt;
      &lt;script src="mxn.js?(googlev3)"&gt;&lt;/script&gt;
      &lt;style&gt;
      div#mymap {
        width: 550px;
        height: 450px;
      }
      &lt;/style&gt;
      &lt;script type="text/javascript"&gt;
      var mapstraction;
      function create_map() {
        mapstraction = new Mapstraction('mymap', 'google');
        <strong class="userinput"><code>mapstraction.addOverlay(</code></strong>
❶         <strong class="userinput"><code>"http://mapscripting.com/example-georss.xml", ❷true);</code></strong>
      }
      &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="create_map()"&gt;
      &lt;div id="mymap"&gt;&lt;/div&gt;
    &lt;/body&gt;
  &lt;/html&gt;</pre><p>Most of this is standard map code; the important lines are in bold. You can see we use Mapstraction's <code class="literal">addOverlay</code> function. The first argument is the GeoRSS URL ❶. This address must be available on the public Web, not on your local computer or a password-protected development server. The reason the feed has to be accessible is the underlying mapping provider will make an Ajax call to load the feed. The mapping provider can't make the call if it can't access the URL. If you don't have your own feed, you can use my example from the companion website.<a id="IDX-CHP-8-0067" class="indexterm"/><a id="IDX-CHP-8-0068" class="indexterm"/><a id="IDX-CHP-8-0069" class="indexterm"/><a id="IDX-CHP-8-0070" class="indexterm"/><a id="IDX-CHP-8-0071" class="indexterm"/></p><p>The second argument ❷ is optional. This argument is a boolean, meaning the value is either <code class="literal">true</code> or <code class="literal">false</code>. It controls whether the map is auto-centered and zoomed in to show only the GeoRSS content.</p><p>Load the previous HTML into your browser, and you should see the GeoRSS content on your map. If you're using my example, you'll see routes across several Portland bridges, plus markers that identify landmarks.</p><p>Now you're a little more familiar with the GeoRSS format and its trio of encodings. In this section, I've shown how they can be used in RSS and Atom, the two most popular web feed formats. Also, you've learned how, in one line of Mapstraction code, to layer your GeoRSS feed on your map. To see an example of digging into GeoRSS, read <a class="xref" href="ch10s03.html" title="#70: Display Recent Earthquakes Worldwide">#70: Display Recent Earthquakes Worldwide</a> in <a class="xref" href="ch10s03.html" title="#70: Display Recent Earthquakes Worldwide">#70: Display Recent Earthquakes Worldwide</a>.</p></div></div>
<div class="sect1" title="#55: Use KML"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_55_colon_use_kml"/>#55: Use KML</h1></div></div></div><p>Google Earth, a three-dimensional geographic browser, popularized KML as a language to share geo-data. The acronym <span class="emphasis"><em>KML</em></span> stands for <span class="emphasis"><em>Keyhole Markup Language</em></span>, named after the company (acquired by Google) who invented it. Nevertheless, KML is an open standard based on XML. KML stores single locations, lists of points, and polygon shapes, among other features. The biggest factor that separates KML from other geographic data formats is that KML can also include styling information, so you can stipulate the color of lines or use custom marker icons.<a id="IDX-CHP-8-0072" class="indexterm"/></p><p>KML has a special schema, meaning elements are declared in a specific way.</p><p>Here's a very basic KML file, containing one location, called a <span class="emphasis"><em>Placemark</em></span>:</p><a id="I_programlisting8_d1e9611"/><pre class="programlisting">❶ &lt;?xml version="1.0" encoding="UTF-8"?&gt;
❷ &lt;kml &gt;
  &lt;Document&gt;
❸   &lt;Placemark&gt;
❹     &lt;name&gt;Eiffel Tower&lt;/name&gt;
❺     &lt;description&gt;The most recognizable place in Paris&lt;/description&gt;
      &lt;Point&gt;
❻       &lt;coordinates&gt;2.29293460923931,48.85819570061303,0&lt;/coordinates&gt;
      &lt;/Point&gt;
    &lt;/Placemark&gt;
  &lt;/Document&gt;
  &lt;/kml&gt;</pre><p>As you put your KML files together, you can view them in Google Earth or on the Google Maps website, as long as the KML is accessible on the web. Try viewing this example at <a class="ulink" href="http://maps.google.com/?q=http%3A//mapscripting.com/example.kml">http://maps.google.com/?q=http%3A//mapscripting.com/example.kml</a>.<a id="IDX-CHP-8-0073" class="indexterm"/><a id="IDX-CHP-8-0074" class="indexterm"/><a id="IDX-CHP-8-0075" class="indexterm"/><a id="IDX-CHP-8-0076" class="indexterm"/></p><p>Now let's examine what's inside that example KML file. As with every XML file, a KML file starts with the XML declaration ❶. Then the file points to the KML namespace ❷ to clearly specify we're speaking a particular XML language. With those technical bits out of the way, we can dive into the actual KML content.</p><p>The geographic data in a KML file all falls within the <code class="literal">&lt;Document&gt;</code> tag. Inside that, I add a <code class="literal">Placemark</code> ❸, which will contain location and other data for a single place. Each Placemark has a name ❹, which is essentially the equivalent of a title in GeoRSS. Similarly, each Placemark also has a description ❺, which can be plain text (as shown) or HTML (with <code class="literal">&lt;</code> and <code class="literal">&gt;</code> brackets written as <code class="literal">&amp;lt;</code> and <code class="literal">&amp;gt;</code>).</p><p>Arguably the most important piece of data for a Placemark is the actual geographic point. To declare this, we use a <code class="literal">&lt;Point&gt;</code> tag and then include the coordinates ❻ within it. Note we include three numbers, as opposed to the usual two. The last number represents altitude and is actually optional. We could increase the number, for example, if we wanted our Placemark to declare the top of the Eiffel Tower.</p><p>One final, important note about the first two coordinates: Unlike most other geographic data formats, <span class="emphasis"><em>KML lists longitude before latitude</em></span>. This setup is easy to recognize in examples like this and in North America, where longitudes are always negative. But you definitely want to make sure you get these numbers in the right order.</p><p>A document generally contains multiple Placemarks, but in this simple example, I only use one. Adding another is easy—just include an additional pair of <code class="literal">&lt;Placemark&gt;</code> tags.</p><p>Now that you've seen a simple location, let's look at some other ways KML marks up geographic data.</p><div class="sect2" title="Lines in KML"><div class="titlepage"><div><div><h2 class="title"><a id="lines_in_kml"/>Lines in KML</h2></div></div></div><p>The single point is the basic feature of geographic data—and that holds for KML, as well. Sometimes a point isn't the best way to describe a place. What single point represents a country or a city? A single point can't; you need many points. This is where lines and polygons become useful.</p><p>Rather than use a different tag, KML declares both lines and polygons as Placemarks. Unlike the ones shown previously, these Placemarks do not contain a <code class="literal">&lt;Point&gt;</code> tag because we're actually declaring multiple points at once to represent a single place.</p><p>Consider this example, which shows the path of the Golden Gate Bridge in San Francisco:<a id="IDX-CHP-8-0077" class="indexterm"/></p><a id="I_programlisting8_d1e9689"/><pre class="programlisting">&lt;Placemark&gt;
    &lt;name&gt;Golden Gate Bridge&lt;/name&gt;
    &lt;description&gt;A San Francisco landmark, for sure.&lt;/description&gt;
❶   &lt;LineString&gt;
❷     &lt;coordinates&gt;
❸       −122.479485,37.827675,0
        −122.477562,37.811028,0
      &lt;/coordinates&gt;
    &lt;/LineString&gt;
  &lt;/Placemark&gt;</pre><p>I've omitted the tags that declare this a KML document and instead focused on the Placemark. I include a name and description, just as in the single point example. To describe the bridge, we first add some KML to say this Placemark is a line ❶, and then we insert a series of coordinates ❷ to describe the line.</p><p>Of course, a bridge has two ends, so the line is a very simple one using two points. If this were a more advanced line, such as describing a trail or the route of a race, we would just continue adding coordinates in an order such that they could later be connected by line segments.</p><p>As in the single point example, we declare three coordinates ❸, listed in longitude, latitude, and altitude order. The altitude is optional, but this coordinate may provide interesting data in some cases, showing the gradient of a trail, for example. This data is hard to show on a two-dimensional web map, but remember KML data is used in other ways, such as in Google Earth.</p></div><div class="sect2" title="Polygons in KML"><div class="titlepage"><div><div><h2 class="title"><a id="polygons_in_kml"/>Polygons in KML</h2></div></div></div><p>You may recall that in GeoRSS, as well as Mapstraction, a polygon is simply a line that ends at the same point where it begins. The same is true in KML, though the definition can also get a little more advanced with its description of a shape.<a id="IDX-CHP-8-0078" class="indexterm"/></p><p>Let's stick with something simple here and continue with the world landmark theme. Consider this bit of KML that describes the outer edges of the Parthenon in Greece:</p><a id="I_programlisting8_d1e9709"/><pre class="programlisting">&lt;Placemark&gt;
    &lt;name&gt;Parthenon&lt;/name&gt;
    &lt;description&gt;A symbol of ancient Greece.&lt;/description&gt;
❶   &lt;Polygon&gt;
❷     &lt;outerBoundaryIs&gt;
❸       &lt;LinearRing&gt;
        &lt;coordinates&gt;
          23.726295,37.971539,0
          23.726376,37.971287,0
          23.727116,37.971420,0
          23.727024,37.971672,0
          23.726295,37.971539,0
        &lt;/coordinates&gt;
      &lt;/LinearRing&gt;
    &lt;/outerBoundaryIs&gt;
  &lt;/Polygon&gt;
&lt;/Placemark&gt;</pre><p>Notice that inside the polygon declaration ❶ I've include several levels of tags before getting to the familiar coordinates list. The reason for those additional levels is that KML's polygons are much more powerful than this example can communicate.<a id="IDX-CHP-8-0079" class="indexterm"/><a id="IDX-CHP-8-0080" class="indexterm"/><a id="IDX-CHP-8-0081" class="indexterm"/><a id="IDX-CHP-8-0082" class="indexterm"/></p><p>For example, here I've declared an outer boundary ❷ for the Parthenon, meaning I'm describing the outside walls. If I also use an inner boundary, I can create a rectangular donut to show just the columns of the Parthenon.</p><p>Inside a boundary, I use a linear ring ❸ to tell KML that I am creating a line that ends at its starting point. Here KML's polygon begins to look similar to GeoRSS, but with different syntax.</p><p>As with the simple line example, the coordinates are a list of longitude, latitude, and altitude (optional) values. We have four corners of the Parthenon to connect, which requires five points. Why not four? The first and the last must be identical—to complete the ring.</p><p>Now that you understand basic Placemarks, including lines and polygons, let's see where KML diverges from other geographic data formats: let's get stylish.</p></div><div class="sect2" title="Style KML"><div class="titlepage"><div><div><h2 class="title"><a id="style_kml"/>Style KML</h2></div></div></div><p>Describing points, lines, and shapes is a basic building block of communicating geography. You can put these three types of data together and get plenty of information about a place. KML also lets you describe how you want the data to look, which separates it from other formats. Read on to learn how to style your KML.</p><p>If you know how HTML and CSS interact, KML styles will seem familiar. As with HTML, you can create styles inline or reference them globally with declarations at the top of your KML file.<a id="IDX-CHP-8-0083" class="indexterm"/></p><p>A style tag is available for each of the three types of geographic data we've seen so far: <code class="literal">&lt;IconStyle&gt;</code>, <code class="literal">&lt;LineStyle&gt;</code>, and <code class="literal">&lt;PolyStyle&gt;</code>. Within the tag, you can declare an icon graphic, color, line width, and opacity. Here's an example of styles added inside the Eiffel Tower Placemark:</p><a id="I_programlisting8_d1e9756"/><pre class="programlisting">&lt;Style&gt;
  &lt;IconStyle&gt;
    &lt;Icon&gt;
      &lt;href&gt;http://mapscripting.com/icons/modernmonument.png&lt;/href&gt;
    &lt;/Icon&gt;
  &lt;/IconStyle&gt;
&lt;/Style&gt;</pre><p>This code is the KML equivalent of <a class="xref" href="ch02s05.html" title="#5: Create a Custom Icon Marker">#5: Create a Custom Icon Marker</a> in <a class="xref" href="ch02s04.html" title="#4: Show and Hide Message Boxes Without Clicking the Marker">#4: Show and Hide Message Boxes Without Clicking the Marker</a>. However, if you have a document with many points, you could end up with a lot of redundancy if most points share the same marker graphic, which makes declaring styles at the top of the code useful.</p><p>You can move the entire <code class="literal">&lt;Style&gt;</code> block up, as an immediate child of the <code class="literal">&lt;Document&gt;</code> tag. Then, if you give the tag an <code class="literal">id</code> attribute, you can reference it below. For example, here is the Parthenon example filled in with white:</p><a id="I_programlisting8_d1e9775"/><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;kml &gt;
  &lt;Document&gt;
    <strong class="userinput"><code>&lt;Style id="stoneBuilding"&gt;</code></strong>
      <strong class="userinput"><code>&lt;LineStyle&gt;</code></strong>
❶       <strong class="userinput"><code>&lt;color&gt;cccccc&lt;/color&gt;</code></strong>
      <strong class="userinput"><code>&lt;/LineStyle&gt;</code></strong>
      <strong class="userinput"><code>&lt;PolyStyle&gt;</code></strong>
        <strong class="userinput"><code>&lt;color&gt;ffffff&lt;/color&gt;</code></strong>
        <strong class="userinput"><code>&lt;fill&gt;1&lt;/fill&gt;</code></strong>
❷       <strong class="userinput"><code>&lt;outline&gt;1&lt;/outline&gt;</code></strong>
      <strong class="userinput"><code>&lt;/PolyStyle&gt;</code></strong>
    <strong class="userinput"><code>&lt;/Style&gt;</code></strong>
    &lt;Placemark&gt;
      &lt;name&gt;Parthenon&lt;/name&gt;
      &lt;description&gt;A symbol of ancient Greece.&lt;/description&gt;
❸     <strong class="userinput"><code>&lt;styleUrl&gt;#stoneBuilding&lt;/styleUrl&gt;</code></strong>
      &lt;Polygon&gt;
        &lt;outerBoundaryIs&gt;
          &lt;LinearRing&gt;
            &lt;coordinates&gt;
              23.726295,37.971539,0
              23.726376,37.971287,0
              23.727116,37.971420,0
              23.727024,37.971672,0
              23.726295,37.971539,0
            &lt;/coordinates&gt;
          &lt;/LinearRing&gt;
        &lt;/outerBoundaryIs&gt;
      &lt;/Polygon&gt;
    &lt;/Placemark&gt;
  &lt;/Document&gt;
  &lt;/kml&gt;</pre><p>The portion of the KML that produces the style is in bold. As you can see, most of the styling is already declared by the time we get to the Placemark. Along with the white-shaded polygon, I add a <code class="literal">LineStyle</code> to give it a light gray outline ❶. Then, I also make sure the <code class="literal">PolyStyle</code> has outlines turned on ❷ via the boolean (<code class="literal">1</code> is on; <code class="literal">0</code> is off).<a id="IDX-CHP-8-0084" class="indexterm"/><a id="IDX-CHP-8-0085" class="indexterm"/></p><p>Finally, we reference the styles ❸ from the Placemark itself. This reference is created much like a reference to an <code class="literal">id</code> within CSS, by prepending a <code class="literal">#</code> in front of the style <code class="literal">id</code>.</p></div><div class="sect2" title="Display KML on a Map"><div class="titlepage"><div><div><h2 class="title"><a id="display_kml_on_a_map"/>Display KML on a Map</h2></div></div></div><p>With your KML file on the Web, you can display it on a map in many ways. Earlier, I showed how you can use the Google Maps website to show KML. You can also open it in Google Earth. In this section, we'll see instead how to layer a KML file into your embedded map using Mapstraction.</p><p>Start with a brand-new HTML file and add the following code:</p><a id="I_programlisting8_d1e9851"/><pre class="programlisting">&lt;html &gt;
    &lt;head&gt;
      &lt;title&gt;Example KML Map&lt;/title&gt;
      &lt;script src="<em class="replaceable"><code>http://maps.google.com/maps/api/js?sensor=false</code></em>"
 type="text/javascript"&gt;&lt;/script&gt;
      &lt;script src="mxn.js?(googlev3)"&gt;&lt;/script&gt;
      &lt;style&gt;
      div#mymap {
        width: 550px;
        height: 450px;
      }
      &lt;/style&gt;
      &lt;script type="text/javascript"&gt;
      var mapstraction;
      function create_map() {
        mapstraction = new Mapstraction('mymap', 'google');
        <strong class="userinput"><code>mapstraction.addOverlay(</code></strong>
❶         <strong class="userinput"><code>"http://mapscripting.com/example.kml",</code></strong> ❷<strong class="userinput"><code>true</code></strong>);
      }
      &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="create_map()"&gt;
      &lt;div id="mymap"&gt;&lt;/div&gt;
    &lt;/body&gt;
  &lt;/html&gt;</pre><p>Most of this is a pretty basic map. The part that loads the KML file is in bold. Just like for the GeoRSS, we use Mapstraction's <code class="literal">addOverlay</code> function. The first argument is the KML URL ❶. As I've mentioned, this address needs to be available on the public Web, not on your local computer or a password-protected development server. The reason the feed has to be accessible is the underlying mapping provider will make an Ajax call to load the feed. This call won't work if the provider can't access the URL. If you don't have your own feed, you can use my example from the companion website.</p><p>The second argument ❷, which is optional, is a boolean, meaning the value is either <code class="literal">true</code> or <code class="literal">false</code>. This controls whether the map is auto-centered and zoomed in to show only the KML content.</p><p>Load this HTML into your browser and you should see the KML content on your map. If you're using my example, you'll see a polyline surrounding the Parthenon.</p></div></div>
<div class="sect1" title="#56: Use GPX"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_56_colon_use_gpx"/>#56: Use GPX</h1></div></div></div><p>Are you a hiker, a runner, or a mountain biker? You could use the GPS exchange format, GPX, to track your favorite trails and routes. Most modern GPS devices, which use satellites to triangulate their location, can store this data and output it in GPX format. Even if the data did not originate on a GPS device, this format is useful for sharing any sequence of latitude and longitude points.<a id="IDX-CHP-8-0086" class="indexterm"/><a id="IDX-CHP-8-0087" class="indexterm"/><a id="IDX-CHP-8-0088" class="indexterm"/></p><p>GPX really is just another way to store <span class="emphasis"><em>polylines</em></span>, a series of coordinates to connect on a map. Where the format is different is that it also contains useful metadata to make more sense of the dozens of points.</p><p>GPX is separated into three types of data:</p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="strong"><strong>Tracks</strong></span> A record of a particular trip, including the time at each step</td></tr><tr><td><span class="strong"><strong>Routes</strong></span> A suggested trip meant to be shared with others, which does not include time information</td></tr><tr><td><span class="strong"><strong>Waypoints</strong></span> A single point, often used for landmarks or other points of interest</td></tr></table><p>From a technical standpoint, GPX is just XML. Its schema is special, however, and elements are declared in a specific way. Here is an example GPX file:</p><a id="I_programlisting8_d1e9920"/><pre class="programlisting">❶ &lt;?xml version="1.0" encoding="UTF-8"?&gt;
❷ &lt;gpx version="1.0" xmlns:xsi="http://www.w3.org/2001
/XMLSchema-instance" xmlns="http://
  www.topografix.com/GPX/1/0" xsi:schemaLocation="http://www.to
pografix.com/GPX/1/0 http://www
  .topografix.com/GPX/1/0/gpx.xsd"&gt;

    &lt;trk&gt;
      &lt;name&gt;Dog Walk&lt;/name&gt;
❸     &lt;trkseg&gt;
❹       &lt;trkpt lat="45.521270" lon="-122.626111"&gt;
❺         &lt;ele&gt;7.125&lt;/ele&gt;
❻         &lt;time&gt;2010-09-06T00:14:34Z&lt;/time&gt;
        &lt;/trkpt&gt;
        &lt;trkpt lat="45.521292" lon="-122.625950"&gt;
          &lt;ele&gt;6.831&lt;/ele&gt;
          &lt;time&gt;2010-09-06T00:14:37Z&lt;/time&gt;
        &lt;/trkpt&gt;
        ...
      &lt;/trkseg&gt;
    &lt;/trk&gt;

  &lt;/gpx&gt;</pre><p>Most XML files begin in a similar way ❶ to show they contain XML. Then the code points to the GPX schema ❷. With the formalities out of the way, let's dive into the actual data.</p><p>This example is showing a track, so we begin by wrapping everything in a <code class="literal">&lt;trk&gt;</code> tag. A track has at least one segment ❸, which contains the individual track points ❹. The latitude and longitude are stored as attributes of the <code class="literal">&lt;trkpt&gt;</code> tag, with the elevation ❺ and timestamp ❻ as subelements.<a id="IDX-CHP-8-0089" class="indexterm"/><a id="IDX-CHP-8-0090" class="indexterm"/><a id="IDX-CHP-8-0091" class="indexterm"/><a id="IDX-CHP-8-0092" class="indexterm"/><a id="IDX-CHP-8-0093" class="indexterm"/></p><p>A program going through the track points uses differences in the latitude and longitude to determine the distance between points. Similarly, the number of seconds or minutes between timestamps can be used to determine the approximate speed. The elevation numbers can determine the trail's grade. We can learn a lot from the metadata.</p><div class="sect2" title="Examples of GPX"><div class="titlepage"><div><div><h2 class="title"><a id="examples_of_gpx"/>Examples of GPX</h2></div></div></div><p>In addition to trail enthusiasts plotting and sharing their escapades, GPX has other even more useful applications. GPX is bringing geographic data that wasn't included before to rich content like photos and video. A world of volunteer cartographers also use it to map streets and cities.</p><p>Walking around snapping shots is something most photographers do with regularity, whether hiking through nature or walking urban streets. By synchronizing the internal times on a GPS and camera, you can get latitude and longitude coordinates for your photos.</p><p>Digital cameras usually timestamp each photo. If you have a record of a path, like the one stored in a GPX file, cross-referencing the two is straightforward. Just find the track point with a timestamp closest to the photo's. Update the photo metadata to include the coordinates, and you have now geo-tagged the photo. You can install many programs on your computer that will do this for you.</p><p>OpenStreetMap uses GPX to map the world. It sends volunteers to walk the streets with GPS units. Then, the track points, along with other information like street names, are used to create maps that are available for anyone—without licensing fees.<a id="IDX-CHP-8-0094" class="indexterm"/><a id="IDX-CHP-8-0095" class="indexterm"/></p><p>In many countries, such as the United States, much of this street data is already available. OpenStreetMap volunteers, in these cases, are checking accuracy and filling in what's missing. In some places, OpenStreetMap is all there is, so the GPX tracks become incredibly important to the project.</p></div><div class="sect2" title="Display GPX Tracks on a Map"><div class="titlepage"><div><div><h2 class="title"><a id="display_gpx_tracks_on_a_map"/>Display GPX Tracks on a Map</h2></div></div></div><p>Once you have a GPX file, you'll want to do something with it, like show it on a map. Getting at the track points requires parsing the XML and then "connecting the dots" with polylines in Mapstraction.</p><p>XML parsing can be painful. I discussed it in detail in the earlier in this chapter. We'll use the jQuery method here, which is as easy as it gets, but it does require a small JavaScript library.</p><p>To start, let's lay the groundwork for the GPX map by preparing the basic HTML, CSS, and JavaScript to display a simple map. Put this code into a new HTML file:<a id="IDX-CHP-8-0096" class="indexterm"/><a id="IDX-CHP-8-0097" class="indexterm"/><a id="IDX-CHP-8-0098" class="indexterm"/></p><a id="I_programlisting8_d1e9993"/><pre class="programlisting">&lt;html &gt;
  &lt;head&gt;
    &lt;title&gt;GPX on a Map&lt;/title&gt;
    &lt;script src="<em class="replaceable"><code>http://maps.google.com/maps/api/js?sensor=false</code></em>"
 type="text/javascript"&gt;&lt;/script&gt;
❶   &lt;script src="http://ajax.googleapis.com/ajax/libs/
jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="mxn.js?(googlev3)"&gt;&lt;/script&gt;
    &lt;style&gt;
      div#mymap {
        width: 600px;
        height: 450px;
      }
    &lt;/style&gt;
    &lt;script type="text/javascript"&gt;
    var mapstraction;
    function create_map() {
      mapstraction = new Mapstraction('mymap', 'google');
❷     mapstraction.setCenterAndZoom(new LatLonPoint(0,0), 2);
      mapstraction.addControls({"zoom": "large"});
❸     parse_gpx("gpxfile.gpx");
    }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="create_map()"&gt;
    &lt;div id="mymap"&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;/html&gt;</pre><p>We haven't quite parsed the GPX yet. This code just prepares a basic map. Make sure you include your Google Maps API key. Otherwise, everything is ready to go. Before moving on, however, I'd like to point out a few bits.</p><p>First, I've included the jQuery JavaScript framework ❶. We'll use it for the Ajax call that will download the GPX file. Also, jQuery makes XML parsing easier, so we'll use it to get at the GPX data.</p><p>The eventual location for the map will be determined by the latitude and longitude values inside the GPX file. Because we don't know what those are yet, I centered the map in the middle of the globe ❷. Assuming we're able to load data, that location will only stay for a short time. If you know what city the data will be in, a good practice is to use the coordinates of the city center.</p><p>Finally, I make a call to the <code class="literal">parse_gpx</code> function ❸, passing a filename. Make sure <span class="emphasis"><em>gpxfile.gpx</em></span> exists in the same directory and has some GPX data. You can find example files at <a class="ulink" href="http://mapscripting.com/gpx-files">http://mapscripting.com/gpx-files</a>.</p><p>But wait . . . where is the <code class="literal">parse_gpx</code> function? We haven't added it yet, so let's write it! Add these lines below the <code class="literal">create_map</code> function:</p><a id="I_programlisting8_d1e10022"/><pre class="programlisting">function parse_gpx(filename) {
❶   jQuery.get(filename, {}, function(xmltxt) {
      var pdata = {"color": "blue"};
      var pts = [];
❷     jQuery("trkpt", xmltxt).each(function(i) {
        var lat = ❸parseFloat($(this).attr("lat"));
        var lon = parseFloat($(this).attr("lon"));
❹       var thispt = new LatLonPoint(lat, lon);
❺       pts.push(thispt);
      });
❻     mapstraction.addPolylineWithData(new Polyline(pts, pdata));
❼     mapstraction.autoCenterAndZoom();
    });
  }</pre><p>The <code class="literal">parse_gpx</code> function is really just a wrapper for the jQuery Ajax call ❶. It grabs the passed filename and returns the XML results to an anonymous, inline function. This is where the real stuff happens. You can see how one of my GPX files looks when added to the map in <a class="xref" href="ch08s05.html#example_gpx_tracks_from_a_walk_in_the_pa" title="Figure 8-1. Example GPX tracks from a walk in the park">Figure 8-1</a>.</p><div class="figure"><a id="example_gpx_tracks_from_a_walk_in_the_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e10035"/><img src="httpatomoreillycomsourcenostarchimages672079.png.jpg" alt="Example GPX tracks from a walk in the park"/></div></div><p class="title">Figure 8-1. Example GPX tracks from a walk in the park</p></div><p>After creating a few variables, the function uses jQuery to look for every <code class="literal">&lt;trkpt&gt;</code> in the GPX file ❷. For each track point, it calls yet another anonymous function, which is sort of equivalent to a <code class="literal">for</code> loop. Each time through the loop, the function parses the latitude and longitude of the current track point.<a id="IDX-CHP-8-0099" class="indexterm"/><a id="IDX-CHP-8-0100" class="indexterm"/><a id="IDX-CHP-8-0101" class="indexterm"/><a id="IDX-CHP-8-0102" class="indexterm"/></p><p>The <code class="literal">parseFloat</code> JavaScript function ❸ takes the text from the GPX file and turns it into the decimal number (also called a <span class="emphasis"><em>floating point number</em></span>) needed. Again, the function uses jQuery to parse the GPX, but it uses the shorthand dollar sign method.</p><p>Before we draw the track on the map, we need to have all the data points to pass to Mapstraction at the same time, as shown in <a class="xref" href="ch04.html#number_symble_16_colon_draw_lines_on" title="#16: Draw Lines on a Map">#16: Draw Lines on a Map</a> in <a class="xref" href="ch04.html#number_symble_16_colon_draw_lines_on" title="#16: Draw Lines on a Map">#16: Draw Lines on a Map</a>. We'll use an array to collect the points. Once we have the latitude and longitude of the current track point, we create a <code class="literal">LatLonPoint</code> with the two values ❹. Then we add the point to the <code class="literal">pts</code> array ❺.</p><p>Once we're outside the loop, we pass our data to draw the Polyline ❻ and then zoom the map automatically to show our entire Polyline ❼. Now we have, in the case of most tracks, a tight view of the GPX data.</p></div></div>
<div class="sect1" title="#57: Convert from XML to JSON"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_57_colon_convert_from_xml"/>#57: Convert from XML to JSON</h1></div></div></div><p>As I've mentioned, XML is not always the easiest format to use with JavaScript. Yet, as this chapter has shown, most of the formats you'll be working with are flavors of XML. By now you probably prefer JSON, right? To make things easier on the JavaScript, we'll need to do a little extra work and convert from XML to JSON.<a id="IDX-CHP-8-0103" class="indexterm"/></p><p>A number of ways are available for getting our data from XML to JSON. And really, the conversion is not that difficult an operation. For example, once we load either XML or JSON into PHP, the data is very similar. In this section, I'll show how you can convert on your own server and also introduce you to a nifty service from Yahoo! called Pipes.</p><div class="sect2" title="Convert Using PHP"><div class="titlepage"><div><div><h2 class="title"><a id="convert_using_php"/>Convert Using PHP</h2></div></div></div><p>Most Unix or Linux servers have a copy of PHP already running, which makes it a great server-side language to learn. We'll use PHP to read in and parse some XML and then turn around and encode it into JSON. The whole process takes just a few lines, thanks to helper functions included in PHP 5.</p><p>Even if you don't have a server, or PHP is not accessible, you can likely install it on your own machine. For a more in-depth discussion of PHP, you'll want to check out <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a>.</p><p>To start converting, create a new PHP file and add these lines:<a id="IDX-CHP-8-0104" class="indexterm"/></p><a id="I_programlisting8_d1e10117"/><pre class="programlisting">&lt;?
  $xmltxt = ❶get_url("http://mapscripting.com/example.xml");
❷ $xmlobj = simplexml_load_string($xmltxt);
  $jtxt = ❸json_encode($xmlobj);
  print $jtxt;
  ?&gt;</pre><p>Like I said, this code isn't very complicated, is it? To get the XML text, I use a helper function ❶ I wrote, which is explained in <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a> in <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a>. You could also read in the file directly, as we did when parsing XML with PHP.</p><p>Once we have the XML text, we convert it first to a PHP object ❷. This parses the hierarchy of the XML file into a format PHP can understand directly. Because JSON is so close to data structures found within PHP, a simple call ❸ is all that's needed to encode the JSON. Then we print it and voilà —we have converted data formats.</p></div><div class="sect2" title="Convert Using Yahoo! Pipes"><div class="titlepage"><div><div><h2 class="title"><a id="convert_using_yahoo_exclamation_pipes"/>Convert Using Yahoo! Pipes</h2></div></div></div><p>Don't have server-side chops, or just don't want to deal with additional code? Many folks are turning to a service from Yahoo! called Pipes. Pipes reads in various data formats, lets you massage the data if you want, and then outputs it as either XML or JSON.</p><p>Why use Yahoo! Pipes instead of your own server? For one, the conversion process is even easier than using PHP. Plus, no code is required because Pipes has a graphical, drag-and-drop interface. You also get the benefit of Yahoo!'s infrastructure. Yahoo! decides how often to check for new content and deals with caching the most recent copy—something we didn't do at all in the PHP example.<a id="IDX-CHP-8-0105" class="indexterm"/></p><p>The downside to relying on Pipes? It introduces another point of failure. Even if your server is humming along, your map might not work if Pipes crashes. Although you can likely count on Yahoo! for uptime, what if the company decides the Pipes product isn't worth keeping around? You'd be hung out to dry.</p><p>To me, the ease of using Pipes outweighs the detractions. Let's see just how easy converting from XML to JSON with Pipes is.</p><p>You'll need a Yahoo! account to store your Pipes. Log in at <a class="ulink" href="http://pipes.yahoo.com/pipes">http://pipes.yahoo.com/pipes</a> and click <span class="strong"><strong>Create a Pipe</strong></span> to go to a blank canvas, with options on the left. First, Pipes requires a data source, so drag a Fetch Feed source on to the canvas. Paste your feed URL into the box, or use <a class="ulink" href="http://mapscripting.com/example.xml">http://mapscripting.com/example.xml</a>.</p><p>Now a second box called Pipe Output should also appear at the bottom of the workspace. Drag the circle at the bottom of the Fetch Feed box to the circle at the top of the Pipe Output. This connects the elements to create a complete Pipe, as shown in <a class="xref" href="ch08s06.html#yahoo_exclamation_pipes_feed_connected" title="Figure 8-2. Yahoo! Pipes feed connected">Figure 8-2</a>. Go ahead and try it and you should see sample output in the debugger at the bottom of the workspace.<a id="IDX-CHP-8-0106" class="indexterm"/></p><div class="figure"><a id="yahoo_exclamation_pipes_feed_connected"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e10162"/><img src="httpatomoreillycomsourcenostarchimages672081.png.jpg" alt="Yahoo! Pipes feed connected"/></div></div><p class="title">Figure 8-2. Yahoo! Pipes feed connected</p></div><p>Here's where things get really interesting: <span class="emphasis"><em>You're done</em></span>. Save the Pipe, and then click <span class="strong"><strong>Run Pipe</strong></span>. You should see your content within the Pipes interface. At the top of your content, you'll see a Get as JSON link. That's the URL to your converted data run through Yahoo!'s servers. Now you can order new business cards because you're a certified data plumber!</p></div></div>
<div class="sect1" title="#58: Filter, Merge, and Sort Data with Yahoo Pipes!"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_58_colon_filter_comma_merg"/>#58: Filter, Merge, and Sort Data with Yahoo Pipes!</h1></div></div></div><p>APIs and RSS feeds are becoming commonplace. So much of the Web's content is now available in a format that programmers are quickly able to use, which is great. The downside is that another problem has been created: Getting at just the right information can be tough.</p><p>Sometimes a feed is a fire hose when a garden variety hose would do. Other times you have to combine multiple sources before you get the information you really need. Yahoo! Pipes has an easy interface for solving both issues—by filtering and merging data.</p><p>Much of this data-munging is stuff programmers have been doing manually using server-side scripts. Sometimes that will still be necessary, but Yahoo! Pipes is able to solve the common scenarios. Plus, for reasons described in the previous project, offloading some of this work onto Yahoo!'s servers provides some major benefits.</p><p>Before you create a Pipe, you'll need at least one data source. This source is often an RSS feed and, for map-related projects, may be GeoRSS. A Pipe is a way to transform data sources. The data comes in the Pipe, some stuff happens, and then the data flows out of the Pipe. If you have a data source, then let's start working on that "stuff" part. You can begin by editing the Pipe we created in the previous section.<a id="IDX-CHP-8-0107" class="indexterm"/></p><div class="sect2" title="Filter Your Feed's Content"><div class="titlepage"><div><div><h2 class="title"><a id="filter_your_feed_apostrophy_s_content"/>Filter Your Feed's Content</h2></div></div></div><p>Rather than simply running our feed through Pipes, let's try filtering out certain content. To do this, we'll need to drag a Filter box from the Operators menu. You can place the box anywhere in the workspace, but placing it between the Fetch box and the Output box may make the most sense.</p><p>Next, you'll need to connect the feed to the filter. Drag the circle at the bottom of the Fetch box to the top of the Filter box. Then connect the Filter box to the Pipe Output by dragging the filter's bottom circle to the output's top circle.</p><p>Of course, the filter isn't useful unless it's actually filtering some content. You can do this two ways with Pipes: You can filter <span class="emphasis"><em>in</em></span> or filter <span class="emphasis"><em>out</em></span>. At the top of the Filter box, you can select <span class="strong"><strong>Block</strong></span> to filter out and <span class="strong"><strong>Allow</strong></span> to filter in.</p><p>Pipes can filter based on any fields in the feed. A common choice is the title, which, for RSS, is <span class="emphasis"><em>item.title</em></span>. Click the arrow next to the first text area in the filter box (see <a class="xref" href="ch08s07.html#filtering_out_items_with_map_in_the_titl" title="Figure 8-3. Filtering out items with map in the title">Figure 8-3</a>) and you'll see a list of available fields. Then you can type the words you want to filter in the second text field. The drop-down box lets you perform some basic types of filtering on the field, including greater-than/less-than for numbers.</p><div class="figure"><a id="filtering_out_items_with_map_in_the_titl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e10225"/><img src="httpatomoreillycomsourcenostarchimages672083.png.jpg" alt="Filtering out items with map in the title"/></div></div><p class="title">Figure 8-3. Filtering out items with <span class="emphasis"><em>map</em></span> in the title</p></div><p>If you want additional filters, just click the plus sign next to Rules. Otherwise, your Pipe is complete. Save it, and then click <span class="strong"><strong>Run Pipe</strong></span>. Your filtered feed will be shown within the Pipes interface. To get this new feed, choose <span class="strong"><strong>Get as RSS</strong></span> or <span class="strong"><strong>Get as JSON</strong></span>. If you are reading the feed in to use with JavaScript, JSON is probably your best choice.<a id="IDX-CHP-8-0108" class="indexterm"/><a id="IDX-CHP-8-0109" class="indexterm"/></p></div><div class="sect2" title="Merge Two or More Feeds"><div class="titlepage"><div><div><h2 class="title"><a id="merge_two_or_more_feeds"/>Merge Two or More Feeds</h2></div></div></div><p>What if you have two similar feeds that you want to combine? Pipes is very good at this! Create a new Pipe and drag two Fetch Feed boxes to the canvas (see <a class="xref" href="ch08s07.html#merging_and_sorting_two_feeds_with_yahoo" title="Figure 8-4. Merging and sorting two feeds with Yahoo! Pipes">Figure 8-4</a>). Choose two feeds (if you're short of examples, you should be able to find an RSS feed from your favorite blogs or websites) and insert their URLs into the Fetch Feed boxes.</p><div class="figure"><a id="merging_and_sorting_two_feeds_with_yahoo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e10257"/><img src="httpatomoreillycomsourcenostarchimages672085.png.jpg" alt="Merging and sorting two feeds with Yahoo! Pipes"/></div></div><p class="title">Figure 8-4. Merging and sorting two feeds with Yahoo! Pipes</p></div><p>If the feeds are of the same variety and you don't plan to filter anything, you can actually use a single Fetch Feed box. Just click the plus sign next to URL. In many cases, you'll want to have the option to perform more advanced operations, so I recommend using a Fetch Feed for each individual feed.</p><p>To combine the two feeds, we'll need a Union box from the Operators menu. Drag the Union box to the canvas below the two Fetch Feed boxes. Drag the circle below each feed to one of the five circles at the top of the Union box. Finally, drag the circle at the bottom of the Union box to the Pipe Output.</p><p>Your feeds are combined in the order they were added to the Union box (left to right). In other words, the second feed's content is only seen after the entire contents of the first feed. This arrangement is not ideal. Most likely, you usually want to see the content in the order it was published. Pipes can do the sorting for you.</p><p>Drag a Sort operator to the canvas. Connect the bottom circle of the Union box to the top of the Sort box. Then connect the bottom of the Sort box to the Pipe Output. You'll need to choose a field to sort by clicking the arrow next to the text field within the Sort box. To use the date, select <span class="strong"><strong>item.pubDate</strong></span>. Now save the Pipe and you're done.<a id="IDX-CHP-8-0110" class="indexterm"/></p><p>You've now filtered, merged, and sorted with Yahoo! Pipes. You can transform data into whatever you want it to be. In fact, if you dig through the documentation a bit (<a class="ulink" href="http://pipes.yahoo.com/pipes/">http://pipes.yahoo.com/pipes/</a>), you'll realize Pipes is even more powerful than the few examples I've shown. You can load feeds dynamically, use web services, and even extract location from text. Best of all, when you're done, the data is in a format that is easy to read in and plot on a map.</p></div></div></body></html>