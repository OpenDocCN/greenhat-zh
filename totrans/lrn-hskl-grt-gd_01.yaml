- en: Chapter 1. Starting Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re the horrible sort of person who doesn’t read introductions, you might
    want to go back and read the last section anyway—it explains how to use this book,
    as well as how to load functions with GHC.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s start GHC’s interactive mode and call some functions, so we can
    get a very basic feel for Haskell. Open a terminal and type **`ghci`**. You will
    be greeted with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GHCi’s default prompt is `Prelude>`, but we’ll be using `ghci>` as our prompt
    for the examples in this book. To make your prompt match the book’s, enter **`:set
    prompt "ghci> "`** into GHCi. If you don’t want to do this every time you run
    GHCi, create a file called *.ghci* in your home folder and set its contents to
    **`:set prompt "ghci> "`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations, you’re in GHCi! Now let’s try some simple arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802506.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we use several operators in one expression, Haskell will execute them in
    an order that takes into account the precedence of the operators. For instance,
    `*` has higher precedence than `-`, so `50 * 100 - 4999` is treated as `(50 *
    100) - 4999`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use parentheses to explicitly specify the order of operations,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pretty cool, huh? (Yeah, I know it’s not, yet, but bear with me.)
  prefs: []
  type: TYPE_NORMAL
- en: One pitfall to watch out for is negative number constants. It’s always best
    to surround these with parentheses wherever they occur in an arithmetic expression.
    For example, entering `5 * -3` will make GHCi yell at you, but entering `5 * (-3)`
    will work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean algebra is also straightforward in Haskell. Like many other programming
    languages, Haskell has the Boolean values `True` and `False`, and uses the `&&`
    operator for conjunction (Boolean *and*), the `||` operator for disjunction (Boolean
    *or*), and the `not` operator to negate a `True` or `False` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test two values for equality or inequality with the `==` and `/=` operators,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Watch out when mixing and matching values, however! If we enter something like
    `5 + "llama"`, we get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What GHCi is telling us here is that `"llama"` is not a number, so it does not
    know how to add it to 5\. The `+` operator expects both of its inputs to be numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `==` operator works on any two items that can be compared,
    with one catch: they both have to be of the same type. For instance, if we tried
    entering `True == 5`, GHCi would complain.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`5 + 4.0` is a valid expression, because although `4.0` isn’t an integer, `5`
    is sneaky and can act like either an integer or a floating-point number. In this
    case, `5` adapts to match the type of the floating-point value `4.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a closer look at types a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802508.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may not have realized it, but we’ve actually been using functions this whole
    time. For instance, `*` is a function that takes two numbers and multiplies them.
    As you’ve seen, we apply (or *call*) it by sandwiching it between the two numbers
    we want to multiply. This is called an *infix* function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most functions, however, are *prefix* functions. When calling prefix functions
    in Haskell, the function name comes first, then a space, then its parameters (also
    separated by spaces). As an example, we’ll try calling one of the most boring
    functions in Haskell, `succ`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `succ` function takes one parameter that can be anything that has a well-defined
    successor, and returns that value. The successor of an integer value is just the
    next higher number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s call two prefix functions that take multiple parameters, `min` and
    `max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `min` and `max` functions each take two parameters that can be put in some
    order (like numbers!), and they return the one that’s smaller or larger, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Function application has the highest precedence of all the operations in Haskell.
    In other words, these two statements are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This means that if we want to get the successor of `9 * 10`, we couldn’t simply
    write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because of the precedence of operations, this would evaluate as the successor
    of 9 (which is 10) multiplied by 10, yielding 100\. To get the result we want,
    we need to instead enter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This returns 91.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function takes two parameters, we can also call it as an infix function
    by surrounding its name with backticks (`` ` ``). For instance, the `div` function
    takes two integers and executes an integral division, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we call it like that, there may be some confusion as to which
    number is being divided by which. By using backticks, we can call it as an infix
    function, and suddenly it seems much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Many programmers who are used to imperative languages tend to stick to the notion
    that parentheses should denote function application, and they have trouble adjusting
    to the Haskell way of doing things. Just remember, if you see something like `bar
    (bar 3)`, it means that we’re first calling the `bar` function with `3` as the
    parameter, then passing that result to the `bar` function again. The equivalent
    expression in C would be something like `bar(bar(3))`.
  prefs: []
  type: TYPE_NORMAL
- en: Baby's First Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802510.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The syntax of a function definition is similar to that of a function call:
    the function name is followed by parameters, which are separated by spaces. But
    then the parameter list is followed by the `=` operator, and the code that makes
    up the body of the function follows that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we’ll write a simple function that takes a number and multiplies
    it by two. Open up your favorite text editor and type in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as *baby.hs*. Now run `ghci`, making sure that *baby.hs* is
    in your current directory. Once in GHCi, enter **`:l baby`** to load the file.
    Now we can play with our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because `+` works on integers as well as on floating point numbers (indeed,
    on anything that can be considered a number), our function also works with any
    of these types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make a function that takes two numbers, multiplies each by two, then
    adds them together. Append the following code to *baby.hs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions in Haskell don’t have to be defined in any particular order, so it
    doesn’t matter which function comes first in the *baby.hs* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now save the file, and enter **`:l baby`** in GHCi to load your new function.
    Testing this function yields predictable results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions that you define can also call each other. With that in mind, we could
    redefine `doubleUs` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple example of a common pattern you will see when using Haskell:
    Basic, obviously correct functions can be combined to form more complex functions.
    This is a great way to avoid code repetition. For example, what if one day mathematicians
    figure out that 2 and 3 are actually the same, and you have to change your program?
    You could just redefine `doubleMe` to be `x + x + x`, and since `doubleUs` calls
    `doubleMe`, it would now also automatically work correctly in this strange new
    world where 2 is equal to 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s write a function that multiplies a number by 2, but only if that number
    is less than or equal to 100 (because numbers bigger than 100 are big enough as
    it is!).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This example introduces Haskell’s `if` statement. You’re probably already familiar
    with if statements from other languages, but what makes Haskell’s unique is that
    the `else` part is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Programs in imperative languages are essentially a series of steps that the
    computer executes when the program is run. When there is an `if` statement that
    doesn’t have a corresponding `else`, and the condition isn’t met, then the steps
    that fall under the `if` statement don’t get executed. Thus, in imperative languages,
    an `if` statement can just do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a Haskell program is a collection of functions. Functions
    are used to transform data values into result values, and every function should
    return some value, which can in turn be used by another function. Since every
    function has to return something, this implies that every `if` has to have a corresponding
    `else`. Otherwise, you could write a function that has a return value when a certain
    condition is met but doesn’t have one when that condition isn’t met! Briefly:
    Haskell’s `if` is an *expression* that must return a value, and not a statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want a function that adds one to every number that would be produced
    by our previous `doubleSmallNumber` function. The body of this new function would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the placement of the parentheses. If we had omitted them, the function
    would only add one if `x` is less than or equal to 100\. Also note the apostrophe
    (`'`) at the end of the function’s name. The apostrophe doesn’t have any special
    meaning in Haskell’s syntax, which means it’s a valid character to use in a function
    name. We usually use `'` to denote either a *strict* version of a function (i.e.,
    one that isn’t lazy), or a slightly modified version of a function or variable
    with a similar name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `''` is a valid character for function names, we can write a function
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are two things to note here. The first is that we didn’t capitalize *Conan*
    in the name of the function. In Haskell, functions can’t begin with capital letters.
    (We’ll see why a bit later.) The second thing to note is that this function doesn’t
    take any parameters. When a function doesn’t take any parameters, we usually call
    it a *definition* or a *name*. Because we cannot change what names (or functions)
    mean once we have defined them, the function `conanO'Brien` and the string `"It's
    a-me, Conan O'Brien!"` can be used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: An Intro to Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802512.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Lists in Haskell are *homogeneous* data structures, which means they store several
    elements of the same type. We can have a list of integers or a list of characters,
    for example, but we can’t have a list made up of both integers and characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are surrounded by square brackets, and the list values are separated
    by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `let` keyword to define a name in GHCi. Entering `let a = 1` in GHCi
    is equivalent to writing `a = 1` in a script, then loading it with `:l`.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common operations when working with lists is concatenation.
    In Haskell, this is done using the `++` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Haskell, strings are really just lists of characters. For example, the string
    `"hello"` is actually the same as the list `['h','e','l','l','o']`. Because of
    this, we can use list functions on strings, which is really handy.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when repeatedly using the `++` operator on long strings. When you
    put together two lists, Haskell has to walk through the entire first list (the
    one on the left side of `++`). That’s not a problem when dealing with smaller
    lists, but appending something to the end of a list with fifty million entries
    is going to take a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, adding something to the beginning of a list is a nearly instantaneous
    operation. We do this with the `:` operator (also called the *cons* operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice how in the first example, `:` takes a character and a list of characters
    (a string) as its arguments. Similarly, in the second example, `:` takes a number
    and a list of numbers. The first argument to the `:` operator always needs to
    be a single item of the same type as the values in the list it’s being added to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `++` operator, on the other hand, always takes two lists as arguments.
    Even if you’re only adding a single element to the end of a list with `++`, you
    still have to surround that item with square brackets, so Haskell will treat it
    like a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Writing `[1,2,3,4] ++ 5` is wrong, because both parameters to `++` should be
    lists, and `5` isn’t a list; it’s a number.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, in Haskell, `[1,2,3]` is just syntactic sugar for `1:2:3:[]`.
    `[]` is an empty list. If we prepend `3` to that, it becomes `[3]`. Then if we
    prepend `2` to that, it becomes `[2,3]`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`[]`, `[[]]` and `[[],[],[]]` are all different things. The first is an empty
    list, the second is a list that contains one empty list, and the third is a list
    that contains three empty lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing List Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to get an element of a list by index, use the `!!` operator. As
    with most programming languages, the indices start at 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, if you try (say) to get the sixth element from a list that only has
    four elements, you’ll get an error, so be careful!
  prefs: []
  type: TYPE_NORMAL
- en: Lists Inside Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists can contain lists as elements, and lists can contain lists that contain
    lists, and so on. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Lists within a list can be of different lengths, but they can’t be of different
    types. Just like you can’t have a list that has some characters and some numbers
    as elements, you also can’t have a list that contains some lists of characters
    and some lists of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists can be compared if the items they contain can be compared. When using
    `<`, `<=`, `>=` and `>` to compare two lists, they are compared in lexicographical
    order. This means that first the two list heads are compared, and if they’re equal,
    the second elements are compared. If the second elements are also equal, the third
    elements are compared, and so on, until differing elements are found. The order
    of the two lists is determined by the order of the first pair of differing elements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we evaluate `[3,4,2] < [3,4,3]`, Haskell sees that `3` and
    `3` are equal, so it compares `4` and `4`. Those two are also equal, so it compares
    `2` and `3`. `2` is smaller than `3`, so it comes to the conclusion that the first
    list is smaller than the second one. The same goes for `<=`, `>=`, and `>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Also, a nonempty list is always considered to be greater than an empty one.
    This makes the ordering of two lists well defined in all cases, including when
    one is a proper initial segment of the other.
  prefs: []
  type: TYPE_NORMAL
- en: More List Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some more basic list functions, followed by examples of their usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head` function takes a list and returns its head, or first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tail` function takes a list and returns its tail. In other words, it chops
    off a list’s head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `last` function returns a list’s last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init` function takes a list and returns everything except its last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To help us visualize these functions, we can think of a list as a monster,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802514.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But what happens if we try to get the head of an empty list?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Oh my—it blows up in our face! If there’s no monster, it doesn’t have a head.
    When using `head`, `tail`, `last`, and `init`, be careful not to use them on empty
    lists. This error cannot be caught at compile time, so it’s always good practice
    to take precautions against accidentally telling Haskell to give you elements
    from an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `length` function takes a list and returns its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `null` function checks if a list is empty. If it is, it returns `True`,
    otherwise it returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reverse` function reverses a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `take` function takes a number and a list. It extracts the specified number
    elements from the beginning of the list, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we try to `take` more elements than there are in the list, Haskell just returns
    the entire list. If we `take` 0 elements, we get an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drop` function works in a similar way, only it drops (at most) the specified
    number of elements from the beginning of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `maximum` function takes a list of items that can be put in some kind of
    order and returns the largest element. The `minimum` function is similar, but
    it returns the smallest item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sum` function takes a list of numbers and returns their sum. The `product`
    function takes a list of numbers and returns their product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `elem` function takes an item and a list of items and tells us if that item
    is an element of the list. It’s usually called as an infix function because it’s
    easier to read that way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Texas Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802516.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What if we need a list made up of the numbers between 1 and 20? Sure, we could
    just type them all out, but that’s not a solution for gentlemen who demand excellence
    from their programming languages. Instead, we’ll use *ranges*. Ranges are used
    to make lists composed of elements that can be *enumerated*, or counted off in
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, numbers can be enumerated: 1, 2, 3, 4, and so on. Characters can
    also be enumerated: the alphabet is an enumeration of characters from A to Z.
    Names, however, can’t be enumerated. (What comes after “John?” I don’t know!)'
  prefs: []
  type: TYPE_NORMAL
- en: To make a list containing all the natural numbers from 1 to 20, you can just
    type `[1..20]`. In Haskell, this is exactly the same as typing `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`.
    The only difference between the two is that writing out long enumeration sequences
    manually is stupid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify a *step* between items in your range. What if we want
    a list of every even number between 1 and 20? Or every third number between 1
    and 20? It’s simply a matter of separating the first two elements with a comma
    and specifying the upper limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: While they are pretty convenient, ranges with steps aren’t always as smart as
    people expect them to be. For example, you can’t enter `[1,2,4,8,16..100]` and
    expect to get all the powers of 2 that are no greater than 100\. For one thing,
    you can only specify a single step size. Also, some sequences that aren’t arithmetic
    can’t be specified unambiguously by giving only their first few terms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make a list with all the numbers from 20 down to 1, you can’t just type `[20..1]`,
    you have to type `[20,19..1]`. When you use a range without steps (like `[20..1]`),
    Haskell will start with an empty list and then keep increasing the starting element
    by one until it reaches or surpasses the end element in the range. Because 20
    is already greater than 1, the result will just be an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use ranges to make infinite lists by not specifying an upper limit.
    For example, let’s create a list containing the first 24 multiples of 13\. Here’s
    one way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But there’s actually a better way—using an infinite list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Because Haskell is *lazy*, it won’t try to evaluate the entire infinite list
    immediately (which is good because it would never finish anyway). Instead, it
    will wait to see which elements you need to get from that infinite list. In the
    above example, it sees that you just want the first 24 elements, and it gladly
    obliges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few functions that can be used to produce long or infinite lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cycle` takes a list and replicates its elements indefinitely to form an infinite
    list. If you try to display the result, it will go on forever, so make sure to
    slice it off somewhere:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`repeat` takes an element and produces an infinite list of just that element.
    It’s like cycling a list with only one element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`replicate` is an easier way to create a list composed of a single item. It
    takes the length of the list and the item to replicate, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One final note about ranges: watch out when using them with floating-point
    numbers! Because floating-point numbers, by their nature, only have finite precision,
    using them in ranges can yield some pretty funky results, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: I'm a List Comprehension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802518.png)'
  prefs: []
  type: TYPE_IMG
- en: '*List comprehensions* are a way to filter, transform, and combine lists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They’re very similar to the mathematical concept of *set comprehensions*. Set
    comprehensions are normally used for building sets out of other sets. An example
    of a simple set comprehension is: { 2 · *x*|*x* ∈ **N**, *x* ≤ 10}. The exact
    syntax used here isn’t crucial—what’s important is that this statement says, “take
    all the natural numbers less than or equal to 10, multiply each one by 2, and
    use these results to create a new set.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to write the same thing in Haskell, we could do something like
    this with list operations: `take 10 [2,4..]`. However, we could also do the same
    thing using list comprehensions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a closer look at the list comprehension in this example to better
    understand list comprehension syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In `[x*2 | x <- [1..10]]`, we say that we *draw* our elements from the list
    `[1..10]`. `[x <- [1..10]]` means that `x` takes on the value of each element
    that is drawn from `[1..10]`. In other words, we *bind* each element from `[1..10]`
    to `x`. The part before the vertical pipe (`|`) is the *output* of the list comprehension.
    The output is the part where we specify how we want the elements that we’ve drawn
    to be reflected in the resulting list. In this example, we say that we want each
    element that is drawn from the list `[1..10]` to be doubled.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem longer and more complicated than the first example, but what if
    we want to do something more complex than just doubling these numbers? This is
    where list comprehensions really come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s add a condition (also called a *predicate*) to our comprehension.
    Predicates go at the end of the list comprehension and are separated from the
    rest of the comprehension by a comma. Let’s say we want only the elements which,
    after being doubled, are greater than or equal to 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want all numbers from 50 to 100 whose remainder when divided by
    7 is 3? Easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Weeding out parts of lists using predicates is also called *filtering*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for another example. Let’s say we want a comprehension that replaces every
    odd number greater than 10 with `"BANG!"`, and every odd number less than 10 with
    `"BOOM!"`. If a number isn’t odd, we throw it out of our list. For convenience,
    we’ll put that comprehension inside a function so we can easily reuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, if you’re trying to define this function inside GHCi, you have to
    include a `let` before the function name. However, if you’re defining this function
    inside a script and then loading that script into GHCi, you don’t have to mess
    around with `let`.
  prefs: []
  type: TYPE_NORMAL
- en: The `odd` function returns `True` when passed an odd number, otherwise it returns
    `False`. The element is included in the list only if all the predicates evaluate
    to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can include as many predicates as we want, all separated by commas. For
    instance, if we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we’d
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only can we have multiple predicates in list comprehensions, we can also
    draw values from several lists. When drawing values from several lists, every
    combination of elements from these lists is reflected in the resulting list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` is drawn from `[1,2,3]` and `y` is drawn from `[10,100,1000]`. These
    two lists are combined in the following way. First, `x` becomes `1`, and while
    `x` is `1`, `y` takes on every value from `[10,100,1000]`. Because the output
    of the list comprehension is `x+y`, the values `11`, `101`, and `1001` are added
    to the beginning of the resulting list (`1` is added to `10`, `100`, and `1000`).
    After that, `x` becomes `2` and the same thing happens, resulting in the elements
    `12`, `102`, and `1002` being added to the resulting list. The same goes when
    `x` draws the value `3`.
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, each element `x` from `[1,2,3]` is combined with each element
    `y` from `[10,100,1000]` in all possible ways, and `x+y` is used to make the resulting
    list from those combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example: if we have two lists, `[2,5,10]` and `[8,10,11]`, and
    we want to get the products of all possible combinations of numbers in those lists,
    we could use the following comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the length of the new list is 9\. Now, what if we wanted all possible
    products that are more than 50? We can just add another predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For epic hilarity, let’s make a list comprehension that combines a list of adjectives
    and a list of nouns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We can even use list comprehensions to write our own version of the `length`
    function! We’ll call it `length'`. This function will replace every element in
    a list with `1`, then add them all up with `sum`, yielding the length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here we use underscore (`_`) as a temporary variable to store the items as we
    draw them from the input list, since we don’t actually care about the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, strings are lists too, so we can use list comprehensions to process
    and produce strings. Here’s an example of a function that takes a string and removes
    all the lowercase letters from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The predicate here does all the work. It says that the character will be included
    in the new list only if it’s an element of the list `[''A''..''Z'']`. We can load
    the function in GHCi and test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create nested list comprehensions if you’re operating on lists
    that contain lists. For example, let’s take a list that contains several lists
    of numbers and remove all the odd numbers without flattening the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here the output of the outer list comprehension is another list comprehension.
    A list comprehension always results in a list of something, so we know that the
    result here will be a list of lists of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can split list comprehensions across several lines to improve their readability.
    If you’re not in GHCi, this can be a great help, especially when dealing with
    nested comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802520.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Tuples* are used to store several heterogeneous elements as a single value.'
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, tuples are a lot like lists. However, there are some fundamental
    differences. First, as mentioned, tuples are heterogeneous. This means that a
    single tuple can store elements of several different types. Second, tuples have
    a fixed size—you need to know how many elements you’ll be storing ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are surrounded by parentheses, and their components are separated by
    commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of when tuples would be useful, let’s think about how we’d represent
    a two-dimensional vector in Haskell. One way would be to use a two item list,
    in the form of `[x,y]`. But suppose we wanted to make a list of vectors, to represent
    the corners of a two-dimensional shape in a coordinate plane. We could just create
    a list of lists, like this: `[[1,2],[8,11],[4,5]]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this method, however, is that we could also make a list like
    `[[1,2],[8,11,5],[4,5]]` and try to use it in the place of a list of vectors.
    Even though it doesn’t make sense as a list of vectors, Haskell has no problem
    with this list appearing wherever the previous list can, since both are of the
    same type (a list of lists of numbers). This could make it more complicated to
    write functions to manipulate vectors and shapes.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a tuple of size two (also called a *pair*) and a tuple of size
    three (also called a *triple*) are treated as two distinct types, which means
    a list can’t be composed of both pairs and triples. This makes tuples much more
    useful for representing vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change our vectors to tuples by surrounding them with parentheses instead
    of square brackets, like this: `[(1,2),(8,11),(4,5)]`. Now, if we try to mix pairs
    and triples, we get an error, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Haskell also considers tuples that have the same length but contain different
    types of data to be distinct types of tuples. For example, you can’t make a list
    of tuples like `[(1,2),("One",2)]`, because the first is a pair of numbers, and
    the second is a pair containing a string followed by a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples can be used to easily represent a wide variety of data. For instance,
    if we wanted to represent someone’s name and age in Haskell, we could use a triple:
    `("Christopher", "Walken", 55)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, tuples are of a fixed size—you should only use them when you know
    in advance how many elements you’ll need. The reason tuples are so rigid in this
    way is that, as mentioned, the size of a tuple is treated as part of its type.
    Unfortunately, this means that you can’t write a general function to append an
    element to a tuple—you’d have to write a function for appending to a pair (to
    produce a triple), another one for appending to a triple (to produce a 4-tuple),
    another one for appending to a 4-tuple, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Like lists, tuples can be compared with each other if their components can be
    compared. However, unlike lists, you can’t compare two tuples of different sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are singleton lists, there’s no such thing as a singleton tuple.
    It makes sense when you think about it: a singleton tuple’s properties would simply
    be those of the value it contains, so distinguishing a new type wouldn’t give
    us any benefit.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Storing data in pairs is very common in Haskell, and there are some useful
    functions in place to manipulate them. Here are two functions that operate on
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fst` takes a pair and returns its first component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`snd` takes a pair and—surprise!—returns its second component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions only operate on pairs. They won’t work on triples, 4-tuples,
    5-tuples, etc. We’ll go over extracting data from tuples in different ways a bit
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `zip` function is a cool way to produce a list of pairs. It takes two lists,
    then “zips” them together into one list by joining the matching elements into
    pairs. It’s a really simple function, but it can be very useful when you want
    to combine two lists in a particular way or traverse two lists simultaneously.
    Here’s a demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Notice that because pairs can have different types in them, `zip` can take two
    lists that contain elements of different types. But what happens if the lengths
    of the lists don’t match?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the above example, only as much of the longer list is used
    as needed—the rest is simply ignored. And because Haskell uses lazy evaluation,
    we can even zip finite lists with infinite lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Finding the Right Triangle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s wrap things up with a problem that combines tuples and list comprehensions.
    We’ll use Haskell to find a right triangle that fits all of these conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The lengths of the three sides are all integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of each side is less than or equal to 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The triangle’s perimeter (the sum of the side lengths) is equal to 24.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802522.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A triangle is a right triangle if one of its angles is a right angle (a 90-degree
    angle). Right triangles have the useful property that if you square the lengths
    of the sides forming the right angle and then add those squares, that sum is equal
    to the square of the length of the side that’s opposite the right angle. In the
    picture, the sides that lie next to the right angle are labeled `a` and `b`, and
    the side opposite the right angle is labeled `c`. We call that side the *hypotenuse*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, let’s generate all possible triples with elements that are
    less than or equal to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We’re drawing from three lists on the right-hand side of the comprehension,
    and the output expression on the left combines them into a list of triples. If
    you evaluate `triples` in GHCi, you’ll get a list that is 1,000 entries long,
    so we won’t show it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll filter out triples that don’t represent right triangles by adding
    a predicate that checks to see if the Pythagorean theorem (`a^2 + b^2 == c^2`)
    holds. We’ll also modify the function to ensure that side `a` isn’t larger than
    the hypotenuse `c`, and that side `b` isn’t larger than side `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we changed the ranges in the lists that we draw values from. This
    ensures that we don’t check unnecessary triples, such as ones where side `b` is
    larger than the hypotenuse (in a right triangle, the hypotenuse is always the
    longest side). We also assumed that side `b` is never larger than side `a`. This
    doesn’t harm anything, because for every triple `(a,b,c)` with `a^2 + b^2 == c^2`
    and `b` > `a` that is left out of consideration, the triple `(b,a,c)` is included—and
    is the same triangle, just with the legs reversed. (Otherwise, our list of results
    would contain pairs of triangles that are essentially the same.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In GHCi, you can’t break up definitions and expressions across multiple lines.
    In this book, however, we occasionally need to break up a single line so the code
    can all fit on the page. (Otherwise the book would have to be really wide, and
    it wouldn’t fit on any normal shelf—and then you’d have to buy bigger shelves!)
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re almost done. Now, we just need to modify the function to only output
    the triangles whose perimeter equals 24:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'And there’s our answer! This is a common pattern in functional programming:
    you start with a certain set of candidate solutions, and successively apply transformations
    and filters to them until you’ve narrowed the possibilities down to the one solution
    (or several solutions) that you’re after.'
  prefs: []
  type: TYPE_NORMAL
