<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;TIPS"><div class="titlepage"><div><div><h1 class="title"><a id="tips"/>Chapter 14. TIPS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e14353"/><img src="httpatomoreillycomsourcenostarchimages333191.png.jpg" alt="image with no caption"/></div></div><p>By now you're some kind of Xen expert, we imagine.<sup>[<a id="CHP-14-FNOTE-1" href="#ftn.CHP-14-FNOTE-1" class="footnote">81</a>]</sup> As such, now we'd like to devote a chapter to the more esoteric aspects of working with Xen. Here are some things that didn't seem to fit anywhere else—stuff like the framebuffer, forwarding PCI devices, or building added functionality into the XenStore. Tips, in other words.</p><p>A number of the topics in <a class="xref" href="ch15.html" title="Chapter 15. TROUBLESHOOTING">Chapter 15</a> might also come in handy when you work through our examples here. Some of the software discussed here is even more bleeding edge than the rest of Xen, which is itself some kind of <span class="emphasis"><em>heavenly sword</em></span>, ravening and incarnadine. What we're trying to get at is that the material in this chapter might not work straight off.</p><div class="sect1" title="Compiling Xen"><div class="titlepage"><div><div><h1 class="title"><a id="compiling_xen"/>Compiling Xen</h1></div></div></div><p>Although we've relied, for the most part, on Xen packages provided by distro maintainers, we think it's generally worthwhile to compile Xen from scratch. This will allow you to use a much more up-to-date version of Xen than versions that come with the distros. It also lets you enable options that the distro maintainers may have disabled.</p><p>If you're feeling adventurous, it's also nice to be able to play with the code—change it around a bit, perhaps, or add some <code class="literal">printk</code> messages to help with debugging.</p><p>The easiest way to compile is to check out the latest source from the <a id="idx-CHP-14-0965" class="indexterm"/>Mercurial repository. Start by making sure you have Mercurial and a bunch of build dependencies. On CentOS 5, we installed these packages with <code class="literal">yum</code>:<sup>[<a id="CHP-14-FNOTE-2" href="#ftn.CHP-14-FNOTE-2" class="footnote">82</a>]</sup></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>mercurial</p></li><li class="listitem"><p>zlib-devel</p></li><li class="listitem"><p>gcc</p></li><li class="listitem"><p>libX11-devel</p></li><li class="listitem"><p>openssl-devel</p></li><li class="listitem"><p>ncurses-devel</p></li><li class="listitem"><p>bridge-utils</p></li><li class="listitem"><p>python-devel</p></li><li class="listitem"><p>git</p></li><li class="listitem"><p>dev86</p></li><li class="listitem"><p>glibc-devel</p></li></ul></div><p>If you want the docs to build successfully, you should also install the following packages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>texinfo</p></li><li class="listitem"><p>tetex-latex</p></li><li class="listitem"><p>pstoedit</p></li><li class="listitem"><p>transfig</p></li></ul></div><p>Given the large amount of Xen documentation available online and from other sources, the included docs are fairly optional.</p><p>When these packages are installed, clone the development repository. We're <a id="idx-CHP-14-0966" class="indexterm"/>using <span class="emphasis"><em>xen-unstable</em></span> here, but if you'd like to use a less unstable repo, you might want to try something like <span class="emphasis"><em>xen-3.3-testing.hg</em></span>. As of early 2009, prgmr.com runs <span class="emphasis"><em>xen-3.3-testing.hg</em></span>. It has been pretty stable.</p><a id="I_programlisting14_d1e14469"/><pre class="programlisting"># hg clone http://xenbits.xen.org/xen-unstable.hg</pre><div class="sidebar"><a id="rpmforge_repository"/><p class="title">RPMFORGE REPOSITORY</p><p>If you want to install all the previously listed <a id="idx-CHP-14-0967" class="indexterm"/>packages using <code class="literal">yum</code>, you must use the <a id="idx-CHP-14-0968" class="indexterm"/>RPMForge repo. To do so safely, <code class="literal">install yum-priorities</code>. On CentOS 5:</p><a id="I_programlisting14_d1e14490"/><pre class="programlisting"># yum install yum-priorities</pre><p>Edit each of the files under <code class="literal">/etc/yum.repos.d/*</code> <a id="idx-CHP-14-0969" class="indexterm"/>and add the line <code class="literal">priority=N</code>,where <code class="literal">N</code> is a number from 1 to 99 (lower number is greater priority). You want <code class="literal">base</code>, <code class="literal">addons</code>, <code class="literal">updates</code>, and <code class="literal">extras</code> to be priority <code class="literal">1</code>; <code class="literal">centosplus</code> and <code class="literal">contrib</code> to be priority <code class="literal">2</code>; and everything else to be priority <code class="literal">10</code> or higher.</p><p>Now, install RPMforge:</p><a id="I_programlisting14_d1e14540"/><pre class="programlisting">wget
http://apt.sw.be/redhat/el5/en/i386/RPMS.dag/rpmforge-release-0.3.6-1
.el5.rf.i386.rpm</pre><p>Of course, if your machine is x86_64, substitute the appropriate architecture:</p><a id="I_programlisting14_d1e14544"/><pre class="programlisting">rpm --import http://dag.wieers.com/rpm/packages/RPM-GPG-KEY.dag.txt</pre><p>then install <code class="literal">rpmforge</code> with:</p><a id="I_programlisting14_d1e14551"/><pre class="programlisting">rpm -K rpmforge-release-0.3.6-1.el5.rf.*.rpm</pre><p>Finally, edit <span class="emphasis"><em>/etc/yum.repos.d/rpmforge.repo</em></span> and add <code class="literal">priority=10</code>.</p></div><p>This will download the repo to a local directory (<span class="emphasis"><em>xen-unstable.hg</em></span> in this case). Next, <code class="literal">cd</code> into that directory and run <code class="literal">make world</code>:<a id="idx-CHP-14-0970" class="indexterm"/></p><a id="I_programlisting14_d1e14576"/><pre class="programlisting"># cd xen-unstable.hg
# make world &amp;&amp; make install</pre><p>This will build and install the Xen hypervisor, its supporting tools, and a Linux kernel for dom0. DomUs can use it as well. Often, this will be all you need. However, if you want to change your kernel configuration, you can. To configure the Linux kernel, run:</p><a id="I_programlisting14_d1e14580"/><pre class="programlisting"># make linux-2.6-xen-config configmode=MENUCONFIG</pre><p>This will open the standard <a id="idx-CHP-14-0971" class="indexterm"/>Linux kernel configurator. Configure the kernel as usual.</p><div class="note" title="Note"><h3 class="title"><a id="note-49"/>Note</h3><p><span class="emphasis"><em>You probably want to leave the dom0 8250 serial driver disabled because it conflicts with the Xen serial console. As usual, don't forget the drivers for your boot device</em></span>.</p></div><p>Then run:</p><a id="I_programlisting14_d1e14595"/><pre class="programlisting"># make linux-2.6-build
# make linux-2.6-install</pre><p>This builds <a id="idx-CHP-14-0972" class="indexterm"/>and installs the kernel. Now, if you are on CentOS, you probably want to make an initrd:</p><a id="I_programlisting14_d1e14605"/><pre class="programlisting"># mkinitrd /boot/initrd-2.6.18.8-xen.img 2.6.18.8-xen</pre><div class="note" title="Note"><h3 class="title"><a id="note-50"/>Note</h3><p><span class="emphasis"><em>There is a bug in early releases of RHEL 5.3 that causes problems with this. See</em></span> <a class="ulink" href="https://bugzilla.redhat.com/show_bug.cgi?id=488991">https://bugzilla.redhat.com/show_bug.cgi?id=488991</a> <span class="emphasis"><em>for details. The solution is to add</em></span> <em class="replaceable"><code>--allow-missing</code></em> <span class="emphasis"><em>to the</em></span> <em class="replaceable"><code>mkinitrd</code></em> <span class="emphasis"><em>command line, thus</em></span>: <em class="replaceable"><code># mkinitrd /boot/initrd-2.6.18.8-xen.img 2.6.18.8-xen --allow-missing</code></em>.<a id="idx-CHP-14-0973" class="indexterm"/></p></div><p>Now, you need to fix <span class="emphasis"><em>/boot/grub/menu.lst</em></span>. Add a stanza like this, but remember to use appropriate devices, paths, and possibly filenames:</p><a id="I_programlisting14_d1e14642"/><pre class="programlisting">title Xen.org 2.6.18.8-xen-3.3
        root (hd0,0)
        kernel /boot/xen-3.3.gz
        module /boot/vmlinuz-2.6.18.8-xen ro root=/dev/md0
        module /boot/initrd-2.6.18.8-xen.img</pre><p>Reboot and enjoy your new Xen installation.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-14-FNOTE-1" href="#CHP-14-FNOTE-1" class="para">81</a>] </sup>Or at least, anyone who hasn't thrown this book out the window must be extremely good at filling in vague directions.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-14-FNOTE-2" href="#CHP-14-FNOTE-2" class="para">82</a>] </sup>We've also included a more Debian-centric set of compilation instructions in <a class="xref" href="ch14s03.html" title="paravirt_ops Dom0">paravirt_ops Dom0</a> on <a class="xref" href="ch14s02.html#alternate_kernels_dom0_and_domu" title="Alternate Kernels (Dom0 and DomU)">Alternate Kernels (Dom0 and DomU)</a> and <a class="xref" href="ch14s04.html" title="paravirt_ops DomU">paravirt_ops DomU</a> on <a class="xref" href="ch14s04.html" title="paravirt_ops DomU">paravirt_ops DomU</a>.</p></div></div></div>
<div class="sect1" title="Compile-Time Tuning"><div class="titlepage"><div><div><h1 class="title"><a id="compile-time_tuning"/>Compile-Time Tuning</h1></div></div></div><p>That's the quick and easy way to build Xen, but the basic compilation with <code class="literal">make world</code> is just the beginning. Compilation represents the first opportunity we have to configure Xen, and there's a lot more that we can do with it now that we've had some practice.<a id="idx-CHP-14-0974" class="indexterm"/></p><p>Most of the <a id="idx-CHP-14-0975" class="indexterm"/>compile-time tuning can be done by twiddling variables in <span class="emphasis"><em>Config.mk</em></span>, at the top level of the Xen source tree. This file is fairly extensively commented and amenable to editing—take a look. You'll find that there's a brief section where you can decide which optional Xen bits to build.</p><p>We usually turn on all of the optional components except for the Virtual Trusted Platform Module (VTPM) tools, leading to a section like this:</p><a id="I_programlisting14_d1e14670"/><pre class="programlisting">XENSTAT_XENTOP     ?= y
VTPM_TOOLS         ?= n
LIBXENAPI_BINDINGS ?= y
XENFB_TOOLS        ?= y
PYTHON_TOOLS       ?= y</pre><div class="note" title="Note"><h3 class="title"><a id="note-51"/>Note</h3><p><span class="emphasis"><em>Xen's VTPM tools are interesting. They've been a subject of heavy development, they have some interesting implications for signed code, and there's the looming specter of DRM, but we just haven't gotten into them. If you decide to build them, you can add virtual TPMs to domains via the</em></span> <em class="replaceable"><code>vtpm=</code></em> <span class="emphasis"><em>option in the domain configuration</em></span>.<a id="idx-CHP-14-0976" class="indexterm"/></p></div><p>If you're having trouble (trust us, you probably will at some point), it would be a good idea to make a debug build. To do that, set the <code class="literal">DEBUG</code> variable at the top of the file:</p><a id="I_programlisting14_d1e14691"/><pre class="programlisting">DEBUG              ?= y</pre><p>Don't worry: Xen will not run in debug mode unless you specifically instruct it to do so at runtime.</p><p>These optional Xen components have a bunch of undocumented dependencies, some of which aren't checked <a id="idx-CHP-14-0977" class="indexterm"/>for by the Makefiles. In particular, the LIBXENAPI_BINDINGS demand libxml2 and curl or the -devel versions of these packages, if you're using a Red Hat derivative.</p><p>Also, if something doesn't work when you build the tools, it would probably be a good idea to avoid running <code class="literal">make world</code> again because that takes a while. Most likely, you can get by with just <code class="literal">make tools</code>.</p><div class="sect2" title="Alternate Kernels (Dom0 and DomU)"><div class="titlepage"><div><div><h2 class="title"><a id="alternate_kernels_dom0_and_domu"/>Alternate Kernels (Dom0 and DomU)</h2></div></div></div><p>The default Xen Makefile will build a single kernel that can be used in both the dom0 and domU. If <a id="idx-CHP-14-0978" class="indexterm"/>saving memory is a high priority, you can build a separate kernel for each. These kernels will each have a reasonable set of configuration options: minimal for the domU, modular for the dom0. Specify the <code class="literal">KERNELS</code> variable on your <code class="literal">make</code> command line:<a id="idx-CHP-14-0979" class="indexterm"/><a id="idx-CHP-14-0980" class="indexterm"/></p><a id="I_programlisting14_d1e14739"/><pre class="programlisting"># make KERNELS="linux-2.6-dom0 linux-2.6-domU"</pre><p>The primary reason to do this, of course, is so that you can strip all the non-Xen device drivers out of the domU kernel. This saves memory and—if you happen to be testing a lot of kernels—compile time.</p></div></div>
<div class="sect1" title="paravirt_ops Dom0"><div class="titlepage"><div><div><h1 class="title"><a id="paravirt_ops_dom0"/>paravirt_ops Dom0</h1></div></div></div><p>To understand why paravirt_ops gets treated as a separate piece, we have to recall that a lot of the early Xen development took place before virtualization went mainstream. The Xen developers, to paravirtualize the Linux kernel, made sweeping changes that proved to be difficult to merge with mainline kernel development.<a id="idx-CHP-14-0981" class="indexterm"/></p><p>paravirt_ops is a generic solution to this problem. It's a kernel-level framework for adding code to enable Linux to run under various hypervisors, including Xen. The idea is that, by making these interfaces part of the official kernel, we can make Xen less invasive and easier to maintain.</p><p>Xen has supported paravirt_ops domUs since version 3.1, and the official Linux kernel has had domU support since version 2.6.23 for i386 and since version 2.6.26 for x86_64. Unfortunately, the kernel.org kernel, as of this writing, only has guest support.</p><p>But there is light at the end of the tunnel. With the latest patches from Jeremy <a id="idx-CHP-14-0982" class="indexterm"/>Fitzhardinge's paravirt_ops <a id="idx-CHP-14-0983" class="indexterm"/>dom0 work and a Xen 3.4 hypervisor, it is, in fact, possible to run a <a id="idx-CHP-14-0984" class="indexterm"/>paravirt_ops dom0 based on Linux kernel version 2.6.30.</p><p>These directions represent a snapshot from a very long development process. They work for us today. URLs may change. The status of the software certainly will. With that in mind, though, here's how we set up a functioning paravirt_ops dom0.</p><p>First, you're going to need some development packages. This time we're <a id="idx-CHP-14-0985" class="indexterm"/>using the <a id="idx-CHP-14-0986" class="indexterm"/>Debian package names:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>mercurial</p></li><li class="listitem"><p>build-essential</p></li><li class="listitem"><p>libncurses5-dev</p></li><li class="listitem"><p>gawk</p></li><li class="listitem"><p>openssl</p></li><li class="listitem"><p>xorg-dev</p></li><li class="listitem"><p>gettext</p></li><li class="listitem"><p>python-dev</p></li><li class="listitem"><p>gitk</p></li><li class="listitem"><p>libcurl4-openssl-dev</p></li><li class="listitem"><p>bcc</p></li><li class="listitem"><p>libz-dev</p></li><li class="listitem"><p>libxml2-dev</p></li></ul></div><p>Next, check out Xen-unstable with Mercurial. We warned you that this stuff is still in development.</p><a id="I_programlisting14_d1e14832"/><pre class="programlisting"># hg clone http://xenbits.xensource.com/xen-unstable.hg
# cd xen-unstable.hg
# make xen
# make install-xen
# make tools
# make install-tools</pre><p>Then check out the current Linux patches from Jeremy Fitzhardinge's git repo:</p><a id="I_programlisting14_d1e14837"/><pre class="programlisting"># git clone git://git.kernel.org/pub/scm/linux/kernel/git/jeremy/xen.git linux-2.6-xen
# cd linux-2.6-xen
# git checkout origin/push2/xen/dom0/master -b push2/xen/dom0/master</pre><p>Configure the kernel. We copied the Ubuntu configuration to <span class="emphasis"><em>.config</em></span> and used that as a base.</p><a id="I_programlisting14_d1e14844"/><pre class="programlisting"># cp /boot/config-2.6.26-11-server .config
# make menuconfig</pre><p>Since we're building a <a id="idx-CHP-14-0987" class="indexterm"/>paravirt_ops <a id="idx-CHP-14-0988" class="indexterm"/>dom0, make sure to turn on the appropriate support:</p><a id="I_programlisting14_d1e14860"/><pre class="programlisting">Processor type and features
    -&gt; Paravirtualized guest support
........-&gt; Enable Xen privileged domain support</pre><p>Be sure to turn on the Xen block device frontend support, under:</p><a id="I_programlisting14_d1e14864"/><pre class="programlisting">Device Drivers
    -&gt; Block devices</pre><p>Next, build the kernel.</p><a id="I_programlisting14_d1e14868"/><pre class="programlisting"># make
# make modules_install install
# depmod 2.6.30-tip
# mkinitramfs -o /boot/initrd-2.6.30-tip.img 2.6.30-tip</pre><p>Add <span class="emphasis"><em>/proc/xen</em></span> to <code class="literal">fstab</code> and mount it so that tools like <code class="literal">xend</code> will be able to communicate with the hypervisor:</p><a id="I_programlisting14_d1e14881"/><pre class="programlisting">none /proc/xen xenfs defaults 0 0</pre><p>Create a GRUB entry to boot your new Xen <a id="idx-CHP-14-0989" class="indexterm"/>paravirt_ops dom0:</p><a id="I_programlisting14_d1e14892"/><pre class="programlisting">title Xen 3.4 / Ubuntu 8.10, kernel 2.6.30-tip
kernel /boot/xen-3.4.gz
module /boot/vmlinuz-2.6.30-tip root=/dev/sdb2 ro console=tty0
module /boot/initrd-2.6.30-tip.img</pre><p>Make sure that these are appropriate values <a id="idx-CHP-14-0990" class="indexterm"/>for your setup, of course. That's all there is to it.</p></div>
<div class="sect1" title="paravirt_ops DomU"><div class="titlepage"><div><div><h1 class="title"><a id="paravirt_ops_domu"/>paravirt_ops DomU</h1></div></div></div><p>"But what," you ask, "is all this about using a kernel.org kernel in a domU?" If you just want to make your own domU kernel, this is a much less involved process, supported without out-of-tree patches since version 2.6.23. All of these directions are presented from within a domU that boots using PV-GRUB or PyGRUB—no intervention from the dom0 administrator should be necessary.<a id="idx-CHP-14-0991" class="indexterm"/></p><p>First, download the kernel source you prefer:<a id="I_indexterm14_d1e14914" class="indexterm"/><a id="I_indexterm14_d1e14919" class="indexterm"/></p><a id="I_programlisting14_d1e14924"/><pre class="programlisting"># wget http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.29.3.tar.bz2</pre><p>Next, install the packages normally required to build the kernel. This example is for Debian, but it should be easy enough to find out what packages your favorite distro needs to build the kernel.</p><a id="I_programlisting14_d1e14928"/><pre class="programlisting"># apt-get install build-essential libncurses5-dev</pre><p>Untar and configure the kernel.  Personally, we like <code class="literal">menuconfig</code>, but that's just a matter of taste:</p><a id="I_programlisting14_d1e14935"/><pre class="programlisting"># tar -jxf linux-2.6.29.3.tar.bz2
# cd linux-2.6.29.3
# make menuconfig</pre><p>Don't forget to enable Xen support:</p><a id="I_programlisting14_d1e14939"/><pre class="programlisting">-&gt; Processor type and features
  -&gt; Paravirtualized guest support
    -&gt; XEN</pre><p>Don't forget your network driver:</p><a id="I_programlisting14_d1e14944"/><pre class="programlisting">-&gt; Device Drivers
  -&gt; Network device support
    -&gt; XEN_NETDEV_FRONTEND</pre><p>or your disk driver:</p><a id="I_programlisting14_d1e14948"/><pre class="programlisting">-&gt; Device Drivers
  -&gt; Block devices
    -&gt; XEN_BLKDEV_FRONTEND</pre><p>Xenfs, which allows you to access the XenBus, is sometimes useful:</p><a id="I_programlisting14_d1e14952"/><pre class="programlisting">-&gt; Device Drivers
  -&gt; XENFS</pre><p>Then customize to your heart's content. Remember, you can remove support for just about all hardware now. We also leave out the balloon driver. RAM is cheap, and we like having definite memory allocations.</p><p>Now, make the kernel as usual:</p><a id="I_programlisting14_d1e14958"/><pre class="programlisting">make -j4 ; make install modules_install</pre><p>Make your initrd as per the usual kernel build. Since we're using Debian for this example, that means using <code class="literal">mkinitramfs</code>. If you compiled <code class="literal">xenblk</code> as a module, make sure to include it.</p><a id="I_programlisting14_d1e14968"/><pre class="programlisting">mkinitramfs -o /boot/initrd-2.6.29.3.img 2.6.29.3</pre><p>Set up GRUB as you normally would:</p><a id="I_programlisting14_d1e14973"/><pre class="programlisting">title kernel.org paravirt <a id="idx-CHP-14-0992" class="indexterm"/>DomU
  root (hd0,0)
  kernel /boot/vmlinuz-2.6.29.3  root=LABEL=DISK1 ro
  initrd /boot/initrd-2.6.29.3.img</pre><p>One last thing <a id="idx-CHP-14-0993" class="indexterm"/>before you reboot: Note that the device name for your console will be hvc0, for <span class="emphasis"><em>hypervisor console</em></span>. This takes the place of the Xen-specific xvc0. If your distro doesn't do so already, you probably want to set up the domain to start a <code class="literal">getty</code> on hvc0. Now, simply restart your domain (halt it and start it up if you are using PyGRUB) and enjoy your modern kernel.</p><a id="I_programlisting14_d1e14995"/><pre class="programlisting"># uname -a
Linux sebastian.xen.prgmr.com 2.6.29.3 #1 SMP Tue May 12 06:32:52 UTC 2009 x86_64 GNU/Linux 2009</pre></div>
<div class="sect1" title="The Xen API: The Way of the Future"><div class="titlepage"><div><div><h1 class="title"><a id="the_xen_api_the_way_of_the_future"/>The Xen API: The Way of the Future</h1></div></div></div><p>The Xen API is an XML-RPC interface to Xen that replaces the old interface used for communication with the hypervisor. It promises to provide a standard, stable interface so that people can build Xen frontends without worrying about the interface changing out from under them. It also extends the previous Xen command set so that more of Xen's functionality can be harnessed in a standardized tool.<a id="idx-CHP-14-0994" class="indexterm"/></p><p>In current versions of Xen, the API is an optional component, but that shouldn't deter you from using it; the most recent Citrix Xen Server product, for example, relies on the API exclusively for communication between the administration frontend and the virtualization host.</p><p>The Xen API is enabled by setting the LIBXENAPI_BINDINGS flag at the top of <span class="emphasis"><em>Config.mk</em></span>:</p><a id="I_programlisting14_d1e15012"/><pre class="programlisting">LIBXENAPI_BINDINGS ?= y</pre><p>When you've built Xen with support for the Xen API, the use of the API is controlled by the <code class="literal">(xen-api-server)</code> directive in <span class="emphasis"><em>/etc/xen/xend-config.sxp</em></span>.</p><a id="I_programlisting14_d1e15022"/><pre class="programlisting">(xen-api-server ((9363 none) (unix none)))</pre><p>This directive turns on the API server and specifies how to connect to it. Each list in parentheses is a connection method. In this case, we're using TCP port 9363 and a local Unix socket, each with no authentication whatsoever.</p><p>To specify that we want to authenticate using <a id="idx-CHP-14-0995" class="indexterm"/>PAM, we can modify this configuration a bit:<a id="I_indexterm14_d1e15032" class="indexterm"/><a id="I_indexterm14_d1e15037" class="indexterm"/></p><a id="I_programlisting14_d1e15042"/><pre class="programlisting">(xen-api-server ((9363 pam '192.0.2.*'))</pre><p>Ordinarily, even when developing a Xen client, you won't need to interact with the <a id="idx-CHP-14-0996" class="indexterm"/>Xen API at a low level. Bindings exist for most of the popular languages, including C and, of course, Python. The Xen.org API documentation, accessible from <a class="ulink" href="http://wiki.xensource.com/xenwiki/XenApi/">http://wiki.xensource.com/xenwiki/XenApi/</a>, is the last word on the subject.</p></div>
<div class="sect1" title="Managing Memory with the Balloon Driver"><div class="titlepage"><div><div><h1 class="title"><a id="managing_memory_with_the_balloon_driver"/>Managing Memory with the Balloon Driver</h1></div></div></div><p>Moving on from compile time and installation issues to the serious day-to-day business of running Xen, we encounter the problem of memory. As we've mentioned, most Xen installations are limited in practice by physical memory.<a id="idx-CHP-14-0997" class="indexterm"/><a id="idx-CHP-14-0998" class="indexterm"/><a id="idx-CHP-14-0999" class="indexterm"/></p><p>Xen expends a great deal of effort on virtualizing memory; its approach is one of the defining features of paravirtualization, and it usually "just works," on a level low enough to ignore completely. However, it sometimes can benefit from a bit of attention by the administrator.</p><p>We've been dancing around the subject of memory oversubscription for a long time, and we'd better come clean: It is possible to assign a dynamic <a id="idx-CHP-14-1000" class="indexterm"/>amount of memory to a domU, but we don't do it because it's not suitable for our <span class="emphasis"><em>virtual private server</em></span> model. Also, the developers have historically been leery about recommending it for production. However, it does exist, and there are some good reasons to use it, which we're sure you can imagine.</p><p>Xen's control over <a id="idx-CHP-14-1001" class="indexterm"/>reallocating memory to virtual machines is somewhat indirect. First, the value in the domU config file for memory is a <span class="emphasis"><em>maximum</em></span>—conceptually, the amount of memory that's physically accessible to the virtual machine. The amount of memory in the config file is what the kernel sees at boot. Adding more would require a reboot. This is being worked on, mostly from the direction of Linux's memory hotplug. We confidently expect someone to provide a patch soon.</p><p>Within this inflexible maximum, Xen can reduce this memory using the <span class="emphasis"><em>balloon driver</em></span>, which is nothing but a module that sits in the domU and <span class="emphasis"><em>inflates</em></span> to consume memory, which it then hands back to the hypervisor.</p><p>Because the dom0 is also a Xen domain, it also can have a memory balloon, which Xen uses to reclaim <a id="idx-CHP-14-1002" class="indexterm"/>dom0 memory for allocation to domUs.</p><div class="note" title="Note"><h3 class="title"><a id="note-52"/>Note</h3><p><span class="emphasis"><em>We favor setting the dom0 memory directly with the</em></span> <em class="replaceable"><code>dom0_mem</code></em> <span class="emphasis"><em>boot option, which actively hides memory from the dom0. By setting</em></span> <em class="replaceable"><code>(dom0-min-mem 0)</code></em> <span class="emphasis"><em>and</em></span> <em class="replaceable"><code>(enable-dom0-ballooning no)</code></em> <span class="emphasis"><em>in</em></span> xend-config.sxp, <span class="emphasis"><em>we can ensure that dom0 doesn't balloon out, and thus has a consistent memory reservation</em></span>.<sup>[<a id="CHP-14-FNOTE-3" href="#ftn.CHP-14-FNOTE-3" class="footnote">83</a>]</sup></p></div><p>You can use <code class="literal">xm</code> to manually adjust the amount of memory used by the balloon:</p><a id="I_programlisting14_d1e15156"/><pre class="programlisting"># xm mem-set sebastian 112</pre><p>The domain treats this as a target, giving <a id="idx-CHP-14-1003" class="indexterm"/>memory to the <a id="idx-CHP-14-1004" class="indexterm"/>balloon as it becomes free.<sup>[<a id="CHP-14-FNOTE-4" href="#ftn.CHP-14-FNOTE-4" class="footnote">84</a>]</sup> Thus, it's possible that a heavily loaded domain will take a while to give up memory to the balloon.</p><p>You can see the effect of the balloon in the list of VMs:</p><a id="I_programlisting14_d1e15175"/><pre class="programlisting"># xm list sebastian
Name                                      ID Mem(MiB) VCPUs State   Time(s)
sebastian                                 71      111     1 -b----     38.4</pre><p>You can also see balloon-related information from <a id="idx-CHP-14-1005" class="indexterm"/>within the domU via <span class="emphasis"><em>/proc/xen/balloon</em></span>:</p><a id="I_programlisting14_d1e15188"/><pre class="programlisting"># cat /proc/xen/balloon
Current allocation:   114688 kB
Requested target:     114688 kB
Low-mem balloon:       24576 kB
High-mem balloon:          0 kB
Driver pages:            136 kB
Xen hard limit:          ??? kB</pre><div class="note" title="Note"><h3 class="title"><a id="note-53"/>Note</h3><p><span class="emphasis"><em>The balloon is pretty aggressive; it can cause an out-of-memory condition in the domU. Use it with caution</em></span>.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-14-FNOTE-3" href="#CHP-14-FNOTE-3" class="para">83</a>] </sup>In newer versions of Xen, you really only need <code class="literal">(enable-dom0-ballooning no)</code>, but that has no effect on older versions. Before the <code class="literal">enable-dom0-ballooning</code> option was enabled, setting <code class="literal">dom0-min-mem</code> to 0 would disable ballooning. Really, you could get away with just setting <code class="literal">dom0-min-mem</code> to 0; I tested it after embarrassing myself on the xen-devel list, and it works, but <code class="literal">(enable-dom0-ballooning no)</code> is nice and clear, and this sort of thing is important enough to specify twice.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-14-FNOTE-4" href="#CHP-14-FNOTE-4" class="para">84</a>] </sup>Although Linux does its best to keep memory in use at all times, it'll give memory to the balloon rather than using it for buffers or cache.</p></div></div></div>
<div class="sect1" title="PCI Forwarding"><div class="titlepage"><div><div><h1 class="title"><a id="pci_forwarding"/>PCI Forwarding</h1></div></div></div><p>You can allow a domU to access arbitrary PCI devices and use them with full privileges. Of course, there's no such thing as a free lunch; Xen can't miraculously duplicate PCI hardware. For a domU to use a PCI device, it has to be hidden from the dom0 and not forwarded to any other domUs.<a id="idx-CHP-14-1006" class="indexterm"/></p><div class="figure"><a id="xen_pci_device_forwarding"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject14_d1e15206"/><img src="httpatomoreillycomsourcenostarchimages333249.png.jpg" alt="Xen PCI device forwarding"/></div></div><p class="title">Figure 14-1. Xen PCI device forwarding</p></div><p>As <a class="xref" href="ch14s07.html#xen_pci_device_forwarding" title="Figure 14-1. Xen PCI device forwarding">Figure 14-1</a> shows, PCI forwarding uses a client/server model in which the <span class="emphasis"><em>pcifront driver</em></span> runs in the domU and communicates directly with the <span class="emphasis"><em>pciback driver</em></span>, which binds to the PCI device and hides it from the dom0.</p><p>First, consider the device that you want to forward to the domU. The test machine that we're sitting in front of appears to have seven (!) USB controllers, so we'll just take a couple of those.</p><p>Use <code class="literal">lspci</code> to determine bus IDs:<a id="idx-CHP-14-1007" class="indexterm"/></p><a id="I_programlisting14_d1e15231"/><pre class="programlisting"># lspci

00:1a.0 USB Controller: Intel Corporation 82801H (ICH8 Family) USB
UHCI #4 (rev 02)
00:1a.1 USB Controller: Intel Corporation 82801H (ICH8 Family) USB
UHCI #5 (rev 02)
00:1a.7 USB Controller: Intel Corporation 82801H (ICH8 Family) USB2
EHCI #2 (rev 02)

(&amp;c.)</pre><p>We'll forward <code class="literal">00:1a.1</code> and <code class="literal">00:1a.7</code>, which are the second of the USB1 controllers listed and the USB2 controller. Your device names will most likely vary from those in this example.</p><p>If pciback is compiled into the kernel, you can boot the dom0 with a <code class="literal">pciback.hide</code> option on the kernel command line. For these two controllers, the option would look like this:</p><a id="I_programlisting14_d1e15246"/><pre class="programlisting">pciback.hide=(00:1a.1)(00:1a.7)</pre><p>If pciback is a module, it's a little more difficult. We need to detach the PCI device from its driver and attach it to the pciback passthrough.</p><a id="I_programlisting14_d1e15251"/><pre class="programlisting"># insmod pciback hide=(00:1a.1)(00:1a.7)
# echo -n 00:1a.1 &gt; /sys/bus/pci/drivers/uhci_hcd/unbind
# echo -n 00:1a.1 &gt; /sys/bus/pci/drivers/pciback/new_slot
# echo -n 00:1a.1 &gt; /sys/bus/pci/drivers/pciback/bind</pre><p>Now put these devices into the domU config file:</p><a id="I_programlisting14_d1e15255"/><pre class="programlisting">pci = [ '00:1a.1', '00:1a.7' ]</pre><p>On the next domU boot, these USB controllers should appear and be available to the native drivers in the domU. Hardware devices on platforms without an IOMMU can DMA to arbitrary memory regions. This can be a security problem if you're giving PCI access to arbitrary domains. The moral is to treat all domains with access to the PCI bus as privileged. Make sure you can trust them.</p></div>
<div class="sect1" title="GRUB Configuration"><div class="titlepage"><div><div><h1 class="title"><a id="grub_configuration"/>GRUB Configuration</h1></div></div></div><p>Of course, we've dealt with GRUB in passing because it's one of the basic prerequisites for Xen. However, there are a few more aspects of GRUB that are worth mentioning in depth. A fair number of Xen's behavior knobs can be tweaked in GRUB at boot time by adjusting the command-line parameters passed to the hypervisor.<a id="idx-CHP-14-1008" class="indexterm"/></p><p>For example, the already-mentioned <code class="literal">dom0_mem</code> parameter adjusts the amount of memory that Xen allows the dom0 to see:</p><a id="I_programlisting14_d1e15273"/><pre class="programlisting">kernel /boot/xen.gz dom0_mem=131072</pre><p>To keep the system from rebooting if you have a kernel panic, which happens more often than we would like, especially when trying to get machines initially set up, add <code class="literal">noreboot</code> to the <code class="literal">kernel</code> line:</p><a id="I_programlisting14_d1e15283"/><pre class="programlisting">kernel /boot/xen.gz dom0_mem=131072 noreboot</pre><p>as well as <code class="literal">panic=0</code> to the Linux <code class="literal">module</code> line:</p><a id="I_programlisting14_d1e15293"/><pre class="programlisting">module /boot/vmlinuz-2.6.18-53.1.21.el5xen panic=0</pre><p>This is, of course, in addition to the plethora of options supported by the Linux kernel, which you can then add to <code class="literal">vmlinuz</code>'s <code class="literal">module</code> line as you see fit.</p></div>
<div class="sect1" title="The Serial Console"><div class="titlepage"><div><div><h1 class="title"><a id="the_serial_console"/>The Serial Console</h1></div></div></div><p>One other important <a id="idx-CHP-14-1009" class="indexterm"/>GRUB-related task is setting up your serial console. As mentioned, we consider the serial console to be the gold standard for console access to any sort of server. It's much simpler than any sort of graphical interface, easy to access with a variety of devices, and is the output most likely to provide useful information when the machine is crashing. Furthermore, because of the client/server architecture inherent in the system, anything that a crashing machine manages to print goes to another, physically separate machine, where it can be analyzed at leisure.</p><p>Xen comes with miniterm, a minimal serial client for this sort of thing, in case you don't have access to a serial client. This is unlikely, but the client is tiny, so why not?</p><p>Miniterm is in the <span class="emphasis"><em>tools/misc/miniterm</em></span> subdirectory of the Xen source tree. If you've built all the tools with Xen, it'll already be built and possibly even installed; if not, you can simply type <strong class="userinput"><code>make</code></strong> in that directory and run the resulting executable.</p><div class="sect2" title="Enabling Serial Output"><div class="titlepage"><div><div><h2 class="title"><a id="enabling_serial_output"/>Enabling Serial Output</h2></div></div></div><p>There are four components that need to have their output redirected to the serial port: GRUB, Xen, the Linux kernel, and Linux's userland. Each of the first three is a simple matter of adding a directive to GRUB's <span class="emphasis"><em>menu.lst</em></span>.<a id="idx-CHP-14-1010" class="indexterm"/><a id="idx-CHP-14-1011" class="indexterm"/></p><p>First, near the top of the file, add these lines:</p><a id="I_programlisting14_d1e15340"/><pre class="programlisting">serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
terminal --timeout 10 serial console</pre><p>Edit the Xen kernel line to tell the hypervisor to use the first serial port for output:</p><a id="I_programlisting14_d1e15344"/><pre class="programlisting">kernel /boot/xen.gz-2.6.18-53.1.21.el5 console=com1 com1=115200,8n1</pre><p>Tell the Linux kernel to print its messages on <code class="literal">ttyS0</code>:</p><a id="I_programlisting14_d1e15351"/><pre class="programlisting">module /boot/vmlinuz-2.6.18-53.1.21.el5xen ro root=/dev/md0
<a id="idx-CHP-14-1012" class="indexterm"/>console=ttyS0,115200n8</pre><p>Finally, edit <span class="emphasis"><em>/etc/inittab</em></span> <a id="idx-CHP-14-1013" class="indexterm"/>and add a line like the following:</p><a id="I_programlisting14_d1e15370"/><pre class="programlisting">7:2345:respawn:/sbin/agetty 115200 ttyS0</pre><p>You may also want to add <code class="literal">ttyS0</code> to <span class="emphasis"><em>/etc/securetty</em></span> so that root will be able to log in, after the manner of a traditional console.</p></div><div class="sect2" title="The Xen Hypervisor Console"><div class="titlepage"><div><div><h2 class="title"><a id="the_xen_hypervisor_console"/>The Xen Hypervisor Console</h2></div></div></div><p>Xen adds another layer to the <a id="idx-CHP-14-1014" class="indexterm"/>serial console by using it to access extra hypervisor features. First, break into the hypervisor console by pressing CTRL-A three times on the serial console. This won't work on the VGA console. You'll get a (XEN) prompt.<a id="idx-CHP-14-1015" class="indexterm"/></p><p>When you're in the hypervisor console, there are several useful (or at least interesting) commands you can give Xen. Try typing <strong class="userinput"><code>h</code></strong> for help or one of the informational commands, like <strong class="userinput"><code>m</code></strong>. You can also crash the machine, reboot it, or dump various pieces of information. Poke around and try it.</p><p>To exit the hypervisor console, type CTRL-A three more times.</p></div></div>
<div class="sect1" title="Xen and LILO"><div class="titlepage"><div><div><h1 class="title"><a id="xen_and_lilo"/>Xen and LILO</h1></div></div></div><p>This section only applies to the real dinosaurs out there, but we sympathize. In keeping with the feeling that you have vanished into the mysterious past, we will present this example using Xen 3.0.<a id="idx-CHP-14-1016" class="indexterm"/></p><p>If you're dead set on using LILO, rather than GRUB, you will be pleased to learn that it is possible. Although it's generally thought that LILO's lack of an equivalent to GRUB's <code class="literal">module</code> directive makes it impossible for it to boot Xen, it's possible to get around that by combining the hypervisor, dom0 kernel, and initrd into one file using <code class="literal">mbootpack</code>.</p><p>Consider the following entry in <span class="emphasis"><em>grub.conf</em></span>:</p><a id="I_programlisting14_d1e15425"/><pre class="programlisting">title slack-xen
        root (hd0,0)
        kernel /boot/xen.gz
        module /vmlinuz-2.6-xen ro root=/dev/hda1 ro
        module /initrd-2.6.18-xen.gz</pre><p>It loads the hypervisor, <span class="emphasis"><em>xen-3.0.gz</em></span>, as the kernel then unpacks <span class="emphasis"><em>vmlinuz-2.6-xen</em></span> and <span class="emphasis"><em>initrd.gz</em></span> into memory. To combine these files, first decompress:</p><a id="I_programlisting14_d1e15438"/><pre class="programlisting"># cd /boot
# gzcat xen-3.0.gz &gt; xen-3.0
# gzcat vmlinuz-2.6-xen0 &gt; vmlinux-2.6-xen0
# gzcat initrd.gz &gt; initrd.img</pre><p>Note the change from <span class="emphasis"><em>vmlinuz</em></span> to <span class="emphasis"><em>vmlinux</em></span>. It's not important except that it keeps you from overwriting the kernel at the beginning <a id="idx-CHP-14-1017" class="indexterm"/>of the <code class="literal">gzcat</code> process.</p><p>Then combine the three files using <code class="literal">mbootpack</code>:<a id="idx-CHP-14-1018" class="indexterm"/></p><a id="I_programlisting14_d1e15465"/><pre class="programlisting"># mbootpack -o vmlinux-2.6-xen.mpack -m vmlinux-2.6-xen0 -m initrd.gz
  -m initrd.img xen3.0</pre><p>The <span class="emphasis"><em>grub.conf</em></span> entry then becomes a <span class="emphasis"><em>lilo.conf</em></span> entry:<a id="idx-CHP-14-1019" class="indexterm"/></p><a id="I_programlisting14_d1e15479"/><pre class="programlisting">image=/boot/vmlinux-2.6-xen.mpack
   label=xen
   root=/dev/ram0</pre><p>Finally, run the <code class="literal">lilo</code> command.<a id="idx-CHP-14-1020" class="indexterm"/></p><a id="I_programlisting14_d1e15491"/><pre class="programlisting"># /sbin/lilo</pre></div>
<div class="sect1" title="The Virtual Framebuffer"><div class="titlepage"><div><div><h1 class="title"><a id="the_virtual_framebuffer"/>The Virtual Framebuffer</h1></div></div></div><p>For as much as purists would like to claim that all administration should be done via serial port, there's something to be said for all this newfangled graphical technology that we've been using for, oh, around the last 25 years. Xen makes a concession to these forward-thinking beliefs by including a facility for a <span class="emphasis"><em>virtual framebuffer</em></span>.<a id="idx-CHP-14-1021" class="indexterm"/></p><p>You will need to edit your <span class="emphasis"><em>Config.mk</em></span> file to build the VFB:</p><a id="I_programlisting14_d1e15509"/><pre class="programlisting">XENFB_TOOLS        ?= y</pre><p>At this point you'll also need libvncserver and libsdl-dev. Install them in your chosen way. We installed CentOS's SDL-devel package and installed libvncserver from source. Then we built Xen and installed it in the usual way.</p><p>To actually use the framebuffer <a id="idx-CHP-14-1022" class="indexterm"/>within a domain, you'll need to specify it in the config file. Recent versions of Xen have improved the syntax somewhat. The <code class="literal">vfb=</code> option controls all aspects of the virtual framebuffer, just as the <code class="literal">vif=</code> and <code class="literal">disk=</code> lines control virtual interfaces and virtual block devices. For example:</p><a id="I_programlisting14_d1e15530"/><pre class="programlisting">vfb = [ 'type=vnc, vncunused=1' ]</pre><p>Here we specify a VNC VFB and tell the VNC server to listen on the first unused port that's over the given number. (We go into more detail on the options available in <a class="xref" href="apb.html" title="Appendix B. THE STRUCTURE OF THE XEN CONFIG FILE">Appendix B</a>.) Or, if you're feeling adventurous, there's the SDL version:</p><a id="I_programlisting14_d1e15536"/><pre class="programlisting">vfb = [ 'type=sdl' ]</pre><p>Simple.</p></div>
<div class="sect1" title="Use of the XenStore for Fun and Profit"><div class="titlepage"><div><div><h1 class="title"><a id="use_of_the_xenstore_for_fun_and_profit"/>Use of the XenStore for Fun and Profit</h1></div></div></div><p>The XenStore is the configuration database in which Xen stores <a id="idx-CHP-14-1023" class="indexterm"/>information on the running domUs. Although Xen uses the XenStore internally for vital matters like setting up virtual devices, you can also write arbitrary data to it from domUs as well as from dom0. Think of it as some sort of interdomain socket.</p><p>This opens up all sorts of possibilities. For example, domains could, in theory, negotiate among themselves for access to shared resources. Or you could have something like the <span class="emphasis"><em>talk</em></span> system on the shared UNIX machines of yore—multiuser chat between people running on the same host. You could use it to propagate host-specific messages, for example, warning people of impending backups or migration. For the most part, though, such applications remain to be written.</p><p>It's a little inconvenient to interact with the XenStore manually because no one's gotten around to providing a handy shell-style interface. In the meantime, we have to make do with tools that interrogate single keys.</p><p>To look at the XenStore, you can use the <code class="literal">xenstore-list</code> command. Here's a shell script from the Xen wiki that dumps keys from the xenstore recursively with <code class="literal">xenstore-list</code>:<a id="idx-CHP-14-1024" class="indexterm"/></p><a id="I_programlisting14_d1e15569"/><pre class="programlisting">#!/bin/sh

function dumpkey() {
   local param=${1}
   local key
   local result
   result=$(xenstore-list ${param})
   if [ "${result}" != "" ] ; then
     for key in ${result} ; do dumpkey ${param}/${key} ; done
   else
     echo -n ${param}'='
     xenstore-read ${param}
   fi
}

for key in /vm /local/domain /tool ; do dumpkey ${key} ; done</pre><p>You'll see that we have three hard-coded top-level keys: <code class="literal">vm</code>, <code class="literal">local/domain</code>, and <code class="literal">tool</code>. These each have a well-defined purpose to the hypervisor: <code class="literal">vm</code> stores domain information by UUID; <code class="literal">local/domain</code> stores domain information by ID (one might say that <code class="literal">vm</code> exports domain data in a form suitable for migration, and <code class="literal">local/domain</code> stores it for local use); and <code class="literal">tool</code> stores tool-specific information.</p><p>Poke around, look at the keys and how they map the information that you already know about the domain from other sources, like <code class="literal">xm list --long</code>. For example, to get the memory usage target for the domain, run:</p><a id="I_programlisting14_d1e15603"/><pre class="programlisting"># xenstore-read /local/domain/15/memory/target
1048576</pre><p>Many <a id="idx-CHP-14-1025" class="indexterm"/>of the keys in the XenStore are also writable. Although we don't recommend adjusting memory usage by writing to the XenStore, see the next section <a id="idx-CHP-14-1026" class="indexterm"/>for an example of interdomain communication via writable XenStore keys.</p><div class="sect2" title="Automatically Connecting to the VNC Console on Domain Boot"><div class="titlepage"><div><div><h2 class="title"><a id="automatically_connecting_to_the_vnc_cons"/>Automatically Connecting to the VNC Console on Domain Boot</h2></div></div></div><p>One neat feature of the Xen LiveCD is that Xen domains, when started, will automatically pop up a VNC window when they've finished booting. The infrastructure that makes this possible is a script in the domU, a listener in the dom0, and the XenBus between them.<a id="idx-CHP-14-1027" class="indexterm"/><a id="idx-CHP-14-1028" class="indexterm"/></p><p>The script in the domU, <span class="emphasis"><em>vnc-advertiser</em></span>, fires off from the domU startup scripts and waits for an Xvnc session to start. When it finds one, it writes to the XenStore:<a id="idx-CHP-14-1029" class="indexterm"/></p><a id="I_programlisting14_d1e15638"/><pre class="programlisting">xenstore-write /tool/vncwatch/${domid} ${local_addr}${screen}</pre><p>In the dom0, a corresponding script watches <a id="idx-CHP-14-1030" class="indexterm"/>for writes to the XenStore. On the LiveCD, it's named <span class="emphasis"><em>vnc-watcher.py</em></span>. This script is a good example of general-purpose uses for the XenStore, so we've copied it wholesale here, with verbose annotations:<a id="idx-CHP-14-1031" class="indexterm"/></p><a id="I_programlisting14_d1e15654"/><pre class="programlisting">#!/usr/bin/env python
###
# <a id="idx-CHP-14-1032" class="indexterm"/>VNC watch utility
# Copyright (C) 2005 XenSource Ltd
#
# This file is subject to the terms and conditions of the GNU General
# Public License.  See the file "COPYING" in the main directory of
# this archive <a id="idx-CHP-14-1033" class="indexterm"/>for more details.
###
# Watches <a id="idx-CHP-14-1034" class="indexterm"/>for VNC appearing in guests and fires up a local VNC
# viewer to that guest.
###

# Import libraries necessary to interact with the xenstore.  Xswatch
# watches a xenstore node and activates a <a id="idx-CHP-14-1035" class="indexterm"/>script-defined function
# when the node changes, while xstransact supports standard read and
# write operations.

from xen.xend.xenstore import xswatch
from xen.xend.xenstore.xstransact import xstransact
from os import system

def main():
   # first make the node:
   xstransact.Mkdir("/tool/vncwatch")
   xstransact.SetPermissions("/tool/vncwatch",
                             { "dom" : 0,
                               "read" : True,
                               "write" : True })
   active_connections = {}

# The watchFired method does the actual work of the script.  When the
# watcher notes changes to the path "/tool/vncwatch/", it calls
# watchFired with the path (and arguments, which are unused in this
# script).

   def watchFired(path, *args, **nargs):
       if path == "/tool/vncwatch":
           # not interested:
           return 1

# If we reach this point, something's changed under our path of
# interest.  Let's read the value at the path.

       vncaddr = xstransact.Read(path)
       print vncaddr

# When the vnc-advertiser notices that Xvnc's shut down in the domU,
# it removes the value from the xenstore.  If that happens, the
# watcher than removes the connection from its internal list (because
# presumably the VNC session no longer exists).

       if vncaddr == None:
           # server terminated, remove from connection list:
           if path in active_connections:
               active_connections.remove(path)
       else:
           # server started or changed, find out what happened:
           if (not active_connections.has_key(path)) or
              active_connections[path] != vncaddr:

# Recall that the vnc-advertiser script writes ${domid}
# ${local_addr}${screen}  to the patch /tool/vncwatch/.  The watcher
# takes that information and uses it to execute the vncviewer command
# with appropriate arguments.

        active_connections[path] = vncaddr system("vncviewer
-truecolour " + vncaddr + " &amp;") return 1

# Associate the watchFired event with a watcher on the path
# "tool/vncwatch"

   mywatch = xswatch.xswatch("/tool/vncwatch", watchFired)
   xswatch.watchThread.join()

if __name__ == "__main__":
   main()

===</pre><p>There are a couple of other sections that we would have loved to include here, but that aren't ready as of this writing, for example, the ongoing open source efforts to build an Amazon EC2 clone or the high-availability work being done by Project Kemari.</p><p>Anyway, please visit our website (<a class="ulink" href="http://prgmr.com/xen/">http://prgmr.com/xen/</a>) for more on the cool yet frightfully everyday things that we do with Xen.</p><p>Also, if you've broken your system trying to upgrade Xen from source, there's no better time than the present to take a look at the next chapter.<a id="I_indexterm14_d1e15684" class="indexterm"/><a id="I_indexterm14_d1e15689" class="indexterm"/></p></div></div></body></html>