- en: 'Chapter 11. Case Study: Intelligent Platform Management Interface Driver'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章. 案例研究：智能平台管理接口驱动程序
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: This chapter examines parts of `ipmi(4)`, the Intelligent Platform Management
    Interface (IPMI) driver. The IPMI specification defines a standard for monitoring
    and managing system hardware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 `ipmi(4)` 的部分内容，即智能平台管理接口 (IPMI) 驱动程序。IPMI 规范定义了用于监控和管理系统硬件的标准。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For our purposes, this description of IPMI is sufficient, as the point of this
    chapter is to demonstrate how PCI drivers such as `ipmi(4)` employ PMIO and MMIO.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，这个 IPMI 的描述就足够了，因为本章的目的是展示 PCI 驱动程序如 `ipmi(4)` 如何使用 PMIO 和 MMIO。
- en: The code base for `ipmi(4)` is composed of 10 source files and 1 header file.
    In this chapter, we’ll walk through one of these files, *ipmi_pci.c*, which contains
    code that’s related to the PCI bus.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipmi(4)` 的代码库由 10 个源文件和 1 个头文件组成。在本章中，我们将遍历其中一个文件，*ipmi_pci.c*，其中包含与 PCI 总线相关的代码。'
- en: Code Analysis
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分析
- en: '[Example 11-1](ch11.html#ipmi_underscore_pci.c "Example 11-1. ipmi_pci.c")
    provides a terse, source-level overview of *ipmi_pci.c*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c") 提供了 *ipmi_pci.c*
    的简洁、源代码级别的概述。'
- en: Example 11-1. ipmi_pci.c
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-1. ipmi_pci.c
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before I describe the functions in [Example 11-1](ch11.html#ipmi_underscore_pci.c
    "Example 11-1. ipmi_pci.c"), note that it contains two ![](httpatomoreillycomsourcenostarchimages1137499.png)
    ![](httpatomoreillycomsourcenostarchimages1137501.png) `DRIVER_MODULE` calls.
    In other words, [Example 11-1](ch11.html#ipmi_underscore_pci.c "Example 11-1. ipmi_pci.c")
    declares two Newbus drivers; each designed to handle a distinct group of devices
    (as you’ll soon see).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我描述 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c") 中的函数之前，请注意它包含两个
    `DRIVER_MODULE` 调用。换句话说，[示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c")
    声明了两个 Newbus 驱动程序；每个都设计用来处理一组不同的设备（正如你很快就会看到的）。
- en: Now let’s discuss the functions found in [Example 11-1](ch11.html#ipmi_underscore_pci.c
    "Example 11-1. ipmi_pci.c").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c") 中找到的函数。
- en: ipmi_pci_probe Function
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ipmi_pci_probe 函数
- en: 'The `ipmi_pci_probe` function is the `device_probe` implementation for the
    first Newbus driver found in [Example 11-1](ch11.html#ipmi_underscore_pci.c "Example 11-1. ipmi_pci.c").
    Here is its function definition:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipmi_pci_probe` 函数是 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c")
    中找到的第一个 Newbus 驱动程序的 `device_probe` 实现。以下是它的函数定义：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137501.png) checks
    the value of the global variable `ipmi_attached`. If it is nonzero, which signifies
    that `ipmi(4)` is currently in use, the error code ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `ENXIO` is returned; otherwise, ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `ipmi_pci_match` is called to determine whether this driver can handle ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `dev`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先检查全局变量 `ipmi_attached` 的值。如果它不为零，这意味着 `ipmi(4)` 当前正在使用中，将返回错误代码 `ENXIO`；否则，将调用
    `ipmi_pci_match` 来确定此驱动程序是否可以处理 `dev`。
- en: ipmi_pci_match Function
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ipmi_pci_match 函数
- en: 'The `ipmi_pci_match` function takes in a PCI Vendor ID/Device ID (VID/DID)
    pair and verifies whether it recognizes those IDs. Before I define (and subsequently
    walk through) this function, a description of the `ipmi_identifiers` array is
    needed. This array is defined near the beginning of [Example 11-1](ch11.html#ipmi_underscore_pci.c
    "Example 11-1. ipmi_pci.c") like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipmi_pci_match` 函数接收一个 PCI 供应商 ID/设备 ID (VID/DID) 对，并验证它是否识别这些 ID。在我定义（随后将逐步介绍）此函数之前，需要描述
    `ipmi_identifiers` 数组。此数组在 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1.
    ipmi_pci.c") 的开头附近定义，如下所示：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the `ipmi_identifiers` array is composed of `ipmi_ident` structures.
    Each `ipmi_ident` structure includes a ![](httpatomoreillycomsourcenostarchimages1137499.png)
    ![](httpatomoreillycomsourcenostarchimages1137501.png) VID/DID pair and a ![](httpatomoreillycomsourcenostarchimages1137503.png)
    description of the PCI device. As you may have guessed, `ipmi_identifiers` lists
    the devices that the first Newbus driver in [Example 11-1](ch11.html#ipmi_underscore_pci.c
    "Example 11-1. ipmi_pci.c") supports.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`ipmi_identifiers` 数组由 `ipmi_ident` 结构组成。每个 `ipmi_ident` 结构包括一个 ![VID/DID](http://atomoreilly.com/source/nostarch/images/1137499.png)
    ![对](http://atomoreilly.com/source/nostarch/images/1137501.png) 和一个 ![PCI 设备的描述](http://atomoreilly.com/source/nostarch/images/1137503.png)。正如你可能猜到的，`ipmi_identifiers`
    列出了 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c") 中第一个 Newbus
    驱动支持的设备。
- en: Now that we’ve discussed `ipmi_identifiers`, let’s walk through `ipmi_pci_match`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了 `ipmi_identifiers`，让我们来了解一下 `ipmi_pci_match`。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function determines whether a specific ![](httpatomoreillycomsourcenostarchimages1137501.png)
    VID/DID pair is listed in ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `ipmi_identifiers`. If so, its ![](httpatomoreillycomsourcenostarchimages1137503.png)
    description is returned.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数确定特定的 ![VID/DID](http://atomoreilly.com/source/nostarch/images/1137501.png)
    对是否列在 ![ipmi_identifiers](http://atomoreilly.com/source/nostarch/images/1137499.png)
    中。如果是，则返回其 ![描述](http://atomoreilly.com/source/nostarch/images/1137503.png)。
- en: ipmi_pci_attach Function
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ipmi_pci_attach 函数
- en: 'The `ipmi_pci_attach` function is the `device_attach` implementation for the
    first Newbus driver found in [Example 11-1](ch11.html#ipmi_underscore_pci.c "Example 11-1. ipmi_pci.c").
    Here is its function definition:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipmi_pci_attach` 函数是 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c")
    中找到的第一个 Newbus 驱动的 `device_attach` 实现。以下是它的函数定义：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    retrieving the IPMI data structure stored in the computer’s *System Management
    BIOS (SMBIOS)*, which is responsible for maintaining hardware configuration information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先 ![检索](http://atomoreilly.com/source/nostarch/images/1137499.png) 计算机中存储的
    IPMI 数据结构，该结构位于 *系统管理 BIOS (SMBIOS)* 中，负责维护硬件配置信息。
- en: Based on the SMBIOS data, `ipmi_pci_attach` determines `ipmi(4)`’s ![](httpatomoreillycomsourcenostarchimages1137501.png)
    mode of operation and whether it requires ![](httpatomoreillycomsourcenostarchimages1137503.png)
    I/O port or ![](httpatomoreillycomsourcenostarchimages1137505.png) I/O memory
    access. Currently, `ipmi(4)` supports only Keyboard Controller Style (KCS) and
    Server Management Interface Chip (SMIC) modes. These modes dictate how IPMI messages
    are transferred. For our purposes, you won’t need to understand the specifics
    of either mode.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 SMBIOS 数据，`ipmi_pci_attach` 确定操作模式 `ipmi(4)` 的 ![模式](http://atomoreilly.com/source/nostarch/images/1137501.png)
    以及是否需要 ![I/O 端口](http://atomoreilly.com/source/nostarch/images/1137503.png) 或
    ![I/O 内存访问](http://atomoreilly.com/source/nostarch/images/1137505.png)。目前，`ipmi(4)`
    仅支持键盘控制器样式 (KCS) 和服务器管理接口芯片 (SMIC) 模式。这些模式决定了 IPMI 消息的传输方式。就我们的目的而言，你不需要了解这两种模式的细节。
- en: The next block of code acquires I/O region access for `ipmi(4)`. Before I describe
    this code, some background on PCI devices is needed. After bootup, PCI devices
    can remap their device registers to a different location, thus avoiding address
    conflicts with other devices. Because of this, PCI devices store the size and
    current location of their I/O-mapped registers in their base address registers
    (BARs). Thus, this block of code first calls ![](httpatomoreillycomsourcenostarchimages1137507.png)
    `PCIR_BAR(0)` to get the address of the first BAR. Then it passes that address
    as the ![](httpatomoreillycomsourcenostarchimages1137509.png) `rid` argument to
    `bus_alloc_resource_any`, thereby acquiring I/O access to the device’s registers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码获取 `ipmi(4)` 的 I/O 区域访问权限。在描述此代码之前，需要了解一些关于 PCI 设备的背景信息。启动后，PCI 设备可以将它们的设备寄存器重新映射到不同的位置，从而避免与其他设备发生地址冲突。因此，PCI
    设备将它们的 I/O 映射寄存器的大小和当前位置存储在其基本地址寄存器 (BARs) 中。因此，此代码块首先调用 ![PCIR_BAR(0)](http://atomoreilly.com/source/nostarch/images/1137507.png)
    以获取第一个 BAR 的地址。然后，它将此地址作为 ![rid](http://atomoreilly.com/source/nostarch/images/1137509.png)
    参数传递给 `bus_alloc_resource_any`，从而获取对设备寄存器的 I/O 访问权限。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be accurate, the `PCIR_BAR(x`) macro returns the RID of the `x`th BAR.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确起见，`PCIR_BAR(x)` 宏返回第 x 个 BAR 的 RID。
- en: The remainder of `ipmi_pci_attach` ![](httpatomoreillycomsourcenostarchimages1137511.png)
    acquires an IRQ, starts up ![](httpatomoreillycomsourcenostarchimages1137513.png)
    KCS or ![](httpatomoreillycomsourcenostarchimages1137515.png) SMIC mode, and calls
    ![](httpatomoreillycomsourcenostarchimages1137517.png) `ipmi_attach` to finish
    initializing the device.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipmi_pci_attach` 函数的剩余部分获取一个中断请求（IRQ），启动 KCS 或 SMIC 模式，并调用 `ipmi_attach` 以完成设备的初始化。'
- en: ipmi2_pci_probe Function
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ipmi2_pci_probe` 函数'
- en: 'The `ipmi2_pci_probe` function is the `device_probe` implementation for the
    second Newbus driver found in [Example 11-1](ch11.html#ipmi_underscore_pci.c "Example 11-1. ipmi_pci.c").
    Here is its function definition:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipmi2_pci_probe` 函数是 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1. ipmi_pci.c")
    中找到的第二个 Newbus 驱动程序的 `device_probe` 实现。以下是其函数定义：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function determines if `dev` is a ![](httpatomoreillycomsourcenostarchimages1137499.png)
    generic IPMI device on the PCI bus. If so, its verbose description is ![](httpatomoreillycomsourcenostarchimages1137501.png)
    set, and the success code ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `BUS_PROBE_GENERIC` is returned. In short, this driver handles any standard IPMI
    device on the PCI bus.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数确定 `dev` 是否是 PCI 总线上的通用 IPMI 设备。如果是，则设置其详细描述，并返回成功代码 `BUS_PROBE_GENERIC`。简而言之，此驱动程序处理
    PCI 总线上的任何标准 IPMI 设备。
- en: As you may have guessed, the first Newbus driver is a hack (that is to say,
    a workaround) for the Dell PE2650, because it does not adhere to the IPMI specification.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，第一个 Newbus 驱动程序是为 Dell PE2650 的一种变通方法（即一种解决方案），因为它不遵循 IPMI 规范。
- en: ipmi2_pci_attach Function
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ipmi2_pci_attach` 函数'
- en: 'The `ipmi2_pci_attach` function is the `device_attach` implementation for the
    second Newbus driver found in [Example 11-1](ch11.html#ipmi_underscore_pci.c "Example 11-1. ipmi_pci.c").
    Here is its function definition:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipmi2_pci_attach` 函数是 [示例 11-1](ch11.html#ipmi_underscore_pci.c "示例 11-1.
    ipmi_pci.c") 中找到的第二个 Newbus 驱动程序的 `device_attach` 实现。以下是其函数定义：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    examining `dev`’s programming interface to determine `ipmi(4)`’s mode of operation
    (either SMIC or KCS). Then ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `PCIR_BAR(0)` is called to obtain the address of the first BAR. From this BAR,
    `ipmi2_pci_attach` ![](httpatomoreillycomsourcenostarchimages1137503.png) identifies
    whether `ipmi(4)` requires ![](httpatomoreillycomsourcenostarchimages1137505.png)
    I/O port or ![](httpatomoreillycomsourcenostarchimages1137507.png) I/O memory
    access before ![](httpatomoreillycomsourcenostarchimages1137509.png) acquiring
    it. Lastly, `ipmi2_pci_attach` ![](httpatomoreillycomsourcenostarchimages1137511.png)
    obtains an IRQ, starts up ![](httpatomoreillycomsourcenostarchimages1137513.png)
    KCS or ![](httpatomoreillycomsourcenostarchimages1137515.png) SMIC mode, and calls
    ![](httpatomoreillycomsourcenostarchimages1137517.png) `ipmi_attach` to finish
    initializing `dev`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先检查 `dev` 的编程接口以确定 `ipmi(4)` 的工作模式（SMIC 或 KCS）。然后调用 `PCIR_BAR(0)` 获取第一个
    BAR 的地址。从这个 BAR 开始，`ipmi2_pci_attach` 确定在获取之前 `ipmi(4)` 是否需要 I/O 端口或 I/O 内存访问。最后，`ipmi2_pci_attach`
    获取一个中断请求，启动 KCS 或 SMIC 模式，并调用 `ipmi_attach` 以完成 `dev` 的初始化。
- en: Conclusion
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter examined the PCI code base for `ipmi(4)` and introduced two fundamentals.
    First, a single source file can contain more than one driver. Second, to acquire
    I/O region access, PCI drivers must first call `PCIR_BAR`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章检查了 `ipmi(4)` 的 PCI 代码库，并介绍了两个基本概念。首先，一个源文件可以包含多个驱动程序。其次，为了获取 I/O 区域访问权限，PCI
    驱动程序必须首先调用 `PCIR_BAR`。
