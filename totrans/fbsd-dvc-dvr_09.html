<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Case Study: Parallel Port Printer Driver"><div class="titlepage"><div><div><h1 class="title"><a id="case_study_colon_parallel_port_printer_d"/>Chapter 9. Case Study: Parallel Port Printer Driver</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id9"/><div class="mediaobject"><a id="I_mediaobject9_d1e16257"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>This chapter is the second case study in this book. In this chapter, we’ll go through <code class="literal">lpt(4)</code>, the parallel port printer driver. <code class="literal">lpt(4)</code>, by default, is configured to be interrupt-driven, which gives us an opportunity to go through a nontrivial interrupt handler. Aside from this, I chose to profile <code class="literal">lpt(4)</code> because it uses almost every topic described in the previous chapters. It’s also relatively short.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To improve readability, some of the variables and functions presented in this chapter have been renamed and restructured from their counterparts in the FreeBSD source.</p></div><div class="sect1" title="Code Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="code_analysis-id1"/>Code Analysis</h1></div></div></div><p><a class="xref" href="ch09.html#lpt.c" title="Example 9-1. lpt.c">Example 9-1</a> provides a terse, source-level overview of <code class="literal">lpt(4)</code>.</p><div class="example"><a id="lpt.c"/><p class="title">Example 9-1. lpt.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;

#include &lt;sys/conf.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/bus.h&gt;
#include &lt;sys/malloc.h&gt;
#include &lt;sys/syslog.h&gt;

#include &lt;machine/bus.h&gt;
#include &lt;sys/rman.h&gt;
#include &lt;machine/resource.h&gt;

#include &lt;dev/ppbus/ppbconf.h&gt;
#include "ppbus_if.h"
#include &lt;dev/ppbus/ppbio.h&gt;
#include &lt;dev/ppbus/ppb_1284.h&gt;

#include &lt;dev/ppbus/lpt.h&gt;
#include &lt;dev/ppbus/lptio.h&gt;

#define LPT_NAME        "lpt"           /* official driver name.        */
#define LPT_INIT_READY  4               /* wait up to 4 seconds.        */
#define LPT_PRI         (PZERO + 8)     /* priority.                    */
#define BUF_SIZE        1024            /* sc_buf size.                 */
#define BUF_STAT_SIZE   32              /* sc_buf_stat size.            */

struct lpt_data {
        short                   sc_state;
        char                    sc_primed;
        struct callout          sc_callout;
        u_char                  sc_ticks;
        int                     sc_irq_rid;
        struct resource        *sc_irq_resource;
        void                   *sc_irq_cookie;
        u_short                 sc_irq_status;
        void                   *sc_buf;
        void                   *sc_buf_stat;
        char                   *sc_cp;
        device_t                sc_dev;
        struct cdev            *sc_cdev;
        struct cdev            *sc_cdev_bypass;
        char                    sc_flags;
        u_char                  sc_control;
        short                   sc_transfer_count;
};

/* bits for sc_state. */
#define LP_OPEN         (1 &lt;&lt; 0)        /* device is open.              */
#define LP_ERROR        (1 &lt;&lt; 2)        /* error received from printer. */
#define LP_BUSY         (1 &lt;&lt; 3)        /* printer is busy writing.     */
#define LP_TIMEOUT      (1 &lt;&lt; 5)        /* timeout enabled.             */
#define LP_INIT         (1 &lt;&lt; 6)        /* initializing in lpt_open.    */
#define LP_INTERRUPTED  (1 &lt;&lt; 7)        /* write call was interrupted.  */
#define LP_HAVEBUS      (1 &lt;&lt; 8)        /* driver owns the bus.         */

/* bits for sc_ticks. */
#define LP_TOUT_INIT    10              /* initial timeout: 1/10 sec.   */
#define LP_TOUT_MAX     1               /* max timeout: 1/1 sec.        */

/* bits for sc_irq_status. */
#define LP_HAS_IRQ      0x01            /* we have an IRQ available.    */
#define LP_USE_IRQ      0x02            /* our IRQ is in use.           */
#define LP_ENABLE_IRQ   0x04            /* enable our IRQ on open.      */
#define LP_ENABLE_EXT   0x10            /* enable extended mode.        */

/* bits for sc_flags. */
#define LP_NO_PRIME     0x10            /* don't prime the printer.     */
#define LP_PRIME_OPEN   0x20            /* prime on every open.         */
#define LP_AUTO_LF      0x40            /* automatic line feed.         */
#define LP_BYPASS       0x80            /* bypass printer ready checks. */

/* masks to interrogate printer status. */
#define LP_READY_MASK   (LPS_NERR | LPS_SEL | LPS_OUT | LPS_NBSY)
#define LP_READY        (LPS_NERR | LPS_SEL |           LPS_NBSY)

/* used in polling code. */
#define LPS_INVERT      (LPS_NERR | LPS_SEL |           LPS_NACK | LPS_NBSY)
#define LPS_MASK        (LPS_NERR | LPS_SEL | LPS_OUT | LPS_NACK | LPS_NBSY)
#define NOT_READY(bus)  ((ppb_rstr(bus) ^ LPS_INVERT) &amp; LPS_MASK)
#define MAX_SPIN        20              /* wait up to 20 usec.          */
#define MAX_SLEEP       (hz * 5)        /* timeout while waiting.       */

static d_open_t                 lpt_open;
static d_close_t                lpt_close;
static d_read_t                 lpt_read;
static d_write_t                lpt_write;
static d_ioctl_t                lpt_ioctl;

static struct cdevsw lpt_cdevsw = {
        .d_version =            D_VERSION,
        .d_open =               lpt_open,
        .d_close =              lpt_close,
        .d_read =               lpt_read,
        .d_write =              lpt_write,
        .d_ioctl =              lpt_ioctl,
        .d_name =               LPT_NAME
};

static devclass_t lpt_devclass;

static void
lpt_identify(driver_t *driver, device_t parent)
{
...
}

static int
lpt_request_ppbus(device_t dev, int how)
{
...
}

static int
lpt_release_ppbus(device_t dev)
{
...
}

static int
lpt_port_test(device_t ppbus, u_char data, u_char mask)
{
...
}

static int
lpt_detect(device_t dev)
{
...
}

static int
lpt_probe(device_t dev)
{
...
}

static void
lpt_intr(void *arg)
{
...
}

static int
lpt_attach(device_t dev)
{
...
}

static int
lpt_detach(device_t dev)
{
...
}

static void
lpt_timeout(void *arg)
{
...
}

static int
lpt_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
{
...
}

static int
lpt_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
{
...
}

static int
lpt_read(struct cdev *dev, struct uio *uio, int ioflag)
{
...
}

static int
lpt_push_bytes(struct lpt_data *sc)
{
...
}

static int
lpt_write(struct cdev *dev, struct uio *uio, int ioflag)
{
...
}

static int
lpt_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
    struct thread *td)
{
...
}

static device_method_t lpt_methods[] = {
        DEVMETHOD(device_identify,      lpt_identify),
        DEVMETHOD(device_probe,         lpt_probe),
        DEVMETHOD(device_attach,        lpt_attach),
        DEVMETHOD(device_detach,        lpt_detach),
        { 0, 0 }
};

static driver_t lpt_driver = {
        LPT_NAME,
        lpt_methods,
        sizeof(struct lpt_data)
};

DRIVER_MODULE(lpt, ppbus, lpt_driver, lpt_devclass, 0, 0);
MODULE_DEPEND(lpt, ppbus, 1, 1, 1);</pre></div></div><p><a class="xref" href="ch09.html#lpt.c" title="Example 9-1. lpt.c">Example 9-1</a> is provided as a convenience; as I go through the code for lpt(4) you can refer to it to see how <code class="literal">lpt(4)</code>’s functions and structures are laid out.<a class="indexterm" id="IDX-CHP-9-0001"/><a class="indexterm" id="IDX-CHP-9-0002"/><a class="indexterm" id="IDX-CHP-9-0003"/><a class="indexterm" id="IDX-CHP-9-0004"/></p><p>To make things easier to follow, I’ll analyze the functions in <code class="literal">lpt(4)</code> in the approximate order they would execute in (rather than in the order they appear). To that end, I’ll begin with the <code class="literal">lpt_identify</code> function.</p><div class="sect2" title="lpt_identify Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_identify_function"/>lpt_identify Function</h2></div></div></div><p>The <code class="literal">lpt_identify</code> function is the <code class="literal">device_identify</code> implementation for <code class="literal">lpt(4)</code>. Logically, this function is required because the parallel port cannot identify its children unaided.</p><p>Here is the function definition for <code class="literal">lpt_identify</code>:</p><a id="I_programlisting9_d1e16343"/><pre class="programlisting">static void
lpt_identify(driver_t *driver, device_t parent)
{
        device_t dev;

        dev = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>device_find_child(parent, <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>LPT_NAME, −1);
        if (!dev)
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>BUS_ADD_CHILD(parent, 0, LPT_NAME, −1);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16365"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> determines whether the parallel port has (ever) identified a child device named <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16371"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">LPT_NAME</code>. If it has not, then <code class="literal">lpt_identify</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16383"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> adds <code class="literal">LPT_NAME</code> to the parallel port’s list of identified children.</p></div><div class="sect2" title="lpt_probe Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_probe_function"/>lpt_probe Function</h2></div></div></div><p>The <code class="literal">lpt_probe</code> function is the <code class="literal">device_probe</code> implementation for <code class="literal">lpt(4)</code>. Here is its function definition:</p><a id="I_programlisting9_d1e16407"/><pre class="programlisting">static int
lpt_probe(device_t dev)
{
        if (!<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>lpt_detect(dev))
                return (ENXIO);

        device_set_desc(dev, "Printer");

        return (BUS_PROBE_SPECIFIC);
}</pre><p>This function simply calls <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16417"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">lpt_detect</code> to detect (that is, probe for) the presence of a printer.</p></div><div class="sect2" title="lpt_detect Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_detect_function"/>lpt_detect Function</h2></div></div></div><p>As mentioned in the previous section, <code class="literal">lpt_detect</code> detects the presence of a printer. It works by writing to the parallel port’s data register. If a printer is present, it can read back the value just written.<a class="indexterm" id="IDX-CHP-9-0005"/><a class="indexterm" id="IDX-CHP-9-0006"/><a class="indexterm" id="IDX-CHP-9-0007"/></p><p>Here is the function definition for <code class="literal">lpt_detect</code>:</p><a id="I_programlisting9_d1e16452"/><pre class="programlisting">static int
lpt_detect(device_t dev)
{
        device_t ppbus = device_get_parent(dev);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>static u_char test[18] = {
                0x55,                   /* alternating zeros.   */
                0xaa,                   /* alternating ones.    */
                0xfe, 0xfd, 0xfb, 0xf7,
                0xef, 0xdf, 0xbf, 0x7f, /* walking zero.        */
                0x01, 0x02, 0x04, 0x08,
                0x10, 0x20, 0x40, 0x80  /* walking one.         */
        };
        int i, error, success = 1;      /* assume success.      */

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ppb_lock(ppbus);

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>lpt_request_ppbus(dev, PPB_DONTWAIT);
        if (error) {
                ppb_unlock(ppbus);
                device_printf(dev, "cannot allocate ppbus (%d)!\n", error);
                return (0);
        }

        for (i = 0; i &lt; 18; i++)
                if (!<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>lpt_port_test(ppbus, test[i], 0xff)) {
                        success = 0;
                        break;
                }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>ppb_wdtr(ppbus, 0);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>ppb_wctr(ppbus, 0);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>lpt_release_ppbus(dev);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>ppb_unlock(ppbus);

        return (success);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16505"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> acquires the parallel port mutex. Next, <code class="literal">lpt(4)</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16514"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> assigned ownership of the parallel port. Then <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16520"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">lpt_port_test</code> is called to write to and read from the parallel port’s data register. The values written to this 8-bit register are housed in <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16530"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">test[]</code> and are designed to toggle all 8 bits.</p><p>Once this is done, the parallel port’s <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16541"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> data and <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16547"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> control registers are cleared, ownership of the parallel port is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16553"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> relinquished, and the parallel port mutex is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16559"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> released.<a class="indexterm" id="IDX-CHP-9-0008"/><a class="indexterm" id="IDX-CHP-9-0009"/><a class="indexterm" id="IDX-CHP-9-0010"/><a class="indexterm" id="IDX-CHP-9-0011"/><a class="indexterm" id="IDX-CHP-9-0012"/></p></div><div class="sect2" title="lpt_port_test Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_port_underscore_test_func"/>lpt_port_test Function</h2></div></div></div><p>The <code class="literal">lpt_port_test</code> function is called by <code class="literal">lpt_detect</code> to determine whether a printer is present. Here is its function definition:</p><a id="I_programlisting9_d1e16602"/><pre class="programlisting">static int
lpt_port_test(device_t ppbus, <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>u_char data, u_char mask)
{
        int temp, timeout = 10000;

        data &amp;= mask;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ppb_wdtr(ppbus, data);

        do {
                DELAY(10);
                temp = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ppb_rdtr(ppbus) &amp; mask;
        } while (temp != data &amp;&amp; --timeout);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>return (temp == data);
}</pre><p>This function takes an <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16630"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> 8-bit value and <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16636"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> writes it to the parallel port’s data register. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16642"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> reads from that register and <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16648"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> returns whether the value written and read match.</p></div><div class="sect2" title="lpt_attach Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_attach_function"/>lpt_attach Function</h2></div></div></div><p>The <code class="literal">lpt_attach</code> function is the <code class="literal">device_attach</code> implementation for <code class="literal">lpt(4)</code>. Here is its function definition:</p><a id="I_programlisting9_d1e16668"/><pre class="programlisting">static int
lpt_attach(device_t dev)
{
        device_t ppbus = device_get_parent(dev);
        struct lpt_data *sc = device_get_softc(dev);
        int error, unit = device_get_unit(dev);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>sc-&gt;sc_primed = 0;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ppb_init_callout(ppbus, &amp;sc-&gt;sc_callout, 0);

        ppb_lock(ppbus);
        error = lpt_request_ppbus(dev, PPB_DONTWAIT);
        if (error) {
                ppb_unlock(ppbus);
                device_printf(dev, "cannot allocate ppbus (%d)!\n", error);
                return (0);
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ppb_wctr(ppbus, LPC_NINIT);

        lpt_release_ppbus(dev);
        ppb_unlock(ppbus);

        /* Declare our interrupt handler. */
        sc-&gt;sc_irq_rid = 0;
        sc-&gt;sc_irq_resource = bus_alloc_resource_any(dev, SYS_RES_IRQ,
            &amp;sc-&gt;sc_irq_rid, RF_ACTIVE | RF_SHAREABLE);

        /* Register our interrupt handler. */
        if (sc-&gt;sc_irq_resource) {
                error = bus_setup_intr(dev, sc-&gt;sc_irq_resource,
                    INTR_TYPE_TTY | INTR_MPSAFE, NULL, <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>lpt_intr,
                    sc, &amp;sc-&gt;sc_irq_cookie);
                if (error) {
                        bus_release_resource(dev, SYS_RES_IRQ,
                            sc-&gt;sc_irq_rid, sc-&gt;sc_irq_resource);
                        device_printf(dev,
                            "unable to register interrupt handler\n");
                        return (error);
                }

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>sc-&gt;sc_irq_status = LP_HAS_IRQ | LP_USE_IRQ | LP_ENABLE_IRQ;
                device_printf(dev, "interrupt-driven port\n");
        } else {
                sc-&gt;sc_irq_status = 0;
                device_printf(dev, "polled port\n");
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>sc-&gt;sc_buf = malloc(BUF_SIZE, M_DEVBUF, M_WAITOK);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>sc-&gt;sc_buf_stat = malloc(BUF_STAT_SIZE, M_DEVBUF, M_WAITOK);

        sc-&gt;sc_dev = dev;

        sc-&gt;sc_cdev = make_dev(&amp;lpt_cdevsw, unit, UID_ROOT, GID_WHEEL, 0600,
            LPT_NAME "%d", unit);
        sc-&gt;sc_cdev-&gt;si_drv1 = sc;
        sc-&gt;sc_cdev-&gt;si_drv2 = 0;

        sc-&gt;sc_cdev_bypass = make_dev(&amp;lpt_cdevsw, unit, UID_ROOT, GID_WHEEL,
            0600, LPT_NAME "%d.ctl", unit);
        sc-&gt;sc_cdev_bypass-&gt;si_drv1 = sc;
        sc-&gt;sc_cdev_bypass-&gt;si_drv2 = (void *)<img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>LP_BYPASS;

        return (0);
}</pre><p>This function can be split into five parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16721"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> sets <code class="literal">sc-&gt;sc_primed</code> to <code class="literal">0</code> to indicate that the printer needs to be primed. It also <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16733"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> initializes <code class="literal">lpt(4)</code>’s <code class="literal">callout</code> structure. The second part essentially <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16746"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> changes the electrical signal at pin 16, dubbed <span class="emphasis"><em>nINIT</em></span>, from high to low causing the printer to initiate an internal reset.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>As most signals are active high, the <span class="emphasis"><em>n</em></span> in <span class="emphasis"><em>nINIT</em></span> denotes that the signal is active low.<a class="indexterm" id="IDX-CHP-9-0013"/><a class="indexterm" id="IDX-CHP-9-0014"/></p></div><p>The third part registers the function <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16776"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">lpt_intr</code> as the interrupt handler. If successful, the <code class="literal">variable sc-&gt;sc_irq_status</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16788"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> assigned <code class="literal">LP_HAS_IRQ</code>, <code class="literal">LP_USE_IRQ</code>, and <code class="literal">LP_ENABLE_IRQ</code> to indicate that the printer is interrupt-driven. The fourth part allocates memory for two buffers: <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16804"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">sc-&gt;sc_buf</code> (which will maintain the data to be printed) and <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16813"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">sc-&gt;sc_buf_stat</code> (which will maintain the printer’s status). Finally, the fifth part creates <code class="literal">lpt(4)</code>’s device nodes: <code class="literal">lpt%d</code> and <code class="literal">lpt%d.ctl</code>, where <code class="literal">%d</code> is the unit number. Note that <code class="literal">lpt%d.ctl</code> contains the <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16838"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">LP_BYPASS</code> flag, while <code class="literal">lpt%d</code> does not. In the <code class="literal">d_foo</code> functions, <code class="literal">LP_BYPASS</code> is used to tell <code class="literal">lpt%d.ctl</code> from <code class="literal">lpt%d</code>. As you’ll see, the <code class="literal">lpt%d</code> device node represents the printer, while <code class="literal">lpt%d.ctl</code> is used solely to change the printer’s mode of operation (via <code class="literal">lpt(4)</code>’s <code class="literal">d_ioctl</code> routine).</p></div><div class="sect2" title="lpt_detach Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_detach_function"/>lpt_detach Function</h2></div></div></div><p>The <code class="literal">lpt_detach</code> function is the <code class="literal">device_detach</code> implementation for <code class="literal">lpt(4)</code>. Here is its function definition:</p><a id="I_programlisting9_d1e16890"/><pre class="programlisting">static int
lpt_detach(device_t dev)
{
        device_t ppbus = device_get_parent(dev);
        struct lpt_data *sc = device_get_softc(dev);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>destroy_dev(sc-&gt;sc_cdev_bypass);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>destroy_dev(sc-&gt;sc_cdev);

        ppb_lock(ppbus);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>lpt_release_ppbus(dev);
        ppb_unlock(ppbus);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>callout_drain(&amp;sc-&gt;sc_callout);

        if (sc-&gt;sc_irq_resource) {
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>bus_teardown_intr(dev, sc-&gt;sc_irq_resource,
                    sc-&gt;sc_irq_cookie);
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>bus_release_resource(dev, SYS_RES_IRQ, sc-&gt;sc_irq_rid,
                    sc-&gt;sc_irq_resource);
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>free(sc-&gt;sc_buf_stat, M_DEVBUF);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>free(sc-&gt;sc_buf, M_DEVBUF);

        return (0);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16943"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16949"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> destroying <code class="literal">lpt(4)</code>’s device nodes. Once this is done, it <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16958"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> relinquishes ownership of the parallel port, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16964"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> drains <code class="literal">lpt(4)</code>’s callout function, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16974"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> tears down <code class="literal">lpt(4)</code>’s interrupt handler, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16983"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> releases <code class="literal">lpt(4)</code>’s IRQ, and <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16992"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e16999"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> frees the allocated memory.</p></div><div class="sect2" title="lpt_open Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_open_function"/>lpt_open Function</h2></div></div></div><p>The <code class="literal">lpt_open</code> function is defined in <code class="literal">lpt_cdevsw</code> (that is, <code class="literal">lpt(4)</code>’s character device switch table) as the <code class="literal">d_open</code> operation. Recall that <code class="literal">d_open</code> operations prepare the device for I/O.<a class="indexterm" id="IDX-CHP-9-0015"/><a class="indexterm" id="IDX-CHP-9-0016"/></p><p>Here is the function definition for <code class="literal">lpt_open</code>:</p><a id="I_programlisting9_d1e17042"/><pre class="programlisting">static int
lpt_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
{
        struct lpt_data *sc = dev-&gt;si_drv1;
        device_t lpt_dev = sc-&gt;sc_dev;
        device_t ppbus = device_get_parent(lpt_dev);
        int try, error;

        if (!sc)
                return (ENXIO);

        ppb_lock(ppbus);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_state) {
                ppb_unlock(ppbus);
                return (EBUSY);
        } else
                sc-&gt;sc_state |= LP_INIT;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>sc-&gt;sc_flags = (uintptr_t)dev-&gt;si_drv2;
        if (sc-&gt;sc_flags &amp; LP_BYPASS) {
                sc-&gt;sc_state = LP_OPEN;
                ppb_unlock(ppbus);
                return (0);
        }

        error = lpt_request_ppbus(lpt_dev, PPB_WAIT | PPB_INTR);
        if (error) {
                sc-&gt;sc_state = 0;
                ppb_unlock(ppbus);
                return (error);
        }

        /* Use our IRQ? */
        if (sc-&gt;sc_irq_status &amp; LP_ENABLE_IRQ)
                sc-&gt;sc_irq_status |= LP_USE_IRQ;
        else
                sc-&gt;sc_irq_status &amp;= ˜LP_USE_IRQ;

        /* Reset printer. */
        if ((sc-&gt;sc_flags &amp; LP_NO_PRIME) == 0)
                if ((sc-&gt;sc_flags &amp; LP_PRIME_OPEN) || sc-&gt;sc_primed == 0) {
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ppb_wctr(ppbus, 0);
                        sc-&gt;sc_primed++;
                        DELAY(500);
                }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ppb_wctr(ppbus, LPC_SEL | LPC_NINIT);

        /* Wait until ready--printer should be running diagnostics. */
        try = 0;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>do {
                /* Give up? */
                if (try++ &gt;= (LPT_INIT_READY * 4)) {
                        lpt_release_ppbus(lpt_dev);
                        sc-&gt;sc_state = 0;
                        ppb_unlock(ppbus);
                        return (EBUSY);
                }

                /* Wait 1/4 second. Give up if we get a signal. */
                if (ppb_sleep(ppbus, lpt_dev, LPT_PRI | PCATCH, "lpt_open",
                    hz / 4) != EWOULDBLOCK) {
                        lpt_release_ppbus(lpt_dev);
                        sc-&gt;sc_state = 0;
                        ppb_unlock(ppbus);
                        return (EBUSY);
                }
        } <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>while ((ppb_rstr(ppbus) &amp; LP_READY_MASK) != LP_READY);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>sc-&gt;sc_control = LPC_SEL | LPC_NINIT;
        if (sc-&gt;sc_flags &amp; LP_AUTO_LF)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>sc-&gt;sc_control |= LPC_AUTOL;
        if (sc-&gt;sc_irq_status &amp; LP_USE_IRQ)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>sc-&gt;sc_control |= LPC_ENA;

        ppb_wctr(ppbus, sc-&gt;sc_control);

        sc-&gt;sc_state &amp;= ˜LP_INIT;
        sc-&gt;sc_state |= LP_OPEN;
        sc-&gt;sc_transfer_count = 0;

        if (sc-&gt;sc_irq_status &amp; LP_USE_IRQ) {
                sc-&gt;sc_state |= LP_TIMEOUT;
                sc-&gt;sc_ticks = hz / LP_TOUT_INIT;
                callout_reset(&amp;sc-&gt;sc_callout, sc-&gt;sc_ticks,
                   <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>lpt_timeout, sc);
        }

        lpt_release_ppbus(lpt_dev);
        ppb_unlock(ppbus);

        return (0);
}</pre><p>This function can be split into six parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17107"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks the value of <code class="literal">sc-&gt;sc_state</code>. If it does not equal <code class="literal">0</code>, which implies that another process has opened the printer, the error code <code class="literal">EBUSY</code> is returned; otherwise, <code class="literal">sc-&gt;sc_state</code> is assigned <code class="literal">LP_INIT</code>. The second part <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17129"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> checks the value of <code class="literal">dev-&gt;si_drv2</code>.<a class="indexterm" id="IDX-CHP-9-0017"/></p><p>If it contains the <code class="literal">LP_BYPASS</code> flag, which indicates that the device node is <code class="literal">lpt%d.ctl, sc-&gt;sc_state</code> is set to <code class="literal">LP_OPEN</code> and <code class="literal">lpt_open</code> exits. Recall that <code class="literal">lpt%d.ctl</code> is used solely to change the printer’s mode of operation, hence the minute amount of preparatory work. The third part <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17159"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> primes the printer and then <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17165"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> selects and resets the printer (a printer prepares to receive data when it’s selected, which occurs when the electrical signal at pin 17, dubbed <span class="emphasis"><em>nSELIN</em></span>, changes from high to low). The fourth part <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17174"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> waits for the printer to <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17180"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> finish its internal reset. The fifth part <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17186"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> selects and resets the printer, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17193"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> enables automatic line feed if requested,<sup>[<a class="footnote" href="#ftn.CHP-9-FN-1" id="CHP-9-FN-1">8</a>]</sup> and <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17203"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> enables interrupts if the printer is interrupt-driven. The fifth part also assigns <code class="literal">LP_OPEN</code> to <code class="literal">sc-&gt;sc_state</code> and zeroes the variable <code class="literal">sc-&gt;sc_transfer_count</code>.<a class="indexterm" id="IDX-CHP-9-0018"/><a class="indexterm" id="IDX-CHP-9-0019"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Automatic line feed is enabled when the electrical signal at pin 14, dubbed nAUTOF, changes from high to low. As you would expect, this causes the printer to automatically insert a line feed after each line.</p></div><p>Finally, the sixth part causes <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17234"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">lpt_timeout</code> to execute one time after <code class="literal">sc-&gt;sc_ticks</code> / <code class="literal">hz</code> seconds. The <code class="literal">lpt_timeout</code> function is used alongside the interrupt handler <code class="literal">lpt_intr</code>. I’ll discuss these functions shortly.</p></div><div class="sect2" title="lpt_read Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_read_function"/>lpt_read Function</h2></div></div></div><p>The <code class="literal">lpt_read</code> function retrieves the printer’s status. Users can get the printer’s status by applying the <code class="literal">cat(1)</code> command to the device node <code class="literal">lpt%d</code>.</p><p>Here is the function definition for <code class="literal">lpt_read</code>:</p><a id="I_programlisting9_d1e17275"/><pre class="programlisting">static int
lpt_read(struct cdev *dev, struct uio *uio, int ioflag)
{
        struct lpt_data *sc = dev-&gt;si_drv1;
        device_t lpt_dev = sc-&gt;sc_dev;
        device_t ppbus = device_get_parent(lpt_dev);
        int num, error = 0;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_flags &amp; LP_BYPASS)
                return (EPERM);

        ppb_lock(ppbus);
        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ppb_1284_negociate(ppbus, <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>PPB_NIBBLE, 0);
        if (error) {
                ppb_unlock(ppbus);
                return (error);
        }

        num = 0;
        while (uio-&gt;uio_resid) {
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ppb_1284_read(ppbus, PPB_NIBBLE,
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>sc-&gt;sc_buf_stat,
                    min(BUF_STAT_SIZE, uio-&gt;uio_resid), <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>&amp;num);
                if (error)
                        goto end_read;

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>if (!num)
                        goto end_read;

                ppb_unlock(ppbus);
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>uiomove(<img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>sc-&gt;sc_buf_stat, num, <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>uio);
                ppb_lock(ppbus);
                if (error)
                        goto end_read;
        }

end_read:
        ppb_1284_terminate(ppbus);
        ppb_unlock(ppbus);
        return (error);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17340"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks the value of <code class="literal">sc-&gt;sc_flags</code>. If it contains the <code class="literal">LP_BYPASS</code> flag, which indicates that the device node is <code class="literal">lpt%d.ctl</code>, the error code <code class="literal">EPERM</code> (which stands for <span class="emphasis"><em>error: operation not permitted</em></span>) is returned. Next, the function <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17362"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">ppb_1284_negociate</code> is called to put the parallel port interface into <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17371"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> nibble mode.<a class="indexterm" id="IDX-CHP-9-0020"/><a class="indexterm" id="IDX-CHP-9-0021"/><a class="indexterm" id="IDX-CHP-9-0022"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Nibble mode is the most common way to retrieve data from a printer. Normally, pins 10, 11, 12, 13, and 15 are used by the printer as external status indicators; however, in nibble mode these pins are used to send data to the host (4 bits at a time).</p></div><p>The remainder of this function transfers data from the printer to user space. The data in this case is the printer’s status. Here, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17395"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">ppb_1284_read</code> transfers data from the printer to <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17404"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> kernel space. The number of bytes transferred is saved in <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17410"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">num</code>. If <code class="literal">num</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17423"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> equals <code class="literal">0</code>, <code class="literal">lpt_read</code> exits. The <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17435"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">uiomove</code> function then moves the data from <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17445"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> kernel space to <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17451"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> user space.</p></div><div class="sect2" title="lpt_write Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_write_function"/>lpt_write Function</h2></div></div></div><p>The <code class="literal">lpt_write</code> function acquires data from user space and stores it in <code class="literal">sc-&gt;sc_buf</code>. This data is then sent to the printer to be printed.</p><p>Here is the function definition for <code class="literal">lpt_write</code>:</p><a id="I_programlisting9_d1e17473"/><pre class="programlisting">static int
lpt_write(struct cdev *dev, struct uio *uio, int ioflag)
{
        struct lpt_data *sc = dev-&gt;si_drv1;
        device_t lpt_dev = sc-&gt;sc_dev;
        device_t ppbus = device_get_parent(lpt_dev);
        register unsigned num;
        int error;

        if (sc-&gt;sc_flags &amp; LP_BYPASS)
                return (EPERM);

        ppb_lock(ppbus);
        error = lpt_request_ppbus(lpt_dev, PPB_WAIT | PPB_INTR);
        if (error) {
                ppb_unlock(ppbus);
                return (error);
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>sc-&gt;sc_state &amp;= ˜LP_INTERRUPTED;
        while (<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>(num = min(BUF_SIZE, uio-&gt;uio_resid))) {
                sc-&gt;sc_cp = sc-&gt;sc_buf;

                ppb_unlock(ppbus);
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>uiomove(sc-&gt;sc_cp, num, uio);
                ppb_lock(ppbus);
                if (error)
                        break;

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>sc-&gt;sc_transfer_count = num;

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>if (sc-&gt;sc_irq_status &amp; LP_ENABLE_EXT) {
                        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>ppb_write(ppbus, sc-&gt;sc_cp,
                            sc-&gt;sc_transfer_count, 0);
                        switch (error) {
                        case 0:
                                sc-&gt;sc_transfer_count = 0;
                                break;
                        case EINTR:
                                sc-&gt;sc_state |= LP_INTERRUPTED;
                                ppb_unlock(ppbus);
                                return (error);
                        case EINVAL:
                                log(LOG_NOTICE,
                                    "%s: extended mode not available\n",
                                    device_get_nameunit(lpt_dev));
                                break;
                        default:
                                ppb_unlock(ppbus);
                                return (error);
                        }
                } else while ((sc-&gt;sc_transfer_count &gt; 0) &amp;&amp;
                             <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>(sc-&gt;sc_irq_status &amp; LP_USE_IRQ)) {
                        if (!(sc-&gt;sc_state &amp; LP_BUSY))
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>lpt_intr(sc);

                        if (sc-&gt;sc_state &amp; LP_BUSY) {
                                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>ppb_sleep(ppbus, lpt_dev,
                                    LPT_PRI | PCATCH, "lpt_write", 0);
                                if (error) {
                                        sc-&gt;sc_state |= LP_INTERRUPTED;
                                        ppb_unlock(ppbus);
                                        return (error);
                                }
                        }
                }

                if (!(sc-&gt;sc_irq_status &amp; LP_USE_IRQ) &amp;&amp;
                     (sc-&gt;sc_transfer_count)) {
                        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>lpt_push_bytes(sc);
                        if (error) {
                                ppb_unlock(ppbus);
                                return (error);
                        }
                }
        }

        lpt_release_ppbus(lpt_dev);
        ppb_unlock(ppbus);

        return (error);
}</pre><p>Like <code class="literal">lpt_read</code>, this function starts by checking the value of <code class="literal">sc-&gt;sc_flags</code>. If it contains the <code class="literal">LP_BYPASS</code> flag, the error code <code class="literal">EPERM</code> is returned. Next, the <code class="literal">LP_INTERRUPTED</code> flag is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17554"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> removed from <code class="literal">sc-&gt;sc_state</code> (as you’ll see, <code class="literal">LP_INTERRUPTED</code> is added to <code class="literal">sc-&gt;sc_state</code> whenever a write operation is interrupted). The following <code class="literal">while</code> loop contains the bulk of <code class="literal">lpt_write</code>. Note that its <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17576"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> expression determines the amount of data to <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17582"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> copy from user space to kernel space. This amount is saved in <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17588"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">sc-&gt;sc_transfer_count</code>, which is decremented each time a byte is sent to the printer.<a class="indexterm" id="IDX-CHP-9-0023"/><a class="indexterm" id="IDX-CHP-9-0024"/><a class="indexterm" id="IDX-CHP-9-0025"/><a class="indexterm" id="IDX-CHP-9-0026"/><a class="indexterm" id="IDX-CHP-9-0027"/></p><p>Now, there are three ways to transfer data from kernel space to the printer. First, if extended mode is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17619"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> enabled, <code class="literal">lpt_write</code> can <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17628"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> write directly to the printer.<a class="indexterm" id="IDX-CHP-9-0028"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Extended mode refers to either Enhanced Parallel Port (EPP) or Extended Capabilities Port (ECP) mode. EPP and ECP modes are designed to transmit data faster and with less CPU overhead than normal parallel port communications. Most parallel ports support one or both of these modes.<a class="indexterm" id="IDX-CHP-9-0029"/><a class="indexterm" id="IDX-CHP-9-0030"/></p></div><p>Second, if the printer is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17648"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> interrupt-driven and the <code class="literal">LP_BUSY</code> flag is cleared in <code class="literal">sc-&gt;sc_state</code>, <code class="literal">lpt_write</code> can call <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17663"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">lpt_intr</code> to transfer data to the printer. Looking at the function definition for <code class="literal">lpt_intr</code> in the following section, you’ll see that <code class="literal">LP_BUSY</code> is set during <code class="literal">lpt_intr</code>’s execution, and that <code class="literal">LP_BUSY</code> is not cleared until <code class="literal">sc-&gt;sc_transfer_count</code> is <code class="literal">0</code>. This prevents <code class="literal">lpt_write</code> from issuing another interrupt-driven transfer until the current one completes, which is why <code class="literal">lpt_write</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17698"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> sleeps.</p><p>Finally, if the first and second options are unavailable, <code class="literal">lpt_write</code> can issue a polled transfer by calling <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17709"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">lpt_push_bytes</code>, which is described in <a class="xref" href="ch09.html#lpt_underscore_push_underscore_bytes_fun" title="lpt_push_bytes Function">lpt_push_bytes Function</a> in <a class="xref" href="ch09.html#lpt_underscore_close_function" title="lpt_close Function">lpt_close Function</a>.</p></div><div class="sect2" title="lpt_intr Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_intr_function"/>lpt_intr Function</h2></div></div></div><p>The <code class="literal">lpt_intr</code> function is <code class="literal">lpt(4)</code>’s interrupt handler. This function transfers 1 byte from <code class="literal">sc-&gt;sc_buf</code> to the printer and then it exits. When the printer is ready for another byte, it will send an interrupt. Note that in <code class="literal">lpt_intr</code>, <code class="literal">sc-&gt;sc_buf</code> is accessed via <code class="literal">sc-&gt;sc_cp</code>.</p><p>Here is the function definition for <code class="literal">lpt_intr</code>:<a class="indexterm" id="IDX-CHP-9-0031"/></p><a id="I_programlisting9_d1e17754"/><pre class="programlisting">static void
lpt_intr(void *arg)
{
        struct lpt_data *sc = arg;
        device_t lpt_dev = sc-&gt;sc_dev;
        device_t ppbus = device_get_parent(lpt_dev);
        int i, status = 0;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>for (i = 0; i &lt; 100 &amp;&amp;
             ((status = ppb_rstr(ppbus)) &amp; LP_READY_MASK) != LP_READY; i++)
                ;       /* nothing. */

        if ((status &amp; LP_READY_MASK) == LP_READY) {
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>sc-&gt;sc_state = (sc-&gt;sc_state | LP_BUSY) &amp; ˜LP_ERROR;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sc-&gt;sc_ticks = hz / LP_TOUT_INIT;

                if (sc-&gt;sc_transfer_count) {
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ppb_wdtr(ppbus, *sc-&gt;sc_cp++);
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>ppb_wctr(ppbus, sc-&gt;sc_control | LPC_STB);
                        ppb_wctr(ppbus, sc-&gt;sc_control);

                        if (--(sc-&gt;sc_transfer_count) &gt; 0)
                               <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>return;
                }

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>sc-&gt;sc_state &amp;= ˜LP_BUSY;

                if (!(sc-&gt;sc_state &amp; LP_INTERRUPTED))
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>wakeup(lpt_dev);

                return;
        } else {
                if (((status &amp; (LPS_NERR | LPS_OUT)) != LPS_NERR) &amp;&amp;
                    (sc-&gt;sc_state &amp; LP_OPEN))
                        sc-&gt;sc_state |= LP_ERROR;
        }
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17807"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks ad nauseam that the printer is online and ready for output. If it is, the <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17813"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">LP_BUSY</code> flag is added to <code class="literal">sc-&gt;sc_state</code> and the <code class="literal">LP_ERROR</code> flag, which denotes a printer error, is removed. Next, <code class="literal">sc-&gt;sc_ticks</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17832"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> reset. Then 1 byte from <code class="literal">sc-&gt;sc_buf</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17841"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> written to the parallel port’s data register and subsequently <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17847"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> sent to the printer (data on the parallel port interface is sent to the printer when the electrical signal at pin 1, dubbed <span class="emphasis"><em>nSTROBE</em></span>, changes from high to low). If there is more data to send (that is, <code class="literal">sc-&gt;sc_transfer_count</code> is greater than <code class="literal">0</code>), <code class="literal">lpt_intr</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17866"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> exits, because it is protocol to wait for an interrupt before sending another byte. If there is no more data to send, <code class="literal">LP_BUSY</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17875"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> cleared from <code class="literal">sc-&gt;sc_state</code> and <code class="literal">lpt_write</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17888"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> woken up.</p></div><div class="sect2" title="lpt_timeout Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_timeout_function"/>lpt_timeout Function</h2></div></div></div><p>The <code class="literal">lpt_timeout</code> function is the callout function for <code class="literal">lpt(4)</code>. It is designed to deal with missed or unhandled interrupts. Here is its function definition:<a class="indexterm" id="IDX-CHP-9-0032"/><a class="indexterm" id="IDX-CHP-9-0033"/><a class="indexterm" id="IDX-CHP-9-0034"/><a class="indexterm" id="IDX-CHP-9-0035"/></p><a id="I_programlisting9_d1e17925"/><pre class="programlisting">static void
lpt_timeout(void *arg)
{
        struct lpt_data *sc = arg;
        device_t lpt_dev = sc-&gt;sc_dev;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_state &amp; LP_OPEN) {
                sc-&gt;sc_ticks++;
                if (sc-&gt;sc_ticks &gt; hz / LP_TOUT_MAX)
                        sc-&gt;sc_ticks = hz / LP_TOUT_MAX;
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>callout_reset(&amp;sc-&gt;sc_callout, sc-&gt;sc_ticks,
                    lpt_timeout, sc);
        } else
                sc-&gt;sc_state &amp;= ˜LP_TIMEOUT;

        if (sc-&gt;sc_state &amp; LP_ERROR)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sc-&gt;sc_state &amp;= ˜LP_ERROR;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (sc-&gt;sc_transfer_count)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>lpt_intr(sc);
        else {
                sc-&gt;sc_state &amp;= ˜LP_BUSY;
                wakeup(lpt_dev);
        }
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17959"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks whether <code class="literal">lpt%d</code> is open. If so, <code class="literal">lpt_timeout</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17971"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> reschedules itself to execute. Next, <code class="literal">LP_ERROR</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17981"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> removed from <code class="literal">sc-&gt;sc_state</code>. Now if <code class="literal">lpt(4)</code> has <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17993"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> missed an interrupt, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e17999"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">lpt_intr</code> is called to restart transferring data to the printer.</p><p>Note that without the <code class="literal">if</code> block at <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18013"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span>, <code class="literal">lpt(4)</code> would hang waiting for an interrupt that’s been sent and lost.</p></div><div class="sect2" title="lpt_push_bytes Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_push_underscore_bytes_fun"/>lpt_push_bytes Function</h2></div></div></div><p>The <code class="literal">lpt_push_bytes</code> function uses polling to transfer data to the printer. This function is called (by <code class="literal">lpt_write</code>) only if extended mode is disabled and the printer is not interrupt-driven.</p><p>Here is the function definition for <code class="literal">lpt_push_bytes</code>:</p><a id="I_programlisting9_d1e18038"/><pre class="programlisting">static int
lpt_push_bytes(struct lpt_data *sc)
{
        device_t lpt_dev = sc-&gt;sc_dev;
        device_t ppbus = device_get_parent(lpt_dev);
        int error, spin, tick;
        char ch;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>while (sc-&gt;sc_transfer_count &gt; 0) {
                ch = *sc-&gt;sc_cp;
                sc-&gt;sc_cp++;
                sc-&gt;sc_transfer_count--;

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>for (spin = 0; NOT_READY(ppbus) &amp;&amp; spin &lt; MAX_SPIN; spin++)
                        DELAY(1);

                if (spin &gt;= MAX_SPIN) {
                        tick = 0;
                        while (NOT_READY(ppbus)) {
                                tick = tick + tick + 1;
                                if (tick &gt; MAX_SLEEP)
                                        tick = MAX_SLEEP;

                                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ppb_sleep(ppbus, lpt_dev, LPT_PRI,
                                    "lpt_poll", tick);
                                if (error != EWOULDBLOCK)
                                        return (error);
                        }
                }

              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ppb_wdtr(ppbus, ch);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>ppb_wctr(ppbus, sc-&gt;sc_control | LPC_STB);
                ppb_wctr(ppbus, sc-&gt;sc_control);
        }

        return (0);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18072"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> verifies that there is data to transfer. Then it <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18078"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> polls the printer to see if it is online and ready for output. If the printer is not ready, <code class="literal">lpt_push_bytes</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18087"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> sleeps for a short period of time and then repolls the printer when it wakes up. This cycle of sleeping and polling is repeated until the printer is ready. If the printer is ready, 1 byte from <code class="literal">sc-&gt;sc_buf</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18097"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> written to the parallel port’s data register and then <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18103"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> sent to the printer. This entire process is repeated until all of the data in <code class="literal">sc-&gt;sc_buf</code> is transferred.<a class="indexterm" id="IDX-CHP-9-0036"/><a class="indexterm" id="IDX-CHP-9-0037"/></p></div><div class="sect2" title="lpt_close Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_close_function"/>lpt_close Function</h2></div></div></div><p>The <code class="literal">lpt_close</code> function is defined in <code class="literal">lpt_cdevsw</code> as the <code class="literal">d_close</code> operation. Here is its function definition:</p><a id="I_programlisting9_d1e18136"/><pre class="programlisting">static int
lpt_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
{
        struct lpt_data *sc = dev-&gt;si_drv1;
        device_t lpt_dev = sc-&gt;sc_dev;
        device_t ppbus = device_get_parent(lpt_dev);
        int error;

        ppb_lock(ppbus);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_flags &amp; LP_BYPASS)
                goto end_close;

        error = lpt_request_ppbus(lpt_dev, PPB_WAIT | PPB_INTR);
        if (error) {
                ppb_unlock(ppbus);
                return (error);
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (!(sc-&gt;sc_state &amp; LP_INTERRUPTED) &amp;&amp;
           <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>(sc-&gt;sc_irq_status &amp; LP_USE_IRQ))
                while ((ppb_rstr(ppbus) &amp; LP_READY_MASK) != LP_READY ||
                   <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>sc-&gt;sc_transfer_count)
                        if (ppb_sleep(ppbus, lpt_dev, LPT_PRI | PCATCH,
                            "lpt_close", hz) != EWOULDBLOCK)
                                break;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>sc-&gt;sc_state &amp;= ˜LP_OPEN;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>callout_stop(&amp;sc-&gt;sc_callout);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>ppb_wctr(ppbus, LPC_NINIT);

        lpt_release_ppbus(lpt_dev);

<img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/> end_close:
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>sc-&gt;sc_state = 0;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>sc-&gt;sc_transfer_count = 0;
        ppb_unlock(ppbus);
        return (0);
}</pre><p>Like <code class="literal">lpt_read</code> and <code class="literal">lpt_write</code>, this function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18207"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks the value of <code class="literal">sc-&gt;sc_flags</code>. If it contains the <code class="literal">LP_BYPASS flag</code>, <code class="literal">lpt_close jumps</code> to <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18223"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">end_close</code>. Next, <code class="literal">lpt(4)</code> is assigned ownership of the parallel port. The following <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18235"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">if</code> block ensures that if there is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18245"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> still data to transfer and the printer is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18251"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> interrupt-driven, the transfer is completed before closing <code class="literal">lpt%d</code>. Then, <code class="literal">LP_OPEN</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18263"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> removed from <code class="literal">sc-&gt;sc_state</code>, <code class="literal">lpt_timeout is</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18276"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> stopped, the printer is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18282"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> reset, and ownership of the parallel port is relinquished. Lastly, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18288"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">sc-&gt;sc_state</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18297"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">sc-&gt;sc_transfer_count</code> are zeroed.<a class="indexterm" id="IDX-CHP-9-0038"/><a class="indexterm" id="IDX-CHP-9-0039"/></p></div><div class="sect2" title="lpt_ioctl Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_ioctl_function"/>lpt_ioctl Function</h2></div></div></div><p>The <code class="literal">lpt_ioctl</code> function is defined in <code class="literal">lpt_cdevsw</code> as the <code class="literal">d_ioctl</code> operation. Before I describe this function, an explanation of its ioctl command, <code class="literal">LPT_IRQ</code>, is needed. <code class="literal">LPT_IRQ</code> is defined in the <code class="literal">&lt;dev/ppbus/lptio.h&gt;</code> header as follows:</p><a id="I_programlisting9_d1e18341"/><pre class="programlisting">#define LPT_IRQ         _IOW('p', 1, <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>long)</pre><p>As you can see, <code class="literal">LPT_IRQ</code> requires a <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18354"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">long int</code> value.</p><a id="I_programlisting9_d1e18363"/><pre class="programlisting">static int
lpt_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,
    struct thread *td)
{
        struct lpt_data *sc = dev-&gt;si_drv1;
        device_t lpt_dev = sc-&gt;sc_dev;
        device_t ppbus = device_get_parent(lpt_dev);
        u_short old_irq_status;
        int error = 0;

        switch (cmd) {
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>case LPT_IRQ:
                ppb_lock(ppbus);
                if (sc-&gt;sc_irq_status &amp; LP_HAS_IRQ) {
                        old_irq_status = sc-&gt;sc_irq_status;
                        switch (*(int *)<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>data) {
                        case 0:
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sc-&gt;sc_irq_status &amp;= ˜LP_ENABLE_IRQ;
                                break;
                        case 1:
                                sc-&gt;sc_irq_status &amp;= ˜LP_ENABLE_EXT;
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>sc-&gt;sc_irq_status |= LP_ENABLE_IRQ;
                                break;
                        case 2:
                                sc-&gt;sc_irq_status &amp;= ˜LP_ENABLE_IRQ;
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>sc-&gt;sc_irq_status |= LP_ENABLE_EXT;
                                break;
                        case 3:
                              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>sc-&gt;sc_irq_status &amp;= ˜LP_ENABLE_EXT;
                                break;
                        default:
                                break;
                        }

                        if (old_irq_status != sc-&gt;sc_irq_status)
                                log(LOG_NOTICE,
                                    "%s: switched to %s %s mode\n",
                                    device_get_nameunit(lpt_dev),
                                    (sc-&gt;sc_irq_status &amp; LP_ENABLE_IRQ) ?
                                    "interrupt-driven" : "polled",
                                    (sc-&gt;sc_irq_status &amp; LP_ENABLE_EXT) ?
                                    "extended" : "standard");
                } else
                        error = EOPNOTSUPP;

                ppb_unlock(ppbus);
                break;
        default:
                error = ENODEV;
                break;
        }

        return (error);
}</pre><p>Based on the <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18404"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> argument given to <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18410"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">LPT_IRQ</code>, <code class="literal">lpt_ioctl</code> either <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18422"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> disables interrupt-driven mode (which enables polled mode), <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18429"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> enables interrupt-driven mode, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18435"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> enables extended mode, or <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18441"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> disables extended mode (which enables standard mode). Note that interrupt-driven mode and extended mode conflict with each other, so if one is enabled, the other is disabled.<a class="indexterm" id="IDX-CHP-9-0040"/><a class="indexterm" id="IDX-CHP-9-0041"/><a class="indexterm" id="IDX-CHP-9-0042"/><a class="indexterm" id="IDX-CHP-9-0043"/><a class="indexterm" id="IDX-CHP-9-0044"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>To run this function, you’d use the <code class="literal">lptcontrol(8)</code> utility, whose source code I suggest you take a quick look at.</p></div></div><div class="sect2" title="lpt_request_ppbus Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_request_underscore_ppbus"/>lpt_request_ppbus Function</h2></div></div></div><p>The <code class="literal">lpt_request_ppbus</code> function sets <code class="literal">lpt(4)</code> as the owner of the parallel port. Recall that owning the parallel port lets a device (such as <code class="literal">lpt%d</code>) transfer data to and from it.</p><p>Here is the function definition for <code class="literal">lpt_request_ppbus</code>:</p><a id="I_programlisting9_d1e18495"/><pre class="programlisting">static int
lpt_request_ppbus(device_t dev, int how)
{
        device_t ppbus = device_get_parent(dev);
        struct lpt_data *sc = device_get_softc(dev);
        int error;

        ppb_assert_locked(ppbus);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_state &amp; LP_HAVEBUS)
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>return (0);

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ppb_request_bus(ppbus, dev, how);
        if (!error)
               <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>sc-&gt;sc_state |= LP_HAVEBUS;

        return (error);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18523"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checking the value of <code class="literal">sc-&gt;sc_state</code>. If it contains <code class="literal">LP_HAVEBUS</code>, which indicates that <code class="literal">lpt(4)</code> currently owns the parallel port, <code class="literal">lpt_request_ppbus</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18542"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> exits. Otherwise, <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18548"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">ppb_request_bus</code> is called to set <code class="literal">lpt(4)</code> as the owner of the parallel port and <code class="literal">sc-&gt;sc_state</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18563"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> assigned <code class="literal">LP_HAVEBUS</code>.</p></div><div class="sect2" title="lpt_release_ppbus Function"><div class="titlepage"><div><div><h2 class="title"><a id="lpt_underscore_release_underscore_ppbus"/>lpt_release_ppbus Function</h2></div></div></div><p>The <code class="literal">lpt_release_ppbus</code> function causes <code class="literal">lpt(4)</code> to relinquish ownership of the parallel port. Here is its function definition:</p><a id="I_programlisting9_d1e18584"/><pre class="programlisting">static int
lpt_release_ppbus(device_t dev)
{
        device_t ppbus = device_get_parent(dev);
        struct lpt_data *sc = device_get_softc(dev);
        int error = 0;

        ppb_assert_locked(ppbus);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (sc-&gt;sc_state &amp; LP_HAVEBUS) {
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ppb_release_bus(ppbus, dev);
                if (!error)
                       <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sc-&gt;sc_state &amp;= ˜LP_HAVEBUS;
        }

        return (error);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18606"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> verifies that <code class="literal">lpt(4)</code> currently owns the parallel port. Next, it calls <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18615"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">ppb_release_bus</code> to relinquish ownership of the parallel port. Then <code class="literal">LP_HAVEBUS</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject9_d1e18628"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> removed from <code class="literal">sc-&gt;sc_state</code>.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-1" id="ftn.CHP-9-FN-1">8</a>] </sup>Curiously enough, it’s currently impossible to request automatic line feed.</p></div></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id8"/>Conclusion</h1></div></div></div><p>This chapter described the entire code base of <code class="literal">lpt(4)</code>, the parallel port printer driver.</p></div></body></html>