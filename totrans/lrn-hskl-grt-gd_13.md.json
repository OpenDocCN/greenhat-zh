["```\nfmap :: (Functor f) => (a -> b) -> f a -> f b\n```", "```\n(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b\n```", "```\nghci> (*) <$> Just 2 <*> Just 8\nJust 16\nghci> (++) <$> Just \"klingon\" <*> Nothing\nNothing\nghci> (-) <$> [3,4] <*> [1,2,3]\n[2,1,0,3,2,1]\n```", "```\n(>>=) :: (Monad m) => m a -> (a -> m b) -> m b\n```", "```\nghci> fmap (++\"!\") (Just \"wisdom\")\nJust \"wisdom!\"\nghci> fmap (++\"!\") Nothing\nNothing\n```", "```\nghci> Just (+3) <*> Just 3\nJust 6\nghci> Nothing <*> Just \"greed\"\nNothing\nghci> Just ord <*> Nothing\nNothing\n```", "```\nghci> max <$> Just 3 <*> Just 6\nJust 6\nghci> max <$> Just 3 <*> Nothing\nNothing\n```", "```\nghci> (\\x -> Just (x+1)) 1\nJust 2\nghci> (\\x -> Just (x+1)) 100\nJust 101\n```", "```\napplyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\napplyMaybe Nothing f  = Nothing\napplyMaybe (Just x) f = f x\n```", "```\nghci> Just 3 `applyMaybe` \\x -> Just (x+1)\nJust 4\nghci> Just \"smile\" `applyMaybe` \\x -> Just (x ++ \" :)\")\nJust \"smile :)\"\nghci> Nothing `applyMaybe` \\x -> Just (x+1)\nNothing\nghci> Nothing `applyMaybe` \\x -> Just (x ++ \" :)\")\nNothing\n```", "```\nghci> Just 3 `applyMaybe` \\x -> if x > 2 then Just x else Nothing\nJust 3\nghci> Just 1 `applyMaybe` \\x -> if x > 2 then Just x else Nothing\nNothing\n```", "```\nclass Monad m where\n    return :: a -> m a\n\n    (>>=) :: m a -> (a -> m b) -> m b\n\n    (>>) :: m a -> m b -> m b\n    x >> y = x >>= \\_ -> y\n\n    fail :: String -> m a\n    fail msg = error msg\n```", "```\ninstance Monad Maybe where\n    return x = Just x\n    Nothing >>= f = Nothing\n    Just x >>= f  = f x\n    fail _ = Nothing\n```", "```\nghci> return \"WHAT\" :: Maybe String\nJust \"WHAT\"\nghci> Just 9 >>= \\x -> return (x*10)\nJust 90\nghci> Nothing >>= \\x -> return (x*10)\nNothing\n```", "```\ntype Birds = Int\ntype Pole = (Birds, Birds)\n```", "```\nlandLeft :: Birds -> Pole -> Pole\nlandLeft n (left, right) = (left + n, right)\n\nlandRight :: Birds -> Pole -> Pole\nlandRight n (left, right) = (left, right + n)\n```", "```\nghci> landLeft 2 (0, 0)\n(2,0)\nghci> landRight 1 (1, 2)\n(1,3)\nghci> landRight (-1) (1, 2)\n(1,1)\n```", "```\nghci> landLeft 2 (landRight 1 (landLeft 1 (0, 0)))\n(3,1)\n```", "```\nx -: f = f x\n```", "```\nghci> 100 -: (*3)\n300\nghci> True -: not\nFalse\nghci> (0, 0) -: landLeft 2\n(2,0)\n```", "```\nghci> (0, 0) -: landLeft 1 -: landRight 1 -: landLeft 2\n(3,1)\n```", "```\nghci> landLeft 10 (0, 3)\n(10,3)\n```", "```\nghci> (0, 0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)\n(0,2)\n```", "```\nlandLeft :: Birds -> Pole -> Maybe Pole\nlandLeft n (left, right)\n    | abs ((left + n) - right) < 4 = Just (left + n, right)\n    | otherwise                    = Nothing\n\nlandRight :: Birds -> Pole -> Maybe Pole\nlandRight n (left, right)\n    | abs (left - (right + n)) < 4 = Just (left, right + n)\n    | otherwise                    = Nothing\n```", "```\nghci> landLeft 2 (0, 0)\nJust (2,0)\nghci> landLeft 10 (0, 3)\nNothing\n```", "```\nghci> landRight 1 (0, 0) >>= landLeft 2\nJust (2,1)\n```", "```\nghci> Nothing >>= landLeft 2\nNothing\n```", "```\nghci> return (0, 0) >>= landRight 2 >>= landLeft 2 >>= landRight 2\nJust (2,4)\n```", "```\nghci> (0, 0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)\n(0,2)\n```", "```\nghci> return (0, 0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)\nNothing\n```", "```\nbanana :: Pole -> Maybe Pole\nbanana _ = Nothing\n```", "```\nghci> return (0, 0) >>= landLeft 1 >>= banana >>= landRight 1\nNothing\n```", "```\n(>>) :: (Monad m) => m a -> m b -> m b\nm >> n = m >>= \\_ -> n\n```", "```\nghci> Nothing >> Just 3\nNothing\nghci> Just 3 >> Just 4\nJust 4\nghci> Just 3 >> Nothing\nNothing\n```", "```\nghci> return (0, 0) >>= landLeft 1 >> Nothing >>= landRight 1\nNothing\n```", "```\nroutine :: Maybe Pole\nroutine = case landLeft 1 (0, 0) of\n    Nothing -> Nothing\n    Just pole1 -> case landRight 4 pole1 of\n        Nothing -> Nothing\n        Just pole2 -> case landLeft 2 pole2 of\n            Nothing -> Nothing\n            Just pole3 -> landLeft 1 pole3\n```", "```\nghci> Just 3 >>= (\\x -> Just (show x ++ \"!\"))\nJust \"3!\"\n```", "```\nghci> Just 3 >>= (\\x -> Just \"!\" >>= (\\y -> Just (show x ++ y)))\nJust \"3!\"\n```", "```\nghci> let x = 3; y = \"!\" in show x ++ y\n\"3!\"\n```", "```\nghci> Nothing >>= (\\x -> Just \"!\" >>= (\\y -> Just (show x ++ y)))\nNothing\nghci> Just 3 >>= (\\x -> Nothing >>= (\\y -> Just (show x ++ y)))\nNothing\nghci> Just 3 >>= (\\x -> Just \"!\" >>= (\\y -> Nothing))\nNothing\n```", "```\nfoo :: Maybe String\nfoo = Just 3   >>= (\\x ->\n      Just \"!\" >>= (\\y ->\n      Just (show x ++ y)))\n```", "```\nfoo :: Maybe String\nfoo = do\n    x <- Just 3\n    y <- Just \"!\"\n    Just (show x ++ y)\n```", "```\nghci> Just 9 >>= (\\x -> Just (x > 8))\nJust True\n```", "```\nmarySue :: Maybe Bool\nmarySue = do\n    x <- Just 9\n    Just (x > 8)\n```", "```\nroutine :: Maybe Pole\nroutine = do\n    start <- return (0, 0)\n    first <- landLeft 2 start\n    second <- landRight 2 first\n    landLeft 1 second\n```", "```\nghci> routine\nJust (3,2)\n```", "```\nroutine :: Maybe Pole\nroutine =\n    case Just (0, 0) of\n        Nothing -> Nothing\n        Just start -> case landLeft 2 start of\n            Nothing -> Nothing\n            Just first -> case landRight 2 first of\n                Nothing -> Nothing\n                Just second -> landLeft 1 second\n```", "```\nroutine :: Maybe Pole\nroutine = do\n    start <- return (0, 0)\n    first <- landLeft 2 start\n    Nothing\n    second <- landRight 2 first\n    landLeft 1 second\n```", "```\njustH :: Maybe Char\njustH = do\n    (x:xs) <- Just \"hello\"\n    return x\n```", "```\nfail :: (Monad m) => String -> m a\nfail msg = error msg\n```", "```\nfail _ = Nothing\n```", "```\nwopwop :: Maybe Char\nwopwop = do\n    (x:xs) <- Just \"\"\n    return x\n```", "```\nghci> wopwop\nNothing\n```", "```\nghci> (*) <$> [1,2,3] <*> [10,100,1000]\n[10,100,1000,20,200,2000,30,300,3000]\n```", "```\ninstance Monad [] where\n    return x = [x]\n    xs >>= f = concat (map f xs)\n    fail _ = []\n```", "```\nghci> [3,4,5] >>= \\x -> [x,-x]\n[3,-3,4,-4,5,-5]\n```", "```\n[[3,-3],[4,-4],[5,-5]]\n```", "```\nghci> [] >>= \\x -> [\"bad\",\"mad\",\"rad\"]\n[]\nghci> [1,2,3] >>= \\x -> []\n[]\n```", "```\nghci> [1,2] >>= \\n -> ['a','b'] >>= \\ch -> return (n, ch)\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n```", "```\nlistOfTuples :: [(Int, Char)]\nlistOfTuples = do\n    n <- [1,2]\n    ch <- ['a','b']\n    return (n, ch)\n```", "```\nghci> [ (n, ch) | n <- [1,2], ch <- ['a','b'] ]\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n```", "```\nghci> [ x | x <- [1..50], '7' `elem` show x ]\n[7,17,27,37,47]\n```", "```\nclass Monad m => MonadPlus m where\n    mzero :: m a\n    mplus :: m a -> m a -> m a\n```", "```\ninstance MonadPlus [] where\n    mzero = []\n    mplus = (++)\n```", "```\nguard :: (MonadPlus m) => Bool -> m ()\nguard True = return ()\nguard False = mzero\n```", "```\nghci> guard (5 > 2) :: Maybe ()\nJust ()\nghci> guard (1 > 2) :: Maybe ()\nNothing\nghci> guard (5 > 2) :: [()]\n[()]\nghci> guard (1 > 2) :: [()]\n[]\n```", "```\nghci> [1..50] >>= (\\x -> guard ('7' `elem` show x) >> return x)\n[7,17,27,37,47]\n```", "```\nghci> guard (5 > 2) >> return \"cool\" :: [String]\n[\"cool\"]\nghci> guard (1 > 2) >> return \"cool\" :: [String]\n[]\n```", "```\nsevensOnly :: [Int]\nsevensOnly = do\n    x <- [1..50]\n    guard ('7' `elem` show x)\n    return x\n```", "```\nghci> [ x | x <- [1..50], '7' `elem` show x ]\n[7,17,27,37,47]\n```", "```\ntype KnightPos = (Int, Int)\n```", "```\nmoveKnight :: KnightPos -> [KnightPos]\nmoveKnight (c,r) = do\n    (c', r') <- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)\n               ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)\n               ]\n    guard (c' `elem` [1..8] && r' `elem` [1..8])\n    return (c', r')\n```", "```\nmoveKnight :: KnightPos -> [KnightPos]\nmoveKnight (c, r) = filter onBoard\n    [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)\n    ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)\n    ]\n    where onBoard (c, r) = c `elem` [1..8] && r `elem` [1..8]\n```", "```\nghci> moveKnight (6, 2)\n[(8,1),(8,3),(4,1),(4,3),(7,4),(5,4)]\nghci> moveKnight (8, 1)\n[(6,2),(7,3)]\n```", "```\nin3 :: KnightPos -> [KnightPos]\nin3 start = do\n    first <- moveKnight start\n    second <- moveKnight first\n    moveKnight second\n```", "```\nin3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight\n```", "```\ncanReachIn3 :: KnightPos -> KnightPos -> Bool\ncanReachIn3 start end = end `elem` in3 start\n```", "```\nghci> (6, 2) `canReachIn3` (6, 1)\nTrue\n```", "```\nghci> (6, 2) `canReachIn3` (7, 3)\nFalse\n```", "```\nghci> return 3 >>= (\\x -> Just (x+100000))\nJust 100003\nghci> (\\x -> Just (x+100000)) 3\nJust 100003\n```", "```\nghci> return \"WoM\" >>= (\\x -> [x,x,x])\n[\"WoM\",\"WoM\",\"WoM\"]\nghci> (\\x -> [x,x,x]) \"WoM\"\n[\"WoM\",\"WoM\",\"WoM\"]\n```", "```\nghci> Just \"move on up\" >>= (\\x -> return x)\nJust \"move on up\"\nghci> [1,2,3,4] >>= (\\x -> return x)\n[1,2,3,4]\nghci> putStrLn \"Wah!\" >>= (\\x -> return x)\nWah!\n```", "```\nxs >>= f = concat (map f xs)\n```", "```\nghci> return (0, 0) >>= landRight 2 >>= landLeft 2 >>= landRight 2\nJust (2,4)\n```", "```\nghci> ((return (0, 0) >>= landRight 2) >>= landLeft 2) >>= landRight 2\nJust (2,4)\n```", "```\nreturn (0, 0) >>= (\\x ->\nlandRight 2 x >>= (\\y ->\nlandLeft 2 y >>= (\\z ->\nlandRight 2 z)))\n```", "```\n(.) :: (b -> c) -> (a -> b) -> (a -> c)\nf . g = (\\x -> f (g x))\n```", "```\n(<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = (\\x -> g x >>= f)\n```", "```\nghci> let f x = [x,-x]\nghci> let g x = [x*3,x*2]\nghci> let h = f <=< g\nghci> h 3\n[9,-9,6,-6]\n```"]