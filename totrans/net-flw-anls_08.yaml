- en: Chapter 8. AD HOC FLOW VISUALIZATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages651574.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although viewing the content of flows and running reports helps track down problems,
    some issues can be properly assessed through visualization only. The average human
    brain simply cannot assemble 6,000 lines of plain-text data into a coherent understanding
    of the situation. Transforming large quantities of data into visual form eases
    comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most common way to convert data to graphical form is through an
    office suite, such as Microsoft Office or OpenOffice.org. Office suites are not
    suited to automation, however. Once you have designed your graphs, regenerating
    them with new data should be trivial or even instantaneous. Tools such as CUFlow
    ([Chapter 6](ch06.html "Chapter 6. PERL, FLOWSCAN, AND CFLOW.PM")) and FlowGrapher
    ([Chapter 7](ch07.html "Chapter 7. FLOWVIEWER")) provide basic graphing, but they
    lack true ad hoc flexibility, such as the ability to choose the style of graph
    or whether to overlay one graph atop another. To provide truly unlimited flexibility
    in a manner that you can automate or quickly reproduce, you need `gnuplot`.
  prefs: []
  type: TYPE_NORMAL
- en: gnuplot 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`gnuplot` ([http://www.gnuplot.info/](http://www.gnuplot.info/)) has a notoriously
    steep learning curve and a reputation for complexity. The notoriety and reputation
    are not completely unwarranted. `gnuplot`''s power and efficiency more than make
    up for its challenges, however. Although mastering `gnuplot` can take years, you
    can quickly learn enough to create impressive graphs of your network data. Almost
    every Unix-like operating system includes current `gnuplot` packages, and you
    can also find packages for Windows, DOS, VMS, and almost every other operating
    system used in the past 20 years.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `gnuplot` on the reporting server simplifies reporting and the development
    of graphs. To use `gnuplot` on your reporting server, you'll need an X server
    on your workstation. If you use a Unix workstation, you're all set. If not, you
    can find any number of X Windows servers for Microsoft Windows. Be sure to choose
    one that can forward X over SSH, rather than speaking raw X over the network.
    (On Windows, I use the PuTTY SSH client and Xming X server.)
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to use an X terminal on your desktop, install `gnuplot` on
    your workstation, and then run reports on the server and transfer them to your
    workstation. Develop your graphs on your workstation, save their configurations,
    and copy those configurations to your server to automatically create more graphs.
  prefs: []
  type: TYPE_NORMAL
- en: OTHER GRAPHING PROGRAMS
  prefs: []
  type: TYPE_NORMAL
- en: gnuplot's main advantage is that it's easily automated. To create graphs on
    the fly without worrying about reproducing them later, consider Grace ([http://plasma-gate.weizmann.ac.il/Grace/](http://plasma-gate.weizmann.ac.il/Grace/)).
  prefs: []
  type: TYPE_NORMAL
- en: Starting gnuplot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to learn `gnuplot` is to use it. When `gnuplot` starts, it displays
    a message and offers its own command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To leave `gnuplot`, enter either **`exit`** or **`quit`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most `gnuplot` commands either alter a drawing''s appearance or create a new
    drawing. For a taste for how `gnuplot` works, graph a sine wave. (For some reason,
    the sine plot is traditional in `gnuplot` tutorials.) On the `gnuplot` command
    line, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should see another window appear, displaying the classic sine wave, as shown
    in [Figure 8-1](ch08.html#sine_wave "Figure 8-1. Sine wave").
  prefs: []
  type: TYPE_NORMAL
- en: '![Sine wave](httpatomoreillycomsourcenostarchimages651604.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. Sine wave
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify your graphs, use the `set` command. You can set countless values,
    from the title of a graph to the labels on the x- and y-axes, colors used, and
    so on. Here I''m giving the graph the title of *test graph*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The displayed graph doesn''t change until you tell `gnuplot` to replot the
    data, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now your graph should have a title.
  prefs: []
  type: TYPE_NORMAL
- en: gnuplot Configuration Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test graph you created here took very little effort. You didn't read in
    any data or enter complicated formulas. Flow data is much more complicated than
    a sine wave, however, and in this chapter you'll work through several iterations
    of your graph to make it look "just right." You can save all the settings from
    a `gnuplot` session so that you can call up those same settings and use them to
    plot new data. Just tell `gnuplot` the name of the file you want to save your
    configuration in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll find a `gnuplot` configuration file named *test.plt* in your current
    directory. This file contains all the `gnuplot` commands you entered, including
    the title and the `plot sin(x)` instruction. Exit `gnuplot`, and restart it. Then
    load this configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Your graph will reappear, with all the changes you specified.
  prefs: []
  type: TYPE_NORMAL
- en: Retyping two commands to re-create your graph wouldn't be difficult, but graphs
    based on flow reports might include dozens of instructions, some of them long
    and tedious. Being able to save your `gnuplot` configuration and reuse it to graph
    new data will save time and effort and reduce errors.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's get some real data to graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time-Series Example: Bandwidth'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common question network engineers get is "How much bandwidth does this application
    use?" I've worked in more than one global operation where management was concerned
    about how much internal bandwidth email consumed or where the Active Directory
    team needed to know how much bandwidth the interdomain controller communications
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Flow reports can answer this question in many different ways. An average of
    bandwidth use through the day is useful but won't reveal intermittent performance
    bottlenecks. A connection that's completely idle most of the time but that has
    a massive throughput spike during each day's peak hours might have an average
    throughput of about 50Kbps. The one-day average is simultaneously accurate and
    useless. The best way to answer this question is with a graph.
  prefs: []
  type: TYPE_NORMAL
- en: You'll start by investigating how much bandwidth you use between your desktop
    DHCP range and the Active Directory domain controllers at remote sites on your
    internal network during a particular 24-hour period. This is a very specific example
    of a question network engineers get all the time, and you can use this technique
    to answer any bandwidth-related question. You'll begin with a look at the total
    inbound and outbound traffic in a total bandwidth report.
  prefs: []
  type: TYPE_NORMAL
- en: Total Bandwidth Report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any time you want to create a graph of bandwidth, packets, or flows over time,
    the best way to get the data is with the `linear-interpolated-flows-octets-packets`
    report (discussed in [Chapter 5](ch05.html "Chapter 5. REPORTING AND FOLLOW-UP
    ANALYSIS")). This report produces a good estimate of the number of octets, flows,
    and packets per second in a selection of flow data. You''re specifically interested
    in bandwidth (octets) per second, so you can produce this information with this
    *stat.cfg* configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because you're interested in the number of bytes transmitted, you remove at
    ❶ the packet and flow counts from this report. The other settings are `flow-report`'s
    defaults. Next, you need to decide what data to feed into the report.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Flows for Total Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say you want to graph the bandwidth usage between your desktop DHCP range and
    several remote hosts. To filter these hosts out of your flow data, you'll use
    primitives for these hosts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You need one filter for the remote domain controllers and one for the desktops.
    (You could write a single filter that captured traffic from the desktops to the
    domain controllers and back, but two separate filters are generally more reusable.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now run the flows for the day you've chosen through these filters and through
    your interpolated octets `flow-report`. You're reporting on all the flows for
    January 14, 2011.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The top of the file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The numbers on the left side are Unix epochal seconds. To double-check the report
    times, convert the first and last ones one with the `date` program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first matching flow began at four minutes after midnight, and the last one
    ended at almost 11:46 **pm**, both on January 14\. The report covers the time
    you're interested in.
  prefs: []
  type: TYPE_NORMAL
- en: '`gnuplot` will have problems with the column names of this file because `unix-secs`
    and `octets` are not graphable numbers. The simplest way to deal with this is
    to delete the first two lines either by hand or with `sed`. (Although editing
    the file by hand might be easier when creating graphs by hand, `sed` can be automated.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Target Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What do you want a graph to look like? It should clearly show how much bandwidth
    is used. The axes should be labeled with times and the unit of bandwidth measurement,
    and the graph itself should have a label. If you want real human beings to care
    about your graphs, times should be local clock time, not in epochal seconds or
    Greenwich mean time (GMT). If the graph has different lines for different types
    of traffic, it should have an interpretation key. And this should all be automatically
    generated. Oh, and while you're at it, you'll make the data accurate and meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The First Graph: Missing the Target'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Begin by creating a default `gnuplot` graph of your data and comparing this
    to your desired result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The bandwidth at any given time is represented by a point, as shown in [Figure 8-2](ch08s02.html#raw_throughput_graph
    "Figure 8-2. Raw throughput graph"). Bandwidth utilization on a second-by-second
    basis is too irregular for nice curving lines, but you'll learn how to make graphs
    using markers other than points later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Raw throughput graph](httpatomoreillycomsourcenostarchimages651606.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. Raw throughput graph
  prefs: []
  type: TYPE_NORMAL
- en: Neither axis has a label; the default graph could represent apples vs. pomegranates
    for all you can tell. In addition, the times along the bottom appear as epochal
    seconds, such as 1.2319E+08, rather than useful times. Epochal seconds are accurate,
    strictly speaking, but not exactly what you want to hand to your co-workers. You'll
    iteratively improve the graph, first by setting labels on the two axes and then
    by telling `gnuplot` how to format the time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You first tell `gnuplot` at ❶ that the data along the x-axis represents time.
    Then at ❷ you tell `gnuplot` the format of the time data along the x-axis. The
    `%s` character is a `gnuplot` time format that represents epoch seconds, and it
    gives `gnuplot` the information it needs to convert epoch seconds to human-friendly
    times. `gnuplot` can print measures of time in the same `strftime` format used
    by `flow-rptfmt` (see [Chapter 5](ch05.html "Chapter 5. REPORTING AND FOLLOW-UP
    ANALYSIS")). For a graph that covers 24 hours, printing the hour is a sensible
    choice, and you set that format at ❸. You then label the x- and y-axes at ❹ and
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've started getting fancy, you tell `gnuplot` at ❻ exactly how to
    plot the data in your file. The dollar sign followed by a number indicates a column
    of data. `($1)` means "column 1," and `($2)` means "column 2." The statement `plot
    "octets.txt" using ($1):($2)` tells `gnuplot` to read `octets.txt` and plot the
    first column against the second column. The result looks like [Figure 8-3](ch08s02.html#flow_diagram_with_basic_labels
    "Figure 8-3. Flow diagram with basic labels").
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow diagram with basic labels](httpatomoreillycomsourcenostarchimages651608.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3. Flow diagram with basic labels
  prefs: []
  type: TYPE_NORMAL
- en: This graph is closer to the target graph described earlier. The x-axis is labeled
    in bytes, and the y-axis is labeled in human-readable times. Notice that the times
    along the bottom don't match the data in the report, however. The flow data started
    just after midnight and ended just before midnight, but this graph starts at about
    5 **am** and ends 24 hours later. This is a time zone problem. I'm in Eastern
    standard time (EST), and `gnuplot` produced a graph in Coordinated Universal Time
    (UTC). This graph needs to display the local time. Also, I buy bandwidth in kilobits
    rather than kilobytes. Although the kilobytes label is accurate, I want the graph
    to show kilobits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert UTC to EST, you subtract five hours, shifting each value by (5 ×
    60 × 60 =) 18,000 seconds. You need to reduce all times listed in the data by
    18,000 seconds to have the graph display an accurate clock time. To convert bytes
    to kilobits, you divide by 125\. (One byte has 8 bits, and one kilobit has 1,000
    bits: 1000 / 8 = 125.) You can set both of these conversions as constants in `gnuplot`
    in order to transform the data as you graph it. (Don''t forget to change the label
    on the y-axis when you change the measurement.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, you define a constant for the number of seconds between EST and UTC (❶)
    and another for the number of octets per kilobit (❷).
  prefs: []
  type: TYPE_NORMAL
- en: Next, because you're changing the measurement on the y-axis from bytes to kilobits,
    you also change the y-axis label, as shown at ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part is where you tell `gnuplot` to change the data as you're graphing
    it. Previously, you graphed the first column against the second. You're transforming
    the first column by adding the time zone offset to every value in that column
    (❹). You transform the second column by dividing every entry by the constant `kb`
    (❺). You don't change the numbers in the *octets.txt* file; you transform them
    on their way to the graph.
  prefs: []
  type: TYPE_NORMAL
- en: While you're here, you can make some other changes, such as assigning a title
    and giving the graph a grid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You'll get the graph shown in [Figure 8-4](ch08s02.html#network_utilization_with_better_times_co
    "Figure 8-4. Network utilization with better times, bandwidth units, grid, and
    title"), which at first glance is similar to the graph in [Figure 8-2](ch08s02.html#raw_throughput_graph
    "Figure 8-2. Raw throughput graph") but with more appropriate times and more useful
    bandwidth measurements, which make it more suitable for sharing with co-workers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Network utilization with better times, bandwidth units, grid, and title](httpatomoreillycomsourcenostarchimages651610.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4. Network utilization with better times, bandwidth units, grid, and
    title
  prefs: []
  type: TYPE_NORMAL
- en: Changing How the Graph Is Drawn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although I like graphs composed of individual points, many people prefer a
    different style of graph. `gnuplot` supports a nearly limitless number of graph
    styles. One popular style of bandwidth graph is one that uses a solid line, called
    an *impulse*, to represent the bandwidth used at any given time. Here, I''m creating
    exactly the same graph as before but using impulses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Other than specifying impulses, this is exactly the same command.
  prefs: []
  type: TYPE_NORMAL
- en: You'll get a graph like [Figure 8-5](ch08s02.html#network_utilization_with_impulses
    "Figure 8-5. Network utilization with impulses"). Some people will find this style
    of graph easier to understand. Just use whatever format your brain is wired to
    accept.
  prefs: []
  type: TYPE_NORMAL
- en: '![Network utilization with impulses](httpatomoreillycomsourcenostarchimages651612.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5. Network utilization with impulses
  prefs: []
  type: TYPE_NORMAL
- en: Clipping Levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You've probably noticed in [Figure 8-5](ch08s02.html#network_utilization_with_impulses
    "Figure 8-5. Network utilization with impulses") that a few data points vary greatly
    from the averages. If you examine the original data, you'll find that several
    connections are only three or four packets. Passing four octets in one millisecond
    is not the same as passing 4,000 octets in 1,000 milliseconds (or one second),
    but that's what a simple "average octets per second" calculation produces on a
    mostly idle network.
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate these outliers, you can establish a sensible clipping level to
    create a more realistic graph. To do this, you'll use `gnuplot`'s built-in logical
    operators, in the format shown here. (Perl and C aficionados should be familiar
    with this syntax.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This translates to "Is `a` true? If true, use `b`. If untrue, use `c`."
  prefs: []
  type: TYPE_NORMAL
- en: 'After assessing your first graph and the data underlying those peaks, you might
    decide that you want your graph to have a maximum value of, say, 300Kbps, and
    that if a value exceeds 300Kbps, it should be treated as 300\. Translated into
    the previous syntax, you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`$2/kb` is the bandwidth in kilobits. With `>300 ?`, you check to see whether
    the bandwidth exceeds 300\. If it does, you use the value `300`. If not, you use
    the actual value of `$2/kb`.'
  prefs: []
  type: TYPE_NORMAL
- en: To have `gnuplot` perform this check for you, enter it in the `plot` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You'll get a result like the graph shown in [Figure 8-6](ch08s02.html#network_utilization_with_clipping_levels
    "Figure 8-6. Network utilization with clipping levels").
  prefs: []
  type: TYPE_NORMAL
- en: '![Network utilization with clipping levels](httpatomoreillycomsourcenostarchimages651614.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6. Network utilization with clipping levels
  prefs: []
  type: TYPE_NORMAL
- en: By setting a clipping level, you get a graph that offers a more realistic image
    of your actual bandwidth usage.
  prefs: []
  type: TYPE_NORMAL
- en: CLIPPING LEVELS AND MULTIPLE GRAPHS
  prefs: []
  type: TYPE_NORMAL
- en: When creating graphs for comparison, use the same clipping levels in all the
    graphs. Varying clipping levels will confuse the results.
  prefs: []
  type: TYPE_NORMAL
- en: Printing Graphs to Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`gnuplot` supports a wide variety of graphics formats. To view the complete
    list your version supports, enter **`set terminal`** at the `gnuplot>` prompt.
    The three most commonly used formats for websites are GIF, JPEG, and PNG.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To have `gnuplot` print graphs to a file instead of to your screen, tell `gnuplot`
    the file type and name. Here, you save the graph to a JPEG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `set output` statement at ❶ tells `gnuplot` the type of output to produce,
    and the one at ❷ says where to put any output. To actually create the file, you
    have `gnuplot` redraw the graph at ❸. Finally, at ❹ you set the terminal to display
    its output to the screen again.
  prefs: []
  type: TYPE_NORMAL
- en: Save Your Work!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use this configuration to easily generate very similar graphs. Save
    it as a basis for future reports.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Unidirectional Bandwidth Reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graph in [Figure 8-6](ch08s02.html#network_utilization_with_clipping_levels
    "Figure 8-6. Network utilization with clipping levels") showed the total amount
    of bandwidth used for communication between the desktops and the domain controllers
    at remote sites. What if you want a report on the bandwidth used in one direction
    only, such as from servers to desktops or from desktops to servers?
  prefs: []
  type: TYPE_NORMAL
- en: The report you'd generate isn't very different from the total bandwidth report
    you generated in the previous section. To create the report, you'd use the `flow-nfilter`
    configuration to extract the data of interest, feed that to your octet's `flow-report`,
    and then feed that to a very similar `gnuplot` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Flows for Unidirectional Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The filter configuration uses the same `desktops` and `remoteDCs` primitives
    you used for the total bandwidth report. As shown here, you create two new filters,
    one for each direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first filter shows only the traffic the domain controllers send to the desktops;
    the second filter shows the traffic desktops send to the domain controllers. Now
    you run one of these new filters against the same flow files, beginning with the
    traffic from the domain controllers to the desktops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the same `sed` command to remove the two extra lines at the top of
    the file. Finally, verify that the contents of the data file resembles that of
    your previous report: two columns containing epoch dates and bandwidth amounts.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Unidirectional Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unidirectional traffic graph should look a lot like the total bandwidth
    graph. In fact, to produce the final graph, you can simply modify the existing
    `gnuplot` configuration and change the title.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You begin by loading at ❶ the configuration you used for the total bandwidth
    graph. This configuration gives you correct times, bits instead of octets, and
    so on. Next, at ❷ you change the title, and at ❸ you create a new plot with your
    new data. The result would look like [Figure 8-7](ch08s02.html#unidirectional_bandwidth_usage
    "Figure 8-7. Unidirectional bandwidth usage").
  prefs: []
  type: TYPE_NORMAL
- en: '![Unidirectional bandwidth usage](httpatomoreillycomsourcenostarchimages651616.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7. Unidirectional bandwidth usage
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, reusing `gnuplot` configurations with different data is a very
    quick way to produce graphs with a consistent appearance but different data.
  prefs: []
  type: TYPE_NORMAL
- en: To create a graph for traffic going in the opposite direction, you would do
    almost the same thing; simply change the graph title and the flow filter.
  prefs: []
  type: TYPE_NORMAL
- en: Combined Inbound/Outbound Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A graph showing both inbound and outbound traffic simultaneously is likely to
    be more useful than a graph showing traffic in one direction only. You already
    have the data; to produce a graph showing traffic in both directions, you just
    need a slightly different `gnuplot` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Data Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you were to create two unidirectional graphs, you would already have the
    data files you need, and that's essentially what you'll do. You can't call both
    data files *octets.txt*; however, you need to give each a distinct name. Since
    you're measuring traffic between local and remote hosts, let's call one of them
    *inbound.txt* and the other *outbound.txt*. Trim the headers off the raw data
    files with `sed`, but otherwise leave the data unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Displaying Two Graphs Simultaneously
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To display two graphs simultaneously, begin with your unidirectional graph configuration.
    You'll change the name of the files being plotted, but all the other configuration
    information such as time zone, kilobits instead of bytes, and so on, will work
    just as well for this new graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'To plot two different data sets drawn from two different files on one graph,
    separate each with a comma in a single `plot` statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This listing displays several new features here. The backslash (`\`) at ❶ tells
    `gnuplot` that a command continues on the next line. If you need to use a backslash
    to show a continued line, enter the backslash, and then just press **enter**.
    You'll be taken to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: The `title` at ❷ within the `plot` statement labels the data. In this case,
    you have two types of data, labeled `inbound` and `outbound`. The comma (,) at
    ❸ separates the two data sources. The resulting graph looks something like [Figure 8-8](ch08s02.html#graph_of_inbound_and_outbound_traffic
    "Figure 8-8. Graph of inbound and outbound traffic").
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph of inbound and outbound traffic](httpatomoreillycomsourcenostarchimages651618.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8. Graph of inbound and outbound traffic
  prefs: []
  type: TYPE_NORMAL
- en: According to the key, the data points of the inbound traffic are plus signs
    (`+`). The outbound traffic data points appear as `x` characters. `gnuplot` will
    also use different colors for the data points. ([Figure 8-8](ch08s02.html#graph_of_inbound_and_outbound_traffic
    "Figure 8-8. Graph of inbound and outbound traffic") is a bit easier to understand
    in color, but this book is in black and white because I want it to be affordable.)
    Having two different data point characters helps, but not much. It's better to
    show both types of traffic simultaneously, but not intermingled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this graph easier to understand at a glance, graph outbound traffic
    as negative numbers, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You've made only two minor changes here, placing minus signs in your outbound
    graph's plot statement at ❶ and ❷. [Figure 8-9](ch08s02.html#utilization_diagram_with_outbound_traffi
    "Figure 8-9. Utilization diagram with outbound traffic as negative numbers") shows
    the resulting graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilization diagram with outbound traffic as negative numbers](httpatomoreillycomsourcenostarchimages651620.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9. Utilization diagram with outbound traffic as negative numbers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this graph, it's clear that you're receiving much more traffic
    than you send, and you receive it much more frequently. The inbound and outbound
    clipping levels are unchanged, but the outbound traffic never approaches the clipping
    level. You can also see that you have a big utilization spike just after 9 **am**
    EST.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get another look at this data, you could graph it with impulses like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result resembles [Figure 8-10](ch08s02.html#impulse_utilization_diagram_with_outboun
    "Figure 8-10. Impulse utilization diagram with outbound traffic as negative numbers").
  prefs: []
  type: TYPE_NORMAL
- en: With proper graphs, anyone—even your manager—can understand network utilization.
    [Figure 8-10](ch08s02.html#impulse_utilization_diagram_with_outboun "Figure 8-10. Impulse
    utilization diagram with outbound traffic as negative numbers") makes it clear
    that desktops are exchanging traffic with remote domain controllers, even though
    Microsoft insisted that clients should contact their local domain controller only.
    You can now resolve the problem with documented facts rather than guesses and
    intermittent packet sniffer snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: '![Impulse utilization diagram with outbound traffic as negative numbers](httpatomoreillycomsourcenostarchimages651622.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10. Impulse utilization diagram with outbound traffic as negative numbers
  prefs: []
  type: TYPE_NORMAL
- en: Automating Graph Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you'll always need to have some ad hoc reporting ability, you'll find
    that you need certain graphs over and over again. You should make producing these
    graphs so easy that one of your flunkies can do it, or you can even schedule graph
    production with `cron`. The best way to manage this is through scripting and automation.
    `gnuplot` is very scripting-friendly, and the following script processes yesterday's
    flow files to generate a bidirectional traffic graph.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script is not optimized. In a real environment, you'd send email via Perl,
    but I don't want to waste a page on that example when you probably already have
    a standard way to send mail on your systems. Too, this script uses insecure temp
    files, and you shouldn't use such files on a shared system. In short, do not use
    this script as is; rather, use it as a guide for writing a script that fits your
    own needs in the best Perl you can maintain. Who told you to listen to me, anyway?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, some of the commands here are a little long, but there's no interface
    to run flow reports directly from within Perl. You replace `sed` with textbook
    Perl routines, but you're already using `system()` calls all over the place.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with `run gnuplot`, you configure `gnuplot` entirely within this script.
    You could also load most of your `gnuplot` configuration from a file.
  prefs: []
  type: TYPE_NORMAL
- en: And as for sending mail (at the end of the script), you probably already have
    a preferred way to send mail from your servers. If you don't, I recommend Perl's
    MIME::Lite module. Otherwise, look at programs such as `mutt` or `metamail`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to compare traffic from multiple time periods is to overlay
    one graph atop another; doing so helps you evaluate the impact of system changes
    on the network. You can use the same type of linear interpolation for this as
    well, with some needed changes to the graph techniques and the time values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following report, you''ll compare inbound and outbound Internet traffic
    from two different 24-hour periods, A and B. The data is in two files: *inboundA.txt*
    and *inboundB.txt*. I''ve already removed the column names from the top of these
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: Data Normalizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the graphs overlay each other, you need to adjust the data times. Bandwidth
    values are largely unchanged, but the time values are problematic. The simplest
    way to do this is to subtract a value from each set of data so that each graph
    starts at time zero.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `sort -key` in the output section of your linear-interpolated report,
    the earliest time in your file appears at the top. For example, look at the top
    of *inboundA.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*InboundA.txt* begins in epochal second 1229488610 (❶). You subtract 1,229,488,610
    from every time value to turn it into an offset from zero. Similarly, *inboundB.txt*
    begins in epochal second 1230179749\. You store these values in `gnuplot`, and
    while you''re defining constants, you''ll also define the number of octets in
    a kilobyte.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Those of you who check these dates will notice that they start about a minute
    apart. A difference of one minute in a small graph of a day's traffic is negligible.
    If you were graphing traffic within a single minute or creating a wide graph for
    a single hour you'd have to correct for this difference, but at this scale we
    don't care.
  prefs: []
  type: TYPE_NORMAL
- en: Time Scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You want to label the x-axis by time using "hours into the samples," but as
    things stand, the x-axis will be numbered in seconds. You can convert seconds
    into hours by configuring `gnuplot`''s *tics*. A tic is a divider along an axis;
    major tics are labeled, and minor tics are not. The previous graphs had a labeled
    tic every two hours and one minor tic halfway between each hour. Let''s keep that
    value: Two hours is 7,200 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With these basic labels, you can now plot your data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The result should look something like [Figure 8-11](ch08s04.html#comparisons_of_traffic_on_two_different
    "Figure 8-11. Comparisons of traffic on two different days"), except in color.
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparisons of traffic on two different days](httpatomoreillycomsourcenostarchimages651624.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11. Comparisons of traffic on two different days
  prefs: []
  type: TYPE_NORMAL
- en: You can combine this sort of comparison graph with the graph that shows inbound
    and outbound traffic simultaneously and get an easy-to-understand comparison of
    traffic from two different time windows. Or you can make one day's traffic negative
    to make it easier to see. You can build graphs that show how much of your Internet
    traffic is web browsing from Monday through Friday, 9 **am** to 5 **pm**, to show
    the impact of users on the network. Or you can compare your current network usage
    to the usage when your new Internet circuit was installed last year. `gnuplot`
    lets you visualize any data you have. If you want more sophisticated examples
    of using `gnuplot` with flow data, look for the CAIDA tools or the FloCon ([http://www.cert.org/flocon/](http://www.cert.org/flocon/))
    proceedings.
  prefs: []
  type: TYPE_NORMAL
