["```\nContent-type: text/plain; charset=\"us-ascii\"\n```", "```\nContent-type: image/jpeg; name=\"ryanpicture.jpg\"\n```", "```\nimage/vnd.dwg,\nimage/vnd.dxf,\nimage/vnd.svf\n```", "````# MIME Composite Media Types: Multipart and Encapsulated Message Structures    MIME discrete media types allow MIME to represent hundreds of different kinds of data in email messages. This alone would make MIME an incredibly useful technology, but the MIME standard goes one step further by defining *composite* media types. These allow MIME to perform even more spectacular feats, such as sending many types of data at once or encapsulating other messages or information into email.    The use of a MIME composite media type is indicated via the Content-Type header of an RFC 822 message. Instead of one of the six discrete media types (`text`, `image`, `audio`, `video`, `model`, or `application`), one of these two composite media types is used: `multipart`, which allows one or more sets of data to be sent in a single MIME message, and `message`, which allows a message to encapsulate another message.    ### Tip    **KEY CONCEPT** Two MIME composite media types exist: `message`, which allows one message to encapsulate another, and `multipart`, which allows multiple individual media types to be encoded into a single email message.    ## MIME Multipart Message Type    The `multipart` media type is the more common of the two types, and for good reason: It is an *incredibly* powerful mechanism. It allows one message to contain many different kinds of information that can be used in different ways. Each piece of data is encoded separately as a MIME body part, and the parts are combined into a single email message. How these parts are used depends on the semantics of the message, indicated by the MIME subtype. RFC 2046 describes several of these, and a few new ones have also been defined by the IANA registration scheme described earlier.    ### MIME Multipart Message Subtypes    Table 78-9 shows the most common multipart media subtypes and how they are used. The first four are defined in RFC 2046.    Table 76-9. Common MIME multipart Media Type Subtypes     | Type/Subtype | Description | Defining Source | | --- | --- | --- | | `multipart/mixed` | Indicates that the body parts are not really related, but they have been bundled for transport in a single message for convenience. For example, this might be used by someone to send an office memo along with a vacation snapshot just for fun. This subtype is also sometimes used when the parts are related but the relationship is communicated to the recipient in some other way (such as via a description in a distinct body part). | RFC 2046 | | `multipart/alternative` | Specifies that the body parts are alternative representations of the same information. The recipient decodes the parts and chooses the one that is best suited to her needs. A common use of this is in sending Hypertext Markup Language (HTML)-encoded email. Some email clients can't display HTML, so it is courteous to send a *multipart/alternative* message containing the message in both HTML and plain text forms. The alternatives should be placed in the message in increasing order of preference, meaning that the preferred format goes last. In the case of a document that includes plain text and rich text alternatives—such as the preceding example with plain text and HTML versions of a document—the plainest format should go first and the fanciest last. | RFC 2046 | | `multipart/parallel` | Tells the recipient that the body parts should all be displayed at the same time (in parallel). For example, someone sends an audio clip along with explanatory text to be displayed alongside it as it plays. | RFC 2046 | | `multipart/digest` | Allows a message to carry a digest, such as a collection of other email messages. | RFC 2046 | | `multipart/related` | Indicates specifically that the body parts are related to each other. Special parameters are used to provide more information on how they are to be interpreted. | RFC 2387 | | `multipart/encrypted` | Used for encrypted data. The first body part contains information on how the data is to be decrypted, and the second contains the data itself. | RFC 1847 |    ## Multipart Message Encoding    You can see just from the different subtypes shown in Table 78-9 how much flexibility the multipart type provides to MIME, and there are other subtypes. In all cases, the same syntax is used to encode the constituent body parts into a single message. The basic process is as follows:    1.  Each individual piece of data is processed as if it were to be transmitted as the body of a discrete media type MIME message. This includes the specification of appropriate headers, such as Content-Type, Content-ID, and Content-Transfer-Encoding, as needed.           2.  A special *boundary delimiter* is chosen to separate the body parts. It must be selected so that it will not appear in any of the body parts; a random string is sometimes used. It is prepended with two dashes (—) when placed in the message to reduce the chance of it being mistaken for data.           3.  The multipart message is assembled. It consists of a *preamble* text area, then a boundary line, followed by the first body part. Each subsequent body part is separated from the previous one with another boundary line. After the last body part, another boundary line appears, followed by an *epilogue* text area.           4.  The special parameter *boundary* is included in the Content-Type header of the message as a whole, to tell the recipient what pattern separates the body parts.              ### Tip    **KEY CONCEPT** MIME multipart messages are formed by first processing each individual data component to create a MIME *body part*. Each can have a distinct encoding method and set of headers, as if it were a separate MIME message. These body parts are then combined into a single multipart message and separated with a *boundary delimiter*. The identity of the delimiter is inserted into the *boundary* parameter of the *Content-Type* header, so the recipient can easily separate the individual body parts upon receipt of the message.    These rules may seem rather complicated, but once you've seen a couple of multipart messages, the structure will make sense. To help clarify multipart message encoding, [Figure 76-1](ch76s07.html#mime_multipart_message_structure_a_mime_ \"Figure 76-1. MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called \"Delimiter.\" This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively.\") shows graphically the overall structure of a multipart MIME message.    [Example 76-1](ch76s07.html#example_of_a_mime_multipart_message \"Example 76-1. Example of a MIME multipart message\") contains a specific example of a multipart message (with portions abbreviated to keep the length down), so you can see what one looks like in text form. (If you want to see more, you probably have several in your own email inbox right now!)    Example 76-1. Example of a MIME multipart message    ``` From: Joe Sender <joe@someplace.org> To: Jane Receiver <jane@somewhereelse.com> Date: Sun, 1 Jun 2003 13:28:19 —0800 Subject: Photo and discussion MIME-Version: 1.0 Content-Type: multipart/mixed; boundary=\"exampledelimtext123\"  This is a multipart message in MIME format  -exampledelimtext123 Content-Type: text/plain  Jane, here is the photo you wanted from me for the new client. Here are some notes on how it was processed. (Blah blah blah...) Talk to you soon, Joe.  -exampledelimtext123  Content-Type: image/jpeg; name=\"clientphoto.jpg\" Content-Transfer-Encoding: base64  SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs ... zv/wAARCADIARoDASIAAhEBAxEB/8QAHAAAAQUBA  -exampledelimtext123  (Epilogue) ```  ![MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called \"Delimiter.\" This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively.](httpatomoreillycomsourcenostarchimages288289.png)  Figure 76-1. MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called \"Delimiter.\" This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively.    In this example, Joe is sending Jane a multipart message containing a JPEG photograph and some explanatory text. The main header of the message specifies the `multipart/mixed` type and a boundary string of `exampledelimtext123`. The message begins with the preamble, which is ignored by the recipient email client but can be seen by the human reader. It is common to put a string here such as the one given in this example. That way, if a person using a client that does not support MIME receives the message, the recipient will know what it is.    The first delimiter string is then placed in the message, followed by the first body part, the text Joe is sending Jane. This is preceded by whatever headers are needed by the body part, in this case `Content-Type: text/plain`. (Note, however, that this is the default in MIME, so it could be omitted here.) After the text message is another delimiter, and then the encoded JPEG photo in the second body part, with its own headers. Finally, there is one more delimiter, and then a space for the epilogue. This is ignored if present and is often not used at all.    It is possible to send a multipart message that has only a single body part. This is sometimes done to take advantage of the preamble area to provide information about how to decode a nontext media type. Of course, this can also be done by including such text decoding instructions as a body part.    ## MIME Encapsulated Message Type    The other composite media type is the `message` type, which is devoted to the special purpose of encapsulating existing email messages within the body of a new message, or encapsulating other types of messages. This may be another email message previously sent or a message of some other kind. This media type also provides flexibility for sending partial messages and other special types of communication. [Table 76-10](ch76s07.html#common_mime_message_media_type_subtypes \"Table 76-10. Common MIME message Media Type Subtypes\") shows the three subtypes defined in RFC 2046.    Table 76-10. Common MIME message Media Type Subtypes     | Type/Subtype | Description | Defining Source | | --- | --- | --- | | `message/rfc822` | Indicates that the body contains an encapsulated email, itself formatted according to the RFC 822 standard. Note that this doesn't necessarily mean it is a plain text email message; it could be a MIME message (though encapsulating MIME within MIME must be done carefully). | RFC 2046 | | `message/partial` | Allows the fragmentation of larger messages into pieces that can later be reassembled. | RFC 2046 | | `message/external-body` | Indicates that the body of the message is not actually contained in the message itself; instead, a reference is provided to where the body is located. Sufficient information to locate the real message body must be provided. | RFC 2046 |    ## MIME Content-Transfer-Encoding Header and Encoding Methods    One of the main reasons why MIME was created was the significant restrictions that the RFC 822 standard places on how data in email messages must be formatted. To follow the rules, messages must be encoded in US-ASCII, a 7-bit data representation. This means that even though each byte can theoretically have any of 256 values, in ASCII only 128 values are valid. Furthermore, lines can be no longer than 1,000 characters including the carriage return and line feed (CRLF) characters at the end, and those two characters cannot appear elsewhere.    For some types of data, such as text files, this is no big deal; but for others it is a serious problem. This is especially the case with binary data. If you look at the data in a video clip, MP3 file, or executable program, it will appear to be random gibberish. In fact, such data is not random; it is represented using specific rules, but the data is expressed in raw binary form, where any 8-bit byte can contain any value from 0 to 255, which is why it looks like junk to humans. More important, this means that this data does not follow the rules for RFC 822 files and cannot be sent directly in this form.    To send non-ASCII data in MIME, it must be encoded. The Content-Transfer-Encoding header is used to specify how a MIME message or body part has been encoded, so that it can be decoded by its recipient. Four types of encoding are defined: `7bit, 8bit`/`binary, quoted-printable`, and `base64`. The quoted-printable and base64 encodings are the most interesting ones, because they are what allow non-RFC-822 data to be sent using RFC 822.    ### Tip    **KEY CONCEPT** MIME supports four encoding methods: `7bit`, `8bit` (`binary`), `quoted-printable`, and `base64`. `7bit` encoding is standard ASCII and is used for text. `quoted-printable` encoding is for output that is mostly text but has some special characters that must be encoded. `base64` is used for arbitrary binary files. The 8-bit encoding method is defined in MIME but not used for RFC 822 messages.    ## 7-Bit and 8-Bit Encoding    `7bit` encoding indicates that the message is already in ASCII form compatible with RFC 822\\. It is the default and is what is assumed if no Content-Transfer-Encoding header is present.    The `8bit` and `binary` values are synonymous. They mean the message has been encoded directly in 8-bit binary form. Yes, I did just say that this would violate the rules of RFC 822\\. These options appear to have been included to support future mechanisms for transporting binary data directly. RFC 1652 describes an SMTP extension that discusses this in part: \"SMTP Service Extension for 8bit-MIMEtransport\" (there is no space between *MIME* and *transport*). However, the standard clearly states that this still does not allow the transfer of raw binary data using SMTP and RFC 822.    ## Quoted-Printable Encoding    Quotable-printable encoding is a special type that is used when most of the data is ASCII text, but it contains certain violations of the rules of RFC 822\\. These illegal sections are converted using special encoding rules so the data as a whole is consistent with RFC 822; only the problem bytes are encoded. The result is that RFC 822 compatibility is achieved while maintaining most of the data as regular text so it can still be easily understood by a human.    An example would be letters with tildes or accents, such as those used in French or Spanish. Another would be a text message formed using an editor that inserts carriage return characters in the middle of a line. Most of the message is still text. The `quoted-printable` encoding can be used here, with the carriage return characters represented as =0D (the hexadecimal value of the character prepended by an equal sign). RFC 2046 contains more details on how this is done.    ## Base64 Encoding    In contrast, `base64` encoding is more often used for raw binary data that is not in human-readable form anyway, such as graphical image, audio, video, and application files. This encoding is used to allow arbitrary binary data to be represented in ASCII form. The data is then sent as ASCII and decoded back into binary form by the recipient. The idea behind this type of encoding is simple: The data that needs to be sent can have any value for each 8-bit byte, which is not allowed. So why not rearrange the bits so the data fits into the 7-bit ASCII limits of RFC 822?    This is done by processing the data to be sent three bytes at a time. There are 24 bits in each three-byte block, which are carved into four sets of 6 bits each. Each 6-bit group has a value from 0 to 63 and is represented by a single ASCII character, as presented in [Table 76-11](ch76s07.html#mime_base_encoding_groups \"Table 76-11. MIME base64 Encoding Groups\").    Table 76-11. MIME base64 Encoding Groups     | 6-Bit Value | Encoding | 6-Bit Value | Encoding | 6-Bit Value | Encoding | 6-Bit Value | Encoding | | --- | --- | --- | --- | --- | --- | --- | --- | | 0 | A | 16 | Q | 32 | g | 48 | w | | 1 | B | 17 | R | 33 | h | 49 | x | | 2 | C | 18 | S | 34 | i | 50 | y | | 3 | D | 19 | T | 35 | j | 51 | z | | 4 | E | 20 | U | 36 | k | 52 | 0 | | 5 | F | 21 | V | 37 | l | 53 | 1 | | 6 | G | 22 | W | 38 | m | 54 | 2 | | 7 | H | 23 | X | 39 | n | 55 | 3 | | 8 | I | 24 | Y | 40 | o | 56 | 4 | | 9 | J | 25 | Z | 41 | p | 57 | 5 | | 10 | K | 26 | a | 42 | q | 58 | 6 | | 11 | L | 27 | b | 43 | r | 59 | 7 | | 12 | M | 28 | c | 44 | s | 60 | 8 | | 13 | N | 29 | d | 45 | t | 61 | 9 | | 14 | O | 30 | e | 46 | u | 62 | + | | 15 | P | 31 | f | 47 | v | 63 | / |    For example, suppose the first three bytes of the data to be sent were the decimal values 212, 39, and 247\\. These cannot all be expressed in 7-bit ASCII. In binary form, they are expressed like so:     | 11010100 00100111 11110111 |    We can divide these into four 6-bit groups:     | 110101 - 00 0010 - 0111 11 - 110111 |    Which yields the four values 53, 2, 31, and 55\\. Thus, the values 214, 39, and 247 would be encoded as the three ASCII characters 1Cf3\\. The conceptual steps of this process are shown in [Figure 76-2](ch76s07.html#mime_base64_encoding_in_this_simplified_ \"Figure 76-2. MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent.\").    ### Note    *The sequence of steps for the encoding are intended to help you understand the process. Computers inherently deal directly with bits and would not bother with converting to decimal before encoding the 6-bit groups into ASCII characters*.  ![MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent.](httpatomoreillycomsourcenostarchimages288291.png.jpg)  Figure 76-2. MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent.    This 3-to-4 encoding is done for all the data. The converted ASCII characters are then placed into the body of the entity instead of the raw binary data, 76 characters to a line. I showed how this is done in the second body part in the example in [Example 76-1](ch76s07.html#example_of_a_mime_multipart_message \"Example 76-1. Example of a MIME multipart message\") (except I didn't use 76 characters per line, to keep the line lengths short). One final character is involved in this scheme, the equal sign (=), which is used as a padding character when needed.    Since base64 characters are regular ASCII, they appear to SMTP like a regular text message. Of course, the data looks like gibberish to us, but that's not a problem since it will be converted back to its regular form and displayed to the recipient as an image, movie, audio, or whatever.    ### Tip    **KEY CONCEPT** MIME uses *base64* encoding to transform arbitrary 8-bit files into a form that is acceptable for communication in email. Each set of three 8-bit bytes is divided into four 6-bit groups, and each 6-bit group is represented by an ASCII character. Since the data is ASCII, it conforms to the RFC 822 message format standard, even if it is not human-readable. The receiving device reverses the encoding, changing each four-character block back into three 8-bit bytes.    The main drawback of the base64 method is that it is about 33 percent less efficient than sending binary data directly, using a protocol like the File Transfer Protocol (FTP). The reason is that three 8-bit bytes of binary data are sent as four ASCII characters, but of course, each ASCII character is represented using 8 bits itself. So there is one-third more overhead when using base64\\. In most cases, this is not a big deal, but it can be significant if downloading very large email files over a slow Internet connection.    Note that RFC 2046 also defines two other encodings: `ietf-token` and `x-token`. These are included to allow new encoding types to be defined in the future.    # MIME Extension for non-ASCII Mail Message Headers    All of the MIME mechanisms discussed up to this point deal with ways of encoding different kinds of ASCII and non-ASCII data into the *body* of an RFC 822 message. In addition to these capabilities, MIME also includes a way in which non-ASCII data can be encoded into *headers* of an RFC 822 message.    At this point, you might be wondering why anyone would want to do this. Sure, it makes sense to be able to use MIME to encode binary data such as an image into an email, but why do it in a header? Well, if you can't see the need for this, chances are that you are a native English speaker. ASCII does a great job of representing English, but isn't so good with many other languages. With RFC 822, speakers of languages that use non-ASCII characters were unable to use descriptive headers fully, such as the Subject and Comments headers. Some could not even properly express their own names!    The solution to this problem is the subject of RFC 2047, the third of the five main MIME standards. It describes how to encode non-ASCII text into ASCII RFC 822 message headers. The idea is straightforward: As with message bodies, the non-ASCII text is replaced with ASCII, and information is provided to describe how this was done.    With this technique, the value of a regular header is replaced by a MIME *encoded-word* that has the following syntax:     | =?*<charset>*?*<encoding>*?*<encoded-text>*?= |    The strings `=?` and `?=` are used to *bracket* the non-ASCII header, which flags it as a MIME encoded header to the recipient's email client. The other elements, separated by `?`, indicate how the non-ASCII text is encoded, as follows:    **<charset>** The character set used, such as `iso-8859-1`.    **<encoding>** Two different encoding types are defined, each represented by a single letter for brevity: `B` indicates base64 encoding, and `Q` indicates quoted-printable encoding (these encoding types are discussed in the previous section.    **<encoded-text>** The non-ASCII text that has been encoded as ASCII using the encoding type indicated.    As you can see, this method is analogous to how a non-ASCII message body or body part would be encoded, but the information about the encoding has been condensed so everything can fit in a single header line. The *<charset>* parameter is somewhat analogous to the Content-Type header for a message body, but since headers can contain only text, it specifies what kind of text it is. The *<encoding>* parameter is clearly equivalent to the Content-Transfer-Encoding header.    ### Tip    **KEY CONCEPT** In addition to its many functions for encoding a variety of data in email message bodies, MIME provides a feature that allows non-ASCII information to be placed into email headers. This is done by encoding the data using either *quoted-printable or base64* encoding, and then using a special format for the header value that specifies its encoding and character set. This technique is especially useful for email sent in languages that cannot be represented easily in standard ASCII, such as many Asian languages.    Here's an example of a non-ASCII header, using the GB2312 character set (for Chinese characters) and base64 encoding:    ``` Subject: =?GB2312?B?u7bTrbLOvNPDwLn61bm74Q==?= ```    I hope that doesn't say anything inappropriate; I took it from a piece of spam email I received once!    # Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)  ![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)  I emphasized in my overall description of TCP/IP email that communication using email requires the interaction of various protocols and elements. One mistake that some people make is to equate the method used for delivering email with the entire system. This is, however, an understandable mistake—just as the postal service is only a part of the whole system of mailing a letter, it is nonetheless a very big part. Likewise, the delivery of email from sender to recipient is arguably the most important part of email as a whole. In modern TCP/IP, this task is the responsibility of the *Simple Mail Transfer Protocol (SMTP)*.    In this chapter, I describe in detail the operation of SMTP. I begin with an overview and history of the protocol and a discussion of the standards that define it. I then examine the way that SMTP client/server communication and message transport work. I explain the way that SMTP servers establish connections and transaction sessions, and then the process by which mail is transferred from one server to another. I describe some of the special features implemented in SMTP and discuss SMTP security issues. I conclude with a reference summary of SMTP commands and replies.    ### Tip    **BACKGROUND INFORMATION** *My discussion of SMTP assumes that you already have a basic understanding of the general concepts of TCP/IP email, as well as familiarity with TCP/IP email addressing and message formatting. These topics are discussed in Chapters [Chapter 74](ch74.html \"Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS\"), [Chapter 75](ch75.html \"Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING\"), and [Chapter 76](ch76.html \"Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME\"), respectively*.    # SMTP Overview, History, and Standards    The overview and history of the TCP/IP email system in [Chapter 74](ch74.html \"Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS\") describes how TCP/IP evolved from its early beginnings to its current form. Since the mechanism used to deliver email is such a big part of the system as a whole, any overview of the system must of necessity discuss how delivery mechanisms have changed as well. In the case of TCP/IP, the delivery of mail evolved through many forms during the 1970s, as developers sought to find effective ways of communicating email messages between systems. Most of these efforts involved attempts to transmit mail using existing protocols; this makes sense, since it is easier to adapt a technology than design one from scratch.    ## SMTP Standards    One important achievement in the development of a mail system was the publishing of the *Mail Transfer Protocol (MTP)*, which was first defined in RFC 772 in September 1980, and then updated in RFC 780 in May 1981\\. MTP describes a set of commands and procedures by which two devices can connect using TCP to exchange email messages. Its operation is described largely using elements borrowed from two early TCP/IP application protocols that were already in use at that time: Telnet and the File Transfer Protocol (FTP). The commands of MTP are actually based directly on those of FTP.    Although there was nothing inherently wrong with basing email delivery on FTP, defining it this way made MTP somewhat of a hack. It was also restricted to the capabilities defined by FTP, a general file transfer protocol, so it was not possible to include features in MTP that were specific to sending and receiving mail. Due to the importance of email, a specific protocol designed for the purpose of delivering email was warranted. SMTP was first defined in RFC 788 and published in November 1981.    The name suggests that SMTP is simpler than the protocol that it replaced. Whether or not this is true is somewhat a matter of opinion; I do note that RFC 788 is 61 pages long, while the earlier RFC 780 was only 43 pages. What SMTP definitely has over MTP is *elegance*; the protocol is designed specifically for the transport of email. While it retains certain similarities to FTP, it is an independent protocol running over the Transmission Control Protocol (TCP). So, from a conceptual standpoint, it can be considered simpler than MTP. In terms of mechanics, the process SMTP uses to transfer an email message is indeed rather simple, especially compared to some other protocols.    RFC 788 described the operation of SMTP carrying email messages corresponding to the ARPAnet text message standard as described in RFC 733\\. Development of both email messages and SMTP continued, and in August 1982, a milestone in TCP/IP email was achieved when RFCs 821 and 822 were published. RFC 821 revised SMTP and became the defining standard for the protocol for the next two decades. RFC 822, its companion standard, became the standard for TCP/IP email messages carried by SMTP.    ### Tip    **KEY CONCEPT** The most important component of the TCP/IP email system is the *Simple Mail Transfer Protocol (SMTP)*. SMTP was derived from the earlier Mail Transfer Protocol (MTP) and is the mechanism used for the delivery of mail between TCP/IP systems and users. The only part of the email system for which SMTP is not used is the final retrieval step by an email recipient.    As the 1980s progressed, and TCP/IP and the Internet both grew in popularity, SMTP gradually overtook other methods to become the dominant method of email message delivery. For a number of years, the protocol was used mostly as is, with no new RFCs published to define new versions or formally change its behavior. This changed in February 1993, when RFC 1425, \"SMTP Service Extensions,\" was published. As the name suggests, this standard describes a process for adding new capabilities to extend how SMTP works, while maintaining backward compatibility with existing systems. SMTP with these extensions is sometimes called *Extended SMTP* or *ESMTP* (though use of this term seems not to be entirely universal).    As development of SMTP continued, RFC 1425 was revised in RFC 1651 in July 1994, and then in RFC 1869 in November 1995\\. Along with these revisions, a number of other RFCs defining particular SMTP extensions, such as pipelining and message size declaration, were defined.    In April 2001, another major milestone in TCP/IP email was reached when revisions of RFC 821 and RFC 822 were published, as RFCs 2821 and 2822, respectively. Both documents are consolidations of updates and changes that had been made to RFCs 821 and 822 between 1982 and 2001\\. And, no, I don't think it is a coincidence that the old and new RFC numbers are exactly 2,000 apart. RFCs 2820 and 2823 were both published in May 2000, so it looks like 2821 and 2822 were reserved for the email standards. I think this naming was a great idea, as it makes it clear that the new RFCs are revisions of the old ones.    RFC 2821 is the current base standard for SMTP. It incorporates the base protocol description from RFC 821 and the latest SMTP extensions as defined in RFC 1869\\. It updates the description of the email communication model to reflect the realities of modern TCP/IP networks, especially the email features built into the Domain Name System (DNS). We'll examine this in more detail in the next section.    ## SMTP Communication and Message Transport Methods    The TCP/IP email communication model describes the way email messages are conveyed from the sender to the recipient. In most cases, this involves the sender's client machine sending the email to its local SMTP server, which sends it to the recipient's local SMTP server, which then sends it to the recipient's local host. SMTP handles the transport between SMTP servers. In fact, the overall email communication model is largely described by the RFC 821 and 2821 SMTP standards.    The initial communication takes place between the sender's client machine and a local SMTP server that the sender is allowed to access. After submission of the email message, that SMTP server becomes responsible for delivering the message to the SMTP server responsible for the recipient's mailbox.    ### Early Email Communication Using Relaying    In the early days of email, when RFC 821 and its predecessors were first defined, the Internet was very different from what it is today. There was no DNS, and this made email delivery complex, because there was no way to map a mailbox address to the IP address of the SMTP server that managed that mailbox. Also, many proprietary networks were connected to the Internet, which meant that it was not always possible for any particular system to communicate with any other.    Given this, how could email be delivered? The most common way in the early days of SMTP was through a process called *relaying*. SMTP routing information was included along with the email address, to specify a sequence of SMTP servers that the mail should be relayed through to get to its destination. For example, if a sender using SMTP Server A wanted to send email to someone whose mailbox was on SMTP Server Z, the sender might have needed to specify that the mail be sent through intermediate SMTP Servers D, P, and U to get there. An SMTP connection would be established from Server A to Server D to send the message on one leg of its journey; then it would go from Server D to P, Server P to U, and then Server U to Z. The process is analogous to how Internet Protocol (IP) routing works, but at the application layer (actually using IP routing at a lower level).    You can probably see the problems with this quite easily: It's cumbersome, requires many devices to handle the mail, results in delays in communication, and requires the communication of source routes between SMTP servers. It was certainly functional, but it was far from ideal.    ### Modern Email Communication Using DNS and Direct Delivery    The creation of DNS radically changed how email delivery worked. DNS includes support for a special *mail exchange (MX)* record that allows easy mapping from the domain name in an email address to the IP address of the SMTP server that handles mail for that domain. I explain this in the description of the regular email address format in [Chapter 76](ch76.html \"Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME\"), as well as the section about DNS email support in [Chapter 56](ch56.html \"Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS\").    In the new system, SMTP communication is much simpler and more direct. The sending SMTP server uses DNS to find the MX record of the domain to which the email is addressed. This gives the sender the DNS name of the recipient's SMTP server. This is resolved to an IP address, and a connection can be made directly from the sender's SMTP server to the recipient's server to deliver the email. While SMTP still supports relaying, direct email delivery using MX records is faster and more efficient, and RFC 2821 makes clear that this is now the preferred method.    In this new system, SMTP is generally used only for two transfers: first, from the sender's client machine to the sender's local SMTP server, and then from that server to the recipient's local SMTP server, as shown in [Figure 74-1](ch74s03.html#email_communication_model_this_diagram_s \"Figure 74-1. Email communication model This diagram shows the four devices that are involved in a typical email communication between two users. Each device consists of a number of different elements, which communicate as indicated by the black arrows. Note the inherent asymmetry, because the method used to send an email from a user is not the same as that used to retrieve it from the server. The large, shaded arrows show a typical transaction: the sender composes mail and it goes to her local email spool. It is sent to the sender's local SMTP server using SMTP, and then to the recipient's SMTP server, where it goes into that user's inbox. It is then retrieved, usually using a protocol such as POP or IMAP.\") in [Chapter 74](ch74.html \"Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND CONCEPTS\"). (A distinct mail access protocol or method is used by the recipient for the last leg of the journey.) Each transfer of an email message between SMTP servers involves the establishment of a TCP connection, and then the transfer of the email headers and body using the SMTP mail transfer process. The following sections describe in detail how this occurs.    ### Tip    **KEY CONCEPT** In the early days of SMTP, mail was delivered using the relatively inefficient process of relaying from server to server across the internetwork. Today, when an SMTP server has mail to deliver to a user, it determines the server that handles the user's mail using the Domain Name System (DNS) and sends the mail directly to that server.    ## Terminology: Client/Server and Sender/Receiver    The original RFC 821 standard referred to the device that initiates an SMTP email transfer as the *sender* and the device that responds to it as the *receiver*. These terms were changed to *client* and *server* in RFC 2821 to \"reflect current industry terminology.\" Strictly speaking, this is correct, but in some ways, the more current terminology is significantly *less* clear.    As I explained in the general discussion of TCP/IP client/server operation in [Chapter 8](ch08.html \"Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE\"), the terms *client* and *server* are used in many different senses in networking, which often leads to confusion. In common parlance, the computers that handle email on the Internet are usually all called *SMTP servers*. This is because they run SMTP server software to provide SMTP services to client machines, such as end-user PCs. In addition, these devices are usually dedicated hardware servers running in network centers, typically managed by Internet service providers (ISPs).    However, the terms *client* and *server* are now used to refer to the roles in a particular SMTP communication as well. Since all SMTP servers both send and receive email, they all act as both clients and servers at different times. An SMTP server that is relaying an email will act as both server and client for that message, receiving it as a server, and then sending it to the next server as a client. Adding to this potential confusion is the fact that the initial stage in sending an email is from the sender's client machine to the sender's local SMTP server. Thus, the client role in an SMTP transaction may not be an actual SMTP server, but the server role will always be a server.    For all of these reasons, the old terms *sender* and *receiver* are still used in places in RFC 2821, where needed for clarity. I consider them much more straightforward and use them in the rest of this chapter.    ### Tip    **KEY CONCEPT** SMTP servers both send and receive email. The device sending mail acts as a client for that transaction, and the one receiving it acts as a server. To avoid confusion, it is easier to refer to the device sending email as the *SMTP sender* and the one receiving as the *SMTP receiver*; these terms were used when SMTP was originally created.    # SMTP Connection and Session Establishment and Termination    The delivery of email using SMTP involves the regular exchange of email messages among SMTP servers. SMTP servers are responsible for sending email that users of the server submit for delivery. They also receive email intended for local recipients, or for forwarding or relaying to other servers.    ## Overview of Connection Establishment and Termination    All SMTP communication is done using TCP. This allows SMTP servers to make use of TCP's many features that ensure efficient and reliable communication. SMTP servers generally must be kept running and connected to the Internet 24 hours a day, seven days a week, to ensure that mail can be delivered at any time. (This is a big reason why most end users employ access protocols such as the Post Office Protocol to access their received email rather than running their own SMTP servers.) The server listens continuously on the SMTP server port, well-known port number 25, for any TCP connection requests from other SMTP servers.    An SMTP server that wishes to send email normally begins with a DNS lookup of the MX record corresponding to the domain name of the intended recipient's email address to get the name of the appropriate SMTP server. This name is then resolved to an IP address; for efficiency, this IP address is often included as an *additional* record in the response to the MX request to save the sending server from needing to perform two explicit DNS resolutions.    The SMTP sender then establishes an SMTP session with the SMTP receiver. Once the session is established, mail transactions can be performed to allow mail to be sent between the devices. When the SMTP sender is finished sending mail, it terminates the connection. All of these processes involve specific exchanges of commands and replies, which are illustrated in [Figure 77-1](ch77s02.html#smtp_transaction_session_establishment_a \"Figure 77-1. SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session.\").    Let's take a look at these processes in more detail, starting with SMTP session establishment.    ## Connection Establishment and Greeting Exchange    The SMTP sender begins by initiating a TCP connection to the SMTP receiver. The sending SMTP server uses an ephemeral port number, since it is playing the role of the client in the transaction. Assuming that the server is willing to accept a connection, it will indicate that it is ready to receive instructions from the client by sending reply code 220\\. This is called the *greeting* or *service ready* response. It commonly includes the full domain name of the server machine, the version of the SMTP server software it is running, and possibly other information.    Now, it would be rude for the server acting as a client to start sending commands to the responding server without saying hello first, wouldn't it? So that's exactly what comes next: the client says, \"Hello.\" In the original SMTP protocol, this is done by issuing a HELO command, which includes the domain name of the sending (client) SMTP server as a courtesy. The receiving device then responds back with a return hello message using an SMTP reply code 250.    For example, if the SMTP server smtp.sendersite.org was making a connection to the SMTP server [mail.receiversplace.com](http://mail.receiversplace.com), it would say:    ``` HELO smtp.sendersite.org. ```    After receiving this greeting, [mail.receiversplace.com](http://mail.receiversplace.com) would respond back with a `hello` message of its own, something like this:    ``` 250 mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you. ```  ![SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session.](httpatomoreillycomsourcenostarchimages288293.png.jpg)  Figure 77-1. SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session.    (The chatty text is of course purely optional; most of the time, SMTP communication is between software programs, so the pleasantries are usually written by programmers who have a sense of humor.)    ## Connection Establishment Using SMTP Extensions    The SMTP extensions first defined in RFC 1425, and then in subsequent standards up to RFC 2821, define an alternative hello message for the client to use: EHLO (extended hello). An SMTP sender supporting SMTP extensions (and most do) uses EHLO instead of HELO in response to the 220 greeting. This serves both to say hello to the SMTP receiver and to tell it that the sender supports SMTP extensions.    If the SMTP receiver supports the extensions, it replies with the usual 250 reply, as well as a series of extra 250 responses. Each of these lists an EHLO *keyword* that indicates a particular SMTP extension the receiver supports. If the receiving server doesn't support the extensions, it will reject the EHLO command with a 500 reply code (\"syntax error, command not recognized\"). This tells the SMTP sender that it cannot use extensions. It will then issue a conventional HELO command, or it will QUIT the connection if it requires the SMTP extension to be present. (In practice, it is rare for a server to *require* the use of SMTP extensions.)    Here's the same example used earlier, but using EHLO. The sender says:    ``` EHLO smtp.sendersite.org. ```    Assuming [mail.receiversplace.com](http://mail.receiversplace.com) supports the SMTP extensions, a typical reply might look like this:    ``` 250-mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you. 250-SIZE 250-DSN 250 PIPELINING ```    Each of these additional replies identifies a particular SMTP extension supported by [mail.receiversplace.com](http://mail.receiversplace.com); in this case, message size declaration (SIZE), delivery status notification (DSN), and command pipelining. (The dashes after the 250 indicate a multiple-line response to a command; this is discussed in the \"SMTP Multiple-Line Text Replies\" section later in the chapter.)    Once the HELO or EHLO command has been sent and the receiving device has responded, the session is initiated. Further commands can be sent by the sending SMTP server to the responding server. These usually take the form of email message transfer transactions using the process described in the upcoming \"SMTP Mail Transaction Process\" section, and other command/reply exchanges as needed.    ## Connection Termination    When the sending device is finished sending all the email it has to transfer to the receiving device, and it has completed all its other activities, it terminates the session by issuing the QUIT command. This normally results in a 221 \"goodbye\" message from the SMTP receiver, which says something like \"closing transmission channel.\" The TCP connection is then terminated.    ### Tip    **KEY CONCEPT** An SMTP session consists of three basic phases. The session is first *established* through the creation of a TCP connection and the exchange of identity information between the SMTP sender and receiver using the HELO command. Once established, *mail transactions* can be performed. When the SMTP sender is finished with the session, it *terminates* it using the QUIT command. If *SMTP extensions* are supported, the SMTP sender uses the *EHLO (extended hello)* command instead of *HELO*, and the SMTP receiver replies with a list of extensions it will allow the SMTP sender to use.    A server may also terminate prematurely in special cases. If it is given a local command to shut down (for example, due to imminent rebooting of the hardware server on which it is running), it may respond to any routine command with a 421 response (\"Service not available, closing transmission channel\"). A server is not supposed to terminate a session simply due to receipt of an invalid command, however; this should happen only in special cases where session termination cannot be avoided.    # SMTP Mail Transaction Process    As described in the previous section, the delivery of an email message begins with the establishment of an SMTP session between the devices sending and receiving the message. The SMTP sender initiates a TCP connection to the SMTP receiver and then sends a HELO or an EHLO command, to which the receiver responds. Assuming no problems ensue, the session is then established and ready for actual email message transactions.    ## Overview of SMTP Mail Transaction    The SMTP mail transaction process itself consists of three steps:    *   **Transaction Initiation and Sender Identification** The SMTP sender tells the SMTP receiver that it wants to start sending a message and gives the receiver the email address of the message's originator.           *   **Recipient Identification** The sender tells the receiver the email address(es) of the intended recipients of the message.           *   **Mail Transfer** The sender transfers the email message to the receiver. This is a complete email message meeting the RFC 822 specification (which may be in MIME format as well).              That's it! So you can see that the word *Simple* in *Simple Mail Transfer Protocol* definitely has at least *some* merit. In fact, one question that sometimes comes up when examining SMTP is \"Why couldn't this process be even simpler?\" The first two steps identify the sender of the email and the intended recipient(s). But all of this information is already contained in headers in the message itself. Why doesn't SMTP just read that information from the message, which would make the mail transaction a *one-step* process?    The explanation isn't specifically addressed in the SMTP standards, but I believe there are several reasons for this:    *   Specifying the sender and recipients separately is more efficient, as it gives the SMTP receiver the information it needs up front before the message itself is transmitted. In fact, the SMTP receiver can decide whether or not to accept the message based on the source and destination email addresses.           *   Having this information specified separately gives greater control on how email is distributed. For example, an email message may be addressed to two recipients, but they may be on totally different systems; the SMTP sender might wish to deliver the mail using two separate SMTP sessions to two different SMTP receivers.           *   In a similar vein, there is the matter of delivering blind carbon copies. Someone who is BCC'ed a message must receive it without being mentioned in the message itself.           *   Having this information separate makes implementing security on SMTP much easier.              For these reasons, SMTP draws a distinction between the message itself, which it calls the *content*, and the sender and recipient identification, which it calls the *envelope*. This is consistent with our running analogy between regular mail and email. Just as the postal service delivers a piece of mail using only the information written on the envelope, SMTP delivers email using the envelope information, not the content of the message. It's not quite the case that the SMTP server doesn't look at the message itself, just that this is not the information it uses to manage delivery.    ### Note    *It is possible for the sender of a message to generate envelope information based on the contents of the message, but this is somewhat external to SMTP itself. It is described in the standard, but caution is urged in exactly how this is implemented*.    ## SMTP Mail Transaction Details    Let's take a more detailed look at the SMTP mail transaction process, using as aids the process diagram in [Figure 77-2](ch77s03.html#smtp_mail_transaction_process_once_an_sm \"Figure 77-2. SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received.\") and the sample transaction of [Example 77-1](ch77s03.html#example_of_an_smtp_mail_transaction \"Example 77-1. Example of an SMTP mail transaction\") (which has commands highlighted in bold and replies in italics).    Example 77-1. Example of an SMTP mail transaction    ``` `MAIL FROM:<joe@someplace.org>` *`250 <joe@someplace.org> . . . Sender ok`* `RCPT TO:<jane@somewhereelse.com>` *`250 <jane@somewhereelse.com> . . . Recipient ok`* `DATA` *`354 Enter mail, end with \".\" on a line by itself`* `From: Joe Sender <joe@someplace.org>` `To: Jane Receiver <jane@somewhereelse.com>` `Date: Sun, 1 Jun 2003 14:17:31 --0800` `Subject: Lunch tomorrow`  `Hey Jane,`  `It's my turn for lunch tomorrow. I was thinking we could` `[rest of message]` `Hope you are free. Send me a reply back when you get a chance.` `Joe.` `.` *`250 OK`* ```  ![SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received.](httpatomoreillycomsourcenostarchimages288295.png.jpg)  Figure 77-2. SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received.    The first two steps in the mail transaction are responsible for providing the receiving SMTP server with the envelope information just discussed. The transaction begins by the SMTP sender issuing a MAIL command. This serves to inform the receiver that a new transaction is commencing and also to tell it the *from* information on the envelope. Here's an example:    ``` MAIL FROM:<joe@someplace.org> ```    The email address of the originator is always enclosed in angle brackets (< and >). The SMTP receiver acknowledges the command with a 250 (\"OK\") reply message, sometimes sending back the address as a confirmation. Here's an example:    ``` 250 <joe@someplace.org> . . . Sender ok ```    Next, the SMTP sender uses RCPT commands to specify the intended recipients of the email that is being sent. Each RCPT line can contain only one recipient, so if multiple recipients are indicated, two or more RCPT commands must be issued. Each one normally specifies an email address, but if relaying is being used, the command may contain routing information as well. (As described earlier in the \"SMTP Communication and Message Transport Methods\" section, this is not as commonly done as it was in the past.) Here's an example:    ``` RCPT TO:<jane@somewhereelse.com> ```    Assuming the server accepts the email, it will give a 250 \"OK\" reply again, like so:    ``` 250 <jane@somewhereelse.com> . . . Recipient ok ```    The SMTP sender then issues the DATA command, which tells the SMTP receiver that the message is coming:    ``` DATA ```    The SMTP receiver responds with a 354 \"intermediate\" reply message, such as this:    ``` 354 Enter mail, end with \".\" on a line by itself ```    The SMTP sender then sends the email message, one line at a time, with a single dot (.) on a line to terminate it. The server confirms the receipt of the message with another 250 \"OK\" reply, and the transaction is finished.    ### Tip    **KEY CONCEPT** After an SMTP session is established, email messages are sent using the SMTP *mail transaction process*. The SMTP sender starts the transaction by identifying the sender of the email and then specifying one or more recipients. The email message itself is then transmitted to the SMTP receiver. Each email to be sent is a separate transaction.    While this indeed is quite simple, notice that I have shown an email transfer from a sender to one recipient, one in which there were no problems or complications in the transaction. Due either to command syntax or server issues, it is possible for various types of errors to occur at different stages of the process, which may result in the transaction failing. As you'll see shortly, security concerns may come also into play, leading to restrictions in what transactions a server may allow.    # SMTP Special Features, Capabilities, and Extensions    The primary job of the SMTP is to implement the TCP/IP email delivery system. Whenever the user of an SMTP server gives it an email message addressed to a remote mailbox, the server will attempt to transfer it to the appropriate destination server, using the SMTP mail transaction process. Many billions of such transfers are performed every day on the Internet, allowing email to reach its destination quickly anywhere around the world.    ## SMTP Special Features and Capabilities    In addition to this basic transfer mechanism, SMTP includes a number of other features and capabilities. These allow SMTP to support special requirements and auxiliary needs of the mail system, as described in detail in RFC 2821\\. It would take many pages to describe them all in detail, so I will provide a quick summary of the more important ones here so you know a bit about them.    The following are some of SMTP's special features:    **Mail Relaying** As discussed in the \"SMTP Communication and Message Transport Methods\" section earlier in this chapter, the protocol was once widely used in a relaying mode, where email was routed from one SMTP server to another to reach its destination. Today, the more efficient, normal method of email transfer on the Internet is directly from the sender's SMTP server to the recipient's server, using DNS MX records to determine the recipient SMTP server address. SMTP still includes the ability to relay mail from one server to another, provided certain conditions are met. Note that many servers won't relay mail because this feature has been abused for spamming and malicious hacking.    **Mail Forwarding** Under certain conditions, an SMTP server may agree to accept email for a remote mailbox and forward it to the appropriate destination. This sounds similar to relaying but is used in a different way. A common example is when users change their email address. For example, if you have worked at XYZ Industries for years and then retire, the company may no longer wish to let you receive email at the company's SMTP server. As a courtesy, however, they may forward email sent to you there, so that you receive it at your new company.    **Mail Gatewaying** Certain SMTP servers may be configured as email gateways. These devices translate TCP/IP email into a form suitable for another email system, and vice versa. Gatewaying is a complex topic because email systems can be so different. One of the more important problems is the inconsistency of addressing methods of different email systems.    **Address Debugging** SMTP includes a VRFY (verify) command that can be used to check the validity of an email address without actually sending mail to it.    **Mailing List Expansion** The SMTP command EXPN (expand) can be used to determine the individual email addresses associated with a mailing list. (Note, however, that this has nothing directly to do with mailing list software like *Majordomo*.)    **Turning** The original SMTP included a command that allows the SMTP sender and SMTP receiver to change roles. This could be used to allow SMTP Server A to send email to Server B, and then have Server B send email it has queued for Server A in the same session. In practice, this capability was not widely used for a variety of reasons, including security considerations. It is now officially not recommended but may still be implemented in some SMTP software.    These are just a few of the features that are mentioned in the SMTP standards. In addition, developers of a particular type of SMTP server software may give it other features as well. The HELP command is one way of determining what commands are supported by a particular SMTP server.    SMTP servers also must perform a great deal of background processing that doesn't get a great deal of attention. This includes managing connections, checking for errors in commands and email messages, and reacting accordingly. They must also be on the lookout for problem conditions, such as looping that may result in an email message being passed back and forth between two SMTP servers, each thinking the other is the intended recipient. In the event of an initial failure to deliver mail, an SMTP server is also required to retry communication periodically with the destination device and return a failure message to the sender if it cannot deliver the message after a certain period of time. RFC 2821 contains more details.    ## SMTP Extensions    As discussed earlier in this chapter, during the 1990s, many extensions to the basic operation of SMTP were defined. These are enabled when two SMTP servers supporting the extension set up a session using the EHLO command and appropriate extension response codes. [Table 77-1](ch77s04.html#smtp_extensions-id001 \"Table 77-1. SMTP Extensions\") summarizes some of the more interesting SMTP extensions that have been defined and gives the RFC number where each is described. You can find the full current set of SMTP extensions at [http://www.iana.org/assignments/mail-parameters](http://www.iana.org/assignments/mail-parameters).    Table 77-1. SMTP Extensions     | Extension Keyword | Extension | Defining Document | Description | | --- | --- | --- | --- | | 8BITMIME | 8-bit MIME support | RFC 1652 | Theoretically defines support for the 8-bit content transfer encoding type in MIME, but complications associated with this. See the discussion of content encoding in [Chapter 76](ch76.html \"Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME\") for details. | | AUTH | Authorization | RFC 2554 | Used to implement an authorization mechanism for servers requiring enhanced security. | | DSN | Delivery status notification | RFC 1891 | Allows an SMTP sender to request that the SMTP receiver notify it if a problem occurs in delivering a message. | | ENHANCEDSTATUSCODES | Enhanced status codes | RFC 2034, RFC 1893 | Extends the traditional three-digit SMTP reply code format with extra codes that provide more information. See the \"SMTP Replies and Reply Codes\" section later in this chapter for more information. | | PIPELINING | Command pipelining | RFC 2920 | Allows multiple commands to be transmitted in batches from the SMTP sender to the receiver, rather than sending one command at a time and waiting for a response code. | | SIZE | Message size declaration | RFC 1870 | Allows information about the size of a message to be declared by an SMTP sender prior to transmitting it, so the SMTP receiver can decide if it wants the message or not. |    ### Note    *Certain commands in the basic SMTP description that are considered optional are also sometimes considered extensions, such as the EXPN and HELP commands; I have not listed these here, since they are not true SMTP extensions*.    # SMTP Security Issues    When it comes to security and SMTP, the theme is a common one in TCP/IP: A lack of security in how the protocol is implemented, because it was developed when the Internet was just a small group of machines controlled by individuals who mostly knew and trusted each other or who were able to use physical security. Developers never imagined TCP/IP being used by millions of anonymous average Joes around the world, which necessitates far more attention to security than a small research internetwork like the ARPAnet.    With SMTP, security matters are, if anything, *worse* than they are with some of the other protocols. Not only does SMTP not have any real security mechanism, the original relaying model of SMTP communication is entirely designed around the idea of cooperation and trust among servers. Since most SMTP servers would be asked to handle a certain number of intermediate transfers, each server was required to accept mail from any originator to be delivered to any destination.    The basic assumption in this model is that users of SMTP servers would all be well behaved and not abuse the system by flooding intermediate servers with a lot of mail to be delivered or sending bogus messages to cause problems. This all changed as the Internet exploded in popularity in the 1990s. Con artists, malicious hackers, and disreputable salespeople discovered that email could be used for free delivery of messages simply by submitting them to an SMTP server for delivery. The result was overloaded servers, primarily due to the sending of large quantities of unwanted email, which Internet users commonly call *spam*.    ### Note    *The term spam, in this context, has nothing directly to do with the Hormel processed meat product. Its use in reference to massive amounts of email comes from a Monty Python comedy sketch in which that word is repeated in phrases over and over again*.    It is actually very easy to impersonate an SMTP server. You can use the Telnet Protocol to connect directly to an SMTP server on port 25\\. SMTP commands are all sent as text, and so are SMTP replies, so you can have a conversation with a server, and even manually perform a mail transaction. This is useful for debugging, but it also makes abuse of a wide-open SMTP server trivially easy. Since spammers often don't want to be identified, they employ spoofing techniques to make it more difficult to identify them, so resolving these problems is even more difficult.    Despite this obvious dilemma, efforts to implement a general security mechanism in SMTP have been resisted for two main reasons. First, there is no foolproof way to retrofit a new security mechanism onto something as widely used as SMTP without creating incompatibilities between newer and older systems. Second, many administrators were reluctant to do away completely with the general notion of cooperation among sites that has helped make the Internet so successful.    Still, something had to be done. The compromise was for system administrators to tighten up their SMTP servers through the imposition of both technical and policy changes. Naturally, these vary from one organization to another. Some of the more common SMTP security provisions include the following:    *   Checking the IP address of a device attempting connection and refusing even to start an SMTP session unless it is in a list of authorized client devices.           *   Restricting certain commands or features, such as email relaying, to authorized users or client servers. This is sometimes done by requiring authentication via the SMTP extension AUTH before the command will be accepted.           *   Limiting the use of commands such as EXPN to prevent unauthorized users from determining the email addresses of users on mailing lists.           *   Checking the validity of envelope information before accepting a message for delivery. Some servers will first verify that the originator's email address is valid before agreeing to accept the MAIL command. Many will check the recipient's address and refuse the message if delivery is not to a local mailbox. Others use even more advanced techniques.           *   Limiting the size of email messages that may be sent or the number that may be sent in a given period of time.           *   Logging all access to the server to keep records of server use and check for abuse.              Because of all the abuse in recent years, you will find that most SMTP servers implement these or other features, even though most of those features are not formally defined by the SMTP standards. Rather, they are enhancements built into individual SMTP server software packages.    SMTP was designed during an era in which Internet security was not much of an issue; as a result, the base protocol includes no security mechanism at all. Since email is so often abused today, most modern SMTP servers incorporate one or more security features to avoid problems.    Some of these measures can actually be quite sophisticated. For example, the SMTP server run by pair Networks, the great web-hosting company I have used for years, uses *POP-before-SMTP authentication*. This means that before the server will accept outgoing mail from the user via SMTP, the user must first log in to check incoming mail using the Post Office Protocol (POP). Since POP includes authentication, a successful POP login tells the server the user is authorized. This \"flips a switch\" in the server that allows the user to access the SMTP service after that login for a limited period of time. If this seems convoluted, then you're starting to get an idea of the hassle that spammers and malicious hackers have created for ISPs today.    It's also worth noting that SMTP does not include any mechanism for encryption to ensure the privacy of email transmissions. Users requiring security to control who sees their messages must use a separate encryption scheme to encode the body of the message prior to submission.    # SMTP Commands    Early TCP/IP email mechanisms were developed by borrowing techniques and elements from existing application protocols, especially Telnet and FTP. SMTP is an independent protocol, but its heritage can still be seen clearly in a few areas. One of the more obvious of these is in the method by which commands are issued by an SMTP sender and replies returned by an SMTP receiver.    Like FTP, all SMTP commands are sent as plain ASCII text over the TCP connection established between the client and server in an SMTP connection. These commands must end with the two-character CRLF sequence that normally terminates ASCII text as required for the Telnet Network Virtual Terminal (NVT; see [Chapter 87](ch87.html \"Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS\")). In fact, you can check the function of an SMTP server and even issue commands to it yourself simply by using Telnet to connect to it on port 25.    All SMTP commands are specified using a four-letter command code. Some commands also either allow or require parameters to be specified. The basic syntax of a command is    ``` <command-code> <parameters> ```    When parameters are used, they follow the command code and are separated from it by one or more space characters. For example, the HELO and EHLO commands are specified with the command code, a space character, and then the domain name of the SMTP sender, as you saw earlier in the discussion of SMTP connection establishment.    [Table 77-2](ch77s06.html#smtp_commands-id001 \"Table 77-2. SMTP Commands\") lists the commands currently used in modern SMTP in the order they are described in RFC 2821, with a brief description of each.    Table 77-2. SMTP Commands     | Command Code | Command | Parameters | Description | | --- | --- | --- | --- | | HELO | Hello | The domain name of the sender | The conventional instruction sent by an SMTP sender to an SMTP receiver to initiate the SMTP session. | | EHLO | Extended Hello | The domain name of the sender | Sent by an SMTP sender that supports SMTP extensions to greet an SMTP receiver and ask it to return a list of SMTP extensions the receiver supports. The domain name of the sender is supplied as a parameter. | | MAIL | Initiate Mail Transaction | Must include a FROM: parameter specifying the originator of the message, and may contain other parameters as well | Begins a mail transaction from the sender to the receiver. | | RCPT | Recipient | Must include a TO: parameter specifying the recipient mailbox, and may also incorporate other optional parameters | Specifies one recipient of the email message being conveyed in the current transaction. | | DATA | Mail Message Data | None | Tells the SMTP receiver that the SMTP sender is ready to transmit the email message. The receiver normally replies with an intermediate \"go ahead\" message, and the sender then transmits the message one line at a time, indicating the end of the message by a single period on a line by itself. | | RSET | Reset | None | Aborts a mail transaction in progress. This may be used if an error is received upon issuing a MAIL or RCPT command, if the SMTP sender cannot continue the transfer as a result. | | VRFY | Verify | Email address of mailbox to be verified | Asks the SMTP receiver to verify the validity of a mailbox. | | EXPN | Expand | Email address of mailing list | Requests that the SMTP server confirm that the address specifies a mailing list, and return a list of the addresses on the list. | | HELP | Help | Optional command name | Requests general help information if no parameter is supplied; otherwise, information specific to the command code supplied. | | NOOP | No Operation | None | Does nothing except for verifying communication with the SMTP receiver. | | QUIT | Quit | None | Terminates the SMTP session. |    Like FTP commands, SMTP commands are not case-sensitive.    ### Tip    **KEY CONCEPT** The SMTP sender performs operations using a set of *SMTP commands*. Each command is identifies using a four-letter code. Since SMTP supports only a limited number of functions, it has a small command set.    The commands in [Table 77-2](ch77s06.html#smtp_commands-id001 \"Table 77-2. SMTP Commands\") are those most commonly used in SMTP today. Certain other commands were also originally defined in RFC 821 but have since become obsolete. These include the following:    **SEND, SAML (Send and Mail), and SOML (Send or Mail)** RFC 821 defined a distinct mechanism for delivering mail directly to a user's terminal as opposed to a mailbox, optionally in combination with conventional email delivery. These were rarely implemented and obsoleted in RFC 2821.    **TURN** Reverses the role of the SMTP sender and receiver as described earlier in the SMTP special features discussion. This had a number of implementation and security issues and was removed from the standard in RFC 2821.    Finally, note that certain SMTP extensions make changes to the basic SMTP command set. For example, the *AUTH* extension specifies a new command (also called AUTH) that specifies an authentication method the SMTP client wants to use. Other extensions define new parameters for existing commands. For example, the SIZE extension defines a *SIZE* parameter that can be added to a *MAIL* command to tell the SMTP receiver the size of the message to be transferred.    # SMTP Replies and Reply Codes    All SMTP protocol operations consist of the plain ASCII text SMTP commands you saw in [Table 77-2](ch77s06.html#smtp_commands-id001 \"Table 77-2. SMTP Commands\"), issued by the sender to the receiver. The receiver analyzes each command, carries out the instruction requested by the sender if possible, and then sends a reply to the sender. The reply serves several functions: confirming command receipt, indicating whether or not the command was accepted, and communicating the result of processing the command.    Just as SMTP commands are sent in a manner reminiscent of how FTP internal commands work, SMTP replies are formatted and interpreted in a way almost identical to that of FTP replies. As with FTP, the reply consists of not just a string of reply text, but a combination of reply text and a numerical *reply code*. And as with FTP, these reply codes use three digits to encode various information about the reply, with each digit having a particular significance. The reply code is really the key part of the reply, with the reply text being merely descriptive.    ### Note    *The discussion of FTP reply codes in [Chapter 72](ch72.html \"Chapter 72. FILE TRANSFER PROTOCOL (FTP)\") contains a thorough explanation of the benefits of using these structured numeric reply codes*.    ## Reply Code Structure and Digit Interpretation    SMTP reply codes can be considered to be of the form *xyz*, where *x* is the first digit, *y* is the second, and *z* is the third.    The first reply code digit (*x*) indicates the success or failure of the command in general terms, whether a successful command is complete or incomplete, and whether an unsuccessful command should be tried again or not. This particular digit is interpreted in exactly the same way as it is in FTP, as shown in [Table 77-3](ch77s07.html#smtp_reply_code_format_first_digit_inter \"Table 77-3. SMTP Reply Code Format: First Digit Interpretation\").    Table 77-3. SMTP Reply Code Format: First Digit Interpretation     | Reply Code Format | Meaning | Description | | --- | --- | --- | | 1yz | Positive Preliminary Reply | An initial response indicating that the command has been accepted and processing of it is still in progress. The SMTP sender should expect another reply before a new command may be sent. Note that while this first digit type is formally defined in the SMTP specification for completeness, it is not currently used by any of the SMTP commands; that is, no reply codes between 100 and 199 exist in SMTP. | | 2yz | Positive Completion Reply | The command has been successfully processed and completed. | | 3yz | Positive Intermediate Reply | The command was accepted but processing it has been delayed, pending receipt of additional information. For example, this type of reply is often made after receipt of a DATA command to prompt the SMTP sender to send the actual email message to be transferred. | | 4yz | Transient Negative Completion Reply | The command was not accepted and no action was taken, but the error is temporary and the command may be tried again. This is used for errors that may be a result of temporary glitches or conditions that may change, such as a resource on the SMTP server being temporarily busy. | | 5yz | Permanent Negative Completion Reply | The command was not accepted and no action was taken. Trying the same command again is likely to result in another error. An example would be sending an invalid command. |    The second reply code digit (*y*) is used to categorize messages into functional groups. This digit is used in the same general way as in FTP, but some of the functional groups are different in SMTP, as you can see in [Table 77-4](ch77s07.html#smtp_reply_code_format_second_digit_inte \"Table 77-4. SMTP Reply Code Format: Second Digit Interpretation\").    Table 77-4. SMTP Reply Code Format: Second Digit Interpretation     | Reply Code Format | Meaning | Description | | --- | --- | --- | | x0z | Syntax | Syntax errors or miscellaneous messages. | | x1z | Information | Replies to requests for information, such as status requests. | | x2z | Connections | Replies related to the connection between the SMTP sender and SMTP receiver. | | x3z | Unspecified | Not defined. | | x4z | Unspecified | Not defined. | | x5z | Mail System | Replies related to the SMTP mail service itself. |    The third reply code digit (*z*) indicates a specific type of message within each of the functional groups described by the second digit. The third digit allows each functional group to have ten different reply codes for each reply type given by the first code digit (preliminary success, transient failure, and so on).    Again, as in FTP, these *x*, *y*, and *z* digit meanings are combined to make specific reply codes. For example, the reply code 250 is a positive reply indicating command completion, related to the mail system. It is usually used to indicate that a requested mail command was completed successfully.    [Table 77-5](ch77s07.html#smtp_reply_codes \"Table 77-5. SMTP Reply Codes\") contains a list of some of the more common SMTP reply codes taken from RFC 2821, in numerical order. For each, I have shown the typical reply text specified in the standard and provided additional descriptive information when needed.    As mentioned earlier, the actual text string for each reply code is implementation-specific. While the standard specifies dry response text such as \"Requested action completed\" for a 250 message, some servers will customize this code or even give different replies to different 250 messages, depending on the context.    Table 77-5. SMTP Reply Codes     | Reply Code | Reply Text | Description | | --- | --- | --- | | 211 | System status or system help reply. |  | | 214 | *<Help message…>* | Used for text sent in reply to the HELP command. | | 220 | *<servername>* Service ready. | Greeting message sent when TCP connection is first established to an SMTP server. | | 221 | *<servername>* closing transmission channel. | Goodbye message sent in response to a QUIT message. | | 250 | Requested mail action ok, completed | Indicates successful execution of a variety of commands. | | 251 | User not local; will forward to *<forward-path>* | Used when the SMTP receiver agrees to forward a message to a remote user. | | 252 | Cannot VRFY user, but will accept message and attempt delivery | Indicates that a server tried to verify an email address, but was not able to do so completely. Usually means the address appears to be valid but it was not possible to ascertain this to be positively true. | | 354 | Start mail input; end with <CRLF>.<CRLF> | Intermediate reply to a DATA command. | | 421 | *<servername>* Service not available, closing transmission channel | Sent in response to any command when the SMTP receiver prematurely terminates the connection. A common reason for this is receipt of a local shutdown command, due to a hardware reboot, for example. | | 450 | Requested mail action not taken: mailbox unavailable | Sent when a mailbox is busy due to another process accessing it. | | 451 | Requested action aborted: local error in processing | Local processing problem on the server. | | 452 | Requested action not taken: insufficient system storage. | Time to clean out the server's hard disk! | | 500 | Syntax error, command unrecognized | Response to a bad command or one that was too long. | | 501 | Syntax error in parameters or arguments |  | | 502 | Command not implemented | Command is valid for SMTP in general but not supported by this particular server. | | 503 | Bad sequence of commands | Commands were not sent in the correct order, such as sending the DATA command before the MAIL command. | | 504 | Command parameter not implemented. |  | | 550 | Requested action not taken: mailbox unavailable | Generic response given due to a problem with a specified mailbox. This includes trying to send mail to an invalid address, refusal to relay to a remote mailbox, and so forth. | | 551 | User not local; please try *<forward-path>* | Tells the SMTP sender to try a different path; may be used to support mailbox forwarding. | | 552 | Requested mail action aborted: exceeded storage allocation | User's mailbox is full. | | 553 | Requested action not taken: mailbox name not allowed | Specification of an invalid mailbox address. | | 554 | Transaction failed. | General failure of a transaction. |    ## SMTP Multiple-Line Text Replies    As in FTP, it is possible for an SMTP reply to contain more than one line of text. In this case, each line starts with the reply code, and all lines but the last have a hyphen between the reply code and the reply text to indicate that the reply continues. The last line has a space between the reply code and reply text, just like a single-line reply. See the \"Connection Establishment Using SMTP Extensions\" section earlier in this chapter for an example of a multiple-line response to an EHLO command.    ## Enhanced Status Code Replies    When the ENHANCEDSTATUSCODES SMTP extension is enabled, this causes supplemental reply codes to be issued by the SMTP receiver in response to each command. These codes are similar in some respects to the standard reply codes; they also use three digits, but the digits are separated by periods. These enhanced codes provide more information about the results of operations, especially errors.    For example, if you try to issue a RCPT command specifying a remote mailbox on a server that does not support this feature, it will send back a 550 reply, which is a generic error meaning \"requested action not taken: mailbox unavailable.\" When enhanced status codes are active, the response will be 550 5.7.1, which is the more specific message \"delivery not authorized, request refused.\" A full description of these enhanced codes can be found in RFC 1893.    ### Tip    **KEY CONCEPT** Each time the SMTP sender issues a command, it receives a *reply* from the SMTP receiver. SMTP replies are similar to FTP replies, using both a three-digit reply code and a descriptive text line. A special *enhanced status codes* SMTP extension is also defined; when enabled, this causes the SMTP receiver to return more detailed result information after processing a command.    # Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS  ![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)  The Simple Mail Transfer Protocol (SMTP) is responsible for most of the process of sending an electronic mail (email) message from the originator to the recipient. SMTP's job ends when the message has been successfully deposited into the recipient's mailbox on his local SMTP server.    In some cases, this mailbox is the end of the message's travels through cyberspace. More often, however, it is only a \"rest stop\"—the last step of the journey is for the message to be accessed and read by the user to whom it was sent. This may require that it be retrieved from the mailbox and transferred to another client machine. For a variety of reasons, SMTP is not used for the process of accessing a mailbox; instead, a special set of protocols and methods is designed specifically for email access and retrieval.    In this chapter, I describe some of the more common techniques used for TCP/IP email access and retrieval. I begin with an overview of the subject that describes in general the different paradigms used for email access and gives an overview of the protocols.    I then describe the operation of the very popular Post Office Protocol (POP), focusing on version 3 (POP3). I look at the protocol in general terms, discussing its history, the various versions of the protocol, and the standards that define them. I describe POP3's general operation and the communication between a client and server, concentrating on the three main states through which the session transitions. I then describe each of these states in sequence: the *Authorization* state, *Transaction* state, and *Update* state.    Following this, I discuss the other common mail access protocol: the Internet Message Access Protocol (IMAP). This includes a description of its benefits compared to the simpler POP3, a discussion of its operation, and a look at how client and server devices communicate, showing how the IMAP session moves through a series of four states.    Finally, I conclude with a discussion of two alternative methods of email access and retrieval. The first I call *direct server access*, which describes several ways that mailboxes are accessed without the use of special remote-access protocols such as POP and IMAP. The second is email access using a web browser. This is the newest email access method and is growing in popularity every year.    # TCP/IP Email Mailbox Access Model, Method, and Protocol Overview    In an ideal world, every device on the Internet would run SMTP server software, and that one protocol would be sufficient to implement the entire TCP/IP email system. You would compose email on your machine, your SMTP software would send it to a recipient's machine, and she would read it.    Here in the real world, however, this is not possible in general terms. An SMTP server must be connected to the Internet and available around the clock to receive email sent at any time by any of the millions of other computers in the world. Most of us either cannot or do not want to run machines continuously connected to the Internet, nor do we want to configure and maintain potentially complex SMTP software. For these reasons, a complete email exchange normally involves not two devices but four: A message is composed on the sender's client machine, and then transferred to the sender's SMTP server, then to the recipient's SMTP server, and finally to the recipient's machine.    The communication between SMTP servers is done with SMTP; so is the initial step of sending the email from the sender's machine to the sender's SMTP server. However, SMTP is not used for the last part of the process, which is accessing the recipient's mailbox. Instead, specific mailbox access and retrieval protocols and methods were devised.    Why not simply have mail wait on the recipient's SMTP server, and then have the mail sent to the recipient client device when it comes online, using SMTP? This isn't possible for two main reasons. First, SMTP was designed for the specific purpose of transporting only email. Having it responsible for client mailbox access would require adding more functionality, making it difficult to keep SMTP *simple*. In the same vein, SMTP works on a *push* model, with transactions being initiated by the sender. It would need changes to allow it to respond to requests from a client device that is only online intermittently.    The second reason is probably more important, because the current protocol configuration allows *flexibility* in how email is accessed. If we used SMTP, all we would be able to do is transfer email to the recipient's client machine. This would be functional, but it would greatly limit the capabilities of how email is used, especially, for example, for users who wish to access mail directly on the server and manipulate it there. Also consider the problem of people with special requirements, such as those who travel and may need to access email from a number of different client devices. There is thus an advantage to providing more than one way to access a mailbox.    ## Email Access and Retrieval Models    RFC 1733, \"Distributed Electronic Mail Models in IMAP4,\" describes three different paradigms, or models, for mail access and retrieval:    **Online Access Model** We would all be using this mode of access in my ideal world scenario, where every machine was always connected to the Internet running an SMTP server. We would have constant, direct online access to our mailboxes. In the real world, this model is still used by some Internet users, especially those who have UNIX accounts or run their own SMTP servers. I call this *direct server access*.    **Offline Access Model** In this paradigm, a user establishes a connection to a server where his mailbox is located. The user downloads received messages to the client device and then deletes them from the server mailbox. All reading and other activity performed on the mail can be done offline once the mail has been retrieved.    **Disconnected Access Model** This is a hybrid of online and offline access. The user downloads messages from the server, so she can read or otherwise manipulate them without requiring a continuous connection to the server. However, the mail is not deleted from the server, as in the offline model. At some time in the future, the user connects back with the server and synchronizes any changes made on the local device with the mailbox on the server. What sort of changes can be made? Examples include marking whether or not a message has been read to keep track of read and unread mail, and marking messages to which the user has already replied. These are important tools to help those with busy mailboxes keep track of what they need to do.    None of the three models is entirely better than the others. Each has advantages and disadvantages, which is why it is good that we have these options rather than the single SMTP protocol for mail access.    Direct server access has the main benefits of instant speed and universal access from any location. As for disadvantages, you must be online to read mail, and it usually requires that you use UNIX email clients, which with most people are not familiar. However, IMAP can also be used for online access.    Offline access has the main advantages of simplicity and short connection time requirements; you can easily connect to the mailbox, download messages, and then read them locally. But that makes this method somewhat inflexible and poorly suited to access from different machines. Still, it is currently the most popular access method because simplicity is important; it is best typified by POP.    Disconnected access attempts to combine the advantages of offline and online access without combining their disadvantages, and it does a pretty good job. The advantages are significant: the ability to access mail quickly and use it offline, while retaining and updating the mailbox on the server to allow access from different client machines. IMAP is popularly used for disconnected access. In the IMAP overview later in this chapter, I explore its advantages over offline access as well as its main disadvantages, which are complexity and far less universal support than POP (though acceptance of IMAP is slowly increasing).    Finally, in recent years, a somewhat new mailbox access method has become popular: email access using the World Wide Web. This technique allows a user to access his mailbox from any computer with an Internet connection and a web browser. It is a good example of line blurring, not only between the access models discussed here, but between TCP/IP applications—in this case, the Web and email.    ### Tip    **KEY CONCEPT** For flexibility, TCP/IP uses a variety of mailbox access and retrieval protocols and methods to allow users to read email. Three different models describe how these different methods work: the *online model*, in which email is accessed and read on the server; the *offline model*, in which mail is transferred to the client device and used there; and the *disconnected model*, in which mail is retrieved and read offline but remains on the server with changes synchronized for consistency.    # TCP/IP Post Office Protocol (POP/POP3)    The overall communication model used for TCP/IP email provides many options to an email user for accessing her electronic mailbox. The most popular access method today is the simple offline access model, in which a client device accesses a server, retrieves mail, and deletes it from the server. POP was designed for quick, simple, and efficient mail access; it is used by millions of people to access billions of email messages every day.    ## POP Overview, History, Versions, and Standards    Of the three mailbox access paradigms—online, offline, and disconnected—the offline model is probably the least capable in terms of features. And it is also the most popular. This may seem counterintuitive, but it is in fact a pattern that repeats itself over and over in the worlds of computing and networking. The reason is that *simplicity* and *ease of implementation* are keys to the success of any technology, and the offline mail access model beats the other two in these areas.    The history of offline email access goes back farther than one might expect—to the early 1980s. Two decades ago, not everyone and his brother were accessing the Internet to check email the way we do today. In fact, only a relatively small number of machines were connected using TCP/IP, and most users of these machines could access their email on a server, using the online access model.    However, even back then, developers recognized the advantages of being able to retrieve email from a server directly to a client computer, rather than accessing the mailbox on the server using Telnet or Network File System (NFS). In 1984, RFC 918 was published, defining POP. This protocol provided a simple way for a client computer to retrieve email from a mailbox on an SMTP server so it could be used locally.    The emphasis was on *simple*. The RFC for this first version of POP is only five pages long, and the standard it defined is extremely rudimentary. It describes a simple sequence of operations in which a user provides a name and password for authentication and then downloads the entire contents of a mailbox. Simple is good, but simple has limits.    RFC 937, \"Post Office Protocol - Version 2\" was published in February 1985\\. POP2 expanded the capabilities of POP by defining a much richer set of commands and replies. This included the ability to read only certain messages, rather than dumping a whole mailbox. Of course, this came at the cost of a slight increase in protocol complexity, but POP2 was still quite simple as protocols go.    These two early versions of POP were used in the mid-1980s, but not very widely. Again, this is simply because the need for an offline email access protocol was limited at that time; most people were not using the Internet before the 1990s.    In 1988, RFC 1081 was published, describing POP3\\. By this time, the personal computer (PC) was transitioning from a curiosity to a place of importance in the worlds of computing and networking. POP3 was based closely on POP2, but the new version was refined and enhanced with the idea of providing a simple and efficient way for PCs and other clients not normally connected to the Internet to access and retrieve email.    Development on POP3 continued through the 1990s, with several new RFCs published every couple of years. RFC 1081 was made obsolete by, in turn, RFCs 1225, 1460, 1725, and 1939\\. Despite the large number of revisions, the protocol itself has not changed a great deal since 1988; these RFCs contain only relatively minor tweaks to the original description of the protocol. RFC 1939 was published in 1996, and POP3 has not been revised since that time, though a few subsequent RFCs define optional extensions and additions to the basic protocol, such as alternative authentication mechanisms.    While POP3 has been enhanced and refined, its developers have remained true to the basic idea of a very simple protocol for quick and efficient email transfer. POP3 is a straightforward state-based protocol, with a client and server proceeding through three stages during a session. A very small number of commands is defined to perform simple tasks, and even after all its changes and revisions, the protocol has a minimum of fluff.    For reasons that are unclear to me, almost everyone refers to POP with its version number—that is, they say *POP3* instead of *POP*. This is true despite most people not using version numbers with many other protocols, and almost no one using any other version of POP. But it is the convention, and I will follow it in the rest of this discussion.    ### Tip    **KEY CONCEPT** POP is currently the most popular TCP/IP email access and retrieval protocol. It implements the offline access model, allowing users to retrieve mail from their SMTP server and use it on their local client computers. It is specifically designed to be a simple protocol and has only a small number of commands. The current revision of POP is version 3, and the protocol is usually abbreviated *POP3*.    ### Note    *Some implementations of POP attempt to implement the disconnected access model, with limited success. More often, however, IMAP is used for this purpose, since it is better suited to that access model. See the overview of IMAP later in this chapter for more details*.    ## POP3 General Operation    POP3 is a regular TCP/IP client/server protocol. In order to provide access to mailboxes, POP3 server software must be installed and continuously running on the server on which the mailboxes are located. This does not necessarily have to be the same physical hardware device that runs the SMTP server software that receives mail for those boxes—a mechanism such as NFS may be used to allow both the POP3 and SMTP servers to \"see\" mailboxes locally. POP3 clients are regular end-user email programs that make connections to POP3 servers to get mail; examples include Microsoft Outlook and Eudora Email.    POP3 uses TCP for communication, to ensure the reliable transfer of commands, responses, and message data. POP3 servers listen on well-known port number 110 for incoming connection requests from POP3 clients. After a TCP connection is established, the POP3 session is activated. The client sends commands to the server, which replies with responses and/or email message contents.    POP3 commands are three or four letters long and are case-insensitive. They are all sent in plain ASCII text and terminated with a CRLF sequence, just as with FTP and SMTP commands. POP3 replies are also textual, but the protocol does not use the complex three-digit reply code mechanism of FTP (and SMTP). In fact, it defines only two basic responses:    **+OK** A positive response, sent when a command or action is successful    **-ERR** A negative response, sent to indicate that an error has occurred    These messages may be accompanied by explanatory text, especially in the case of an ERR response, to provide more information about the nature of the error.    ## POP3 Session States    POP3 is described in terms of a *finite state machine (FSM)*, with a session transitioning through three states during the course of its lifetime, as shown in [Figure 78-1](ch78s02.html#pop3_finite_state_machine_pop_uses_a_fin \"Figure 78-1. POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.\"). (I describe the concepts behind using FSM as a descriptive tool in [Chapter 47](ch47.html \"Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION\").) Fortunately, unlike the FSMs of protocols like TCP, this one really is simple, because it is *linear*. The session goes through each state once and only once, in the following sequence:    1.  **Authorization State** The server provides a greeting to the client to indicate that it is ready for commands. The client then provides authentication information to allow access to the user's mailbox.           2.  **Transaction State** The client is allowed to perform various operations on the mailbox. These include listing and retrieving messages and marking retrieved messages for deletion.           3.  **Update State** When the client is finished with all of its tasks and issues the QUIT command, the session enters this state automatically, where the server actually deletes the messages marked for deletion in the Transaction state. The session is then concluded, and the TCP connection between the two is terminated.            ![POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.](httpatomoreillycomsourcenostarchimages288297.png.jpg)  Figure 78-1. POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.    POP3 is designed so that only certain commands may be sent in each of these states. Here, I will describe the activities that take place in these three states, including the commands that are issued by the client in each.    ### Tip    **KEY CONCEPT** POP3 is a client/server protocol that is described using a simple linear sequence of states. A POP3 session begins with a POP3 client making a TCP connection to a POP3 server, at which point the session is in the *Authorization* state. After successful authentication, the session moves to the *Transaction* state, where the client can perform mail access transactions. When it is finished, the client ends the session and the *Update* state is entered automatically, where cleanup functions are performed and the POP3 session ended.    ### POP3 Authorization State: User Authentication Process and Commands    A session between a POP3 client and a POP3 server begins when the client sends a TCP connection request to the server. The connection is established using the standard TCP three-way handshake, and the POP3 session commences. The first of the three states of a POP3 session, the Authorization state, is responsible for authenticating the POP3 client with the server.    When the session first enters this state, the server sends a greeting message to the client. This tells the client that the connection is alive and ready for the client to send the first command. An example of such a greeting follows:    ``` +OK POP3 server ready ```    The client is now required to authenticate the user who is trying to access a mailbox. This proves that the user has the right to access the server and identifies the user so the server knows which mailbox is being requested.    The normal method of authorization in POP3 is a standard user name/password login. This is pretty much identical to how a login is performed in FTP; even the commands are the same. First the client issues a USER command along with the user's mailbox name (his user name or email address). The server responds with an intermediate acknowledgment. The client then uses the PASS command to send the user's password. Assuming the login is valid, the server responds to the client with an acknowledgment that indicates successful authentication. The response will also typically specify the number of messages waiting for the user in the mailbox. This process is illustrated in [Figure 78-2](ch78s02.html#pop3_user_authentication_process_once_th \"Figure 78-2. POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access.\").  ![POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access.](httpatomoreillycomsourcenostarchimages288299.png.jpg)  Figure 78-2. POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access.    [Example 78-1](ch78s02.html#example_of_pop3_authorization \"Example 78-1. Example of POP3 authorization\") shows an example POP3 authorization, with the client's commands in boldface and the server's responses in italics.    ### Note    *Some servers may require only the name of the user* (jane), *while others require the full email address, as shown in [Example 78-1](ch78s02.html#example_of_pop3_authorization \"Example 78-1. Example of POP3 authorization\")*.    Example 78-1. Example of POP3 authorization    ``` *`+OK POP3 server ready`* `USER jane@somewhereelse.com` *`+OK`* `PASS *******` *`+OK jane@somewhereelse.com has 3 messages`* ```    If authorization is successful, the POP3 session transitions to the Transaction state, where mail-access commands can be performed. If the user name or password is incorrect, an error response is given, and the session cannot proceed. The authorization may also fail due to technical problems, such as an inability by the server to lock the mailbox (perhaps due to new mail arriving via SMTP).    Since user name/password authorization is considered by many people to be insufficient for the security needs of modern internetworks, the POP3 standard also defines an alternative authentication method using the APOP command. This is a more sophisticated technique based on the Message Digest 5 (MD5) encryption algorithm. If the server supports this technique, in its opening greeting it provides a string indicating a *timestamp* that is unique for each POP3 session. The client then performs an MD5 calculation using this timestamp value and a shared secret known by the server and client. The result of this calculation is included in the client's APOP command. If it matches the server's calculation, authentication is successful; otherwise, the session remains in the Authorization state.    POP was also designed to be extendable through the addition of other authentication mechanisms. This process is based on the use of the optional AUTH command, as described in RFC 1734.    ### Tip    **KEY CONCEPT** A POP3 session begins in the Authorization state, where the client device is expected to authenticate with the server. By default, POP3 uses only a simple user name/password authentication method. Optional authentication methods are also defined for applications requiring more security.    ### POP3 Transaction State: Mail and Information Exchange Process and Commands    Once the POP3 client has successfully authenticated the user who is performing mailbox access, the session transitions from the Authorization state to the Transaction state. There's no real mystery as to what this phase of the connection is all about: The POP3 client issues the commands that perform mailbox access and message retrieval transactions.    Most of the commands defined in POP3 are valid only in the Transaction state. [Table 78-1](ch78s02.html#pop_transaction_commands \"Table 78-1. POP3 Transaction Commands\") lists each of them, in the order in which they appear in RFC 1939.    Table 78-1. POP3 Transaction Commands     | Command Code | Command | Parameters | Description | | --- | --- | --- | --- | | STAT | Status | None | Requests status information for the mailbox. The server will normally respond, telling the client the number of messages in the mailbox and the number of bytes of data it contains. Optionally, more information may also be returned. | | LIST | List Messages | Optional message number | Lists information for the messages in a mailbox; generally this means showing the message number and its size. If a message number is given, only that message's information is provided; otherwise, the full contents of the mailbox are described, one line at a time, with a line containing just a single period at the end. | | RETR | Retrieve | Message number | Retrieves a particular message from the mailbox. The server responds with a standard +OK message and then immediately sends the message in RFC 822 format, one line at a time. A line with a single period is sent after the last line. | | DELE | Delete | Message number | Marks a message as deleted. Once deleted, any further attempt to access a message (using LIST or RETR, for example) results in an error. | | NOOP | No Operation | None | Does nothing; the server just returns an +OK reply. | | RSET | Reset | None | Resets the session to the state it was in upon entry to the Transaction state. This includes undeleting any messages already marked for deletion. | | TOP | Retrieve Message Top | Message number and number of lines | Allows a client to retrieve only the beginning of a message. The server returns the headers of the message and only the first *N* lines, where *N* is the number of lines specified. This command is optional and may not be supported by all servers. | | UIDL | Unique ID Listing | Optional message number | If a message number was specified, returns a unique identification code for that message; otherwise, returns an identification code for each message in the mailbox. This command is optional and may not be supported by all servers. |    The Transaction state is relatively unstructured in that commands do not need to be issued in any particular order to meet the requirements of the standard. However, there is a natural progression to how a mailbox is retrieved, and that means the commands are usually used in the following order:    1.  The client issues a STAT command to see the number of messages in the mailbox.           2.  The client issues a LIST command, and the server tells it the number of each message to be retrieved.           3.  The client issues a RETR command to get the first message and, if successful, marks it for deletion with DELE. The client uses RETR/DELE for each successive message.              [Example 78-2](ch78s02.html#example_of_the_pop3_mail_exchange_proces \"Example 78-2. Example of the POP3 mail exchange process\") and [Figure 78-3](ch78s02.html#pop3_mail_exchange_process_this_diagram_ \"Figure 78-3. POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)\") show a sample access sequence for a mailbox containing two messages that total 574 bytes; the client's commands are in boldface and the server's responses are in italics.    Example 78-2. Example of the POP3 mail exchange process    ``` `STAT` *`+OK 2 574`* `LIST` *`+OK`* *`1 414`* *`2 160`* *`.`* `RETR 1` *`+OK`* *`(Message 1 is sent)`* *`.`* `DELE 1` *`+OK message 1 deleted`* `RETR 2` *`+OK`* *`(Message 2 is sent)`* *`.`* `DELE 2` *`+OK message 2 deleted`* `QUIT` ```    The exact message sent in reply to each command is server-dependent; some say +OK, while others provide more descriptive text, as I have done here for the responses to the DELE command.    ### Tip    **KEY CONCEPT** After successful authorization, the POP3 session transitions to the Transaction state, where the client actually accesses email messages on the server. The client normally begins by first retrieving statistics about the mailbox from the server and obtaining a list of the messages in the mailbox. The client then retrieves each message one at a time, marking each retrieved message for deletion on the server.    In some cases, a POP3 client may be configured to *not* delete messages after retrieving them. This is useful, for example, when Web-based access is being combined with a conventional email client program.    ### POP3 Update State: Mailbox Update and Session Termination Process and Commands    Once the POP3 client has completed all the email message access and retrieval transactions that it needs to perform, it isn't quite finished yet. The POP3 standard defines a final session state, the Update state, to perform various housekeeping functions, after which both the POP3 session and the underlying TCP connection are terminated.    The transition from the Transaction state to the Update state occurs when the POP3 client issues the QUIT command. This command has no parameters and serves to tell the POP3 server that the client is finished and wishes to end the session. The POP3 standard lists this command as part of its description of the Update state, though it is actually issued from the Transaction state.  ![POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)](httpatomoreillycomsourcenostarchimages288301.png.jpg)  Figure 78-3. POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)    After the POP3 server receives the QUIT command, it deletes any messages that were previously marked for deletion by the DELE command in the Transaction state. It's interesting to note that POP chose to implement this two-stage deletion process. The standard doesn't describe specifically why this was done, but it seems likely that it is a precaution to insure against accidental deletion and loss of mail.    By delaying actual deletion until the Update state, the server can verify that it has received and processed all commands prior to the move to the Update state. This also allows the deletion of messages to be undone if necessary, using the RSET command, if the user changes her mind about the deletion prior to exiting the Transaction state. Finally, if any problem occurs with communication between the client and server that causes the TCP connection to be interrupted prematurely before the QUIT command is issued, no messages will be removed from the mailbox, giving the client a second chance to retrieve them in case they were not received properly.    Once the deleted messages have been removed, the server returns an acknowledgment to the client: +OK if the update was successful, or -ERR if there was a problem removing one or more of the deleted messages. Assuming no problems occurred, the +OK response will also contain a goodbye message of some sort, indicating that the session is about to be closed. The TCP connection between the client and server is then torn down and the session is done.    ### Tip    **KEY CONCEPT** When the POP3 client is done with its email transactions, it issues the QUIT command. This causes the Update state to be entered automatically, where the server performs necessary cleanup operations, including deleting any messages marked for deletion in the Transaction state.    A POP3 mail-retrieval session normally lasts a few seconds or minutes, but it can take many minutes if the mailbox is large and the connection between the client and server is slow. There is no limit on how long the client and server can be connected, as long as commands continue to be sent by the client. A POP3 server will normally implement an inactivity timer, however, which is customizable but must have a duration of no less than ten minutes. If the connection is idle for the full duration of the inactivity timer, the server assumes that the client has experienced some sort of a problem and shuts down the connection. If this occurs, the server does not delete any messages marked for deletion—again, this is to give the client another chance to retrieve those messages if a problem occurred getting them the first time.    # TCP/IP Internet Message Access Protocol (IMAP/IMAP4)    The offline mailbox access model provides the basic mail access functions that most users need. Using the popular POP3, a user can access her mailbox and retrieve messages so she can read them on her local machine. This model has the advantage of simplicity, but it does not provide many features that are increasingly in demand today, such as keeping track of the status of messages and allowing access from many client devices simultaneously. To provide better control over how mail is accessed and managed, we must use either the online or disconnected access models. IMAP was created to allow these access models to be used; it provides rich functionality and flexibility for the TCP/IP email user.    ### Tip    **RELATED INFORMATION** *The main price that IMAP pays for having a much richer set of functionality than POP is much more complexity. In this section, I have described IMAP in approximately the same level of detail that I did earlier for POP. Please see the appropriate RFC documents for the full description of the protocol and more discussion of some of its nuances, particularly the syntax of the many commands and parameters, which would take dozens of pages to cover fully here*.    ## IMAP Overview, History, Versions, and Standards    POP3 has become the most popular protocol for accessing TCP/IP mailboxes, not because of its rich functionality, but in spite of its lack of functionality. POP implements the offline mail access model, where mail is retrieved and then deleted from the server where the mailbox resides, so it can be used on a local machine. Millions of people use POP3 every day to access incoming mail. Unfortunately, due to the way the offline access model works, POP3 cannot be used for much else.    The online model is the one we would use in an ideal world, in which we all would be always connected to the Internet all the time. Offline access is a necessity, however, because most user client machines are connected to the Internet only periodically. The transfer of mail from the server to a client machine removes the requirement that we be online to perform mail functions, but it costs us the benefits of central mail storage on the server.    This may seem counterintuitive: how can it be better to have mail stored on some remote server rather than on our local computer? The main reason for this is flexibility of access. One of the biggest problems with offline access using POP3 is that mail is transferred permanently from a central server to one client machine. This is fine as long as an individual uses only that one machine, but what if the person has separate work and home computers or travels a great deal? And what about a mailbox shared by many users? These concerns have become more and more important in recent years.    Another issue is data security and safety. Mail servers run by Internet service providers (ISPs) are usually located in professionally managed data centers. They are carefully controlled and monitored, and backups occur on a routine basis. Most people do not take this sort of care with their own PCs and Macs, nor do they back up their data routinely. So, it's less likely that people will lose mail that on the server.    Of course, we still have the problem of not wanting to force users to be online all the time to access their mail. The solution is the disconnected mailbox access model, which marries the benefits of online and offline access. Mail is retrieved for local use as in the offline model, so the user does not need to be connected to the server continuously. However, changes made to the mailbox are synchronized between the client and the server. The mail remains on the server, where it can be accessed from a different client in the future, and the server acts as a permanent home base for the user's mail.    Recognizing these benefits, developers made some attempts to implement POP using the disconnected access model. Typically, this was done by using POP commands to retrieve mail but still leave it on the server, which is an option in many client programs. This works, but only to a limited extent; for example, keeping track of which messages are new or old becomes an issue when they are both retrieved and left on the server. POP simply lacks the features required for proper disconnected access because it was not designed for it.    In the mid-1980s, development began at Stanford University on a new protocol that would provide a more capable way of accessing user mailboxes. The result was the Interactive Mail Access Protocol, later renamed the Internet Message Access Protocol (IMAP).    ### IMAP Features    IMAP was designed for the specific purpose of providing flexibility in how users access email messages. It, in fact, can operate in all three of the access modes: online, offline, and disconnected access. Of these, the online and disconnected access modes are of interest to most users of the protocol; offline access is similar to how POP works.    IMAP allows a user to do all of the following:    *   Access and retrieve mail from a remote server so it can be used locally while retaining it on the server.           *   Set message flags so that the user can keep track of which messages he has already seen, already answered, and so on.           *   Manage multiple mailboxes and transfer messages from one mailbox to another. You can organize mail into categories, which is useful for those working on multiple projects or those who are on various mailing lists.           *   Determine information about a message prior to downloading it, to decide whether or not to retrieve it.           *   Download only portions of a message, such as one body part from a MIME multipart message. This can be quite helpful in cases where large multimedia files are combined with short text elements in a single message.           *   Manage documents other than email. For example, IMAP can be used to access Usenet messages.              Of course, there are some disadvantages to IMAP, but not many. One disadvantage is that it is more complex, but it's really not that complex, and the protocol has been around for enough years that this is not a big issue. The most important sticking point with IMAP is simply that it is used less commonly than POP, so providers that support it are not as easy to find as those that support POP. This is changing, however, as more people discover IMAP's benefits.    ### Tip    **KEY CONCEPT** POP is popular because of its simplicity and long history, but it has few features and normally supports only the rather limited offline mail access method. To provide more flexibility for users in how they access, retrieve, and work with email messages, IMAP was developed. IMAP is used primarily in the online and disconnected access models. It allows users to access mail from many different devices, manage multiple mailboxes, select only certain messages for downloading, and much more. Due to its many capabilities, it is growing in popularity.    ### IMAP History and Standards    IMAP has had a rather interesting history—interesting in the sense that the normal orderly development process that is used for most TCP/IP protocols broke down. The result wasn't quite as bad as the chaos that occurred in the development of SNMP version 2 (see [Chapter 65](ch65.html \"Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW\")), but it was still unusual.    The first version of IMAP formally documented as an Internet standard was IMAP version 2 (IMAP2) in RFC 1064, published in July 1988\\. This was updated in RFC 1176, August 1990, retaining the same version number. However, it seems that some of the people involved with IMAP were not pleased with RFC 1176, so they created a new document defining version 3 of IMAP (IMAP3): RFC 1203, published in February 1991\\. This is described by its authors as a \"counter proposal.\"    For whatever reason, however, IMAP3 was never accepted by the marketplace. Instead, people kept using IMAP2 for a while. An extension to the protocol was later created, called IMAP2bis, which added support for Multipurpose Internet Mail Extensions (MIME) to IMAP. This was an important development due to the usefulness of MIME, and many implementations of IMAP2bis were created. Despite this, for some reason IMAP2bis was never published as an RFC. This may have been due to the problems associated with the publishing of IMAP3.    ### Note    *bis is a Latin word meaning again. It is sometimes used to differentiate changed technical documents from their previous versions when no official new version number is allocated*.    In December 1994, IMAP version 4 (IMAP4) was published in two RFCs: RFC 1730 describing the main protocol, and RFC 1731 describing authentication mechanisms for IMAP4\\. IMAP4 is the current version of IMAP that is widely used today. It continues to be refined; the latest specific version is actually called version 4rev1 (IMAP4rev1), defined in RFC 2060, and then most recently by RFC 3501\\. Most people still just call this *IMAP4*, and that's what I will do in the rest of this section.    ## IMAP General Operation    IMAP4 is a standard client/server protocol like POP3 and most other TCP/IP application protocols. For the protocol to function, an IMAP4 server must be operating on the server where user mailboxes are located. Again, as with POP3, this does not necessarily need to be the same physical server that provides SMTP service. The mailbox must in some way be made accessible to both SMTP for incoming mail, and to IMAP4 for message retrieval and modification. A mechanism for ensuring exclusive access to avoid interference between the various protocols is also needed.    IMAP4 uses the Transmission Control Protocol (TCP) for communication. This ensures that all commands and data are sent reliably and received in the correct order. IMAP4 servers listen on well-known port number 143 for incoming connection requests from IMAP4 clients. After a TCP connection is established, the IMAP4 session begins.    ## IMAP Session States    The session between an IMAP4 client and server is described in the IMAP standards using an FSM. Again, this is similar to how POP3 operates, except that IMAP4 is a bit more complex. Its FSM defines four states instead of three, and where a POP3 session is linear (going through each state only once) in IMAP4 the session is not. However, the state flow is still fairly straightforward, mostly following a logical sequence from one state to the next. The IMAP FSM is illustrated in [Figure 78-4](ch78s03.html#imap_fsm_the_imap_fsm_is_slightly_more_c \"Figure 78-4. IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in Figure 78-1) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.\").  ![IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in ) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.](httpatomoreillycomsourcenostarchimages288303.png.jpg)  Figure 78-4. IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in [Figure 78-1](ch78s02.html#pop3_finite_state_machine_pop_uses_a_fin \"Figure 78-1. POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.\")) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.    The following are the IMAP states, in the usual sequence in which they occur for a session:    1.  **Not Authenticated State** The session normally begins in this state after a TCP connection is established, unless the special IMAP *preauthentication* feature has been used (we'll get to this feature shortly). At this point, the client cannot really do much aside from providing authentication information so it can move to the next state.           2.  **Authenticated State** The client has completed authentication, either through an authentication process in the prior state or through preauthentication. The client is now allowed to perform operations on whole mailboxes. The client must select a mailbox before individual message operations are permitted.           3.  **Selected State** After a mailbox has been chosen, the client is allowed to access and manipulate individual messages within the mailbox. When the client is finished with the current mailbox, it can close it and return to the Authenticated state to select a new one to work with, or it can log out to end the session.           4.  **Logout State** The client may issue a Logout command from any of the other states to request that the IMAP session be ended. The session may also enter this state if the session inactivity timer expires. The server sends a response, and the connection is terminated.              ### Tip    **KEY CONCEPT** IMAP is a client/server application, and an IMAP session begins with the client making a TCP connection to the server. The session then normally starts in the Not Authenticated state and remains there until successful authentication. In the Authenticated state, the client may perform operations on whole mailboxes, but a mailbox must be selected to transition to the Selected state, where individual messages can be manipulated. The client can work with many mailboxes by selecting each one in turn; it then logs out from the server.    Of the four IMAP states, only the first three are *interactive*, meaning states in which commands are actively issued by the client and responses provided by the server. Some IMAP commands can be used while the session is in any state; others are state-specific.    ### Session Establishment and Greeting    The server determines in which state the IMAP session begins and sends a *greeting* message to tell the client the session is established and indicate which state it is in. Normally, the server will begin the session in the Not Authenticated state. This is conveyed to the client with the normal OK greeting message, such as this:    ``` * OK <*`server-name`*> server ready ```    ### Preauthentication    In certain circumstances, a server may already know the identity of the client, perhaps as a result of some external authentication mechanism not part of the IMAP protocol. In this case, a special greeting is used:    ``` * PREAUTH <*`server-name`*> server ready, logged in as <*`user-name`*> ```    This tells the client that it is already in the Authenticated state.    If the server decides for whatever reason not to accept a new session from the client, it can respond with a BYE response, instead of OK or PREAUTH, and close the TCP connection.    ## IMAP Commands, Results, and Responses    Once an IMAP session is established, all communication between the client and server takes place in the form of *commands* sent by the client and *responses* returned by the server. Like POP3, commands and responses are sent as strings of ASCII text and terminated with a CRLF sequence, making them compatible with the way data is sent using the Telnet Protocol. However, IMAP has a few differences from POP and many other TCP/IP application protocols.    The first interesting thing about IMAP commands is that most are not abbreviated into codes of three or four letters—they are spelled out in full. So where POP3 has a STAT command, the command in IMAP is called STATUS. Commands are normally shown in uppercase, as I do in this book, but they are case-insensitive.    IMAP also uses an interesting system of *command tagging* to match client commands explicitly with certain server responses. Each time a client sends a command, it prefixes it with a tag that is unique for the particular session. The tags are usually short strings with a monotonically increasing number in them; the examples in the IMAP standards have the first command tagged a0001, the second a0002, and so on. That said, as long as each command is uniquely labeled, it doesn't matter what tagging scheme is used. When the server needs to send a response that is specific to a command, it tags the reply with the appropriate command tag. Not all replies are tagged, however.    The standard doesn't state explicitly why this tagging scheme is needed, but I believe it is probably related to IMAP's multiple command feature. IMAP clients are allowed to send a sequence of commands to the server to be processed, rather than sending commands only one at a time. This can improve performance when certain commands would take a long time to complete. The only restriction is that the commands must be independent enough that the result of executing them all would be the same, regardless of the order in which they were processed. For example, sending a command to read a particular entity in combination with a command to store a value into the same entity is not allowed.    ### Tip    **KEY CONCEPT** IMAP tags its commands with a unique identifier. These tags can then be used in replies by the server to match replies with the commands to which they correspond. This enables multiple commands to be sent to an IMAP server in succession.    ### Command Groups    IMAP commands are organized into groups based on which session states the IMAP session may be in when they are used:    **\"Any State\" Commands** A small number of commands that can be used at any time during an IMAP session.    **Not Authenticated State Commands** Commands that can be used only in the Not Authenticated state. They are usually used for authentication, of course.    **Authenticated State Commands** Commands used to perform various actions on mailboxes. (Note that despite the name, these commands can also be used in the Selected state.)    **Selected State** A set of commands for accessing and manipulating individual messages that can be used only in the Selected state.    The reason for having the distinct Authenticated and Selected states and command groups is that IMAP is designed specifically to enable the manipulation of multiple mailboxes. After the session starts and the client is authenticated, the client is allowed to issue commands that work with entire mailboxes. However, it may not issue commands that manipulate individual messages until it tells the server which mailbox it wants to work with, which puts it in the Selected state. The client can also issue mailbox commands from the Selected state.    ### Note    *In addition to these four state groups, the standard also defines an extension mechanism that allows new commands to be defined. These must begin with the letter X*.    ### \"Any State\" Commands    [Table 78-2](ch78s03.html#imap_any_state_commands \"Table 78-2. IMAP \"Any State\" Commands\") describes the IMAP \"any state\" commands, which can be used whenever needed.    Table 78-2. IMAP \"Any State\" Commands     | Command | Parameters | Description | | --- | --- | --- | | CAPABILITY | None | Asks the server to tell the client what capabilities and features it supports. | | NOOP (No Operation) | None | Does nothing. May be used to reset the inactivity timer or to prompt the server periodically to send notification if new messages arrive. | | LOGOUT | None | Tells the server that the client is done and ready to end the session, which transitions to the Logout state for termination. |    ### Results and Responses    Each command sent by the IMAP client elicits some sort of reaction from the IMAP server. The server takes action based on what the client requested and then returns one or more text strings to indicate what occurred. The server can send two types of replies after a command is received:    **Result** A reply usually indicating the status or disposition of a command. It may be tagged with the command tag of the command whose result it is communicating, or it may be a general message that is not tagged.    **Response** Any type of information that is being sent by the server to the client. It is usually not tagged with a command tag and is not specifically intended to indicate server status.    ### Note    *The IMAP standards sometimes use the terms result, response, and reply in a manner that I find to be inconsistent. Watch out for this if you examine the IMAP RFCs*.    ### Tip    **KEY CONCEPT** IMAP servers issue two basic types of replies to client commands: *results* are replies that indicate the success, failure, or status of a command; *responses* are general replies containing many different types of information that the server needs to send to the client.    ### Result Codes    Three main result codes are sent in reply to a command, and two special ones are used in certain circumstances:    **OK** A positive result to a command, usually sent with the tag of the command that was successful. May be sent untagged in the server's initial greeting when a session starts.    **NO** A negative result to a command. When tagged, indicates the command failed; when untagged, serves as a general warning message about some situation on the server.    **BAD** Indicates an error message. It is tagged when the error is directly related to a command that has been sent and otherwise is untagged.    **PREAUTH** An untagged message sent at the start of a session to indicate that no authentication is required; the session goes directly to the Authenticated state.    **BYE** Sent when the server is about to close the connection. It is always untagged and is sent in reply to a Logout command or when the connection is to be closed for any other reason.    ### Response Codes    In contrast to results, responses are used to communicate a wide variety of information to the client device. Responses normally include descriptive text that provides details about what is being communicated. They may be sent either directly in reply to a command or incidentally to one. An example of the latter case would be if a new message arrives in a mailbox during a session. In this case, the server will convey this information unilaterally at its first opportunity, regardless of what command was recently sent.    The following are the response codes defined by the IMAP standard:    **ALERT** An alert message to be sent to the human user of the IMAP client to inform him of something important.    **BADCHARSET** Sent when a search fails due to use of an unsupported character set.    **CAPABILITY** A list of server capabilities may be sent as part of the initial server greeting so the CAPABILITY command does not need to be used.    **PARSE** Sent when an error occurs parsing the headers or MIME content of an email message.    **PERMANENTFLAGS** Communicates a list of message status flags that the client is allowed to manipulate.    **READ-ONLY** Tells the client that the mailbox is accessible only in a read-only mode.    **READ-WRITE** Tells the client that the mailbox is accessible in read-write mode.    **TRYCREATE** Sent when an APPEND or COPY command fails due to the target mailbox not existing, to suggest to the client that it try creating the mailbox first.    **UIDNEXT** Sent with a decimal number that specifies the next unique identifier value to use in an operation. These identifiers allow each message to be uniquely identified.    **UIDVALIDITY** Sent with a decimal number that specifies the unique identifier validity value, used to confirm unique message identification.    **UNSEEN** Sent with a decimal number that tells the client the message that is flagged as not yet seen (a new message).    ## IMAP Not Authenticated State: User Authentication Process and Commands    An IMAP4 session begins with an IMAP4 client establishing a TCP connection with an IMAP4 server. Under normal circumstances, the IMAP4 server has no idea who the client is, and therefore starts the session in the Not Authenticated state. For security reasons, the client is not allowed to do anything until it is authenticated. Thus, the only purpose of this state is to allow the client to present valid credentials so the session can move on to the Authenticated state.    ### IMAP Authentication Methods    The IMAP4 standard defines three different mechanisms by which a client may authenticate itself. These are implemented using one or more of the three different commands allowed only in the Not Authenticated state, which are shown in [Table 78-3](ch78s03.html#imap_not_authenticated_state_commands \"Table 78-3. IMAP Not Authenticated State Commands\").    Table 78-3. IMAP Not Authenticated State Commands     | Command | Parameters | Description | | --- | --- | --- | | LOGIN | User name and password | Specifies a user name and password to use for authentication. | | AUTHENTICATE | Authentication mechanism name | Tells the server that the client wants to use a particular authentication mechanism and prompts the client and server to exchange authentication information appropriate for that mechanism. | | STARTTLS | None | Tells the IMAP4 server to use the Transport Layer Security (TLS) protocol for authentication, and prompts TLS negotiation to begin. |    In response to a LOGIN or AUTHENTICATE command, the server will send an OK message if the authentication was successful, and then transition to the Authenticated state. It will send a NO response if authentication failed due to incorrect information. The client can then try another method of authenticating or terminate the session with the LOGOUT command.    The three authentication methods are as follows:    **Plain Login** This is the typical user name/password technique, using the LOGIN command by itself. This is similar to the simple scheme used in POP3, except that in IMAP4 one command is used to send both the user name and password. Since the command and parameters are sent in plain text, this is by far the least secure method of authentication and is not recommended by the standard unless some other means is used in conjunction.    **TLS Login** This is a secure login where the Transport Layer Security (TLS) protocol is first enabled with the STARTTLS command, and then the LOGIN command can be used securely. Note that STARTTLS only causes the TLS negotiation to begin and does not itself cause the IMAP client to be authenticated. Either LOGIN or AUTHENTICATE must still be used.    **Negotiated Authentication Method** The AUTHENTICATE command allows the client and server to use any authentication scheme that they both support. The server may indicate which schemes it supports in response to a CAPABILITY command. After specifying the authentication mechanism to be used, the server and client exchange authentication information as required by the mechanism specified. This may require one or more additional lines of data to be sent.    ### Tip    **KEY CONCEPT** IMAP supports three basic types of authentication: a plain user name/password login, authentication using the Transport Layer Security (TLS) protocol, or the negotiation of some other authentication method between the client and server. In some cases, the IMAP server may choose to preauthenticate clients that it is able to identify reliably; in which case, the Not Authenticated state is skipped entirely.    ## IMAP Authenticated State: Mailbox Manipulation/Selection Process and Commands    In the normal progression of an IMAP session, the Authenticated state is the first state in which the IMAP client is able to perform useful work on behalf of its user. This state will normally be reached from the Not Authenticated state after successful authentication using the LOGIN or AUTHENTICATE command. Alternately, a server may preauthenticate a client and begin the session in this state directly.    Once in the Authenticated state, the client is considered authorized to issue commands to the server. However, it may issue only commands that deal with *whole mailboxes*. As mentioned in the general operation overview, IMAP was created to allow access to, and manipulation of, multiple mailboxes. For this reason, the client must specify dynamically which mailbox it wants to use before commands dealing with individual messages may be given. This is done in this state using the SELECT or EXAMINE command, which both cause a transition to the Selected state.    It is also possible that the Authenticated state can be reentered during the course of a session. If the CLOSE command is used from the Selected state to close a particular mailbox, the server will consider that mailbox deselected, and the session will transition back to the Authenticated state until a new selection is made. The same can occur if a new SELECT or EXAMINE command is given from the Selected state but fails.    ### Authenticated State Commands    [Table 78-4](ch78s03.html#imap_authenticated_state_commands \"Table 78-4. IMAP Authenticated State Commands\") provides a brief description of the mailbox-manipulation commands that can be used in the Authenticated state.    Table 78-4. IMAP Authenticated State Commands     | Command | Parameters | Description | | --- | --- | --- | | SELECT | Mailbox name | Selects a particular mailbox so that messages within it can be accessed. If the command is successful, the session transitions to the Selected state. The server will also normally respond with information for the client about the selected mailbox, as described after this table. | | EXAMINE | Mailbox name | The same as the SELECT command, except that the mailbox is opened read-only; no changes are allowed. | | CREATE | Mailbox name | Creates a mailbox with the given name. | | DELETE | Mailbox name | Deletes the specified mailbox. | | RENAME | Current and new mailbox names | Renames a mailbox. | | SUBSCRIBE | Mailbox name | Adds the mailbox to the server's set of active mailboxes. This is sometimes used when IMAP4 is employed for Usenet message access. | | UNSUBSCRIBE | Mailbox name | Removes the mailbox from the active list. | | LIST | Mailbox name or reference string | Requests a partial list of available mailbox names, based on the parameter provided. | | LSUB | Mailbox name or reference string | The same as LIST but returns only names from the active list. | | STATUS | Mailbox name | Requests the status of the specified mailbox. The server responds providing information such as the number of messages in the box and the number of recently arrived and unseen messages. | | APPEND | Mailbox name, message, optional flags, and date/time | Adds a message to a mailbox. |    ### Note    *All of the commands in [Table 78-4](ch78s03.html#imap_authenticated_state_commands \"Table 78-4. IMAP Authenticated State Commands\") may also be used in the Selected state; they should really be called Authenticated+Selected state commands*.    When either the SELECT or EXAMINE command is successfully issued, the server will return to the client a set of useful information about the mailbox, which can be used to guide commands issued from the Selected state. This information includes the following three mandatory responses:    **<*n*> EXISTS** Tells the client the number of messages in the mailbox.    **<*n*> RECENT** Tells the client the number of recently arrived (new) messages.    **FLAGS (<*flag-list*>)** Tells the client which flags are supported in the mailbox. These include the following: `\\Seen`, `\\Answered`, `\\Flagged` (marked for special attention), `\\Deleted`, `\\Draft`, and `\\Recent`. (The backslashes are part of the flag names.)    The reply from the server may also contain these optional replies:    **UNSEEN <*n*>** The message number of the first unseen message.    **PERMANENTFLAGS (<*flag-list*>)** A list of flags (as for the FLAGS response above) that the client is allowed to change.    **UIDNEXT <*n*>** The next unique identifier value. This is used to check for changes made to the mailbox since the client last accessed it.    **UIDVALIDITY <*n*>** The unique identifier validity value, used to confirm valid UID values.    ### Tip    **KEY CONCEPT** In the Authenticated state, the IMAP client can perform operations on whole mailboxes, such as creating, renaming, or deleting mailboxes, or listing mailbox contents. The SELECT and EXAMINE commands are used to tell the IMAP server which mailbox the client wants to open for message-specific access. Successful execution of either command causes the server to provide the client with several pieces of important information about the mailbox, after which the session transitions to the Selected state.    ## IMAP Selected State: Message Manipulation Process and Commands    Once the IMAP client has been authorized to access the server, it enters the Authenticated state, where it is allowed to execute tasks on whole mailboxes. Since IMAP allows multiple mailboxes to be manipulated, message-specific commands cannot be used until the client tells the server which mailbox in wants to work with. Only one mailbox can be accessed at a time in a given session.    After the SELECT or EXAMINE command is successfully issued, the session enters the Selected state. In this state, the full palette of message and mailbox commands is available to the client. This includes the message-specific commands in [Table 78-5](ch78s03.html#imap_selected_state_commands \"Table 78-5. IMAP Selected State Commands\") as the mailbox commands defined for the Authenticated state. Most of IMAP's message-specific commands do not include a mailbox name as a parameters, since the server knows automatically that the commands apply to whatever mailbox was selected in the Authenticated state.    The session remains in the Selected state for as long as the client continues to have work to do with the particular selected (or examined) mailbox. Three different actions can cause a transition out of the Selected state:    *   If the client has nothing more to do when it is done with the current mailbox, it can use the LOGOUT command to end the session.           *   The client can use the CLOSE command to tell the server it is finished with the current mailbox but keep the session active. The server will close the mailbox, and the session will go back to the Authenticated state.           *   The client can issue a new SELECT or EXAMINE command, which will implicitly close the current mailbox and then open the new one. The transition in this case is from the Selected state back to the Selected state, but with a new current mailbox.              ### Selected State Commands    [Table 78-5](ch78s03.html#imap_selected_state_commands \"Table 78-5. IMAP Selected State Commands\") lists the message-specific commands that can be used only in the Selected state.    Table 78-5. IMAP Selected State Commands     | Command | Parameters | Description | | --- | --- | --- | | CHECK | None | Sets a checkpoint for the current mailbox. This is used to mark when a certain sequence of operations has been completed. | | CLOSE | None | Explicitly closes the current mailbox and returns the session to the Authenticated state. When this command is issued, the server will also implicitly perform an EXPUNGE operation on the mailbox. | | EXPUNGE | None | Permanently removes any messages that were flagged for deletion by the client. This is done automatically when a mailbox is closed. | | SEARCH | Search criteria and an optional character set specification | Searches the current mailbox for messages matching the specified search criteria. The server response lists the message numbers meeting the criteria. | | FETCH | Sequence of message numbers and a list of message data items (or a macro) | Retrieves information about a message or set of messages from the current mailbox. | | STORE | Sequence of message numbers, message data item name, and value | Stores a value for a particular message data item for a set of messages. | | COPY | Sequence of message numbers and a mailbox name | Copies the set of messages specified to the end of the specified mailbox. | | UID | Command name and arguments | Used to allow one of the other commands above to be performed using unique identifier numbers for specifying the messages to be operated on, rather than the usual message sequence numbers. |    The list in [Table 78-5](ch78s03.html#imap_selected_state_commands \"Table 78-5. IMAP Selected State Commands\") might seem surprisingly short. You might wonder, for example, where the specific commands are to read a message header or body, delete a message, mark a message as read, and so forth. The answer is that these (and much more) are all implemented as part of the powerful and flexible FETCH and STORE commands.    The FETCH command can be used to read a number of specific elements from either one message or a sequence of messages. The list of message data items specifies what information is to be read. The data items that can be read include the headers of the message, the message body, flags that are set for the message, the date of the message, and much more. The FETCH command can even be used to retrieve part of a message, such as one body part of a MIME multipart message, making it very useful indeed. Special macros are also defined for convenience. For example, the client can specify the message data item FULL to get all the data associated with a message.    The complement to FETCH, the STORE command, is used to make changes to a message. However, this command does not modify the basic message information such as the content of headers and the message body. Rather, it exists for changing the message's status flags. For example, after replying to a particular message, the client may set the `\\Answered` flag for that message using the STORE command.    Message deletion in IMAP is done in two stages for safety, as in POP and many other protocols. The client sets the `\\Deleted` flag for whichever messages are to be removed, using the STORE command. The messages are deleted only when the mailbox is expunged, typically when it is closed.    The search facility in IMAP4 is also surprisingly quite sophisticated, allowing the client to look for messages based on multiple criteria simultaneously. For example, with the appropriate syntax, you could search for \"all posts that are flagged as having been answered that were sent by Jane Jones before April 1, 2004.\" Users of IMAP clients can thus easily locate specific messages even in very large mailboxes without needing to download and hunt through hundreds of messages.    ### Tip    **KEY CONCEPT** After the client opens a specific mailbox, the IMAP session enters the Selected state, where operations such as reading and copying individual email messages may be performed. The two most important commands used in this state are FETCH, which can be used to retrieve a whole message, part of a message, or only certain message headers or flags; and STORE, which sets a message's status information. IMAP also includes a powerful search facility, providing users with great flexibility in finding messages in a mailbox. When the client is finished working with a particular mailbox, it may choose a different one and reenter the Selected state, close the mailbox and return to the Authenticated state, or log out, automatically entering the Logout state.    # TCP/IP Direct Server Email Access    This final portion of the journey of a TCP/IP email message is usually the job of an email access and retrieval protocol like POP3 or IMAP4\\. These are *customized* protocols, by which I mean that they were created specifically for the last step of the email communication process. However, there are also several *generic* methods by which an email client can gain access to a mailbox, without the use of a special protocol.    These methods are all variations of the online email access model. They generally work by establishing *direct access* to the server where the mailbox is located. The mailbox itself is just a file on a server somewhere, so if that file can be made available, it can be viewed and manipulated like any other file using an email client program that reads and writes the mailbox file. The following are some of the ways in which this can be done:    **Using the SMTP Server Directly** The simplest method for gaining access to the mailbox is to log on to the server itself. This is not an option for most people, and even in years gone by, it was not often done, for security and other reasons. However, some people do run their own SMTP servers, giving them considerable control over access to their email.    **File Sharing Access** Using a protocol such as NFS, it is possible to have a mailbox mounted on a user's client machine where it can be accessed as if it were a local file. The mail is still on the server and not the client machine, but the communication between the client and the server occurs transparently to both the user and the email client software.    **Dial-Up Remote Server Access** A user on a client machine dials up a server where her mailbox is located and logs in to it. The user then can issue commands to access mail on that server as if she were logged in to it directly.    **Telnet Remote Server Access** Instead of dialing in to the server, a user can connect to it for remote access using the Telnet Protocol.    These techniques are much more commonly associated with timesharing systems, which commonly use the UNIX family of operating systems more than others. They are also often combined; for example, remote access is often provided for UNIX users, but most companies don't want users logging in directly to the SMTP server. Instead, an ISP might run an SMTP server on one machine called *mail.companyname.com* and also operate a different server that is designed for client access called *users.companyname.com*. A user could access email by dialing into the users machine, which would employ NFS to access user mailboxes on the mail machine.    Direct server access is a method that has been around for decades. At one time, this was how the majority of people accessed email, for two main reasons. First, if you go back far enough, protocols like POP or IMAP had not yet been developed; the TCP/IP email system as a whole predates them by many years, and direct access was the only option back then. Second, the general way that email and networks were used years ago was different from what it is today. Most individuals did not have PCs at home, and no Internet as we know it existed. Remotely accessing a UNIX server using a modem or Telnet for email and other services was just the way it was done.    I got started using direct server access for email more than ten years ago, and I still use it today. I Telnet in to a client machine and use a UNIX email program called `elm` to access and manipulate my mailbox. To me, this provides numerous advantages:    *   Most important, I can access my email using Telnet from any machine on the Internet, anywhere around the world.           *   Since I am logged in directly, I get immediate notification when new mail arrives, without needing to check routinely for new mail.           *   My mailbox is always accessible, and all my mail is always on a secure server in a professionally managed data center.           *   I have complete control over my mailbox and can edit it, split it into folders, write custom spam filters, or do anything else I need to do.              This probably sounds good, but most people today do not use direct server access because of the disadvantages of this method. One big issue is that you must be logged in to the Internet to access your email. Another one, perhaps even larger, is the need to be familiar with UNIX and a UNIX email program. UNIX is simply not as user-friendly as a graphical operating systems such as Windows or the Mac. For example, my UNIX email program doesn't support color and cannot show me attached graphic images. I must extract images and other files from MIME messages and transfer them to my own PC for viewing.    Most ordinary computer users today don't know UNIX and don't want to know it. They are much happier using a fancy graphical email program based on POP3 or IMAP4\\. However, a number of us old UNIX dinosaurs are still around and believe the benefits of direct access outweigh the drawbacks. (Oh, one other benefit that I forgot to mention is that it's very hard to get a computer virus in email when you use UNIX!)    ### Tip    **KEY CONCEPT** Instead of using a dedicated protocol like POP3 or IMAP4 to retrieve mail, on some systems it is possible for a user to have direct server access to email. This is most commonly done on UNIX systems, where protocols like Telnet or NFS can give a user shared access to mailboxes on a server. This is the oldest method of email access. It provides the user with the most control over his mailbox and is well suited to those who must access mail from many locations. The main drawback is that it means the user must be on the Internet to read email, and it also usually requires familiarity with the UNIX operating system, which few people use today.    # TCP/IP World Wide Web Email Access    Most email users like the advantages of online access, especially the ability to read mail from a variety of different machines. What they don't care for is direct server access using protocols like Telnet, UNIX, and nonintuitive, character-based email programs. They want online access, but they want it to be simple and easy to use.    In the 1990s, the World Wide Web was developed and grew in popularity very rapidly, due in large part to its ease of use. Millions of people became accustomed to firing up a web browser to perform a variety of tasks, to the point at which using the Web has become almost second nature. It didn't take very long before someone figured out that using the Web would be a natural way of providing easy access to email on a server.    This technique is straightforward. It exploits the flexibility of the Hypertext Transfer Protocol (HTTP) to tunnel email from a mailbox server to the client. A web browser (client) is opened and given a URL for a special web server document that accesses the user's mailbox. The web server reads information from the mailbox and sends it to the web browser, where it is displayed to the user.    This method uses the online access model like direct server access, because requests must be sent to the web server, and this requires the user to be online. The mail also remains on the server, as when NFS or Telnet are used. The big difference between Web-based mail and the UNIX methods is that the former is much easier for nonexperts to use.    Since the idea was first developed, many companies have jumped on the Web-mail bandwagon, and the number of people using this technique has exploded into the millions in just a few years. Many free services even popped up in the late 1990s as part of the dot-com bubble, allowing any Internet user to send and receive email using the Web at no charge (except perhaps for tolerating advertising). Many ISPs now offer Web access as an option in additional to conventional POP/IMAP access, which is useful for those who travel.    There are drawbacks to the technique, however, which as you might imagine are directly related to its advantages. Web-based mail is easy to use, but inflexible; the user does not have direct access to her mailbox and can use only whatever features the provider's website implements. For example, suppose the user wants to search for a particular string in her mailbox; this requires that the Web interface provide this function. If it doesn't, the user is out of luck.    Web-based mail also has a disadvantage that is an issue for some people: performance. Using conventional UNIX direct access, it is quick and easy to read through a mailbox; the same is true of access using POP3, once the mail is downloaded. In contrast, Web-based mail services mean each request requires another HTTP request/response cycle. The fact that many Web-based services are free often means server overload that exacerbates the speed issue.    Note that when Web-based mail is combined with other methods such as POP3, care must be taken to avoid strange results. If the Web interface doesn't provide all the features of the conventional email client, certain changes made by the client may not show up when Web-based access is used. Also, mail retrieval using POP3 by default removes the mail from the server. If you use POP3 to read your mailbox and then later try to use the Web to access those messages from elsewhere, you will find that the mail is gone—it's on the client machine where you used the POP3 client. Many email client programs now allow you to specify that you want the mail left on the server after retrieving it using POP3.    ### Tip    **KEY CONCEPT** In the past few years, a new method has been developed to allow email access using the World Wide Web. This technique is rapidly growing in popularity, because it provides many of the benefits of direct server access, such as the ability to receive email anywhere around the world, while being much simpler and easier than the older methods of direct access such as making a Telnet connection to a server. In some cases, Web-based email can be used in combination with other methods or protocols, such as POP3, giving users great flexibility in how they read their mail.````"]