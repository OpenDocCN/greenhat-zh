<html><head></head><body><div class="part" title="Part&#xA0;III-1.&#xA0;NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION"><div class="titlepage"><div><div><h1 class="title"><a id="name_systems_and_tcpip_name_registration"/>Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION</h1></div></div></div><div class="partintro" id="id3294584" title="NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION"><div/><p>TCP/IP APPLICATION LAYER PROTOCOLS</p><p>The OSI Reference Model is used to describe the architecture of networking protocols and technologies and to show how they relate to one another. In the chapter describing OSI Reference Model concepts (<a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>), I mentioned that its seven layers could be organized into two layer groupings: the lower layers (1 through 4) and the upper layers (5 through 7). While there are certainly other ways to divide the layers, this split best reflects the different roles that the layers play in a network.</p><p>The lower layers are concerned primarily with the mechanics of formatting, encoding, and sending data over a network. These layers involve software elements, but they are often closely associated with networking hardware devices. In contrast, the upper layers are concerned mainly with user interaction and the implementation of software applications, protocols, and services that let us actually use the network. These elements generally don't need to worry about details, relying on the lower layers to ensure that data gets to where it needs to go reliably.</p><p>In this section, I describe the details of the many protocols and applications that occupy the upper layers in TCP/IP. The organization of this section is quite different from the previous section's organization. Since the TCP/IP protocol suite uses an architecture that lumps all the higher layers together, even attempting to differentiate between these layers is not worthwhile. For these reasons, this section is divided by functions, rather than by layers. It contains ten parts: four that discuss application layer protocols that support the operation of TCP/IP, and six that discuss actual application protocols.</p><p>The first part discusses naming systems, especially the TCP/IP Domain Name System (DNS). The second part overviews file and resource sharing protocols, with a focus on the Network File System (NFS). The third part covers TCP/IP host configuration and the host configuration protocols: the Boot Protocol (BOOTP) and the Dynamic Host Configuration Protocol (DHCP). The fourth part describes the TCP/IP network management framework, including the Simple Network Management Protocol (SNMP) and Remote Network Monitoring (RMON).</p><p>The fifth part introduces TCP/IP applications with a look at application layer addressing and an overview of file and message transfer applications. The sixth part covers the general file transfer protocols: the File Transfer Protocol (FTP) and the Trivial File Transfer Protocol (TFTP). The seventh part explains the many related protocols that together form TCP/IP's electronic mail application. The eighth part covers the Web and the important Hypertext Transfer Protocol (HTTP). The ninth part describes Usenet (network news) and Gopher. Finally, the tenth part discusses interactive and administrative protocols.</p><p><a class="xref" href="ch50.html" title="Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES">Chapter 50</a></p><p><a class="xref" href="ch51.html" title="Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM">Chapter 51</a></p><p><a class="xref" href="ch52.html" title="Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS">Chapter 52</a></p><p><a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a></p><p><a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a></p><p><a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a></p><p><a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a></p><p><a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a></p><p>Humans and computers first started dealing with each other several decades ago. The relationship between man (and woman!) and machine has been a pretty good one overall, and this is reflected in the fact that while computers were once just the province of techies, they are now <span class="emphasis"><em>mainstream</em></span>. However, there are areas where humans and computers simply don't see eye to eye. One of these is in the way that we deal with information.</p><p>Computers work best with numbers, while most people prefer not to work with numbers. This fundamental difference represented a problem for the designers of networking technology. It made sense from a technical standpoint to design addressing schemes for networks and internetworks using simple numeric identifiers, for simplicity and efficiency. Unfortunately, identifying computers using numeric addresses is cumbersome for people and becomes more so as the number of devices on a network increases. To solve this problem, the techies went to work and came up with <span class="emphasis"><em>name systems</em></span> for networks. These mechanisms allow computers to continue to use simple, efficient numeric addresses, while letting humans specify names to identify network devices.</p><p>This part includes eight chapters that explain both the theory and practice behind networking name systems. The first chapter describes the motivation for name systems and the important concepts and techniques behind how they work. The second chapter provides an introduction to name systems on TCP/IP and a brief description of the simple host table name system.</p><p>The remaining chapters describe the very important Domain Name System (DNS). The third chapter provides an overview of DNS, including a description of its characteristics and components. The fourth chapter discusses the DNS name space and architecture, and the fifth chapter covers the DNS name registration process, including hierarchical authorities and administration. The sixth chapter describes DNS name servers and how they represent, manage, and provide data when resolution is invoked. The seventh chapter describes DNS clients, called <span class="emphasis"><em>resolvers</em></span>, how they initiate resolution, and the steps involved in the resolution process. Finally, the eighth chapter ties together the information about name servers and resolvers by providing a look at message exchange between these units, and describing the formats of messages, resource records, and DNS master files. This chapter includes a brief look at the changes made to DNS to support the new version 6 of the Internet Protocol (IPv6) and its much longer addresses.</p><p>Note that even though the abbreviation <span class="emphasis"><em>DNS</em></span> usually stands for <span class="emphasis"><em>Domain Name System</em></span>, you will also sometimes see the <span class="emphasis"><em>S</em></span> stand for other words, especially <span class="emphasis"><em>Service</em></span> or <span class="emphasis"><em>Server</em></span>. Also, some documents refer to this name system as <span class="emphasis"><em>the DNS</em></span>. Most people just say <span class="emphasis"><em>DNS</em></span>, without the definite article, and that's the convention I follow here as well.</p><p>A set of related TCP/IP utilities called <span class="emphasis"><em>nslookup, host</em></span>, and <span class="emphasis"><em>dig</em></span> can be used by an administrator to query DNS name servers for information. They are useful for a variety of purposes, including manually determining the IP address of a host, checking for specific resource records maintained for a DNS name, and verifying the name resolution function. You can find more information about these utilities in <a class="xref" href="pt21.html" title="Part III-10. INTERACTIVE AND ADMINISTRATIVE UTILITIES AND PROTOCOLS">Part III-10</a>.</p></div></div>
<div class="chapter" title="Chapter&#xA0;50.&#xA0;NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES"><div class="titlepage"><div><div><h1 class="title"><a id="name_system_issues_concepts_and_techniqu"/>Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e54100"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Name systems can be considered as the diplomats of the networking protocol stack. Just as a political diplomat is skilled at speaking multiple languages and ensuring good communications between those who may view the world in different ways, name systems bridge the gulf between the numeric addresses that computers like to use and the simpler names that humans prefer.</p><p>Before looking at specific name systems, it makes sense to discuss them generally. This will help you to understand the reasons why these systems are important and the concepts that underlie all name systems, regardless of their specific implementation.</p><p>I begin this chapter with an overview of name systems and a discussion of why they were created. I then discuss the three main functions of a name system: the name space, name registration, and name resolution. I then expand on this functional overview, illustrating how name spaces and architectures work, the issues behind name registration and administration, and finally, name resolution techniques and the practical issues in the resolution process.</p><p>This chapter provides an introduction to name <a class="indexterm" id="idx-CHP-50-1788"/>systems and doesn't discuss specific name systems. I like to use examples to explain concepts and, for this purpose, do make reference to the TCP/IP Domain Name System (DNS) at times. However, you do not need to be familiar with DNS to follow this chapter.</p><div class="sect1" title="Name System Overview"><div class="titlepage"><div><div><h1 class="title"><a id="name_system_overview"/>Name System Overview</h1></div></div></div><p>One of several important differences between humans and computers is how we prefer to deal with information. Computers work with numbers, while very few humans like to do so. This distinction becomes particularly important when we look at how identifiers, or addresses, are assigned to network devices.</p><div class="sect2" title="Symbolic Names for Addressing"><div class="titlepage"><div><div><h2 class="title"><a id="symbolic_names_for_addressing"/>Symbolic Names for Addressing</h2></div></div></div><p>To a computer, there is no problem with simply giving a number to each device on the network and using those numbers to move information around. Your computer would be perfectly happy if you assigned a number like 341,481,178,295 to it and all the other machines on your network, and then issued commands such as, "Send this file to machine 56,712,489,901." However, most humans don't want to use a network in this manner. These long, cryptic numbers don't mean anything to them. They want to tell their machine, "Send this file to Joe's computer," or "Print this on the color laser in the Sales department," or "Check the latest headlines on CNN's website."<a class="indexterm" id="idx-CHP-50-1789"/></p><p>This difference led to the development of <span class="emphasis"><em>name systems</em></span>. These technologies allow computers on a network to be given both a conventional numeric address and a more user-friendly, human-readable name, composed of letters, numbers, and other special symbols. Sometimes called a <span class="emphasis"><em>symbolic name</em></span>, this can be used as an alternative form of addressing for devices. The name system takes care of the functions necessary to manage this system, including ensuring that names are unique, translating from names to numbers, and managing the list of names and numbers.</p></div><div class="sect2" title="A Paradox: Name Systems Are Both Essential and Unnecessary"><div class="titlepage"><div><div><h2 class="title"><a id="a_paradox_name_systems_are_both_essentia"/>A Paradox: Name Systems Are Both Essential and Unnecessary</h2></div></div></div><p>What's interesting about name systems is that they are extremely important to networks, but at the same time, they often aren't strictly necessary for a network to operate. This seeming paradox is due again to the difference between humans and computers. Computers need only the numeric addressing scheme, not the names assigned to them. So, without name systems, the computers and the network can still work, but it will be much harder for people to use them!</p><p>An example of this can most readily be seen when a problem disables the operation of a part of DNS used to provide naming services on the Internet. Technically, DNS isn't needed to use most parts of the Internet, because all communications use IP addresses. This means that even though you might normally access CNN's website at <a class="ulink" href="http://www.cnn.com">www.cnn.com</a>, you could instead just use the IP address 64.236.16.20.</p><p>The problem is that prior to reading this, you probably had no idea what the IP address of CNN's website is, and that's true of almost everyone else who uses the site as well. Also, you might want to check not just CNN's website, but perhaps 1, 2, or 20 other news sites. It would be difficult to remember the numbers for even a small percentage of the thousands of different websites on the Internet, so each time you wanted to access a resource, you would need to manually look up its address, as shown in <a class="xref" href="ch50.html#internetwork_access_without_a_name_syste" title="Figure 50-1. Internetwork access without a name system When there is no name system, a user must know the address of any device he or she wishes to access on the internetwork. Since most of us have limited memories for numbers, this means each access must be preceded by an inefficient, tedious, manual address lookup.">Figure 50-1</a>.</p><div class="figure"><a id="internetwork_access_without_a_name_syste"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e54156"/><img alt="Internetwork access without a name system When there is no name system, a user must know the address of any device he or she wishes to access on the internetwork. Since most of us have limited memories for numbers, this means each access must be preceded by an inefficient, tedious, manual address lookup." src="httpatomoreillycomsourcenostarchimages288143.png.jpg"/></div></div><p class="title">Figure 50-1. Internetwork access without a name system When there is no name system, a user must know the address of any device he or she wishes to access on the internetwork. Since most of us have limited memories for numbers, this means each access must be preceded by an inefficient, tedious, manual address lookup.</p></div><p>In contrast, it's much easier to remember the names of resources. With a name system, you just enter the name of a device, and the name system converts it to an address, as shown in <a class="xref" href="ch50.html#internetwork_access_with_a_name_system" title="Figure 50-2. Internetwork access with a name system">Figure 50-2</a>. This is why name systems are so important, even if they aren't needed by the networking technologies themselves. In fact, the reliance on name systems like DNS is so significant that many people don't even realize they can enter IP addresses into their web browsers!</p><div class="figure"><a id="internetwork_access_with_a_name_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e54168"/><img alt="Internetwork access with a name system" src="httpatomoreillycomsourcenostarchimages288145.png.jpg"/></div></div><p class="title">Figure 50-2. Internetwork access with a name system</p></div><p>When an internetwork is equipped with a name system, the user no longer needs to know the address of a device to access it. He or she enters the name, and the name system converts it into an address automatically, like a computerized Rolodex, as shown here. The name system then passes the address to the client software, which uses that address to access the requested resource as if the user had entered it directly.</p></div><div class="sect2" title="Factors That Determine the Necessity of a Name System"><div class="titlepage"><div><div><h2 class="title"><a id="factors_that_determine_the_necessity_of_"/>Factors That Determine the Necessity of a Name System</h2></div></div></div><p>More generally, the importance of a name system depends greatly on the characteristics of the network where it is used. The following are the three main issues in determining the need for a name system:</p><p><span class="strong"><strong>Network Size</strong></span> With a really small network and only a handful of computers, having human users remember the numeric addresses for these machines is at least feasible, if not ideal. For example, a small home network with two or three machines doesn't really <span class="emphasis"><em>need</em></span> a name system, in theory. If you have thousands or millions of devices, however, the name system becomes essential.</p><p><span class="strong"><strong>Address Size and Complexity</strong></span> The more complex the numeric addressing scheme, or the larger the numbers used, the more difficult it is for humans to remember the numbers. This makes having a name system all the more essential for the users of those addresses.</p><p><span class="strong"><strong>User Base Size and Skill</strong></span> In the early days of networks, a small number of highly skilled and well-trained engineers used them, and these people sometimes just memorized the numbers of the machines they worked with every day. In modern networks with thousands or millions of regular users, expecting the average person to remember device numbers is not reasonable.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-300"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Networking name systems are important because they allow devices to be assigned efficient numeric addresses, while still enabling humans to access them using names that are easier to remember. Name systems become more important as you increase the size of the network, the address, or the user base. They are also more essential when the user base is limited in skill or experience.</p></div><p>Looking at these issues, we can see that the trends in today's networks are all in the direction of increasing the importance of name systems. Our networks, both private and public, are growing larger, and we have more people using them, including more people without a technical background. We are also increasingly moving from small addresses to larger ones. The best example of this is the upcoming change to IP. While DNS is important for the 32-bit addresses used in IPv4, it's even <span class="emphasis"><em>more</em></span> important for dealing with the enormous 128-bit addresses of IPv6 (see <a class="xref" href="pt07.html" title="Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)">Part II-4</a>).</p></div><div class="sect2" title="Basic Name System Functions: Name Space, Name Registration, and Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="basic_name_system_functions_name_space_n"/>Basic Name System Functions: Name Space, Name Registration, and Name Resolution</h2></div></div></div><p>While the difference between numeric addresses and symbolic names is very significant to the users of network devices, it's important to remember that both numbers and names really serve the same basic purpose: <span class="emphasis"><em>device identification</em></span>. Even when we use a name system to make devices easier to access, the computers themselves will still normally need to use the underlying numeric identifier. In essence, every device will end up with (at least) two identifiers: a number <span class="emphasis"><em>and</em></span> a name.</p><p>The fact that devices end up with multiple identifiers is what allows both people and their machines to use the method of identification they prefer. However, it means that there must be ways of managing the assignment of names to devices and converting between them. A name system involves more than just slapping names on computers. It must be a complete <span class="emphasis"><em>system</em></span> that allows names to be used by the humans while numbers continue to be used by the devices.</p><p>At the highest level, a name system must handle three basic functions:</p><p><span class="strong"><strong>Name Space Definition</strong></span> The name system defines a <span class="emphasis"><em>name space</em></span> for the networking system on which it runs. The name space, also sometimes called a <span class="emphasis"><em>name architecture</em></span>, describes the rules for how names are structured and used. It also defines how the name of one device is related to the names of other devices in the system and how to ensure that there are no invalid names that would cause problems with the system as a whole.</p><p><span class="strong"><strong>Name Registration</strong></span> To implement the name system, a name must be assigned to each device on the network. Like any addressing system, a name system cannot work properly unless every name on the system is unique. We need some way of managing how the names are assigned so the result is sensible. The process of linking specific names to particular devices is usually called <span class="emphasis"><em>name registration</em></span>.</p><p><span class="strong"><strong>Name Resolution</strong></span> Even though humans like symbolic names, computers usually have little use for them. It is necessary to define a mechanism by which a device's symbolic name can be translated into its numeric address. This process is usually called <span class="emphasis"><em>name resolution</em></span>.</p><p>The name space is more of a descriptive function, which defines how names work in the system. Name registration and resolution are more active functions, with each name system including one or more specific procedures for how these jobs are carried out. Name registration and resolution are in some ways complements of each other, so certain registration techniques are most often associated with particular resolution methods. In turn, the types of registration and resolution methods that are possible depend on the name space, and in particular, its architecture. These relationships are shown in simplified form in <a class="xref" href="ch50.html#name_system_functions" title="Figure 50-3. Name system functions">Figure 50-3</a>.</p><div class="figure"><a id="name_system_functions"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e54256"/><img alt="Name system functions" src="httpatomoreillycomsourcenostarchimages288147.png.jpg"/></div></div><p class="title">Figure 50-3. Name system functions</p></div><p>This diagram shows the relationships between the three main functions of a name system. The <span class="emphasis"><em>name space</em></span> defines the structure of the name system and the rules for creating names. The name space is used as the basis for the <span class="emphasis"><em>name registration</em></span> method, which defines the mappings between names and addresses. When a user wants to access a device by name, a <span class="emphasis"><em>name resolution</em></span> method is used to consult the <a class="indexterm" id="idx-CHP-50-1790"/>name space, determine what address is associated with a name, and then convert the name to an address. The processes of registration and resolution can be either quite plain or fairly complicated, depending on the type of name system used. Simple name systems are largely manual in operation, easy to understand, and best used in smaller networks. Larger, more complex networks and internetworks require more sophisticated methods of registration and resolution, which involve less administrator intervention and <span class="emphasis"><em>scale</em></span> better as new machines are added to the network.</p><p>Although name registration and name resolution work as functions at the highest level, they are probably better thought of as <span class="emphasis"><em>sets</em></span> of functions. Name registration is necessarily tied to issues such as name system administration and management, and understanding resolution requires that we look at a number of important implementation issues in the areas of efficiency and reliability. The rest of this chapter expands on this overview by considering each of these three functions in more detail.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-301"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A name system consists of three theoretical high-level functions: the <span class="emphasis"><em>name space</em></span>, which describes how names are created and organized; the <span class="emphasis"><em>name registration</em></span> technique, which is used to set up relationships between names and addresses; and the <span class="emphasis"><em>name resolution</em></span> method, which is responsible for translating names to addresses.</p></div></div></div></div>
<div class="sect1" title="Name Spaces and Name Architectures"><div class="titlepage"><div><div><h1 class="title"><a id="name_spaces_and_name_architectures"/>Name Spaces and Name Architectures</h1></div></div></div><p>The main idea of a name system is to provide a way to identify devices using symbolic names. Like any identification mechanism, before it can be used, we must define the way that identification will be performed. Numeric addressing schemes (like IP addresses) have rules for how addresses are created and assign addresses to each device from their <span class="emphasis"><em>address space</em></span>. In a similar way, devices in a name system are given names from the system's <span class="emphasis"><em>name space</em></span>.<a class="indexterm" id="idx-CHP-50-1791"/><a class="indexterm" id="idx-CHP-50-1792"/></p><div class="sect2" title="Name Space Functions"><div class="titlepage"><div><div><h2 class="title"><a id="name_space_functions"/>Name Space Functions</h2></div></div></div><p>Of the three main components of a name system, the name space is the most abstract. It is also the most fundamental part of the system, since it actually describes how the names are created. There are several aspects to what the name space defines in a name system:</p><p><span class="strong"><strong>Name Size and Maximum Number of Names</strong></span> The name space specifies the number of characters (symbols) that compose names. It also defines the maximum number of names that can appear in the system.</p><p><span class="strong"><strong>Name Rules and Syntax</strong></span> The name space specifies which characters and symbols are allowed in a name. This is used to allow legal names to be chosen for all devices, while avoiding illegal names.</p><p><span class="strong"><strong>Name Architecture and Semantics</strong></span> Each name space uses a specific <span class="emphasis"><em>architecture</em></span> or <span class="emphasis"><em>structure</em></span>, which describes how names are constructed and interpreted.</p><p>The concepts of name size and name syntax are relatively straightforward. The <span class="emphasis"><em>name architecture</em></span> is probably the most important differentiating characteristic of name systems. For this reason, name <a class="indexterm" id="idx-CHP-50-1793"/>spaces are sometimes even <span class="emphasis"><em>called</em></span> name <a class="indexterm" id="idx-CHP-50-1794"/>architectures. The <a class="indexterm" id="idx-CHP-50-1795"/>architecture of the name <a class="indexterm" id="idx-CHP-50-1796"/>space determines whether names are assigned and used as a simple unstructured set of symbols or have a more complex internal structure. In the latter case, the name space also must define how elements of a particular name are related to each other.<a class="indexterm" id="idx-CHP-50-1797"/></p><p>Theoretically, many different name architectures are possible. In practice, most fall into one of two categories: <a class="indexterm" id="idx-CHP-50-1798"/>flat and hierarchical.</p></div><div class="sect2" title="Flat Name Architecture (Flat Name Space)"><div class="titlepage"><div><div><h2 class="title"><a id="flat_name_architecture_flat_name_space"/>Flat Name Architecture (Flat Name Space)</h2></div></div></div><p>In a <span class="emphasis"><em>flat name architecture</em></span>, names are assigned as a sequence of symbols that are interpreted as a single, whole label without any internal structure. There is no clear relationship between any name and any other name.</p><p>An example of this sort of architecture would be a name system where computers are given unstructured names like Engineering Workstation 1 or Joanne's PC, as shown in the example in <a class="xref" href="ch50s02.html#flat_name_architecture_flat_name_s-id001" title="Figure 50-4. Flat name architecture (flat name space) This diagram shows an example of a flat name architecture. There is no structure that organizes the names or dictates how they must be constructed. Logically, each device is a peer of each of the others.">Figure 50-4</a>.</p><div class="figure"><a id="flat_name_architecture_flat_name_s-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e54410"/><img alt="Flat name architecture (flat name space) This diagram shows an example of a flat name architecture. There is no structure that organizes the names or dictates how they must be constructed. Logically, each device is a peer of each of the others." src="httpatomoreillycomsourcenostarchimages288149.png.jpg"/></div></div><p class="title">Figure 50-4. Flat name architecture (flat name space) This diagram shows an example of a flat name architecture. There is no structure that organizes the names or dictates how they must be constructed. Logically, each device is a peer of each of the others.</p></div></div><div class="sect2" title="Hierarchical Name Architecture (Structured Name Space)"><div class="titlepage"><div><div><h2 class="title"><a id="hierarchical_name_architecture_structure"/>Hierarchical Name Architecture (Structured Name Space)</h2></div></div></div><p>In a <span class="emphasis"><em>hierarchical name architecture</em></span>, or structured name space, the names are a sequence of symbols, but these symbols are assigned using a specific and clear structure. Each name consists of discrete elements that are related to each other, usually by using hierarchical parent/child semantics. There are many naming architectures in various contexts that use this type of hierarchical structure. For example, consider how a large company might set up an organization chart and name the executives and officers in the organization. One hypothetical example of a hierarchical name architecture is illustrated in <a class="xref" href="ch50s02.html#hierarchical_name_architecture_str-id001" title="Figure 50-5. Hierarchical name architecture (structured name space)">Figure 50-5</a>.<a class="indexterm" id="idx-CHP-50-1799"/></p><p>The best-known real-world example of a hierarchical name space is the name space of DNS (see <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>), which uses text labels separated by periods (or <span class="emphasis"><em>dots</em></span>) to form an internal structure. All the names in the system are organized into a structure, and a particular device's place in the structure can be determined by looking at its name. For example, <a class="ulink" href="http://www.tcpipguide.com">www.tcpipguide.com</a> refers to the World Wide Web server for <span class="emphasis"><em>The TCP/IP Guide</em></span>, which is named under the umbrella of commercial (.com) companies.</p><div class="figure"><a id="hierarchical_name_architecture_str-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e54444"/><img alt="Hierarchical name architecture (structured name space)" src="httpatomoreillycomsourcenostarchimages288151.png.jpg"/></div></div><p class="title">Figure 50-5. Hierarchical name architecture (structured name space)</p></div><p>This diagram contains the same devices as <a class="xref" href="ch50s02.html#flat_name_architecture_flat_name_s-id001" title="Figure 50-4. Flat name architecture (flat name space) This diagram shows an example of a flat name architecture. There is no structure that organizes the names or dictates how they must be constructed. Logically, each device is a peer of each of the others.">Figure 50-4</a>, but they have been arranged using a hierarchical, structured name architecture. In this case, the organization has chosen to structure its device names first by facility location, and then by department. Each name starts with something like USA-Service- or EU-Mfg-. This has immediate benefits by providing local control over device naming without risk of conflicts. If someone named John were hired into the USA sales force, his machine could be named USA-Sales-John, without conflicting with the machine owned by John of the European sales force (EU-Sales-John). The structure also makes it easier to know immediately where a device can be found within the organization.<a class="indexterm" id="idx-CHP-50-1800"/></p></div><div class="sect2" title="Comparing Name Architectures"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_name_architectures"/>Comparing Name Architectures</h2></div></div></div><p>As you will see in the next two sections in this chapter, the architecture of the name space is intimately related to how names are registered and managed, and ultimately, how they are resolved. A flat name space requires a central authority of some sort to assign names to all devices in the system to ensure uniqueness. A hierarchical name architecture is ideally suited to a more distributed registration scheme that allows many authorities to share in the registration and administrative process.</p><p>All of this means that the advantages and disadvantages of each of these architectures are not a great mystery. Flat name spaces have the advantage of simplicity and the ability to create short and easily remembered names, as shown in <a class="xref" href="ch50s02.html#flat_name_architecture_flat_name_s-id001" title="Figure 50-4. Flat name architecture (flat name space) This diagram shows an example of a flat name architecture. There is no structure that organizes the names or dictates how they must be constructed. Logically, each device is a peer of each of the others.">Figure 50-4</a>. However, they do not scale well to name systems containing hundreds or thousands of machines, due to the difficulties in ensuring each <a class="indexterm" id="idx-CHP-50-1801"/>name is unique. For example, what happens if there are four people named John who all try to name their computers John's PC? Another issue is the overhead needed to centrally manage these names.</p><p>In contrast, hierarchical name spaces are more sophisticated and flexible, because they allow names to be assigned using a logical structure. We can name our machines using a hierarchy that reflects our organization's structure, for example, and give authority to different parts of the organization to manage parts of the name space. As long as each department is named uniquely and that unique department name is part of each machine name, we don't need to worry about each assigned name being unique across the entire organization; it just needs to be unique within the department. Thus, we can have four different machines named with their department name and John, as <a class="xref" href="ch50s02.html#hierarchical_name_architecture_str-id001" title="Figure 50-5. Hierarchical name architecture (structured name space)">Figure 50-5</a> demonstrates. The price of this flexibility is the need for longer names and more complexity in name <a class="indexterm" id="idx-CHP-50-1802"/>registration and resolution.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-302"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The two most common types of name architecture are the flat name space and the hierarchical name space. Names in a flat name space are all peers with no relationship. In a hierarchical architecture, a multiple-level structure is used to organize names in a specific way. The flat system is simpler and satisfactory for small networks. The hierarchical name space is more flexible and powerful, and better suited to larger networks and internetworks.</p></div></div></div>
<div class="sect1" title="Name Registration Methods, Administration, and Authorities"><div class="titlepage"><div><div><h1 class="title"><a id="name_registration_methods_administration"/>Name Registration Methods, Administration, and Authorities</h1></div></div></div><p>It seems obvious that for our name system to be implemented, we need some method of assigning names to each of the devices that will use the system. Just as a name system has a name space that is comparable to an addressing system's address space, it also must implement a set of rules and procedures for assigning names, comparable to how an addressing system assigns addresses. This is called <span class="emphasis"><em>name registration</em></span>.</p><div class="sect2" title="Name Registration Functions"><div class="titlepage"><div><div><h2 class="title"><a id="name_registration_functions"/>Name Registration Functions</h2></div></div></div><p>In general, name registration encompasses the following four concepts and tasks:</p><p><span class="strong"><strong>Name Assignment and Guarantee of Uniqueness</strong></span> The core task of the name registration process is assigning names to devices. Like all identification schemes, a key requirement of name registration is ensuring that each name is unique. Duplicated names cause ambiguity and make consistent name resolution impossible.</p><p><span class="strong"><strong>Central Registration Authority Designation</strong></span> Ensuring uniqueness of names requires that there be someone in charge of the name assignment process. This <span class="emphasis"><em>central registration authority</em></span> may be a single individual that maintains a file containing names, or it may be an organization that is responsible for the overall name registration process. The authority is also charged with resolving problems and conflicts that may arise in registrations.</p><p><span class="strong"><strong>Registration Authority Delegation</strong></span> In smaller name systems, the central registration authority may be responsible for the actual registration process for all devices. In larger, hierarchical name systems, having this process centralized is impractical. Instead, the central registration authority will divide the name space and <span class="emphasis"><em>delegate</em></span> authority for registering names in different parts of it to subordinate organizations. This requires a delegation policy to be developed and implemented.</p><p><span class="strong"><strong>Hierarchical Structure Definition</strong></span> When a hierarchical name space is used, the central authority is responsible for defining how the structure will look. This, in turn, dictates how names can be registered in different parts of the hierarchy, and of course, also impacts how authority is delegated.</p><p>The complexity of the <a class="indexterm" id="idx-CHP-50-1803"/>name registration process depends to a great extent on the size and complexity of the name system as a whole, and, in particular, on the architecture of the name space. In a simple name system using a flat name space, registration is usually accomplished using a single authority. There is no structure and usually no delegation of authority, so there isn't much to registration. For hierarchical name systems, name registration is tied tightly to the hierarchy used for names.</p></div><div class="sect2" title="Hierarchical Name Registration"><div class="titlepage"><div><div><h2 class="title"><a id="hierarchical_name_registration"/>Hierarchical Name Registration</h2></div></div></div><p>The central authority defines the structure of the hierarchy and decides how the hierarchy is to be <span class="emphasis"><em>partitioned</em></span> into subsets that can be independently administered by other authorities. Those authorities may, in turn, delegate subsets of their name spaces as well, creating a flexible and extensible system.</p><p>This ability to delegate authority for name registration is one of the most powerful benefits of a hierarchical name space. For example, in DNS, a central authority is responsible for name registration as a whole. This central authority is in charge of deciding which top-level domains—such as .com, .edu, .info, and .uk—are allowed to exist. Authority for managing each of these subsets of the worldwide hierarchy is then delegated to other organizations. These organizations continue the process of dividing the hierarchy as they see fit. Eventually, each organization is able to decide how it will name its own internal systems independently; for example, IBM can register names in any way it sees fit within the ibm.com name.</p></div><div class="sect2" title="Name Registration Methods"><div class="titlepage"><div><div><h2 class="title"><a id="name_registration_methods"/>Name Registration Methods</h2></div></div></div><p>There are several common methods by which the actual process of registration is carried out. These include <a class="indexterm" id="idx-CHP-50-1804"/>table name registration, broadcast name registration, and database registration. Each of these has its strengths and weaknesses, and again, some are better suited to flat name spaces and some to hierarchical ones.<a class="indexterm" id="idx-CHP-50-1805"/></p></div><div class="sect2" title="Table Name Registration"><div class="titlepage"><div><div><h2 class="title"><a id="table_name_registration"/>Table Name Registration</h2></div></div></div><p>Using table name registration, name assignments are maintained in a table by an administrator. When names need to be added, deleted, or changed, the table is edited.</p><p>This technique is usually associated with small, flat name space name systems. It has the same benefits and drawbacks as flat architecture in general: It is simple and easy to implement, but doesn't scale well to larger systems. With a dozen machines, having someone edit <a class="indexterm" id="idx-CHP-50-1806"/>name registration tables is practical; with thousands of machines, it is not. It is also not conducive to a hierarchical system where there are multiple authorities, because the table needs to be kept in one place.</p><p>In larger internetworks, tables may be used as an adjunct to one of the other, more sophisticated, registration <a class="indexterm" id="idx-CHP-50-1807"/>techniques.</p></div><div class="sect2" title="Broadcast Name Registration"><div class="titlepage"><div><div><h2 class="title"><a id="broadcast_name_registration"/>Broadcast Name Registration</h2></div></div></div><p>Broadcast name registration is a trial-and-error technique. A device that wants to use a particular name sends out a message to all other devices on the network, asking if anyone else is already using it. If so, it chooses a different name. If not, the name is considered registered and can then be used.</p><p>This technique is more sophisticated than using tables, but it is still limited to use in relatively small systems. It is not practical to attempt to broadcast to thousands of systems, and this method could not be used over the Internet, since there is no way to broadcast to every device on an internetwork.</p></div><div class="sect2" title="Database Registration"><div class="titlepage"><div><div><h2 class="title"><a id="database_registration"/>Database Registration</h2></div></div></div><p>With database registration, a database of name assignments is maintained. To register a name, a request must be made to have the name assignment added to the database. If the authority for the name system is entirely centralized, the database will be centralized and maintained by that authority. If authority for parts of the hierarchy is delegated, then a <span class="emphasis"><em>distributed database</em></span> is used for registration, with each authority maintaining the part of the database describing its section of the hierarchy.</p><p>This is the most sophisticated technique and one normally associated with hierarchical name systems like DNS. It has several benefits, including flexibility, reliability, and distribution of maintenance effort. Its main drawback is complexity.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-303"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Name registration</em></span> is the process by which names are linked to addresses in a name system. It encompasses activities such as central registry authority designation and delegation, and name space structure management. The most common methods of name registration, in order of both increasing capability and complexity, are manual table maintenance, broadcast registration, and database registration.</p></div></div></div>
<div class="sect1" title="Name Resolution Techniques and Elements"><div class="titlepage"><div><div><h1 class="title"><a id="name_resolution_techniques_and_elements"/>Name Resolution Techniques and Elements</h1></div></div></div><p>As we discussed earlier in this chapter, using a name system creates two parallel identification systems for computers: the numbers used by machines and the names used by people. The job of the name system is to integrate these two schemes. Name registration allows humans to specify which machines use which names. This is only half the process, however; we also need a way for machines to take a name given to them by a human and translate it into the numeric address it can actually use for communication. This is called <span class="emphasis"><em>name resolution</em></span>.</p><p><a class="indexterm" id="idx-CHP-50-1808"/>Name resolution, also sometimes called <span class="emphasis"><em>name translation, mapping</em></span>, or <span class="emphasis"><em>binding</em></span>, is the most well-known aspect of name systems, because it is where most of the "heavy lifting" of a name system occurs. The name space is generally set up once, and name registration occurs infrequently—only when names must be created or changed. In contrast, every user of a name system instructs the machines he or she uses to perform name <a class="indexterm" id="idx-CHP-50-1809"/>resolution, hundreds or even thousands of times a day.</p><div class="sect2" title="Name Resolution Methods"><div class="titlepage"><div><div><h2 class="title"><a id="name_resolution_methods"/>Name Resolution Methods</h2></div></div></div><p>Several different techniques can be used for name resolution. How this function is implemented depends a great deal on the other two name system functions: name space and name registration. As you might imagine, a simple name system with a simple name registration method will most often use a simple resolution method as well. Complex hierarchical systems with distributed databases require more sophistication in how names are resolved. There are three common name resolution methods: table name resolution, broadcast name resolution, and client/server name resolution.<a class="indexterm" id="idx-CHP-50-1810"/></p></div><div class="sect2" title="Table-Based Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="table-based_name_resolution"/>Table-Based Name Resolution</h2></div></div></div><p>The table used for table-based name registration is consulted by a device when resolution needs to be performed. The table tells the device how to transform the name of the machine it needs to contact into an address.<a class="indexterm" id="idx-CHP-50-1811"/></p><p>This technique obviously corresponds to table name registration. It is the simplest and least capable of the three methods. Table name resolution is suitable for stand-alone use only in very small name systems, but it can be a supplement to other methods as well.</p></div><div class="sect2" title="Broadcast Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="broadcast_name_resolution"/>Broadcast Name Resolution</h2></div></div></div><p>When a device needs to resolve a name, it broadcasts a query that says something to this effect: "I need to send to the device named <span class="emphasis"><em>X</em></span>. Who is that?" The device whose name is <span class="emphasis"><em>X</em></span> responds, "I'm <span class="emphasis"><em>X</em></span>, and my numeric address is <span class="emphasis"><em>N</em></span>."</p><p>This is the complement of broadcast name registration. It, too, can be used only in simple systems where every device can hear a broadcast. The use of broadcasts also makes it wasteful of network bandwidth.</p></div><div class="sect2" title="Client/Server Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="clientserver_name_resolution"/>Client/Server Name Resolution</h2></div></div></div><p>With client/server name resolution, servers are programmed with software that allows them to respond to name resolution requests sent by clients. These servers take the name in the request, look up the associated numeric identifier in a database, and send it back in a response.</p><p>This technique is generally used in conjunction with database name registration. It is the most complex name resolution method, but it is also the most efficient and the only one that can really work properly on a large, distributed hierarchical name system.</p></div><div class="sect2" title="Client/Server Name Resolution Functional Elements"><div class="titlepage"><div><div><h2 class="title"><a id="clientserver_name_resolution_functional_"/>Client/Server Name Resolution Functional Elements</h2></div></div></div><p>Client/server name resolution is the method used for most large, modern name systems. The client/server method of request/reply resolution is similar to how many other protocols function. One thing that is unique about name resolution, however, is that name resolution isn't often invoked directly by the client. It's rare, for example, for a human user to say, "Please resolve the following name." We also certainly wouldn't want users to need to manually resolve a name to an address each time they wished to contact a device, as this would be cumbersome.</p><p>Instead, the system is automated by having software accept machine names input by users. The software resolves the name by passing it to a <span class="emphasis"><em>name resolver</em></span> software component. The resolver acts as the client in the name resolution process. It contacts a <span class="emphasis"><em>name server</em></span>, which responds to the request. The name resolver and name server constitute the two main functional elements in name resolution.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-304"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Name resolution</em></span> is arguably the most important of the main functional elements of a name system, because it is the part of the system that actually converts names into addresses. The two main components of name resolution are <span class="emphasis"><em>name resolvers</em></span>, which act as clients in the resolution process, and <span class="emphasis"><em>name servers</em></span>. The three main name resolution methods—table-based, broadcast, and client/server—correspond closely to the table, broadcast, and database methods of name registration.</p></div><p>In a distributed database for a hierarchical name system, multiple requests may be required, since name servers will contain only information for certain machines and not others. Resolvers follow a special procedure to travel the hierarchy until they find the server that has the information they want. Again, DNS's name resolution is the best example of this method.</p></div></div>
<div class="sect1" title="Efficiency, Reliability, and Other Name Resolution Considerations"><div class="titlepage"><div><div><h1 class="title"><a id="efficiency_reliability_and_other_name_re"/>Efficiency, Reliability, and Other Name Resolution Considerations</h1></div></div></div><p>As described in the previous section, the primary function of name resolution is allowing humans to identify devices using names, then converting these names into numbers so that computers can use the numbers instead. This basic task is conceptually quite simple, but it can become quite complex in implementation. The reason for this is the key characteristic that makes name resolution so different from the other tasks performed by a name system: the frequency with which it is done.</p><p>Name registration is seldom done, but name resolution is done very often. If you consider a large internetwork with thousands of users running various applications, millions of names must be resolved every day. Now, consider something like the Internet, which must process billions of client/server requests and replies daily! Ensuring that such systems work requires that we do more than just implement a resolution process; we must add facilities to ensure that resolution is done as effectively as possible.</p><div class="sect2" title="Efficiency Considerations"><div class="titlepage"><div><div><h2 class="title"><a id="efficiency_considerations"/>Efficiency Considerations</h2></div></div></div><p>The first major concern with <a class="indexterm" id="idx-CHP-50-1812"/>name resolution is <span class="emphasis"><em>efficiency</em></span>. Name resolution uses up system resources, especially with resolution techniques that require requests and replies to be sent. This means we want to minimize the number of times resolution is performed, if at all possible. Now, consider that many people will frequently access the same machines over and over again. For example, if you go to a website called <a class="ulink" href="http://www.thisisasite.com">www.thisisasite.com</a> for the first time, your system will need to resolve that name. After the home page for that site loads, if you click a link to another page on that site, the page will also be found at that same name: <a class="ulink" href="http://www.thisisasite.com">www.thisisasite.com</a>. So, it would be wasteful to need to resolve that name a second time.</p><p>To avoid this, name systems almost always include some sort of <span class="emphasis"><em>caching</em></span> capability, which allows devices to remember recent name resolutions and retain the mapping from name to address for a period of time. Whenever a name needs to be resolved, the cache is first checked before going through the formal process of resolution. The use of caching eliminates the vast majority of actual name resolution requests that would otherwise be required.<a class="indexterm" id="idx-CHP-50-1813"/></p><p>The drawbacks of caching are that it requires some system resources of its own and that it adds complexity to the system. One issue is deciding how long to retain data in the cache. If we keep it too short a time, we generate extra unnecessary resolution requests. If we keep it too long, we risk having the mapping become stale if the name assignment for the machine changes. These are issues that a sophisticated name system must handle. A typical solution is to allow each name registration to specify how long information about that name-to-address link may be cached.</p></div><div class="sect2" title="Reliability Considerations"><div class="titlepage"><div><div><h2 class="title"><a id="reliability_considerations"/>Reliability Considerations</h2></div></div></div><p>The next main concern after efficiency is name resolution <span class="emphasis"><em>reliability</em></span>. As I said earlier in this chapter, having a name system isn't strictly necessary for the computers, but it's very important for the users, especially on a large network like the Internet.</p><p>While having a single central place that maintains all information about a name system may make administration simpler, it creates a dangerous single point of failure. If anything happens to the device storing the information, the entire name system fails. Modern name systems employ redundancies to prevent having the entire system rely on any particular device for resolution. A typical approach in a client/server system is to have multiple servers in different locations (or attached to different networks) that can respond to name resolution requests.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-305"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since name resolution is the part of a name system that is used most often, it is here that we must pay careful attention to implementation issues. The two most important ones are efficiency and reliability. Efficiency is essential due to the many thousands or millions of resolutions performed every day on a large system. Reliability is a consideration because users of the name system quickly come to rely on it, so we must make sure it is robust.</p></div></div><div class="sect2" title="Other Considerations"><div class="titlepage"><div><div><h2 class="title"><a id="other_considerations"/>Other Considerations</h2></div></div></div><p>An optional feature in some name resolution systems is <span class="emphasis"><em>load balancing</em></span>. When properly implemented, load balancing allows a single name to map to more than one underlying address. This allows requests sent to a particular virtual device to actually be directed to a number of different actual physical devices, spreading the load over multiple machines. A common use of this feature is for very popular websites that are visited often.</p><p>Finally, while name resolution is obviously designed to allow names to be mapped to addresses, there are cases where we may wish to go in the other direction: given a numeric address, find the name that goes with it. This process, called <span class="emphasis"><em>reverse resolution</em></span>, is analogous to having a phone number and trying to find the name of the person or company to which it belongs. Just as we can't easily find the name matching a phone number using a conventional phone book (we would need to scan every page looking for the number), reverse resolution requires special support on the part of the name system. This is especially true if the name system data is distributed over many servers.</p></div></div>
<div class="chapter" title="Chapter&#xA0;51.&#xA0;TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_name_systems_overview_and_the_host"/>Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e54783"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> TCP/IP has become sufficiently popular that many people—even those who aren't geeks—are fairly comfortable working with its numeric identifiers (IP addresses). Even so, it's a lot easier to work with names than numbers, and it's certainly easier to remember names. We can consider also that name systems become more important when used on larger networks, and TCP/IP is used to implement the Internet, the world's largest internetwork. Having a good name system is vital to the operation of the Internet, and thus, has become an important element of TCP/IP as a whole.</p><p>In this chapter, I begin the discussion of TCP/IP's name systems with a look at the history of the use of host names in TCP/IP and the early development of its name systems. I then provide a description of the simple host table name system, the first one used in the protocol suite. I discuss why host tables were replaced by the Domain Name System (DNS) and how, even today, they can be used to complement DNS functions.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-306"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>This chapter assumes that you are already familiar with the general concepts and issues of name systems explained in the preceding chapter</em></span>.</p></div><div class="sect1" title="A Brief History of TCP/IP Host Names and Name Systems"><div class="titlepage"><div><div><h1 class="title"><a id="a_brief_history_of_tcpip_host_names_and_"/>A Brief History of TCP/IP Host Names and Name Systems</h1></div></div></div><p><a class="indexterm" id="idx-CHP-51-1814"/>In the previous chapter, I described an interesting paradox: Even though name systems aren't strictly necessary for the functioning of a networking system, they make using a network so much easier for people that they are considered an essential part of most networks. No better evidence of this can be found than in the history of name system development in TCP/IP.</p><div class="sect2" title="Developing the First Name System: ARPAnet Host Name Lists"><div class="titlepage"><div><div><h2 class="title"><a id="developing_the_first_name_system_arpanet"/>Developing the First Name System: ARPAnet Host Name Lists</h2></div></div></div><p><a class="indexterm" id="idx-CHP-51-1815"/><a class="indexterm" id="idx-CHP-51-1816"/>The history of name systems in the TCP/IP protocol suite actually goes back well before the Transmission Control Protocol (TCP) and Internet Protocol (IP) were themselves even created. In the late 1960s and early 1970s, when the predecessor of the Internet, called the <a class="indexterm" id="idx-CHP-51-1817"/><span class="emphasis"><em>ARPAnet</em></span>, was being developed, it used older networking protocols that served the same function that TCP and IP do today.</p><p>The ARPAnet was very small by today's standards, containing at first only a few machines, referred to as <span class="emphasis"><em>hosts</em></span>, just as TCP/IP machines often are called today. The addressing scheme was also very simple, consisting of just the combination of a computer number and a port number for each host. With only a handful of machine names, it was easy to memorize addresses, but as the ARPAnet grew to several dozen machines, this scheme became untenable.</p><p>As early as 1971, it was apparent to the engineers designing the ARPAnet that symbolic names were much easier for everyone to work with than numeric addresses. They began to assign simple host names to each of the devices on the network. Each site managed its own <span class="emphasis"><em>host table</em></span>, which listed the mappings of names to addresses.</p><p>Naturally, the ARPAnet engineers immediately recognized the dangers of having each site maintain a list of possibly inconsistent host names. Since the internetwork was just a small "club" at this point, they used the Request for Comment (RFC) process itself to document standard host-name-to-address mappings. RFC 226, "Standardization of Host Mnemonics," is the first RFC I could find showing how host names were assigned. It was published on September 20, 1971.</p><p>This initial name system was about as manual as a system could be. As additions and changes were made to the network, the list of host names was updated in a new RFC, leading to a series of RFCs being published in the 1970s. Each host administrator still maintained his or her own host table, which was updated when a new RFC was published. During this time, the structure of host names was still under discussion, and changes were made to just about every aspect of the name system as new ideas were explored and refined.</p></div><div class="sect2" title="Storing Host Names in a Host Table File"><div class="titlepage"><div><div><h2 class="title"><a id="storing_host_names_in_a_host_table_file"/>Storing Host Names in a Host Table File</h2></div></div></div><p>This early name system worked fine while the ARPAnet was very small, but it presented many problems as the internetwork grew. One problem was that it was extremely slow in responding to network modifications, because additions and changes would be entered into device tables only after a new list was published. Also, even with the centralized list, there were still potential consistency issues, because a site manager might forget to update a file or make a typographical error.</p><p>The first improvement was to make the list of host name assignments a standard "master" text file, which was centrally managed and could be downloaded using network protocols like the File Transfer Protocol (FTP). The file was maintained at the Network Information Center (<a class="indexterm" id="idx-CHP-51-1818"/>NIC) at <a class="indexterm" id="idx-CHP-51-1819"/>Stanford University. The process for defining and using this file was described in RFCs 606 and 608, both entitled "Host Names On-Line," published in December 1973 and January 1974, respectively. These documents also formally specified the syntax for the TCP/IP <a class="indexterm" id="idx-CHP-51-1820"/>host table name system, described later in this chapter.</p><p>The use of a centrally managed <a class="indexterm" id="idx-CHP-51-1821"/>host table continued through the 1970s. When TCP/IP was developed, the system was maintained, and the mappings were made between host names and 32-bit IP addresses. RFC 810, "DoD Internet Host Table Specification," shows how host tables were defined for use with IP addresses. It was published in March 1982.</p></div><div class="sect2" title="Outgrowing the Host Table Name System and Moving to DNS"><div class="titlepage"><div><div><h2 class="title"><a id="outgrowing_the_host_table_name_system_an"/>Outgrowing the Host Table Name System and Moving to DNS</h2></div></div></div><p>The continuing growth of the ARPAnet/Internet made it apparent that the simple host table name system would eventually become unmanageable. With at first dozens, and then hundreds and thousands of new <a class="indexterm" id="idx-CHP-51-1822"/>hosts connecting to the internetwork, a single text file maintained in a central location just wasn't up to the task.</p><p>The idea of moving to a hierarchical name system based on the concept of <span class="emphasis"><em>domains</em></span> was first introduced in September 1981 in RFC 799, "Internet Name Domains." Considerable discussion and development of this concept occurred in the early 1980s. By 1983, a plan was put in place to migrate from the flat host table name system to the new Domain Name System (DNS). The detailed history of the development of this name system is continued in the overview of DNS in <a class="xref" href="ch52.html" title="Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS">Chapter 52</a>.</p></div></div></div>
<div class="sect1" title="The TCP/IP Host Table Name System"><div class="titlepage"><div><div><h1 class="title"><a id="the_tcpip_host_table_name_system"/>The TCP/IP Host Table Name System</h1></div></div></div><p>The pioneers of the modern Internet made the first name system for the TCP/IP suite when they created simple files containing the names and addresses of the machines in the early ARPAnet, as explained in the preceding section. This system was so simple that it originally wasn't even formally specified as a name system per se. Since the files contained names for network hosts, the process for relating names to addresses was simply called the <span class="emphasis"><em>host name</em></span> mechanism. Later, these files were called <span class="emphasis"><em>host tables</em></span>, and for this reason, this technology is commonly called the TCP/IP <span class="emphasis"><em>host table name system</em></span>.</p><p>As a system, it is extremely simple, since it consists of nothing more than a text file maintained on each machine on the network. This file is normally called <a class="indexterm" id="idx-CHP-51-1823"/>/etc/hosts on a UNIX system and HOSTS on a Windows system (usually residing in the main Windows directory). The file usually begins with some comment lines and then lists pairs of IP addresses and host names. A very simplified example (using the modern table structure, which is slightly different from the original host table format) is shown in <a class="xref" href="ch51s02.html#example_tcpip_host_table" title="Example 51-1. Example TCP/IP host table">Example 51-1</a>.</p><a id="I_programlisting2_d1e54913"/><pre class="programlisting"># Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
#
# Each line should take the form:
# &lt;address&gt;              &lt;host name&gt;
#
127.0.0.1                localhost
209.68.14.80             www.pcguide.com
216.92.177.143           www.desktopscenes.com
198.175.98.64            ftp.intel.comHost Table Name Space
<a class="indexterm" id="idx-CHP-51-1824"/></pre><div class="example"><a id="example_tcpip_host_table"/><p class="title">Example 51-1. Example TCP/IP host table</p><div class="example-contents"><p><a class="indexterm" id="idx-CHP-51-1825"/>The name space and architecture for the host table name system is theoretically flat, with each name being able to take any form, without any real structure. Despite this, for consistency, certain rules were eventually put in place regarding how names should be created, as discussed in <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>. As you will learn later in this chapter, it's also possible to use host tables to support the implementation of a hierarchical name space, which would mean that the names would need to be created using that name space's structural rules.</p></div></div><div class="sect2" title="Host Table Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="host_table_name_resolution"/>Host Table Name Resolution</h2></div></div></div><p><a class="indexterm" id="idx-CHP-51-1826"/>Name resolution in the host table name system is very simple. Each device reads the host table into memory when it starts up. Users of the system can refer to the names in that host table by using names, instead of a numeric IP addresses, in their invocation of various applications. When the software detects a name has been used in this manner, it refers the name to the internal resolver routine in the device, which looks up the name in the host table in memory and returns its address. There is no need for any transmissions or servers to be contacted; resolution is entirely local.</p></div><div class="sect2" title="Host Table Name Registration"><div class="titlepage"><div><div><h2 class="title"><a id="host_table_name_registration"/>Host Table Name Registration</h2></div></div></div><p><a class="indexterm" id="idx-CHP-51-1827"/>Now, here is the part where I am supposed to say that name registration in the host table name system is simple as well, right? Well, yes and no. From a purely technical standpoint, it certainly is simple. A name is registered on a particular device when the name and corresponding IP address are entered into the device's host table, and that's it.</p><p>However, name registration is much more complicated from an administrative standpoint, and this is where we find the major weakness of using host tables. Each network device maintains its own host table independent of the others, usually stored as a file on its local hard disk. This is in contrast to database registration systems (see <a class="xref" href="ch50.html" title="Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES">Chapter 50</a>), where the data is centrally stored and managed. This approach to name registration leads to two very important concerns:</p><p><span class="strong"><strong>Consistency</strong></span> Since every device has its own host table, how do we ensure that information is consistent throughout all the tables on the different devices?</p><p><span class="strong"><strong>Modifications</strong></span> How do we ensure that information about new device mappings and changes to existing ones are propagated to all devices?</p><p>As explained earlier in this chapter, the original mechanism for name registration was simply hand-editing, with administrators consulting updated published lists of device names. This was a very inefficient method that was prone to error and slow to acknowledge changes to the network. The revised system used a centrally managed master file that was downloaded by all sites on a regular basis. Name registration in this method required that the name/address mapping be submitted to the authority managing the central file, the NIC.</p></div><div class="sect2" title="Weaknesses of the Host Table Name System"><div class="titlepage"><div><div><h2 class="title"><a id="weaknesses_of_the_host_table_name_system"/>Weaknesses of the Host Table Name System</h2></div></div></div><p><a class="indexterm" id="idx-CHP-51-1828"/>The use of a centralized master file for name registration certainly worked better than using the equivalent of interoffice memos to publish host name lists, but it was practical only in the early days of TCP/IP. As the internetwork grew, more weaknesses of the host table system became apparent:</p><p><span class="strong"><strong>Central Administration Overload</strong></span> The changes to the central file became more frequent, increasing the administrative load on the individual managing the master file, to the point where changes were being made many times per day. As the Internet continued to grow, it would eventually have become impossible for human beings to enter the changes as fast as they were being submitted.</p><p><span class="strong"><strong>Growth in the Master File Size</strong></span> Every host needed a line in the master file. When the Internet grew to be thousands and eventually millions of devices, the file size would have become excessive.</p><p><span class="strong"><strong>Excessive Bandwidth Use</strong></span> Since the master file was changing so often, this also meant that all the devices on the network needed to keep downloading this master file repeatedly to stay current. At the same time, the file was also growing in size. Frequent downloads of a big file meant large amounts of network bandwidth were being consumed on something that was, in essence, an overhead activity.</p><p><span class="strong"><strong>Flat Name Space Problems</strong></span> The lack of a hierarchical name space led to conflicts when users chose identical names for their devices, and this further increased the workload on the central administrator. These issues were ameliorated in part by using naming conventions, such as using a prefix with a location before each individual machine name (like the example we saw in <a class="xref" href="ch50.html" title="Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES">Chapter 50</a>), but this was not an ideal solution.</p><p>All of these are reasons why the designers of the Internet eventually moved away from using host tables for the entire Internet to the more capable DNS.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-307"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>host table name system</em></span> was the original mechanism used for implementing names on the early Internet. It consists simply of a set of tables containing mappings between names and addresses maintained on each machine in the internetwork. When a name needs to be resolved, the table is consulted to determine the appropriate address. This system is extremely simple, but not very capable and not well suited to a large global Internet, which is why it was eventually abandoned in favor of DNS.</p></div></div><div class="sect2" title="Use of the Host Table Name System in Modern Networking"><div class="titlepage"><div><div><h2 class="title"><a id="use_of_the_host_table_name_system_in_mod"/>Use of the Host Table Name System in Modern Networking</h2></div></div></div><p>Although the host table name system has critical weaknesses, it has not gone away entirely. There are two circumstances in which this technique is still of value, as explained in this section.</p><div class="sect3" title="Small &quot;Island&quot; Networks"><div class="titlepage"><div><div><h3 class="title"><a id="small_island_networks"/>Small "Island" Networks</h3></div></div></div><p>If you are setting up a small local area network (LAN) using TCP/IP, and you don't need the names of your devices to be accessible by those outside your network, then guess what: You have the equivalent, of sorts, of the early Internet. In that case, the host table system is as applicable to you as it was to the Internet in the 1970s. You can simply set up host tables on each device and manage them manually.</p><p>As long as the LAN is small enough that editing these files periodically is not a hassle, this is actually a fast and effective name system, because no exchange of messages is needed for resolution. You can even maintain a master file on one machine and copy it to the others when changes are required using a script, to save time.</p></div><div class="sect3" title="Local Name Mappings to Supplement DNS"><div class="titlepage"><div><div><h3 class="title"><a id="local_name_mappings_to_supplement_dns"/>Local Name Mappings to Supplement DNS</h3></div></div></div><p>Even though modern systems use DNS for most name resolution, they also usually still support the use of host table files. You can manually enter common name mappings into this file, even for devices that are on the global Internet. Your system can then be set up to consult this list before making use of its assigned DNS server.</p><p>The use of the HOSTS file in conjunction with DNS allows you to manually specify mappings for commonly accessed sites, which may provide a slight performance improvement since there is no need to access a server. Since the HOSTS file doesn't enforce any particular structure to names, it is naturally quite possible to put DNS-style hierarchical names into the file, as I showed in <a class="xref" href="ch51s02.html#example_tcpip_host_table" title="Example 51-1. Example TCP/IP host table">Example 51-1</a>. The file is loaded into memory and used to <span class="emphasis"><em>override</em></span> the normal DNS process for names listed in it.</p><p>Of course, you then subject yourself to all the potential maintenance headaches of manually edited files. You must update these files as host names or addresses are changed in the DNS system. For this reason, this second use of the HOSTS file for Internet sites served by DNS is less popular than the use of the file for local machines.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-308"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Even though the host table name system is not the primary mechanism used for TCP/IP naming, it is still used in two circumstances. The first is to implement a basic name system in a small local TCP/IP internetwork. The second is as an adjunct to DNS, where it allows manual mappings to be created that override the DNS process when needed.</p></div></div></div></div>
<div class="chapter" title="Chapter&#xA0;52.&#xA0;DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS"><div class="titlepage"><div><div><h1 class="title"><a id="domain_name_system_dns_overview_function"/>Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e55042"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The creation of host tables to map computer names to addresses greatly improved the usability of the early Internet and the TCP/IP protocol suite that implemented it. Unfortunately, while the host table name system worked well when the internetwork was small, it did not scale particularly well as the Internet started to grow in size and complexity. The name system had to stay, but the use of host tables had to be dispensed with in favor of a newer, more capable system.</p><p>Over the period of several years, many engineers worked to create a system that would meet not just the needs of TCP/IP internetworks of the time, but also those of the future. The new name system was based on a hierarchical division of the network into groups and subgroups, with names reflecting this structure. It was designed to store data in a distributed fashion to facilitate decentralized control and efficient operation, and included flexible and extensible mechanisms for name registration and resolution. This new name system for TCP/IP was called the <span class="emphasis"><em>Domain Name System (DNS)</em></span>.</p><p>We'll begin our look at <a class="indexterm" id="idx-CHP-52-1829"/>DNS in this introductory chapter. I start by providing an overview of DNS's <a class="indexterm" id="idx-CHP-52-1830"/>development, history, and standards, continuing the history begun in the overall look at TCP/IP name systems. I discuss the design goals and objectives of the creators of DNS, to help you understand better what its designers were trying to do. I then talk about the main components of DNS and the functions it performs, relating these to the basic functions explained in the overview section on name systems.</p><div class="sect1" title="DNS Overview, History, and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="dns_overview_history_and_standards"/>DNS Overview, History, and Standards</h1></div></div></div><p>The aversion that most people have to trying to remember numeric identifiers led to the very quick adoption of a name system for devices on the predecessors of what we now call the Internet. In the 1960s and early 1970s, names were given to machines, and these names were maintained in host tables. The TCP/IP host table name system (described in <a class="xref" href="ch51.html" title="Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM">Chapter 51</a>) worked well for a number of years, with a centrally maintained master list used by device administrators to ensure a consistent view of the network.</p><p>Unfortunately, such a system works well only when the number of devices is small. As the budding Internet grew, numerous weaknesses became apparent in the host table method, as I detailed in <a class="xref" href="ch51.html" title="Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM">Chapter 51</a>. Furthermore, the problems with the system weren't something that could be easily patched with small changes; the problems were structural, part of the basic idea of host tables as a whole. A completely new approach was needed for how names would be used on the Internet.</p><div class="sect2" title="Early DNS Development and the Move to Hierarchical Domains"><div class="titlepage"><div><div><h2 class="title"><a id="early_dns_development_and_the_move_to_hi"/>Early DNS Development and the Move to Hierarchical Domains</h2></div></div></div><p>The most important paradigm shift made by the TCP/IP engineers was the decision to change the name system from one that used a single, centralized list of names to a more decentralized system. The idea was to create a structured topology where names were organized into <span class="emphasis"><em>domains</em></span>. This idea was first introduced in RFC 799, "Internet Name Domains," published in September 1981.</p><p>RFC 799 actually describes more the mechanics of delivering electronic mail messages between domains than the domains themselves. Interestingly, the standard assumes a flat structure of domains in its discussion, while mentioning the possibility of creating a hierarchical structure instead. It was the decision to go to such a hierarchical name space for domains that led to the creation of DNS in the form in which we know it today.</p><p>Many RFC documents describing the development of different aspects of DNS were published in the early 1980s. The first real milestone in DNS's history was probably the publishing, in November 1983, of three initial documents discussing DNS concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RFC 881, "Domain Names Plan and Schedule," discusses the issues involved in implementing the new DNS and how to migrate from the older host table system.</p></li><li class="listitem"><p>RFC 882, "Domain Names: Concepts and Facilities," describes the concepts and functional elements of DNS in fairly extensive detail. It includes a discussion of the name space, resource records, and how name servers and resolvers work.</p></li><li class="listitem"><p>RFC 883, "Domain Names: Implementation Specification," provides the nitty-gritty details on DNS messaging and operation.</p></li></ul></div></div><div class="sect2" title="Standardization of DNS and Initial Defining Standards"><div class="titlepage"><div><div><h2 class="title"><a id="standardization_of_dns_and_initial_defin"/>Standardization of DNS and Initial Defining Standards</h2></div></div></div><p><a class="indexterm" id="idx-CHP-52-1831"/>The three "Domain Names" RFC documents published in November 1983 were discussed frequently over the months that followed, and the basic DNS mechanism was revised many times. Several subsequent RFCs were published, updating the DNS transition plan and schedule. Finally, in November 1987, agreement on the operation of the system was finalized, and four new RFCs were published that formalized the DNS system for the first time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RFC 1032, "Domain Administrators Guide," specifies administrative procedures and policies for those running a domain.</p></li><li class="listitem"><p>RFC 1033, "Domain Administrators Operations Guide," provides technical details on how to operate a DNS server, including how to maintain portions of the DNS distributed database of names.</p></li><li class="listitem"><p>RFC 1034, "Domain Names - Concepts and Facilities," replaces RFC 882, providing an introduction and conceptual description of DNS.</p></li><li class="listitem"><p>RFC 1035, "Domain Names - Implementation and Specification," is an update to RFC 883, specifying how DNS works in detail, including resource record definitions, message types, master file format, and resolver and name server implementation details.</p></li></ul></div><p>These last two documents, RFCs 1034 and 1035, are considered the definitive original specification for the operation of DNS. While they are now many years old, they still provide the essential description of how DNS works.</p><p>As the Internet has grown to include thousands and then millions of sites, the importance of DNS has grown as well. Today, most people use DNS almost every time they use TCP/IP to access the Internet. It has gone from an alternative form of addressing for applications to one that is preferred by most users. It is also an important building block of the more complete application layer addressing scheme developed for TCP/IP: Uniform Resource Identifiers (URIs) (described in <a class="xref" href="ch70.html" title="Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)">Chapter 70</a>).</p><p>The hierarchical nature of the DNS name space has allowed the Internet to grow by making the assignment and mapping of names manageable. The authority structure (which defines who is in charge of parts of the name space) is also hierarchical, giving local administrators control over the names of devices they manage, while ensuring name consistency across the hierarchy as a whole. The distribution of data using many name servers and a standardized resolution technique following a standard message protocol provides efficiency and reliability. These concepts will become clearer as we explore DNS more completely in later sections of this chapter.</p></div><div class="sect2" title="DNS Evolution and Important Additional Standards"><div class="titlepage"><div><div><h2 class="title"><a id="dns_evolution_and_important_additional_s"/>DNS Evolution and Important Additional Standards</h2></div></div></div><p>TCP/IP and the Internet have both changed a lot since 1987, of course, and <a class="indexterm" id="idx-CHP-52-1832"/>DNS has also had to change. Many RFCs have been written since the base documents were published in the late 1980s, most of which further clarify the operation of DNS, expand on its capabilities, or define new features for it. You can find all of these by searching for "domain" or "DNS" in a list of RFCs. There are dozens of these. The following are a few of the more interesting ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RFC 1183, "New DNS RR Definitions," defines several new experimental resource record types. Other subsequent RFCs have also defined new resource records.</p></li><li class="listitem"><p>RFC 1794, "DNS Support for Load Balancing," discusses load balancing for greater performance in DNS servers.</p></li><li class="listitem"><p>RFC 1995, "Incremental Zone Transfer in DNS," specifies a new feature that allows only part of a zone to be transferred to a secondary name server for efficiency.</p></li><li class="listitem"><p>RFC 1996, "A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)," adds a new message type to DNS to allow primary (authoritative) DNS servers to tell secondary servers that information has changed in the main database.</p></li><li class="listitem"><p>RFC 2136, "Dynamic Updates in the Domain Name System (DNS UPDATE)," describes a technique for dynamically making resource record changes in the DNS database (also called <span class="emphasis"><em>Dynamic DNS</em></span>).</p></li><li class="listitem"><p>RFC 2181, "Clarifications to the DNS Specification," discusses several issues with the main DNS <a class="indexterm" id="idx-CHP-52-1833"/>standards as defined in RFCs 1034 and 1035 and how to address them.</p></li><li class="listitem"><p>RFC 2308, "Negative Caching of DNS Queries (DNS NCACHE)," specifies the operation of negative caching, a feature that allows a server to maintain information about names that do not exist more efficiently.</p></li></ul></div></div><div class="sect2" title="DNS Adaptation for Internet Protocol Version 6"><div class="titlepage"><div><div><h2 class="title"><a id="dns_adaptation_for_internet_protocol_ver"/>DNS Adaptation for Internet Protocol Version 6</h2></div></div></div><p>Version 6 of the Internet Protocol (IPv6, covered in <a class="xref" href="pt07.html" title="Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)">Part II-4</a>) was developed starting in the mid-1990s and brought with it the need to make changes and enhancements to the operation of DNS. (Even though DNS operates at the higher layers, it deals intimately with addresses, and addresses have changed in IPv6, as discussed in <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a>.) The modifications required to allow DNS to support IPv6 were first defined in RFC 1886, "IPv6 DNS Extensions," which was part of a group of RFCs that laid out the fundamentals of IPv6. Several subsequent standards have been published since that time; these are discussed in the section on IPv6 DNS near the end of <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a>.</p><p>The rest of this chapter provides a more complete overview of DNS and its development, by discussing the design goals of its creators and the protocol's key characteristics.</p></div></div></div>
<div class="sect1" title="DNS Design Goals, Objectives, and Assumptions"><div class="titlepage"><div><div><h1 class="title"><a id="dns_design_goals_objectives_and_assumpti"/>DNS Design Goals, Objectives, and Assumptions</h1></div></div></div><p>As we just saw, the elapsed time from the first RFC discussing TCP/IP domain names to the publishing of the official standards describing the operation of DNS was more than six years. This is a very long time for the development of a system, but it isn't surprising. A lot of thought had to go into the creation of DNS, to be certain that it would meet all of the many demands that would be placed on it.</p><p>The first problem was that the creators of DNS needed to worry about both how to define the new system and how to migrate from the old one. Considerable time was spent figuring out how all the existing hosts would be moved over to the new DNS name space and how the new protocols for exchanging DNS information would be implemented on them.</p><p>The creators of DNS knew they were making the new system because the old one didn't scale very well. They also knew that if migration was a difficult problem with the small number of hosts in existence at that time, it would be much more difficult if they needed to go to another new system in the future. This made the key challenge in DNS to create a system that would meet the needs of the Internet not just the day it was introduced, or the following year, but even ten years or more down the road.</p><div class="sect2" title="DNS Design Goals and Objectives"><div class="titlepage"><div><div><h2 class="title"><a id="dns_design_goals_and_objectives"/>DNS Design Goals and Objectives</h2></div></div></div><p><a class="indexterm" id="idx-CHP-52-1834"/>Back in the 1980s, no one had any idea how the Internet would grow as it has in the last decade. That DNS still works as well as it does is a testament to the skill of its designers. Much of this success is due to the early groundwork put into the design of the system. DNS engineers documented some of what they considered to be the main design goals in creating it, which can help us understand not just what DNS does, but also why. These design goals and objectives are as follows:</p><p><span class="strong"><strong>Creation of a Global, Scalable, Consistent Name Space</strong></span> The name space needed to be capable of spanning a large, global internetwork containing millions of machines. It was necessary that it provide a consistent and predictable method for naming devices and resources, so they could be easily found. It was also, obviously, essential that name duplication be avoided, even when conflicts could potentially be between devices on different continents.</p><p><span class="strong"><strong>Local Control over Local Resources</strong></span> Administrators of networks and small internetworks on the Internet as a whole needed to be able to have control over the naming of their own devices. It would not be acceptable to need to go through a central authority for naming every single object, nor would it be acceptable for every administrator to need to know the names of everyone else's networks and machines.</p><p><span class="strong"><strong>Distributed Design to Avoid Bottlenecks</strong></span> The designers of DNS knew that they would need to abandon the idea of a centralized database in favor of a distributed approach to data storage, to avoid the bottlenecks that would result in using DNS with many devices.</p><p><span class="strong"><strong>Application Universality</strong></span> The system needed to be general enough that it would support a wide variety of applications. For example, it needed to support host identification, mail delivery, and other functions.</p><p><span class="strong"><strong>Multiple Underlying Protocol Support</strong></span> DNS needed to be inherently able to support different underlying protocols. Many people don't realize, for example, that DNS can support not just IP addresses, but other types of addresses, simply because IP is so dominant in networking today.</p><p><span class="strong"><strong>Hardware Universality</strong></span> Both large and small computers needed to be able to use the system.</p><p>Keep these objectives in mind as you learn more about DNS, and they will help you understand better why certain design attributes were chosen. For example, if we consider the first two objectives listed, they seem almost contradictory: How can we have a global name space with unique names if individual administrators were able to assign local names? As you will see, this is where the power of the DNS hierarchical name space shines through.</p></div><div class="sect2" title="DNS Design Assumptions"><div class="titlepage"><div><div><h2 class="title"><a id="dns_design_assumptions"/>DNS Design Assumptions</h2></div></div></div><p>The design goals tell us what DNS's creators wanted to make sure the new system addressed. In addition, the engineers that worked on the protocol's implementation details needed to make decisions based on certain assumptions of how it would be used:</p><p><span class="strong"><strong>Rapidly Growing Database Size</strong></span> By the mid-1980s, it was obvious that the DNS database of names would start out rather small but would grow quickly. The system needed to be capable of handling this rapid growth.</p><p><span class="strong"><strong>Variable Data Modification Rate</strong></span> Most of the data in the name database would change only infrequently, but some data would change more often than that. This meant flexibility would be required in how data changes were handled and how information about those changes was communicated.</p><p><span class="strong"><strong>Delegatable Organizational Responsibility</strong></span> Responsibility for portions of the name database would be delegated primarily on the basis of organizational boundaries. Many organizations would also run their own hardware and software to implement portions of the overall system.</p><p><span class="strong"><strong>Relative Importance of Name Information Access</strong></span> It was assumed that the most important thing about DNS was providing reliable name resolution, so the system was created so that it was always possible for a user to access a name and determine its address. A key decision in creating the system was deciding that even if the information were slightly out of date, it was better than no information at all. If a name server were unable to provide the latest data to fill a request, it would return the best information it had available.</p><p><span class="strong"><strong>Handling of Requests for Missing Information</strong></span> Since the name data was to be distributed, a particular name server might not have the information requested by a user. In this case, the name server should not just say, "I don't know." It should provide a referral to a more likely source of the information or take care of finding the data by issuing its own requests. This led to the creation of the several DNS name resolution techniques: local, iterative, and recursive.</p><p><span class="strong"><strong>Use of Caching for Performance</strong></span> From the start, it was assumed that DNS would make extensive use of caching to avoid unnecessary queries to servers containing parts of the distributed name database.</p><p>Arguably, a lot more assumptions were made in creating this system, as is the case in the development of every system. For example, DNS needed to make assumptions about how exactly data would be stored, the transport mechanism for sending messages, the role of administrators, and so on. You'll learn more about these as we go through our look at the system.</p></div></div>
<div class="sect1" title="DNS Components and General Functions"><div class="titlepage"><div><div><h1 class="title"><a id="dns_components_and_general_functions"/>DNS Components and General Functions</h1></div></div></div><p><a class="indexterm" id="idx-CHP-52-1835"/><a class="indexterm" id="idx-CHP-52-1836"/>To meet the many objectives set for it by its designers, DNS requires a great deal of functionality. It is a true name system with the emphasis on <span class="emphasis"><em>system</em></span>, and as such, is considerably more complex than the host table name system used earlier in TCP/IP. In <a class="xref" href="ch50.html" title="Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES">Chapter 50</a>, I divided the many tasks of a full-featured name system into three categories. DNS includes functions in all of these categories, and so using these categories is a good way to take a high-level look at the way DNS works (see <a class="xref" href="ch52s03.html#dns_functions_dns_consists_of_three_main" title="Figure 52-1. DNS functions DNS consists of three main functional categories: name space, name registration, and name servers/resolution. Each of these consists of a number of specific tasks and responsibilites.">Figure 52-1</a>).</p><div class="figure"><a id="dns_functions_dns_consists_of_three_main"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e55283"/><img alt="DNS functions DNS consists of three main functional categories: name space, name registration, and name servers/resolution. Each of these consists of a number of specific tasks and responsibilites." src="httpatomoreillycomsourcenostarchimages288153.png.jpg"/></div></div><p class="title">Figure 52-1. DNS functions DNS consists of three main functional categories: name space, name registration, and name servers/resolution. Each of these consists of a number of specific tasks and responsibilites.</p></div><div class="sect2" title="DNS Name Space"><div class="titlepage"><div><div><h2 class="title"><a id="dns_name_space"/>DNS Name Space</h2></div></div></div><p>DNS uses a hierarchical <a class="indexterm" id="idx-CHP-52-1837"/>name space consisting of a single, complex, multiple-level structure into which all names in the system fit. The name space is organized starting from a single root into which containers (called <span class="emphasis"><em>domains</em></span>) are placed. Each can contain either individual device names or more specific subcontainers. The overall structure is somewhat analogous to how a directory system on a computer organizes files from general to specific, using an arbitrary structure that can be optimized to various needs. A specific syntax is used to define valid names, and special terminology is used to describe parts of the structure and identify domain names, from the root down to the device level.</p></div><div class="sect2" title="Name Registration (Including Administration and Authorities)"><div class="titlepage"><div><div><h2 class="title"><a id="name_registration_including_administrati"/>Name Registration (Including Administration and Authorities)</h2></div></div></div><p>DNS name registration is used to enter individual names into the DNS distributed database. DNS uses a hierarchical arrangement of authorities that complements the hierarchical name space. A centralized authority determines the overall shape and structure of the name space and handles registration of names at the highest level. Authority is then <span class="emphasis"><em>delegated</em></span> to different organizations to manage various parts of the name space. A set of universal policies controls the registration process and deals with problems and conflicts.</p></div><div class="sect2" title="Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="name_resolution"/>Name Resolution</h2></div></div></div><p>DNS uses a powerful, distributed, client/server name resolution mechanism. This is probably the area where the most attention needed to be put into the design of DNS, to ensure that it could scale to handle millions and eventually billions of name resolution requests each day.</p><p>The name resolution process is implemented using two basic software elements that play the role of server and client: name servers and name resolvers.</p><p>DNS name servers are special programs running on hardware servers that are the heart of DNS. Servers are maintained by organizations that have administrative control over part of the DNS name space. They contain <span class="emphasis"><em>resource records</em></span> that describe names, addresses, and other characteristics of those portions of the name space. As such, the servers themselves are arranged into a hierarchy analogous to that of the name space, although not identical in structure.</p><p>The main job of name servers is to receive requests for name resolution and respond with either the data requested from the database or with the name of another name server that will lead to the requested information. Name servers are also responsible for data caching and other administrative tasks to ensure efficient operation of the system as a whole.</p><p>Name resolvers are the usual clients in the name resolution process. When a user makes reference to a name in a networking application, the name is passed to the resolver, which issues a request to a name server. Depending on the configuration, more than one request may be needed, and several different resolution processes may be combined to find the needed information. Resolvers also may employ caching or implement other features.</p><div class="note" title="Note"><h3 class="title"><a id="note-130"/>Note</h3><p><span class="emphasis"><em>The division between resolvers and servers is based on roles. As you'll see when we look at name resolution, name servers may also function as clients in certain exchanges of data. See <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a> for an explanation of this apparent paradox</em></span>.</p></div><p>If this seems a lot like the classic description of a name system that I gave in <a class="xref" href="ch50.html" title="Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES">Chapter 50</a>, that's not a coincidence. DNS is considered <span class="emphasis"><em>the</em></span> name system against which most others are usually compared. If you understand these high-level descriptions, then you already know the basics of how DNS works. The next three chapters delve into each of these three functional areas in more detail and will help you really learn how DNS does its thing.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-309"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> As a complete name system, DNS provides numerous capabilities that implement each of the three basic name system functions. The DNS <span class="emphasis"><em>name space</em></span> is hierarchical and is organized using a multilevel structure with particular naming rules. The DNS <span class="emphasis"><em>name registration</em></span> system is based on the idea of a hierarchy of domains and registration authorities responsible for them. DNS <span class="emphasis"><em>name resolution</em></span> is similarly hierarchical, and it is designed around interaction between <span class="emphasis"><em>name resolver</em></span> and <span class="emphasis"><em>name server</em></span> software components that consult databases of DNS <span class="emphasis"><em>resource records</em></span> and communicate using a special messaging protocol to answer client queries.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;53.&#xA0;DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_space_architecture_and_terminol"/>Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e55371"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The <a class="indexterm" id="idx-CHP-53-1838"/>name space is the most fundamental part of any name system, since it is what defines the ways that the names themselves are created. The name space tells us what form names may take and provides the rules for how they are created. Most important, it specifies the <span class="emphasis"><em>architecture</em></span> of the names—the internal structure of names themselves. This, in turn, has a critical influence on how name registration and resolution work, making an examination of name space and architecture issues the obvious place to start in learning the details of the Domain Name System (DNS).</p><p>In this chapter, I describe the concepts behind the DNS name space and its structure. I begin with an overview of the DNS name space and description of the hierarchical architecture it uses. I then explain the terminology often used to refer to parts of the name space. Next, I provide a formal description of DNS labels and the official and unofficial rules for creating domain names. I conclude with a description of domain name specifications, and I explain the concept of qualification and how fully qualified and partially qualified names differ.</p><div class="sect1" title="DNS Domains and the DNS Hierarchical Name Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="dns_domains_and_the_dns_hierarchical_nam"/>DNS Domains and the DNS Hierarchical Name Architecture</h1></div></div></div><p>The most important element of a name system's name space is its <span class="emphasis"><em>name architecture</em></span>, which describes how names are constructed and interpreted. The architecture of DNS is, unsurprisingly, based on the concept of an abstraction called a <span class="emphasis"><em>domain</em></span>. This is obviously a good place to start in explaining how DNS works.<a class="indexterm" id="idx-CHP-53-1839"/></p><div class="sect2" title="The Essential Concept in the DNS Name Space: Domains"><div class="titlepage"><div><div><h2 class="title"><a id="the_essential_concept_in_the_dns_name_sp"/>The Essential Concept in the DNS Name Space: Domains</h2></div></div></div><p>Dictionary definitions of the word <span class="emphasis"><em>domain</em></span> generally convey the notion of a sphere of influence or an area of control or rulership. An essential concept is that in various contexts, control or authority can be exerted at many different levels. One sphere of influence may contain smaller ones, which can, in turn, contain still smaller ones. This means that such domains are naturally arranged in a hierarchy.<a class="indexterm" id="idx-CHP-53-1840"/><a class="indexterm" id="idx-CHP-53-1841"/></p><p>As an example, consider geopolitical domains. We have no centralized "world government" on earth, but we do have the United Nations, which deals with worldwide issues. At the next level down, we have individual countries. Some of these countries have divisions such as states and provinces. Still lower levels have counties, municipalities, neighborhoods, and individual residences or businesses. The "domains" are inherently hierarchical in organization.</p><p>DNS uses the word <span class="emphasis"><em>domain</em></span> in a manner very similar to this, and it employs a hierarchical structure that works in much the same way as the geopolitical example. In DNS, a <span class="emphasis"><em>domain</em></span> is defined as either a single object or a set of objects that have been collected together based on some type of commonality. Usually, in DNS, that commonality is that they are all administered by the same organization or authority, which makes the name hierarchy tightly linked to the notion of the DNS hierarchical authority structure (see <a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a>).</p><div class="note" title="Note"><h3 class="title"><a id="note-131"/>Note</h3><p><span class="emphasis"><em>The term domain is also used in other contexts in the world of networking. The most notable example of this is in Microsoft networking, where domain is also used to represent the notion of a collection of objects under common authority. However, the two types of domains are completely different and not related beyond this conceptual level</em></span>.<a class="indexterm" id="idx-CHP-53-1842"/><a class="indexterm" id="idx-CHP-53-1843"/></p></div></div><div class="sect2" title="The DNS Hierarchical Tree Structure of Names"><div class="titlepage"><div><div><h2 class="title"><a id="the_dns_hierarchical_tree_structure_of_n"/>The DNS Hierarchical Tree Structure of Names</h2></div></div></div><p>We could construct a tree diagram with the United Nations on top, with lines pointing to each of the countries in the world. Then, within the United States, we could draw lines to each of the states. Within each state, we could draw lines to each county, and so on. The result would be something that looks like an upside-down tree, as illustrated in <a class="xref" href="ch53.html#example_of_a_global_hierarchical_domain_" title="Figure 53-1. Example of a global hierarchical domain architecture This diagram shows an example of hierarchical architecture, based on political divisions. The United Nations is an umbrella organization representing (to one extent or another) all of the world's nations. It is the root of the tree; underneath it we find individual nations. Each nation then is further subdivided in a manner it chooses. For example, Canada has provinces and territories, and the United States has individual states. These can be further subdivided in any number of ways.">Figure 53-1</a>. This is called a <span class="emphasis"><em>tree structure</em></span>.<a class="indexterm" id="idx-CHP-53-1844"/></p><p>Tree structures are common in computing and networking. For example, trees are a type of topology used to connect networks into a local area network.</p><p>For understanding DNS, the best example of a tree structure is the directory tree used to store files on a computer's hard disk. The root directory is at the top of the structure and may contain named files and/or named directories. Each directory can itself contain individual files or subdirectories, which can, in turn, contain their own subdirectories, and so on. The domain name structure in DNS is conceptually arranged in the same way, but instead of dealing with files, DNS deals with named objects, usually devices like Internet Protocol (IP) hosts.</p><div class="figure"><a id="example_of_a_global_hierarchical_domain_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e55477"/><img alt="Example of a global hierarchical domain architecture This diagram shows an example of hierarchical architecture, based on political divisions. The United Nations is an umbrella organization representing (to one extent or another) all of the world's nations. It is the root of the tree; underneath it we find individual nations. Each nation then is further subdivided in a manner it chooses. For example, Canada has provinces and territories, and the United States has individual states. These can be further subdivided in any number of ways." src="httpatomoreillycomsourcenostarchimages288155.png.jpg"/></div></div><p class="title">Figure 53-1. Example of a global hierarchical domain architecture This diagram shows an example of hierarchical architecture, based on political divisions. The United Nations is an umbrella organization representing (to one extent or another) all of the world's nations. It is the root of the tree; underneath it we find individual nations. Each nation then is further subdivided in a manner it chooses. For example, Canada has provinces and territories, and the United States has individual states. These can be further subdivided in any number of ways.</p></div><p>The highest level is still the <span class="emphasis"><em>root</em></span> of the tree. It contains a number of domains, each of which can contain individual objects (names) and/or lower-level domains. Lower-level domains can, in turn, have still lower-level domains, allowing the tree as a whole to take on an arbitrary structure.</p><p>Like a directory structure, the DNS hierarchical name architecture allows names to be organized from most general to most specific. It also has complete flexibility, allowing us to arrange the structure in any way that we want. For example, we could make a name system that is structured exactly paralleling the geopolitical organization chart shown in <a class="xref" href="ch53.html#example_of_a_global_hierarchical_domain_" title="Figure 53-1. Example of a global hierarchical domain architecture This diagram shows an example of hierarchical architecture, based on political divisions. The United Nations is an umbrella organization representing (to one extent or another) all of the world's nations. It is the root of the tree; underneath it we find individual nations. Each nation then is further subdivided in a manner it chooses. For example, Canada has provinces and territories, and the United States has individual states. These can be further subdivided in any number of ways.">Figure 53-1</a>. We could have the root of the name structure represent the United Nations and create a domain for each country. Then, for those countries that have states, we could create state domains within those country domains. Smaller countries not needing those domains could have city domains directly under the country domain. The hierarchy is flexible, because at each level, it can be given a suitable substructure.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-310"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The DNS <a class="indexterm" id="idx-CHP-53-1845"/>name space is arranged into a <span class="emphasis"><em>hierarchy of domains</em></span> shaped like an inverted tree. It is structurally similar to the directory structure of a file system, with a root that contains domains, each of which can contain subdomains and so forth.</p></div><p>It's important to remember that every stand-alone internetwork can have its own name space and unique hierarchical structure. Many times, people conflate the idea of <span class="emphasis"><em>a</em></span> DNS name space with <span class="emphasis"><em>the</em></span> DNS name space. The latter refers to the DNS hierarchy used for the <a class="indexterm" id="idx-CHP-53-1846"/>global Internet, and it's obvious that this deserves a great deal of attention. But it is just one possible arrangement, although an important one, of an infinite number of possible structures.</p><div class="note" title="Note"><h3 class="title"><a id="note-132"/>Note</h3><p><span class="emphasis"><em><a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a> provides more specific information about the Internet's DNS hierarchy. As you'll see, geopolitical structures are, in fact, used to assign names to some of the Internet's computers, but other parts of the hierarchy are different</em></span>.</p></div></div></div></div>
<div class="sect1" title="DNS Structural Elements and Terminology"><div class="titlepage"><div><div><h1 class="title"><a id="dns_structural_elements_and_terminology"/>DNS Structural Elements and Terminology</h1></div></div></div><p>Now that we've reviewed the fundamentals of the DNS name space, let's look at its structure in more detail. At the same time, I'll define the many different terms used to refer to parts of the DNS <a class="indexterm" id="idx-CHP-53-1847"/>domain name hierarchy.</p><div class="sect2" title="DNS Tree-Related Terminology"><div class="titlepage"><div><div><h2 class="title"><a id="dns_tree-related_terminology"/>DNS Tree-Related Terminology</h2></div></div></div><p>As I explained in the previous section, the DNS name structure is shaped somewhat like a tree. The comparison between structured elements and trees is a common one in networking. The main difference between technology and biology is that DNS trees grow from the top down, instead of reaching for the sky. The analogy to a tree naturally leads to the use of several tree-related terms in describing the DNS name structure, some of which are illustrated in <a class="xref" href="ch53s02.html#dns_tree-related_and_domain-related_term" title="Figure 53-2. DNS tree-related and domain-related terminology The top of the DNS name space is the root of the tree, and it has no name. Under the root comes any number of top-level domains (TLDs). Within each of these can be placed second-level domains, then within those subdomains, and so forth. Some of the tree terminology used in DNS is also shown here. The portion of the tree with the light shading is one branch; the darker area highlights a smaller subbranch within that branch. The darkest nodes within that area are the leaves of that smaller branch of the tree.">Figure 53-2</a>:<a class="indexterm" id="idx-CHP-53-1848"/></p><p><span class="strong"><strong>Root</strong></span> This is the conceptual top of the DNS name structure. The <span class="emphasis"><em>root</em></span> domain in DNS contains the entire structure. By definition, it has no name; it is <span class="emphasis"><em>null</em></span>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-53-1849"/>Branch</strong></span> A <span class="emphasis"><em>branch</em></span> is any contiguous portion of DNS hierarchy. It consists of a domain and all the domains and objects within it. All branches connect together to the root, just as in a real tree. (Yes, it would be better if the root were called the <span class="emphasis"><em>trunk</em></span>, but computer science majors apparently don't take botany electives.)</p><p><span class="strong"><strong>Leaf</strong></span> This is an end object in the structure; that is, a domain that doesn't have anything underneath it. The analogy to a leaf being at the end of a sequence of branches is apt.</p><p>There is no specific term to refer to a domain that is not a leaf. These are sometimes called <span class="emphasis"><em>interior nodes</em></span>, meaning that they are in the middle of the structure. A <span class="emphasis"><em>node</em></span> is the generic computing term for an object in a topology or structure. So, in DNS, every node is a domain, and it may be an interior node that contains additional domains and/or objects or a leaf that is a specific, named device. The term <span class="emphasis"><em>domain</em></span> is thus somewhat ambiguous, as it can refer to either a collection of objects that represents a branch of the tree or to a specific leaf.<a class="indexterm" id="idx-CHP-53-1850"/></p></div><div class="sect2" title="DNS Domain-Related Terminology"><div class="titlepage"><div><div><h2 class="title"><a id="dns_domain-related_terminology"/>DNS Domain-Related Terminology</h2></div></div></div><p>There are also several domain-like terms that are often used to refer to domains at different levels of the hierarchy. These terms are also shown in <a class="xref" href="ch53s02.html#dns_tree-related_and_domain-related_term" title="Figure 53-2. DNS tree-related and domain-related terminology The top of the DNS name space is the root of the tree, and it has no name. Under the root comes any number of top-level domains (TLDs). Within each of these can be placed second-level domains, then within those subdomains, and so forth. Some of the tree terminology used in DNS is also shown here. The portion of the tree with the light shading is one branch; the darker area highlights a smaller subbranch within that branch. The darkest nodes within that area are the leaves of that smaller branch of the tree.">Figure 53-2</a>:<a class="indexterm" id="idx-CHP-53-1851"/></p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-53-1852"/>Root Domain</strong></span> This is the root of the tree.</p><p><span class="strong"><strong>Top-Level Domains (<a class="indexterm" id="idx-CHP-53-1853"/>TLDs)</strong></span> These are the highest-level domains directly under the root of the tree. They are also sometimes called <span class="emphasis"><em>first-level domains</em></span>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-53-1854"/>Second-Level Domains</strong></span> Shockingly enough, these are the domains located directly below the top-level domains.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-53-1855"/>Subdomains</strong></span> In some contexts, this term refers only to domains that are located directly below the second-level domains.</p><div class="figure"><a id="dns_tree-related_and_domain-related_term"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e55640"/><img alt="DNS tree-related and domain-related terminology The top of the DNS name space is the root of the tree, and it has no name. Under the root comes any number of top-level domains (TLDs). Within each of these can be placed second-level domains, then within those subdomains, and so forth. Some of the tree terminology used in DNS is also shown here. The portion of the tree with the light shading is one branch; the darker area highlights a smaller subbranch within that branch. The darkest nodes within that area are the leaves of that smaller branch of the tree." src="httpatomoreillycomsourcenostarchimages288157.png"/></div></div><p class="title">Figure 53-2. DNS tree-related and domain-related terminology The top of the DNS name space is the root of the tree, and it has no name. Under the root comes any number of top-level domains (TLDs). Within each of these can be placed second-level domains, then within those subdomains, and so forth. Some of the tree terminology used in DNS is also shown here. The portion of the tree with the light shading is one branch; the darker area highlights a smaller subbranch within that branch. The darkest nodes within that area are the leaves of that smaller branch of the tree.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-311"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The top of the DNS name space is the <span class="emphasis"><em>root</em></span>. Under the root come <span class="emphasis"><em>top-level domains</em></span>, and within these are <span class="emphasis"><em>second-level domains</em></span> and then <span class="emphasis"><em>subdomains</em></span>. In theory, any number of levels of subdomains can be created. A branch is any contiguous portion of the DNS tree. A leaf is a domain with nothing underneath it in the structure, and it usually represents a single device.<a class="indexterm" id="idx-CHP-53-1856"/><a class="indexterm" id="idx-CHP-53-1857"/><a class="indexterm" id="idx-CHP-53-1858"/></p></div><p>The term <span class="emphasis"><em>subdomain</em></span> can also be used generically, like the word <span class="emphasis"><em>domain</em></span> itself. In that case, it refers simply to the relationship between two domains, with a subdomain being under another domain in the structure. This means, for example, that top-level domains can be said to be subdomains of the root; every second-level domain is a subdomain of a top-level domain, and so on. But again, sometimes <span class="emphasis"><em>subdomain</em></span> means specifically a third-level or lower domain.</p></div><div class="sect2" title="DNS Family-Related Terminology"><div class="titlepage"><div><div><h2 class="title"><a id="dns_family-related_terminology"/>DNS Family-Related Terminology</h2></div></div></div><p>Another set of <a class="indexterm" id="idx-CHP-53-1859"/>terminology related to DNS compares the tree structure not to a living tree, but to another analogy: a family tree. These terms are most often used to describe how a particular domain relates to the other domains or subdomains around it, so they are relative terms. The following family-related terms are common (see <a class="xref" href="ch53s02.html#dns_name_space_family_tree_this_diagram_" title="Figure 53-3. DNS name space &quot;family tree&quot; This diagram is similar to Figure 53-2, but the nodes are labeled to show the family-oriented terminology sometimes used in DNS. In this case, the names are relative to the interior node shown in the darker shade. The domain immediately above it is its parent node. Other nodes on the same level are siblings, and subdomains within it are children of that node.">Figure 53-3</a>).<a class="indexterm" id="idx-CHP-53-1860"/></p><p><span class="strong"><strong>Parent Domain</strong></span> This is the domain that is above this one in the hierarchy. For example, the root domain is the parent of all top-level domains.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-53-1861"/>Child</strong></span> This is a domain at the next level down from this one in the hierarchy. Thus, the top-level domains are <span class="emphasis"><em>children</em></span> of the root.</p><p><span class="strong"><strong>Sibling</strong></span> This is a peer at the same level as this one in the hierarchy, with the same parent. Thus, all top-level domains are <span class="emphasis"><em>siblings</em></span> with the root as a parent; all second-level domains within a particular top-level domain are siblings, and so on.</p><div class="figure"><a id="dns_name_space_family_tree_this_diagram_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e55731"/><img alt="DNS name space &quot;family tree&quot; This diagram is similar to , but the nodes are labeled to show the family-oriented terminology sometimes used in DNS. In this case, the names are relative to the interior node shown in the darker shade. The domain immediately above it is its parent node. Other nodes on the same level are siblings, and subdomains within it are children of that node." src="httpatomoreillycomsourcenostarchimages288159.png.jpg"/></div></div><p class="title">Figure 53-3. DNS name space "family tree" This diagram is similar to <a class="xref" href="ch53s02.html#dns_tree-related_and_domain-related_term" title="Figure 53-2. DNS tree-related and domain-related terminology The top of the DNS name space is the root of the tree, and it has no name. Under the root comes any number of top-level domains (TLDs). Within each of these can be placed second-level domains, then within those subdomains, and so forth. Some of the tree terminology used in DNS is also shown here. The portion of the tree with the light shading is one branch; the darker area highlights a smaller subbranch within that branch. The darkest nodes within that area are the leaves of that smaller branch of the tree.">Figure 53-2</a>, but the nodes are labeled to show the family-oriented terminology sometimes used in DNS. In this case, the names are relative to the interior node shown in the darker shade. The domain immediately above it is its parent node. Other nodes on the same level are siblings, and subdomains within it are children of that node.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-312"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The domain above a given domain in the DNS name space is called its <span class="emphasis"><em>parent domain</em></span>. Domains at the same level within the same parent are <span class="emphasis"><em>siblings</em></span>. Subdomains are called <span class="emphasis"><em>children</em></span> of that domain.<a class="indexterm" id="idx-CHP-53-1862"/><a class="indexterm" id="idx-CHP-53-1863"/><a class="indexterm" id="idx-CHP-53-1864"/></p></div><p>Like a real tree, the DNS name structure must be a true tree in its structure. Every domain can have only one parent (except the root), just as every branch of a tree connects to only one limb (except the root/trunk). Also, no loops can appear in the structure; you cannot have a domain whose child is also its parent, for example.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-313"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A DNS name space must be arranged as a true topological tree. This means each domain can have only one parent, and no loops are permitted in the structure.</p></div><p>Keep in mind that even though the name hierarchy represents an arrangement of named devices, it is only a logical structure. There is no necessary correspondence to the physical location of devices. A <a class="indexterm" id="idx-CHP-53-1865"/>domain with 10 children may represent 11 devices in 11 different countries. We'll explore this more when we look at DNS authority structures in the next chapter.</p></div></div>
<div class="sect1" title="DNS Labels, Names, and Syntax Rules"><div class="titlepage"><div><div><h1 class="title"><a id="dns_labels_names_and_syntax_rules"/>DNS Labels, Names, and Syntax Rules</h1></div></div></div><p>We've seen how the DNS name space hierarchy allows us to arrange domains into a virtual tree that reflects the characteristics of how the devices themselves are organized. While using a hierarchical name space is inherently more complex than a flat name space, it yields a powerful result: the ability to specify names that can be locally managed while remaining globally unique. At the same time, the complexity of the tree yields the benefit of relatively simple name construction using domain identifiers.<a class="indexterm" id="idx-CHP-53-1866"/></p><div class="sect2" title="DNS Labels and Label Syntax Rules"><div class="titlepage"><div><div><h2 class="title"><a id="dns_labels_and_label_syntax_rules"/>DNS Labels and Label Syntax Rules</h2></div></div></div><p>Naming <a class="indexterm" id="idx-CHP-53-1867"/>in DNS begins with giving each domain, or node, in the DNS name space a text <span class="emphasis"><em>label</em></span>. The label identifies the domain within the structure and must follow several syntax rules:<a class="indexterm" id="idx-CHP-53-1868"/></p><p><span class="strong"><strong>Length</strong></span> Each label can theoretically be from 0 to 63 characters in length. In practice, a length of 1 to about 20 characters is most common, with a special exception for the label assigned to the root of the tree (which is 0 characters in length, as explained in the next section).</p><p><span class="strong"><strong>Symbols</strong></span> Letters and numbers are allowed, as well as the dash character (-). No other punctuation is permitted. For example, an underscore (_) cannot be used in a label.</p><p><span class="strong"><strong>Case</strong></span> Labels are not case-sensitive. For example, <span class="emphasis"><em>Jabberwocky</em></span> and <span class="emphasis"><em>jabberwocky</em></span> are equivalent domain name labels.</p><p>Every label must be unique within its parent domain. So, for example, if we have a top-level domain called Rocks, we can have only one subdomain within Rocks called Crystal. Due to the case-insensitivity of labels, we cannot have both CRYSTAL and Crystal within Rocks, because they are considered the same.</p><p>It is this concept of <span class="emphasis"><em>local uniqueness</em></span> within a parent domain that ensures the uniqueness of names as a whole, while allowing local control over naming. Whoever is in charge of the Rocks domain can assign names to as many individual objects or subdomains as he likes, as long as those names are unique within the domain. Someone else, say, the maintainer of the Glass domain, can also create a subdomain called Crystal within Glass. There will not be a conflict, because the Glass and Rocks domains are separate. Of course, since all top-level domains have the same parent (the root), all top-level domains must be unique.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-314"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each node in the DNS name space is identified by a label. Each <span class="emphasis"><em>label</em></span> must be unique within a parent domain, but it does not need to be unique across domains. This enables each domain to have local control over the names of subdomains, without causing any conflicts in the full domain names created on a global level.</p></div></div><div class="sect2" title="Domain Name Construction"><div class="titlepage"><div><div><h2 class="title"><a id="domain_name_construction"/>Domain Name Construction</h2></div></div></div><p>Each individual domain within the domain name structure can be uniquely identified using the sequence of <a class="indexterm" id="idx-CHP-53-1869"/>labels that starts from the root of the tree and progresses down to that domain. The labels at each level in the hierarchy are listed in sequence, starting with the highest level, from right to left, separated by dots. The result is the formal definition of a <span class="emphasis"><em>domain name</em></span>.</p><p>The root of the name space is given a zero-length, null name by default; that is, the label for the root exists, but it's empty. This is done because the root technically is part of every domain name, so it must be included in every domain name. If it were something long like Root, we would need to include that at the end of every domain name. This would simply make every name longer, while not really adding any useful information—we already know every domain name is under the root.</p><p>Consider the example of a top-level domain called Rocks, within which is a second-level domain Crystal. The domain name of Rocks is Rocks., with the dot separating Rocks and the empty label (the null root). In practice, the trailing dot is often omitted, so the domain name of the top-level domain Rocks can be considered as just Rocks. The subdomain Crystal within Rocks has the domain name Crystal.Rocks. If we had a device named Salt within the Crystal.Rocks domain, it would be called Salt.Crystal.Rocks. This is fairly straightforward, as you can see in <a class="xref" href="ch53s03.html#dns_labels_and_domain_name_construction_" title="Figure 53-4. DNS labels and domain name construction Each node in the DNS name space has a label (except the root, whose label is null). The domain name for a node is constructed simply by placing in order the sequence of labels from the top of the tree down to the individual domain, going from right to left, separating each label with a dot (period).">Figure 53-4</a>.</p><div class="figure"><a id="dns_labels_and_domain_name_construction_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e55867"/><img alt="DNS labels and domain name construction Each node in the DNS name space has a label (except the root, whose label is null). The domain name for a node is constructed simply by placing in order the sequence of labels from the top of the tree down to the individual domain, going from right to left, separating each label with a dot (period)." src="httpatomoreillycomsourcenostarchimages288161.png.jpg"/></div></div><p class="title">Figure 53-4. DNS labels and domain name construction Each node in the DNS name space has a label (except the root, whose label is null). The domain name for a node is constructed simply by placing in order the sequence of labels from the top of the tree down to the individual domain, going from right to left, separating each label with a dot (period).</p></div><p>We can use these names to easily identify subdomains of a particular domain. For example, if we start with Salt.Crystal.Rocks, it's obvious that Crystal.Rocks is its parent domain. It's also clear that both Crystal.Rocks and Salt.Crystal.Rocks are subdomains of Rocks; one is a single level down from Rocks, and the other is two levels down.<a class="indexterm" id="idx-CHP-53-1870"/></p><p>Note that there is a maximum limit of 255 characters for a complete domain name, for implementation purposes. In practice, most domain names are much shorter than this limit, as it would violate the whole purpose of domain names if we let them get so long that no one could remember them.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-315"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A <span class="emphasis"><em>domain name</em></span> is a string of text that uniquely identifies a particular node in the name space. The domain name for a node is constructed by concatenating in right-to-left order all the labels in the branch of the DNS tree, starting from the top of the tree down to the particular node, separating each by a dot (period).</p></div><p>Finally, note that in many protocols, it is possible to specify a particular resource within a domain name by providing a directory structure after a name. This is done using the standard TCP/IP URL syntax, where a path is indicated using slashes to separate subdirectories. For example, a specific file at Salt.Crystal.Rocks might be located at Salt.Crystal.Rocks/chem/composition. While DNS names are case-insensitive, the labels in a path are case-sensitive. So, this example would be different from Salt.Crystal.Rocks/chem/Composition. See the discussion of URL syntax in <a class="xref" href="ch70.html" title="Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)">Chapter 70</a> for more details.</p></div></div>
<div class="sect1" title="Absolute (Fully Qualified) and Relative (Partially Qualified) Domain Name Specifications"><div class="titlepage"><div><div><h1 class="title"><a id="absolute_fully_qualified_and_relative_pa"/>Absolute (Fully Qualified) and Relative (Partially Qualified) Domain Name Specifications</h1></div></div></div><p>As explained in the previous section, we can specify the domain name of any node in the DNS name hierarchy by simply starting at the root node and following the sequence of subdomains down to the node in question, listing each level's labels separated by a dot. When we do this, we get a single name that uniquely identifies a particular device. In practice, domain names can be specified by their fully qualified names or their partially qualified names.<a class="indexterm" id="idx-CHP-53-1871"/></p><div class="sect2" title="Fully Qualified Domain Names"><div class="titlepage"><div><div><h2 class="title"><a id="fully_qualified_domain_names"/>Fully Qualified Domain Names</h2></div></div></div><p>Technically, if a top-level domain A contains a subdomain B that contains subdomain C, the full domain name for C is C.B.A.. This is called the <span class="emphasis"><em>fully qualified domain name (FQDN)</em></span> for the node. Here, the word <span class="emphasis"><em>qualified</em></span> is synonymous with <span class="emphasis"><em>specified</em></span>. The domain name C.B.A. is fully qualified because it gives the full location of the specific domain that bears its name within the whole DNS name space.<a class="indexterm" id="idx-CHP-53-1872"/></p><p><a class="indexterm" id="idx-CHP-53-1873"/>FQDNs are also sometimes called <span class="emphasis"><em>absolute</em></span> domain names. This term reflects the fact that you can refer unambiguously to the name of any device using its FQDN from any other portion of the name space. Using the FQDN always instructs the person or software interpreting the name to start at the root, and then follow the sequence of domain labels from right to left, going top to bottom within the tree.<a class="indexterm" id="idx-CHP-53-1874"/></p></div><div class="sect2" title="Partially Qualified Domain Names"><div class="titlepage"><div><div><h2 class="title"><a id="partially_qualified_domain_names"/>Partially Qualified Domain Names</h2></div></div></div><p>There are also some situations in which you may refer to a device using an incomplete name specification. This is called a <span class="emphasis"><em>partially qualified domain name (PQDN)</em></span>, which means that the name only partially specifies the location of the device. By definition, a PQDN is ambiguous, because it doesn't give the full path to the domain. Thus, you can use a PQDN only within the context of a particular parent domain, whose absolute domain name is known.</p><p>We can find the FQDN of a partially specified domain name by appending the partial name to the absolute name of the parent domain. For example, if we have the PQDN Z within the context of the FQDN Y.X., we know the FQDN for Z is Z.Y.X.</p><p>Why bother with this? The answer is convenience. An administrator for a domain can use PQDNs as a shorthand to refer to devices or subdomains without needing to repeat the entire full name. For example, suppose you are in charge of the computer science department at the University of Widgetopia. The domain name for the department as a whole is cs.widgetopia.edu., and the individual hosts you manage are named after fruit. In the DNS files you maintain, you could refer to each device by its FQDN every time; for example, apple.cs.widgetopia.edu., banana.cs.widgetopia.edu., and so on. But it's easier to tell the software, "If you see a name that is not fully qualified, assume it is in the cs.widgetopia.edu domain." Then you can just call the machines apple, banana, and so on. Whenever the DNS software sees a PQDN such as kiwi, it will treat it as kiwi.cs.widgetopia.edu.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-316"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> A <span class="emphasis"><em>fully qualified domain name (FQDN)</em></span> is a complete domain name that uniquely identifies a node in the DNS name space by giving the full path of labels from the root of the tree down to that node. It defines the absolute location of a domain. In contrast, a <span class="emphasis"><em>partially qualified domain name (PQDN)</em></span> specifies only a portion of a domain name. It is a relative name that has meaning only within a particular context. The partial name must be interpreted within that context to fully identify the node.</p></div><p>I mentioned earlier in this chapter that the trailing dot for the null root domain is usually omitted. This is true in common parlance and when users specify a domain name in an application. You don't use the trailing dot in your web browser, for instance. However, the dot is used to clearly distinguish a FQDN from a PQDN within DNS master files. This allows us to use both FQDNs and PQDNs together. In our example, apple would refer to apple.cs.widgetopia.edu., but apple.com. would refer to the FQDN for Apple Computer, Inc. You must be careful about watching the dots here, because apple.com (without a trailing period) would be a PQDN and would refer to apple.com.cs.widgetopia.edu., not the domain of Apple Computer.</p></div></div>
<div class="chapter" title="Chapter&#xA0;54.&#xA0;DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_registration_public_administrat"/>Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e55961"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The previous chapter explained how the Domain <a class="indexterm" id="idx-CHP-54-1875"/>Name System (DNS) name space consists of a hierarchy of domains and subdomains. From the root, we have a number of top-level domains, then second-level domains below them, and still lower-level domains below that. The obvious questions then become: How do we determine the shape and structure of the name space, and who will manage it? More specifically, who will control the root of the tree and decide what the top-level domains will be called? How will we then subdivide control over the rest of the name space? How do we ensure there are no conflicts in choosing the names of sibling subdomains within a domain?</p><p>DNS can be used on private networks controlled by a single organization, and if so, that organization is obviously in charge of the name space. We'll discuss private naming, but in reality, it's just not that interesting. The vast majority of DNS use occurs on the public Internet. Here, we have a much greater challenge, because we need to construct a name space that spans the globe and covers millions of machines managed by different organizations. For this, we need a very capable <span class="emphasis"><em>name registration</em></span> process and administration methods to support it.</p><p>In this chapter, I will describe the process of name registration and how authorities are managed within <a class="indexterm" id="idx-CHP-54-1876"/>DNS, focusing on the public Internet. I begin with a description of the DNS hierarchical <a class="indexterm" id="idx-CHP-54-1877"/>authority structure and how it relates to the hierarchical name space, and a discussion of the concepts behind the DNS distributed name database. I describe the Internet's organizational and geopolitical top-level domains, and how they are administered by various authorities. I then discuss how <a class="indexterm" id="idx-CHP-54-1878"/>authority is delegated to the second-level and lower-level domains, and how public registration of domain names works, including how public registration issues and problems are resolved. I explain how the DNS name space is partitioned into administrative zones of authority, and then I conclude with a brief discussion of private DNS name registration.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-317"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>Most TCP/IP implementations include a special utility called whois that can be used to interrogate the DNS distributed name database to obtain registration information about domains. This application can be very useful for troubleshooting. For details, see the section discussing whois in <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a></em></span>.</p></div><div class="sect1" title="DNS Hierarchical Authority Structure and the Distributed Name Database"><div class="titlepage"><div><div><h1 class="title"><a id="dns_hierarchical_authority_structure_and"/>DNS Hierarchical Authority Structure and the Distributed Name Database</h1></div></div></div><p>In the previous chapter, I explained that the central concept of naming in DNS is based on <span class="emphasis"><em>domains</em></span>. Each domain can be considered akin to a sphere of influence or control. A domain "spreads its wings" over all the objects and subdomains that it contains. Due to this concept of influence, when we consider any DNS name space, we see that it is hierarchical because it reflects a hierarchy of organizations that control domains and the nodes within them. This means that there is a <span class="emphasis"><em>hierarchical authority structure</em></span> that complements the hierarchical name structure in DNS.</p><p>The primary reason why the name space hierarchy leads to an authority hierarchy is the requirement that sibling subdomains be unique within a domain. As soon as we have a need for uniqueness, we must have some sort of authority or process that ensures that each subdomain or object picks a different name within that domain. This is what name registration is all about.</p><p>This concept of a hierarchical authority structure is a bit abstract, but it's easier to understand if we examine a sample DNS name space and discuss the issues involved in assigning names within it. Naturally, we want to start at the top of the name hierarchy, with the root domain, null.</p><div class="sect2" title="The DNS Root Domain Central Authority"><div class="titlepage"><div><div><h2 class="title"><a id="the_dns_root_domain_central_authority"/>The DNS Root Domain Central Authority</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1879"/>To start off the name space, we must create top-level domains (TLDs) within the root. Now, each of these must be unique, so one authority must manage the creation of all TLDs. This means that the authority that controls the root domain controls the entire name space.</p><p>In the case of the Internet, this central authority is ultimately responsible for every name in DNS. The central DNS authority for the Internet, which controls the creation of TLDs, was initially called the <a class="indexterm" id="idx-CHP-54-1880"/><span class="emphasis"><em>Network Information Center</em></span>. It was later the <span class="emphasis"><em>Internet Assigned Numbers Authority (IANA)</em></span>, which is also responsible for protocol numbers, IP addresses, and more. These functions are now shared by IANA and the <span class="emphasis"><em>Internet Corporation for Assigned Names and Numbers (ICANN)</em></span>. We'll discuss the specific TLDs of the Internet in the next few chapters; IANA, ICANN, and related organizations are discussed in the section on Internet registration authorities in <a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a>.</p></div><div class="sect2" title="TLD Authorities"><div class="titlepage"><div><div><h2 class="title"><a id="tld_authorities"/>TLD Authorities</h2></div></div></div><p>At the next level down in the authority hierarchy, we create second-level domains within each of the TLDs. Each TLD must itself be managed using a coordinating authority, however, this is not necessarily the organization that runs the root (IANA). IANA <span class="emphasis"><em>delegates</em></span> authority for some of the TLDs to other organizations.</p><p>IANA may delegate control for each TLD to a different authority at this level of the hierarchy. In fact, there can be completely different rules for managing the creation of second-level domains in one TLD than there are in another. And in some TLDs, there are multiple authorities that work together on name registration.</p></div><div class="sect2" title="Lower-Level Authority Delegation"><div class="titlepage"><div><div><h2 class="title"><a id="lower-level_authority_delegation"/>Lower-Level Authority Delegation</h2></div></div></div><p>This process of authority delegation continues as we move down the name space hierarchy. At each level, the name space becomes more specific.</p><p>If we use an organizational hierarchy, like the .COM TLD, we generally delegate authority for each second-level domain to the organization whose name it represents. So, for example, IBM.COM is managed by IBM. Since IBM is huge, it may itself subdivide the authority structure further, but smaller organizations probably won't.</p></div><div class="sect2" title="Authority Hierarchy's Relationship to the Name Hierarchy"><div class="titlepage"><div><div><h2 class="title"><a id="authority_hierarchys_relationship_to_the"/>Authority Hierarchy's Relationship to the Name Hierarchy</h2></div></div></div><p>The authority hierarchy is complementary to the name hierarchy; they are not exactly the same. It is not necessary that there be a different authority for every level of the hierarchy. In many cases, a single authority may manage a section of the name space that spans more than one level of the structure. For example, IANA manages the Internet root domain (null) and also the .INT TLD, but other TLDs are managed by other organizations. The name hierarchy is divided into <span class="emphasis"><em>zones of authority</em></span> that reflect the hierarchy of authorities that manage parts of the name space.</p><p>Also, authority over a domain doesn't necessarily imply physical control. A domain can contain subdomains that are managed by organizations on different continents, and a single subdomain can contain named devices that are on different continents as well.</p></div><div class="sect2" title="The DNS Distributed Name Database"><div class="titlepage"><div><div><h2 class="title"><a id="the_dns_distributed_name_database"/>The DNS Distributed Name Database</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1881"/><a class="indexterm" id="idx-CHP-54-1882"/>Of course, with authority comes responsibility, and the main responsibility an authority has for a domain is registering names within the domain. When a name is registered, a set of data is created for it, which can then be used by internetwork devices to resolve the name into an address or perform other functions.</p><p>The set of all the data describing all DNS domains constitutes the DNS <span class="emphasis"><em>name database</em></span>. Just as registration authority is distributed and hierarchical, this database is distributed and hierarchical. In other words, there is no single place where all DNS name information is stored. Instead, DNS servers carry resource records (see <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a>) that describe the domains for which they have authority. As you'll see, the fact that this database is distributed has major implications on how name resolution is carried out.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-318"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The name space of the public Internet is managed by a <span class="emphasis"><em>hierarchy of authorities</em></span> that is similar in structure to the hierarchical DNS name space, though not identical. The top of the hierarchy is centrally managed by IANA/ICANN, which delegates authority to other organizations for registering names in various other parts of the hierarchy. The information about name registrations is maintained in resource records stored in various locations, which form a distributed name database on the Internet.</p></div></div></div></div>
<div class="sect1" title="DNS Organizational (Generic) TLDs and Authorities"><div class="titlepage"><div><div><h1 class="title"><a id="dns_organizational_generic_tlds_and_auth"/>DNS Organizational (Generic) TLDs and Authorities</h1></div></div></div><p><a class="indexterm" id="idx-CHP-54-1883"/>The top of the DNS name hierarchy is managed by a central authority, which controls the entire name space by virtue of deciding which TLDs are allowed to exist. Obviously, it is very important that a great deal of thought go into how the TLDs are chosen. A poor design at this top level would make the entire hierarchy poorly reflect the actual structure of organizations using the name space.</p><p>The creators of DNS could have chosen any number of ways to structure the Internet's name hierarchy. One obvious possibility is to structure the Internet based on geopolitical boundaries: countries, states, and so forth. Another sensible idea is to structure the name space based on types of organizations.</p><p>The beauty of the hierarchical name space is that we don't need to choose between different methods of structuring the name space. We can use more than one technique at the same time, and this is exactly what was done when DNS was first implemented. Both the organization type and geography structures were used for TLDs. This gives multiple options for name registration for most groups and individuals.</p><p>I'll begin here by discussing <a class="indexterm" id="idx-CHP-54-1884"/>organizational TLDs, and then we'll look at geopolitical ones. As you'll see, although there are only a handful of organizational TLDs, there is no doubt that they have been much more popular than the geopolitical ones.</p><div class="sect2" title="Original Generic TLDs"><div class="titlepage"><div><div><h2 class="title"><a id="original_generic_tlds"/>Original Generic TLDs</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1885"/>The initial deployment of DNS featured a set of seven top-level domains that are called <span class="emphasis"><em>generic</em></span> TLDs. The idea was that each company or organization could choose a name within one of these TLDs; they were generic enough that every organization would find a place that suited them. I prefer to call them <span class="emphasis"><em>organizational</em></span>, because they divide the generic portion of the name space by organization type.</p><p>The initial TLDs and their original intended organization types were as follows:</p><p><span class="strong"><strong>.ARPA</strong></span> A temporary domain used many years ago for transition to DNS; today, this domain is used for reverse name resolution (see <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>).</p><p><span class="strong"><strong>.COM</strong></span> Corporations and businesses</p><p><span class="strong"><strong>.EDU</strong></span> Universities and other educational organizations</p><p><span class="strong"><strong>.GOV</strong></span> Government agencies</p><p><span class="strong"><strong>.MIL</strong></span> Military organizations</p><p><span class="strong"><strong>.NET</strong></span> Organizations that implement, deal with, or manage networking technologies and/or the Internet</p><p><span class="strong"><strong>.ORG</strong></span> Other organizations that don't fit into any of the previous classifications</p><p>At first glance, this seems like a reasonable way to cover the organizations of the world. However, since the .ARPA domain (whose name refers to the ARPAnet, the precursor of the modern Internet, as described in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>) was temporary, this left only six categories for all other organizations. Also, the TLDs weren't all used as was originally foreseen. For example, the .GOV and .MIL domains were not used for all types of government and military organizations, but primarily for the United States federal government and military. The .EDU domain ended up being used only for universities, again in the United States.</p><p>This left only three common TLDs—.COM, .NET, and .ORG—for almost all other groups and companies that wanted to use the organizational hierarchy. Since there were only three such TLDs, they quickly became very crowded, especially the .COM domain. A new fourth domain, .INT for international organizations, was added fairly soon to the original seven. However, it was intended only for a small number of organizations, such as international standards bodies.</p><p>Of course, there was no inherent reason why the generic domains should be limited to only the few that were originally created.</p></div><div class="sect2" title="New Generic TLDs"><div class="titlepage"><div><div><h2 class="title"><a id="new_generic_tlds"/>New Generic TLDs</h2></div></div></div><p>Over the years, many suggestions were made for new generic TLDs that would expand the number of possible second-level domain names and also provide better categorization for different organization types—that is, to make the generic TLDs less generic. There was some resistance at first to adopting these new names, especially because there were so many different ideas about what new TLDs should be created.</p><p>IANA took input from a lot of people and followed a complex procedure to determine what new TLDs should be made. In 2001 and 2002, approval was given for the creation of several new TLDs, and decisions were made about authorities for administering them.</p><p>Of the new TLDs approved in the past few years, the number that has achieved widespread popularity is, to my knowledge, zero. Humans are creatures of inertia, and most people are still used to names ending in <a class="indexterm" id="idx-CHP-54-1886"/>.COM, .NET, or .ORG. In time this may change, but it will probably take a few years.</p><div class="note" title="Note"><h3 class="title"><a id="note-133"/>Note</h3><p><span class="emphasis"><em>Some people actually felt that adding new generic TLDs was a bad idea, since it makes organizations potentially more difficult to locate (due to the possibility of a name ending in a variety of different TLDs). This is debatable, however, especially since the exhaustion of address space in the existing TLDs means many companies have needed to choose unintuitive domain names anyway</em></span><a class="indexterm" id="idx-CHP-54-1887"/>.</p></div><p><a class="xref" href="ch54s02.html#internet_dns_organizational_generic_top_" title="Table 54-1. Internet DNS Organizational (Generic) Top-Level Domains">Table 54-1</a> shows all the current <a class="indexterm" id="idx-CHP-54-1888"/>generic TLDs and describes how they are used, and it lists the current central authority that manages each. The original TLDs are highlighted in italics (I am including .INT as an original TLD, since it was created long before the "new" ones). <a class="xref" href="ch54s02.html#internet_dns_organizational_generic_tlds" title="Figure 54-1. Internet DNS organizational (generic) TLDs There are 15 generic TLDs currently defined for the Internet. They are shown here in alphabetical order, with the original TLDs shown in light shading and the new ones added in 2001/2002 in darker shading.">Figure 54-1</a> shows the 15 <a class="indexterm" id="idx-CHP-54-1889"/>generic TLDs in graphical form.</p><div class="figure"><a id="internet_dns_organizational_generic_tlds"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e56215"/><img alt="Internet DNS organizational (generic) TLDs There are 15 generic TLDs currently defined for the Internet. They are shown here in alphabetical order, with the original TLDs shown in light shading and the new ones added in 2001/2002 in darker shading." src="httpatomoreillycomsourcenostarchimages288163.png.jpg"/></div></div><p class="title">Figure 54-1. Internet DNS organizational (generic) TLDs There are 15 generic TLDs currently defined for the Internet. They are shown here in alphabetical order, with the original TLDs shown in light shading and the new ones added in 2001/2002 in darker shading.</p></div><div class="table"><a id="internet_dns_organizational_generic_top_"/><p class="title">Table 54-1. Internet DNS Organizational (Generic) Top-Level Domains</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Internet DNS Organizational (Generic) Top-Level Domains"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1890"/><a class="indexterm" id="idx-CHP-54-1891"/>Generic TLD</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Abbreviation For</p></th><th style="border-bottom: 0.5pt solid ; "><p>Authority</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>.AERO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Aerospace</p></td><td style="border-bottom: 0.5pt solid ; "><p>Société Internationale de Télécommunications Aéronautiques (SITA)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used for members of the aerospace industry, such as airlines and airports. (Yes, that is French!)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>.ARPA</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Address and Routing Parameter Area</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IANA/ ICANN</p></td><td style="border-bottom: 0.5pt solid ; "><p>First defined as a temporary domain for migration from the older host table system, the <span class="emphasis"><em>ARPA</em></span> of course originally stood for the Advanced Research Projects Agency, creators of the predecessors of the Internet. Today, the .ARPA domain is used for internal Internet management purposes; the expanded name shown in this table was, I believe, chosen to fit the acronym. The best-known use of this domain is for reverse DNS lookups.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>.BIZ</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Business</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NeuLevel, Inc.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used for businesses. Intended as a competitor to .COM.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>.COM</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Commercial Organizations</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>VeriSign, Inc.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Originally intended for corporations and other commercial interests, .COM is also widely used for other purposes, including small businesses and even individuals who like the popularity of the .COM domain.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1892"/>.COOP</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Cooperative Associations</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Dot Cooperation, LLC</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used for cooperative associations.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1893"/><span class="emphasis"><em>.EDU</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Education</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Educause</p></td><td style="border-bottom: 0.5pt solid ; "><p>Originally intended for all types of educational organizations, .EDU is now used only for degree-granting higher-education institutions accredited in the US. Other educational institutions such as public schools usually use the country code TLDs.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1894"/><span class="emphasis"><em>.GOV</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Government</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>U.S. General Services Administration</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved for the U.S. federal government.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1895"/>.INFO</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Information</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Afilias, Ltd.</p></td><td style="border-bottom: 0.5pt solid ; "><p>A very generic TLD designed for information resources of various sorts. It is unrestricted, in that anyone can register any sort of organization in .INFO. It's also positioned as an alternative to .COM.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1896"/><span class="emphasis"><em>.INT</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>International</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IANA .int Domain Registry</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used only for large organizations established by international treaty.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1897"/><span class="emphasis"><em>.MIL</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Military</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>U.S. DoD Network Information Center</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved for the U.S. military.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1898"/>.MUSEUM</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Museum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Museum Domain Management Association</p></td><td style="border-bottom: 0.5pt solid ; "><p>Take a guess. See http://index.museum for a complete list of museums using this TLD.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1899"/>.NAME</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Names</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Global Name Registry</p></td><td style="border-bottom: 0.5pt solid ; "><p>In the original generic hierarchy, there was no place set aside for individuals to register names for themselves, so people would create domains like <a class="indexterm" id="idx-CHP-54-1900"/>jonesfamily.org. This was not ideal, so .NAME was created as a place for individuals and families to register a domain for their names. .NAME also competes with the country code TLDs.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1901"/><span class="emphasis"><em>.NET</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Network</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>VeriSign, Inc.</p></td><td style="border-bottom: 0.5pt solid ; "><p>This was supposed to be used only for Internet service providers (ISPs) and other organizations working intimately with the Internet or networking. Due to the exhaustion of name spaces in .COM and .ORG, many .NET domains are registered to other organizations, however.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>.ORG</em></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Organizations</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Public Interest Registry</p></td><td style="border-bottom: 0.5pt solid ; "><p>Originally intended for organizations not fitting into the other generic TLDs, .ORG quickly became associated with professional and nonprofit organizations. It is possible, however, to have a for-profit company use an .ORG name.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-54-1902"/>.PRO</p></td><td style="border-right: 0.5pt solid ; "><p>Professional</p></td><td style="border-right: 0.5pt solid ; "><p>RegistryPro</p></td><td style=""><p>Reserved for credentialed professionals such as lawyers and doctors.</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-319"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One of the two ways in which the Internet's DNS name space is divided is using a set of generic TLDs. These TLDs are intended to provide a place for all companies and organizations to be named based on their organization type. There were originally six such domains, but this has been expanded so that there are now 15.</p></div></div></div>
<div class="sect1" title="DNS Geopolitical (Country Code) TLDs and Authorities"><div class="titlepage"><div><div><h1 class="title"><a id="dns_geopolitical_country_code_tlds_and_a"/>DNS Geopolitical (Country Code) TLDs and Authorities</h1></div></div></div><p>In theory, the generic TLDs would be sufficient to meet the needs of all the individuals, companies, and groups in the world. This is especially true since .ORG, by definition, is a catchall that can include anyone or anything. Thus, in an ideal world, everyone in the world would have been able to find a place in those simple domains.</p><p>However, back at the beginning of DNS, its creators recognized that the generic TLDs might not meet the needs of everyone around the world, especially in certain cases. There are several reasons for this:</p><p><span class="strong"><strong>Americentricism of the Generic Domains</strong></span> I don't mean this as a criticism (I'm an American citizen and love my country!). It is indisputable, however, that United States organizations and companies dominate the generic TLDs. This is not surprising, given that the Internet was first developed in the United States, but it still presents a problem for certain groups. For example, if the United States military controls the .MIL domain, where does, say, Great Britain's military fit into the name space?</p><p><span class="strong"><strong>Language</strong></span> Most of the generic domains are populated by organizations that primarily do business in English. There are hundreds of languages in the world, however, and it's easier for the speakers of those tongues if they can more readily locate resources they can understand.</p><p><span class="strong"><strong>Local Control</strong></span> Countries around the world rarely agree on much, and they certainly differ on how organizations within their nations should have their Internet presence arranged. There was a desire on the parts of many to allow nations to have the ability to set up subsets of the name space for their own use.</p><p>For these and other reasons, the Internet's name space was set up with a set of <a class="indexterm" id="idx-CHP-54-1903"/><span class="emphasis"><em>country code</em></span> TLDs paralleling the generic ones, sometimes called <a class="indexterm" id="idx-CHP-54-1904"/><span class="emphasis"><em>ccTLDs</em></span>. I call these <a class="indexterm" id="idx-CHP-54-1905"/><span class="emphasis"><em>geopolitical</em></span> TLDs, since they are based on geopolitical divisions of the world (similar to the example I used in the overview of the DNS name space in <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>). In this hierarchy, every country of the world is assigned a particular two-letter code as a TLD, with a specific authority put in charge of administering the domain. For example, the ccTLD for Great Britain is .UK, the one for Canada is .CA, and the one for Japan is .JP. The codes often are more meaningful in the local language than in English. For example, Germany's is .DE, and Switzerland's is .CH.</p><div class="sect2" title="Country Code Designations"><div class="titlepage"><div><div><h2 class="title"><a id="country_code_designations"/>Country Code Designations</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1906"/>When I said that countries rarely agree on anything, I wasn't kidding. In fact, they can't even agree on what's a country! Real shooting wars have been fought over whether or not a particular territory was independent or part of another nation, and the creators of DNS wanted no part of this sort of controversy. As the IANA website says, "The IANA is not in the business of deciding what is and what is not a country, nor what code letters are appropriate for a particular country."</p><p>To remain neutral, IANA's ccTLD codes are taken directly from the standard country abbreviations maintained by the International Organization for Standardization (ISO) in <a class="indexterm" id="idx-CHP-54-1907"/>ISO Standard 3166-1. When a country is recognized by the ISO and a code assigned to it on this list, IANA creates it as a TLD. There are presently more than 200 different geopolitical TLDs. You can find the current list of IANA country code TLDs at <a class="ulink" href="http://www.iana.org/cctld/cctld-whois.htm">http://www.iana.org/cctld/cctld-whois.htm</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-320"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Due to the limitations of the generic TLDs, a set of <span class="emphasis"><em>country</em></span> code top-level domains was created. This <span class="emphasis"><em>geopolitical hierarchy</em></span> allows each nation on earth to set up its own name system based on its own requirements and to administer it in the manner it sees fit. The IANA determines what is a country based on official decisions made by ISO.</p></div></div><div class="sect2" title="Country Code TLD Authorities"><div class="titlepage"><div><div><h2 class="title"><a id="country_code_tld_authorities"/>Country Code TLD Authorities</h2></div></div></div><p>Each country has the authority to set up its TLD with whatever internal substructure it chooses; again, this is the power of a hierarchical structure.</p><p>Some countries enforce a further geographical substructure at the lower levels. For example, the .US domain for the United States was originally set up so that all second-level domains were two-letter state abbreviations (this was later changed).</p><p>Other countries may actually use organizational subdomains within their country code. For example, Great Britain has .CO.UK for companies in the country (like .COM but for the UK only; they left off the <span class="emphasis"><em>M</em></span>), and .COM.AU is for corporations in Australia.</p><p>Other countries may not have any particular substructure at all, especially if they are small.</p></div><div class="sect2" title="Leasing/Sale of Country Code Domains"><div class="titlepage"><div><div><h2 class="title"><a id="leasingsale_of_country_code_domains"/>Leasing/Sale of Country Code Domains</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1908"/>Interestingly, some very small countries with recognizable country codes, especially to English speakers, have used their codes for very creative purposes, including selling or renting the name space to enterprising companies.</p><p>A good example is the <a class="indexterm" id="idx-CHP-54-1909"/>.TV domain, which technically belongs to the island nation of <span class="emphasis"><em>Tuvalu</em></span>. Of course, to most people, "TV" means something quite different. Some folks thought that domain names ending in .TV might be popular in the English-speaking world, so they formed a company called The .TV Corporation and negotiated with the government of Tuvalu to use the .TV domain. Today, the authority for this TLD is this corporation, headquartered in California! Similar arrangements can be found with the <a class="indexterm" id="idx-CHP-54-1910"/>.CC, <a class="indexterm" id="idx-CHP-54-1911"/>.NU, <a class="indexterm" id="idx-CHP-54-1912"/>.TO, and other TLDs.</p><p>This serves as a good reminder that the name space is logical and not physical. Obviously, the many computers with .TV names are not actually located on a remote island in the South Pacific. Similarly, if a website ends with .CA, for example, it probably represents a Canadian organization, but that doesn't necessarily mean the website itself is actually hosted in Canada.</p></div><div class="sect2" title="Drawbacks of the Geopolitical TLDs"><div class="titlepage"><div><div><h2 class="title"><a id="drawbacks_of_the_geopolitical_tlds"/>Drawbacks of the Geopolitical TLDs</h2></div></div></div><p>The geopolitical domains have been very popular for certain uses. National governments and other official institutions like to use them, for obvious reasons. Typing www.gov.<span class="emphasis"><em>xx</em></span> or www.government.<span class="emphasis"><em>xx</em></span>, where <span class="emphasis"><em>xx</em></span> is a country code is likely to bring you to the national government website of most countries. Some companies and organizations use the ccTLDs because they allow them to choose a name already taken in the generic hierarchies or simply to express national pride.</p><p>For many other companies and organizations, however, the generic TLDs have been much more popular than the country codes. I think the most important reason for this is that organizations are easier to locate using the generic domains.</p><p>Here's a good example of what I mean. In the town near where I live, a new grocery store called Aldi recently opened. I like the store and wanted to learn more about it, so I fired up my web browser and sought out its website. Yes, I could have typed it into a search engine, but like most people, I'm lazy. It was much easier to just enter www.aldi.com into my browser, and lo and behold, up popped the website of Aldi International.</p><p>Now, Aldi is actually headquartered in Germany, and the company does have a website at www.aldi.de as well. But I didn't know that. I found them easily by going to www.aldi.com, because I didn't need to know their physical location, and because I know that most large companies have a .COM domain. Of course, being findable is very important, especially for commercial organizations trying to do business.</p><p>Another good example is the United States, which has its own country code, .US, in addition to dominating the generic TLDs. The authority in charge of this domain initially chose to make it follow a strict geographical hierarchy, so every domain had to be of the form <span class="emphasis"><em>organization.city.state-code</em></span>.us. So, to use this part of the name space, a company in Boston must be within the .boston.ma.us domain. That's very neat and logical, but it makes names both longer and harder to guess than the generic equivalents.</p><p>Suppose you wanted to get information on metals giant Alcoa. If you're in the industry, you might know Alcoa is located in Pittsburgh, but if not, which is easier to find: www.alcoa.pittsburgh.pa.us or www.alcoa.com? Anyone here know how to spell Albuquerque?</p><p>It is for this reason that the .US domain achieved success in certain segments of society but not in others, especially commercial entities (corporations). The strict hierarchy does have some real advantages, such as avoiding name space conflicts, but its disadvantages were such that the rules were recently relaxed in the .US domain.</p></div></div>
<div class="sect1" title="Public Registration for Second-Level and Lower Domains"><div class="titlepage"><div><div><h1 class="title"><a id="public_registration_for_second-level_and"/>Public Registration for Second-Level and Lower Domains</h1></div></div></div><p><a class="indexterm" id="idx-CHP-54-1913"/>The IANA is in charge of deciding which TLDs exist in the Internet name space, and as such, they are ultimately responsible for all names in the Internet. The entire point of the authority hierarchy, however, is that IANA should not be responsible for the whole name space. So, while IANA maintains control over certain TLDs, such as .INT and .ARPA, control for managing the others is delegated to secondary authorities for each TLD.</p><p>Just as IANA had the choice <a class="indexterm" id="idx-CHP-54-1914"/>of how to delegate authority to the subdomains of the root domain, the organization in charge of each TLD gets to make the same decision about how second-level domains are to be created under the TLD.</p><p>In many TLDs, especially the generic ones, second-level domains are assigned directly to individuals or organizations. For example, a company named XYZ Industries might want to get the domain xyzindustries.com.</p><p>In other TLDs, second-level domains are set up in a particular structure, like the state codes used in the .US domain. There, you need to go down more levels, but eventually you get to the point where companies and people register their own domains. For example, in the .US domain, XYZ Industries might want to register xyz.phoenix.az.us if it were headquartered in Phoenix.</p><p>This transition point between the <a class="indexterm" id="idx-CHP-54-1915"/>authorities granted responsibility for parts of the name space and the regular people and groups who want to get names is important. A process of <span class="emphasis"><em>public registration</em></span> had to be established to allow such name assignment to occur in a consistent and manageable way. This was not that difficult to accomplish back when the original generic TLDs and country code TLDs were first created. The Internet was quite small, and it made sense to just have the authority in charge of each TLD perform registrations within that TLD. This ensured that there was no duplication of names within a TLD with a minimum of fuss.</p><div class="sect2" title="Registration Authority"><div class="titlepage"><div><div><h2 class="title"><a id="registration_authority"/>Registration Authority</h2></div></div></div><p>For very important generic TLDs such as .COM, .NET, and .ORG, the authority in charge of registration was the Internet Network Information Center (the InterNIC). The InterNIC was set up as a service administered by the United States government, who later granted the contract to manage it to Network Solutions Inc. (NSI). NSI was eventually purchased by VeriSign, who later spun it off as a separate venture. (Things change quickly in the networking world!)</p><p>NSI single-handedly performed all registrations within the .COM, .NET, and .ORG TLDs for many years. The popularity of the original generic TLDs, however, led to an explosion in demand for name registration in these domains in the 1990s. Having a single company in charge of registration led to this becoming another bottleneck in the Internet's Domain Name System. There were also many folks who didn't like the lack of accountability and competition that came with having a single monopoly in charge of registration. The InterNIC could set its own price and originally charged $35 per year per domain name, then later $50 per year.</p><p>In the late 1990s, responsibility for name registration was given to ICANN. The registration process was <span class="emphasis"><em>deregulated</em></span>, to borrow a term referring to removal of monopolies from industries like power generation. As of December 1999, there was still a single authority with overall responsibility for each TLD, including .COM, .NET, and .ORG.</p><p>Today, NSI is still the authority running .COM and .NET. However, it isn't the only organization that registers names within these TLDs. It further delegates registration authority to a multitude of other companies, called <a class="indexterm" id="idx-CHP-54-1916"/><span class="emphasis"><em>accredited registrars</em></span>. Any registrar can register names within the TLD(s) for which they are accredited.</p></div><div class="sect2" title="Registration Coordination"><div class="titlepage"><div><div><h2 class="title"><a id="registration_coordination"/>Registration Coordination</h2></div></div></div><p>Naturally, <a class="indexterm" id="idx-CHP-54-1917"/>coordination becomes much more of a concern when you have multiple companies registering names in a TLD. A special set of technical and administrative procedures is followed to ensure that there are no problems, such as two registrars trying to grab a name at the same time.</p><p>The system has worked well, and those who wish to use TLDs where competition exists now can choose from a variety of registering companies. The most noticeable result of this was also the most predictable one: the cost of registering a domain name in the deregulated generic TLDs is usually much lower than the fees originally charged by the InterNIC.</p><p>Once a company, individual, or organization has a registered lower-level domain, he/she/it becomes the authority for that domain. Use of the domain then becomes private, but depending on how the domain is used, further public name registration may be required. See the discussion of private registration, near the end of this chapter, for more information.</p></div></div>
<div class="sect1" title="DNS Public Registration Disputes and Dispute Resolution"><div class="titlepage"><div><div><h1 class="title"><a id="dns_public_registration_disputes_and_dis"/>DNS Public Registration Disputes and Dispute Resolution</h1></div></div></div><p><a class="indexterm" id="idx-CHP-54-1918"/>The Internet started off as a medium for research into networking, evolved into a system for interconnecting scientists, and ended up as a global communications tool used by just about everyone. As part of this evolution, the Internet also became a very important part of how business is done in the world. Money started to come into the Internet picture in the early 1990s, and just a few short years later, its impact on the Internet was so significant that the growth of the stock market to dizzying heights in the late 1990s is now often called "the Internet bubble."</p><div class="sect2" title="Public Registration Disputes"><div class="titlepage"><div><div><h2 class="title"><a id="public_registration_disputes"/>Public Registration Disputes</h2></div></div></div><p>Unfortunately, the increasing importance of the Internet to commercial interests crashed headlong into the noncommercial original design of Internet technology, and nowhere was this more evident than in DNS. Since there were only a few generic TLDs, each name within a TLD had to be unique, and humans are often confrontational creatures, it didn't take long before arguments broke out over who should be able to use what name and why. And, of course, from there, it didn't take long before lawsuits and other unpleasantries were common.</p><p>There are a surprising number of significant problems associated with public registration of domain names:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-54-1919"/>Corporate Name <a class="indexterm" id="idx-CHP-54-1920"/>Conflicts</strong></span> The .COM domain is for corporations, but many corporations have the same name. The ACME Furniture Company, the ACME Restaurant Supply Corporation, and ACME Footwear, Inc., probably all would like to have the acme.com domain. But there can be only one such domain within .COM. (These are fictional examples; acme.com is actually owned by an organization called <span class="emphasis"><em>Acme Labs</em></span>.)</p><p><span class="strong"><strong>Corporate/Individual/Small <a class="indexterm" id="idx-CHP-54-1921"/>Business Name Conflicts</strong></span> There are many corporations that have names similar to or even identical to the names of individuals, leading to potential <a class="indexterm" id="idx-CHP-54-1922"/>conflicts. For example, suppose your first name is Wendy and you own a small fabric store called Wendy's Fabrics. But you are Internet savvy and decide you want to register wendys.com as soon as you hear about the Internet in 1993. Then this big hamburger chain comes along and has a problem with that.</p><div class="note" title="Note"><h3 class="title"><a id="note-134"/>Note</h3><p><span class="emphasis"><em>To my knowledge, no such issue arose with respect to Wendy's, but there actually was a widely publicized case that shows just how recently most corporations were out of the loop with respect to domain naming. In 1994, a writer for Wired magazine was astonished to find that the mcdonalds.com domain name was unregistered! To show just how unregulated the registration process was, he registered it himself, and caused a bit of a stir as a result. The Golden Arches folks eventually acquired the domain from him in an amicable arrangement, where he relinquished the name and they made a donation to charity</em></span>.</p></div><p><span class="strong"><strong>Corporate Warfare</strong></span> A particularly ugly type of conflict is when companies intentionally try to take business from each other by registering names that have nothing to do with their own companies. An example would be if Burger King had tried to register mcdonalds.com and use it to advertise Burger King products. (Which they didn't do, I might add, so please nobody sue me!) Another example is when companies try to use alternate TLDs, such as registering burgerking.org to confuse people trying to find burgerking.com. In fact, many companies have taken the step of registering their names in many different TLDs to prevent this sort of thing from happening.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-54-1923"/>Cybersquatting</strong></span> Some ambitious (to choose a nice term) individuals, recognizing early on the potential value of certain names, registered large volumes of names with the hopes of reselling them. Many people condemned this as exploitative, and the term <span class="emphasis"><em>cybersquatting</em></span> was created to refer to this type of activity. Unfortunately, a lot of money was made this way, and there are many domain names that, to this day, cannot be used because they have been reserved indefinitely by people or individuals who will never use them.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-54-1924"/>Deceptive Naming Practices</strong></span> Another type of somewhat diabolic creativity has been displayed by people who seek to take advantage of the inability of some of us to spell. For example, if you were a competitor of a large company called Superb Transceivers Inc., which registered superbtransceivers.com, you might register superbtranscievers.com and redirect traffic from there to your own domain. Another example takes advantage of the common mix-up between the letter <span class="emphasis"><em>O</em></span> and 0 (zero). For example, a software company once registered micros0ft.com, much to the chagrin of the Redmond, Washington software giant.</p><p>Incidentally, it was all this nonsense that led, in part, to the clamor for new generic TLDs. Even though the more complicated schemes used by TLDs like .US are not very popular, they have a huge advantage over the generic domains. Since all these registrations are geographic, there are far fewer conflicts. For example, the ACME Furniture Company might use acme.seattle.wa.us, the ACME Restaurant Supply Corporation might have acme.mendocino.ca.us, and ACME Footwear, Inc., could go with acme.anchorage.ak.us. A dispute would arise only when organizations have the same name and also are in the same state and town. You could still have three Joe's Pizza Parlors in Chicago duke it out, but it's not likely to be a problem for big companies.</p></div><div class="sect2" title="Methods of Registration Dispute Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="methods_of_registration_dispute_resoluti"/>Methods of Registration Dispute Resolution</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1925"/>So, how do we resolve these situations? As the saying goes, it can be done either the easy way or the hard way. Here are some methods that have been used for <a class="indexterm" id="idx-CHP-54-1926"/>dispute resolution:</p><p><span class="strong"><strong>Domain Name Sharing</strong></span> Sometimes, the antagonists agree on a productive solution. One particularly constructive idea is to agree to <span class="emphasis"><em>share</em></span> the domain name. For example, the three different ACME companies could each create their own more specifically named domains, such as acmefurniture.com, acmerestaurantsupply.com, and acmefootwear.com. Then they might agree to have the www.acme.com registered to nobody, by having one company register it and not use it for anything. Even better, they could set it up with a simple web page that says the domain is shared, with a link to the three sites. Unfortunately, it seems grade school children understand the concept of sharing better than most corporate executives do, so this type of resolution is rare.</p><p><span class="strong"><strong>Domain Name Purchase</strong></span> Another option is purchase. If a big company wants a domain name already registered by an individual or a small business, it will often just purchase the name, as this is the easiest thing to do. During the height of the Internet mania, there were domain names that sold for <span class="emphasis"><em>millions</em></span> of dollars—just for the right to use the name! Many cybersquatters and other speculators got rich selling names.</p><p><span class="strong"><strong>Litigation</strong></span> Often, the combatants don't play nice, and the usual occurs: threats, intimidation, lawsuits, and so forth. Sometimes, a letter from a lawyer is enough to resolve the issue, especially when some poor individual owning a website gets threatened with legal action by a large company—this has happened many times. However, often the disagreeing parties stick to their guns, especially if two companies lock horns and their lawyers refused to back down. Usually, the matter then ends up in the courts, where it is eventually resolved one way or the other. Usually, claims of trademark infringement would be used by a company challenging a prior domain name registration.</p></div><div class="sect2" title="The Uniform Domain Name Dispute Resolution Policy"><div class="titlepage"><div><div><h2 class="title"><a id="the_uniform_domain_name_dispute_resoluti"/>The Uniform Domain Name Dispute Resolution Policy</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1927"/>Lawsuits are expensive and time-consuming, so there was a desire that some other mechanism exist for resolving these <a class="indexterm" id="idx-CHP-54-1928"/>conflicts as well. Since the authority for each TLD controls what happens within it, it also has the right to create its own policies for how to deal with these sorts of issues. For the generic TLDs, the original registering authority, the <a class="indexterm" id="idx-CHP-54-1929"/>InterNIC, had a dispute resolution policy that allowed people with a complaint to challenge a domain name registration if they had a trademark interest in that name. The policy was controversial for a number of reasons, not the least of which because it led to some domain names being successfully challenged, even if there was no proof of trademark infringement.</p><p>The current authority for the generic TLDs, IANA/ICANN, created a new Uniform Domain Name Dispute Resolution Policy (<a class="indexterm" id="idx-CHP-54-1930"/>UDRP) in 1999, to better handle domain name conflicts. This policy specifies a procedure whereby a company that has a valid trademark can challenge a domain name if it infringes on the trademark, is confusingly similar to it, or was registered by someone else in bad faith. At the same time, it also lists ways that the original registrant can prove that the registration is valid and should be maintained. This new system eliminates many of the problems associated with public registration of domain names—such as deceptive naming, corporate warfare, and cybersquatting—while not automatically allowing a second-comer to shut down a legitimate domain.</p></div></div>
<div class="sect1" title="DNS Name Space Administrative Hierarchy Partitioning: DNS Zones of Authority"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_space_administrative_hierarchy_"/>DNS Name Space Administrative Hierarchy Partitioning: DNS Zones of Authority</h1></div></div></div><p>I explained earlier in this chapter that the DNS name space is arranged in a hierarchy and that there is also a hierarchy of authorities that is related to that hierarchical name structure. However, the two hierarchies are not exactly the same. If they were the same, we would need a separate authority for every domain at every level of the tree, and that's something we are very unlikely to want to have everywhere in the structure.</p><p>At the very top levels of the DNS tree, it seems reasonable that we might want to designate a separate authority at each level of the structure. Consider the geopolitical name hierarchy; IANA/ICANN manages the root domain, but each of the ccTLDs is managed by a distinct national authority.</p><p>However, when we get to the lower levels of the structure, it is often inconvenient or downright impossible to have each level correspond to a separate authority. As an example, let's suppose you are in charge of the Googleplex University IT department, which runs its own DNS servers for the googleplex.edu domain. Suppose there were only two schools at this university, teaching fine arts and computer science. Suppose also that the name space for the computers were divided into three subdomains: finearts.googleplex.edu, compsci.googleplex.edu, and admin.googleplex.edu (for central administrative functions, including the IT department itself).</p><p>Most likely, you don't want or need the Fine Arts department running its own DNS servers. The same is likely true of the administration machines. However, it's possible that the Computer Science department does want to run its own DNS servers, because this department probably has many more computers than the other departments, and the staff might use running a DNS server as part of the curriculum.</p><p>In this case, you might want yourself, the administrator for googleplex.edu, to maintain authority for the finearts.googleplex.edu and admin.googleplex.edu subdomains and everything within them, while delegating authority for compsci. googleplex.edu to whomever in the Computer Science department is designated for the task. DNS is specifically designed to allow these divisions between the name hierarchy and the authority structure to be created.</p><div class="sect2" title="Methods of Dividing a Name Space into Zones of Authority"><div class="titlepage"><div><div><h2 class="title"><a id="methods_of_dividing_a_name_space_into_zo"/>Methods of Dividing a Name Space into Zones of Authority</h2></div></div></div><p>The complete DNS name structure is divided by making <span class="emphasis"><em>cuts</em></span> (as RFC 1034 calls them) between adjacent nodes to create groups of contiguous nodes in the structure. Each group is called a <span class="emphasis"><em>zone of authority</em></span><a class="indexterm" id="idx-CHP-54-1931"/>, or more commonly, just a <span class="emphasis"><em>zone</em></span>. Each zone is usually identified by the domain name of the highest-level node in the zone; that is, the one closest to the root. The zones in DNS are by definition <span class="emphasis"><em>non-overlapping</em></span>—every domain or subdomain is in exactly one zone. The division of the name space into zones can be made in an arbitrary way. At one extreme, we could place a cut between every node, and thereby divide the entire name space so each domain (and subdomain, and so on) was a separate zone. If we did this, the name hierarchy and authority hierarchy would indeed be the same for the entire DNS tree. At the other end of the scale, we could use no cuts at all, defining a single zone encompassing the entire DNS structure. This would mean the root was the authority for the entire tree.</p><p>Of course in practice, neither of these methods is particularly useful, as neither reflects how the real-world administration of DNS works. Instead, we generally divide the name structure in a variety of places, depending on the needs of different parts of the name space. There are many cases where we might want to create a subdomain that is responsible for its own DNS server operation; there are others where we might not want to do that. The significance of a cut in the name hierarchy is that making such a cut represents, in essence, a <span class="emphasis"><em>declaration of DNS independence</em></span> by the node below the cut from the one above the cut.</p><p>Returning to our example, if googleplex.edu is in charge of its own DNS servers, then there would be a cut in the name space between googleplex.edu and .EDU at the next-higher level. This means that the DNS server for .EDU is no longer in charge of DNS for the googleplex.edu domain; instead, either the unversity itself or someone hired as a third party must provide DNS for it. In this case, we are assuming the folks at Googleplex U. themselves run their own DNS. Without making any other cuts, the googleplex.edu domain would be a single zone containing everything below that name, including both finearts.googleplex.edu and compsci.googleplex.edu.</p><p>In our example, however, we would make another cut, between googleplex.edu and compsci.googleplex.edu. This, in effect, <span class="emphasis"><em>liberates</em></span> compsci.googleplex.edu, allowing its administrators to be in charge of their own DNS server. In doing this, we end up with two distinct zones: one encompassing googleplex.edu, finearts.googleplex.edu, and admin.googleplex.edu (and everything underneath them) and another for compsci.googleplex.edu (and everything below it). This is illustrated in <a class="xref" href="ch54s06.html#dns_zones_of_authority_cuts_can_be_made_" title="Figure 54-2. DNS zones of authority Cuts can be made between nodes in the DNS name tree to create an arbitrary hierarchy of name authorities. This example shows the DNS tree branch for googleplex.edu, with each zone indicated using a different shading. IANA/ICANN is responsible for the root domain, and a separate authority named Educause takes care of .EDU. The third zone covers much of googleplex.edu, except that a cut has been made between googleplex and compsci to create an independent zone of authority for compsci.googleplex.edu.">Figure 54-2</a>.</p></div><div class="sect2" title="The Impact of Zones on Name Resolution: Authoritative Servers"><div class="titlepage"><div><div><h2 class="title"><a id="the_impact_of_zones_on_name_resolution_a"/>The Impact of Zones on Name Resolution: Authoritative Servers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-54-1932"/>The concept of zones is critical to understanding how DNS name servers work, and therefore, how name resolution is performed. All of the information about the subdomains and individual devices in the zone is represented using a set of resource records stored on a DNS name server. Usually, this name server is associated with the highest-level domain name in the zone. A name server that contains the definitive information for the zone is said to be <span class="emphasis"><em>authoritative</em></span> for the zone.</p><div class="figure"><a id="dns_zones_of_authority_cuts_can_be_made_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e56913"/><img alt="DNS zones of authority Cuts can be made between nodes in the DNS name tree to create an arbitrary hierarchy of name authorities. This example shows the DNS tree branch for googleplex.edu, with each zone indicated using a different shading. IANA/ICANN is responsible for the root domain, and a separate authority named Educause takes care of .EDU. The third zone covers much of googleplex.edu, except that a cut has been made between googleplex and compsci to create an independent zone of authority for compsci.googleplex.edu." src="httpatomoreillycomsourcenostarchimages288165.png"/></div></div><p class="title">Figure 54-2. DNS zones of authority Cuts can be made between nodes in the DNS name tree to create an arbitrary hierarchy of name authorities. This example shows the DNS tree branch for googleplex.edu, with each zone indicated using a different shading. IANA/ICANN is responsible for the root domain, and a separate authority named Educause takes care of .EDU. The third zone covers much of googleplex.edu, except that a cut has been made between googleplex and compsci to create an independent zone of authority for compsci.googleplex.edu.</p></div><p>An authoritative server for a zone is one that maintains the official information about the zone, and the one that is ultimately responsible for providing name resolution information about it. We'll discuss this in the section on DNS servers and name resolution in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-321"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The DNS name registration hierarchy is divided into regions called <a class="indexterm" id="idx-CHP-54-1933"/><span class="emphasis"><em>zones of authority</em></span>. Each zone represents an area that is administered independently and consists of a contiguous segment of the DNS name tree.</p></div><p>Every DNS zone has a set of authoritative servers, which are usually a pair called the <span class="emphasis"><em>primary</em></span> (or <span class="emphasis"><em>master</em></span>) and <span class="emphasis"><em>secondary</em></span> (or <span class="emphasis"><em>slave</em></span>) servers. However, it is also possible for a single DNS name server to be authoritative for more than one zone.</p><p>As mentioned earlier, it is not always necessary for the actual owner of a domain to provide DNS services for it. Very often, especially for the domains owned by small businesses or individuals, DNS services are provided by a third party, often an ISP. For example, I have had pcguide.com registered as a domain since 1997, but my long-time web-hosting provider, pair Networks, has provided DNS services for me since the beginning. This means that pair's DNS servers in the pair.com hierarchy are responsible for pcguide.com. They are also responsible for many other domains for the company's customers.</p></div></div>
<div class="sect1" title="DNS Private Name Registration"><div class="titlepage"><div><div><h1 class="title"><a id="dns_private_name_registration"/>DNS Private Name Registration</h1></div></div></div><p><a class="indexterm" id="idx-CHP-54-1934"/>We have now reviewed the hierarchical nature of the DNS name space and the authority structure that administers it. Name registration begins with the generic and country code TLDs within the root of the name hierarchy, then proceeds to second-level domains within the TLDs and then lower-level subdomains below those. As we progress down the name tree, we move from the most general, public authority (IANA/ICANN, which runs all of DNS), through the high-level TLD authorities, and eventually down to the level of individual organizations, corporations, and individuals.</p><p>This dividing line between public authorities and private authorities occurs in many different places in the name structure. Wherever it does occur, below that line, responsibility for the domain becomes that of the organization that registered it. The organization can further subdivide the name space, granting parts of it to other organizations, or even reselling it. Alternatively, an organization may decide to use the name space to create a purely internal structure. I call this <a class="indexterm" id="idx-CHP-54-1935"/><span class="emphasis"><em>private name registration</em></span>, in contrast to the <span class="emphasis"><em>public name registration</em></span> described earlier in this chapter.</p><p>For example, if a company called XYZ Industries registers xyzindustries.com, that company becomes the owner of not just that domain name, but any subdomain structure or named items within it that the company may choose to create. This is the beauty and power of authority delegation and the hierarchical structure. The company has an important decision to make, however: whether they want to create names that are part of the global DNS name structure or use names within the structure purely privately.</p><div class="sect2" title="Using Publicly Accessible Private Names"><div class="titlepage"><div><div><h2 class="title"><a id="using_publicly_accessible_private_names"/>Using Publicly Accessible Private Names</h2></div></div></div><p>If an organization's administrators want names within their domain to be part of the global DNS name structure, they must perform the work required to properly set up and manage these names so they fit into DNS. The most common example is creating a public World Wide Web server. Most companies name such servers beginning with www, so XYZ Industries would probably wish to have the name www.xyzindustries.com for its web server address.</p><p>Obviously, the XYZ Industries owners want and need anyone on the Internet to be able to locate this server. Thus, even though they have private control of the xyzindustries.com domain, and own the name www.xyzindustries.com, they must follow proper procedures for ensuring that DNS resource records are set up for their www subdomain so everyone on the Internet can find it. They may do this themselves, if they run their own DNS servers, or may have an ISP or other third party do it for them, as described earlier.</p></div><div class="sect2" title="Using Private Names for Internal Use"><div class="titlepage"><div><div><h2 class="title"><a id="using_private_names_for_internal_use"/>Using Private Names for Internal Use</h2></div></div></div><p>The alternative is to create purely private names for use only within the organization. For example, it is likely that even if XYZ wants a public web server, the administrators may wish to name many other machines that are to be accessed only within the company itself. In this case, they don't need to set up these machines so they are publicly recognizable. They can create private machine names and manage them internally within their own network.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-322"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Once an organization registers a particular domain name, it becomes the owner of that name and can decide whether and how to create a substructure within that domain. If an organization wants objects in the domain to be accessible on the public Internet, it must structure its domain to be consistent with Internet DNS standards. Alternately, it can create a purely private domain using any structure and rules it prefers.</p></div><p>One common way to do this is to make use of the older host table name system. This system is now archaic for large internetworks, but is often still used in smaller companies due to its simplicity. A name is <span class="emphasis"><em>registered</em></span> by being added to the host tables on each of the computers within the organization, and <span class="emphasis"><em>resolved</em></span> when the operating system on a host checks this file prior to using standard DNS resolution methods. The host table supplements DNS in this case (it is not really a part of DNS). The two systems are complementary and can work together, as explained in <a class="xref" href="ch51.html" title="Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM">Chapter 51</a>.</p></div><div class="sect2" title="Using Private Names on Networks Not Connected to the Internet"><div class="titlepage"><div><div><h2 class="title"><a id="using_private_names_on_networks_not_conn"/>Using Private Names on Networks Not Connected to the Internet</h2></div></div></div><p>Note that if you are running a purely private network not connected to the Internet at all, you can actually set up your own entirely private name hierarchy and run DNS yourself. In this case, you are in charge of the DNS root and can use any naming system you like.</p><p>This approach is sometimes considered attractive, because you can then use very simple machine names on small networks, without needing to perform any public registration or use names that correspond to the global hierarchy. Instead of the accounting computer in XYZ Industries being named accounting.xyzindustries.com, internally it could be named accounting. You can mix these with real DNS names, too, when accessing resources. For example, Joe's machine could be called just joe, while the website of UPS would, of course, still be www.ups.com.</p><p>The most common example of this mixing of private and public names is the definition of the private local name for the loopback address of a computer. Most Windows and UNIX machines define the name <span class="emphasis"><em>localhost</em></span> to be the address 127.0.0.1, which means "this computer" on any TCP/IP machine.</p></div></div>
<div class="chapter" title="Chapter&#xA0;55.&#xA0;DNS NAME SERVER CONCEPTS AND OPERATION"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_server_concepts_and_operation"/>Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e57017"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Of all the components and functional elements that combine to form the Domain Name System (DNS), <a class="indexterm" id="idx-CHP-55-1936"/>name servers are arguably the most important. These servers, which may be either dedicated devices or software processes running on machines that also perform other tasks, are the workhorses of DNS. They store and manage information about domains, and respond to resolution requests for clients—in some cases, millions of times each day. Understanding how they perform this most basic task and the many support jobs for which they are also responsible is crucial to understanding DNS as a whole.</p><p>In this chapter, I describe the concepts related to DNS name servers and explain how they operate. I begin with an overview of DNS name server functions and general operation. I describe the way that DNS name server data is stored in resource records and the role of classes. I discuss the different roles of name servers in DNS and explain the all-important root name servers. I discuss how DNS zones are managed, the notions of domain contacts and zone transfers, and how caching and load balancing are used to improve efficiency in DNS. I conclude with a brief outline of several enhancements to basic DNS server <a class="indexterm" id="idx-CHP-55-1937"/>operation, including the new Notify and Update message types and incremental zone transfers.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-323"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>The information in this section should be considered complementary to that in the following chapter on DNS resolvers</em></span>.</p></div><div class="sect1" title="DNS General Operation"><div class="titlepage"><div><div><h1 class="title"><a id="dns_general_operation"/>DNS General Operation</h1></div></div></div><p>The three major functions of a name system are creating a name space, performing name registration, and providing name resolution services. The previous chapters describe how DNS uses a hierarchical tree structure for its name space (<a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>), and a hierarchical tree for name authorities and registration (<a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a>). I'm sure that, given this, you will have to struggle to contain your surprise when I tell you that name resolution is also oriented around the notion of a hierarchical structure.</p><p>The devices that are primarily charged with performing the functions required to enable name resolution are <span class="emphasis"><em>name servers</em></span>. They are arranged in a hierarchy that is closely related to the authority structure of the name system. Just as the authority structure complements the name structure but is not exactly the same as it, the name server <a class="indexterm" id="idx-CHP-55-1938"/>architecture complements both the authority structure and the name structure, but may be different from them in its actual composition.</p><div class="sect2" title="DNS Name Server Architecture and the Distributed Name Database"><div class="titlepage"><div><div><h2 class="title"><a id="dns_name_server_architecture_and_the_dis"/>DNS Name Server Architecture and the Distributed Name Database</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-1939"/>In a large DNS implementation, information about domains is not centralized in a single database run by one authority. Instead, it is <span class="emphasis"><em>distributed</em></span> across many different authorities that manage particular top-level domains (TLDs), second-level domains, or lower-level subdomains. In the case of the global Internet, literally millions of different authorities, many of them responsible only for their own local domain space, participate cooperatively in running the DNS system.</p><p>With authority for registration distributed in this manner, the information about domains is similarly spread among many entities, resulting in a <span class="emphasis"><em>distributed database</em></span>. A key concept in DNS name resolution is that each entity that maintains responsibility for a part of the name space must also arrange to have that information stored on a DNS server. This is required so that the server can provide the information about that part of the name space when resolution is performed. As you can see, the existence of a structured hierarchy of authorities directly implies the need for a hierarchy of servers that store that hierarchical name information.</p><p>Each DNS zone of authority is required to have one or more DNS servers that are in charge of managing information about that zone. These servers are said to be <span class="emphasis"><em>authoritative</em></span> for the zone. Storing information about the domains, subdomains, and objects in the zone is done by recording the data in special resource records that are read from DNS master lists maintained by administrators. Servers then respond to requests for this information.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-324"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> DNS public name information is stored in a <span class="emphasis"><em>distributed database</em></span> of <a class="indexterm" id="idx-CHP-55-1940"/>DNS name servers that are structured in a hierarchy comparable to the hierarchy of authorities. Each zone has one or more DNS name servers in charge of the zone's information, called <span class="emphasis"><em>authoritative name servers</em></span>.</p></div><p>Since information in DNS is stored in a distributed form, there is no single server that has information about every domain in the system. As you'll see in the next chapter, the process of resolution instead relies on the hierarchy of name servers. At the top of the DNS hierarchy is the <span class="emphasis"><em>root</em></span> domain, and in that domain are root name servers. These are the most important servers, because they maintain information about the TLDs within the root. They also have knowledge of the servers that can be used to resolve domains one level below them. Those servers, in turn, are responsible for the TLDs and can reference servers that are responsible for second-level domains. Thus, a DNS resolution may require that requests be sent to more than one server.</p></div><div class="sect2" title="DNS Server Support Functions"><div class="titlepage"><div><div><h2 class="title"><a id="dns_server_support_functions"/>DNS Server Support Functions</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-1941"/>The storing and serving of name data (through responses to requests from DNS resolvers) is the main function of a DNS server. However, other support jobs are also typically required of a DNS server:</p><p><span class="strong"><strong>Interacting with Other Servers</strong></span> Because the DNS resolution process often requires that multiple servers be involved, servers must maintain not just name information, but information about the existence of other servers. Depending on the type of DNS request, servers may themselves become clients and generate requests to other servers.</p><p><span class="strong"><strong>Zone Management and Transfers</strong></span> The server must provide a way for DNS information within the zone to be managed. A facility also exists to allow a <span class="emphasis"><em>zone transfer</em></span> to be performed between the master (primary) server for a zone and slave (secondary) servers.</p><p><span class="strong"><strong>Performance Enhancement Functions</strong></span> Due to the large number of requests servers handle, they employ numerous techniques to reduce the time required to respond to queries. The most important of these is caching of name information. A variation of regular caching called <span class="emphasis"><em>negative caching</em></span> may also be used to improve performance, and load balancing is a feature that can be used to improve efficiency of busy devices registered within the DNS system.</p><p><span class="strong"><strong>Administration</strong></span> Various other administrative details are required of name servers, such as storing information about the different types of contacts (humans) who are responsible for certain tasks related to management of a domain or zone.</p><p>As you'll see later in this chapter, not all name servers perform all of these tasks described; some perform only a subset.</p></div><div class="sect2" title="The Logical Nature of the DNS Name Server Hierarchy"><div class="titlepage"><div><div><h2 class="title"><a id="the_logical_nature_of_the_dns_name_serve"/>The Logical Nature of the DNS Name Server Hierarchy</h2></div></div></div><p>Like the other hierarchies, the name server hierarchy is logical in nature. I already mentioned that it often is not exactly the same as the authority hierarchy. For one thing, it is common for a single DNS name server to be the authoritative server for a number of domains. Even if a particular group has authority for a subdomain of a particular domain, it's possible they will share the DNS servers with the authority of their parent domain for efficiency reasons. For example, a university might delegate control over parts of its domain space to different groups (as in the example of DNS zones in <a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a>) but still manage all subdomains on the same server. In practice, the lower the level of the subdomain in the DNS name hierarchy, the less likely that subdomain has its own DNS server.</p><p>Another important aspect of the logical nature of the name server hierarchy is that there is no necessary relationship between the structure of the name servers and their location. In fact, in many cases, name servers are specifically put in different places for reliability reasons. The best example of this is the set of root name servers. These are all at the top of the DNS server architecture, but they are spread around the globe to prevent a single problem from taking all of them out. Also remember not to be fooled by the structure of a name in the geopolitical DNS name hierarchy (as discussed in <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>). A name server called ns1.blahblah.ca might be in Canada, but it very well might not be located there.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-325"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The DNS name server hierarchy is logical in nature and not exactly the same as the DNS name server tree. One server may be responsible for many domains and subdomains. Also, the structure of the DNS name server hierarchy doesn't necessarily indicate the physical locations of name servers.</p></div></div></div></div>
<div class="sect1" title="DNS Name Server Data Storage"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_server_data_storage"/>DNS Name Server Data Storage</h1></div></div></div><p><a class="indexterm" id="idx-CHP-55-1942"/>One of the most important jobs performed by name servers is the storage of name data. Since the authority for registering names is distributed across the internetwork using DNS, the database of name information is likewise distributed. An <span class="emphasis"><em>authoritative</em></span> server is responsible for storing and managing all the information for the zones of authority it is assigned.</p><p>Each DNS server is, in essence, a type of database server. The database contains many kinds of information about the subdomains and individual devices within the domain or zone for which the server is responsible. In DNS, the database entries that contain this name information are called <span class="emphasis"><em>resource records (RRs)</em></span>. A specific set of RRs is associated with each node within the zone.</p><div class="sect2" title="Binary and Text Representations of Resource Records"><div class="titlepage"><div><div><h2 class="title"><a id="binary_and_text_representations_of_resou"/>Binary and Text Representations of Resource Records</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-1943"/>The entire point of DNS is to allow humans to work with names and computers to work with numbers. This principle is further reflected in the two very different <a class="indexterm" id="idx-CHP-55-1944"/>representations that exist for the DNS RRs themselves (see <a class="xref" href="ch55s02.html#dns_rr_master_file_and_binary_field_form" title="Figure 55-1. DNS RR master file and binary field formats">Figure 55-1</a>):</p><p><span class="strong"><strong>RR Field Format (Binary) Representation</strong></span> Name servers are required to respond to queries for name information by sending RRs within DNS messages. Obviously, we want to do this in as efficient a way as possible, so each RR is internally stored using a special field format that is similar to the many field formats used for messages in other protocols. All RRs use a general field format for some of their fields and then have a unique portion that is specific to the RR type.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-55-1945"/>Master File (<a class="indexterm" id="idx-CHP-55-1946"/>Text) Representation</strong></span> Computers are happy to exchange binary-encoded field formats and have no problem remembering that, for example, RR type 15 corresponds to a mail exchange (MX) record. However, human administrators want to be able to quickly and easily maintain DNS information without needing to remember cryptic codes or work with binary values. For this reason, DNS uses a <span class="emphasis"><em>master file</em></span> format for its user-machine interface, which allows RRs to be specified in text form for easier maintenance.</p><div class="figure"><a id="dns_rr_master_file_and_binary_field_form"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e57227"/><img alt="DNS RR master file and binary field formats" src="httpatomoreillycomsourcenostarchimages288167.png.jpg"/></div></div><p class="title">Figure 55-1. DNS RR master file and binary field formats</p></div><p>To meet the needs of humans and computers, DNS uses two representations for the data stored in RRs. Administrators enter and maintain information in textual DNS master files. These are read by DNS server software and internally stored in binary format for answering DNS requests.</p></div><div class="sect2" title="Use of RRs and Master Files"><div class="titlepage"><div><div><h2 class="title"><a id="use_of_rrs_and_master_files"/>Use of RRs and Master Files</h2></div></div></div><p>Each node may have a variable number of records, depending on the node type and what information is being kept for it. The RRs are added, changed, or deleted when DNS information changes, by administrators who make modifications to the text master files on the server computer. These files are then read into memory by the DNS server software, parsed (interpreted), and converted into binary form. Then they are ready for use in resolving DNS name requests and other queries. I describe both the binary RR field formats and master file format in <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-326"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> DNS name servers store DNS information in the form of <span class="emphasis"><em>resource records (RRs)</em></span>. Each RR contains a particular type of information about a node in the DNS tree. There are two representations for RRs: Conventional binary field formats are used for communication between DNS name servers and resolvers, and text <span class="emphasis"><em>master files</em></span> are edited by administrators to manage DNS zones.</p></div></div><div class="sect2" title="Common RR Types"><div class="titlepage"><div><div><h2 class="title"><a id="common_rr_types"/>Common RR Types</h2></div></div></div><p>The main <a class="indexterm" id="idx-CHP-55-1947"/>DNS standards, RFC 1034 and 1035, defined a number of RR types. Over time, the list has changed, with new RR types being created in subsequent standards and the use of others changed. Like other Internet parameters, the list of DNS RR types is maintained in a file by the Internet Assigned Numbers Authority (IANA). Also like other Internet parameters, there are actually several dozen defined RRs in DNS, but only a few are commonly used; others are now obsolete, used for special purposes, or experimental in nature. The current list of <a class="indexterm" id="idx-CHP-55-1948"/>DNS resource records is maintained in a file that can be found at <a class="ulink" href="http://www.iana.org/assignments/dns-parameters">http://www.iana.org/assignments/dns-parameters</a>.</p><p><a class="xref" href="ch55s02.html#summary_of_common_dns_resource_records" title="Table 55-1. Summary of Common DNS Resource Records">Table 55-1</a> summarizes the most important RR types. For each, I have shown the numeric Type value for the record, which is used to identify the RR type in message exchanges, and the <a class="indexterm" id="idx-CHP-55-1949"/>text code used for the RR in master files.</p><div class="table"><a id="summary_of_common_dns_resource_records"/><p class="title">Table 55-1. Summary of Common DNS Resource Records</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Summary of Common DNS Resource Records"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1950"/>RR Type Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RR <a class="indexterm" id="idx-CHP-55-1951"/>Text Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RR Type</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Address</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains a 32-bit IP address. This is the "meat and potatoes" of DNS, since it is where the address of a node is stored for name resolution purposes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1952"/>Name Server</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the name of a DNS <a class="indexterm" id="idx-CHP-55-1953"/>name server that is authoritative for the zone. Each zone must have at least one NS record that points to its primary name server, and that name must also have a valid Address (A) record.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1954"/>CNAME</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1955"/>Canonical Name</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to allow aliases to be defined that point to the real name of a node. The <a class="indexterm" id="idx-CHP-55-1956"/>CNAME record provides a mapping between this alias and the canonical (real) name of the node. It is commonly used to hide changes in the internal DNS structure from outside users, by letting them use an unchanging alias, while the internal names are modified based on the needs of the organization. See the discussion of name resolution in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a> for an example.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1957"/>SOA</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1958"/>Start Of Authority</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to mark the start of a DNS zone and provide important information about it. Every zone must have exactly one SOA record, which contains the name of the zone, its primary (master) authoritative server name, and technical details such as the email address of its administrator and parameters for how often slave (secondary) name servers are updated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1959"/>PTR</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1960"/>Pointer</p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides a <a class="indexterm" id="idx-CHP-55-1961"/>pointer to another location in the name space. These records are best known for their use in reverse resolution through the IN-ADDR.ARPA domain (described in <a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1962"/>MX</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1963"/>Mail Exchange</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the location (device name) that is responsible for handling email sent to the domain.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-55-1964"/>TXT</p></td><td style="border-right: 0.5pt solid ; "><p>Text String</p></td><td style=""><p>Allows arbitrary additional text associated with the domain to be stored.</p></td></tr></tbody></table></div></div><p>All of these RRs are used in different ways to define zones and devices within them and then permit name resolution and other functions to take place. You'll see how they are used in more detail in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>, which covers name resolution. You can also find a more lengthy description of some of them in the section in <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a> devoted to RR field formats.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-327"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>See the topic on IPv6 DNS support near the end of <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a> for IPv6-specific RR types</em></span>.</p></div></div><div class="sect2" title="RR Classes"><div class="titlepage"><div><div><h2 class="title"><a id="rr_classes"/>RR Classes</h2></div></div></div><p>Finally, I would like to mention a historical note about RRs. When <a class="indexterm" id="idx-CHP-55-1965"/>DNS was first created, its inventors wanted it to be as generic as possible. To that end, they designed it so that a DNS server could, theoretically, provide name service for more than one type of underlying protocol; that is, DNS could support TCP/IP as well as other protocols simultaneously.</p><p>Of course, protocols have different addressing schemes and also varying needs for name resolution. Therefore, DNS was defined so that each protocol could have a distinct set of RR types. Each set of RR types was called a <span class="emphasis"><em>class</em></span>. Technically, an RR must be identified using both a class identifier and an RR type. Like the RR types, <a class="indexterm" id="idx-CHP-55-1966"/>classes have a numeric code number and a text abbreviation. The class for TCP/IP uses the number 1, with the text code IN (for Internet).</p><p>In practice, this notion of multiple classes of RRs never took off. Today, DNS is, to my knowledge, used only for TCP/IP. (There may be some obscure exceptions.) Several other classes have been defined by RFC 1035 and are in the IANA DNS parameters list, but they are for relatively obscure, experimental, or obsolete network types, with names such as CSNET, CHAOS, and Hesiod. You'll still see this concept of class in the specification of DNS message and RR formats, but there really is only class today: IN for TCP/IP. For this reason, in most cases, the class name can be omitted in DNS-related commands and data entries, and IN will be assumed by default.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-328"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The DNS standards were originally created to allow them to work with multiple protocols, by specifying the class of each RR. Today, the only class commonly used is that for TCP/IP, which is called IN (for Internet).</p></div></div></div>
<div class="sect1" title="DNS Name Server Types and Roles"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_server_types_and_roles"/>DNS Name Server Types and Roles</h1></div></div></div><p><a class="indexterm" id="idx-CHP-55-1967"/>So far, we have looked at the functions of DNS servers, focusing on the important job of storing name server information. There are many thousands of DNS servers on the Internet, and not all are used in the same way. Each DNS server has a particular role in the overall operation of the name system. The different kinds of servers also interact with each other in a variety of ways.</p><div class="sect2" title="Master (Primary)/Slave (Secondary) Servers"><div class="titlepage"><div><div><h2 class="title"><a id="master_primaryslave_secondary_servers"/>Master (Primary)/Slave (Secondary) Servers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-1968"/><a class="indexterm" id="idx-CHP-55-1969"/><a class="indexterm" id="idx-CHP-55-1970"/><a class="indexterm" id="idx-CHP-55-1971"/>Every zone needs to have at least one DNS name server that is responsible for it. These <a class="indexterm" id="idx-CHP-55-1972"/>DNS name servers are called <span class="emphasis"><em>authoritative</em></span> servers for the zone, because they contain the full set of RRs that describe the zone. When any device on the Internet wants to know something about a zone, it consults one of its authoritative servers.</p><p>From a strictly theoretical perspective, having one name server for each zone or domain is sufficient to provide name resolution services for the entire DNS name structure. From an implementation standpoint, however, having only one name server for each part of the name space is not a wise idea. Instead, each zone usually has associated with it at least two name servers: one <span class="emphasis"><em>primary</em></span> or <span class="emphasis"><em>master</em></span> name server, and one <span class="emphasis"><em>secondary</em></span> or <span class="emphasis"><em>slave</em></span> name server. Some zones may have more than one secondary name server.</p><div class="note" title="Note"><h3 class="title"><a id="note-135"/>Note</h3><p><span class="emphasis"><em>The terms primary and secondary are used often in the DNS standards to refer to the roles of the two authoritative servers for a zone. However, master and slave are now the preferred terms, because primary and secondary are somewhat ambiguous and used in other contexts. You should be prepared to see both terms used</em></span><a class="indexterm" id="idx-CHP-55-1973"/>.</p></div><p>The master name server is obviously the most essential server. It is on this name server that the master files for the zone's RRs are maintained, so the master name server is the final word on information on the zone. However, there are several reasons why slave servers are also important:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-55-1974"/>Redundancy</strong></span> If there were only one name server and it failed, no one would be able to resolve names such as <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> into IP addresses, and that would be a Bad Thing. Slave name servers act as a backup for the masters they support. Redundancy is the most important consideration in setting up master and slave name servers. Sticking two machines side by side in a server room, plugged into the same electrical service, both connected to the Internet with the same Internet service provider (ISP), and making one your master DNS server and the other your slave is not a smart move. Ideally, the primary and secondary servers should be as independent as possible; they should be physically distant and have separate connections to the Internet.</p><p><span class="strong"><strong>Maintenance</strong></span> With more than one server, we can easily take the primary server down for maintenance when needed without name resolution service being disrupted.</p><p><span class="strong"><strong>Load Handling</strong></span> Busy zones can use multiple servers to spread the load of name resolution requests to improve performance.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-55-1975"/>Efficiency</strong></span> There are many cases where there is an advantage to positioning a name server in a particular geographical location for the sake of efficiency. For example, a company may have an office in a distant location connected using a low-speed wide area network link. To reduce name resolution traffic across that link, it makes sense to have that zone's information available in a name server on both sides of the connection, which would require two physical servers.</p><p>Just as the names <span class="emphasis"><em>master</em></span> and <span class="emphasis"><em>slave</em></span> suggest, the secondary name servers are not the original source of information about a zone. They normally obtain their RRs not from human-edited master files, but from updates from the master server. This is accomplished using a process called a<span class="emphasis"><em> zone transfer</em></span>. These transfers are performed on a regular basis to ensure that the slave servers are kept up-to-date. The slaves can then respond to name resolution requests with current information. Both the master and the slave are considered authoritative for the zone.</p></div><div class="sect2" title="Name Server Roles"><div class="titlepage"><div><div><h2 class="title"><a id="name_server_roles"/>Name Server Roles</h2></div></div></div><p>The master and slave roles for a zone are logical and do not always correspond to individual physical hardware devices. A single physical name server can play multiple roles in the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It can be the master name server for more than one zone. Each zone in this case has a distinct set of RRs maintained in separate master files.</p></li><li class="listitem"><p>It can be a slave name server for more than one zone.</p></li><li class="listitem"><p>It can be a slave name server for certain <a class="indexterm" id="idx-CHP-55-1976"/>zones as well as a primary for others.</p></li></ul></div><p>Note, however, that a single physical name server cannot be a master and a slave server for the same zone.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-329"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The master DNS server for a zone is its primary server, which maintains the master copy of DNS information. Most DNS zones also have at least one slave or secondary DNS server. These are important because they serve as backups for the primary server, and they can also help share the load of responding to requests in busy zones. Secondary name servers get their information from primary servers on a routine basis. Both master and slave servers are considered authoritative for the zones whose data they maintain.</p></div></div><div class="sect2" title="Caching-Only Name Servers"><div class="titlepage"><div><div><h2 class="title"><a id="caching-only_name_servers"/>Caching-Only Name Servers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-1977"/>For efficiency, all DNS servers—both masters and slaves—perform caching of DNS information so it can be used again if requested in the near future. (Caching is described in the "Name Server Caching" section later in this chapter.) The importance of caching is so significant that some servers are set up only to cache information from other DNS servers. Unsurprisingly, these are called <span class="emphasis"><em>caching-only</em></span> name servers.</p><p>These name servers are not authoritative for any zone or domain, and they don't maintain any RRs of their own. They can answer name resolution requests only by contacting other name servers that <span class="emphasis"><em>are</em></span> authoritative and then relaying the information. They then store the information for future requests. Why bother? The reason is performance. Through strategic placement, a caching-only server can increase DNS resolution performance substantially in some networks by cutting down on requests to authoritative servers.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-330"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> There are DNS servers that do not maintain DNS RRs of their own but solely hold recently used information from other zones. These are called <span class="emphasis"><em>caching-only</em></span> name servers and are not authoritative for any zone.</p></div></div></div>
<div class="sect1" title="DNS Zone Management, Contacts, and Zone Transfers"><div class="titlepage"><div><div><h1 class="title"><a id="dns_zone_management_contacts_and_zone_tr"/>DNS Zone Management, Contacts, and Zone Transfers</h1></div></div></div><p>The authority for a particular DNS zone is responsible for performing a variety of tasks to manage it. <span class="emphasis"><em>Zone management</em></span> encompasses the entire gamut of jobs related to a zone: deciding on the name hierarchy within the zone, specifying procedures for name registration, technical work related to keeping DNS servers running, and other administrative overhead of all sorts. This job can be either very small or incredibly large, depending on the type of organization. A small <a class="indexterm" id="idx-CHP-55-1978"/>domain owned by an individual doesn't require much work to manage, while one for a huge company might require a dedicated staff to maintain.</p><div class="sect2" title="Domain Contacts"><div class="titlepage"><div><div><h2 class="title"><a id="domain_contacts"/>Domain Contacts</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-1979"/>It is important that it be possible for anyone on an internetwork to be able to determine who the owner of a domain is, so that person can be reached for whatever reason. On the Internet, each DNS domain has associated with it a set of three <span class="emphasis"><em>contacts</em></span> that are responsible for different facets of managing a domain:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-55-1980"/>Administrative Contact</strong></span> The main contact, responsible for the domain as a whole. This individual or organization is considered the overall owner of the domain.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-55-1981"/>Billing Contact</strong></span> A contact responsible for handling payment for domain services and other accounting matters.</p><p><span class="strong"><strong>Technical Contact</strong></span> A contact who handles the technical details of setting up DNS for the domain and making sure it works.</p><p>For smaller domains, there usually is no separate billing contact; it is the same as the administrative contact. In contrast, the technical contact is often different from the administrative contact in both large and small domains. Large organizations will make the technical contact someone in their information technology department. Small organizations often let their ISP provide DNS services, and in that case, the technical contact will be someone at that ISP.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-331"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each DNS domain has associated with it a set of three contact names that indicate who is responsible for managing it. The <span class="emphasis"><em>administrative</em></span> contact is the person with overall responsibility for the domain. The <span class="emphasis"><em>billing contact</em></span> is responsible for payment issues; this may be the same as the administrative contact. The <span class="emphasis"><em>technical contact</em></span> is in charge of technical matters for the domain and is often a different person than the administrative contact, especially when DNS services are outsourced.</p></div></div><div class="sect2" title="Zone Transfers"><div class="titlepage"><div><div><h2 class="title"><a id="zone_transfers"/>Zone Transfers</h2></div></div></div><p>The ultimate purpose of zone management is to ensure that information about the zone is kept current on the zone's master and slave name servers, so it can be efficiently provided to name resolvers. Thus, the management of a zone begins with decision-making and administrative actions that result in changes to the RRs for the zone. These are reflected in changes made to the DNS master files on the master (primary) DNS server for the zone.</p><p>In contrast, each zone's secondary DNS server(s) act as slaves to the master primary server. They carry information about the zone, but do not load it from local master files that are locally edited. Instead, they obtain their information from the master name server on a regular basis. The procedure responsible for this is called a <span class="emphasis"><em>zone transfer</em></span>.</p><p>The records on the master name server can be updated at any time. As soon as the master name server's records have been changed, the information at the slave name servers becomes partially out-of-date. This is not generally a big deal, because most of the data will still be accurate, and the secondary server will continue to respond to resolution requests using the most current information it has. However, it is obviously important that we update the slave servers on a regular basis; if this is not done, eventually their data will become stale and unreliable. To this end, it is necessary that zone transfers be performed on a regular basis.</p><div class="sect3" title="Control of When Zone Transfers Occur"><div class="titlepage"><div><div><h3 class="title"><a id="control_of_when_zone_transfers_occur"/>Control of When Zone Transfers Occur</h3></div></div></div><p>Controlling when zone transfers happen requires implementation of a communication process between the servers that consists of two basic parts. First, we need a mechanism to allow slave servers to regularly check for changes to the data on the master. Second, we must have a mechanism for copying the RRs for the zone from the primary name server to the secondary server when needed.</p><p>Both mechanisms make use of standard DNS query/response facilities and special fields in the RRs for the zone. Of particular importance is the Start Of Authority (SOA) record for the zone, which contains several parameters that control zone status checking and zone transfers. While the formal description of these parameters can be found in the description of RR formats in <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a>, I'll discuss how they are used here.</p><p>When a slave name server starts up, it may have no information about the zone at all, or it may have a copy of the zone's RRs stored on its local storage, from the last time it was running. In the former case, it must immediately perform a full zone transfer, since it has no information. In the latter case, it will read its last-known copy of the zone from local storage; it may immediately perform a <span class="emphasis"><em>poll</em></span> on the master server to see if the data has changed, depending on configuration. A poll is done by requesting the SOA RR for the zone.</p><p>The Serial field in the SOA record contains a serial number (which may be arbitrary or may be encoded so it has a particular meaning) that acts as the version number of the master server's zone database. Each time the master file for the zone is modified (either manually by editing or automatically through another means), this serial number is increased. Therefore, a slave server can detect when changes have been made on the master by seeing if the Serial field in the most recent SOA record is greater than the one the slave stored the last time it polled the master. If the serial number has changed, the slave begins a zone transfer.</p><p>Three other fields in the SOA record control the timing that slave name servers use for polling and updating their information:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-55-1982"/>Refresh</strong></span> This field specifies how many seconds a slave server waits between attempts to check for an update on the master. Assuming the slave can make contact, this is the longest period of time that data on a slave will become stale when the master changes.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-55-1983"/>Retry</strong></span> This field controls how long the slave must wait before trying again to check in with the master if its last attempt failed. This is used to prevent rapid-fire attempts to contact a master that may clog the network.</p><p><span class="strong"><strong>Expire</strong></span> If, for whatever reason, the slave name server is not able to make contact with the master for a number of seconds given by this field's value, it must assume that the information it has is stale and stop using it. This means that it will stop acting as an authoritative name server for the zone until it receives an update.</p><p>The fact that these parameters are part of the SOA record for the zone gives the administrator of the zone complete control over how often master name servers are updated. In a small zone where changes are rare, the interval between checks made by the slave servers can be increased; for larger zones or ones that are changed often, the Refresh interval can be decreased.</p></div><div class="sect3" title="Zone Transfer Mechanism"><div class="titlepage"><div><div><h3 class="title"><a id="zone_transfer_mechanism"/>Zone Transfer Mechanism</h3></div></div></div><p>When a zone transfer is required, it is accomplished using a DNS query sent to the master server using the regular DNS query/response messaging method used for name resolution (discussed in the next section). A special DNS question type, called AXFR (address transfer) is used to initiate the zone transfer. The server will then transfer the RRs for the zone using a series of DNS response messages (assuming that the server that requested the transfer is authorized to do so). Since it's important that zone <a class="indexterm" id="idx-CHP-55-1984"/>transfers be received reliably, and since the amount of data to be sent is large and needs to be managed, a Transmission Control Protocol (TCP) session must first be established and used for zone transfers. This is in contrast to the simpler User Datagram Protocol (UDP) transport used for regular DNS messages (as described in the section discussing the use of UDP and TCP for DNS at the start of <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a>).</p><p>Once the zone transfer is complete, the slave name server will update its database and return to regular operation. It will continue to perform regular polls of the master server every Refresh seconds. If it has a problem with a regular poll, it will try again after Retry seconds. Finally, if an amount of time equal to Expires seconds elapses, the master name server will stop serving data from the zone until it reestablishes contact with the primary name server.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-332"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Slave name servers do not have their DNS information managed directly by an administrator. Instead, they obtain information from their master name server on a periodic basis through a process called a <span class="emphasis"><em>zone transfer</em></span>. Several fields in the Start Of Authority (SOA) DNS RR control the zone transfer process, including specifying how often transfers are done and how slave name servers handle problem conditions such as an inability to contact the master server.</p></div><p>Note that the DNS <a class="indexterm" id="idx-CHP-55-1985"/><span class="emphasis"><em>Notify</em></span> feature is an enhancement to the basic zone status check/zone transfer model. It allows the master server to notify a slave server when the master's database has changed. Another new feature allows only part of a zone to be transferred instead of the entire zone. See the discussion of DNS name server enhancements later in this chapter for more information.</p></div></div></div>
<div class="sect1" title="DNS Root Name Servers"><div class="titlepage"><div><div><h1 class="title"><a id="dns_root_name_servers"/>DNS Root Name Servers</h1></div></div></div><p>DNS is strongly oriented around the notion of hierarchical structure. The name space, registration authorities, and <a class="indexterm" id="idx-CHP-55-1986"/>name servers are all arranged in a tree structure. Like these structures, the name resolution process is also hierarchical. As explained in <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>, a fully qualified domain name (FQDN) is resolved by starting with the least specific domain name element (label) and working toward the most specific one.</p><p>Naturally, the least specific portion of every name is the root node under which the entire DNS structure exists. This means that, absent caching and other performance enhancements, all name resolution begins with the root of the name tree. We find here a set of name servers that are responsible for name server functions for the DNS root: the DNS <a class="indexterm" id="idx-CHP-55-1987"/><span class="emphasis"><em>root name servers</em></span>.</p><p>Like all name servers, <a class="indexterm" id="idx-CHP-55-1988"/>DNS root name servers store information about and provide name resolution services for all the nodes within the root zone. This includes certain specific TLDs and subdomains. Most TLDs, however, are in their own zones. The root name servers are used as the "go-to" spot to obtain the names and addresses of the authoritative servers for each of these TLDs. For example, if we want to resolve the name <a class="ulink" href="http://www.xyzindustries.co.uk">www.xyzindustries.co.uk</a>, the root name servers are where a resolver would find the identity of the name server that is responsible for .UK.</p><div class="sect2" title="Root Name Server Redundancy"><div class="titlepage"><div><div><h2 class="title"><a id="root_name_server_redundancy"/>Root Name Server Redundancy</h2></div></div></div><p>Clearly, these root name servers are extremely important to the functioning of the DNS system as a whole. If anything were to ever happen to cause the root name servers to stop operating, the entire DNS system would essentially shut down. For this reason, there obviously isn't just one root server, nor are there two or three; there are (at present) thirteen different root name servers.</p><p>In fact, there are actually far more than 13 physical servers. Most of the 13 name servers are implemented as clusters of several independent physical hardware servers. Some are distributed collections of servers that are in different physical locations. The best example is the F root server, which has been implemented as a set of more than a dozen <span class="emphasis"><em>mirrors</em></span> in various places around the world, to provide better service.</p><p>The principles of redundancy that are a good idea for choosing a secondary name server for a regular domain obviously apply that much more to the root. This is why the various physical devices that compose the 13 root servers are all located in different places all around the globe. Many of them are in the United States, but even these are in many locations throughout the country (albeit concentrated in a couple of hot spots in California and near Washington, DC) and are set up to use different networks to connect to the Internet.</p><p>The root name servers are, of course, rather powerful. Despite there being several dozen pieces of hardware to spread the load, they must each handle large amounts of data, 24 hours a day. They are run by networking professionals who ensure that they function efficiently. An Internet standard, RFC 2870, "Root Name Server Operational Requirements," spells out the basic rules and practices for the operation of these name servers. It specifies extensive procedures for ensuring the security of the servers and for avoiding performance problems due to their pivotal role.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-333"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Information about the DNS root and its TLDs is managed by a set of <span class="emphasis"><em>root name servers</em></span>. These servers are essential to the operation of DNS. They are arranged into 13 groups and physically distributed around the world.</p></div><p>Despite all the efforts taken to ensure that the root servers are widely distributed and secure, they still collectively represent a point of weakness in the global Internet. Millions and millions of people depend on these servers. There have been incidents in the past where rogue elements on the Internet have attempted to disrupt DNS by attacking the root name servers. One widely publicized incident was a denial-of-service (DoS) attack against the root servers on October 21, 2002. The attack failed, but it significantly raised awareness of the importance of these servers and how essential DNS security is.</p></div><div class="sect2" title="Current Root Name Servers"><div class="titlepage"><div><div><h2 class="title"><a id="current_root_name_servers"/>Current Root Name Servers</h2></div></div></div><p>Originally, the root name servers were given domain names reflecting the organizations that ran them. In these historical names, we can see a veritable who's who of the big players in the development of the Internet: the Information Sciences Institute (ISI), National Aeronautics and Space Administration (NASA), United States military, and others. Several of the servers are still run by government agencies or the United States military, where added security can be put into place to protect them. For convenience, however, all the root name servers are now given alphabetical letter names in the special domain root-servers.net.</p><p><a class="xref" href="ch55s05.html#internet_dns_root_name_servers" title="Table 55-2. Internet DNS Root Name Servers">Table 55-2</a> shows the most current information about the DNS root name servers as of the date of publishing of this book. For your interest and amusement, I have also mapped the locations of these servers in <a class="xref" href="ch55s05.html#geographic_locations_of_internet_dns_roo" title="Figure 55-2. Geographic locations of Internet DNS root name servers">Figure 55-2</a>.</p><div class="table"><a id="internet_dns_root_name_servers"/><p class="title">Table 55-2. Internet DNS Root Name Servers</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Internet DNS Root Name Servers"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Root Server Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Historical Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Location(s)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>198.41.0.4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ns.internic.net</p></td><td style="border-bottom: 0.5pt solid ; "><p>Dulles, VA, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>b.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128.9.0.107</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ns1.isi.edu</p></td><td style="border-bottom: 0.5pt solid ; "><p>Marina Del Rey, CA, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>c.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.33.4.12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>c.psi.net</p></td><td style="border-bottom: 0.5pt solid ; "><p>Herndon, VA and Los Angeles, CA, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>d.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128.8.10.90</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>terp.umd.edu</p></td><td style="border-bottom: 0.5pt solid ; "><p>College Park, MD, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>e.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.203.230.10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ns.nasa.gov</p></td><td style="border-bottom: 0.5pt solid ; "><p>Mountain View, CA, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>f.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.5.5.241</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ns.isc.org</p></td><td style="border-bottom: 0.5pt solid ; "><p>Auckland, New Zealand; Sao Paulo, Brazil; Hong Kong, China; Johannesburg, South Africa; Los Angeles, CA, U.S.; New York, NY, U.S.; Madrid, Spain; Palo Alto, CA, U.S.; Rome, Italy; Seoul, Korea; San Francisco, CA, U.S.; San Jose, CA, U.S.; Ottawa, ON, Canada</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>g.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.112.36.4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ns.nic.ddn.mil</p></td><td style="border-bottom: 0.5pt solid ; "><p>Vienna, VA, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>h.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>128.63.2.53</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>aos.arl.army.mil</p></td><td style="border-bottom: 0.5pt solid ; "><p>Aberdeen, MD, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>i.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.36.148.17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>nic.nordu.net</p></td><td style="border-bottom: 0.5pt solid ; "><p>Stockholm, Sweden; Helsinki, Finland</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>j.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>192.58.128.30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>Dulles, VA, U.S.; Mountain View, CA, U.S.; Sterling, VA, U.S.; Seattle, WA, U.S.; Atlanta, GA, U.S.; Los Angeles, CA, U.S.; Amsterdam, The Netherlands</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>k.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>193.0.14.129</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>London, UK; Amsterdam, The Netherlands</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>l.root-servers.net</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>198.32.64.12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-bottom: 0.5pt solid ; "><p>Los Angeles, CA, U.S.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>m.root-servers.net</p></td><td style="border-right: 0.5pt solid ; "><p>202.12.27.33</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style=""><p>Tokyo, Japan</p></td></tr></tbody></table></div></div><div class="figure"><a id="geographic_locations_of_internet_dns_roo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e58084"/><img alt="Geographic locations of Internet DNS root name servers" src="httpatomoreillycomsourcenostarchimages288169.png.jpg"/></div></div><p class="title">Figure 55-2. Geographic locations of Internet DNS root name servers</p></div><p>The current list of root name servers can be found in the file <a class="ulink" href="ftp://ftp.rs.internic.net/domain/named.root">ftp://ftp.rs.internic.net/domain/named.root</a>. You can also find the information in a more user-friendly format at <a class="ulink" href="http://www.root-servers.org">http://www.root-servers.org</a>.</p></div></div>
<div class="sect1" title="DNS Name Server Caching"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_server_caching"/>DNS Name Server Caching</h1></div></div></div><p><a class="indexterm" id="idx-CHP-55-1989"/>Most of the grunt work done by name servers is responding to name resolution requests. Busy servers—like the root name servers, the ones that carry zone information for the TLDs, and ones that serve very busy zones—must handle hundreds or even thousands of name resolution requests each <span class="emphasis"><em>second</em></span>. Each of these requests takes time and resources to resolve and takes internetwork bandwidth away from the business of transferring data. It is essential, therefore, that DNS server implementations employ mechanisms to improve their efficiency and cut down on unnecessary name resolution requests. One of the most important of these is <span class="emphasis"><em>caching</em></span>.</p><div class="sect2" title="Name Server Caching"><div class="titlepage"><div><div><h2 class="title"><a id="name_server_caching"/>Name Server Caching</h2></div></div></div><p>The word <span class="emphasis"><em>cache</em></span> refers to a store, or a place where something is kept. In the computer world, the term usually refers to an area of memory set aside for storing information that has been recently obtained so it can be used again. In the case of DNS, <a class="indexterm" id="idx-CHP-55-1990"/>caching is used by DNS name servers to store the results of recent name resolution and other requests, so that if the request occurs again, it can be satisfied from the cache without requiring another complete run of the name resolution process. Due to how most people use computers, a particular request is often followed by another request for the same name, so caching can significantly reduce the number of requests that result in complete name resolution procedures.</p><p>An example is the best way to illustrate this. Suppose you are using a host on your company's local network. This host is probably configured to use your company's DNS name server to handle resolution requests. You type <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> into your web browser, which causes a resolution attempt to be made for that address. Most likely, your local DNS server doesn't know that name, so it will follow the complete name resolution process (described in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>) to get its address. After doing this, your local DNS server will <span class="emphasis"><em>cache</em></span> the name <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> and the address associated with it.</p><p>If you click a link for a page at that website, that new page will also probably be somewhere at the <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> site. This will result in another DNS resolution request being sent off to your local DNS server. However, this time, the local server will not need to perform a resolution. It remembers that this name is in its cache and returns the saved address for the name immediately. Voilà! You get your answer faster, and unnecessary Internet traffic is avoided.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-334"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Caching</em></span> is an essential efficiency feature that reduces DNS message traffic by eliminating unnecessary requests for recently resolved names. Whenever a name is resolved, the resulting DNS information is cached so it can be used for subsequent requests that occur shortly thereafter.</p></div><p>Of course, things aren't entirely this simple. One very important issue that comes up with every caching system, including the one used in DNS, is the matter of the <span class="emphasis"><em>freshness</em></span> of the cache.</p></div><div class="sect2" title="Caching Data Persistence and the Time to Live Interval"><div class="titlepage"><div><div><h2 class="title"><a id="caching_data_persistence_and_the_time_to"/>Caching Data Persistence and the Time to Live Interval</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-1991"/>Suppose your local DNS server resolves the name <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>, and then caches its address. In this example, where you click a link a few seconds after the XYZ Industries home page loads, you aren't likely to be too concerned about how fresh the DNS data is. But how about if you shut down your computer to go on vacation for two weeks, and then come back to work and type the name into your browser again. If your local server still has the name in its cache, how do you know the IP address of <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> hasn't changed during that two-week period?</p><p>Two different mechanisms are used to address this issue. The first is that when data is cached, the <a class="indexterm" id="idx-CHP-55-1992"/>caching server also makes a note of the authoritative server from which it came. When a resolver (client) asks for a name resolution and the address is drawn from the cache, the server marks the answer as <span class="emphasis"><em>non-authoritative</em></span> to clearly tell the client that the name came from the cache. The server also supplies the name of the authoritative server that originally supplied the data.</p><p>The client then has a choice: It can either use the non-authoritative answer or issue a request for a fresh name resolution from the authoritative server. This is a trade-off between performance (using the cached data) and currency (asking for a fresh resolution each time). Usually, the cached data can be used safely, because <a class="indexterm" id="idx-CHP-55-1993"/>DNS information doesn't change very often.</p><p>The second technique for ensuring that caching data doesn't get too old is a procedure for limiting the <span class="emphasis"><em>persistence</em></span> of <a class="indexterm" id="idx-CHP-55-1994"/>DNS cached data. Each RR has associated with it a time interval, called the <span class="emphasis"><em>Time to Live (TTL)</em></span>. Whenever an RR is read from a server, the TTL for the record is also read. Any server caching the record is supposed to discard the record after that time interval expires.</p><p>Each zone also has associated with it a default value for the TTL field to be applied to all records in the zone. This allows an administrator to select a TTL value for all records in a zone without needing to enter TTL numbers for each record individually. At the same time, the administrator can assign an override TTL value to any records that need a number that is different from the default. This default TTL was originally kept in the special SOA RR for each zone, but is now handled using a special directive in the zone's master file.</p><div class="note" title="Note"><h3 class="title"><a id="note-136"/>Note</h3><p><span class="emphasis"><em>This Time to Live (TTL) field is not related to the one used in Internet Protocol (IP) datagrams (see <a class="xref" href="ch21.html" title="Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 21</a>). Obviously, IP and DNS are totally different protocols, but more than that, the TTL fields in IP and DNS don't have the same meaning at all</em></span>.</p></div><p>It's worth emphasizing that DNS gives control over caching to the owner of the record, not whoever is running the DNS server doing the caching. While it is possible for a particular caching server to override the TTL and specify how long data will be held in its own cache, DNS is not supposed to work that way. The ability to specify a TTL on a record-by-record basis allows the persistence of cache data to be tailored to the needs of the individual data elements. Data that changes often can be given a small TTL value; infrequently modified records can be given a higher TTL. Selecting the TTL value must be done carefully. This is another trade-off between performance (which is optimized with higher TTL values, reducing the number of queries made for cached data) and freshness of the data (which increases as the TTL values are lowered).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-335"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Cached information can become stale over time and result in incorrect responses sent to queries. Each RR can have associated with it a time interval, called the <span class="emphasis"><em>Time to Live (TTL)</em></span>, that specifies how long the record may be held in a cache. The value of this field is controlled by the owner of the RR, who can tailor it to the specific needs of each RR type.</p></div></div><div class="sect2" title="Negative Caching"><div class="titlepage"><div><div><h2 class="title"><a id="negative_caching"/>Negative Caching</h2></div></div></div><p>Classic DNS caching stores only the results of successful name resolutions. It is also possible for DNS servers to cache the results of <span class="emphasis"><em>unsuccessful</em></span> name resolution attempts; this is called <a class="indexterm" id="idx-CHP-55-1995"/><span class="emphasis"><em>negative caching</em></span>. To extend the example we've been using in this section, suppose you mistakenly thought the name of the company's website was <a class="ulink" href="http://www.xyz-industries.com">www.xyz-industries.com</a> and typed that into your browser. Your local DNS server would be unable to resolve the name and would mark that name as unresolvable in its cache—a <a class="indexterm" id="idx-CHP-55-1996"/>negative cache entry.</p><p>Suppose you typed the name in incorrectly because someone mistyped it on an internal memo. If a colleague later tried the same name, the DNS server would say, "I already know this is a bogus name," and not try to resolve it again. Since there is no RR for an invalid name, the server itself must decide how long to cache this negative information. Negative caching improves performance because resolving a name that doesn't exist takes resources, just as resolving an existing one does. Note that regular caching is sometimes called <a class="indexterm" id="idx-CHP-55-1997"/><span class="emphasis"><em>positive caching</em></span> to contrast it with negative caching.</p><p>The value to be used for negative caching in a zone is now specified by the Minimum field in the SOA RR for each zone. As mentioned in the previous section, this was formerly used to specify the default TTL for a zone.</p></div></div>
<div class="sect1" title="DNS Name Server Load Balancing"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_server_load_balancing"/>DNS Name Server Load Balancing</h1></div></div></div><p><a class="indexterm" id="idx-CHP-55-1998"/>The Address (A) RR is the most fundamental one in DNS, since it records an actual mapping between a domain name and an IP address. Let's consider for a moment one of the words in that sentence in more detail. No, I don't mean <span class="emphasis"><em>address</em></span> or <span class="emphasis"><em>RR</em></span> or <span class="emphasis"><em>mapping</em></span>. I mean the word <span class="emphasis"><em>an</em></span>!</p><p>The Address record mentions only a single address for each domain name. This means that each domain name maps to only a single physical hardware device. When the number of requests that a particular server or other device needs to handle is relatively small, this is not a problem; the function can usually be implemented using a single physical hardware device. If the server gets busier, the usual solution is to throw more hardware at the problem—get a bigger machine.</p><p>However, some hosts on a large internetwork, especially the Internet, feature servers that must handle tremendous amounts of traffic from many clients. There simply is no single hardware device that can readily handle the traffic of a site like <a class="ulink" href="http://www.cnn.com">www.cnn.com</a> or <a class="ulink" href="http://www.microsoft.com">www.microsoft.com</a>, for example, without becoming unwieldy. Sites like these must use a technique called <a class="indexterm" id="idx-CHP-55-1999"/><span class="emphasis"><em>load balancing</em></span> to spread requests across multiple hardware servers.</p><div class="sect2" title="Using Multiple Address Records to Spread Out Requests to a Domain"><div class="titlepage"><div><div><h2 class="title"><a id="using_multiple_address_records_to_spread"/>Using Multiple Address Records to Spread Out Requests to a Domain</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-2000"/>One simple way to do load balancing would be to have multiple machine names. For example, CNN could create several different websites called <a class="ulink" href="http://www1.cnn.com">www1.cnn.com</a>, <a class="ulink" href="http://www2.cnn.com">www2.cnn.com</a>, and so on, each pointing to a different hardware device. DNS certainly supports this type of solution. The problem with this solution is that it is cumbersome; it requires users to remember multiple server names.</p><p>It would be better if we could balance the load automatically. DNS supports this by providing a simple way to implement load balancing. Instead of specifying a single Address RR for a name, we can create several such records, thereby associating more than one IP address with a particular DNS name. When we do this, each time the authoritative name server for the zone in which that name exists resolves that name, it sends all the addresses on the list back to the requester. The server changes the order of the addresses supplied in the response, choosing the order randomly or in a sequential, round-robin fashion. The client will usually use the first address in the list returned by the server, so by changing the list, the server ensures that requests for that device's name are resolved to <a class="indexterm" id="idx-CHP-55-2001"/>multiple hardware units.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-336"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Rather than creating a single Address (A) RR for a DNS domain name, it is possible to create multiple ones. This associates several IP addresses with one name, which can be used to spread a large number of requests for one domain name over many physical IP devices. This allows DNS to implement load balancing for busy Internet servers.</p></div><p>As Internet traffic increases, load balancing is becoming more popular. In early 2003, I saw a survey that indicated approximately 10 percent of Internet names at that time used load balancing—a fairly significant number. Most employed either two or three addresses, but some used as many as sixty addresses! Incidentally, at last check, <a class="ulink" href="http://www.cnn.com">www.cnn.com</a> was associated with eight different IP addresses. (You can check the number of addresses associated with a name using the <code class="literal">host</code> command, as described in <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a>.)</p></div><div class="sect2" title="Using Multiple DNS Servers to Spread Out DNS Requests"><div class="titlepage"><div><div><h2 class="title"><a id="using_multiple_dns_servers_to_spread_out"/>Using Multiple DNS Servers to Spread Out DNS Requests</h2></div></div></div><p>The term <span class="emphasis"><em>DNS load balancing</em></span> also has a completely different meaning from what I described in the previous section. In the discussion of DNS server roles, I talked about how each zone should have at least one slave (secondary) DNS server in addition to the master (primary) server. The usually stated main reason for this is redundancy, in case something happens to cause the master server to fail. However, having a slave server can also allow the load of DNS resolution requests to be balanced between the servers. In fact, some busy domains have more than two servers specifically for this reason.</p><p>Thus, <span class="emphasis"><em>DNS load balancing</em></span> can refer to either using DNS to spread the load of requests (such as web page requests) to a device that is named using DNS or to spreading the load of DNS requests themselves.</p></div></div>
<div class="sect1" title="DNS Name Server Enhancements"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_server_enhancements"/>DNS Name Server Enhancements</h1></div></div></div><p><a class="indexterm" id="idx-CHP-55-2002"/>The fundamentals of operation of DNS servers, as explained in the preceding sections in this chapter, are specified in the main DNS standards, RFC 1034 and 1035. These documents are pretty old by computer industry standards; they were published in 1987. To the credit of the designers of DNS, most of what they originally put into the DNS protocol is still valid and in use today. The creators of DNS knew that it had to be able to scale to a large size, and the system has successfully handled the expansion of the Internet to a degree far beyond what anyone could have imagined 15 or so years ago.</p><p>As originally defined, DNS requires that DNS information be updated manually by editing master files on the master server for a zone. The zone is then copied in its entirety to slave servers using the polling/zone-transfer mechanism described earlier in this chapter. This method is satisfactory when the internetwork is relatively small and changes to a zone are made infrequently. However, in the modern Internet, large zones may require nearly constant changes to their RRs. Hand-editing and constantly copying master files can be impractical, especially when they grow large, and having slave servers get out of date between zone transfers may lead to reliability and performance concerns. For these reasons, several enhancements to the operation of DNS servers have been proposed over the years. We'll take a closer look at three of them here: DNS <a class="indexterm" id="idx-CHP-55-2003"/>Notify, incremental zone transfers, and Dynamic DNS.</p><div class="sect2" title="Automating Zone Transfers: DNS Notify"><div class="titlepage"><div><div><h2 class="title"><a id="automating_zone_transfers_dns_notify"/>Automating Zone Transfers: DNS Notify</h2></div></div></div><p>The first problem that many DNS administrators wanted to tackle was the reliance on polling for updating slave name servers. Imagine that you placed an order for a new music CD at your favorite online music store, but it was out of stock—backordered. Which makes more sense: having you call them every six hours to ask if your CD has arrived yet, or having the store simply call you when it shows up?</p><p>The answer is so obvious that the question seems ridiculous. Yet DNS uses the first model: slave name servers must constantly call up their zone masters and ask them, "Has anything changed yet?" This both generates unnecessary traffic and results in the slave name server being out of date from the time the master <span class="emphasis"><em>does</em></span> change until the next poll is performed. Tweaking the Refresh time for the zone allows only the choice between more polls or more staleness when changes happen; neither is really good.</p><p>To improve this situation, a new technique was developed and formalized in RFC 1996, published in 1996 (weird coincidence!). This standard, "A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)," defines a new DNS message type called <span class="emphasis"><em>Notify</em></span> and describes a protocol for its use. The Notify message is a variation on the standard DNS message type, with some of the fields redefined to support this new feature.</p><p>If both the master and slave name servers support this feature, when a modification is made to an RR, the master server will automatically send a Notify message to its slave server(s), saying, "Your CD has arrived!" er… "The database has changed." The slave then acts as if its Refresh timer had just expired. Enabling this feature allows the Refresh interval to be dramatically increased, since slave servers don't need to constantly poll the master for changes.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-337"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The optional DNS Notify feature allows a master name server to inform slave name servers when changes are made to a zone. This has two advantages: It cuts down on unnecessary polling by the slave servers to find out if changes have occurred to DNS information, and it also reduces the amount of time that slave name servers have out-of-date records.</p></div></div><div class="sect2" title="Improving Zone Transfer Efficiency: Incremental Transfers"><div class="titlepage"><div><div><h2 class="title"><a id="improving_zone_transfer_efficiency_incre"/>Improving Zone Transfer Efficiency: Incremental Transfers</h2></div></div></div><p>The second issue with regular DNS is the need to transfer the entire zone whenever a change to any part of it is made. There are many zones on the Internet that have truly enormous master files that change constantly. Consider the master files for the .COM zone, for example. Having to copy the entire database to slave name servers every time there is a change to even one record is beyond inefficient—it's downright insane!</p><p>RFC 1995, "<a class="indexterm" id="idx-CHP-55-2004"/>Incremental Zone Transfer in DNS," specifies a new type of zone transfer called an <span class="emphasis"><em>incremental zone transfer</em></span>. When this feature is implemented on master and slave name servers in a zone, the master server keeps track of the most recent changes made to the database. Each time a slave server determines that a change has occurred and the slave's database needs to be updated, it sends an IXFR (incremental transfer) query to the master, which contains the serial number of the slave's current copy of the database. The master then looks to see what RRs have changed since that serial number was the current one and sends only the updated RRs to the slave server.</p><p>To conserve storage, the master server obviously doesn't keep all the changes made to its database forever. It will generally track the last few modifications to the database, with the serial number associated with each. If the slave sends an IXFR request that contains a serial number for which recent change information is still on the master server, only the changes are sent in reply. If the request has a serial number so old that the master server no longer has information about some of the changes since that version of the database, a complete zone transfer is performed instead of an incremental one.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-338"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The DNS <span class="emphasis"><em>incremental zone transfer</em></span> enhancement uses a special message type that allows a slave name server to determine what changes have occurred since it last synchronized with the master server. By transferring only the changes, the amount of time and bandwidth used for zone <a class="indexterm" id="idx-CHP-55-2005"/>transfers can be significantly reduced.</p></div></div><div class="sect2" title="Dealing with Dynamic IP Addresses: DNS Update/Dynamic DNS"><div class="titlepage"><div><div><h2 class="title"><a id="dealing_with_dynamic_ip_addresses_dns_up"/>Dealing with Dynamic IP Addresses: DNS Update/Dynamic DNS</h2></div></div></div><p><a class="indexterm" id="idx-CHP-55-2006"/><a class="indexterm" id="idx-CHP-55-2007"/>The third problem with classic DNS is that it assumes changes are made infrequently to zones, so they can be handled by hand-editing master files. Some zones are so large that hand-editing of the master files would be nearly continuous. However, the problem goes beyond just inconvenience. Regular DNS assumes that the IP address for a host is relatively static. Modern networks, however, make use of host technologies such as the Dynamic Host Configuration Protocol (DHCP) (described in <a class="xref" href="pt14.html" title="Part III-3. HOST CONFIGURATION AND TCP/IP HOST CONFIGURATION PROTOCOLS">Part III-3</a>), to assign IP addresses dynamically to devices. When DHCP is used, the IP address of each host in a zone could change on a weekly, daily, or even hourly basis! Clearly, there would be no hope of keeping up with this rate of change using a human being and a text editor.</p><p>In April 1997, RFC 2136, "Dynamic Updates in the Domain Name System (DNS UPDATE)," was published. This standard describes an enhancement to basic DNS operation that allows DNS information to be dynamically updated. When this feature is implemented, the resulting system is sometimes called <span class="emphasis"><em>Dynamic DNS (DDNS)</em></span><a class="indexterm" id="idx-CHP-55-2008"/>.</p><p>RFC 2136 defines a new DNS message type: the Update message. Like the Notify message, the Update message is designed around the structure of regular DNS messages, but with changes to the meanings of several of the fields. As the name implies, Update messages allow RRs to be selectively changed within the master name server for a zone. Using a special message syntax, it is possible to add, delete, or modify RRs.</p><p>Obviously, care must be taken in how this feature is used, since we don't want just anyone to be making changes willy-nilly to our master records. The standard specifies a detailed process for verifying Update messages, as well as security procedures that must be put into place so the server accepts such messages from only certain individuals or systems.</p><p>Dynamic DNS allows administrators to make changes much more easily, but its true power becomes evident only when it is used to integrate DNS with other address-related protocols and services. Dynamic DNS solves a major weakness with traditional DNS: the inability to easily associate a host name with an address assigned using a protocol like DHCP.</p><p>With DNS servers supporting this feature, DNS and DHCP can be integrated, allowing automatic address and name assignment, and automatic update of DNS records when a host's IP address changes. One common application of Dynamic DNS is to allow the use of DNS names by those who access the Internet using a service provider that dynamically assigns IP addresses. Dynamic DNS is similarly used by certain directory services, notably Microsoft's Active Directory, to associate addresses with device names.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-339"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> An enhancement to DNS, commonly called <span class="emphasis"><em>Dynamic DNS (DDNS)</em></span>, allows DNS information in a server's database to be updated automatically, rather than always requiring hand-editing of master files. This can not only save time and energy on the part of administrators, but it also allows DNS to better handle dynamic address assignment, such as the type performed by host configuration protocols like DHCP.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;56.&#xA0;DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS"><div class="titlepage"><div><div><h1 class="title"><a id="dns_resolution_concepts_and_resolver_ope"/>Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e58471"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> In the preceding three chapters, I have described the Domain Name System (DNS) name space, authorities, registration mechanism, and name servers. These elements can all be considered part of the infrastructure of DNS; they are the parts of the system that must be established first to enable it to be used. Once we have these components in place, we can actually get down to the business at hand: name resolution. This is accomplished using a specific set of procedures carried out by DNS clients called <span class="emphasis"><em>resolvers</em></span>.</p><p>In this chapter, I describe DNS name resolvers and the process of name resolution itself. I begin with an overview of the functions performed by DNS resolvers and how they work in general terms. I then describe the two fundamental methods of name resolution used in DNS: iterative and recursive resolution. I discuss the way that resolvers improve efficiency through local resolution and caching. I describe the steps in the actual name resolution algorithm. I then cover two special cases of name resolution: reverse name resolution using the special IN-ADDR.ARPA domain, and the way that DNS provides mail support using Mail Exchange resource records.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-340"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>The information in this section complements that in the previous chapter on DNS name servers. I assume in the topics here that you have at least basic familiarity with DNS servers</em></span>.</p></div><div class="sect1" title="DNS Resolver Functions and General Operation"><div class="titlepage"><div><div><h1 class="title"><a id="dns_resolver_functions_and_general_opera"/>DNS Resolver Functions and General Operation</h1></div></div></div><p>Name servers are arguably the most important part of the DNS system as a whole. After all, they store all the data on the system and actually provide the addresses we need when names are given to them. Without these servers, there would be no DNS at all. Of course, what use is a server if nobody is asking for service? The clients in the system, called <span class="emphasis"><em>resolvers</em></span>, are also important, because they initiate the process of name resolution. Resolvers are where the rubber meets the road, so to speak.<a class="indexterm" id="idx-CHP-56-2009"/></p><p>The operation of DNS resolvers is explained in the two main DNS standards. RFC 1034 describes the functions performed by resolvers and how they work in general terms. This includes a discussion of the algorithm used to conduct name resolution. RFC 1035 deals more with the implementation details of resolvers and the fine points of how they do their jobs. Several subsequent standards have modified these base standards, changing some of the ways that resolvers work in different ways.</p><div class="sect2" title="Name Resolution Services"><div class="titlepage"><div><div><h2 class="title"><a id="name_resolution_services"/>Name Resolution Services</h2></div></div></div><p>Just as the main job of a DNS server is to store DNS name data and serve it when it receives requests, the main job of a DNS resolver is to, well, resolve. While most people think of name resolution as only the process of transforming a DNS name into an IP address, this is just one of several types of resolution services performed by DNS. The following are a few of the most typical types of DNS resolution:</p><p><span class="strong"><strong>Standard Name Resolution</strong></span> Taking a DNS name as input and determining its corresponding IP address.</p><p><span class="strong"><strong>Reverse Name Resolution</strong></span> Taking an IP address and determining what name is associated with it.</p><p><span class="strong"><strong>Electronic Mail Resolution</strong></span> Determining where to send electronic mail (email) messages based on the email address used in a message.</p></div><div class="sect2" title="Functions Performed by Name Resolvers"><div class="titlepage"><div><div><h2 class="title"><a id="functions_performed_by_name_resolvers"/>Functions Performed by Name Resolvers</h2></div></div></div><p>There are other types of resolution activities as well, though again, most name resolution requests are of the standard variety, making it the primary focus in our discussion. To accomplish this task, name resolvers perform a number of related functions:</p><p><span class="strong"><strong>Providing the <a class="indexterm" id="idx-CHP-56-2010"/>User Interface</strong></span> Normal name resolution usually doesn't involve explicitly running a piece of resolver software. In your web browser, you don't have to say, "Please find the IP address for <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>," and then say, "Please connect to this IP address for XYZ Industries." You just type <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>, and the name resolution happens. There is no magic involved. The resolver is just called <span class="emphasis"><em>implicitly</em></span> instead of explicitly. The web browser recognizes that a name has been entered instead of an IP address and feeds it to the resolver, saying, "I need you to resolve this name, please." (Hey, it never hurts to be polite.) The resolver takes care of resolution and provides the IP address to the web browser, which connects to the site. Thus, the resolver is the interface between the user (both the human user and the software user, the browser) and the DNS system.</p><p><span class="strong"><strong>Forming and Sending Queries</strong></span> Given a name to resolve, the DNS resolver must create an appropriate query using the DNS messaging system, determine what type of resolution to perform, and send the query to the appropriate name server.</p><p><span class="strong"><strong>Processing Responses</strong></span> The resolver must accept back responses from the DNS server to which it sent its query and decide what to do with the information within the reply. As you'll see, it may be necessary for more than one server to be contacted for a particular name resolution.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-341"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The primary clients in DNS are software modules called DNS <span class="emphasis"><em>name resolvers</em></span>. They are responsible for accepting names from client software, generating resolution requests to DNS servers, and processing and returning responses.</p></div><p>These tasks seem fairly simple, and they are in some ways, but implementation can become rather complicated. The resolver may need to juggle several outstanding name resolutions simultaneously. It must keep track of the different requests, queries, and responses and make sure everything is kept straight.</p><p>Name resolvers don't need to perform nearly as many administrative jobs as name servers do; clients are usually simpler than servers in this regard. One important support function that many name resolvers do perform, however, is caching. Like name servers, name resolvers can cache the results of the name resolutions they perform to save time if the same resolution is required again. (Not all resolvers perform caching, however.)</p><p>Even though resolvers are the DNS components that are most associated with name resolution, name servers can also act as clients in certain types of name resolution. In fact, it is possible to set up a network so that the resolvers on each of the client machines do nothing more than hand resolution requests to a local DNS server and let the server take care of it. In this case, the client resolver becomes little more than a shell, sometimes called a <span class="emphasis"><em>stub resolver</em></span>. This has the advantage of centralizing name resolution for the network, but a potential disadvantage of performance reduction.<a class="indexterm" id="idx-CHP-56-2011"/></p></div></div></div>
<div class="sect1" title="DNS Name Resolution Techniques: Iterative and Recursive Resolution"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_resolution_techniques_iterative"/>DNS Name Resolution Techniques: Iterative and Recursive Resolution</h1></div></div></div><p>Conventional name resolution transforms a DNS name into an IP address. At the highest level, this process can be considered to have two phases. In the first phase, we locate a DNS name server that has the information we need: the address that goes with a particular name. In the second phase, we send that server a request containing the name we want to resolve, and it sends back the address required.<a class="indexterm" id="idx-CHP-56-2012"/></p><p>Somewhat ironically, the second phase (the actual mapping of the name into an address) is fairly simple. It is the first phase—finding the right server—that is potentially difficult and represents most of the work in DNS name resolution. While perhaps surprising, this is a predictable result of how DNS is structured. Name information in DNS is not centralized, but rather distributed throughout a hierarchy of servers, each of which is responsible for one zone in the DNS name space. This means we must follow a special sequence of steps to find the server that has the information we need.</p><p>The formal process of <a class="indexterm" id="idx-CHP-56-2013"/>name resolution parallels the treelike hierarchy of the DNS name space, authorities, and servers. Resolution of a particular DNS name starts with the most general part of the name and proceeds to the most specific part. Naturally, the most general part of every name is the <span class="emphasis"><em>root</em></span> of the DNS tree, represented in a name as a trailing dot (.), sometimes omitted. The next most specific part is the top-level domain (TLD), then the second-level domain, and so forth. The DNS name servers are linked in that the DNS server at one level knows the name of the servers that are responsible for subdomains in zones below it at the next level.</p><p>Suppose we start with C.B.A. as the fully qualified domain name (FQDN). Formally, every name resolution begins with the root of the tree—this is why the root name servers are so important. It's possible that the root name servers are authoritative for this name, but this is probably not the case; that's not what the root name servers are usually used for. What the root name server does know is the name of the server responsible for the TLD: A.. The name server for A. may have the information to resolve C.B.A., but it's still fairly high level, so C.B.A. is probably not directly within its zone. In that case, it will not know the address we seek, but it will know the name of the server responsible for B.A.. In turn, that name server may be authoritative for C.B.A., or it may just know the address of the server for C.B.A., which will have the information we need. As you can see, it is very possible that several different servers may be needed in a name resolution.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-342"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since DNS name information is stored as a distributed database spread across many servers, name resolution cannot usually be performed using a single request/response communication. It is first necessary to find the server that has the information that the resolver requires. This usually requires a sequence of message exchanges, starting from a root name server and proceeding down to the specific server containing the resource records (RRs) that the client requires.</p></div><p>The DNS standards actually define two distinct ways of following this hierarchy of servers to discover the correct one. They both eventually lead to the right device, but they differ in how they assign responsibility for resolution when it requires multiple steps. The two techniques are <span class="emphasis"><em>iterative resolution</em></span> and <span class="emphasis"><em>recursive resolution</em></span>.<a class="indexterm" id="idx-CHP-56-2014"/></p><div class="sect2" title="Iterative Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="iterative_resolution"/>Iterative Resolution</h2></div></div></div><p>When a client sends an iterative request to a name server, the server responds with either the answer to the request (for a regular resolution, the IP address we want) <span class="emphasis"><em>or</em></span> the name of another server that has the information or is closer to it. The original client must then <span class="emphasis"><em>iterate</em></span> by sending a new request to this referred server, which again may either answer it or provide another server name. The process continues until the correct server is found. The iterative resolution method is illustrated in <a class="xref" href="ch56s02.html#iterative_dns_name_resolution_in_this_ex" title="Figure 56-1. Iterative DNS name resolution In this example, the client is performing a name resolution for C.B.A. using strictly iterative resolution. It is thus responsible for forming all DNS requests and processing all replies. It starts by sending a request to the root name server for this mythical hierarchy. That server doesn't have the address of C.B.A., so it instead returns the address of the name server for A. The client then sends its query to that name server, which points the client to the server for B.A. That name server refers the client to the name server that actually has the address for C.B.A., which returns it to the client. Contrast this to Figure 56-2.">Figure 56-1</a>.</p><div class="figure"><a id="iterative_dns_name_resolution_in_this_ex"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e58639"/><img alt="Iterative DNS name resolution In this example, the client is performing a name resolution for C.B.A. using strictly iterative resolution. It is thus responsible for forming all DNS requests and processing all replies. It starts by sending a request to the root name server for this mythical hierarchy. That server doesn't have the address of C.B.A., so it instead returns the address of the name server for A. The client then sends its query to that name server, which points the client to the server for B.A. That name server refers the client to the name server that actually has the address for C.B.A., which returns it to the client. Contrast this to ." src="httpatomoreillycomsourcenostarchimages288171.png.jpg"/></div></div><p class="title">Figure 56-1. Iterative DNS name resolution In this example, the client is performing a name resolution for C.B.A. using strictly iterative resolution. It is thus responsible for forming all DNS requests and processing all replies. It starts by sending a request to the root name server for this mythical hierarchy. That server doesn't have the address of C.B.A., so it instead returns the address of the name server for A. The client then sends its query to that name server, which points the client to the server for B.A. That name server refers the client to the name server that actually has the address for C.B.A., which returns it to the client. Contrast this to <a class="xref" href="ch56s02.html#recursive_dns_name_resolution_this_is_th" title="Figure 56-2. Recursive DNS name resolution This is the same theoretical DNS resolution shown in Figure 56-1, but this time, the client asks for the name servers to perform recursive resolution, and they agree to do so. As in the iterative case, the client sends its initial request to the root name server. That server doesn't have the address of C.B.A., but instead of merely returning to the client the address of the name server for A., it sends a request to that server itself. That name server sends a request to the server for B.A., which sends a request to the server for C.B.A.. The address of C.B.A. is then carried back up the chain of requests, from the server of C.B.A. to that of B.A., then A., then the root, and then finally, back to the client.">Figure 56-2</a>.</p></div></div><div class="sect2" title="Recursive Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="recursive_resolution"/>Recursive Resolution</h2></div></div></div><p>When a client sends a <a class="indexterm" id="idx-CHP-56-2015"/>recursive request to a name server, the server responds with the answer if it has the information sought. If it doesn't, the server takes responsibility for finding the answer by becoming a client on behalf of the original client and sending new requests to other servers. The original client sends only one request and eventually gets the information it wants (or an error message if it is not available). This technique is shown in <a class="xref" href="ch56s02.html#recursive_dns_name_resolution_this_is_th" title="Figure 56-2. Recursive DNS name resolution This is the same theoretical DNS resolution shown in Figure 56-1, but this time, the client asks for the name servers to perform recursive resolution, and they agree to do so. As in the iterative case, the client sends its initial request to the root name server. That server doesn't have the address of C.B.A., but instead of merely returning to the client the address of the name server for A., it sends a request to that server itself. That name server sends a request to the server for B.A., which sends a request to the server for C.B.A.. The address of C.B.A. is then carried back up the chain of requests, from the server of C.B.A. to that of B.A., then A., then the root, and then finally, back to the client.">Figure 56-2</a>.</p></div><div class="sect2" title="Contrasting Iterative and Recursive Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="contrasting_iterative_and_recursive_reso"/>Contrasting Iterative and Recursive Resolution</h2></div></div></div><p>To help explain the difference between iterative and recursive resolution, let's take a side trip to a real-world case. Suppose you are trying to find the phone number of your old friend Carol, with whom you haven't spoken in years. You call your friend Joe. He doesn't have Carol's number, but he gives you John's number, suggesting you call him. So you call John. He doesn't have the information, but he knows the number of Carol's best friend, Debbie, and gives that to you. You call Debbie, and she gives you Carol's information. This is an example of an iterative process.<a class="indexterm" id="idx-CHP-56-2016"/></p><div class="figure"><a id="recursive_dns_name_resolution_this_is_th"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e58672"/><img alt="Recursive DNS name resolution This is the same theoretical DNS resolution shown in , but this time, the client asks for the name servers to perform recursive resolution, and they agree to do so. As in the iterative case, the client sends its initial request to the root name server. That server doesn't have the address of C.B.A., but instead of merely returning to the client the address of the name server for A., it sends a request to that server itself. That name server sends a request to the server for B.A., which sends a request to the server for C.B.A.. The address of C.B.A. is then carried back up the chain of requests, from the server of C.B.A. to that of B.A., then A., then the root, and then finally, back to the client." src="httpatomoreillycomsourcenostarchimages288173.png.jpg"/></div></div><p class="title">Figure 56-2. Recursive DNS name resolution This is the same theoretical DNS resolution shown in <a class="xref" href="ch56s02.html#iterative_dns_name_resolution_in_this_ex" title="Figure 56-1. Iterative DNS name resolution In this example, the client is performing a name resolution for C.B.A. using strictly iterative resolution. It is thus responsible for forming all DNS requests and processing all replies. It starts by sending a request to the root name server for this mythical hierarchy. That server doesn't have the address of C.B.A., so it instead returns the address of the name server for A. The client then sends its query to that name server, which points the client to the server for B.A. That name server refers the client to the name server that actually has the address for C.B.A., which returns it to the client. Contrast this to Figure 56-2.">Figure 56-1</a>, but this time, the client asks for the name servers to perform recursive resolution, and they agree to do so. As in the iterative case, the client sends its initial request to the root name server. That server doesn't have the address of C.B.A., but instead of merely returning to the client the address of the name server for A., it sends a request to that server itself. That name server sends a request to the server for B.A., which sends a request to the server for C.B.A.. The address of C.B.A. is then carried back up the chain of requests, from the server of C.B.A. to that of B.A., then A., then the root, and then finally, back to the client.</p></div><p>In contrast, suppose you call Joe and Joe says, "I don't know, but I think I know how to find out." He calls John, and then Debbie, and then calls you back with the phone number. That would be like <a class="indexterm" id="idx-CHP-56-2017"/>recursive resolution.<a class="indexterm" id="idx-CHP-56-2018"/></p><p>So, in essence, iteration is like doing the job yourself, while recursion is like passing the buck. You might think that everyone would always want to use recursion since it makes the other guy do the work. This is true, but passing the buck is not considered good form if it is not done with permission. Not all name servers support recursion, especially servers near the top of the hierarchy. Obviously, we don't want to bog down certain name servers—such as the root name servers, the ones that handle .COM, and other critical TLDs—with doing recursion. It is for this reason that clients must request that name servers perform recursion for them. One place where recursion is often used is with the local name server on a network. Rather than making client machine resolvers perform iterative resolution, it is common for the resolver to generate a <a class="indexterm" id="idx-CHP-56-2019"/>recursive request to the local DNS server, which then generates iterative requests to other servers as needed. As you can see, recursive and iterative requests can be combined in a single resolution, providing significant flexibility to the process as a whole. This is demonstrated in a more realistic example in the "DNS Name Resolution Process" section later in this chapter.</p><p>Again, remember that for the purpose of understanding resolution, a DNS server can act as a client. As soon as a DNS server accepts a recursive request for resolution on a name it cannot resolve itself, it becomes a client in the process. Also, it is common for resolvers to know the names of not one, but two local DNS servers, so if a problem occurs reaching the first, they can try the second.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-343"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The two methods of name resolution in DNS are <span class="emphasis"><em>iterative resolution</em></span> and <span class="emphasis"><em>recursive resolution</em></span>. In iterative resolution, if a client sends a request to a name server that does not have the information the client needs, the server returns a pointer to a different name server, and the client sends a new request to that server. In recursive resolution, if a client sends a request to a server that doesn't have the requested information, that server takes on the responsibility for sending requests to other servers to find the necessary records, and then returns them to the client. A server doing this takes on the role of client for its requests to other servers.</p></div></div></div>
<div class="sect1" title="DNS Name Resolution Efficiency Improvements: Caching and Local Resolution"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_resolution_efficiency_improveme"/>DNS Name Resolution Efficiency Improvements: Caching and Local Resolution</h1></div></div></div><p>The basic resolution techniques—iterative and recursive—can be considered complete from an algorithmic standpoint. By starting at the top (root) and working our way down, we are "guaranteed" to always eventually arrive at the server that has the information we need. I put <span class="emphasis"><em>guaranteed</em></span> in quotation marks because, as always, there are no real guarantees in networking—we might have asked for a nonexistent name, or a server might have bad data, for example. But in the absence of such atypical problems, the process leads to the information eventually.<a class="indexterm" id="idx-CHP-56-2020"/><a class="indexterm" id="idx-CHP-56-2021"/></p><p>The problem is that last word: <span class="emphasis"><em>eventually</em></span>. Both iterative and recursive resolution will get us to the right server, but they take a long time to do it, especially if the name we are trying to resolve is in a deep part of the DNS hierarchy (for example, F.E.D.C.B.A.). Since resolution is done so often, it is helpful to define changes to the basic resolution process that improve efficiency as much as possible.</p><div class="sect2" title="The Motivation for Caching: Locality of Reference"><div class="titlepage"><div><div><h2 class="title"><a id="the_motivation_for_caching_locality_of_r"/>The Motivation for Caching: Locality of Reference</h2></div></div></div><p>A computer science principle called <span class="emphasis"><em>locality of reference</em></span> describes two common phenomena related to how computers (and networks) are used. The first, sometimes called <span class="emphasis"><em>spatial locality of reference</em></span>, observes that a resource is more likely to be referenced if it is near another resource that was recently referenced. The second, <span class="emphasis"><em>temporal locality of reference</em></span>, says a resource is more likely to be accessed if it was recently accessed.<a class="indexterm" id="idx-CHP-56-2022"/><a class="indexterm" id="idx-CHP-56-2023"/></p><p>We can observe both of these phenomena by using the example of browsing the Web. To observe <a class="indexterm" id="idx-CHP-56-2024"/>spatial locality of reference, notice what happens when you visit a site such as <a class="ulink" href="http://www.tcpipguide.com">http://www.tcpipguide.com</a>. The initial request asks the server for the main index document of <span class="emphasis"><em>The TCP/IP Guide</em></span>. However, that document contains links to several images and other items, all of which are also located at the domain <a class="ulink" href="http://tcpipguide.com">tcpipguide.com</a>. When your browser asks for the main document, it will shortly thereafter also ask for a number of graphics. As you navigate the site, you will click links to go to other web pages. Again, most of these will be at the same domain, <a class="ulink" href="http://tcpipguide.com">tcpipguide.com</a>.</p><p>What this means is that if we resolve a particular domain name, it is likely that we will need to resolve it again very soon in the future. It would be silly to need to interrogate the same domain server dozens of times, asking it to resolve the same name each time.</p><p>The second phenomenon, <span class="emphasis"><em>temporal locality of reference</em></span>, is one you have probably noticed yourself. You are far more likely to access a resource you have used recently than one you have not looked at in a year. This means that maintaining information about recently used resources can be inherently advantageous.</p><p>These two phenomena are the rationale for <a class="indexterm" id="idx-CHP-56-2025"/>caching in the computer world in general, and as you have seen in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a>, in DNS servers in particular. The same advantages apply to resolvers, and many of them perform caching also, in a way rather similar to how it is done in servers.</p></div><div class="sect2" title="Name Resolver Caching"><div class="titlepage"><div><div><h2 class="title"><a id="name_resolver_caching"/>Name Resolver Caching</h2></div></div></div><p>On a particular client computer, once a particular name is resolved, it is cached and remains ready for the next time it is needed. Again, this eliminates traffic and load on DNS servers. (Note, however, that not all resolvers perform caching.)</p><p>You might be wondering why we bother having caching on both resolvers and servers. This is not redundant, as it may appear. Or rather, it's redundant, but in a good way. To understand why, we must recognize that a fundamental trade-off in caching is that a cache provides better performance the closer it is the requester of the data, but better coverage the farther it is from the user.</p><p>If resolvers didn't cache results but our local server did, we could get the information from the server's cache, but it would require waiting for the exchange of a query and response. The resolver's cache is closer to the user and so more efficient. At the same time, this doesn't obviate the need for caching at our network's local DNS server. The server is farther away from the user than the resolver, but its cache is shared by many machines. They can all benefit from its cache. For example, if you look up a particular name, and then someone else does a few minutes later, she can use your cached resolution, even though she is typing it for the first time.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-344"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In addition to the caching performed by DNS name servers, many (but not all) DNS resolvers also cache the results of recent resolution requests. This cache is checked prior to beginning a name resolution, to save time when multiple requests are made for the same name.</p></div><p>Caching by name resolvers follows the same general principles and rules as caching by name servers, outlined in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a>. The amount of time a resource record (RR) is held in the cache is specified by its Time to Live (TTL) value. Also, resolvers will not cache the results of certain queries, such as reverse lookups, and may also not cache a resolution if they suspect (for whatever reason) that the data returned is unreliable or corrupted.</p></div><div class="sect2" title="Local Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="local_resolution"/>Local Resolution</h2></div></div></div><p>One other area where resolution efficiency can be improved is the special case where we are trying to resolve the names of computers in our own organizations. Suppose that you, an employee at XYZ Industries, want to get some sales information using the File Transfer Protocol (FTP) from <a class="ulink" href="http://sales.xyzindustries.com">sales.xyzindustries.com</a>. Your FTP client will invoke your local resolver to resolve that name, by sending it to your local DNS server. Now, would it be smart for that server, which is here inside the company, to start the resolution process up at the root name server? Not really.<a class="indexterm" id="idx-CHP-56-2026"/></p><p>The local DNS server that accepts local resolution requests from resolvers on the network may be the authoritative name server for <a class="ulink" href="http://sales.xyzindustries.com">sales.xyzindustries.com</a>. In other cases, it may know how to answer certain resolution requests directly. Obviously, it makes sense for the server to check to see if it can answer a resolver's query before heading up to the root server, since this provides a faster answer to the client and saves internetwork traffic. This is called <span class="emphasis"><em>local resolution</em></span>.</p><p>Most DNS servers will perform this check to see if they have the information needed for a request before commencing the formal top-down resolution process. The exception is DNS servers that do not maintain information about any zones: <span class="emphasis"><em>caching-only servers</em></span>. In some cases, DNS resolvers on client machines may also have access to certain local zone information, in which case, they can use it instead of sending a resolution query at all.</p><div class="note" title="Note"><h3 class="title"><a id="note-137"/>Note</h3><p><span class="emphasis"><em>Most operating systems support the use of the old host table mechanism (described in <a class="xref" href="ch51.html" title="Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM">Chapter 51</a>), which can be useful for local machines on a network. If a host has a host table, the resolver will check the host table to see if it can find a mapping for a name before it will bother with the more time-consuming DNS resolution process. This is not technically part of DNS, but is often used in conjunction with it</em></span>.</p></div></div></div>
<div class="sect1" title="DNS Name Resolution Process"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_resolution_process"/>DNS Name Resolution Process</h1></div></div></div><p>In the first half of this chapter, I have described what name resolvers do, explained the basic top-down resolution process using iterative and recursive resolution, and discussed how local resolution and caching are used to improve resolution performance. Now it's time to tie all this background material together and see how the name resolution process works as a whole.<a class="indexterm" id="idx-CHP-56-2027"/></p><p>As usual, the best way to do this is by <a class="indexterm" id="idx-CHP-56-2028"/>example. Here, I will actually combine two examples I have used earlier: the fictitious company XYZ Industries and the nonexistent college, Googleplex University.</p><div class="sect2" title="A Simple Example of DNS Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="a_simple_example_of_dns_name_resolution"/>A Simple Example of DNS Name Resolution</h2></div></div></div><p>Let's say that XYZ Industries runs its own DNS servers for the <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a> zone. The master name server is called <a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a>, and the slave is <a class="ulink" href="http://ns2.xyzindustries.com">ns2.xyzindustries.com</a>. These are also used as local DNS servers for resolvers on client machines. We'll assume for this example that, as is often the case, our DNS servers will accept recursive requests from machines within our company, but we will not assume that other machines will accept such requests. Let's also assume that both the server and resolver perform caching, and that the caches are empty.</p><p>Let's say that Googleplex University runs its own DNS servers for the googleplex.edu domain, as in the example in <a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a>. There are three subdomains: finearts.googleplex.edu, compsci.googleplex.edu, and admin.googleplex.edu. Of these, compsci.googleplex.edu is in a separate zone with dedicated servers, while the other subdomains are in the googleplex.edu zone (see <a class="xref" href="ch54s06.html#dns_zones_of_authority_cuts_can_be_made_" title="Figure 54-2. DNS zones of authority Cuts can be made between nodes in the DNS name tree to create an arbitrary hierarchy of name authorities. This example shows the DNS tree branch for googleplex.edu, with each zone indicated using a different shading. IANA/ICANN is responsible for the root domain, and a separate authority named Educause takes care of .EDU. The third zone covers much of googleplex.edu, except that a cut has been made between googleplex and compsci to create an independent zone of authority for compsci.googleplex.edu.">Figure 54-2</a>).</p><p>Now, suppose you are an employee within XYZ Industries and one of your clients is in charge of the networking department at Googleplex U. You type into your web browser the address of that department's web server, <a class="ulink" href="http://www.net.compsci.googleplex.edu">www.net.compsci.googleplex.edu</a>. In simplified terms, the procedure would involve the following steps (<a class="xref" href="ch56s04.html#example_of_the_dns_name_resolution_proce" title="Figure 56-3. Example of the DNS name resolution process This fairly complex example illustrates a typical DNS name resolution using both iterative and recursive resolution. The user types a DNS name (www.net.compsci.googleplex.edu) into a web browser, which causes a DNS resolution request to be made from her client machine's resolver to a local DNS name server. That name server agrees to resolve the name recursively on behalf of the resolver, but uses iterative requests to accomplish it. These requests are sent to a DNS root name server, followed in turn by the name servers for .edu, googleplex.edu, and compsci.googleplex.edu. The IP address is then passed to the local name server and then back to the user's resolver, and finally, to her web browser software.">Figure 56-3</a> shows the process graphically):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Your web browser recognizes the request for a name and invokes your local resolver, passing to it the name <a class="ulink" href="http://www.net.compsci.googleplex.edu">www.net.compsci.googleplex.edu</a>.</p></li><li class="listitem"><p>The resolver checks its cache to see if it already has the address for this name. If it does, it returns it immediately to the web browser, but in this case, we are assuming that it does not. The resolver also checks to see if it has a local host table file. If so, it scans the file to see if this name has a static mapping. If so, it resolves the name using this information immediately. Again, let's assume it does not, since that would be boring.</p></li><li class="listitem"><p>The resolver generates a recursive query and sends it to <a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> (using that server's IP address, of course, which the resolver knows).</p></li><li class="listitem"><p>The local DNS server receives the request and checks its cache. Again, let's assume it doesn't have the information needed. If it did, it would return the information, marked non-authoritative, to the resolver. The server also checks to see if it has in its zone resource records that can resolve <a class="ulink" href="http://www.net.compsci.googleplex.edu">www.net.compsci.googleplex.edu</a>. Of course, it does not in this case, since they are in totally different domains.</p></li><li class="listitem"><p><a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> generates an iterative request for the name and sends it to a root name server.</p></li><li class="listitem"><p>The root name server does not resolve the name. It returns the name and address of the name server for the .edu domain.</p></li><li class="listitem"><p><a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> generates an iterative request and sends it to the name server for .edu.</p></li><li class="listitem"><p>The name server for .edu returns the name and address of the name server for the googleplex.edu domain.</p></li><li class="listitem"><p><a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> generates an iterative request and sends it to the name server for googleplex.edu.</p></li><li class="listitem"><p>The name server for googleplex.edu consults its records. It sees, however, that this name is in the compsci.googleplex.edu subdomain, which is in a separate zone. It returns the name server for that zone.</p></li><li class="listitem"><p><a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> generates an iterative request and sends it to the name server for compsci.googleplex.edu.</p></li><li class="listitem"><p>The name server for compsci.googleplex.edu is authoritative for <a class="ulink" href="http://www.net.compsci.googleplex.edu">www.net.compsci.googleplex.edu</a>. It returns the IP address for that host to <a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a>.</p></li><li class="listitem"><p><a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> caches this resolution.</p></li><li class="listitem"><p>The local name server returns the resolution to the resolver on your local machine.</p></li><li class="listitem"><p>Your local resolver also caches the information.</p></li><li class="listitem"><p>The local resolver gives the address to your browser.</p></li><li class="listitem"><p>Your browser commences an HTTP request to the Googleplex machine's IP address.</p></li></ol></div><p>This seems rather complicated and slow. Of course, computers work faster than you can read (or I can type, for that matter). Even given that, the benefits of caching are obvious—if the name were in the cache of the resolver or the local DNS server, most of these steps would be avoided.</p><p>Note that this <a class="indexterm" id="idx-CHP-56-2029"/>example is highly simplified and also shows only one possible way that servers might be set up. For one thing, it is possible that even though compsci.googleplex.edu is in a separate zone from googleplex.edu, they might use the same server. In that case, one iteration in the process would be skipped. The example also doesn't show what happens if an error occurs in the process. Also, if the name entered were an alias, indicated by a CNAME record, this would change the processing as well.</p><div class="figure"><a id="example_of_the_dns_name_resolution_proce"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e58984"/><img alt="Example of the DNS name resolution process This fairly complex example illustrates a typical DNS name resolution using both iterative and recursive resolution. The user types a DNS name (www.net.compsci.googleplex.edu) into a web browser, which causes a DNS resolution request to be made from her client machine's resolver to a local DNS name server. That name server agrees to resolve the name recursively on behalf of the resolver, but uses iterative requests to accomplish it. These requests are sent to a DNS root name server, followed in turn by the name servers for .edu, googleplex.edu, and compsci.googleplex.edu. The IP address is then passed to the local name server and then back to the user's resolver, and finally, to her web browser software." src="httpatomoreillycomsourcenostarchimages288175.png.jpg"/></div></div><p class="title">Figure 56-3. Example of the DNS name resolution process This fairly complex example illustrates a typical DNS name resolution using both iterative and recursive resolution. The user types a DNS name (<a class="ulink" href="http://www.net.compsci.googleplex.edu">www.net.compsci.googleplex.edu</a>) into a web browser, which causes a DNS resolution request to be made from her client machine's resolver to a local DNS name server. That name server agrees to resolve the name recursively on behalf of the resolver, but uses iterative requests to accomplish it. These requests are sent to a DNS root name server, followed in turn by the name servers for .edu, googleplex.edu, and compsci.googleplex.edu. The IP address is then passed to the local name server and then back to the user's resolver, and finally, to her web browser software.</p></div></div><div class="sect2" title="Changes to Resolution to Handle Aliases (CNAME Records)"><div class="titlepage"><div><div><h2 class="title"><a id="changes_to_resolution_to_handle_aliases_"/>Changes to Resolution to Handle Aliases (CNAME Records)</h2></div></div></div><p>CNAME records are used to allow a constant name for a device to be presented to the outside world, while allowing the actual device that corresponds to the name to vary inside the organization. When a CNAME is used, it changes the name resolution process by adding an extra step: First we resolve the alias to the canonical name, and then we resolve the canonical name.</p><p>For example, web servers are almost always named starting with www., so at XYZ Industries, we want people to be able to find our website at <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>. However, the web server may be shared with other services on <a class="ulink" href="http://bigserver.xyzindustries.com">bigserver.xyzindustries.com</a>. We can set up a CNAME record to point <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> to <a class="ulink" href="http://bigserver.xyzindustries.com">bigserver.xyzindustries.com</a>. Resolution of www will result in a CNAME pointing to bigserver, which is then itself resolved. If in the future, our business grows and we decide to upgrade our web service to run on <a class="ulink" href="http://biggerserver.xyzindustries.com">biggerserver.xyzindustries.com</a>, we just change the CNAME record, and users are unaffected.</p></div></div>
<div class="sect1" title="DNS Reverse Name Resolution Using the IN-ADDR.ARPA Domain"><div class="titlepage"><div><div><h1 class="title"><a id="dns_reverse_name_resolution_using_the_in"/>DNS Reverse Name Resolution Using the IN-ADDR.ARPA Domain</h1></div></div></div><p>If most people were asked to identify the core job of DNS to one function, they would probably say it was converting the names of objects into the numeric IP addresses associated with them. (Well, they would if they knew much about DNS.) For this reason, DNS is sometimes compared to a telephone book, or to telephone 411 (information) service. There are certain problems with this analogy, but at the highest level, it is valid. In both cases, we take a name, consult a database (of one type or another), and produce from it a number that matches that name.<a class="indexterm" id="idx-CHP-56-2030"/><a class="indexterm" id="idx-CHP-56-2031"/></p><p>In the real world, there are sometimes situations where you don't want to find the phone number that goes with a name, but rather, you have a phone number and want to know what person it belongs to. For example, this might happen if your telephone records the number of incoming calls but you don't have caller ID to display the name associated with a number. You might also find a phone number on a piece of paper and not remember whose number it is.</p><p>Similarly, in the networking world, there are many situations where we have an IP address and want to know what name goes with it. For example, a World Wide Web server records the IP address of each device that connects to it in its server logs, but these numbers are generally meaningless to humans, who prefer to see the names that go with them. A more serious example might be a hacker trying to break into your computer; by converting the IP address into a name, you might be able to find out what part of the world he is from, what Internet service provider (ISP) he is using, and so forth. There are also many reasons why a network administrator might want to find out the name that goes with an address, for setup or troubleshooting purposes.</p><p>DNS originally included a feature called <span class="emphasis"><em>inverse querying</em></span> that would allow this type of "opposite" resolution.</p><div class="sect2" title="The Original Method: Inverse Querying"><div class="titlepage"><div><div><h2 class="title"><a id="the_original_method_inverse_querying"/>The Original Method: Inverse Querying</h2></div></div></div><p>For <a class="indexterm" id="idx-CHP-56-2032"/>inverse querying, a resolver could send a query which, instead of having a name filled in and a space for the server to fill in the IP address, had the IP address and a space for the name. The server would check its RRs and return the name to the resolver.</p><p>This works fine in theory, and even in practice, if the internetwork is very small. However, remember that due to the distributed nature of DNS information, the biggest part of the job of resolution is finding the right server. Now, in the case of regular resolution, we can easily find the right server by traversing the hierarchy of servers. This is possible because the servers are connected together following a hierarchy of names.</p><p>DNS servers are not, however, arranged based on IP address. This means that to use inverse queries, we need to use the right name server for the IP address we want to resolve into a name, with no easy way to find out what it is. Sure, we could try sending the inverse query to the authoritative DNS server for every zone in the hierarchy. If you tried, it would probably take you longer than it took to write this book, so let's not go there. The end result of all of this is that inverse queries were never popular, except for local server troubleshooting. They were formally removed from DNS in November 2002 through the publishing of RFC 3425.</p><p>So, what to do? Well, the problem is that the servers are arranged by name and not by IP address. The solution, therefore, is as simple as it sounds: Arrange the servers by IP address. This doesn't mean we remove the name hierarchy, or duplicate all the servers, or anything silly like that. Instead, we create an additional, numerical hierarchy that coexists with the name hierarchy. We then use this to find names from numbers, using a process commonly called <span class="emphasis"><em>reverse name resolution</em></span>.</p></div><div class="sect2" title="The IN-ADDR.ARPA Name Structure for Reverse Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="the_in-addrarpa_name_structure_for_rever"/>The IN-ADDR.ARPA Name Structure for Reverse Resolution</h2></div></div></div><p>The name hierarchy for the Internet is implemented using a special domain called <span class="emphasis"><em>IN-ADDR.ARPA</em></span>, located within the reserved .ARPA TLD (<span class="emphasis"><em>IN-ADDR</em></span> stands for <span class="emphasis"><em>INternet ADDRess</em></span>). Recall from the discussion in <a class="xref" href="ch54.html" title="Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES">Chapter 54</a> that .ARPA was originally used to transition old Internet hosts to DNS and is now used by the folks that run the Internet for various purposes.</p><p>A special numerical hierarchy is created within IN-ADDR.ARPA that covers the entire IP address space (see <a class="xref" href="ch56s05.html#the_dns_in-addrarpa_reverse_name_resolut" title="Figure 56-4. The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special IN-ADDR.ARPA hierarchy was created to allow easy reverse lookups of DNS names. IN-ADDR.ARPA contains 256 subdomains numbered 0 to 255, each of which has 256 subdomains numbered 0 to 255, and so forth, down to four levels. Thus, each IP address is represented in the hierarchy. This example shows the DNS domain name www.xyzindustries.com. It would have a conventional RR pointing to its IP address, 191.27.203.8, as well as a reverse resolution record at 8.203.27.191.IN-ADDR.ARPA, pointing to the domain name www.xyzindustries.com.">Figure 56-4</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>At the first level within IN-ADDR.ARPA there are 256 subdomains called 0, 1, 2, and so on, up to 255; for example, 191.IN-ADDR.ARPA. (Actually, there may not be all 256 of these, since some IP addresses are reserved, but let's ignore that for now.)</p></li><li class="listitem"><p>Within each of the first-level subdomains, there are 256 further subdomains at the second level, numbered the same way. So, for example, one of these would be 27.191.IN-ADDR.ARPA.</p></li><li class="listitem"><p>Again, there are 256 subdomains at the third level within each of the second-level subdomains, such as 203.27.191.IN-ADDR.ARPA.</p></li><li class="listitem"><p>Finally, there are 256 subdomains at the fourth level within each of the third-level subdomains, such as 8.203.27.191.IN-ADDR.ARPA.</p></li></ul></div><p>As you can see, within IN-ADDR.ARPA, we have created a name space that parallels the address space of the Internet Protocol (IP). Yes, this means there are several billion nodes and branches in this part of the Internet DNS name space!</p></div><div class="sect2" title="RR Setup for Reverse Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="rr_setup_for_reverse_resolution"/>RR Setup for Reverse Resolution</h2></div></div></div><p>With this structure in place, we can now associate one entry in this name space with each entry in the real DNS name space. We do this using the Pointer (PTR) RR type. For example, if <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> has the IP address 191.27.203.8, then the DNS server for its zone will have an Address (A) RR indicating this. In master file text format, it will say something like this:<a class="indexterm" id="idx-CHP-56-2033"/></p><a id="I_programlisting7_d1e59099"/><pre class="programlisting">www.xyzindustries.com.  A  191.27.203.8</pre><div class="figure"><a id="the_dns_in-addrarpa_reverse_name_resolut"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e59110"/><img alt="The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special IN-ADDR.ARPA hierarchy was created to allow easy reverse lookups of DNS names. IN-ADDR.ARPA contains 256 subdomains numbered 0 to 255, each of which has 256 subdomains numbered 0 to 255, and so forth, down to four levels. Thus, each IP address is represented in the hierarchy. This example shows the DNS domain name www.xyzindustries.com. It would have a conventional RR pointing to its IP address, 191.27.203.8, as well as a reverse resolution record at 8.203.27.191.IN-ADDR.ARPA, pointing to the domain name www.xyzindustries.com." src="httpatomoreillycomsourcenostarchimages288177.png"/></div></div><p class="title">Figure 56-4. The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special IN-ADDR.ARPA hierarchy was created to allow easy reverse lookups of DNS names. IN-ADDR.ARPA contains 256 subdomains numbered 0 to 255, each of which has 256 subdomains numbered 0 to 255, and so forth, down to four levels. Thus, each IP address is represented in the hierarchy. This example shows the DNS domain name <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>. It would have a conventional RR pointing to its IP address, 191.27.203.8, as well as a reverse resolution record at 8.203.27.191.IN-ADDR.ARPA, pointing to the domain name <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>.</p></div><p>However, there will also be the following entry for it within the IN-ADDR.ARPA domain:<a class="indexterm" id="idx-CHP-56-2034"/><a class="indexterm" id="idx-CHP-56-2035"/></p><a id="I_programlisting7_d1e59125"/><pre class="programlisting">8.203.27.191.IN-ADDR.ARPA  PTR  www.xyzindustries.com</pre><div class="note" title="Note"><h3 class="title"><a id="note-138"/>Note</h3><p><span class="emphasis"><em>Remember that DNS names are case-insensitive, so</em></span> IN-ADDR.ARPA <span class="emphasis"><em>could also be given</em></span> as in-addr.arpa.</p></div><p>Once this is done, reverse name resolution can be easily performed by doing a name resolution on 8.203.27.191.in-addr.arpa. If we do this, a server for the IN-ADDR.ARPA domain will return to us the name <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>. This is shown in <a class="xref" href="ch56s05.html#the_dns_in-addrarpa_reverse_name_resolut" title="Figure 56-4. The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special IN-ADDR.ARPA hierarchy was created to allow easy reverse lookups of DNS names. IN-ADDR.ARPA contains 256 subdomains numbered 0 to 255, each of which has 256 subdomains numbered 0 to 255, and so forth, down to four levels. Thus, each IP address is represented in the hierarchy. This example shows the DNS domain name www.xyzindustries.com. It would have a conventional RR pointing to its IP address, 191.27.203.8, as well as a reverse resolution record at 8.203.27.191.IN-ADDR.ARPA, pointing to the domain name www.xyzindustries.com.">Figure 56-4</a>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-345"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Most name resolutions require that we transform a DNS domain name into an IP address. However, there are cases where we want to perform a <span class="emphasis"><em>reverse name resolution</em></span>, by starting with an IP address and finding out what domain name matches it. This is difficult to do using the conventional DNS distributed name hierarchy, because there is no easy way to find the DNS server containing the entries for a particular IP address. To this end, a special hierarchy called <span class="emphasis"><em>IN-ADDR.ARPA</em></span> was set up for reverse name lookups. This hierarchy contains four levels of numerical subdomains structured so that each IP address has its own node. The node for an IP address contains an entry that points to the DNS domain name associated with that address.</p></div><p>I'm sure you've noticed that the numbers are backward in the IN-ADDR.ARPA domain. We've already seen the reason for this: Name resolution proceeds from the least specific to the most specific element, going from right to left. In contrast, IP addresses have the least specific octet on the left and the most specific on the right. Thus, we reverse them to maintain consistency with the DNS name space.</p><p>This immediately yields one extra benefit. Just as we can delegate authority for portions of the regular name space, for example, letting XYZ Industries be in charge of everything in <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a>, we can also delegate authority for parts of the IN-ADDR.ARPA name space. For example, since the <a class="indexterm" id="idx-CHP-56-2036"/>Massachusetts Institute of Technology (MIT) owns all IP addresses with a first octet of 18 (at least, I think it still does), it is possible that if <a class="indexterm" id="idx-CHP-56-2037"/>MIT wanted to, it could control the 18.IN-ADDR.ARPA domain as well for reverse queries. This would not be possible without reversing the octets.</p><p>Note that for this system to work reliably, it is essential that the data in the regular name space and the reverse name space remain consistent. Whenever a new DNS name is registered, an appropriate entry must be made within IN-ADDR.ARPA as well. Special procedures have been put into place to allow these pointer entries to be created automatically.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-346"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>A similar scheme using a different reverse domain is used for DNS under version 6 of the Internet Protocol (IPv6). See the end of <a class="xref" href="ch57.html" title="Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS">Chapter 57</a> for more information</em></span>.</p></div></div></div>
<div class="sect1" title="DNS Electronic Mail Support and Mail Exchange (MX) Resource Records"><div class="titlepage"><div><div><h1 class="title"><a id="dns_electronic_mail_support_and_mail_exc"/>DNS Electronic Mail Support and Mail Exchange (MX) Resource Records</h1></div></div></div><p>Most savvy users of the Internet know that <a class="indexterm" id="idx-CHP-56-2038"/>DNS exists, and they usually associate it with the most common Internet applications. Of these applications, the "Big Kahuna" is the World Wide Web. It's probably the case that the majority of DNS <a class="indexterm" id="idx-CHP-56-2039"/>name resolution requests are spawned as a result of web server domain names being typed into browsers billions of times a day, as well as requests for named pages generated by both user mouse clicks and web-based applications.</p><p>Of course, DNS is not tied specifically to any one application. We can specify names in any place where an IP address would go. For example, you can use a DNS name instead of an address for an FTP client, or even for a troubleshooting utility like traceroute or ping (see <a class="xref" href="ch88.html" title="Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS">Chapter 88</a>). The resolver will, in each case, take care of translating the name for you.</p><p>There's one application that has always used DNS, but it's one that doesn't usually spring to mind when you think about DNS: electronic mail (discussed in <a class="xref" href="pt18.html" title="Part III-7. TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND PROTOCOLS">Part III-7</a>). Electronic mail (<a class="indexterm" id="idx-CHP-56-2040"/>email) is, in fact, more reliant on DNS than just about any other TCP/IP application. Consider that while you may sometimes type an IP address for a command like traceroute, or even type it into a browser, you probably have never sent anyone mail by entering <span class="email"><a class="email" href="mailto:joe@14.194.29.60">joe@14.194.29.60</a></span> into your email client. You type something like <span class="email"><a class="email" href="mailto:joe@xyzindustries.com">joe@xyzindustries.com</a></span>, and DNS takes care of figuring out where email for XYZ Industries is to go.</p><div class="sect2" title="Special Requirements for Email Name Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="special_requirements_for_email_name_reso"/>Special Requirements for Email Name Resolution</h2></div></div></div><p>Name resolution for email addresses is different from other applications in DNS, for three reasons (which I describe in more detail in the discussion of TCP/IP email addressing and address resolution in <a class="xref" href="ch75.html" title="Chapter 75. TCP/IP ELECTRONIC MAIL ADDRESSES AND ADDRESSING">Chapter 75</a>): <a class="indexterm" id="idx-CHP-56-2041"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We may not want email to go to the exact machine specified by the address.</p></li><li class="listitem"><p>We need to be able to change server names without changing everyone's email address.</p></li><li class="listitem"><p>We need to be able to support multiple servers for handling mail.</p></li></ul></div><p>For example, XYZ Industries might want to use a dedicated mail server called <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> to handle incoming mail, but actually construct all of its email addresses to use <span class="email"><a class="email" href="mailto:@xyzindustries.com">@xyzindustries.com</a></span>. This makes addresses shorter and allows the server's name to be changed without affecting user addresses. If the company wishes, it might decide to use two servers, <a class="ulink" href="http://mail1.xyzindustries.com">mail1.xyzindustries.com</a> and <a class="ulink" href="http://mail2.xyzindustries.com">mail2.xyzindustries.com</a>, for redundancy, and again have just <span class="email"><a class="email" href="mailto:@xyzindustries.com">@xyzindustries.com</a></span> for addresses.</p><p>To allow the flexibility needed for these situations, a special DNS RR type, called a <span class="emphasis"><em>Mail Exchange (MX)</em></span> record, is defined.</p></div><div class="sect2" title="The Mail Exchange (MX) Record and Its Use"><div class="titlepage"><div><div><h2 class="title"><a id="the_mail_exchange_mx_record_and_its_use"/>The Mail Exchange (MX) Record and Its Use</h2></div></div></div><p>Each MX record specifies a particular mail server that is to be used to handle incoming email for a particular domain. Once this record is established, resolution of email messages is pretty much similar to regular resolution. Suppose you want to send a message to <span class="email"><a class="email" href="mailto:joe@xyzindustries.com">joe@xyzindustries.com</a></span>. The basic process is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Your email client invokes the resolver on your local machine to perform an email resolution on <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a>.</p></li><li class="listitem"><p>Your local resolver and local DNS server follow the process described earlier in this chapter to find the authoritative server for <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a>, which is <a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a>.</p></li><li class="listitem"><p><a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> finds the MX record for <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a> and replies back indicating that <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> should be used for email.</p></li></ol></div><p>The email client can't actually send anything to <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a>; it needs its IP address. So, it would then need to resolve that name. This resolution request will likely end up right back at the same DNS name server that just handled the MX request. To eliminate the inefficiency of two separate resolutions, the DNS name server can combine the information. In our example, <a class="ulink" href="http://ns1.xyzindustries.com">ns1.xyzindustries.com</a> will include the A (Address) RR for <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> in the Additional section of the DNS message that it sends in step 3.</p><div class="note" title="Note"><h3 class="title"><a id="note-139"/>Note</h3><p><span class="emphasis"><em>RFC 1035 originally defined several other RR types related to email as well: Mailbox (MB), Mail Group (MG), and Mail Rename (MR). These are called "experimental" in the standard. I think the experiment failed, whatever it was, because I don't believe these are used today. There are also two even older mail-related RRs, Mail Destination (MD) and Mail Forwarder (MF), which must have been used at one time but were already obsolete at the time RFC 1035 itself was written</em></span>.</p></div><p>It is also possible to specify multiple MX records for a particular domain, each pointing to a different mail server's name. This provides redundancy, so if there is a problem with one mail server, another can pick up the slack. DNS allows each mail server to be specified with a <span class="emphasis"><em>preference</em></span> value, so you can clearly indicate which is the main mail server, which is the first backup, the second backup, and so on. The DNS server will choose the mail server with the lowest preference value first, then the next highest one, and so on.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-347"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since email is sent using host names and not IP addresses, DNS contains special provisions to support the transfer of email between sites. Special <span class="emphasis"><em>Mail Exchange (MX)</em></span> DNS RRs are set up that contain the names of mail servers that a domain wants to use for handling incoming email. Before sending email to a site, a device performs a name resolution to get that site's MX record, so it knows where to send the message.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;57.&#xA0;DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS"><div class="titlepage"><div><div><h1 class="title"><a id="dns_messaging_and_message_resource_recor"/>Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e59335"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Networking is all about the communication of information between connected devices. In the case of the Domain Name System (DNS), information about names and objects on the internetwork is exchanged during each of the many types of operations DNS performs. This involves sending <span class="emphasis"><em>messages</em></span> between devices. Like most protocols, DNS uses its own set of messages with distinct field formats, and it follows a particular set of rules for generating them and transporting them over the internetwork.</p><p>In this chapter, I explain how messages are generated and sent in DNS, and I describe the formats used for messages and resource records (RRs). I begin with an overview discussion of DNS messages and how they are generated and transported. I provide an overview of the general DNS message format and the five sections it contains. I describe the notation used for names and the special compression method that helps keep DNS messages down in size. I then show the fields in the DNS message Header and Question section. I illustrate the common field format used for all RRs and the specific fields in the most important record types. I also provide a description of the format used for DNS text master files.</p><p>I conclude with a brief discussion of the changes made to DNS to support Internet Protocol version 6 (IPv6). Most of these changes (but not all of them) are associated with message formats and RRs, the subject of this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-348"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>This chapter assumes that you are already familiar with DNS concepts and operation as described in Chapters <a class="xref" href="ch52.html" title="Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS">Chapter 52</a> through <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a></em></span>.</p></div><div class="sect1" title="DNS Message Generation and Transport"><div class="titlepage"><div><div><h1 class="title"><a id="dns_message_generation_and_transport"/>DNS Message Generation and Transport</h1></div></div></div><p><a class="indexterm" id="idx-CHP-57-2042"/>In the preceding chapters in this part of the book, we have explored the many different tasks that servers and resolvers perform: regular name resolution, reverse name resolution, email resolution, zone transfers, and more. Each of these operations requires that information be exchanged between a pair of DNS devices. Like so many other TCP/IP protocols, DNS is designed to accomplish this information transfer using a <span class="emphasis"><em>client/server</em></span> model. All DNS exchanges begin with a client sending a request and a server responding with an answer.</p><div class="sect2" title="DNS Client/Server Messaging Overview"><div class="titlepage"><div><div><h2 class="title"><a id="dns_clientserver_messaging_overview"/>DNS Client/Server Messaging Overview</h2></div></div></div><p><a class="indexterm" id="idx-CHP-57-2043"/>In <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>'s overview of TCP/IP's client/server nature, I explained a potential source of confusion regarding these terms: the fact that they refer to hardware roles, software roles, and transactional roles. This issue definitely applies when it comes to DNS. You've already seen that DNS implementation consists of two sets of software elements: resolvers that act as clients and name servers that are the servers. Resolver software usually runs on client machines like PCs, while name server software often runs on dedicated server hardware. However, these designations are based on the overall role of the hardware and software.</p><p>From a messaging viewpoint, the client is the initiator of the communication, regardless of what type of machine does this initiating, and the server is the device that responds to the client. A resolver usually acts as a client and a name server as a server. However, in a particular exchange, a DNS name server can act as a client, in at least two cases. First, in recursive name resolution, a server generates requests to others servers and therefore acts as a client. Second, in administrative functions like zone transfers, one server acts as a client and sends a request to another server. (There are no cases in DNS that I know of where a resolver acts as a server, incidentally.)</p><p>Most transactions in DNS consist of the exchange of a single query message and a single response message. The device acting as client for the transaction creates the query and sends it to the server; the server then sends back a reply. In certain cases where a great deal of data needs to be sent, such as zone transfers, the server may send back multiple messages. Multiple such transactions may be required to perform a complete name resolution, as the example of the DNS resolution process in the previous chapter demonstrated.</p></div><div class="sect2" title="DNS Message Transport Using UDP and TCP"><div class="titlepage"><div><div><h2 class="title"><a id="dns_message_transport_using_udp_and_tcp"/>DNS Message Transport Using UDP and TCP</h2></div></div></div><p>TCP/IP has two different <a class="indexterm" id="idx-CHP-57-2044"/>transport layer protocols: the User Datagram Protocol (UDP) and Transmission Control Protocol (TCP) (see <a class="xref" href="pt11.html" title="Part II-8. TCP/IP TRANSPORT LAYER PROTOCOLS">Part II-8</a>). UDP and TCP share layer 4 in the TCP/IP model, because they are so different in terms of capabilities and operation. Some application layer protocols need the services of TCP and can use it to take advantage of them, while others are better off with the simpler UDP. DNS is itself a perfect example of the valid reasons for having both UDP and TCP in the protocol suite (see <a class="xref" href="ch42.html" title="Chapter 42. OVERVIEW AND COMPARISON OF TCP AND UDP">Chapter 42</a>), because it uses both.</p><p>UDP is a simple connectionless protocol that provides no real features but is very fast. It is ideally suited for small, quick exchanges of information and can be faster than TCP because there is no need to establish a connection. This makes it a good choice for most of the conventional queries used in DNS, because they are normally very short, and fast data exchange is important. For this reason, the DNS standards recommend use of UDP for queries and replies as part of regular and reverse name resolution. UDP DNS messages are limited to 512 bytes; longer messages are truncated, and a special bit in the header is set to indicate that this has occurred. If a message being truncated causes a problem for its recipient, the query must be repeated using TCP.</p><div class="note" title="Note"><h3 class="title"><a id="note-140"/>Note</h3><p><span class="emphasis"><em>The 512-byte limit on DNS UDP messages can be surpassed if the optional Extension Mechanisms for DNS (<a class="indexterm" id="idx-CHP-57-2046"/>EDNS0) are implemented. These are described in RFC 2671</em></span><a class="indexterm" id="idx-CHP-57-2045"/>.</p></div><p>Since UDP does not provide reliable delivery of messages, DNS clients must keep track of requests they have sent. If no response is received after a particular amount of time, the request must be retransmitted. The need to take care of these details is considered an acceptable trade-off for the lower setup costs involved with UDP, such as not requiring a connection. The rate at which retransmissions are sent is usually set at a minimum of two to five seconds to prevent excessive DNS traffic on the internetwork.</p><p>For certain special DNS transactions, UDP is simply inappropriate. The most common example of such a transaction is a zone transfer. While the query for a zone transfer is small in size, the amount of data sent in response can be quite large. The limit of 512 bytes for UDP is not even close to enough. Furthermore, we really do need to make sure that a zone transfer is accomplished reliably and with flow control and other data transfer management features, or we risk having corrupted zone information in our secondary DNS server databases.</p><p>The solution is to use TCP for these types of exchanges. TCP allows messages to be of arbitrary length, and as a connection-oriented, acknowledged, reliable protocol, automatically provides the mechanisms we need to ensure that zone transfers and other lengthy operations complete successfully. The cost is the small amount of overhead needed to establish the connection, but since zone transfers are infrequent (compared to the sheer volume of regular name resolutions), this is not a problem.</p><p>You can see how DNS nicely illustrates the roles of both TCP and UDP in TCP/IP. Since both transport protocols can be used, name servers listen for UDP and TCP requests on the same well-known port number, 53. The device acting as the client uses an ephemeral port number for the transaction. All DNS messages are sent unicast from one device directly to another.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-349"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> DNS uses both UDP and TCP to send messages. Conventional message exchanges are short, and thus well suited to the use of the very fast UDP; DNS itself handles the detection and retransmission of lost requests. For larger or more important exchanges of <a class="indexterm" id="idx-CHP-57-2047"/>information, especially zone transfers, TCP is used—both for its reliability and its ability to handle messages of any size.</p></div></div><div class="sect2" title="DNS Message Processing and General Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="dns_message_processing_and_general_messa"/>DNS Message Processing and General Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-57-2048"/>As we've just discussed, DNS message exchanges are all based on the principle of client/server computing. In a particular exchange, one device acts as a client, initiating the communication by sending a query; the other acts as the server by responding to the query with an answer. This query/response behavior is an integral part of DNS, and it is reflected in the format used for DNS messages.</p><p>A common message format is used for DNS queries and responses. This message format contains five sections that provide a place for the query asked by the client, the answer(s) provided by the server, and header information that controls the entire process. <a class="xref" href="ch57.html#dns_general_message_format-id001" title="Table 57-1. DNS General Message Format">Table 57-1</a> describes the DNS general message format, providing a brief summary of each of its sections and how they are used. You can also see a simplified illustration of the message format in <a class="xref" href="ch57.html#dns_general_message_format-id002" title="Figure 57-1. DNS general message format">Figure 57-1</a>.</p><div class="table"><a id="dns_general_message_format-id001"/><p class="title">Table 57-1. DNS General Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS General Message Format"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Section Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Header</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains fields that describe the type of message and provide important information about it. Also contains fields that indicate the number of entries in the other sections of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Question</p></td><td style="border-bottom: 0.5pt solid ; "><p>Carries one or more questions—that is, queries for information being sent to a DNS name server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Answer</p></td><td style="border-bottom: 0.5pt solid ; "><p>Carries one or more RRs that answer the question(s) indicated in the Question section.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Authority</p></td><td style="border-bottom: 0.5pt solid ; "><p>Contains one or more RRs that point to authoritative name servers that can be used to continue the resolution process.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Additional</p></td><td style=""><p>Conveys one or more RRs that contain additional information related to the query that is not strictly necessary to answer the queries (questions) in the message.</p></td></tr></tbody></table></div></div><p>The Header section is always present in all messages and is fixed in length. In addition to containing important DNS control information, it has a flag (QR) that indicates whether a message is a query or a response. It also has four "count" fields that tell the recipient the number of entries in the other four sections.</p><p>When a client initiates a query, it creates a message with the fields in the Header section filled in, and one or more queries (requests for information) in the Question section. It sets the QR flag to 0 to indicate that this is a query, and it places a number in the QDCount field of the header that indicates the number of questions in the Question section. The number of entries in the other sections are usually 0, so their count fields (ANCount, NSCount, and ARCount) are set to 0 in the header. (Although more than one question can be put into a query, usually only one is included.)</p><div class="figure"><a id="dns_general_message_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e59519"/><img alt="DNS general message format" src="httpatomoreillycomsourcenostarchimages288179.png"/></div></div><p class="title">Figure 57-1. DNS general message format</p></div><p>When the server receives the query, it processes it and performs the <a class="indexterm" id="idx-CHP-57-2049"/>information retrieval operation requested (if it can). It then uses the query as the basis for its response message. The Header and Question sections are copied to the response message, and the QR flag is set to 1 to indicate that the message is a reply. Certain fields are also changed in the Header section to provide information back to the client. For example, the server sets the RCode (Response Code) field to indicate whether the query was successful or if an error occurred, and if one did occur, to indicate what the problem was. The next section of this chapter illustrates all the Header fields and indicates how each is used by both client and server.</p><p>The server is also responsible for filling in the other three sections of the message: Answer, Authority, and Additional. These sections share the same basic format, each carrying one or more RRs that use a common record format. The number of records in each section is indicated using the count fields in the message header. The sections differ only in terms of the types of records they carry. Answer records are directly related to the question asked, while Authority records carry RRs that identify other name servers. Authority records are thus the means by which name servers are hierarchically linked when the server doesn't have the information the client requested.</p><p>The Additional section exists for the specific purpose of improving DNS efficiency. There are cases where a server supplies an answer to a query that it has reason to believe will lead to a subsequent question that the server can also answer. For example, suppose a server provides the name of another name server in the Authority section (an NS RR). The client may not have the address for that server, which would mean it must perform an extra name resolution to contact the referenced server. If the server providing the NS record already knows the IP address for this name server, it can include it in the Additional section. The same goes for a server providing an MX record as I explained in the discussion of DNS mail support in the previous chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-350"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> DNS uses a general message format for all messages. It consists of a fixed 12-byte header, a Question section that contains a query, and then three additional sections that can carry RRs of different types. The Answer section usually contains records that directly answer the question of the message; the Authority section holds the names of name servers being sent back to the client; and the Additional section holds extra information that may be of value to the client, such as the IP address of a name server mentioned in the Authority section.</p></div><p>Another optimization by DNS is a special compression technique used to reduce the size of DNS messages. This is explained in the "DNS Name Notation and Message Compression" section later in this chapter.</p><p>Note that the special Notify and Update messages use a different format than the regular DNS query/response messages. These special messages (whose use is described in the section about DNS server enhancements in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a>) are based on the regular format but with the meanings of certain fields changed. You can find these field formats in RFC 1996 and RFC 2136, respectively.</p><p>The client/server information exchange in DNS is facilitated using query/response messaging. Both queries and responses have the same general format, containing up to five individual sections carrying information. Of these, two are usually found in both queries and responses: the Header section and the Question section. We will look at these two sections first, and then examine the RR formats used by servers for the other three message sections.</p></div></div></div>
<div class="sect1" title="DNS Message Header Format"><div class="titlepage"><div><div><h1 class="title"><a id="dns_message_header_format"/>DNS Message Header Format</h1></div></div></div><p><a class="indexterm" id="idx-CHP-57-2050"/>The header is the most important part of any message, since it is where critical control fields are carried. In DNS messages, the Header section carries several key control flags, and it also indicates which of the other sections are used in the message. Examining the Header section can help you understand several of the nuances of how messaging works in DNS.</p><p>The format of the Header section used in all DNS messages is illustrated in <a class="xref" href="ch57s02.html#dns_message_header_format-id002" title="Figure 57-2. DNS message header format">Figure 57-2</a> and described in detail in Tables <a class="xref" href="ch57s02.html#dns_message_header_format-id001" title="Table 57-2. DNS Message Header Format">Table 57-2</a>, <a class="xref" href="ch57s02.html#header_opcode_values" title="Table 57-3. Header OpCode Values">Table 57-3</a>, and <a class="xref" href="ch57s02.html#header_rcode_values" title="Table 57-4. Header RCode Values">Table 57-4</a>. Where fields are used differently by the client and server in an exchange, I have mentioned in <a class="xref" href="ch57s02.html#dns_message_header_format-id001" title="Table 57-2. DNS Message Header Format">Table 57-2</a> how the use is differentiated between the two.</p><p>Note that the current lists of valid question types, query operation codes, and response codes are maintained by the Internet Assigned Numbers Authority (IANA) as one of its many lists of Internet parameters. Response codes 0 to 5 are part of regular DNS and are defined in RFC 1035; codes 6 to 10 implement Dynamic DNS and are defined in RFC 2136.</p><div class="table"><a id="dns_message_header_format-id001"/><p class="title">Table 57-2. DNS Message Header Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Message Header Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifier: A 16-bit identification field generated by the device that creates the DNS query. It is copied by the server into the response, so it can be used by that device to match that query to the corresponding reply received from a DNS server. This is used in a manner similar to how the Identifier field is used in many of the Internet Control Message Protocol (ICMP) message types.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>QR</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Query/Response Flag: Differentiates between queries and responses. Set to 0 when the query is generated; changed to 1 when that query is changed to a response by a replying server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>OpCode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2 (4 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Operation Code: Specifies the type of query the message is carrying. This field is set by the creator of the query and copied unchanged into the response. See <a class="xref" href="ch57s02.html#header_opcode_values" title="Table 57-3. Header OpCode Values">Table 57-3</a> for the OpCode values.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AA</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Authoritative Answer Flag: This bit is set to 1 in a response to indicate that the server that created the response is authoritative for the zone in which the domain name specified in the Question section is located. If it is 0, the response is non-authoritative.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TC</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Truncation Flag: When set to 1, indicates that the message was truncated due to its length being longer than the maximum permitted for the type of transport mechanism used. TCP doesn't have a length limit for messages; UDP messages are limited to 512 bytes, so this bit being sent usually is an indication that the message was sent using UDP and was too long to fit. The client may need to establish a TCP session to get the full message. On the other hand, if the portion truncated was part of the Additional section, it may choose not to bother.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RD</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Recursion Desired: When set in a query, requests that the server receiving the query attempt to answer the query recursively, if the server supports recursive resolution. The value of this bit is not changed in the response.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RA</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Recursion Available: Set to 1 or cleared to 0 in a response to indicate whether the server creating the response supports recursive queries. This can then be noted by the device that sent the query for future use.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Z</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3/8 (3 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Zero: Three reserved bits set to 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RCode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/2 (4 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Response Code: Set to 0 in queries, then changed by the replying server in a response to convey the results of processing the query. This field is used to indicate if the query was answered successfully or if some sort of error occurred. See <a class="xref" href="ch57s02.html#header_rcode_values" title="Table 57-4. Header RCode Values">Table 57-4</a> for the RCode values.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>QDCount</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Question Count: Specifies the number of questions in the Question section of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ANCount</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Answer Record Count: Specifies the number of RRs in the Answer section of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>ARCount</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style=""><p>Additional Record Count: Specifies the number of RRs in the Additional section of the message.</p></td></tr></tbody></table></div></div><div class="table"><a id="header_opcode_values"/><p class="title">Table 57-3. Header OpCode Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Header OpCode Values"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-57-2051"/>OpCode Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Query Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Query</p></td><td style="border-bottom: 0.5pt solid ; "><p>A standard query.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IQuery</p></td><td style="border-bottom: 0.5pt solid ; "><p>An inverse query; now obsolete. RFC 1035 defines the inverse query as an optional method for performing inverse DNS lookups; that is, finding a name from an IP address. Due to implementation difficulties, the method was never widely deployed, however, in favor of reverse mapping using the IN-ADDR.ARPA domain. Use of this OpCode value was formally obsoleted in RFC 3425, November 2002.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Status</p></td><td style="border-bottom: 0.5pt solid ; "><p>A server status request.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved, not used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Notify</p></td><td style="border-bottom: 0.5pt solid ; "><p>A special message type added by RFC 1996. It is used by a primary (master, authoritative) server to tell secondary servers that data for a zone has changed and prompt them to request a zone transfer. See the discussion of DNS server enhancements in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a> for more details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; "><p>Update</p></td><td style=""><p>A special message type added by RFC 2136 to implement Dynamic DNS. It allows RRs to be added, deleted, or updated selectively. See the discussion of DNS server enhancements in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a> for more details.</p></td></tr></tbody></table></div></div><div class="table"><a id="header_rcode_values"/><p class="title">Table 57-4. Header RCode Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Header RCode Values"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RCode Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response Code</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>No error occurred.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Format Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server was unable to respond to the query due to a problem with how it was constructed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Server Failure</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server was unable to respond to the query due to a problem with the server itself.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Name Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>The name specified in the query does not exist in the domain. This code can be used by an authoritative server for a zone (since it knows all the objects and subdomains in a domain) or by a caching server that implements negative caching.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Not Implemented</p></td><td style="border-bottom: 0.5pt solid ; "><p>The type of query received is not supported by the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Refused</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server refused to process the query, generally for policy reasons and not technical ones. For example, certain types of operations, such as zone transfers, are restricted. The server will honor a zone transfer request only from certain devices.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>YX Domain</p></td><td style="border-bottom: 0.5pt solid ; "><p>A name exists when it should not.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>YX RR Set</p></td><td style="border-bottom: 0.5pt solid ; "><p>An RR set exists that should not.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NX RR Set</p></td><td style="border-bottom: 0.5pt solid ; "><p>An RR set that should exist does not.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Not Auth</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server receiving the query is not authoritative for the zone specified.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; "><p>Not Zone</p></td><td style=""><p>A name specified in the message is not within the zone specified in the message.</p></td></tr></tbody></table></div></div><div class="figure"><a id="dns_message_header_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e59944"/><img alt="DNS message header format" src="httpatomoreillycomsourcenostarchimages288181.png.jpg"/></div></div><p class="title">Figure 57-2. DNS message header format</p></div></div>
<div class="sect1" title="DNS Question Section Format"><div class="titlepage"><div><div><h1 class="title"><a id="dns_question_section_format"/>DNS Question Section Format</h1></div></div></div><p><a class="indexterm" id="idx-CHP-57-2052"/>DNS queries always contain at least one entry in the Question section that specifies what the client in the exchange is trying to find out. These entries are copied to the response message unchanged, for reference on the part of the client if needed. The format used for each entry in the Question section of a DNS message described in detail in Tables <a class="xref" href="ch57s03.html#dns_message_question_section_format" title="Table 57-5. DNS Message Question Section Format">Table 57-5</a> and <a class="xref" href="ch57s03.html#question_section_qtype_values" title="Table 57-6. Question Section QType Values">Table 57-6</a>, and illustrated in <a class="xref" href="ch57s03.html#dns_message_question_section_forma-id001" title="Figure 57-3. DNS message Question section format">Figure 57-3</a>.</p><div class="table"><a id="dns_message_question_section_format"/><p class="title">Table 57-5. DNS Message Question Section Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Message Question Section Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-57-2053"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>QName</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Question Name: Contains the object, domain, or zone name that is the subject of the query, encoded using standard DNS name notation, which is explained later in this chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>QType</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Question Type: Specifies the type of question being asked by the device acting as a client. This field may contain a code number corresponding to a particular type of RR being requested. (<a class="xref" href="ch55s02.html#summary_of_common_dns_resource_records" title="Table 55-1. Summary of Common DNS Resource Records">Table 55-1</a> in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a> contains the numbers for the most common RRs.) If so, this means the client is asking for that type of record to be sent for the domain name listed in QName. The QType field may also contain one of the codes listed in <a class="xref" href="ch57s03.html#question_section_qtype_values" title="Table 57-6. Question Section QType Values">Table 57-6</a>, corresponding to a special type of requests.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>QClass</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style=""><p>Question Class: Specifies the class of the RR being requested, normally the value 1 for Internet (IN). See the discussion of classes and RR types in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a> for an explanation. In addition, the QClass value 255 is defined to have the special meaning "any class."</p></td></tr></tbody></table></div></div><div class="table"><a id="question_section_qtype_values"/><p class="title">Table 57-6. Question Section QType Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Question Section QType Values"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>QType Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Question Type</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>251</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IXFR</p></td><td style="border-bottom: 0.5pt solid ; "><p>A request for an incremental (partial) zone transfer, per RFC 1995</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>252</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AXFR</p></td><td style="border-bottom: 0.5pt solid ; "><p>A request for a zone transfer</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>253</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MAILB</p></td><td style="border-bottom: 0.5pt solid ; "><p>A request for mailbox-related records (RR types MB, MG, or MR; now obsolete)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>254</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MAILA</p></td><td style="border-bottom: 0.5pt solid ; "><p>A request for mail agent RR (now obsolete; MX records are used instead)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>255</p></td><td style="border-right: 0.5pt solid ; "><p>* (asterisk)</p></td><td style=""><p>A request for all records</p></td></tr></tbody></table></div></div><div class="figure"><a id="dns_message_question_section_forma-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e60099"/><img alt="DNS message Question section format" src="httpatomoreillycomsourcenostarchimages288183.png.jpg"/></div></div><p class="title">Figure 57-3. DNS message Question section format</p></div></div>
<div class="sect1" title="DNS Message Resource Record Field Formats"><div class="titlepage"><div><div><h1 class="title"><a id="dns_message_resource_record_field_format"/>DNS Message Resource Record Field Formats</h1></div></div></div><p><a class="indexterm" id="idx-CHP-57-2054"/><a class="indexterm" id="idx-CHP-57-2055"/>As you've learned in this and the previous chapter, the exchange of information in DNS consists of a series of client/server transactions. Clients send requests, or <span class="emphasis"><em>queries</em></span>, to servers, and the servers send back <span class="emphasis"><em>responses</em></span>. DNS servers are database servers, and they store DNS name database <a class="indexterm" id="idx-CHP-57-2056"/>information in the form of RRs. The questions asked by clients are requests for <a class="indexterm" id="idx-CHP-57-2057"/>information from a DNS server's database, and they are answered by the DNS server looking up the requested RRs and putting them into the DNS response message.</p><p>The Answer, Authority, and Additional sections of the overall DNS message format are the places where servers put DNS RRs to be sent back to a client. Each section consists of zero or more records, and in theory, any record can be placed in any section. The sections differ only in the semantics (meaning) that the client draws from a record being in one section rather than in another section.</p><p>RRs have two representations: binary and text. The text format is used for master files edited by humans and is discussed in the "DNS Master File Format" section later in this chapter. The binary representation consists of regular numeric and text fields, just like the other fields in the DNS message format.</p><div class="sect2" title="DNS Common RR Format"><div class="titlepage"><div><div><h2 class="title"><a id="dns_common_rr_format"/>DNS Common RR Format</h2></div></div></div><p>There are certain types of information that are common to all RRs and other types that are unique to each type of record. To handle this, all RRs are represented using a common field format, which contains a single RData field that varies by record type. The common RR format is described in <a class="xref" href="ch57s04.html#dns_common_resource_record_format" title="Table 57-7. DNS Common Resource Record Format">Table 57-7</a> and illustrated in <a class="xref" href="ch57s04.html#dns_common_rr_format-id001" title="Figure 57-4. DNS common RR format">Figure 57-4</a>.</p><div class="table"><a id="dns_common_resource_record_format"/><p class="title">Table 57-7. DNS Common Resource Record Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Common Resource Record Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Name</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Name: Contains the object, domain, or zone name that is the subject of the RR, encoded using standard DNS name notation, which is explained later in this chapter. All of the information in the RR is associated with this object, which I call the named object for the record.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Type: A code value specifying the type of resource record. The type values for the most common kinds of RRs are shown in <a class="xref" href="ch55s02.html#summary_of_common_dns_resource_records" title="Table 55-1. Summary of Common DNS Resource Records">Table 55-1</a>, in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a> and also in the following sections of this chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Class</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Class: Specifies the class of the RR being requested, normally the value 1 for Internet (IN). See <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a> for an explanation.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TTL</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Time to Live: Specifies the number of seconds that the record should be retained in the cache of the device reading the record. See the discussion of DNS name server caching in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a> for a full explanation. A value of 0 means to use this information for the current name resolution only; do not cache it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RDLength</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Resource Data Length: Indicates the size of the RData field, in bytes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>RData</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Resource Data: The data portion of the RR.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="RData Field Formats for Common RRs"><div class="titlepage"><div><div><h2 class="title"><a id="rdata_field_formats_for_common_rrs"/>RData Field Formats for Common RRs</h2></div></div></div><p><a class="indexterm" id="idx-CHP-57-2058"/>The RData field consists of one or more subfields that carry the actual payload for the RR. The following sections present the most common RR types. For each, I have indicated the RR text code, name, and type value; provided a brief summary of the RR's use; and shown the structure of the RData field in a table.</p><div class="figure"><a id="dns_common_rr_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e60256"/><img alt="DNS common RR format" src="httpatomoreillycomsourcenostarchimages288185.png"/></div></div><p class="title">Figure 57-4. DNS common RR format</p></div><div class="sect3" title="A (Address) RR (Type Value 1)"><div class="titlepage"><div><div><h3 class="title"><a id="a_address_rr_type_value_1"/>A (Address) RR (Type Value 1)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2059"/>A (<a class="indexterm" id="idx-CHP-57-2060"/>Address) is the primary RR type in <a class="indexterm" id="idx-CHP-57-2061"/>DNS. It contains a 32-bit IP <a class="indexterm" id="idx-CHP-57-2062"/>address associated with a domain name, as shown in <a class="xref" href="ch57s04.html#dns_address_rr_data_format" title="Table 57-8. DNS Address RR Data Format">Table 57-8</a>.</p><div class="table"><a id="dns_address_rr_data_format"/><p class="title">Table 57-8. DNS Address RR Data Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Address RR Data Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-57-2063"/>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; "><p>Address</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>Address: The 32-bit IP address corresponding to this record's named object.</p>
</td></tr></tbody></table></div></div></div><div class="sect3" title="NS (Name Server) RR (Type Value 2)"><div class="titlepage"><div><div><h3 class="title"><a id="ns_name_server_rr_type_value_2"/>NS (Name Server) RR (Type Value 2)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2064"/>The NSDName data field carries the domain name of a <a class="indexterm" id="idx-CHP-57-2065"/>name server, as shown in <a class="xref" href="ch57s04.html#dns_name_server_rr_data_format" title="Table 57-9. DNS Name Server RR Data Format">Table 57-9</a>.</p><div class="table"><a id="dns_name_server_rr_data_format"/><p class="title">Table 57-9. DNS Name Server RR Data Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Name Server RR Data Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; "><p>NSDName</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Name Server Domain Name: A variable-length name of a name server that should be authoritative for this record's named object. Like all names, this name is encoded using standard DNS name notation. A request for this RR type normally results in an A record for the name server specified also being returned in the Additional section of the response, if available.</p></td></tr></tbody></table></div></div></div><div class="sect3" title="CName (Canonical Name) RR (Type Value 5)"><div class="titlepage"><div><div><h3 class="title"><a id="cname_canonical_name_rr_type_value_5"/>CName (Canonical Name) RR (Type Value 5)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2066"/><a class="indexterm" id="idx-CHP-57-2067"/>The CName data field contains the real name of a named object that has been referenced using an alias, as shown in <a class="xref" href="ch57s04.html#dns_canonical_name_rr_data_format" title="Table 57-10. DNS Canonical Name RR Data Format">Table 57-10</a>.</p><div class="table"><a id="dns_canonical_name_rr_data_format"/><p class="title">Table 57-10. DNS Canonical Name RR Data Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Canonical Name RR Data Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-57-2068"/>CName</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p><a class="indexterm" id="idx-CHP-57-2069"/>Canonical Name: The canonical (real) name of the named object. This name is then resolved using the standard DNS resolution procedure to get the address for the originally specified name.</p></td></tr></tbody></table></div></div></div><div class="sect3" title="SOA (Start Of Authority) RR (Type Value 6)"><div class="titlepage"><div><div><h3 class="title"><a id="soa_start_of_authority_rr_type_value_"/>SOA (Start Of Authority) RR (Type Value 6)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2070"/>The <a class="indexterm" id="idx-CHP-57-2071"/>SOA record marks the start of a DNS zone and contains key information about how it is to be managed and used. The SOA record is the most complex of the DNS RR types. Its format is explained in <a class="xref" href="ch57s04.html#dns_start_of_authority_rr_data_format" title="Table 57-11. DNS Start Of Authority RR Data Format">Table 57-11</a> and illustrated in <a class="xref" href="ch57s04.html#dns_start_of_authority_soa_rr_data_forma" title="Figure 57-5. DNS Start Of Authority (SOA) RR Data Format">Figure 57-5</a>. See the discussion of zone transfers in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a> for information about how the fields in this RR are used.</p><div class="table"><a id="dns_start_of_authority_rr_data_format"/><p class="title">Table 57-11. DNS Start Of Authority RR Data Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Start Of Authority RR Data Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-57-2072"/>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MName</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Master Name: The domain name of the name server that is the source of the data for the zone. This is normally the primary authoritative server for the zone. It is encoded using the standard DNS name format.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RName</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Responsible Name: The email address of the person responsible for this zone. Email addresses in DNS are encoded using a special variation of the regular DNS name notation, discussed later in this chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Serial</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Serial Number: The serial number, or version number, of the RR database for this zone. Used to determine when changes have been made to the database to trigger zone transfers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Refresh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Refresh Interval: The number of seconds that secondary name servers for this zone will wait between attempts to check for changes made to the zone database on the primary name server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Retry</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retry Interval: The number of seconds a secondary name server waits before trying again to check with a primary for changes if its previous attempt failed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Expire</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Expire Interval: The number of seconds that can elapse between successful contacts with the primary name server before a secondary name server must consider the information it holds stale.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Minimum</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>Negative Caching TTL: Originally carried the default TTL value for records where no explicit TTL value was specified. Now represents the zone's negative cache TTL. See the discussion of DNS name server caching in <a class="xref" href="ch55.html" title="Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION">Chapter 55</a>.</p></td></tr></tbody></table></div></div></div><div class="sect3" title="PTR (Pointer) RR (Type Value 12)"><div class="titlepage"><div><div><h3 class="title"><a id="ptr_pointer_rr_type_value_12"/>PTR (Pointer) RR (Type Value 12)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2073"/><a class="indexterm" id="idx-CHP-57-2074"/>The <a class="indexterm" id="idx-CHP-57-2075"/>PTR record carries a <a class="indexterm" id="idx-CHP-57-2076"/>pointer to an RR. It's used for reverse address lookups. It contains one data field, shown in <a class="xref" href="ch57s04.html#dns_pointer_rr_data_format" title="Table 57-12. DNS Pointer RR Data Format">Table 57-12</a>.</p><div class="table"><a id="dns_pointer_rr_data_format"/><p class="title">Table 57-12. DNS Pointer RR Data Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Pointer RR Data Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; "><p>PTRDName</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Pointer Domain Name: A variable-length domain name. This is a name pointed to by the RR. See the description of reverse resolution in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a> for the most common way that this record type is used.</p></td></tr></tbody></table></div></div><div class="figure"><a id="dns_start_of_authority_soa_rr_data_forma"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e60598"/><img alt="DNS Start Of Authority (SOA) RR Data Format" src="httpatomoreillycomsourcenostarchimages288187.png"/></div></div><p class="title">Figure 57-5. DNS Start Of Authority (SOA) RR Data Format</p></div></div><div class="sect3" title="MX (Mail Exchange) RR (Type Value 15)"><div class="titlepage"><div><div><h3 class="title"><a id="mx_mail_exchange_rr_type_value_15"/>MX (Mail Exchange) RR (Type Value 15)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2077"/>The special <a class="indexterm" id="idx-CHP-57-2078"/>MX record contains information about the mail server(s) to be used for sending email to the domain (see <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>). Each record contains two fields, as shown in <a class="xref" href="ch57s04.html#dns_mail_exchange_rr_data_format" title="Table 57-13. DNS Mail Exchange RR Data Format">Table 57-13</a>.</p><div class="table"><a id="dns_mail_exchange_rr_data_format"/><p class="title">Table 57-13. DNS Mail Exchange RR Data Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Mail Exchange RR Data Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-57-2079"/>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Preference</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Preference Value: The preference level for this <a class="indexterm" id="idx-CHP-57-2080"/>mail exchange. Lower values signify higher preference.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Exchange</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Exchange Domain Name: The domain name, encoded using standard DNS name notation, of a host willing to provide mail exchange services for this named object.</p></td></tr></tbody></table></div></div></div><div class="sect3" title="TXT (Text) RR (Type Value 16)"><div class="titlepage"><div><div><h3 class="title"><a id="txt_text_rr_type_value_16"/>TXT (Text) RR (Type Value 16)</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2081"/><a class="indexterm" id="idx-CHP-57-2082"/>The TXT record contains additional descriptive information about the named object, as shown in <a class="xref" href="ch57s04.html#dns_text_rr_data_format" title="Table 57-14. DNS Text RR Data Format">Table 57-14</a>.</p><div class="table"><a id="dns_text_rr_data_format"/><p class="title">Table 57-14. DNS Text RR Data Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="DNS Text RR Data Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-57-2083"/>TXT-Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p><a class="indexterm" id="idx-CHP-57-2084"/>Text Data: Variable-length descriptive <a class="indexterm" id="idx-CHP-57-2085"/>text.</p></td></tr></tbody></table></div></div></div></div></div>
<div class="sect1" title="DNS Name Notation and Message Compression"><div class="titlepage"><div><div><h1 class="title"><a id="dns_name_notation_and_message_compressio"/>DNS Name Notation and Message Compression</h1></div></div></div><p>Obviously, the entire DNS protocol is oriented around dealing with names for domains, subdomains, and objects. As you've seen in the preceding topics, there are many fields in DNS messages and RRs that carry the names of objects, name servers, and so forth. DNS uses a special notation for encoding names in RRs and fields, a variation of this notation for email addresses, and a special compression method that reduces the size of messages for efficiency.</p><div class="sect2" title="Standard DNS Name Notation"><div class="titlepage"><div><div><h2 class="title"><a id="standard_dns_name_notation"/>Standard DNS Name Notation</h2></div></div></div><p>In <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>, you learned how DNS names are constructed. Each node in the name hierarchy has a label associated with it. The fully qualified domain name (FQDN) for a particular device consists of the sequence of labels that starts from the root of the tree and progresses down to that device. The labels at each level in the hierarchy are listed in sequence, starting with the highest level, from right to left, separated by dots. This results in the domain names we are used to working with, such as <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>.</p><p>It would be possible to encode these names into RRs or other DNS message fields directly: Put the letter <span class="emphasis"><em>w</em></span> into each of the first three bytes of the name, then put a dot (.) into the fourth byte, an <span class="emphasis"><em>x</em></span> into the fifth byte, and so on. The disadvantage of this is that as a computer was reading the name, it wouldn't be able to tell when each name was finished. We would need to include a length field for each name.</p><p>Instead, DNS uses a special notation for DNS names. Each label is encoded, one after the next, in the name field. Before each label, a single byte is used that holds a binary number indicating the number of characters in the label. Then the label's characters are encoded, one per byte. The end of the name is indicated by a null label, representing the root; this has a length of zero, so each name ends with just a 0 character, indicating this zero-length root label.</p><p>Note that the dots between the labels aren't necessary, since the length numbers delineate the labels. The computer reading the name also knows how many bytes are in each label as it reads the name, so it can easily allocate space for the label as it reads it from the name.</p><p>For example, <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a> would be encoded as follows:</p><a id="I_programlisting8_d1e60763"/><pre class="programlisting">[3] w w w [13] x y z i n d u s t r i e s [3] c o m [0]</pre><p>I have shown the label lengths in square brackets to distinguish them. Remember that these label lengths are binary encoded numbers, so a single byte can hold a value from 0 to 255; that [13] is one byte, not two, as you can see in <a class="xref" href="ch57s05.html#dns_standard_name_notation_in_dns_every_" title="Figure 57-6. DNS standard name notation In DNS, every named object or other name is represented by a sequence of label lengths and then labels, with each label length taking one byte and each label taking one byte per character. This example shows the encoding of the name www.xyzindustries.com.">Figure 57-6</a>. Labels are actually limited to a maximum of 63 characters, and you'll see shortly why this is significant.</p><div class="figure"><a id="dns_standard_name_notation_in_dns_every_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e60775"/><img alt="DNS standard name notation In DNS, every named object or other name is represented by a sequence of label lengths and then labels, with each label length taking one byte and each label taking one byte per character. This example shows the encoding of the name www.xyzindustries.com." src="httpatomoreillycomsourcenostarchimages288189.png"/></div></div><p class="title">Figure 57-6. DNS standard name notation In DNS, every named object or other name is represented by a sequence of label lengths and then labels, with each label length taking one byte and each label taking one byte per character. This example shows the encoding of the name <a class="ulink" href="http://www.xyzindustries.com">www.xyzindustries.com</a>.</p></div></div><div class="sect2" title="DNS Electronic Mail Address Notation"><div class="titlepage"><div><div><h2 class="title"><a id="dns_electronic_mail_address_notation"/>DNS Electronic Mail Address Notation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-57-2086"/><a class="indexterm" id="idx-CHP-57-2087"/><a class="indexterm" id="idx-CHP-57-2088"/>Email addresses are used in certain DNS resource records, such as the RName field in the SOA RR. Email addresses take the form &lt;<span class="emphasis"><em>name</em></span>&gt;@&lt;<span class="emphasis"><em>domain-name</em></span>&gt;. DNS encodes these in exactly the same way as regular DNS domains, simply treating the @ like another dot. So, <span class="email"><a class="email" href="mailto:johnny@somewhere.org">johnny@somewhere.org</a></span> would be treated as johnny.somewhere.org and encoded as follows:</p><a id="I_programlisting8_d1e60811"/><pre class="programlisting">[6] j o h n n y [9] s o m e w h e r e [3] o r g [0]</pre><p>Note that there is no specific indication that this is an email address. The name is interpreted as an email address instead of a device name based on context.</p></div><div class="sect2" title="DNS Message Compression"><div class="titlepage"><div><div><h2 class="title"><a id="dns_message_compression"/>DNS Message Compression</h2></div></div></div><p><a class="indexterm" id="idx-CHP-57-2089"/><a class="indexterm" id="idx-CHP-57-2090"/>A single DNS message may contain many domain names. Now, consider that when a particular name server sends a response containing multiple domain names, they are all usually in the same zone or are related to the zone. Most of these names will have common elements to their names.</p><p>Consider our previous mail example of a client asking for an MX record for <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a>. The response to this client will contain, among other things, these two records:</p><p><span class="strong"><strong>MX Record</strong></span> An MX record that has <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a> in the Name field of the record and <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> in the RData field.</p><p><span class="strong"><strong>A Record</strong></span> Assuming the name server knows the IP address of <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a>, the Additional section will contain an A record that has <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> in the Name field and its address in the RData field.</p><p>This is just one small example of name duplication. It can be much more extreme with other types of DNS messages, with certain string patterns being repeated many times. Normally, this would require that each name be spelled out fully using the encoding method described here. But this would be wasteful, since a large portion of these names is common. To cut down on this duplication, a special technique called <span class="emphasis"><em>message compression</em></span> is used.</p><div class="sect3" title="Using Message Compression to Avoid Duplication of a Full Name"><div class="titlepage"><div><div><h3 class="title"><a id="using_message_compression_to_avoid_dupli"/>Using Message Compression to Avoid Duplication of a Full Name</h3></div></div></div><p>Using message compression, instead of a DNS name encoded using the combination of labels and label lengths, a two-byte subfield represents a <span class="emphasis"><em>pointer</em></span> to another location in the message where the name can be found. The first two bits of this subfield are set to 1 (the value 11 in binary), and the remaining 14 bits contain an <span class="emphasis"><em>offset</em></span> that specifies where in the message the name can be found, counting the first byte of the message (the first byte of the ID field) as 0.</p><p>Let's go back to our example. Suppose that in the DNS message, the RData field of the MX record, containing <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a>, begins at byte 47. In this first instance, we would find the name encoded in full as follows:</p><a id="I_programlisting8_d1e60878"/><pre class="programlisting">[4] m a i l [13] x y z i n d u s t r i e s [3] c o m [0]</pre><p>However, in the second instance, where <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> shows up in the Name field of the A record, we would instead put two 1 bits, followed by the number 47 encoded in binary. So, this would be the 16-bit binary pattern 11000000 00101111, or two numeric byte values 192 and 47. This second instance now takes 2 bytes instead of duplicating the 24 bytes needed for the first instance of the name.</p><p>How does a device reading a Name field differentiate a pointer from a real name? This is the reason that 11 is used at the start of the field. Doing this guarantees that the first byte of the pointer will always have a value of 192 or larger. Since labels are restricted to a length of 63 or less, when the host reads the first byte of a name, if it sees a value of 63 or less in a byte, it knows this is a real name; a value of 192 or more means it is a pointer.</p></div><div class="sect3" title="Using Message Compression to Avoid Duplication of Part of a Name"><div class="titlepage"><div><div><h3 class="title"><a id="using_message_compression_to_avoid-id001"/>Using Message Compression to Avoid Duplication of Part of a Name</h3></div></div></div><p>The previous example shows how pointers can be used to eliminate duplication of a whole name: The name <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> was used in two places, and a pointer was used instead of the second. Pointers are even more powerful than this, however. They can also be used to point to only part of a real name or can be combined with additional labels to provide a compressed representation of a name related to another name in a RR. This provides even greater space savings.</p><p>In the previous example, this means that even the first instance of <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> can be compressed. Recall that the MX record will have <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a> in the Name field and <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a> in the RData field. If the Name field of that record starts at byte 19, then we can encode the RData field as follows:</p><a id="I_programlisting8_d1e60906"/><pre class="programlisting">[4] m a i l [pointer-to-byte-19]</pre><p>The device reading the record will get "mail" for the first label and then read "<a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a>" from the Name field to get the complete name, <a class="ulink" href="http://mail.xyzindustries.com">mail.xyzindustries.com</a>.</p><p>Similarly, suppose we had a record in this same message that contained a reference to the parent domain for <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a>, which is "com." This could simply be encoded as follows:</p><a id="I_programlisting8_d1e60921"/><pre class="programlisting">[pointer-to-byte-33]</pre><p>The reason is that byte 33 is where we find the <code class="literal">[3] c o m [0]</code> part of the Name field containing <code class="literal">[13] x y z i n d u s t r i e s [3] c o m [0]</code>.</p></div></div></div>
<div class="sect1" title="DNS Master File Format"><div class="titlepage"><div><div><h1 class="title"><a id="dns_master_file_format"/>DNS Master File Format</h1></div></div></div><p><a class="indexterm" id="idx-CHP-57-2091"/>DNS servers answer queries from clients by sending reply messages containing RRs. You have already seen in this chapter the binary message formats used to encode these RRs. These message formats are great for transmitted messages, because they are compact and efficient. Computers have no problem reading fields very quickly and knowing how to interpret a particular string of ones and zeros.</p><p>Humans, on the other hand, don't deal well with cryptic codes in binary. Before an RR can be provided by a server, it is necessary for a human administrator to tell the server what those records are and what information they contain. To make this job easier, DNS includes a special text representation for zones and RRs. Administrators edit special <span class="emphasis"><em>master files</em></span> that describe the zone and the records it contains. These files are then read into memory by the server's DNS software and converted into binary form for responding to client requests. This is described in more detail in <a class="xref" href="ch56.html" title="Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS">Chapter 56</a>.</p><p>Each master file consists of a simple, flat text file that can be created with any sort of text editor. Each file contains a number of lines expressed using a simple set of syntax rules that describe a zone and the records within it. The basic syntactic rules for DNS master files are specified in RFC 1035, Section 5.1. Certain DNS implementations use their own variations on the syntax in the standard, though they are all pretty similar.</p><div class="sect2" title="DNS Common Master File Record Format"><div class="titlepage"><div><div><h2 class="title"><a id="dns_common_master_file_record_format"/>DNS Common Master File Record Format</h2></div></div></div><p>Just as all RRs are stored internally using a common field format, they also use a common <a class="indexterm" id="idx-CHP-57-2092"/>master file format. Each record normally appears on a separate line of the file. This format is as follows, with optional fields shown in square brackets:</p><a id="I_programlisting8_d1e60965"/><pre class="programlisting">&lt;<em class="replaceable"><code>domain-name</code></em>&gt;  [&lt;<em class="replaceable"><code>ttl</code></em>&gt;]  &lt;<em class="replaceable"><code>class</code></em>&gt;  &lt;<em class="replaceable"><code>type</code></em>&gt;  &lt;<em class="replaceable"><code>rdata</code></em>&gt;</pre><p>The fields are as follows:</p><p><code class="literal">&lt;<em class="replaceable"><code>domain-name</code></em>&gt;</code> A DNS domain name, which may be either an FQDN or a partially qualified name (PQDN).</p><p><code class="literal">&lt;<em class="replaceable"><code>ttl</code></em>&gt;</code> A TTL value, in seconds, for the record. If omitted, the default TTL value for the zone is used. In fact, most RRs do not have a specified TTL and just use the default provided by the SOA record.</p><p><code class="literal">&lt;<em class="replaceable"><code>class</code></em>&gt;</code> The RR class. For modern DNS, this field is optional, and it defaults to IN, for Internet.</p><p><code class="literal">&lt;<em class="replaceable"><code>type</code></em>&gt;</code> The RR type, specified using a text code such as A or NS, not the numeric code.</p><p><code class="literal">&lt;<em class="replaceable"><code>rdata</code></em>&gt;</code> RR data, which is a set of space-separated entries that depends on the record type.</p><p>The <code class="literal">&lt;</code><em class="replaceable"><code>rdata</code></em><code class="literal">&gt;</code> can be either a single piece of information or a set of entries, depending on the record type. In the case of longer record types, especially the SOA record, multiple entry <code class="literal">&lt;</code><em class="replaceable"><code>rdata</code></em><code class="literal">&gt;</code> fields are spread over several lines and enclosed in parentheses; the parentheses make all the entries act as if they were on a single line. Note that if the <code class="literal">&lt;</code><em class="replaceable"><code>ttl</code></em><code class="literal">&gt;</code> field is present, the order of it and the <code class="literal">&lt;</code><em class="replaceable"><code>class</code></em><code class="literal">&gt;</code> field may be switched without any problems, because one is a number and the other text (IN).</p></div><div class="sect2" title="Use and Interpretation of Partially Qualified Domain Names (PQDNs)"><div class="titlepage"><div><div><h2 class="title"><a id="use_and_interpretation_of_partially_qual"/>Use and Interpretation of Partially Qualified Domain Names (PQDNs)</h2></div></div></div><p>Domain names may be mixed between FQDNs and PQDNs (described in <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>). PQDNs are used to make master files faster to create and more readable, by cutting down on the common parts of names. They are sort of the human equivalent of DNS message compression. An FQDN is shown as a full domain name ending in a dot (.) to represent the DNS name tree root. A PQDN is given as just a partial name with no root, and is interpreted as an FQDN by the software reading the master file. (See the description of the <code class="literal">$ORIGIN</code> directive in the next section for more information.)</p><p>It is important to remember the trailing dot to mark FQDNs. If the origin is <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a> and in its zone file the name bigisp.net appears, the server will read this as <a class="ulink" href="http://bigisp.net.xyzindustries.com">bigisp.net.xyzindustries.com</a>—probably not what you want. Also, email addresses, such as the <code class="literal">&lt;</code><em class="replaceable"><code>r-name</code></em><code class="literal">&gt;</code> field in the SOA record, have the @ of the email address converted to a dot, following the standard DNS convention.</p></div><div class="sect2" title="Master File Directives"><div class="titlepage"><div><div><h2 class="title"><a id="master_file_directives"/>Master File Directives</h2></div></div></div><p><a class="indexterm" id="idx-CHP-57-2093"/>In addition to RRs, most master file implementations also support the use of <a class="indexterm" id="idx-CHP-57-2094"/><span class="emphasis"><em>directives</em></span>. These are commands that specify certain important pieces of information to guide how the master file is to be interpreted. The following are three of the most common <a class="indexterm" id="idx-CHP-57-2095"/>directives:</p><p><code class="literal">$ORIGIN</code> Specifies the domain name that is appended to unqualified specifications. This is the base used to convert PQDNs to FQDNs. For example, if the origin is <a class="ulink" href="http://xyzindustries.com">xyzindustries.com</a>., then a PQDN such as "sales" will be interpreted as <a class="ulink" href="http://sales.xyzindustries.com">sales.xyzindustries.com</a>. Once defined, the origin can be referenced by just using @ in place of a name, as you will see in the example of a sample master file shown at the end of this section.</p><p><code class="literal">$TTL</code> Specifies the default TTL value to be used for any RRs that do not specify a TTL value in the record itself. (This value was formerly specified by the Minimum field in the SOA record.)</p><p><code class="literal">$INCLUDE</code> Allows one master file to include the contents of another. This is sometimes used to save the duplication of certain entries that are common between zones.</p></div><div class="sect2" title="Syntax Rules for Master Files"><div class="titlepage"><div><div><h2 class="title"><a id="syntax_rules_for_master_files"/>Syntax Rules for Master Files</h2></div></div></div><p><a class="indexterm" id="idx-CHP-57-2096"/>There are a few other syntax rules for <a class="indexterm" id="idx-CHP-57-2097"/>DNS master files, some of which are intended to save time or energy on the part of administrators:</p><p><span class="strong"><strong>Multiple-Record Shorthand</strong></span> If multiple consecutive records pertain to the same domain, the <code class="literal">&lt;</code><em class="replaceable"><code>domain-name</code></em><code class="literal">&gt;</code> is specified for the first one and can be then be left blank for the subsequent ones. The server will assume that any RRs without a <code class="literal">&lt;</code><em class="replaceable"><code>domain-name</code></em><code class="literal">&gt;</code> indicated apply to the last <code class="literal">&lt;</code><em class="replaceable"><code>domain-name</code></em><code class="literal">&gt;</code> it saw.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-57-2098"/>Comments</strong></span> A semicolon (;) marks a comment. Any text from the semicolon until the end of the line is ignored.</p><p><span class="strong"><strong>Escape Character</strong></span> A backslash (\) is used to "escape" the special meaning of a character. For example, a double-quotation (quote) mark (") is used to delimit text strings; a literal double-quote character is indicated by a backslash–double-quote combination (\").</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-57-2099"/>White Space</strong></span> Tabs and spaces are used as delimiters and blank lines are ignored. For readability, most smart administrators indent using tabs to clarify which records belong with which names, and group records using blank lines and comments.</p><p><span class="strong"><strong>Case</strong></span> Like DNS domain names, master file entries are case-insensitive.</p></div><div class="sect2" title="Specific RR Syntax and Examples"><div class="titlepage"><div><div><h2 class="title"><a id="specific_rr_syntax_and_examples"/>Specific RR Syntax and Examples</h2></div></div></div><p>The following <a class="indexterm" id="idx-CHP-57-2100"/>sections show the specific <a class="indexterm" id="idx-CHP-57-2101"/>formats and examples for each of the common RR types. The fields are basically the same as the ones explained in the <a class="indexterm" id="idx-CHP-57-2102"/>NS binary record formats. The examples include explanatory comments using the DNS comment format. Assume that these examples are for the zone googleplex.edu.</p><div class="sect3" title="A (Address) RR"><div class="titlepage"><div><div><h3 class="title"><a id="a_address_rr"/>A (Address) RR</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2103"/>The format for an A record is as follows:</p><a id="I_programlisting8_d1e61212"/><pre class="programlisting">&lt;<em class="replaceable"><code>domain-name</code></em>&gt; [&lt;<em class="replaceable"><code>ttl</code></em>&gt;] IN A &lt;<em class="replaceable"><code>ip-address</code></em>&gt;
<a class="indexterm" id="idx-CHP-57-2104"/></pre><p>Here is an example:</p><a id="I_programlisting8_d1e61232"/><pre class="programlisting">admin1.googleplex.edu IN A 204.13.100.3    ; An FQDN
admin2 IN A 204.13.100.44                  ; A PQDN equivalent to
                                           ; admin2.googleplex.edu</pre></div><div class="sect3" title="NS (Name Server) RR"><div class="titlepage"><div><div><h3 class="title"><a id="ns_name_server_rr"/>NS (Name Server) RR</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2105"/>The format for an NS record is as follows:</p><a id="I_programlisting8_d1e61242"/><pre class="programlisting">&lt;<em class="replaceable"><code>domain-name</code></em>&gt;  [&lt;<em class="replaceable"><code>ttl</code></em>&gt;]  IN  NS  &lt;<em class="replaceable"><code>name-server-name</code></em>&gt;</pre><p>Here is an example:</p><a id="I_programlisting8_d1e61255"/><pre class="programlisting">&lt; googleplex.edu. IN NS custns.bigisp.net  ; Secondary NS</pre></div><div class="sect3" title="CName (Canonical Name) RR"><div class="titlepage"><div><div><h3 class="title"><a id="cname_canonical_name_rr"/>CName (Canonical Name) RR</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2106"/><a class="indexterm" id="idx-CHP-57-2107"/>The format for a CName record is as follows:</p><a id="I_programlisting8_d1e61270"/><pre class="programlisting">&lt;<em class="replaceable"><code>domain-name</code></em>&gt;  [&lt;<em class="replaceable"><code>ttl</code></em>&gt;]  IN  CNAME  &lt;<em class="replaceable"><code>canonical-name</code></em>&gt;</pre><p>Here is an example:</p><a id="I_programlisting8_d1e61283"/><pre class="programlisting">www IN CNAME bigserver   ; www.googleplex.edu is really
                         ; bigserver.googleplex.edu.</pre></div><div class="sect3" title="SOA (Start Of Authority) RR"><div class="titlepage"><div><div><h3 class="title"><a id="soa_start_of_authority_rr"/>SOA (Start Of Authority) RR</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2108"/>The format for an <a class="indexterm" id="idx-CHP-57-2109"/>SOA record is as follows:</p><a id="I_programlisting8_d1e61299"/><pre class="programlisting">&lt;<em class="replaceable"><code>domain-name</code></em>&gt; [&lt;<em class="replaceable"><code>ttl</code></em>&gt;] IN SOA &lt;<em class="replaceable"><code>m-name</code></em>&gt; &lt;<em class="replaceable"><code>r-name</code></em>&gt; (
      &lt;<em class="replaceable"><code>serial-number</code></em>&gt;
      &lt;<em class="replaceable"><code>refresh-interval</code></em>&gt;
      &lt;<em class="replaceable"><code>retry-interval</code></em>&gt;
      &lt;<em class="replaceable"><code>expire-interval</code></em>&gt;
      &lt;<em class="replaceable"><code>default-ttl</code></em>&gt;)</pre><p>Here is an example:</p><a id="I_programlisting8_d1e61331"/><pre class="programlisting">&lt; googleplex.edu. IN SOA ns1.googleplex.edu it.googleplex.edu (
      42     ; Version 42 of the zone.
      21600  ; Refresh every 6 hours.
      3600   ; Retry every hour.
      604800 ; Expire after one week.
      86400) ; Negative Cache TTL is one day.</pre></div><div class="sect3" title="PTR (Pointer) RR"><div class="titlepage"><div><div><h3 class="title"><a id="ptr_pointer_rr"/>PTR (Pointer) RR</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2110"/><a class="indexterm" id="idx-CHP-57-2111"/>The format for a <a class="indexterm" id="idx-CHP-57-2112"/>PTR record is as follows:</p><a id="I_programlisting8_d1e61350"/><pre class="programlisting">&lt;<em class="replaceable"><code>reverse-domain-name</code></em>&gt; [&lt;<em class="replaceable"><code>ttl</code></em>&gt;] IN PTR &lt;<em class="replaceable"><code>domain-name</code></em>&gt;</pre><p>Here is an example:</p><a id="I_programlisting8_d1e61363"/><pre class="programlisting">3.100.13.204.IN-ADDR.ARPA. IN PTR admin1.googleplex.edu.</pre><p>Note that the PTR record would actually be in the IN-ADDR.ARPA domain.</p></div><div class="sect3" title="MX (Mail Exchange) RR"><div class="titlepage"><div><div><h3 class="title"><a id="mx_mail_exchange_rr"/>MX (Mail Exchange) RR</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2113"/><a class="indexterm" id="idx-CHP-57-2114"/>The format of an <a class="indexterm" id="idx-CHP-57-2115"/>MX record is as follows:</p><a id="I_programlisting8_d1e61384"/><pre class="programlisting">&lt;<em class="replaceable"><code>domain-name</code></em>&gt; [&lt;<em class="replaceable"><code>ttl</code></em>&gt;] IN MX &lt;<em class="replaceable"><code>preference-value</code></em>&gt; &lt;<em class="replaceable"><code>exchange-name</code></em>&gt;</pre><p>Here is an example:</p><a id="I_programlisting8_d1e61400"/><pre class="programlisting">googleplex.edu.     IN MX 10 mainmail.googleplex.edu.
                    IN MX 20 backupmail.googleplex.edu</pre></div><div class="sect3" title="TXT (Text) RR"><div class="titlepage"><div><div><h3 class="title"><a id="txt_text_rr"/>TXT (Text) RR</h3></div></div></div><p><a class="indexterm" id="idx-CHP-57-2116"/><a class="indexterm" id="idx-CHP-57-2117"/>The format of a <a class="indexterm" id="idx-CHP-57-2118"/>TXT record is as follows:</p><a id="I_programlisting8_d1e61419"/><pre class="programlisting">&lt;<em class="replaceable"><code>domain-name</code></em>&gt; [&lt;<em class="replaceable"><code>ttl</code></em>&gt;] IN TXT &lt;<em class="replaceable"><code>text-information</code></em>&gt;
<a class="indexterm" id="idx-CHP-57-2119"/></pre><p>Here is an example:</p><a id="I_programlisting8_d1e61439"/><pre class="programlisting">googleplex.edu. IN TXT "Contact Joe at X321 for more info."</pre></div></div><div class="sect2" title="Sample Master File"><div class="titlepage"><div><div><h2 class="title"><a id="sample_master_file"/>Sample Master File</h2></div></div></div><p>The following is a real-world example of a DNS master file, taken from my own <a class="ulink" href="http://pcguide.com">pcguide.com</a> server (slightly modified), hosted by (and DNS information provided by) the fine folks at <a class="ulink" href="http://pair.com">pair.com</a>. Note the use of @ as a shortcut to mean "this domain" (<a class="ulink" href="http://pcguide.com">pcguide.com</a>).</p><a id="I_programlisting8_d1e61455"/><pre class="programlisting">$ORIGIN pcguide.com.
@ IN SOA ns23.pair.com. root.pair.com. (
      2001072300  ; Serial
      3600        ; Refresh
      300         ; Retry
      604800      ; Expire
      3600 )      ; Minimum

@ IN NS ns23.pair.com.
@ IN NS ns0.ns0.com.

localhost  IN A  127.0.0.1
@          IN A  209.68.14.80
           IN MX 50  qs939.pair.com.

www    IN CNAME   @
ftp    IN CNAME   @
mail   IN CNAME   @
relay  IN CNAME   relay.pair.com.</pre></div></div>
<div class="sect1" title="DNS Changes to Support IPv6"><div class="titlepage"><div><div><h1 class="title"><a id="dns_changes_to_support_ipv6"/>DNS Changes to Support IPv6</h1></div></div></div><p><a class="indexterm" id="idx-CHP-57-2120"/>Version 4 of the Internet Protocol (IPv4) is the basis of today's Internet and the foundation upon which the TCP/IP protocol suite is built. While IPv4 has served us well for over two decades, it has certain important drawbacks that would limit internetworks of the future if it were to continue to be used. For this reason, the next generation of IP, IP version 6 (IPv6), has been in development for many years. IPv6 will eventually replace IPv4 and take TCP/IP into the future.</p><p>The change from IPv4 to IPv6 will have effects that ripple to other TCP/IP protocols, including DNS. DNS is a higher-level protocol, so you might think that based on the principle of layering, a change to IP should not affect it. However, this is another example of how strict layering doesn't always apply. DNS works directly with IP addresses, and one of the most significant modifications that IPv6 makes to IP is in the area of addressing, so this means that using DNS on IPv6 requires some <a class="indexterm" id="idx-CHP-57-2121"/>changes to how the protocol works.</p><div class="sect2" title="IPv6 DNS Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="ipv6_dns_extensions"/>IPv6 DNS Extensions</h2></div></div></div><p>In fact, because DNS is so architecturally distant from IP down there at layer 3, the changes required are not extensive. RFC 1886, "<a class="indexterm" id="idx-CHP-57-2122"/>IPv6 <a class="indexterm" id="idx-CHP-57-2123"/>DNS Extensions," published in December 1995, was the Internet Engineering Task Force's (IETF's) first formalized attempt to describe the changes needed in DNS to support IPv6. It defines three specific modifications to DNS for IPv6:</p><p><span class="strong"><strong>New RR Type—<a class="indexterm" id="idx-CHP-57-2124"/>AAAA (IPv6 Address)</strong></span> The regular DNS Address (A) RR is defined for a 32-bit IPv4 address, so a new one was created to allow a domain name to be associated with a 128-bit <a class="indexterm" id="idx-CHP-57-2125"/>IPv6 address. The four <span class="emphasis"><em>A</em></span>s (AAAA) are a mnemonic to indicate that the <a class="indexterm" id="idx-CHP-57-2126"/>IPv6 address is four times the size of the IPv4 address. The AAAA record is structured in very much the same way as the A record in both binary and master file formats; it is just much larger. The DNS RR Type value for AAAA is 28.</p><p><span class="strong"><strong>New Reverse Resolution Hierarchy</strong></span> A new hierarchical structure similar to IN-ADDR.ARPA is defined for IPv6 reverse lookups, but the IETF put it in a different top-level domain (TLD). The new domain is <a class="indexterm" id="idx-CHP-57-2127"/><span class="emphasis"><em>IP6.INT</em></span> and is used in a way similar to how IN-ADDR.ARPA works. However, since IPv6 addresses are expressed in hexadecimal instead of dotted-decimal, IP6.INT has 16 subdomains 0 through F, and each of those has 16 subdomains 0 through F, and so on, 16 layers deep. Yes, this leads to a potentially frightfully large reverse resolution database!</p><p><span class="strong"><strong>Changes to Query Types and Resolution Procedure</strong></span> All query types that work with A records or result in A records being included in the Additional section of a reply must be changed to also handle AAAA records. Also, queries that would normally result in A records being returned in the Additional section must return the corresponding AAAA records only in the Answer section, not in the Additional section.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-351"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Even though DNS resides far above IP in the TCP/IP protocol suite architecture, it works intimately with IP addresses. For this reason, changes are required to allow it to support the new IPv6. These changes include the definition of a new IPv6 address RR (AAAA), a new reverse resolution domain hierarchy, and certain changes to how messaging is performed.</p></div></div><div class="sect2" title="Proposed Changes to the IPv6 DNS Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="proposed_changes_to_the_ipv6_dns_extensi"/>Proposed Changes to the IPv6 DNS Extensions</h2></div></div></div><p>In 2000, the IETF published RFC 2874, "DNS Extensions to Support IPv6 Address Aggregation and Renumbering." This standard proposed a replacement for the IPv6 support introduced in RFC 1886, using a new record type, A6, instead of RFC 1886's AAAA. The main difference between AAAA and A6 records is that the former are just whole addresses like A records, while A6 records can contain either a whole or partial address.</p><p>The idea behind RFC 2874 was that A6 records could be set up in a manner that complements the IPv6 format for unicast addresses (see <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a>). Then name resolution would involve a technique called <span class="emphasis"><em>chaining</em></span> to determine a full address for a name from a set of partially specified address components. In essence, this would make the addresses behave much the way hierarchical names themselves work, providing some potential flexibility benefits.</p><p>For a couple of years, both RFC 1886 and RFC 2874 were proposed standards, and this led to considerable confusion. In August 2002, RFCs 3363 and 3364 were published, which clarified the situation with these two proposals. RFC 3363 represents the "Supreme Court decision," which was that RFC 2874 and the A6 record be changed to experimental status and the AAAA record of RFC 1886 be kept as the DNS IPv6 standard.</p><p>The full explanation for the decision can be found in RFC 3364. In a nutshell, it boiled down to the IETF believing that there were significant potential risks in the successful implementation of RFC 2874. While the capabilities of the A6 record were interesting, it was not clear that they were needed, and given those risks, the IETF felt that sticking with RFC 1886 was the better move.</p></div></div></body></html>