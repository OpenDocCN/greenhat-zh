- en: Chapter 6. EXPLORE PROXIMITY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Maps are all about proximity. What's nearby? How far is it from one location
    to another? This chapter will help you answer those questions with your own maps.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you'll be using another service, such as Yahoo!'s Local Search
    API. In others, Mapstraction comes through with some handy functions. We'll also
    rely on some mathematicians far smarter than I am to help us make sense of a two-dimensional
    coordinate system applied to earth's three-dimensional sphere.
  prefs: []
  type: TYPE_NORMAL
- en: '#36: Calculate Distance Between Two Points'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the ancient times of paper maps, determining the distance between two places
    on a map required using the map's scale and some measuring device. I would often
    use a scrap of paper or my finger to duplicate the length for the number of times
    necessary to calculate the distance. Without a ruler, calculating the distance
    was not an exact science. Some providers still show scales, but Mapstraction makes
    performing the calculation yourself unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a map with two markers: `marker1` and `marker2`. You can
    determine the latitude and longitude points of these markers and, from there,
    derive the distance. Or, you can let Mapstraction do it for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The result is the number of kilometers from `marker1`'s location to `marker2`'s
    location. The `distance` function can be called on any `LatLonPoint`, with a second
    `LatLonPoint` passed as an argument. A marker's `LatLonPoint` is stored in the
    `location` property.
  prefs: []
  type: TYPE_NORMAL
- en: What's really happening with this calculation? Isn't it the simple Pythagorean
    Theorem that we all learned in grade school—*a*² + *b*² = *c*²? Unfortunately,
    not quite. Pythagoras was working in two dimensions and the earth is a three-dimensional
    ellipsoid—that is, a slightly warped sphere.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. MAPPING BASICS"), I described the latitude
    and longitude system, where the distance between degrees of longitude gets smaller
    the farther a point is from the equator. In other words, Pythagoras will get you
    *close enough* if you're in Ecuador, but your calculation would be way off in
    Sweden.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need another strangely named formula—the *Haversine*. This function uses
    the radius of the earth and some fancy spherical trigonometry. Here is a slightly
    altered version of Mapstraction''s distance function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The very first thing this function does is calculate the multiplier ❶ needed
    to convert degrees into radians, which the trigonometry functions use to calculate
    the distance required. A radian is about 57 degrees (180 degrees divided by pi).
    To convert latitude and longitude decimal degrees to radians, we need to multiply
    by the number of radians in a degree, which is roughly 1/57 (pi divided by 180
    degrees).
  prefs: []
  type: TYPE_NORMAL
- en: Then we get into the Haversine formula, which determines the shortest distance
    between two points on a sphere. To get a usable distance, we must know the radius
    of the sphere. In this case, we use the radius of the earth in kilometers ❷. To
    get miles, use a radius of 3958\. Or multiply the kilometer result by 0.6213\.
    Mapstraction also has two helper functions, `KMToMiles` and `milesToKM`, to perform
    these conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Could You Throw an Object Across a River?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This math makes my head hurt, so let's look at a practical example. Well, throwing
    things may not be practical in your locale, but in Portland, the Willamette River
    runs through the middle of the city. Naturally, I often wonder whether something
    could be thrown across the river.
  prefs: []
  type: TYPE_NORMAL
- en: The farthest distance a human has thrown an object was when Erin Hemmings threw
    a disc 1333 feet, over a quarter mile (0.4 km). In this example, we'll see if
    the distance from Portland's downtown west bank to the east bank of the Willamette
    is less than Hemmings' toss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we want to visualize this on a map, so we add the following code
    to the JavaScript section of our basic map, replacing any JavaScript already there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Be sure you call the `create_map` function when the page loads and that you
    have a `div` tag with its `id` set to `mymap`, just as you did with the basic
    map. Within the function, along with creating the Mapstraction map, this code
    creates two points, one for each side of the river. Then it calculates the distance
    between those two points ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We could stop here, but let's add something visual to the map, so it makes more
    sense. Let's add a marker for each of the two points. Then, to make things really
    clear, let's draw a line between the points ❷. You can see how this map looks
    in [Figure 6-1](ch06.html#two_points_and_the_distance_between_them "Figure 6-1. Two
    points and the distance between them").
  prefs: []
  type: TYPE_NORMAL
- en: Below the map, we show the user the distance that we calculated. We do this
    by adding a new text node below the map `div` ❸. The text will show the distance,
    which is 0.22 km. Compare this to the record, and you can see that, if your name
    is Erin Hemmings, you can indeed throw an object across the Willamette River!
  prefs: []
  type: TYPE_NORMAL
- en: '![Two points and the distance between them](httpatomoreillycomsourcenostarchimages672049.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. Two points and the distance between them
  prefs: []
  type: TYPE_NORMAL
- en: '#37: Find True Distance with Routing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Determining the distance between two points is at the crux of searching. That's
    why Mapstraction gives you access to the distance function described in the previous
    project. However, this function only tells you the distance as the crow flies.
    I have yet to see any crows using maps.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to determine the driving distance between two points, you need a
    lot of information. You need to have a map's underlying data that stores intersections
    and whether a street is one way or two way. Then you need an algorithm to determine
    optimal routes. Creating this on your own would be a chore, so in this example,
    you'll take advantage of the driving directions service from the Google Maps API.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, you'll still be using Mapstraction, but you'll be counting
    on Google to calculate the distance. That means you'll need to load the Google
    API, so you'll likely use Google as your mapping provider. You could load a second
    provider and display the Google routing results on its map, however.
  prefs: []
  type: TYPE_NORMAL
- en: You need to understand what's going on here. Unlike calculating the simple distance
    between points, which relies on a formula, here you need to send the points to
    Google and wait for a reply. Due to the wait time for results, performing this
    over many points is not advisable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to the routing code. For this example, I''ll use the two points
    from the standard distance calculation and compare the results. Add this to the
    JavaScript section of your basic map, replacing any other code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because much of the setup is similar to the map in the previous distance project,
    let's start by discussing the Google-specific code. We can create a `DirectionsService`
    object ❶ because the Google API has been loaded. Even though we usually talk to
    Google through Mapstraction, here we're communicating with Google directly.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've created the `DirectionsService` object, we can do something with
    it. The first thing we do is prepare options ❷, such as our starting and finishing
    points, for our directions search. Because our points were created for Mapstraction,
    we need to convert them to Google's proprietary format. Then we send those options
    to Google along with a callback function ❸ to receive the results.
  prefs: []
  type: TYPE_NORMAL
- en: When the directions have loaded, Google calls our `setDDist` function. We add
    the driving directions route to the map as a proprietary Google polyline ❹, which
    will help us visually compare the two distance methods. Then we can get the driving
    distance for these directions in meters ❺. To convert to kilometers, just divide
    by 1000.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll add a new text node below the map `div` ❻, which will communicate
    both distances to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Driving distance compared to Haversine distance](httpatomoreillycomsourcenostarchimages672051.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2. Driving distance compared to Haversine distance
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 6-2](ch06s02.html#driving_distance_compared_to_haversine_d
    "Figure 6-2. Driving distance compared to Haversine distance"), the distance you
    have to drive is much farther than the lazy crow has to fly. Seeing as the shortest
    distance between two points is a straight line, the routing results will always
    be farther. In this case, because only so many bridges cross the Willamette River,
    the effect is magnified, at least until Google includes swimming directions in
    its API.
  prefs: []
  type: TYPE_NORMAL
- en: '#38: Create Driving Directions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most useful feature of mapping websites has always been their driving
    directions. The routing technology behind driving direction is more advanced than
    most developers can take on, but Google provides access to driving directions
    via its API. In this section, I'll create a directions widget that could help
    any business show its customers the way to the store. In this case, I'll use La
    Bonita, a Mexican restaurant where I wrote much of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example depends heavily on the Google Maps API, so this project is one
    of the few where I won''t use Mapstraction. To start, let''s add some basic HTML
    to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is for a basic, pretty much empty HTML page. We'll fill it
    in with a form to accept user input and JavaScript to ask Google for driving directions.
    First, let's look at a few new elements, and I'll explain what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript section, I hard-coded La Bonita's address ❶. You can replace
    this with your business address or the location of a party. Then, customers or
    guests will later input their own address. Together, these two addresses will
    make up the start and end points for the driving directions.
  prefs: []
  type: TYPE_NORMAL
- en: When the page loads, we're calling the `create_map` function ❷, just as we've
    done in most Mapstraction examples. That's because I made this function up; I
    could have called anything, as it's not tied to Mapstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Down in the HTML, I included a second `div` ❸. This tag will hold the driving
    direction text. This second `div` is after the map `div`, so the directions will
    be listed below the map. This part of the driving directions service is optional
    (in fact, I omitted it in [#37: Find True Distance with Routing](ch06s02.html
    "#37: Find True Distance with Routing") in [#37: Find True Distance with Routing](ch06s02.html
    "#37: Find True Distance with Routing")), but the text is important for this example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve put the shell of an HTML page together, let''s add the pieces
    that will make this map work. In the blank space above the map `div` (and just
    below the `<h1>` tag), include this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Most forms send data to the server, but with this example, we want to use JavaScript.
    This means when the user submits the form, we need to call a JavaScript function
    ❹. Then we need to return false to keep the browser from sending the data to the
    server anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code asks for the user''s location in three pieces: address, city, and
    state. You could use just one or two fields if you want, but separating them out
    into separate fields helps make your format expectations clear. On the other hand,
    prepping the call to the driving directions service will be more work.'
  prefs: []
  type: TYPE_NORMAL
- en: The state is shown as a drop-down menu ❺. In the case of my example, I have
    only included Oregon and Washington. La Bonita's food is good, but nobody is going
    to travel very far to get it. You can include the states where your customers
    are most likely to live.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll hook everything together with JavaScript. At a minimum, we need
    to create the two functions we''ve already referenced in our HTML: `create_map`
    will get the Google Map ready, and `loadDir` will send the addresses to Google''s
    driving directions service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to the JavaScript section, below La Bonita''s address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we make the `gdir` variable global by declaring it outside of a function
    ❶. That way, the variable can be referenced from anywhere in the code. After creating
    the map, we also need to initialize the `gdir` variable ❷, so Google knows we're
    going to be asking for driving directions.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost ready for a user to interact with our form. Let's look at the
    function, `loadDir`, that is called when the form is submitted. First, the function
    pieces together the address with the city/state ❸. You might prefer to check for
    empty or malformed content in these fields, but this simple example merely concatenates
    them together.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set up the options ❹, including the two addresses, that tells Google
    what directions to find. Finally, the function sends the options to Google along
    with a callback function ❺. In the `setDir` function, which receives the driving
    directions, we simply tell Google to render the route on the map and the text
    below the map, as shown in [Figure 6-3](ch06s04.html#driving_directions_from_google
    "Figure 6-3. Driving directions from Google").
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it. We''ve created driving directions to get anyone to La Bonita. To
    use it for your business, simply alter the `myaddress` variable and fill in the
    appropriate states. To see an example that digs a little deeper into driving directions,
    see [#73: Find a Coffee Shop to Meet in the Middle](ch10s06.html "#73: Find a
    Coffee Shop to Meet in the Middle") in [#73: Find a Coffee Shop to Meet in the
    Middle](ch10s06.html "#73: Find a Coffee Shop to Meet in the Middle").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the full documentation for Google''s driving directions: [http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService](http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService)'
  prefs: []
  type: TYPE_NORMAL
- en: '#39: Determine Closest Marker'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a point and a whole bunch of markers, can you find the one closest to
    your point? In this project, we'll loop through every marker on the map and draw
    a line between wherever the user clicks and its closest marker, which we'll determine
    by calculating the distance between two points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can find the closest marker, however, we need a map with a handful
    of markers plotted. To do this, we''ll get five random points, as shown earlier
    in the chapter. Here, I''ve reprinted the `get_random_by_bounds` function you''ll
    need from that section. Add these lines to your JavaScript section at the top
    of your basic map, but make sure they are outside of the `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Driving directions from Google](httpatomoreillycomsourcenostarchimages672053.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3. Driving directions from Google
  prefs: []
  type: TYPE_NORMAL
- en: 'With that helper function ready, add these lines to your basic map''s `create_map`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming you''ve already initialized the map, you can almost dive into creating
    the markers. First, you need to create the bounds for the markers, which represents
    the area you''ll use to create the random location. In this case, I used some
    points ❶ that roughly define the "four corners" states in the United States: Arizona,
    Utah, Colorado, and New Mexico.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create a loop ❷ to perform the same bit of code five times. Each
    time through the loop, we'll get a new random point ❸, so our markers could be
    anywhere within the bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, I'd ask Mapstraction to center and zoom automatically when using random
    markers. Here, however, I set the bounds to be the quartet of states ❹, the same
    area that could possibly hold a marker. This way, I know the markers will all
    be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we listen for the user to click the map. Upon a click, we tell Mapstraction
    to call a function to find the closest marker ❺. Now we need to write that function.
    Add these lines to your JavaScript, outside of the `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to find the closest marker to the point the user clicked, we need
    to check the distance between each marker and the click point. We need to keep
    two pieces of data during our search: the current closest marker we have found
    and its distance to the point.'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we create those two variables and assume the first marker (remember
    JavaScript array indexes start at zero) is currently closest ❻. So we know what
    distance to compare, we also calculate the first marker's distance to the point
    ❼. Now we're ready to loop through all the other markers ❽, starting with the
    second one.
  prefs: []
  type: TYPE_NORMAL
- en: Each time through the loop, we calculate the distance between the current marker
    and the click point. If the distance is farther than the closest distance we have
    found so far, we do nothing. If this current marker is now closer than the previous
    ❾ one, we replace our original two variables with new values.
  prefs: []
  type: TYPE_NORMAL
- en: After the loop, I created a new polyline between the point where the user clicked
    and the marker that we determined is closest ❿. Load this example into a web browser
    and click around a few times. You'll create several lines, connecting multiple
    markers if you move around enough (see [Figure 6-4](ch06s04.html#each_click_connects_to_its_closest_marke
    "Figure 6-4. Each click connects to its closest marker.")). Which marker is closest
    to Albuquerque? How about Denver?
  prefs: []
  type: TYPE_NORMAL
- en: '![Each click connects to its closest marker.](httpatomoreillycomsourcenostarchimages672055.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4. Each click connects to its closest marker.
  prefs: []
  type: TYPE_NORMAL
- en: '#40: Find a Point Along a Line'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you're taking a short flight with your forgetful pilot friend from
    Wichita, Kansas, to Tulsa, Oklahoma, about 140 miles. "Oops," he says nonchalantly
    after you're airborne, "I forgot to gas up." I know what you're thinking—turn
    around! But your friend assures you there is enough gas to go 80 miles, which
    should get you into Oklahoma where the gas is cheaper.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the distance between two points is useful, but sometimes you want to
    know the story between those points. For example, what's the midpoint between
    two cities? Or, given point A and point B, what are the coordinates of point C
    that is nine miles along that line? It's a math-heavy problem to solve, but doing
    so makes for some fun possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fun might not be the right word if you were really flying on a near-empty tank
    from Wichita to Tulsa. But you would definitely want to know where along that
    route you will be after 80 miles when the engine starts to sputter. You would
    be smart to double-check: *will you get to Oklahoma, as your friend claims?* After
    all, this information is coming from the guy who forgot to put gas in his airplane.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the answer to the question, we''ll use a three step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Plot our starting and ending points on a map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate our bearing (direction) using the two points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the bearing and starting point to find a new point 80 miles away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's get started while there's still time to turn around.
  prefs: []
  type: TYPE_NORMAL
- en: Plot Your Route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since planes fly in a straight line, we''ll use a simple polyline, similar
    to the initial example in [#16: Draw Lines on a Map](ch04.html#number_symble_16_colon_draw_lines_on
    "#16: Draw Lines on a Map") in [#16: Draw Lines on a Map](ch04.html#number_symble_16_colon_draw_lines_on
    "#16: Draw Lines on a Map"). All we need are the starting and ending points for
    the two airports.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a line between Wichita and Tulsa, add the following function to your
    basic map, replacing your current `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and load it up. Your map should look similar to [Figure 6-5](ch06s05.html#direct_route_between_wichita_and_tulsa
    "Figure 6-5. Direct route between Wichita and Tulsa").
  prefs: []
  type: TYPE_NORMAL
- en: Do you think you can make it to Oklahoma? The 80 miles of fuel in the tank will
    take you almost 60 percent through your route. It's going to be close. Let's continue
    and find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![Direct route between Wichita and Tulsa](httpatomoreillycomsourcenostarchimages672057.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5. Direct route between Wichita and Tulsa
  prefs: []
  type: TYPE_NORMAL
- en: Find Your Bearing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to find a point along a line, you first need to know the direction
    that the line is pointed. The direction is called the bearing, and it is a number
    expressed in degrees, from 0 to 359\. Most compasses mark these degrees around
    the outside, along with the four cardinal directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll write a function to calculate the bearing for us, based
    on the work of Chris Veness of Movable Type Ltd. ([http://movable-type.co.uk/](http://movable-type.co.uk/)).
    Add the following code to the JavaScript section of your map file, but outside
    the `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Along with the function to calculate the bearing, I've also included a couple
    helper functions to convert between degrees and radians. The trigonometry we use
    is less complicated when using radians (that's right—the math could be even more
    complicated). However, we also need to convert back since degrees are what Mapstraction
    expects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from within your `create_map` function, add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we call the `get_bearing` function, passing our two points. The result
    should be about 146 degrees. Notice that if you swap the order of the arguments
    to the function, the result will be different: about 326 degrees. That''s because
    you travel a different direction to go from Tulsa to Wichita. Since it''s the
    exact opposite direction, the two results are 180 degrees different.'
  prefs: []
  type: TYPE_NORMAL
- en: We're going from Wichita to Tulsa, so we'll take that result and use it in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Determine New Point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we know the direction we're traveling. That's an important step toward finding
    the point that is 80 miles along our route. It's time to employ some more fancy
    math using the bearing and the coordinates of our starting point, Wichita.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section we''ll write another function, again based on the work of Chris
    Veness. Add the following code to your JavaScript, taking care to not put it inside
    any other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to call our newly created function. Add the following code inside
    the `create_map` function, just after the line that calculates the bearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the distance we're passing to the new function is 128, not 80\.
    That's because the function expects the distance in *kilometers*, not miles. This
    matches the way Mapstraction calculates distance. To convert miles to kilometers,
    multiply the miles by 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Take a deep breath before you load your changes. Along with determining the
    point 80 miles along the path, the code creates and adds a marker to the map,
    as shown in [Figure 6-6](ch06s05.html#miles_from_wichita_gets_you_into_oklahom
    "Figure 6-6. 80 Miles from Wichita gets you into Oklahoma!").
  prefs: []
  type: TYPE_NORMAL
- en: '![80 Miles from Wichita gets you into Oklahoma!](httpatomoreillycomsourcenostarchimages672059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6. 80 Miles from Wichita gets you into Oklahoma!
  prefs: []
  type: TYPE_NORMAL
- en: And you can take another deep breath, because it looks like 80 miles of gas
    will get you from Wichita into Oklahoma where, according to your forgetful pilot
    friend, you can fill up for less. As for finding a landing strip, that's another
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to find a point along a line, try out a less hypothetical
    project. [#73: Find a Coffee Shop to Meet in the Middle](ch10s06.html "#73: Find
    a Coffee Shop to Meet in the Middle") in [#73: Find a Coffee Shop to Meet in the
    Middle](ch10s06.html "#73: Find a Coffee Shop to Meet in the Middle") combines
    the project you just finished with driving directions and local search results.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The point you find will only appear directly on the line over short distances,
    like the 140-mile trip in this example. For larger distances, the point will be
    correct, but the line will be wrong. Standard polylines do not take the curvature
    of the earth into consideration. To get a line that follows the "great circle"
    shortest distance between two points, you'll need to use a geodesic polyline,
    which is supported by Google.
  prefs: []
  type: TYPE_NORMAL
- en: '#41: Plot Local Results on a Map'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are searching nearby, sooner or later you want to find businesses that
    meet certain qualifications. For example, in Portland we're always looking for
    coffee. In San Francisco, where this example takes place, that means finding delicious,
    cheap burritos.
  prefs: []
  type: TYPE_NORMAL
- en: In this project we'll use JavaScript to perform a local search for the keyword
    *burritos*. Both Google and Yahoo! have APIs that allow for this type of search.
    In this example, we'll use Yahoo! because it is simple and to the point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re starting with a basic Mapstraction map, so we minimize the number of
    provider-specific calls. Because most of my examples have used Google as a provider,
    double-check that you''re calling the Yahoo! Maps API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the external JavaScripts loaded, replace any existing inline JavaScript
    code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To be able to use Yahoo-specific calls, we need to grab the map object ❶. Then
    we need to let the map know that we're interested in an event, which will occur
    when our search is complete. We also reference a function where the results can
    be sent ❷. We'll create that function in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to write the code that actually initiates a local search to Yahoo!
    ❸. The `searchLocal` function requires four values to be passed to it: We send
    the center of the map, the search query, the search radius (in miles) ❹, and the
    number of results ❺.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we write the `plotResults` function. Add the following lines below the
    `create_map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The search results are passed from Yahoo! as a parameter ❶ to our function.
    The parameter is a special object that contains a number of pieces of information
    about each business we found. We want to extract the latitude, longitude, address,
    and business name from the object, which we do by looping ❷ through the results.
  prefs: []
  type: TYPE_NORMAL
- en: Each time through the loop, we access the four pieces of information we require
    for a business. To get usable latitude and longitude values, we need to use the
    JavaScript helper function `parseFloat` ❸. This function converts textual values
    into the floating point numbers required for coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The rest is probably old hat to you by now. We create a marker, put text in
    the message box (the name and address of the location), and when we've added all
    the markers, we make sure they can all be seen on the map ❹, as shown in [Figure 6-7](ch06s07.html#local_results_plotted_on_a_yahoo_exclama
    "Figure 6-7. Local results plotted on a Yahoo! map").
  prefs: []
  type: TYPE_NORMAL
- en: '#42: Retrieve Local Results with HTTP'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On many occasions you'll want to use something more powerful than JavaScript
    to perform a local search. For example, you may want to store the results in a
    database or output them into an RSS feed. In either case, the approach used in
    the previous project just won't do. Instead, we'll use Yahoo!'s Local Search API
    and access it with PHP, a popular server-side programming language available on
    many web hosts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Local results plotted on a Yahoo! map](httpatomoreillycomsourcenostarchimages672061.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7. Local results plotted on a Yahoo! map
  prefs: []
  type: TYPE_NORMAL
- en: Before we bring the results into code, let's see what they look like. One of
    the great things about an API like the one we're using is that it outputs plain-text
    XML, which can be interpreted by a web browser and is human-readable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the concepts in this project may be considered advanced. They build
    upon those introduced in [Chapter 8](ch08.html "Chapter 8. DATA FORMATS") and
    [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like going to an ordinary web page, you can access the Local Search API
    by visiting a URL. Try typing this search for burritos in San Francisco into your
    location bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The request parameters are highlighted in bold. The first, your `appid`, is
    your Yahoo! API key. The `query` is what you're searching for and the `location`
    is where you're searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the results are loaded, you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Like most XML documents, the results declare themselves to be XML ❶ on the first
    line. The second line is the root element ❷ of the document, meaning it contains
    all other tags below it. Every result is stored within a `<Result>` tag ❸, with
    data items stored within tags one level below.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on the terms used to describe XML, see [#52: Use XML](ch08.html#number_symble_52_colon_use_xml
    "#52: Use XML") in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52:
    Use XML"), which also contains a more in-depth description of parsing XML than
    I''ll provide in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Parse Local Results with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewing the XML that Yahoo! returns within a browser is one thing. Even more
    useful is to read it into PHP, which allows you to do even more. In this example,
    we'll get the same burrito results as in the previous section and print out the
    name of the first restaurant found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new PHP file and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I've stored the three parameters as PHP variables. This makes it easy for you
    to include your own API key and change the search terms. Go ahead and change what
    we're searching for, or include your own city. Notice that, even though we're
    hard-coding the search criteria, I've used the `urlencode` function to make sure
    the URL remains valid. For example, the encoding of the location ❶ will replace
    the spaces and comma with URL-friendly versions of those characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I put the parameters together in URL form ❷, so we can retrieve the results.
    The actual call to download the web page happens in another function ❸, which
    you can find described in detail in [#61: Retrieve a Web Page](ch09s03.html "#61:
    Retrieve a Web Page") in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve
    a Web Page").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the PHP code prints out the name of the first result: El Farolito
    in the example results. You are more likely to want to do something more interesting
    with the results than print out the first name, but this gives you an idea of
    how to access the items.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Useful Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, I showed just three parameters that you can use to
    search with Yahoo!''s Local Search API: `appid` (required), `query` (required
    for most searches), and `location`.'
  prefs: []
  type: TYPE_NORMAL
- en: Many more options are available, the most interesting of which I've included
    in [Table 6-1](ch06s07.html#additional_parameters_accepted_by_yahoo "Table 6-1. Additional
    Parameters Accepted by Yahoo! Local Search").
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1. Additional Parameters Accepted by Yahoo! Local Search
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `city`, `state`, and `zip` | Any of these three can be used, alone or in
    combination, to replace the free-form `location` parameter used in the example.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `latitude` and `longitude` | If both of these are used, they take the place
    of any other location data and set the search center at the point created by the
    coordinates. |'
  prefs: []
  type: TYPE_TB
- en: '| `radius` | Sets the maximum distance (in miles) from the search location.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `results` | Declares the number of results, from 1 to 20\. The default value
    is 10. |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Indicates how the results will be sorted, using one of four options:
    `distance`, `rating`, `relevance`, or `title`. The default value is `relevance`.
    |'
  prefs: []
  type: TYPE_TB
- en: More parameters are listed in Yahoo!'s documentation,^([[2](#ftn.CHP-6-FN-1)])
    but with the examples here you should be able to get some interesting results.
    Where's your nearest taxidermist?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#CHP-6-FN-1)]) [http://developer.yahoo.com/search/local/V3/localSearch.html](http://developer.yahoo.com/search/local/V3/localSearch.html)
  prefs: []
  type: TYPE_NORMAL
- en: '#43: Check Whether a Point Is Within a Bounding Box'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the most important shapes in mapping is the rectangle. After centuries,
    we still view maps in a rectangular shape, even with today's fancy JavaScript.
    A rectangle can also be easily described (you only need two points), and determining
    if a point is within a specific rectangle requires no fancy math.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see in later in this project, checking for a point within a `BoundingBox`
    is the first step. You might also use this to determine, for example, whether
    all the markers are on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Because finding if a point is within a rectangle is such a useful feature, Mapstraction
    has baked it in as a function. Given any `BoundingBox` object, you can pass a
    `LatLonPoint` and receive back either true (within the box) or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s code to determine whether a point is within the map view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What's happening? It's not that complicated. A `BoundingBox` is determined by
    its southwest and northeast points (see [Figure 6-8](ch06s08.html#a_boundingbox_is_declared_by_its_southwe
    "Figure 6-8. A BoundingBox is declared by its southwest and northeast points.")).
    So to be within a box, your latitude must be between the latitude of those two
    points. Longitude is the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![A BoundingBox is declared by its southwest and northeast points.](httpatomoreillycomsourcenostarchimages672063.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8. A `BoundingBox` is declared by its southwest and northeast points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a slightly altered version of Mapstraction''s `BoundingBox contains`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the math is fairly straightforward, but that would be a lot of code to
    write out each time. I'm sure glad Mapstraction does it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Can You Click Inside the Box?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to check for points inside a box, let's try it. This example
    will create a bounding box smaller than the viewable map. When the user clicks,
    we check whether the point where he or she clicked is inside our box.
  prefs: []
  type: TYPE_NORMAL
- en: To make things clear, we'll draw a polyline around the bounding box, making
    it easy to tell whether Mapstraction returns the correct results. Do you think
    you can click inside the box?
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code into the JavaScript section of a basic map, replacing
    any existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the map, we make a somewhat arbitrary bounding box ❶ around
    San Francisco. Then we take that same box and make it visible on the map by tracing
    its edges ❷. We use the `BoundingBox_to_Polyline` function, which I explain in
    detail in [#19: Draw a Rectangle to Declare an Area](ch04s04.html "#19: Draw a
    Rectangle to Declare an Area") in [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area"). For convenience, I have reprinted
    it here.'
  prefs: []
  type: TYPE_NORMAL
- en: Next we need to listen for clicks on the map ❸. When the user clicks, we need
    to see if the clicked point is within the box. To do this, we call the `contains`
    function on the `BoundingBox` object we created ❹. The outcome (true or false)
    will determine what message we display to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To communicate the outcome to the user, we add a new marker where the user clicked
    and open up its message box ❺ to display whether the click was inside the bounds.
    Try it a few times. Click inside, click outside—it gets it right every time! An
    example result is shown in [Figure 6-9](ch06s08.html#clicking_a_point_within_the_bounding_box
    "Figure 6-9. Clicking a point within the bounding box").
  prefs: []
  type: TYPE_NORMAL
- en: '![Clicking a point within the bounding box](httpatomoreillycomsourcenostarchimages672065.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-9. Clicking a point within the bounding box
  prefs: []
  type: TYPE_NORMAL
- en: '#44: Get a Random Point in a Bounding Box'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quick! Think of a number between −122.9 and −122.8! Though not an ordinary question,
    you may find yourself asking it while creating maps. Especially for testing, you'll
    want to be able to generate random geographic points, often within a specific
    area. In a way, finding a random point within a box is the opposite of the previous
    project.
  prefs: []
  type: TYPE_NORMAL
- en: I've created a special function just for creating random points. You may have
    even seen it in other parts of this book. In this section, I'll describe it briefly,
    and then use it in an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to get a random point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The most important piece of information that this function needs is to know
    the general area, or the *bounds*, where you want the random point. This information
    is passed as the single parameter ❶ of this function, a Mapstraction `BoundingBox`
    object. The `BoundingBox` object is made up of the southwest (SW) and northeast
    (NE) corners of a rectangular area. Between those two points, you can determine
    the maximum and minimum values of the edges.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know where the point will be, but we still need to make the point random
    using a built-in JavaScript function ❷. The number returned by `Math.random` is
    a decimal between 0 and 1, which is not likely to be what you want. We can, however,
    use that number, multiplied by our range ❸, to determine the random coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to get the random latitude, we take the NE latitude minus the SW
    latitude and multiply that answer (the distance in degrees between the two latitudes)
    by the random number. Then, we add the SW latitude (the smallest of the two) to
    the outcome. As a result, our smallest latitude (when the random number is zero)
    will be the same as the SW latitude; the largest latitude (when the random number
    is one) will be the same as the NE latitude.
  prefs: []
  type: TYPE_NORMAL
- en: The same process is then applied to the longitude but with a new random number.
    Now that we have a latitude and a longitude, we can return the two numbers as
    a new `LatLonPoint` ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example using a random point. Be sure you have the `get_random_by_bounds`
    function in your JavaScript code and then add the following lines to the `create_map`
    function of a basic map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We need some bounds to be able to pass to the random point function. In this
    case, I made up some points ❶ roughly located around my hometown of Portland,
    Oregon. When creating a new `BoundingBox`, we must pass four numbers in this order:
    SW latitude, SW longitude, NE latitude, and NE longitude.'
  prefs: []
  type: TYPE_NORMAL
- en: Next we get the random point ❷ by passing the bounds we just created. Remember
    the function we created used a `return` to share the new random point. When we
    call the function, we can declare a variable (which I called `pt`) to store that
    returned value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the random point, I used it to create a new marker and then placed
    the marker on the map. If you want to visually check that the point is really
    within your bounds, try incorporating [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area") in [#19: Draw a Rectangle to Declare
    an Area](ch04s04.html "#19: Draw a Rectangle to Declare an Area") with this one.'
  prefs: []
  type: TYPE_NORMAL
- en: '#45: Check Whether a Point Is Within a Shape'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did the user just click on Kansas? Is this address within the city limits? These
    questions are common ones you'll want to answer with a *hit test*, the process
    used to determine whether a point is inside a shape. To do so requires some data
    (the outline of the shape) and a little math. In this section, I'll show how you
    can crunch the coordinates and find the answers to these and other questions.
  prefs: []
  type: TYPE_NORMAL
- en: First, the data. A shape can be described as a series of latitude and longitude
    points, where the start and end are the same point, enclosing a polygon. You may
    be able to create the shape you want by tracing the border. You can likely find
    someone sharing their shape online. For example, polygons for all 50 US states
    can be found at [http://mapscripting.com/state-boundaries](http://mapscripting.com/state-boundaries).
  prefs: []
  type: TYPE_NORMAL
- en: We'll perform a hit test to see if the point where a user clicks is inside a
    state. Seeing as Kansas is somewhat rectangular, let's choose a state that has
    a slightly more complex shape, such as Utah (see [Figure 6-10](ch06s10.html#the_state_of_utah_apostrophy_s_panhandle
    "Figure 6-10. The state of Utah's panhandle makes for a good hit test.")). The
    edges of Utah are made up of six points, which means describing Utah as a line
    requires seven points (because the final point needs to reconnect with the first
    point).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some Mapstraction code to describe the outline of Utah as a series
    of coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we want to write a function that determines whether a particular point is
    within the polygon that could be created with these points. Our point could be
    anywhere on the earth. Seeing as Utah is a relatively small area, our point is
    quite likely not in the state. Let's rule that out quickly—before getting to the
    advanced math.
  prefs: []
  type: TYPE_NORMAL
- en: '![The state of Utah''s panhandle makes for a good hit test.](httpatomoreillycomsourcenostarchimages672067.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-10. The state of Utah's panhandle makes for a good hit test.
  prefs: []
  type: TYPE_NORMAL
- en: Find the Polygon's Bounding Box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to determine that a point is *not* within a polygon is to show
    the point lies outside the polygon's bounding box. To determine the rectangular
    bounds of a polygon, we must look through each point, so we can find the minimum
    and maximum values for both latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have those values, we'll know what to use to create the bounding box.
    An example of one is shown in [Figure 6-11](ch06s10.html#a_polygon_apostrophy_s_rectangular_bound
    "Figure 6-11. A polygon's rectangular bounds").
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a function to create a new Mapstraction `BoundingBox` from a series
    of `LatLonPoints`. Here is the code for the entire function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![A polygon''s rectangular bounds](httpatomoreillycomsourcenostarchimages672069.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-11. A polygon's rectangular bounds
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to determine four values: the smallest latitude, the largest latitude,
    the smallest longitude, and the largest longitude. Because we have to start somewhere,
    we begin with the assumption that the first point is both minimum and maximum.
    That''s simply so we have something to compare.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, beginning with the second point (which has an index of one because JavaScript
    array indexes start at zero), we loop through all the other points ❶. Each time
    through the loop, we check whether we have found new minimum or maximum values.
    For example, if the current point has a latitude greater than what we currently
    think is the maximum ❷, then we need to set the maximum to be this value ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have completed the loop, the four values will be correct. Those values
    represent the corners of a `BoundingBox`. The SW corner is made up of the minimum
    values, the NE corner of the maximum. We can create the `BoundingBox` and return
    it for use elsewhere ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the bounds, we can check whether a point is within the polygon
    with the simple rectangle that surrounds our polygon. I covered this in detail
    earlier, and I'll demonstrate it again in a few sections when we perform the complete
    hit test.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Our Point to an Outside Point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, if we've gotten this far, we've determined that our point is inside the
    polygon's bounding box. This doesn't mean the point is within the polygon itself,
    but it's at least nearby. In our Utah example, our point is in the very northeast
    corner of the bounding box, but not inside the Utah polygon.
  prefs: []
  type: TYPE_NORMAL
- en: Now the tricky stuff begins, but within this trickery, you'll find simplicity.
    We need to make a temporary line for testing. This line connects our point (the
    one that may be inside the polygon) to a point that we can guarantee is outside
    the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: When we draw the temporary line, it may intersect the line segments that make
    up our polygon. If the lines crosses the polygon an odd number of times, our point
    is inside. If it crosses the polygon an even number of times, or not at all, our
    point is outside. [Figure 6-12](ch06s10.html#polygon_representing_utah_only_intersect
    "Figure 6-12. Polygon representing Utah only intersected once—the point is inside
    the shape.") provides a visual of the Utah example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Polygon representing Utah only intersected once—the point is inside the shape.](httpatomoreillycomsourcenostarchimages672071.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-12. Polygon representing Utah only intersected once—the point is inside
    the shape.
  prefs: []
  type: TYPE_NORMAL
- en: The hit test is only conclusive if we can guarantee the new point we create
    will be outside the polygon. How can we do that? We'll create a latitude for our
    new point that is less than the SW latitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the point we''re testing is called `mypt` and our `BoundingBox` is called
    `box`, here''s the code to create our testing point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to move very far outside the bounding box. To determine how much
    to change the latitude, I took the number of degrees between the SW and NE ❶ and
    divided by 100\. In the case of Utah, our new point would be 0.05 degrees below
    the southern border. The smaller the difference between north and south latitudes,
    the closer the new point will be to the bounding box—but the point will always
    be outside of the box.
  prefs: []
  type: TYPE_NORMAL
- en: For the longitude of the new point, I set it to be the same as the longitude
    of the point we're checking. That decision was arbitrary, as any longitude would
    create a point outside the bounding box, because the latitude is less than the
    box's smallest latitude.
  prefs: []
  type: TYPE_NORMAL
- en: Check for Line Intersections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have a bounding box and a point outside the box that can be connected
    with the point we want to test. The final step is to determine how many times
    the line connecting those two points crosses the polygon. To do this, we need
    to know how to check whether two lines intersect.
  prefs: []
  type: TYPE_NORMAL
- en: The code becomes a little confusing because there are many variables, despite
    only working with two line segments. We have four separate points or eight different
    values. From two to four to eight. Like I said, things become confusing quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add in a little vector math (based on a solution written in Visual Basic and
    available at [http://www.vb-helper.com/howto_segments_intersect.html](http://www.vb-helper.com/howto_segments_intersect.html)),
    and the code starts to look complicated. Here is the JavaScript code to test whether
    a line segment from point A to B intersects with another from point C to D:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the code does is calculate how far away the ends of each line
    are, such as the distance between the latitudes of point A and B ❶. These values
    become the foundation of the vector computations that will determine whether the
    lines intersect.
  prefs: []
  type: TYPE_NORMAL
- en: With just the latitude and longitude distances, we can make sure the lines aren't
    parallel ❷. Determining this saves us further computation because parallel lines
    will never intersect. More importantly, we won't divide by zero with our first
    segment test ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The `segtest1` and `segtest2` variables compare line AB to CD, then vice versa.
    The value determines where the two lines intersect. Because they aren't parallel,
    they *will* intersect somewhere. If both of the segment tests are between 0 and
    1 ❹, then we know the intersection happens within our line segments.
  prefs: []
  type: TYPE_NORMAL
- en: Perform the Hit Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we've found the bounding box of the polygon, drawn a line from
    the point outside the polygon to our point in question, and learned how to determine
    whether two line segments intersect. Do you feel like we've lost track of the
    original plan to find out whether our point is within the polygon? Okay then,
    let's put it all together and perform the hit test.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our point is within the polygon if the line that we created intersects
    an odd number of lines that make up the polygon. We'll need to test each and every
    segment against our line that we know at least *starts* outside the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function, using the pieces we''ve put together earlier in this
    project, to determine whether a point is within a polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The hit test function is passed the point to check and the array of points that
    make up the polygon. From the latter, we're able to determine the bounding box
    of the polygon ❶. Then, of course, we don't have to do anything unless our point
    is within this box ❷. The point cannot be within the polygon if it isn't within
    the polygon's bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to check whether the point is inside the polygon. To do this,
    we create a temporary line between our point and a point outside the bounding
    box ❸. Then we need to check where this line intersects with the polygon. To do
    this, we'll loop through the polygon's points ❹, checking for intersections with
    this temporary line.
  prefs: []
  type: TYPE_NORMAL
- en: Each time through the loop, we make two line segments from four points. The
    first segment is made from two consecutive points from the polygon. The other
    segment is created with our point and the point we found outside the bounding
    box.
  prefs: []
  type: TYPE_NORMAL
- en: We pass these points to the function we created to check for intersections ❺.
    If the two segments cross, we increase the intersection count. Either way, we
    then move on to the next trip through the loop.
  prefs: []
  type: TYPE_NORMAL
- en: When the loop finishes, we'll know whether our point is within the polygon.
    If the intersection count is odd, the point is inside. If the count is even, our
    point is outside. A number is odd if, when dividing it by two, you have a remainder
    of one. The modulus operator, `%`, gives us the remainder ❻. A remainder means
    we have an odd number of intersections, and we return true because the point is
    within the polygon. In all other cases, we return false because the point is not
    within the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: You Clicked in Utah!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we're able to check whether a point is within a polygon, let's incorporate
    it into a map. At the beginning of this chapter, we created a series of points
    shaped like the state of Utah. We'll use that, along with all the other code shown
    so far, to report whether the user has clicked inside the polygon described by
    the `utah` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a basic map and add in the polygon points. We''ll need the functions
    we''ve created so far, too. Make sure to include the `check_polygon`, `check_intersection`,
    and `points_to_bounds` functions. Then add the following code, replacing the `create_map`
    function that already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The first few lines create the new map, center it on Utah, and add zoom controls.
    Then we need to wait for the user to click somewhere on the map ❶. When is the
    user clicks, we initiate an inline, anonymous function, with the click point passed
    as an argument, as shown in [#27: The User Clicks the Map](ch05s02.html "#27:
    The User Clicks the Map") in [#27: The User Clicks the Map](ch05s02.html "#27:
    The User Clicks the Map").'
  prefs: []
  type: TYPE_NORMAL
- en: The difficult work of checking for whether a point is within a polygon is passed
    off to the `check_polygon` function. This function, which we wrote in a previous
    section, returns either `true` or `false`. If the function returns true ❷, we
    create a text variable to tell the user "You clicked in Utah!" Otherwise, the
    user gets a message saying "That's not Utah!"
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to report the click and the outcome. We do this by creating a marker
    at the click point ❸ and putting the text inside a message box. Then we add the
    marker to the page and open the message box.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out for yourself or see [Figure 6-13](ch06s10.html#you_can_apostrophy_t_trick_mathmthat_poi
    "Figure 6-13. You can't trick math—that point is outside of Utah!"). See if you
    can trick the test by clicking in the NE corner of the state, where Wyoming appears
    to intrude into Utah's bounding box. Sure enough, if you click outside of Utah,
    you'll see the correct message. Ditto when clicking inside of Utah. The hit test
    gets the right answer every time.
  prefs: []
  type: TYPE_NORMAL
- en: '![You can''t trick math—that point is outside of Utah!](httpatomoreillycomsourcenostarchimages672073.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-13. You can't trick math—that point is outside of Utah!
  prefs: []
  type: TYPE_NORMAL
- en: '#46: Get Nearest Locations from Your Own Database'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, I showed how to calculate the distance between two
    points and how to determine the closest marker to a point. Arguably more useful
    is what we''ll be doing in this project: getting the nearest location to a point
    from a list of many possibilities stored in a database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To look up locations in a database, we need to have something in the database
    in the first place. For this example, we''ll use the database table from [#63:
    Store Locations to a Database](ch09s05.html "#63: Store Locations to a Database")
    in [Install MySQL Yourself](ch09s04.html#install_mysql_yourself "Install MySQL
    Yourself"). Although we''re using MySQL as an engine, most databases will work
    with the SQL statements here. *Structured query language (SQL)* is a syntax to
    communicate with a database server.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we're looking for the nearest locations to a single point, we need to
    determine what that point is. I've chosen a point near me in Portland, Oregon,
    with a latitude of 45.517 and a longitude of −122.649\. Now we'll plug this into
    the Haversine formula—that's the same bit of trigonometry we used in JavaScript,
    but this time we'll use SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'From either the MySQL command interpreter or phpMyAdmin, type the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We select all the fields from the places table, plus an additional field, as
    described by the entire section in bold. That's a lot of code! It calculates the
    distance between our point and the points in the database using the latitude and
    longitude values stored with each place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance, which becomes a column named `dist`, is expressed in kilometers.
    As with the previous implementation of the Haversine formula, we multiply by the
    radius of the earth, which is 6371 km. For miles, replace the number ❶ with its
    mile equivalent: 3958.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this SQL query, your results will be the same as those shown in
    [Table 6-2](ch06s11.html#results_of_nearest_place_sql "Table 6-2. Results of Nearest
    Place SQL"). Because we ordered by the distance, the places nearest to our point
    come first in the table. Therefore, the nearest place to the point we selected
    is Old Faithful.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2. Results of Nearest Place SQL
  prefs: []
  type: TYPE_NORMAL
- en: '| ID | Name | Latitude | Longitude | Distance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Old Faithful Geyser | 44.4605 | − 110.828 | 936.12 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | St. Louis Arch | 38.6247 | − 90.1851 | 2765.97 |'
  prefs: []
  type: TYPE_TB
