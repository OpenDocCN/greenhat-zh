["```\n#include <fcntl.h>\n#include <kvm.h>\n\nkvm_t *\nkvm_openfiles(const char *execfile, const char *corefile,\n    const char *swapfile, int flags, char *errbuf);\n\n```", "```\n#include <kvm.h>\n#include <nlist.h>\n\nint\nkvm_nlist(kvm_t *kd, struct nlist *nl);\n\n```", "```\n#include <kvm.h>\n\nchar *\nkvm_geterr(kvm_t *kd);\n\n```", "```\n#include <kvm.h>\n\nssize_t\nkvm_read(kvm_t *kd, unsigned long addr, void *buf, size_t nbytes);\n\n```", "```\n#include <kvm.h>\n\nssize_t\nkvm_write(kvm_t *kd, unsigned long addr, const void *buf, size_t nbytes);\n\n```", "```\n#include <fcntl.h>\n#include <kvm.h>\n\nint\nkvm_close(kvm_t *kd);\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n\n/* The system call function. */\nstatic int\nhello(struct thread *td, void *syscall_args)\n{\n        int i;\n        ❶for (i = 0; i < 10; i++)\n                printf(\"FreeBSD Rocks!\\n\");\n\n        return(0);\n}\n\n/* The sysent for the new system call. */\nstatic struct sysent hello_sysent = {\n        0,                      /* number of arguments */\n        hello                   /* implementing function */\n};\n\n/* The offset in sysent[] where the system call is to be allocated. */\nstatic int offset = NO_SYSCALL;\n\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"System call loaded at offset %d.\\n\", offset);\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"System call unloaded from offset %d.\\n\", offset);\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n}\n\nSYSCALL_MODULE(hello, &offset, &hello_sysent, load, NULL);\n\n```", "```\n$ `objdump -dR ./hello.ko`\n\n./hello.ko:     file format elf32-i386-freebsd\n\nDisassembly of section .text:\n\n00000480 <hello>:\n 480:   55                      push   %ebp\n 481:   89 e5                   mov    %esp,%ebp\n 483:   53                      push   %ebx\n 484:   bb 09 00 00 00          mov    $0x9,%ebx\n 489:   83 ec 04                sub    $0x4,%esp\n 48c:   8d 74 26 00             lea    0x0(%esi),%esi\n 490:   c7 04 24 0d 05 00 00    movl   $0x50d,(%esp)\n                        493: R_386_RELATIVE     *ABS*\n 497:   e8 fc ff ff ff          call   498 <hello+0x18>\n                        498: R_386_PC32 printf\n 49c:   4b                      dec    %ebx\n 49d:   79 f1                   jns    490 <hello+0x10>\n 49f:   83 c4 04                add    $0x4,%esp\n 4a2:   31 c0                   xor    %eax,%eax\n 4a4:   5b                      pop    %ebx\n 4a5:   c9                      leave\n 4a6:   c3                      ret\n 4a7:   89 f6                   mov    %esi,%esi\n 4a9:   8d bc 27 00 00 00 00    lea    0x0(%edi),%edi\n\n```", "```\n#include <fcntl.h>\n#include <kvm.h>\n#include <limits.h>\n#include <nlist.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#define SIZE    0x30\n\n/* Replacement code. */\nunsigned char nop_code[] =\n        \"\\x90\\x90\";             /* nop          */\n\nint\nmain(int argc, char *argv[])\n{\n        int i, offset;\n        char errbuf[_POSIX2_LINE_MAX];\n        kvm_t *kd;\n        struct nlist nl[] = { {NULL}, {NULL}, };\n        unsigned char hello_code[SIZE];\n\n        /* Initialize kernel virtual memory access. */\n        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);\n        if (kd == NULL) {\n                fprintf(stderr, \"ERROR: %s\\n\", errbuf);\n                exit(-1);\n        }\n\n        nl[0].n_name = \"hello\";\n\n        /* Find the address of hello. */\n        if (kvm_nlist(kd, nl) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        if (!nl[0].n_value) {\n                fprintf(stderr, \"ERROR: Symbol %s not found\\n\",\n                    nl[0].n_name);\n                exit(-1);\n        }\n        /* Save a copy of hello. */\n        if (kvm_read(kd, nl[0].n_value, hello_code, SIZE) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Search through hello for the jns instruction. */\n\n        ❶ for (i = 0; i < SIZE; i++) {\n                if (hello_code[i] == 0x79) {\n                        offset = i;\n                        break;\n                }\n        }\n\n        /* Patch hello. */\n        if (kvm_write(kd, nl[0].n_value + offset, nop_code,\n           ❷sizeof(nop_code) - 1) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Close kd. */\n        if (kvm_close(kd) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        exit(0);\n}\n\n```", "```\n$ `sudo kldload ./hello.ko`\nSystem call loaded at offset 210.\n$ `perl -e 'syscall(210);'`\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\nFreeBSD Rocks!\n$ `gcc -o fix_hello fix_hello.c -lkvm`\n$ `sudo ./fix_hello`\n$ `perl -e 'syscall(210);'`\nFreeBSD Rocks!\n\n```", "```\n 200:   bb 12 95 00 00          mov    $0x9512,%ebx\n 205:   e8 f6 00 00 00          call   300\n 20a:   b8 2f 14 00 00          mov    $0x142f,%eax\n\n```", "```\n#include <fcntl.h>\n#include <kvm.h>\n#include <limits.h>\n#include <nlist.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#define SIZE    0x30\n\n/* Replacement code. */\nunsigned char nop_code[] =\n        \"\\x90\\x90\";             /* nop          */\n\nint\nmain(int argc, char *argv[])\n{\n        int i, jns_offset, call_offset;\n        char errbuf[_POSIX2_LINE_MAX];\n        kvm_t *kd;\n        struct nlist nl[] = { {NULL}, {NULL}, {NULL}, };\n        unsigned char hello_code[SIZE], call_operand[4];\n\n        /* Initialize kernel virtual memory access. */\n        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);\n        if (kd == NULL) {\n                fprintf(stderr, \"ERROR: %s\\n\", errbuf);\n                exit(-1);\n        }\n\n        nl[0].n_name = \"hello\";\n        nl[1].n_name = \"uprintf\";\n\n        /* Find the address of hello and uprintf. */\n        if (❶kvm_nlist(kd, nl) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        if (!nl[0].n_value) {\n                fprintf(stderr, \"ERROR: Symbol %s not found\\n\",\n                    nl[0].n_name);\n                exit(-1);\n        }\n\n        if (!nl[1].n_value) {\n                fprintf(stderr, \"ERROR: Symbol %s not found\\n\",\n                    nl[1].n_name);\n                exit(-1);\n        }\n\n        /* Save a copy of hello. */\n        if (kvm_read(kd, nl[0].n_value, hello_code, SIZE) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n        /* Search through hello for the jns and call instructions. */\n        for (i = 0; i < SIZE; i++) {\n                if (hello_code[i] == 0x79)\n                        jns_offset = i;\n                if (hello_code[i] == 0xe8)\n                        ❷call_offset = i;\n        }\n\n        /* Calculate the call statement operand. */\n        *(unsigned long *)&call_operand[0] = ❸nl[1].n_value -\n            ❹(nl[0].n_value + call_offset + 5);\n\n        /* Patch hello. */\n        if (kvm_write(kd, nl[0].n_value + jns_offset, nop_code,\n            sizeof(nop_code) - 1) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        if (❺kvm_write(kd, nl[0].n_value + call_offset + 1, call_operand,\n            sizeof(call_operand)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Close kd. */\n        if (kvm_close(kd) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        exit(0);\n}\n\n```", "```\n$ `sudo kldload ./hello.ko`\nSystem call loaded at offset 210.\n$ `perl -e 'syscall(210);'`\n$ `gcc -o fix_hello_improved fix_hello_improved.c -lkvm`\n$ `sudo ./fix_hello_improved`\n$ `perl -e 'syscall(210);'`\nFreeBSD Rocks!\n\n```", "```\n#include <sys/types.h>\n#include <sys/malloc.h>\n\nvoid *\nmalloc(unsigned long size, struct malloc_type *type, int flags);\n\n```", "```\n#include <sys/types.h>\n#include <sys/malloc.h>\n\nMALLOC(space, cast, unsigned long size, struct malloc_type *type, int flags);\n\n```", "```\n(space) = (cast)malloc((u_long)(size), type, flags)\n\n```", "```\n#include <sys/types.h>\n#include <sys/malloc.h>\n\nvoid\nfree(void *addr, struct malloc_type *type);\n\n```", "```\n#include <sys/types.h>\n#include <sys/malloc.h>\n\nFREE(void *addr, struct malloc_type *type);\n\n```", "```\nfree((addr), type)\n\n```", "```\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n\nstruct kmalloc_args {\n        unsigned long size;\n        unsigned long *addr;\n};\n\n/* System call to allocate kernel virtual memory. */\nstatic int\nkmalloc(struct thread *td, void *syscall_args)\n{\n        struct kmalloc_args *uap;\n        uap = (struct kmalloc_args *)syscall_args;\n\n        int error;\n        unsigned long addr;\n\n        ❶MALLOC(addr, unsigned long, uap->size, M_TEMP, M_NOWAIT);\n        ❷error = copyout(&addr, uap->addr, sizeof(addr));\n\n        return(error);\n}\n\n/* The sysent for the new system call. */\nstatic struct sysent kmalloc_sysent = {\n        2,                      /* number of arguments */\n        kmalloc                 /* implementing function */\n};\n\n/* The offset in sysent[] where the system call is to be allocated. */\nstatic int offset = NO_SYSCALL;\n/* The function called at load/unload. */\nstatic int\nload(struct module *module, int cmd, void *arg)\n{\n        int error = 0;\n\n        switch (cmd) {\n        case MOD_LOAD:\n                uprintf(\"System call loaded at offset %d.\\n\", offset);\n                break;\n\n        case MOD_UNLOAD:\n                uprintf(\"System call unloaded from offset %d.\\n\", offset);\n                break;\n\n        default:\n                error = EOPNOTSUPP;\n                break;\n        }\n\n        return(error);\n}\n\nSYSCALL_MODULE(kmalloc, &offset, &kmalloc_sysent, load, NULL);\n\n```", "```\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/module.h>\n\nint\nmain(int argc, char *argv[])\n{\n        int syscall_num;\n        struct module_stat stat;\n\n        unsigned long addr;\n\n        if (argc != 2) {\n                printf(\"Usage:\\n%s <size>\\n\", argv[0]);\n                exit(0);\n        }\n\n        stat.version = sizeof(stat);\n        modstat(modfind(\"kmalloc\"), &stat);\n        syscall_num = stat.data.intval;\n        syscall(syscall_num, (unsigned long)atoi(argv[1]), &addr);\n        printf(\"Address of allocated kernel memory: 0x%x\\n\", addr);\n\n        exit(0);\n}\n\n```", "```\n#include <fcntl.h>\n#include <kvm.h>\n#include <limits.h>\n#include <nlist.h>\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/module.h>\n/* Kernel memory allocation (kmalloc) function code.\n❶unsigned char kmalloc[] =\n        \"\\x55\"                          /* push   %ebp                  */\n        \"\\xb9\\x01\\x00\\x00\\x00\"          /* mov    $0x1,%ecx             */\n        \"\\x89\\xe5\"                      /* mov    %esp,%ebp             */\n        \"\\x53\"                          /* push   %ebx                  */\n        \"\\xba\\x00\\x00\\x00\\x00\"          /* mov    $0x0,%edx             */\n        \"\\x83\\xec\\x10\"                  /* sub    $0x10,%esp            */\n        \"\\x89\\x4c\\x24\\x08\"              /* mov    %ecx,0x8(%esp)        */\n        \"\\x8b\\x5d\\x0c\"                  /* mov    0xc(%ebp),%ebx        */\n        \"\\x89\\x54\\x24\\x04\"              /* mov    %edx,0x4(%esp)        */\n        \"\\x8b\\x03\"                      /* mov    (%ebx),%eax           */\n        \"\\x89\\x04\\x24\"                  /* mov    %eax,(%esp)           */\n        \"\\xe8\\xfc\\xff\\xff\\xff\"          /* call   4e2 <kmalloc+0x22>    */\n        \"\\x89\\x45\\xf8\"                  /* mov    %eax,0xfffffff8(%ebp) */\n        \"\\xb8\\x04\\x00\\x00\\x00\"          /* mov    $0x4,%eax             */\n        \"\\x89\\x44\\x24\\x08\"              /* mov    %eax,0x8(%esp)        */\n        \"\\x8b\\x43\\x04\"                  /* mov    0x4(%ebx),%eax        */\n        \"\\x89\\x44\\x24\\x04\"              /* mov    %eax,0x4(%esp)        */\n        \"\\x8d\\x45\\xf8\"                  /* lea    0xfffffff8(%ebp),%eax */\n        \"\\x89\\x04\\x24\"                  /* mov    %eax,(%esp)           */\n        \"\\xe8\\xfc\\xff\\xff\\xff\"          /* call   500 <kmalloc+0x40>    */\n        \"\\x83\\xc4\\x10\"                  /* add    $0x10,%esp            */\n        \"\\x5b\"                          /* pop    %ebx                  */\n        \"\\x5d\"                          /* pop    %ebp                  */\n        \"\\xc3\"                          /* ret                          */\n        \"\\x8d\\xb6\\x00\\x00\\x00\\x00\";     /* lea    0x0(%esi),%esi        */\n\n/*\n * The relative address of the instructions following the call statements\n * within kmalloc.\n */\n#define OFFSET_1        0x26\n#define OFFSET_2        0x44\n\nint\nmain(int argc, char *argv[])\n{\n\n        int i;\n        char errbuf[_POSIX2_LINE_MAX];\n        kvm_t *kd;\n        struct nlist nl[] = { {NULL}, {NULL}, {NULL}, {NULL}, {NULL}, };\n        unsigned char mkdir_code[sizeof(kmalloc)];\n        unsigned long addr;\n\n        if (argc != 2) {\n                printf(\"Usage:\\n%s <size>\\n\", argv[0]);\n                exit(0);\n        }\n\n        /* Initialize kernel virtual memory access. */\n        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);\n        if (kd == NULL) {\n                fprintf(stderr, \"ERROR: %s\\n\", errbuf);\n                exit(-1);\n        }\n\n        nl[0].n_name = \"mkdir\";\n        nl[1].n_name = \"M_TEMP\";\n        nl[2].n_name = \"malloc\";\n        nl[3].n_name = \"copyout\";\n\n        /* Find the address of mkdir, M_TEMP, malloc, and copyout. */\n        if (kvm_nlist(kd, nl) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        for (i = 0; i < 4; i++) {\n                if (!nl[i].n_value) {\n                        fprintf(stderr, \"ERROR: Symbol %s not found\\n\",\n                            nl[i].n_name);\n                        exit(-1);\n                }\n        }\n\n        /*\n         * Patch the kmalloc function code to contain the correct addresses\n         * for M_TEMP, malloc, and copyout.\n         */\n        *(unsigned long *)&kmalloc[10] = nl[1].n_value;\n        *(unsigned long *)&kmalloc[34] = nl[2].n_value -\n            (nl[0].n_value + OFFSET_1);\n        *(unsigned long *)&kmalloc[64] = nl[3].n_value -\n            (nl[0].n_value + OFFSET_2);\n\n        /* Save sizeof(kmalloc) bytes of mkdir. */\n        if (kvm_read(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Overwrite mkdir with kmalloc. */\n        if (kvm_write(kd, nl[0].n_value, kmalloc, sizeof(kmalloc)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Allocate kernel memory. */\n        syscall(136, (unsigned long)atoi(argv[1]), &addr);\n        printf(\"Address of allocated kernel memory: 0x%x\\n\", addr);\n\n        /* Restore mkdir. */\n        if (kvm_write(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Close kd. */\n        if (kvm_close(kd) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        exit(0);\n}\n\n```", "```\n$ `objdump -dR ./kmalloc.ko`\n\n./kmalloc.ko:     file format elf32-i386-freebsd\n\nDisassembly of section .text:\n\n000004c0 <kmalloc>:\n 4c0:   55                      push   %ebp\n 4c1:   b9 01 00 00 00          mov    $0x1,%ecx\n 4c6:   89 e5                   mov    %esp,%ebp\n 4c8:   53                      push   %ebx\n 4c9:   ba 00 00 00 00          mov    $0x0,%edx\n                        ❶4ca: R_386_32   M_TEMP\n 4ce:   83 ec 10                sub    $0x10,%esp\n 4d1:   89 4c 24 08             mov    %ecx,0x8(%esp)\n 4d5:   8b 5d 0c                mov    0xc(%ebp),%ebx\n 4d8:   89 54 24 04             mov    %edx,0x4(%esp)\n 4dc:   8b 03                   mov    (%ebx),%eax\n 4de:   89 04 24                mov    %eax,(%esp)\n 4e1:   e8 fc ff ff ff          call   4e2 <kmalloc+0x22>\n                        ❷4e2: R_386_PC32 malloc\n 4e6:   89 45 f8                mov    %eax,0xfffffff8(%ebp)\n 4e9:   b8 04 00 00 00          mov    $0x4,%eax\n 4ee:   89 44 24 08             mov    %eax,0x8(%esp)\n 4f2:   8b 43 04                mov    0x4(%ebx),%eax\n 4f5:   89 44 24 04             mov    %eax,0x4(%esp)\n 4f9:   8d 45 f8                lea    0xfffffff8(%ebp),%eax\n 4fc:   89 04 24                mov    %eax,(%esp)\n 4ff:   e8 fc ff ff ff          call   500 <kmalloc+0x40>\n                        ❸500: R_386_PC32 copyout\n 504:   83 c4 10                add    $0x10,%esp\n 507:   5b                      pop    %ebx\n 508:   5d                      pop    %ebp\n 509:   c3                      ret\n 50a:   8d b6 00 00 00 00       lea    0x0(%esi),%esi\n\n```", "```\n        *(unsigned long *)&kmalloc[10] = ❶nl[1].n_value;\n        *(unsigned long *)&kmalloc[34] = ❷nl[2].n_value -\n            ❸(nl[0].n_value + OFFSET_1);\n        *(unsigned long *)&kmalloc[64] = ❹nl[3].n_value -\n            ❺(nl[0].n_value + OFFSET_2);\n\n```", "```\n$ `gcc -o kmalloc_reloaded kmalloc_reloaded.c -lkvm`\n$ `sudo ./kmalloc_reloaded 10`\nAddress of allocated kernel memory: 0xc1bb91b0\n\n```", "```\nKDB: enter: manual escape to debugger\n[thread pid 13 tid 100003 ]\nStopped at      kdb_enter+0x2c: leave\ndb> `examine/x 0xc1bb91b0`\n0xc1bb91b0:     70707070\ndb>\n0xc1bb91b4:     70707070\ndb>\n0xc1bb91b8:     dead7070\n\n```", "```\n$ `nm /boot/kernel/kernel | grep mkdir`\nc04dfc00 T devfs_vmkdir\nc06a84e0 t handle_written_mkdir\nc05bfa10 T kern_mkdir\nc05bfec0 T mkdir\nc07d1f40 B mkdirlisthd\nc04ef6a0 t msdosfs_mkdir\nc06579e0 t nfs4_mkdir\nc066a910 t nfs_mkdir\nc067a830 T nfsrv_mkdir\nc07515b6 r nfsv3err_mkdir\nc06c32e0 t ufs_mkdir\nc07b8d20 D vop_mkdir_desc\nc05b77f0 T vop_mkdir_post\nc07b8d44 d vop_mkdir_vp_offsets\n$ `objdump -d --start-address=0xc05bfec0 /boot/kernel/kernel`\n\n/boot/kernel/kernel:     file format elf32-i386-freebsd\n\nDisassembly of section .text:\n\nc05bfec0 <mkdir>:\nc05bfec0:       55                      push   %ebp\nc05bfec1:       89 e5                   mov    %esp,%ebp\nc05bfec3:       83 ec 10                sub    $0x10,%esp\nc05bfec6:       8b 55 0c                mov    0xc(%ebp),%edx\nc05bfec9:       8b 42 04                mov    0x4(%edx),%eax\nc05bfecc:       89 44 24 0c             mov    %eax,0xc(%esp)\nc05bfed0:       31 c0                   xor    %eax,%eax\nc05bfed2:       89 44 24 08             mov    %eax,0x8(%esp)\nc05bfed6:       8b 02                   mov    (%edx),%eax\nc05bfed8:       89 44 24 04             mov    %eax,0x4(%esp)\nc05bfedc:       8b 45 08                mov    0x8(%ebp),%eax\nc05bfedf:       89 04 24                mov    %eax,(%esp)\nc05bfee2:       e8 29 fb ff ff          call   c05bfa10 <kern_mkdir>\nc05bfee7:       c9                      leave\nc05bfee8:       c3                      ret\nc05bfee9:       8d b4 26 00 00 00 00    lea    0x0(%esi),%esi\n\n```", "```\n$ `nm /boot/kernel/kernel | grep mkdir`\nc047c560 T devfs_vmkdir\nc0620e40 t handle_written_mkdir\nc0556ca0 T kern_mkdir\nc0557030 T mkdir\nc071d57c B mkdirlisthd\nc048a3e0 t msdosfs_mkdir\nc05e2ed0 t nfs4_mkdir\nc05d8710 t nfs_mkdir\nc05f9140 T nfsrv_mkdir\nc06b4856 r nfsv3err_mkdir\nc063a670 t ufs_mkdir\nc0702f40 D vop_mkdir_desc\nc0702f64 d vop_mkdir_vp_offsets\n$ `objdump -d --start-address=0xc0557030 /boot/kernel/kernel`\n\n/boot/kernel/kernel:     file format elf32-i386-freebsd\n\nDisassembly of section .text:\n\nc0557030 <mkdir>:\nc0557030:       55                      push   %ebp\nc0557031:       31 c9                   xor    %ecx,%ecx\nc0557033:       89 e5                   mov    %esp,%ebp\nc0557035:       83 ec 10                sub    $0x10,%esp\nc0557038:       8b 55 0c                mov    0xc(%ebp),%edx\nc055703b:       8b 42 04                mov    0x4(%edx),%eax\nc055703e:       89 4c 24 08             mov    %ecx,0x8(%esp)\nc0557042:       89 44 24 0c             mov    %eax,0xc(%esp)\nc0557046:       8b 02                   mov    (%edx),%eax\nc0557048:       89 44 24 04             mov    %eax,0x4(%esp)\nc055704c:       8b 45 08                mov    0x8(%ebp),%eax\nc055704f:       89 04 24                mov    %eax,(%esp)\nc0557052:       e8 49 fc ff ff          call   c0556ca0 <kern_mkdir>\nc0557057:       c9                      leave\nc0557058:       c3                      ret\nc0557059:       8d b4 26 00 00 00 00    lea    0x0(%esi),%esi\n\n```", "```\n#include <fcntl.h>\n#include <kvm.h>\n#include <limits.h>\n#include <nlist.h>\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/module.h>\n\n/* Kernel memory allocation (kmalloc) function code. */\nunsigned char kmalloc[] =\n. . .\n\n/*\n * The relative address of the instructions following the call statements\n * within kmalloc.\n */\n#define K_OFFSET_1      0x26\n#define K_OFFSET_2      0x44\n\n/* \"Hello, world!\\n\" function code. */\n❶unsigned char hello[] =\n        \"\\x48\"                          /* H                            */\n        \"\\x65\"                          /* e                            */\n        \"\\x6c\"                          /* l                            */\n        \"\\x6c\"                          /* l                            */\n        \"\\x6f\"                          /* o                            */\n        \"\\x2c\"                          /* ,                            */\n        \"\\x20\"                          /*                              */\n        \"\\x77\"                          /* w                            */\n        \"\\x6f\"                          /* o                            */\n        \"\\x72\"                          /* r                            */\n        \"\\x6c\"                          /* l                            */\n        \"\\x64\"                          /* d                            */\n        \"\\x21\"                          /* !                            */\n        \"\\x0a\"                          /* \\n                           */\n        \"\\x00\"                          /* NULL                         */\n        \"\\x55\"                          /* push   %ebp                  */\n        \"\\x89\\xe5\"                      /* mov    %esp,%ebp             */\n        \"\\x83\\xec\\x04\"                  /* sub    $0x4,%esp             */\n        \"\\xc7\\x04\\x24\\x00\\x00\\x00\\x00\"  /* movl   $0x0,(%esp)           */\n        \"\\xe8\\xfc\\xff\\xff\\xff\"          /* call   uprintf               */\n        \"\\x31\\xc0\"                      /* xor    %eax,%eax             */\n        \"\\x83\\xc4\\x04\"                  /* add    $0x4,%esp             */\n        \"\\x5d\";                         /* pop    %ebp                  */\n/*\n * The relative address of the instruction following the call uprintf\n * statement within hello.\n */\n#define H_OFFSET_1      0x21\n\n/* Unconditional jump code. */\nunsigned char jump[] =\n        \"\\xb8\\x00\\x00\\x00\\x00\"          /* movl   $0x0,%eax             */\n        \"\\xff\\xe0\";                     /* jmp    *%eax                 */\n\nint\nmain(int argc, char *argv[])\n{\n        int i, call_offset;\n        char errbuf[_POSIX2_LINE_MAX];\n        kvm_t *kd;\n        struct nlist nl[] = { {NULL}, {NULL}, {NULL}, {NULL}, {NULL},\n            {NULL}, };\n        unsigned char mkdir_code[sizeof(kmalloc)];\n        unsigned long addr, size;\n\n        /* Initialize kernel virtual memory access. */\n        kd = kvm_openfiles(NULL, NULL, NULL, O_RDWR, errbuf);\n        if (kd == NULL) {\n                fprintf(stderr, \"ERROR: %s\\n\", errbuf);\n                exit(-1);\n        }\n\n        nl[0].n_name = \"mkdir\";\n        nl[1].n_name = \"M_TEMP\";\n        nl[2].n_name = \"malloc\";\n        nl[3].n_name = \"copyout\";\n        nl[4].n_name = \"uprintf\";\n\n        /*\n         * Find the address of mkdir, M_TEMP, malloc, copyout,\n         * and uprintf.\n         */\n        if (kvm_nlist(kd, nl) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        for (i = 0; i < 5; i++) {\n                if (!nl[i].n_value) {\n                        fprintf(stderr, \"ERROR: Symbol %s not found\\n\",\n                            nl[i].n_name);\n                        exit(-1);\n                }\n        }\n\n        /* Save sizeof(kmalloc) bytes of mkdir. */\n        if (kvm_read(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n        /* Search through mkdir for call kern_mkdir. */\n        for (i = 0; i < sizeof(kmalloc); i++) {\n                if (mkdir_code[i] == 0xe8) {\n                        call_offset = i;\n                        break;\n                }\n        }\n\n        /* Determine how much memory you need to allocate. */\n        size = (unsigned long)sizeof(hello) + (unsigned long)call_offset +\n            (unsigned long)sizeof(jump);\n\n        /*\n         * Patch the kmalloc function code to contain the correct addresses\n         * for M_TEMP, malloc, and copyout.\n         */\n        *(unsigned long *)&kmalloc[10] = nl[1].n_value;\n        *(unsigned long *)&kmalloc[34] = nl[2].n_value -\n            (nl[0].n_value + K_OFFSET_1);\n        *(unsigned long *)&kmalloc[64] = nl[3].n_value -\n            (nl[0].n_value + K_OFFSET_2);\n\n        /* Overwrite mkdir with kmalloc. */\n        if (kvm_write(kd, nl[0].n_value, kmalloc, sizeof(kmalloc)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Allocate kernel memory. */\n        syscall(136, size, &addr);\n\n        /* Restore mkdir. */\n        if (kvm_write(kd, nl[0].n_value, mkdir_code, sizeof(kmalloc)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /*\n         * Patch the \"Hello, world!\\n\" function code to contain the\n         * correct addresses for the \"Hello, world!\\n\" string and uprintf.\n         */\n        *(unsigned long *)&hello[24] = addr;\n        *(unsigned long *)&hello[29] = nl[4].n_value - (addr + H_OFFSET_1);\n\n        /*\n         * Place the \"Hello, world!\\n\" function code into the recently\n         * allocated kernel memory.\n         */\n        if (kvm_write(kd, addr, hello, sizeof(hello)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /*\n         * Place all the mkdir code up to but not including call kern_mkdir\n         * after the \"Hello, world!\\n\" function code.\n         */\n        if (kvm_write(kd, addr + (unsigned long)sizeof(hello) - 1,\n            mkdir_code, call_offset) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /*\n         * Patch the unconditional jump code to jump back to the call\n         * kern_mkdir statement within mkdir.\n         */\n        *(unsigned long *)&jump[1] = nl[0].n_value +\n            (unsigned long)call_offset;\n\n        /*\n         * Place the unconditional jump code into the recently allocated\n         * kernel memory, after the mkdir code.\n         */\n        if (kvm_write(kd, addr + (unsigned long)sizeof(hello) - 1 +\n            (unsigned long)call_offset, jump, sizeof(jump)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /*\n         * Patch the unconditional jump code to jump to the start of the\n         * \"Hello, world!\\n\" function code.\n         */\n        ❷*(unsigned long *)&jump[1] = addr + 0x0f;\n\n        /*\n         * Overwrite the beginning of mkdir with the unconditional\n         * jump code.\n         */\n        if (kvm_write(kd, nl[0].n_value, jump, sizeof(jump)) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        /* Close kd. */\n        if (kvm_close(kd) < 0) {\n                fprintf(stderr, \"ERROR: %s\\n\", kvm_geterr(kd));\n                exit(-1);\n        }\n\n        exit(0);\n}\n\n```", "```\n$ `gcc -o mkdir_patch mkdir_patch.c -lkvm`\n$ `sudo ./mkdir_patch`\n$ `mkdir TESTING`\nHello, world!\n$ `ls -F`\nTESTING/       mkdir_patch*   mkdir_patch.c\n\n```", "```\nvoid\nsyscall(frame)\n        struct trapframe frame;\n{\n        caddr_t params;\n        struct sysent *callp;\n        struct thread *td = curthread;\n        struct proc *p = td->td_proc;\n        register_t orig_tf_eflags;\n        u_int sticks;\n        int error;\n        int narg;\n        int args[8];\n        u_int code;\n. . .\n        if (code >= p->p_sysent->sv_size)\n                callp = &p->p_sysent->sv_table[0];\n        else\n                ❶callp = &p->p_sysent->sv_table[code];\n. . .\n}\n\n```", "```\n 486:   64 a1 00 00 00 00       mov    %fs:0x0,%eax\n 48c:   8b 00                   mov    (%eax),%eax\n 48e:   8b 80 a0 01 00 00       mov    0x1a0(%eax),%eax\n 494:   8b 40 04                mov    0x4(%eax),%eax\n\n```"]