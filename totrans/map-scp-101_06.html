<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;EXPLORE PROXIMITY"><div class="titlepage"><div><div><h1 class="title"><a id="explore_proximity"/>Chapter 6. EXPLORE PROXIMITY</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e6095"/><img src="httpatomoreillycomsourcenostarchimages671943.png.jpg" alt="image with no caption"/></div></div><p>Maps are all about proximity. What's nearby? How far is it from one location to another? This chapter will help you answer those questions with your own maps.<a id="IDX-CHP-6-0001" class="indexterm"/><a id="IDX-CHP-6-0002" class="indexterm"/><a id="IDX-CHP-6-0003" class="indexterm"/></p><p>In some cases, you'll be using another service, such as Yahoo!'s Local Search API. In others, Mapstraction comes through with some handy functions. We'll also rely on some mathematicians far smarter than I am to help us make sense of a two-dimensional coordinate system applied to earth's three-dimensional sphere.</p><div class="sect1" title="#36: Calculate Distance Between Two Points"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_36_colon_calculate_distanc"/>#36: Calculate Distance Between Two Points</h1></div></div></div><p>In the ancient times of paper maps, determining the distance between two places on a map required using the map's scale and some measuring device. I would often use a scrap of paper or my finger to duplicate the length for the number of times necessary to calculate the distance. Without a ruler, calculating the distance was not an exact science. Some providers still show scales, but Mapstraction makes performing the calculation yourself unnecessary.<a id="IDX-CHP-6-0004" class="indexterm"/><a id="IDX-CHP-6-0005" class="indexterm"/><a id="IDX-CHP-6-0006" class="indexterm"/><a id="IDX-CHP-6-0007" class="indexterm"/></p><p>Let's say you have a map with two markers: <code class="literal">marker1</code> and <code class="literal">marker2</code>. You can determine the latitude and longitude points of these markers and, from there, derive the distance. Or, you can let Mapstraction do it for you:</p><a id="I_programlisting6_d1e6142"/><pre class="programlisting">var dist_km = marker1.location.distance(marker2.location);</pre><p>The result is the number of kilometers from <code class="literal">marker1</code>'s location to <code class="literal">marker2</code>'s location. The <code class="literal">distance</code> function can be called on any <code class="literal">LatLonPoint</code>, with a second <code class="literal">LatLonPoint</code> passed as an argument. A marker's <code class="literal">LatLonPoint</code> is stored in the <code class="literal">location</code> property.</p><p>What's really happening with this calculation? Isn't it the simple Pythagorean Theorem that we all learned in grade school—<span class="emphasis"><em>a</em></span><sup>2</sup> + <span class="emphasis"><em>b</em></span><sup>2</sup> = <span class="emphasis"><em>c</em></span><sup>2</sup>? Unfortunately, not quite. Pythagoras was working in two dimensions and the earth is a three-dimensional ellipsoid—that is, a slightly warped sphere.<a id="IDX-CHP-6-0008" class="indexterm"/></p><p>In <a class="xref" href="ch01.html" title="Chapter 1. MAPPING BASICS">Chapter 1</a>, I described the latitude and longitude system, where the distance between degrees of longitude gets smaller the farther a point is from the equator. In other words, Pythagoras will get you <span class="emphasis"><em>close enough</em></span> if you're in Ecuador, but your calculation would be way off in Sweden.</p><p>You need another strangely named formula—the <span class="emphasis"><em>Haversine</em></span>. This function uses the radius of the earth and some fancy spherical trigonometry. Here is a slightly altered version of Mapstraction's distance function:<a id="IDX-CHP-6-0009" class="indexterm"/></p><a id="I_programlisting6_d1e6203"/><pre class="programlisting">function LatLonPoint_distance(pt1, pt2) {
❶   var rads = Math.PI / 180;
    var diffLat = (pt1.lat-pt2.lat) * rads;
    var diffLon = (pt1.lon-pt2.lon) * rads;
    var a = Math.sin(diffLat / 2) * Math.sin(diffLat / 2) +
            Math.cos(pt1.lat * rads) * Math.cos(pt2.lat * rads) *
            Math.sin(diffLon/2) * Math.sin(diffLon/2);
    return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)) * ❷6371;
  }</pre><p>The very first thing this function does is calculate the multiplier ❶ needed to convert degrees into radians, which the trigonometry functions use to calculate the distance required. A radian is about 57 degrees (180 degrees divided by pi). To convert latitude and longitude decimal degrees to radians, we need to multiply by the number of radians in a degree, which is roughly 1/57 (pi divided by 180 degrees).<a id="IDX-CHP-6-0010" class="indexterm"/></p><p>Then we get into the Haversine formula, which determines the shortest distance between two points on a sphere. To get a usable distance, we must know the radius of the sphere. In this case, we use the radius of the earth in kilometers ❷. To get miles, use a radius of 3958. Or multiply the kilometer result by 0.6213. Mapstraction also has two helper functions, <code class="literal">KMToMiles</code> and <code class="literal">milesToKM</code>, to perform these conversions.</p><div class="sect2" title="Could You Throw an Object Across a River?"><div class="titlepage"><div><div><h2 class="title"><a id="could_you_throw_an_object_across_a_river"/>Could You Throw an Object Across a River?</h2></div></div></div><p>This math makes my head hurt, so let's look at a practical example. Well, throwing things may not be practical in your locale, but in Portland, the Willamette River runs through the middle of the city. Naturally, I often wonder whether something could be thrown across the river.</p><p>The farthest distance a human has thrown an object was when Erin Hemmings threw a disc 1333 feet, over a quarter mile (0.4 km). In this example, we'll see if the distance from Portland's downtown west bank to the east bank of the Willamette is less than Hemmings' toss.</p><p>Naturally, we want to visualize this on a map, so we add the following code to the JavaScript section of our basic map, replacing any JavaScript already there:</p><a id="I_programlisting6_d1e6228"/><pre class="programlisting">var mapstraction;
  var dist;
  var wportland, eportland;
  function create_map() {
    mapstraction = new mxn.Mapstraction('mymap', 'google');
    mapstraction.addSmallControls();
    // Declare points for each side of the river
    wportland = new mxn.LatLonPoint(45.52822, −122.67195);
    eportland = new mxn.LatLonPoint(45.52933, −122.66957);

❶   dist = eportland.distance(wportland); // Calculate distance

    // Show points on the map
    mapstraction.addMarker(new mxn.Marker(wportland));
    mapstraction.addMarker(new mxn.Marker(eportland));
❷   mapstraction.addPolylineWithData(new mxn.Polyline([wportland, eportland]));
    mapstraction.autoCenterAndZoom();

    var disttext = document.createTextNode("Distance is " + dist + " km.");
❸   mapstraction.currentElement.parentNode.appendChild(disttext);
  }</pre><p>Be sure you call the <code class="literal">create_map</code> function when the page loads and that you have a <code class="literal">div</code> tag with its <code class="literal">id</code> set to <code class="literal">mymap</code>, just as you did with the basic map. Within the function, along with creating the Mapstraction map, this code creates two points, one for each side of the river. Then it calculates the distance between those two points ❶.</p><p>We could stop here, but let's add something visual to the map, so it makes more sense. Let's add a marker for each of the two points. Then, to make things really clear, let's draw a line between the points ❷. You can see how this map looks in <a class="xref" href="ch06.html#two_points_and_the_distance_between_them" title="Figure 6-1. Two points and the distance between them">Figure 6-1</a>.</p><p>Below the map, we show the user the distance that we calculated. We do this by adding a new text node below the map <code class="literal">div</code> ❸. The text will show the distance, which is 0.22 km. Compare this to the record, and you can see that, if your name is Erin Hemmings, you can indeed throw an object across the Willamette River!</p><div class="figure"><a id="two_points_and_the_distance_between_them"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6256"/><img src="httpatomoreillycomsourcenostarchimages672049.png.jpg" alt="Two points and the distance between them"/></div></div><p class="title">Figure 6-1. Two points and the distance between them</p></div></div></div></div>
<div class="sect1" title="#37: Find True Distance with Routing"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_37_colon_find_true_distanc"/>#37: Find True Distance with Routing</h1></div></div></div><p>Determining the distance between two points is at the crux of searching. That's why Mapstraction gives you access to the distance function described in the previous project. However, this function only tells you the distance as the crow flies. I have yet to see any crows using maps.<a id="IDX-CHP-6-0011" class="indexterm"/><a id="IDX-CHP-6-0012" class="indexterm"/><a id="IDX-CHP-6-0013" class="indexterm"/></p><p>To be able to determine the driving distance between two points, you need a lot of information. You need to have a map's underlying data that stores intersections and whether a street is one way or two way. Then you need an algorithm to determine optimal routes. Creating this on your own would be a chore, so in this example, you'll take advantage of the driving directions service from the Google Maps API.<a id="IDX-CHP-6-0014" class="indexterm"/><a id="IDX-CHP-6-0015" class="indexterm"/><a id="IDX-CHP-6-0016" class="indexterm"/></p><p>For this example, you'll still be using Mapstraction, but you'll be counting on Google to calculate the distance. That means you'll need to load the Google API, so you'll likely use Google as your mapping provider. You could load a second provider and display the Google routing results on its map, however.</p><p>You need to understand what's going on here. Unlike calculating the simple distance between points, which relies on a formula, here you need to send the points to Google and wait for a reply. Due to the wait time for results, performing this over many points is not advisable.<a id="IDX-CHP-6-0017" class="indexterm"/></p><p>Let's get to the routing code. For this example, I'll use the two points from the standard distance calculation and compare the results. Add this to the JavaScript section of your basic map, replacing any other code:</p><a id="I_programlisting6_d1e6301"/><pre class="programlisting">var mapstraction;
  var gdir;
  var dist, ddist;
  var wportland, eportland;
  function create_map() {
    mapstraction = new mxn.Mapstraction('mymap', 'google');
    mapstraction.addSmallControls();
    // Declare points for each side of the river
    wportland = new mxn.LatLonPoint(45.52822, −122.67195);
    eportland = new mxn.LatLonPoint(45.52933, −122.66957);
    dist = eportland.distance(wportland); // Calculate distance
    mapstraction.addPolylineWithData(new mxn.Polyline([wportland, eportland]));

    // Google-specific code for driving directions
❶   gdir = new google.maps.DirectionsService();
❷   var diropt = {
    origin: wportland.toProprietary(mapstraction.api),
    destination: eportland.toProprietary(mapstraction.api),
    travelMode: google.maps.DirectionsTravelMode.DRIVING
    };
    gdir.route(diropt, ❸setDDist);
  }
  function setDDist() {
    if (status == google.maps.DirectionsStatus.OK) {
      var directionsDisplay = new google.maps.DirectionsRenderer(
                              {map: mapstraction.getMap()});
❹     directionsDisplay.setDirections(response);
❺     ddist = response.routes[0].legs[0].distance.value / 1000;
      // driving distance in km
      var disttext = document.createTextNode("Normal distance is " + dist +
      " km, but driving distance is " + ddist + " km");
❻     mapstraction.currentElement.parentNode.appendChild(disttext);
    }
  }
  function handleErrors(){
    // Handle errors in this section
  }</pre><p>Because much of the setup is similar to the map in the previous distance project, let's start by discussing the Google-specific code. We can create a <code class="literal">DirectionsService</code> object ❶ because the Google API has been loaded. Even though we usually talk to Google through Mapstraction, here we're communicating with Google directly.</p><p>Once we've created the <code class="literal">DirectionsService</code> object, we can do something with it. The first thing we do is prepare options ❷, such as our starting and finishing points, for our directions search. Because our points were created for Mapstraction, we need to convert them to Google's proprietary format. Then we send those options to Google along with a callback function ❸ to receive the results.<a id="IDX-CHP-6-0018" class="indexterm"/><a id="IDX-CHP-6-0019" class="indexterm"/><a id="IDX-CHP-6-0020" class="indexterm"/><a id="IDX-CHP-6-0021" class="indexterm"/></p><p>When the directions have loaded, Google calls our <code class="literal">setDDist</code> function. We add the driving directions route to the map as a proprietary Google polyline ❹, which will help us visually compare the two distance methods. Then we can get the driving distance for these directions in meters ❺. To convert to kilometers, just divide by 1000.</p><p>Finally, we'll add a new text node below the map <code class="literal">div</code> ❻, which will communicate both distances to the user.</p><div class="figure"><a id="driving_distance_compared_to_haversine_d"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6341"/><img src="httpatomoreillycomsourcenostarchimages672051.png.jpg" alt="Driving distance compared to Haversine distance"/></div></div><p class="title">Figure 6-2. Driving distance compared to Haversine distance</p></div><p>As you can see in <a class="xref" href="ch06s02.html#driving_distance_compared_to_haversine_d" title="Figure 6-2. Driving distance compared to Haversine distance">Figure 6-2</a>, the distance you have to drive is much farther than the lazy crow has to fly. Seeing as the shortest distance between two points is a straight line, the routing results will always be farther. In this case, because only so many bridges cross the Willamette River, the effect is magnified, at least until Google includes swimming directions in its API.</p></div>
<div class="sect1" title="#38: Create Driving Directions"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_38_colon_create_driving_di"/>#38: Create Driving Directions</h1></div></div></div><p>Perhaps the most useful feature of mapping websites has always been their driving directions. The routing technology behind driving direction is more advanced than most developers can take on, but Google provides access to driving directions via its API. In this section, I'll create a directions widget that could help any business show its customers the way to the store. In this case, I'll use La Bonita, a Mexican restaurant where I wrote much of this book.<a id="IDX-CHP-6-0022" class="indexterm"/><a id="IDX-CHP-6-0023" class="indexterm"/></p><p>This example depends heavily on the Google Maps API, so this project is one of the few where I won't use Mapstraction. To start, let's add some basic HTML to a new file:</p><a id="I_programlisting6_d1e6367"/><pre class="programlisting">&lt;html &gt;
  &lt;head&gt;
    &lt;title&gt;Driving Directions with Google Maps&lt;/title&gt;

    &lt;script type="text/javascript" src="http://maps.google.
com/maps/api/js?sensor=false"&gt;&lt;/script&gt;
    &lt;style type="text/css"&gt;
    div#mymap {
      width: 400px;
      height: 350px;
    }
    div#mydir {
      width: 400px;
    }
    &lt;/style&gt;
    &lt;script type="text/javascript"&gt;
      ❶var myaddress = "2839 NE Alberta St, Portland, OR";
      // Google Maps Driving Directions Code Will Go Here
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body ❷onload="create_map()" onunload="GUnload()"&gt;
    &lt;h1&gt;Venido a La Bonita&lt;/h1&gt;

    &lt;div id="mymap"&gt;&lt;/div&gt;
    ❸&lt;div id="mydir"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre><p>Most of this code is for a basic, pretty much empty HTML page. We'll fill it in with a form to accept user input and JavaScript to ask Google for driving directions. First, let's look at a few new elements, and I'll explain what they mean.</p><p>In the JavaScript section, I hard-coded La Bonita's address ❶. You can replace this with your business address or the location of a party. Then, customers or guests will later input their own address. Together, these two addresses will make up the start and end points for the driving directions.</p><p>When the page loads, we're calling the <code class="literal">create_map</code> function ❷, just as we've done in most Mapstraction examples. That's because I made this function up; I could have called anything, as it's not tied to Mapstraction.</p><p>Down in the HTML, I included a second <code class="literal">div</code> ❸. This tag will hold the driving direction text. This second <code class="literal">div</code> is after the map <code class="literal">div</code>, so the directions will be listed below the map. This part of the driving directions service is optional (in fact, I omitted it in <a class="xref" href="ch06s02.html" title="#37: Find True Distance with Routing">#37: Find True Distance with Routing</a> in <a class="xref" href="ch06s02.html" title="#37: Find True Distance with Routing">#37: Find True Distance with Routing</a>), but the text is important for this example.</p><p>Now that we've put the shell of an HTML page together, let's add the pieces that will make this map work. In the blank space above the map <code class="literal">div</code> (and just below the <code class="literal">&lt;h1&gt;</code> tag), include this form:<a id="IDX-CHP-6-0024" class="indexterm"/><a id="IDX-CHP-6-0025" class="indexterm"/></p><a id="I_programlisting6_d1e6409"/><pre class="programlisting">&lt;form onSubmit="❹loadDir();return false;"&gt;
  Address: &lt;input type="text" name="addr" /&gt;
  City: &lt;input type="text" name="city" value="Portland" /&gt;
  ❺&lt;select name="state"&gt;
    &lt;option&gt;OR&lt;/option&gt;
    &lt;option&gt;WA&lt;/option&gt;
  &lt;/select&gt;
  &lt;input type="submit" value="Go" /&gt;
&lt;/form&gt;</pre><p>Most forms send data to the server, but with this example, we want to use JavaScript. This means when the user submits the form, we need to call a JavaScript function ❹. Then we need to return false to keep the browser from sending the data to the server anyway.</p><p>This code asks for the user's location in three pieces: address, city, and state. You could use just one or two fields if you want, but separating them out into separate fields helps make your format expectations clear. On the other hand, prepping the call to the driving directions service will be more work.</p><p>The state is shown as a drop-down menu ❺. In the case of my example, I have only included Oregon and Washington. La Bonita's food is good, but nobody is going to travel very far to get it. You can include the states where your customers are most likely to live.</p><p>Now we'll hook everything together with JavaScript. At a minimum, we need to create the two functions we've already referenced in our HTML: <code class="literal">create_map</code> will get the Google Map ready, and <code class="literal">loadDir</code> will send the addresses to Google's driving directions service.</p><p>Add this to the JavaScript section, below La Bonita's address:</p><a id="I_programlisting6_d1e6428"/><pre class="programlisting">❶ var map, gdir;
  function create_map() {
    var opt = {center: new google.maps.LatLng(45.559192, −122.636049), zoom: 15,
               mapTypeId: google.maps.MapTypeId.ROADMAP};
    map = new google.maps.Map(document.getElementById("mymap"), opt);
❷   gdir = new google.maps.DirectionsService();
  }
  function loadDir() {
    var stateobj = document.getElementById('state');
❸   var fromaddress = document.getElementById('addr').value + " "
          + document.getElementById('city').value + ", "
          + stateobj.options[stateobj.selectedIndex].value;
❹   var diropt = {
      origin: fromaddress, destination: myaddress,
      travelMode: google.maps.DirectionsTravelMode.DRIVING
    }
    gdir.route(diropt, ❺setDir);
  }
  function setDir(response, status) {
    if (status == google.maps.DirectionsStatus.OK) {
      var directionsDisplay = new google.maps.DirectionsRenderer(
          {map: map, panel: document.getElementById('mydir')});
      directionsDisplay.setDirections(response);
    }
  }</pre><p>First, we make the <code class="literal">gdir</code> variable global by declaring it outside of a function ❶. That way, the variable can be referenced from anywhere in the code. After creating the map, we also need to initialize the <code class="literal">gdir</code> variable ❷, so Google knows we're going to be asking for driving directions.<a id="IDX-CHP-6-0026" class="indexterm"/><a id="IDX-CHP-6-0027" class="indexterm"/><a id="IDX-CHP-6-0028" class="indexterm"/><a id="IDX-CHP-6-0029" class="indexterm"/><a id="IDX-CHP-6-0030" class="indexterm"/><a id="IDX-CHP-6-0031" class="indexterm"/></p><p>We are almost ready for a user to interact with our form. Let's look at the function, <code class="literal">loadDir</code>, that is called when the form is submitted. First, the function pieces together the address with the city/state ❸. You might prefer to check for empty or malformed content in these fields, but this simple example merely concatenates them together.</p><p>Next we set up the options ❹, including the two addresses, that tells Google what directions to find. Finally, the function sends the options to Google along with a callback function ❺. In the <code class="literal">setDir</code> function, which receives the driving directions, we simply tell Google to render the route on the map and the text below the map, as shown in <a class="xref" href="ch06s04.html#driving_directions_from_google" title="Figure 6-3. Driving directions from Google">Figure 6-3</a>.</p><p>That's it. We've created driving directions to get anyone to La Bonita. To use it for your business, simply alter the <code class="literal">myaddress</code> variable and fill in the appropriate states. To see an example that digs a little deeper into driving directions, see <a class="xref" href="ch10s06.html" title="#73: Find a Coffee Shop to Meet in the Middle">#73: Find a Coffee Shop to Meet in the Middle</a> in <a class="xref" href="ch10s06.html" title="#73: Find a Coffee Shop to Meet in the Middle">#73: Find a Coffee Shop to Meet in the Middle</a>.</p><p>Check out the full documentation for Google's driving directions: <a class="ulink" href="http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService">http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService</a></p></div>
<div class="sect1" title="#39: Determine Closest Marker"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_39_colon_determine_closest"/>#39: Determine Closest Marker</h1></div></div></div><p>Given a point and a whole bunch of markers, can you find the one closest to your point? In this project, we'll loop through every marker on the map and draw a line between wherever the user clicks and its closest marker, which we'll determine by calculating the distance between two points.</p><p>Before we can find the closest marker, however, we need a map with a handful of markers plotted. To do this, we'll get five random points, as shown earlier in the chapter. Here, I've reprinted the <code class="literal">get_random_by_bounds</code> function you'll need from that section. Add these lines to your JavaScript section at the top of your basic map, but make sure they are outside of the <code class="literal">create_map</code> function:</p><a id="I_programlisting6_d1e6495"/><pre class="programlisting">function get_random_by_bounds(bounds) {
  var lat = bounds.sw.lat + (Math.random() * (bounds.ne.lat − bounds.sw.lat));
             var lon = bounds.sw.lon + (Math.random()
 * (bounds.ne.lon − bounds.sw.lon));
  return new mxn.LatLonPoint(lat, lon);
}</pre><div class="figure"><a id="driving_directions_from_google"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6500"/><img src="httpatomoreillycomsourcenostarchimages672053.png.jpg" alt="Driving directions from Google"/></div></div><p class="title">Figure 6-3. Driving directions from Google</p></div><p>With that helper function ready, add these lines to your basic map's <code class="literal">create_map</code> function:</p><a id="I_programlisting6_d1e6510"/><pre class="programlisting">❶ var bounds = new mxn.BoundingBox(32.4, −113.9, 40.9, −103.0);
❷ for (i=1; i&lt;=5; i++) {
    var marker = new mxn.Marker(❸get_random_by_bounds(bounds));
    mapstraction.addMarker(marker);
  }
❹ mapstraction.setBounds(bounds);
  mapstraction.click.addHandler(❺find_closest_marker);</pre><p>Assuming you've already initialized the map, you can almost dive into creating the markers. First, you need to create the bounds for the markers, which represents the area you'll use to create the random location. In this case, I used some points ❶ that roughly define the "four corners" states in the United States: Arizona, Utah, Colorado, and New Mexico.<a id="IDX-CHP-6-0032" class="indexterm"/></p><p>Now we can create a loop ❷ to perform the same bit of code five times. Each time through the loop, we'll get a new random point ❸, so our markers could be anywhere within the bounds.</p><p>Normally, I'd ask Mapstraction to center and zoom automatically when using random markers. Here, however, I set the bounds to be the quartet of states ❹, the same area that could possibly hold a marker. This way, I know the markers will all be visible.</p><p>Lastly, we listen for the user to click the map. Upon a click, we tell Mapstraction to call a function to find the closest marker ❺. Now we need to write that function. Add these lines to your JavaScript, outside of the <code class="literal">create_map</code> function:</p><a id="I_programlisting6_d1e6527"/><pre class="programlisting">function find_closest_marker(event_type, event_source, event_args) {
    if (mapstraction.markers.length &gt; 0) {
      var clickpoint = event_args.location;
❻     var closest_marker = mapstraction.markers[0];
❼     var closest_dist = clickpoint.distance(closest_marker.location);
❽     for (var i=1; i &lt; mapstraction.markers.length; i++) {
        var thismarker = mapstraction.markers[i];
        var thisdist = clickpoint.distance(thismarker.location);
❾       if (thisdist &lt; closest_dist) {
          closest_dist = thisdist;
          closest_marker = thismarker;
        }
      }
      if (closest_marker) {
❿       var poly = new mxn.Polyline([clickpoint, closest_marker.location]);
        mapstraction.addPolyline(poly);
      }
    }
  }</pre><p>In order to find the closest marker to the point the user clicked, we need to check the distance between each marker and the click point. We need to keep two pieces of data during our search: the current closest marker we have found and its distance to the point.</p><p>To begin, we create those two variables and assume the first marker (remember JavaScript array indexes start at zero) is currently closest ❻. So we know what distance to compare, we also calculate the first marker's distance to the point ❼. Now we're ready to loop through all the other markers ❽, starting with the second one.</p><p>Each time through the loop, we calculate the distance between the current marker and the click point. If the distance is farther than the closest distance we have found so far, we do nothing. If this current marker is now closer than the previous ❾ one, we replace our original two variables with new values.<a id="IDX-CHP-6-0033" class="indexterm"/><a id="IDX-CHP-6-0034" class="indexterm"/></p><p>After the loop, I created a new polyline between the point where the user clicked and the marker that we determined is closest ❿. Load this example into a web browser and click around a few times. You'll create several lines, connecting multiple markers if you move around enough (see <a class="xref" href="ch06s04.html#each_click_connects_to_its_closest_marke" title="Figure 6-4. Each click connects to its closest marker.">Figure 6-4</a>). Which marker is closest to Albuquerque? How about Denver?</p><div class="figure"><a id="each_click_connects_to_its_closest_marke"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6552"/><img src="httpatomoreillycomsourcenostarchimages672055.png.jpg" alt="Each click connects to its closest marker."/></div></div><p class="title">Figure 6-4. Each click connects to its closest marker.</p></div></div>
<div class="sect1" title="#40: Find a Point Along a Line"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_40_colon_find_a_point_alon"/>#40: Find a Point Along a Line</h1></div></div></div><p>Let's say you're taking a short flight with your forgetful pilot friend from Wichita, Kansas, to Tulsa, Oklahoma, about 140 miles. "Oops," he says nonchalantly after you're airborne, "I forgot to gas up." I know what you're thinking—turn around! But your friend assures you there is enough gas to go 80 miles, which should get you into Oklahoma where the gas is cheaper.</p><p>Knowing the distance between two points is useful, but sometimes you want to know the story between those points. For example, what's the midpoint between two cities? Or, given point A and point B, what are the coordinates of point C that is nine miles along that line? It's a math-heavy problem to solve, but doing so makes for some fun possibilities.</p><p>Fun might not be the right word if you were really flying on a near-empty tank from Wichita to Tulsa. But you would definitely want to know where along that route you will be after 80 miles when the engine starts to sputter. You would be smart to double-check: <span class="emphasis"><em>will you get to Oklahoma, as your friend claims?</em></span> After all, this information is coming from the guy who forgot to put gas in his airplane.<a id="IDX-CHP-6-0035" class="indexterm"/><a id="IDX-CHP-6-0036" class="indexterm"/></p><p>To find out the answer to the question, we'll use a three step process:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Plot our starting and ending points on a map.</p></li><li class="listitem"><p>Calculate our bearing (direction) using the two points.</p></li><li class="listitem"><p>Use the bearing and starting point to find a new point 80 miles away.</p></li></ol></div><p>Let's get started while there's still time to turn around.</p><div class="sect2" title="Plot Your Route"><div class="titlepage"><div><div><h2 class="title"><a id="plot_your_route"/>Plot Your Route</h2></div></div></div><p>Since planes fly in a straight line, we'll use a simple polyline, similar to the initial example in <a class="xref" href="ch04.html#number_symble_16_colon_draw_lines_on" title="#16: Draw Lines on a Map">#16: Draw Lines on a Map</a> in <a class="xref" href="ch04.html#number_symble_16_colon_draw_lines_on" title="#16: Draw Lines on a Map">#16: Draw Lines on a Map</a>. All we need are the starting and ending points for the two airports.</p><p>To draw a line between Wichita and Tulsa, add the following function to your basic map, replacing your current <code class="literal">create_map</code> function:</p><a id="I_programlisting6_d1e6607"/><pre class="programlisting">var mapstraction;
var wichita = new mxn.LatLonPoint(37.7454463, −97.4080747);
var tulsa = new mxn.LatLonPoint(36.0390101, −95.9936344);

function create_map() {
  mapstraction = new mxn.Mapstraction('mymap', 'google');
  mapstraction.setCenterAndZoom(wichita, 8);
  mapstraction.addPolyline(new mxn.Polyline([wichita, tulsa]));
  mapstraction.autoCenterAndZoom();
  // Find bearing

  // Find point X km along route

}</pre><p>Save the file and load it up. Your map should look similar to <a class="xref" href="ch06s05.html#direct_route_between_wichita_and_tulsa" title="Figure 6-5. Direct route between Wichita and Tulsa">Figure 6-5</a>.</p><p>Do you think you can make it to Oklahoma? The 80 miles of fuel in the tank will take you almost 60 percent through your route. It's going to be close. Let's continue and find out.</p><div class="figure"><a id="direct_route_between_wichita_and_tulsa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6618"/><img src="httpatomoreillycomsourcenostarchimages672057.png.jpg" alt="Direct route between Wichita and Tulsa"/></div></div><p class="title">Figure 6-5. Direct route between Wichita and Tulsa</p></div></div><div class="sect2" title="Find Your Bearing"><div class="titlepage"><div><div><h2 class="title"><a id="find_your_bearing"/>Find Your Bearing</h2></div></div></div><p>In order to find a point along a line, you first need to know the direction that the line is pointed. The direction is called the bearing, and it is a number expressed in degrees, from 0 to 359. Most compasses mark these degrees around the outside, along with the four cardinal directions.<a id="IDX-CHP-6-0037" class="indexterm"/><a id="IDX-CHP-6-0038" class="indexterm"/><a id="IDX-CHP-6-0039" class="indexterm"/></p><p>In this section, we'll write a function to calculate the bearing for us, based on the work of Chris Veness of Movable Type Ltd. (<a class="ulink" href="http://movable-type.co.uk/">http://movable-type.co.uk/</a>). Add the following code to the JavaScript section of your map file, but outside the <code class="literal">create_map</code> function:</p><a id="I_programlisting6_d1e6644"/><pre class="programlisting">function get_bearing(pt1, pt2) {
  var lat1 = degrees_to_radians(pt1.lat);
  var lat2 = degrees_to_radians(pt2.lat);
  var lon_diff = degrees_to_radians(pt2.lon − pt1.lon);
  var y = Math.sin(lon_diff) * Math.cos(lat2);
  var x = Math.cos(lat1) * Math.sin(lat2)
          - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon_diff);
  var bearing = Math.atan2(y, x);
  return (radians_to_degrees(bearing)+360) % 360;
}
function degrees_to_radians(deg) {
  return deg * Math.PI / 180;
}
function radians_to_degrees(rad) {
  return rad * 180 / Math.PI;
}</pre><p>Along with the function to calculate the bearing, I've also included a couple helper functions to convert between degrees and radians. The trigonometry we use is less complicated when using radians (that's right—the math could be even more complicated). However, we also need to convert back since degrees are what Mapstraction expects.<a id="IDX-CHP-6-0040" class="indexterm"/><a id="IDX-CHP-6-0041" class="indexterm"/></p><p>Now, from within your <code class="literal">create_map</code> function, add this line:</p><a id="I_programlisting6_d1e6661"/><pre class="programlisting">var bearing = get_bearing(wichita, tulsa);</pre><p>Here we call the <code class="literal">get_bearing</code> function, passing our two points. The result should be about 146 degrees. Notice that if you swap the order of the arguments to the function, the result will be different: about 326 degrees. That's because you travel a different direction to go from Tulsa to Wichita. Since it's the exact opposite direction, the two results are 180 degrees different.</p><p>We're going from Wichita to Tulsa, so we'll take that result and use it in the next section.</p></div><div class="sect2" title="Determine New Point"><div class="titlepage"><div><div><h2 class="title"><a id="determine_new_point"/>Determine New Point</h2></div></div></div><p>Now we know the direction we're traveling. That's an important step toward finding the point that is 80 miles along our route. It's time to employ some more fancy math using the bearing and the coordinates of our starting point, Wichita.</p><p>In this section we'll write another function, again based on the work of Chris Veness. Add the following code to your JavaScript, taking care to not put it inside any other functions:</p><a id="I_programlisting6_d1e6677"/><pre class="programlisting">function get_destination(pt, dist, bearing) {
  var R = 6371; // radius of earth (km)
  var lat1 = degrees_to_radians(pt.lat);
  var lon1 = degrees_to_radians(pt.lon);
  bearing = degrees_to_radians(bearing);
  var cosLat1 = Math.cos(lat1);
  var sinLat1 = Math.sin(lat1);
  var distOverR = dist / R;
  var cosDistOverR = Math.cos(distOverR);
  var sinDistOverR = Math.sin(distOverR);

  var lat2 = Math.asin( sinLat1 * cosDistOverR

             + cosLat1 * sinDistOverR * Math.cos(bearing) );
  var lon2 = lon1 + Math.atan2( Math.sin(bearing) * sinDistOverR * cosLat1,
             cosDistOverR Đ sinLat1 * Math.sin(lat2) );
  lon2 = (lon2 + Math.PI) % (2 * Math.PI) Đ Math.PI;
  lat2 = radians_to_degrees(lat2);
  lon2 = radians_to_degrees(lon2);

  return new mxn.LatLonPoint(lat2, lon2);
}</pre><p>Now we need to call our newly created function. Add the following code inside the <code class="literal">create_map</code> function, just after the line that calculates the bearing:</p><a id="I_programlisting6_d1e6684"/><pre class="programlisting">var newpt = get_destination(wichita, 128, bearing);
var mk = new mxn.Marker(newpt);
mapstraction.addMarker(mk);</pre><p>Notice that the distance we're passing to the new function is 128, not 80. That's because the function expects the distance in <span class="emphasis"><em>kilometers</em></span>, not miles. This matches the way Mapstraction calculates distance. To convert miles to kilometers, multiply the miles by 1.6.</p><p>Take a deep breath before you load your changes. Along with determining the point 80 miles along the path, the code creates and adds a marker to the map, as shown in <a class="xref" href="ch06s05.html#miles_from_wichita_gets_you_into_oklahom" title="Figure 6-6. 80 Miles from Wichita gets you into Oklahoma!">Figure 6-6</a>.</p><div class="figure"><a id="miles_from_wichita_gets_you_into_oklahom"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6698"/><img src="httpatomoreillycomsourcenostarchimages672059.png.jpg" alt="80 Miles from Wichita gets you into Oklahoma!"/></div></div><p class="title">Figure 6-6. 80 Miles from Wichita gets you into Oklahoma!</p></div><p>And you can take another deep breath, because it looks like 80 miles of gas will get you from Wichita into Oklahoma where, according to your forgetful pilot friend, you can fill up for less. As for finding a landing strip, that's another issue.<a id="IDX-CHP-6-0042" class="indexterm"/></p><p>Now that you know how to find a point along a line, try out a less hypothetical project. <a class="xref" href="ch10s06.html" title="#73: Find a Coffee Shop to Meet in the Middle">#73: Find a Coffee Shop to Meet in the Middle</a> in <a class="xref" href="ch10s06.html" title="#73: Find a Coffee Shop to Meet in the Middle">#73: Find a Coffee Shop to Meet in the Middle</a> combines the project you just finished with driving directions and local search results.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The point you find will only appear directly on the line over short distances, like the 140-mile trip in this example. For larger distances, the point will be correct, but the line will be wrong. Standard polylines do not take the curvature of the earth into consideration. To get a line that follows the "great circle" shortest distance between two points, you'll need to use a geodesic polyline, which is supported by Google.<a id="IDX-CHP-6-0043" class="indexterm"/><a id="IDX-CHP-6-0044" class="indexterm"/></p></div></div></div>
<div class="sect1" title="#41: Plot Local Results on a Map"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_41_colon_plot_local_result"/>#41: Plot Local Results on a Map</h1></div></div></div><p>When you are searching nearby, sooner or later you want to find businesses that meet certain qualifications. For example, in Portland we're always looking for coffee. In San Francisco, where this example takes place, that means finding delicious, cheap burritos.</p><p>In this project we'll use JavaScript to perform a local search for the keyword <span class="emphasis"><em>burritos</em></span>. Both Google and Yahoo! have APIs that allow for this type of search. In this example, we'll use Yahoo! because it is simple and to the point.</p><p>We're starting with a basic Mapstraction map, so we minimize the number of provider-specific calls. Because most of my examples have used Google as a provider, double-check that you're calling the Yahoo! Maps API:</p><a id="I_programlisting6_d1e6738"/><pre class="programlisting">&lt;script type="text/javascript"
src="http://api.maps.yahoo.com/ajaxymap?v=3.8&amp;appid=<em class="replaceable"><code>yourkeyhere</code></em>"&gt;&lt;/script&gt;</pre><p>With the external JavaScripts loaded, replace any existing inline JavaScript code with the following:</p><a id="I_programlisting6_d1e6745"/><pre class="programlisting">var mapstraction;
  function create_map() {
    mapstraction = new mxn.Mapstraction('mymap', 'yahoo');
    mapstraction.setCenterAndZoom(new mxn.LatLonPoint(37.7740486,-122.4101883), 15);
    mapstraction.addLargeControls();
    // Yahoo-specific calls
❶   var ymap = mapstraction.getMap();
    YEvent.Capture(ymap, EventsList.onEndLocalSearch, ❷plotResults);
❸   ymap.searchLocal(ymap.getCenterLatLon(), 'burritos', ❹1, ❺5);
  }</pre><p>To be able to use Yahoo-specific calls, we need to grab the map object ❶. Then we need to let the map know that we're interested in an event, which will occur when our search is complete. We also reference a function where the results can be sent ❷. We'll create that function in a moment.<a id="IDX-CHP-6-0045" class="indexterm"/><a id="IDX-CHP-6-0046" class="indexterm"/><a id="IDX-CHP-6-0047" class="indexterm"/><a id="IDX-CHP-6-0048" class="indexterm"/><a id="IDX-CHP-6-0049" class="indexterm"/><a id="IDX-CHP-6-0050" class="indexterm"/><a id="IDX-CHP-6-0051" class="indexterm"/><a id="IDX-CHP-6-0052" class="indexterm"/></p><p>Now, we need to write the code that actually initiates a local search to Yahoo! ❸. The <code class="literal">searchLocal</code> function requires four values to be passed to it: We send the center of the map, the search query, the search radius (in miles) ❹, and the number of results ❺.</p><p>Then we write the <code class="literal">plotResults</code> function. Add the following lines below the <code class="literal">create_map</code> function:</p><a id="I_programlisting6_d1e6792"/><pre class="programlisting">function plotResults(❶results) {
    if (results.Data) {
      var places = results.Data.ITEMS;
❷     for (i=0; i &lt; places.length; i++) {
        var thisplace = places[i];
        var lat = ❸parseFloat(thisplace.LATITUDE);
        var lon = parseFloat(thisplace.LONGITUDE);
        var marker = new mxn.Marker(new mxn.LatLonPoint(lat, lon));
        marker.setInfoBubble(thisplace.TITLE + '&lt;br /&gt;' + thisplace.ADDRESS);
        mapstraction.addMarker(marker);
      }
    }
❹   mapstraction.autoCenterAndZoom();
  }</pre><p>The search results are passed from Yahoo! as a parameter ❶ to our function. The parameter is a special object that contains a number of pieces of information about each business we found. We want to extract the latitude, longitude, address, and business name from the object, which we do by looping ❷ through the results.</p><p>Each time through the loop, we access the four pieces of information we require for a business. To get usable latitude and longitude values, we need to use the JavaScript helper function <code class="literal">parseFloat</code> ❸. This function converts textual values into the floating point numbers required for coordinates.</p><p>The rest is probably old hat to you by now. We create a marker, put text in the message box (the name and address of the location), and when we've added all the markers, we make sure they can all be seen on the map ❹, as shown in <a class="xref" href="ch06s07.html#local_results_plotted_on_a_yahoo_exclama" title="Figure 6-7. Local results plotted on a Yahoo! map">Figure 6-7</a>.</p></div>
<div class="sect1" title="#42: Retrieve Local Results with HTTP"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_42_colon_retrieve_local_re"/>#42: Retrieve Local Results with HTTP</h1></div></div></div><p>On many occasions you'll want to use something more powerful than JavaScript to perform a local search. For example, you may want to store the results in a database or output them into an RSS feed. In either case, the approach used in the previous project just won't do. Instead, we'll use Yahoo!'s Local Search API and access it with PHP, a popular server-side programming language available on many web hosts.<a id="IDX-CHP-6-0053" class="indexterm"/></p><div class="figure"><a id="local_results_plotted_on_a_yahoo_exclama"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6817"/><img src="httpatomoreillycomsourcenostarchimages672061.png.jpg" alt="Local results plotted on a Yahoo! map"/></div></div><p class="title">Figure 6-7. Local results plotted on a Yahoo! map</p></div><p>Before we bring the results into code, let's see what they look like. One of the great things about an API like the one we're using is that it outputs plain-text XML, which can be interpreted by a web browser and is human-readable.<a id="IDX-CHP-6-0054" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some of the concepts in this project may be considered advanced. They build upon those introduced in <a class="xref" href="ch08.html" title="Chapter 8. DATA FORMATS">Chapter 8</a> and <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a>.</p></div><p>Just like going to an ordinary web page, you can access the Local Search API by visiting a URL. Try typing this search for burritos in San Francisco into your location bar:</p><a id="I_programlisting6_d1e6836"/><pre class="programlisting">http://local.yahooapis.com/LocalSearchService/V3/localSearch?<strong class="userinput"><code>appid</code></strong>=
<em class="replaceable"><code>yourkeyhere</code></em>&amp;<strong class="userinput"><code>query</code></strong>=burritos&amp;<strong class="userinput"><code>location</code></strong>=San+Francisco+CA</pre><p>The request parameters are highlighted in bold. The first, your <code class="literal">appid</code>, is your Yahoo! API key. The <code class="literal">query</code> is what you're searching for and the <code class="literal">location</code> is where you're searching.<a id="IDX-CHP-6-0055" class="indexterm"/></p><p>Once the results are loaded, you'll see something like this:<a id="IDX-CHP-6-0056" class="indexterm"/><a id="IDX-CHP-6-0057" class="indexterm"/><a id="IDX-CHP-6-0058" class="indexterm"/><a id="IDX-CHP-6-0059" class="indexterm"/><a id="IDX-CHP-6-0060" class="indexterm"/></p><a id="I_programlisting6_d1e6887"/><pre class="programlisting">❶ &lt;?xml version="1.0"?&gt;
❷ &lt;ResultSet ... totalResultsAvailable="553" totalResultsReturned="10"&gt;
❸   &lt;Result id="21356805"&gt;
      &lt;Title&gt;El Farolito&lt;/Title&gt;
      &lt;Address&gt;2777 Mission St&lt;/Address&gt;
      &lt;City&gt;San Francisco&lt;/City&gt;
      &lt;State&gt;CA&lt;/State&gt;
      &lt;Latitude&gt;37.752713&lt;/Latitude&gt;
      &lt;Longitude&gt;-122.41835&lt;/Longitude&gt;
      ...
    &lt;/Result&gt;
    &lt;Result id="21342579"&gt;
      ...
    &lt;/Result&gt;
    ...
  &lt;/ResultSet&gt;</pre><p>Like most XML documents, the results declare themselves to be XML ❶ on the first line. The second line is the root element ❷ of the document, meaning it contains all other tags below it. Every result is stored within a <code class="literal">&lt;Result&gt;</code> tag ❸, with data items stored within tags one level below.</p><p>For more on the terms used to describe XML, see <a class="xref" href="ch08.html#number_symble_52_colon_use_xml" title="#52: Use XML">#52: Use XML</a> in <a class="xref" href="ch08.html#number_symble_52_colon_use_xml" title="#52: Use XML">#52: Use XML</a>, which also contains a more in-depth description of parsing XML than I'll provide in the next section.</p><div class="sect2" title="Parse Local Results with PHP"><div class="titlepage"><div><div><h2 class="title"><a id="parse_local_results_with_php"/>Parse Local Results with PHP</h2></div></div></div><p>Viewing the XML that Yahoo! returns within a browser is one thing. Even more useful is to read it into PHP, which allows you to do even more. In this example, we'll get the same burrito results as in the previous section and print out the name of the first restaurant found.</p><p>Create a new PHP file and add the following lines:</p><a id="I_programlisting6_d1e6908"/><pre class="programlisting">&lt;?
    $api_key = "<em class="replaceable"><code>yourkeyhere</code></em>";
    $search_term = urlencode("burritos");
    $location = ❶"urlencode("San Francisco, CA");
    $url = "http://local.yahooapis.com/LocalSearchService/V3/localSearch";
❷   $url .= "?appid=$api_key&amp;query=$search_term&amp;location=$location";
❸   $xobj = get_xml($url);
    print $xobj-&gt;Result[0]-&gt;Title;
  ?&gt;</pre><p>I've stored the three parameters as PHP variables. This makes it easy for you to include your own API key and change the search terms. Go ahead and change what we're searching for, or include your own city. Notice that, even though we're hard-coding the search criteria, I've used the <code class="literal">urlencode</code> function to make sure the URL remains valid. For example, the encoding of the location ❶ will replace the spaces and comma with URL-friendly versions of those characters.<a id="IDX-CHP-6-0061" class="indexterm"/><a id="IDX-CHP-6-0062" class="indexterm"/><a id="IDX-CHP-6-0063" class="indexterm"/><a id="IDX-CHP-6-0064" class="indexterm"/><a id="IDX-CHP-6-0065" class="indexterm"/></p><p>Next, I put the parameters together in URL form ❷, so we can retrieve the results. The actual call to download the web page happens in another function ❸, which you can find described in detail in <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a> in <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a>.</p><p>Finally, the PHP code prints out the name of the first result: El Farolito in the example results. You are more likely to want to do something more interesting with the results than print out the first name, but this gives you an idea of how to access the items.</p></div><div class="sect2" title="Other Useful Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="other_useful_parameters"/>Other Useful Parameters</h2></div></div></div><p>In the previous example, I showed just three parameters that you can use to search with Yahoo!'s Local Search API: <code class="literal">appid</code> (required), <code class="literal">query</code> (required for most searches), and <code class="literal">location</code>.</p><p>Many more options are available, the most interesting of which I've included in <a class="xref" href="ch06s07.html#additional_parameters_accepted_by_yahoo" title="Table 6-1. Additional Parameters Accepted by Yahoo! Local Search">Table 6-1</a>.</p><div class="table"><a id="additional_parameters_accepted_by_yahoo"/><p class="title">Table 6-1. Additional Parameters Accepted by Yahoo! Local Search</p><div class="table-contents"><table summary="Additional Parameters Accepted by Yahoo! Local Search" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Parameter name</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">city</code>, <code class="literal">state</code>, and <code class="literal">zip</code></p></td><td style="text-align: left" valign="top"><p>Any of these three can be used, alone or in combination, to replace the free-form <code class="literal">location</code> parameter used in the example.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">latitude</code> and <code class="literal">longitude</code></p></td><td style="text-align: left" valign="top"><p>If both of these are used, they take the place of any other location data and set the search center at the point created by the coordinates.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">radius</code></p></td><td style="text-align: left" valign="top"><p>Sets the maximum distance (in miles) from the search location.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">results</code></p></td><td style="text-align: left" valign="top"><p>Declares the number of results, from 1 to 20. The default value is 10.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sort</code></p></td><td style="text-align: left" valign="top"><p>Indicates how the results will be sorted, using one of four options: <code class="literal">distance</code>, <code class="literal">rating</code>, <code class="literal">relevance</code>, or <code class="literal">title</code>. The default value is <code class="literal">relevance</code>.</p></td></tr></tbody></table></div></div><p>More parameters are listed in Yahoo!'s documentation,<sup>[<a id="CHP-6-FN-1" href="#ftn.CHP-6-FN-1" class="footnote">2</a>]</sup> but with the examples here you should be able to get some interesting results. Where's your nearest taxidermist?</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-6-FN-1" href="#CHP-6-FN-1" class="para">2</a>] </sup><a class="ulink" href="http://developer.yahoo.com/search/local/V3/localSearch.html">http://developer.yahoo.com/search/local/V3/localSearch.html</a></p></div></div></div>
<div class="sect1" title="#43: Check Whether a Point Is Within a Bounding Box"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_43_colon_check_whether_a_p"/>#43: Check Whether a Point Is Within a Bounding Box</h1></div></div></div><p>Among the most important shapes in mapping is the rectangle. After centuries, we still view maps in a rectangular shape, even with today's fancy JavaScript. A rectangle can also be easily described (you only need two points), and determining if a point is within a specific rectangle requires no fancy math.<a id="IDX-CHP-6-0066" class="indexterm"/></p><p>As you'll see in later in this project, checking for a point within a <code class="literal">BoundingBox</code> is the first step. You might also use this to determine, for example, whether all the markers are on the screen.</p><p>Because finding if a point is within a rectangle is such a useful feature, Mapstraction has baked it in as a function. Given any <code class="literal">BoundingBox</code> object, you can pass a <code class="literal">LatLonPoint</code> and receive back either true (within the box) or false.</p><p>Here's code to determine whether a point is within the map view:</p><a id="I_programlisting6_d1e7077"/><pre class="programlisting">var box = mapstraction.getBounds();
var inview = box.contains(new mxn.LatLonPoint(37.7740486, −122.4101883));</pre><p>What's happening? It's not that complicated. A <code class="literal">BoundingBox</code> is determined by its southwest and northeast points (see <a class="xref" href="ch06s08.html#a_boundingbox_is_declared_by_its_southwe" title="Figure 6-8. A BoundingBox is declared by its southwest and northeast points.">Figure 6-8</a>). So to be within a box, your latitude must be between the latitude of those two points. Longitude is the same.</p><div class="figure"><a id="a_boundingbox_is_declared_by_its_southwe"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7092"/><img src="httpatomoreillycomsourcenostarchimages672063.png.jpg" alt="A BoundingBox is declared by its southwest and northeast points."/></div></div><p class="title">Figure 6-8. A <code class="literal">BoundingBox</code> is declared by its southwest and northeast points.</p></div><p>Here is a slightly altered version of Mapstraction's <code class="literal">BoundingBox contains</code> function:</p><a id="I_programlisting6_d1e7102"/><pre class="programlisting">function check_bounds(pt, box) {
  return (pt.lat &gt;= box.sw.lat &amp;&amp; pt.lat &lt;= box.ne.lat
       &amp;&amp; pt.lon &gt;= box.sw.lon &amp;&amp; pt.lon &lt;= box.ne.lon);</pre><p>Yes, the math is fairly straightforward, but that would be a lot of code to write out each time. I'm sure glad Mapstraction does it for us.</p><div class="sect2" title="Can You Click Inside the Box?"><div class="titlepage"><div><div><h2 class="title"><a id="can_you_click_inside_the_box_question"/>Can You Click Inside the Box?</h2></div></div></div><p>Now that we know how to check for points inside a box, let's try it. This example will create a bounding box smaller than the viewable map. When the user clicks, we check whether the point where he or she clicked is inside our box.<a id="IDX-CHP-6-0067" class="indexterm"/></p><p>To make things clear, we'll draw a polyline around the bounding box, making it easy to tell whether Mapstraction returns the correct results. Do you think you can click inside the box?</p><p>Add the following code into the JavaScript section of a basic map, replacing any existing code:</p><a id="I_programlisting6_d1e7119"/><pre class="programlisting">var mapstraction;
  var box;
  function create_map() {
    mapstraction = new mxn.Mapstraction('mymap', 'google');
    mapstraction.setCenterAndZoom(new mxn.LatLonPoint(37.7740486,-122.4101883), 9);
    mapstraction.addSmallControls();
❶   box = new mxn.BoundingBox(37.5, −122.8, 37.9, −122.2);
❷   var poly = BoundingBox_to_Polyline(box);
    mapstraction.addPolyline(poly);
❸   mapstraction.click.addHandler(function(event_type, event_source, event_args) {
      var reply = "";
      var clickpoint = event_args.location;
❹     if (box.contains(clickpoint)) {
        reply = "You clicked inside the box! ";
      }
      else {
        reply = "Sorry--You missed the box. ";
      }
      // Create marker at click
      var mk = new mxn.Marker(clickpoint);
      mk.setInfoBubble(reply);
      mapstraction.addMarker(mk);
❺     mk.openBubble();
    });
  }
  function BoundingBox_to_Polyline(box) {
    var points = [box.sw, new mxn.LatLonPoint(box.ne.lat, box.sw.lon), box.ne,
                  new mxn.LatLonPoint(box.sw.lat, box.ne.lon),
                  new mxn.LatLonPoint(box.sw.lat, box.sw.lon-.0001)];
    var poly = new mxn.Polyline(points);
    return poly;
  }</pre><p>After creating the map, we make a somewhat arbitrary bounding box ❶ around San Francisco. Then we take that same box and make it visible on the map by tracing its edges ❷. We use the <code class="literal">BoundingBox_to_Polyline</code> function, which I explain in detail in <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a> in <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a>. For convenience, I have reprinted it here.</p><p>Next we need to listen for clicks on the map ❸. When the user clicks, we need to see if the clicked point is within the box. To do this, we call the <code class="literal">contains</code> function on the <code class="literal">BoundingBox</code> object we created ❹. The outcome (true or false) will determine what message we display to the user.<a id="IDX-CHP-6-0068" class="indexterm"/><a id="IDX-CHP-6-0069" class="indexterm"/></p><p>To communicate the outcome to the user, we add a new marker where the user clicked and open up its message box ❺ to display whether the click was inside the bounds. Try it a few times. Click inside, click outside—it gets it right every time! An example result is shown in <a class="xref" href="ch06s08.html#clicking_a_point_within_the_bounding_box" title="Figure 6-9. Clicking a point within the bounding box">Figure 6-9</a>.</p><div class="figure"><a id="clicking_a_point_within_the_bounding_box"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7155"/><img src="httpatomoreillycomsourcenostarchimages672065.png.jpg" alt="Clicking a point within the bounding box"/></div></div><p class="title">Figure 6-9. Clicking a point within the bounding box</p></div></div></div>
<div class="sect1" title="#44: Get a Random Point in a Bounding Box"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_44_colon_get_a_random_poin"/>#44: Get a Random Point in a Bounding Box</h1></div></div></div><p>Quick! Think of a number between −122.9 and −122.8! Though not an ordinary question, you may find yourself asking it while creating maps. Especially for testing, you'll want to be able to generate random geographic points, often within a specific area. In a way, finding a random point within a box is the opposite of the previous project.</p><p>I've created a special function just for creating random points. You may have even seen it in other parts of this book. In this section, I'll describe it briefly, and then use it in an example.<a id="IDX-CHP-6-0070" class="indexterm"/><a id="IDX-CHP-6-0071" class="indexterm"/><a id="IDX-CHP-6-0072" class="indexterm"/></p><p>Here is the code to get a random point:</p><a id="I_programlisting6_d1e7178"/><pre class="programlisting">function get_random_by_bounds(❶bounds) {
    var lat = bounds.sw.lat + (❷Math.random() * ❸(bounds.ne.lat − bounds.sw.lat));
    var lon = bounds.sw.lon + (Math.random() * (bounds.ne.lon − bounds.sw.lon));
❸   return new mxn.LatLonPoint(lat, lon);
  }</pre><p>The most important piece of information that this function needs is to know the general area, or the <span class="emphasis"><em>bounds</em></span>, where you want the random point. This information is passed as the single parameter ❶ of this function, a Mapstraction <code class="literal">BoundingBox</code> object. The <code class="literal">BoundingBox</code> object is made up of the southwest (SW) and northeast (NE) corners of a rectangular area. Between those two points, you can determine the maximum and minimum values of the edges.</p><p>Now, we know where the point will be, but we still need to make the point random using a built-in JavaScript function ❷. The number returned by <code class="literal">Math.random</code> is a decimal between 0 and 1, which is not likely to be what you want. We can, however, use that number, multiplied by our range ❸, to determine the random coordinate.</p><p>For example, to get the random latitude, we take the NE latitude minus the SW latitude and multiply that answer (the distance in degrees between the two latitudes) by the random number. Then, we add the SW latitude (the smallest of the two) to the outcome. As a result, our smallest latitude (when the random number is zero) will be the same as the SW latitude; the largest latitude (when the random number is one) will be the same as the NE latitude.</p><p>The same process is then applied to the longitude but with a new random number. Now that we have a latitude and a longitude, we can return the two numbers as a new <code class="literal">LatLonPoint</code> ❹.</p><p>Here's an example using a random point. Be sure you have the <code class="literal">get_random_by_bounds</code> function in your JavaScript code and then add the following lines to the <code class="literal">create_map</code> function of a basic map:</p><a id="I_programlisting6_d1e7211"/><pre class="programlisting">var b = new mxn.BoundingBox(❶45.5, −122.9, 45.6, −122.8);
❷ var pt = get_random_by_bounds(b);
  var mk = new mxn.Marker(pt);
  mapstraction.addMarker(mk);</pre><p>We need some bounds to be able to pass to the random point function. In this case, I made up some points ❶ roughly located around my hometown of Portland, Oregon. When creating a new <code class="literal">BoundingBox</code>, we must pass four numbers in this order: SW latitude, SW longitude, NE latitude, and NE longitude.</p><p>Next we get the random point ❷ by passing the bounds we just created. Remember the function we created used a <code class="literal">return</code> to share the new random point. When we call the function, we can declare a variable (which I called <code class="literal">pt</code>) to store that returned value.<a id="IDX-CHP-6-0073" class="indexterm"/><a id="IDX-CHP-6-0074" class="indexterm"/><a id="IDX-CHP-6-0075" class="indexterm"/><a id="IDX-CHP-6-0076" class="indexterm"/><a id="IDX-CHP-6-0077" class="indexterm"/></p><p>To show the random point, I used it to create a new marker and then placed the marker on the map. If you want to visually check that the point is really within your bounds, try incorporating <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a> in <a class="xref" href="ch04s04.html" title="#19: Draw a Rectangle to Declare an Area">#19: Draw a Rectangle to Declare an Area</a> with this one.</p></div>
<div class="sect1" title="#45: Check Whether a Point Is Within a Shape"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_45_colon_check_whether_a_p"/>#45: Check Whether a Point Is Within a Shape</h1></div></div></div><p>Did the user just click on Kansas? Is this address within the city limits? These questions are common ones you'll want to answer with a <span class="emphasis"><em>hit test</em></span>, the process used to determine whether a point is inside a shape. To do so requires some data (the outline of the shape) and a little math. In this section, I'll show how you can crunch the coordinates and find the answers to these and other questions.<a id="IDX-CHP-6-0078" class="indexterm"/></p><p>First, the data. A shape can be described as a series of latitude and longitude points, where the start and end are the same point, enclosing a polygon. You may be able to create the shape you want by tracing the border. You can likely find someone sharing their shape online. For example, polygons for all 50 US states can be found at <a class="ulink" href="http://mapscripting.com/state-boundaries">http://mapscripting.com/state-boundaries</a>.</p><p>We'll perform a hit test to see if the point where a user clicks is inside a state. Seeing as Kansas is somewhat rectangular, let's choose a state that has a slightly more complex shape, such as Utah (see <a class="xref" href="ch06s10.html#the_state_of_utah_apostrophy_s_panhandle" title="Figure 6-10. The state of Utah's panhandle makes for a good hit test.">Figure 6-10</a>). The edges of Utah are made up of six points, which means describing Utah as a line requires seven points (because the final point needs to reconnect with the first point).</p><p>Here is some Mapstraction code to describe the outline of Utah as a series of coordinates:</p><a id="I_programlisting6_d1e7275"/><pre class="programlisting">utah = [new mxn.LatLonPoint(36.99, −114.05), new mxn.LatLonPoint(36.99, −109.04),
        new mxn.LatLonPoint(40.99, −109.05), new mxn.LatLonPoint(40.99, −111.05),
        new mxn.LatLonPoint(41.99, −111.05), new mxn.LatLonPoint(41.99, −114.04),
        new mxn.LatLonPoint(36.99, −114.05)];</pre><p>Now we want to write a function that determines whether a particular point is within the polygon that could be created with these points. Our point could be anywhere on the earth. Seeing as Utah is a relatively small area, our point is quite likely not in the state. Let's rule that out quickly—before getting to the advanced math.</p><div class="figure"><a id="the_state_of_utah_apostrophy_s_panhandle"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7282"/><img src="httpatomoreillycomsourcenostarchimages672067.png.jpg" alt="The state of Utah's panhandle makes for a good hit test."/></div></div><p class="title">Figure 6-10. The state of Utah's panhandle makes for a good hit test.</p></div><div class="sect2" title="Find the Polygon's Bounding Box"><div class="titlepage"><div><div><h2 class="title"><a id="find_the_polygon_apostrophy_s_bounding_b"/>Find the Polygon's Bounding Box</h2></div></div></div><p>The easiest way to determine that a point is <span class="emphasis"><em>not</em></span> within a polygon is to show the point lies outside the polygon's bounding box. To determine the rectangular bounds of a polygon, we must look through each point, so we can find the minimum and maximum values for both latitude and longitude.<a id="IDX-CHP-6-0079" class="indexterm"/><a id="IDX-CHP-6-0080" class="indexterm"/><a id="IDX-CHP-6-0081" class="indexterm"/><a id="IDX-CHP-6-0082" class="indexterm"/></p><p>Once we have those values, we'll know what to use to create the bounding box. An example of one is shown in <a class="xref" href="ch06s10.html#a_polygon_apostrophy_s_rectangular_bound" title="Figure 6-11. A polygon's rectangular bounds">Figure 6-11</a>.</p><p>Let's write a function to create a new Mapstraction <code class="literal">BoundingBox</code> from a series of <code class="literal">LatLonPoints</code>. Here is the code for the entire function:</p><a id="I_programlisting6_d1e7323"/><pre class="programlisting">function points_to_bounds(pts) {
    if (pts.length &gt; 0) { var minlat = pts[0].lat
      var maxlat = minlat;
      var minlon = pts[0].lon
      var maxlon = minlon;
❶     for (var i = 1; i &lt; pts.length; i++) {
        var pt = pts[i];
❷       if (pt.lat &gt; maxlat) {
❸         maxlat = pt.lat;
         }
        if (pt.lon &gt; maxlon) {
          maxlon = pt.lon;
        }
  if (pt.lat &lt; minlat) {
          minlat = pt.lat;
        }
        if (pt.lon &lt; minlon) {
          minlon = pt.lon;
        }
      }
❹     return new mxn.BoundingBox(minlat, minlon, maxlat, maxlon);
    }
    return null;
  }</pre><div class="figure"><a id="a_polygon_apostrophy_s_rectangular_bound"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7328"/><img src="httpatomoreillycomsourcenostarchimages672069.png.jpg" alt="A polygon's rectangular bounds"/></div></div><p class="title">Figure 6-11. A polygon's rectangular bounds</p></div><p>We want to determine four values: the smallest latitude, the largest latitude, the smallest longitude, and the largest longitude. Because we have to start somewhere, we begin with the assumption that the first point is both minimum and maximum. That's simply so we have something to compare.</p><p>Then, beginning with the second point (which has an index of one because JavaScript array indexes start at zero), we loop through all the other points ❶. Each time through the loop, we check whether we have found new minimum or maximum values. For example, if the current point has a latitude greater than what we currently think is the maximum ❷, then we need to set the maximum to be this value ❸.</p><p>Once we have completed the loop, the four values will be correct. Those values represent the corners of a <code class="literal">BoundingBox</code>. The SW corner is made up of the minimum values, the NE corner of the maximum. We can create the <code class="literal">BoundingBox</code> and return it for use elsewhere ❹.<a id="IDX-CHP-6-0083" class="indexterm"/></p><p>Now that we have the bounds, we can check whether a point is within the polygon with the simple rectangle that surrounds our polygon. I covered this in detail earlier, and I'll demonstrate it again in a few sections when we perform the complete hit test.</p></div><div class="sect2" title="Connect Our Point to an Outside Point"><div class="titlepage"><div><div><h2 class="title"><a id="connect_our_point_to_an_outside_point"/>Connect Our Point to an Outside Point</h2></div></div></div><p>Okay, if we've gotten this far, we've determined that our point is inside the polygon's bounding box. This doesn't mean the point is within the polygon itself, but it's at least nearby. In our Utah example, our point is in the very northeast corner of the bounding box, but not inside the Utah polygon.</p><p>Now the tricky stuff begins, but within this trickery, you'll find simplicity. We need to make a temporary line for testing. This line connects our point (the one that may be inside the polygon) to a point that we can guarantee is outside the polygon.</p><p>When we draw the temporary line, it may intersect the line segments that make up our polygon. If the lines crosses the polygon an odd number of times, our point is inside. If it crosses the polygon an even number of times, or not at all, our point is outside. <a class="xref" href="ch06s10.html#polygon_representing_utah_only_intersect" title="Figure 6-12. Polygon representing Utah only intersected once—the point is inside the shape.">Figure 6-12</a> provides a visual of the Utah example.</p><div class="figure"><a id="polygon_representing_utah_only_intersect"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7366"/><img src="httpatomoreillycomsourcenostarchimages672071.png.jpg" alt="Polygon representing Utah only intersected once—the point is inside the shape."/></div></div><p class="title">Figure 6-12. Polygon representing Utah only intersected once—the point is inside the shape.</p></div><p>The hit test is only conclusive if we can guarantee the new point we create will be outside the polygon. How can we do that? We'll create a latitude for our new point that is less than the SW latitude.<a id="IDX-CHP-6-0084" class="indexterm"/><a id="IDX-CHP-6-0085" class="indexterm"/><a id="IDX-CHP-6-0086" class="indexterm"/><a id="IDX-CHP-6-0087" class="indexterm"/><a id="IDX-CHP-6-0088" class="indexterm"/></p><p>If the point we're testing is called <code class="literal">mypt</code> and our <code class="literal">BoundingBox</code> is called <code class="literal">box</code>, here's the code to create our testing point:</p><a id="I_programlisting6_d1e7401"/><pre class="programlisting">var lat_change = (❶(box.ne.lat - box.sw.lat) / 100);
var pt2 = new mxn.LatLonPoint(box.sw.lat - lat_change, mypt.lon);</pre><p>We don't need to move very far outside the bounding box. To determine how much to change the latitude, I took the number of degrees between the SW and NE ❶ and divided by 100. In the case of Utah, our new point would be 0.05 degrees below the southern border. The smaller the difference between north and south latitudes, the closer the new point will be to the bounding box—but the point will always be outside of the box.</p><p>For the longitude of the new point, I set it to be the same as the longitude of the point we're checking. That decision was arbitrary, as any longitude would create a point outside the bounding box, because the latitude is less than the box's smallest latitude.</p></div><div class="sect2" title="Check for Line Intersections"><div class="titlepage"><div><div><h2 class="title"><a id="check_for_line_intersections"/>Check for Line Intersections</h2></div></div></div><p>Now we have a bounding box and a point outside the box that can be connected with the point we want to test. The final step is to determine how many times the line connecting those two points crosses the polygon. To do this, we need to know how to check whether two lines intersect.</p><p>The code becomes a little confusing because there are many variables, despite only working with two line segments. We have four separate points or eight different values. From two to four to eight. Like I said, things become confusing quickly.</p><p>Add in a little vector math (based on a solution written in Visual Basic and available at <a class="ulink" href="http://www.vb-helper.com/howto_segments_intersect.html">http://www.vb-helper.com/howto_segments_intersect.html</a>), and the code starts to look complicated. Here is the JavaScript code to test whether a line segment from point A to B intersects with another from point C to D:</p><a id="I_programlisting6_d1e7418"/><pre class="programlisting">function check_intersection(A, B, C, D) {
❶   var latdiff1 = B.lat − A.lat;
    var latdiff2 = D.lat − C.lat;
    var londiff1 = B.lon − A.lon;
    var londiff2 = D.lon − C.lon;

    // Make sure lines aren't parallel
❷   if (londiff2 * latdiff1 - latdiff2 * londiff1 != 0) {
      var segtest1 = (londiff1 * (C.lat - A.lat) + latdiff1 * (A.lon − C.lon))
                     / ❸(londiff2 * latdiff1 - latdiff2 * londiff1);
      var segtest2 = (londiff2 * (A.lat - C.lat) + latdiff2 * (C.lon − A.lon))
                     / (latdiff2 * londiff1 - londiff2 * latdiff1);
❹     if (segtest1 &gt;= 0 &amp;&amp; segtest1 &lt;= 1 &amp;&amp; segtest2 &gt;= 0 &amp;&amp; segtest2 &lt;= 1) {
        return true;
      }
    }
    return false;
  }</pre><p>The first thing the code does is calculate how far away the ends of each line are, such as the distance between the latitudes of point A and B ❶. These values become the foundation of the vector computations that will determine whether the lines intersect.<a id="IDX-CHP-6-0089" class="indexterm"/><a id="IDX-CHP-6-0090" class="indexterm"/></p><p>With just the latitude and longitude distances, we can make sure the lines aren't parallel ❷. Determining this saves us further computation because parallel lines will never intersect. More importantly, we won't divide by zero with our first segment test ❸.</p><p>The <code class="literal">segtest1</code> and <code class="literal">segtest2</code> variables compare line AB to CD, then vice versa. The value determines where the two lines intersect. Because they aren't parallel, they <span class="emphasis"><em>will</em></span> intersect somewhere. If both of the segment tests are between 0 and 1 ❹, then we know the intersection happens within our line segments.</p></div><div class="sect2" title="Perform the Hit Test"><div class="titlepage"><div><div><h2 class="title"><a id="perform_the_hit_test"/>Perform the Hit Test</h2></div></div></div><p>At this point, we've found the bounding box of the polygon, drawn a line from the point outside the polygon to our point in question, and learned how to determine whether two line segments intersect. Do you feel like we've lost track of the original plan to find out whether our point is within the polygon? Okay then, let's put it all together and perform the hit test.</p><p>Remember our point is within the polygon if the line that we created intersects an odd number of lines that make up the polygon. We'll need to test each and every segment against our line that we know at least <span class="emphasis"><em>starts</em></span> outside the polygon.</p><p>Here is the function, using the pieces we've put together earlier in this project, to determine whether a point is within a polygon:</p><a id="I_programlisting6_d1e7456"/><pre class="programlisting">function check_polygon(mypt, polypts) {
❶   var box = points_to_bounds(polypts);
❷   if (box.contains(mypt)) {
      var lat_change = ((box.ne.lat - box.sw.lat) / 100);
❸     var pt2 = new mxn.LatLonPoint(box.sw.lat - lat_change, mypt.lon);
      var intersections = 0;
❹     for (var i = 1; i &lt; polypts.length; i++) {
        var seg1 = polypts[i-1];
        var seg2 = polypts[i];
❺       if (check_intersection(seg1, seg2, mypt, pt2)) {
          intersections++;
        }
      }
❻     if (intersections % 2 == 1) {
        return true;
      }
    }
    return false;
  }</pre><p>The hit test function is passed the point to check and the array of points that make up the polygon. From the latter, we're able to determine the bounding box of the polygon ❶. Then, of course, we don't have to do anything unless our point is within this box ❷. The point cannot be within the polygon if it isn't within the polygon's bounds.<a id="IDX-CHP-6-0091" class="indexterm"/><a id="IDX-CHP-6-0092" class="indexterm"/></p><p>Now we're ready to check whether the point is inside the polygon. To do this, we create a temporary line between our point and a point outside the bounding box ❸. Then we need to check where this line intersects with the polygon. To do this, we'll loop through the polygon's points ❹, checking for intersections with this temporary line.</p><p>Each time through the loop, we make two line segments from four points. The first segment is made from two consecutive points from the polygon. The other segment is created with our point and the point we found outside the bounding box.</p><p>We pass these points to the function we created to check for intersections ❺. If the two segments cross, we increase the intersection count. Either way, we then move on to the next trip through the loop.</p><p>When the loop finishes, we'll know whether our point is within the polygon. If the intersection count is odd, the point is inside. If the count is even, our point is outside. A number is odd if, when dividing it by two, you have a remainder of one. The modulus operator, <code class="literal">%</code>, gives us the remainder ❻. A remainder means we have an odd number of intersections, and we return true because the point is within the polygon. In all other cases, we return false because the point is not within the polygon.<a id="IDX-CHP-6-0093" class="indexterm"/></p></div><div class="sect2" title="You Clicked in Utah!"><div class="titlepage"><div><div><h2 class="title"><a id="you_clicked_in_utah_exclamation"/>You Clicked in Utah!</h2></div></div></div><p>Now that we're able to check whether a point is within a polygon, let's incorporate it into a map. At the beginning of this chapter, we created a series of points shaped like the state of Utah. We'll use that, along with all the other code shown so far, to report whether the user has clicked inside the polygon described by the <code class="literal">utah</code> variable.</p><p>Create a basic map and add in the polygon points. We'll need the functions we've created so far, too. Make sure to include the <code class="literal">check_polygon</code>, <code class="literal">check_intersection</code>, and <code class="literal">points_to_bounds</code> functions. Then add the following code, replacing the <code class="literal">create_map</code> function that already exists:<a id="IDX-CHP-6-0094" class="indexterm"/></p><a id="I_programlisting6_d1e7505"/><pre class="programlisting">function create_map() {
    mapstraction = new mxn.Mapstraction('mymap', 'google');
    mapstraction.setCenterAndZoom(new mxn.LatLonPoint(39.5, −111.7), 6);
    mapstraction.addSmallControls();
❶   mapstraction.click.addHandler(function(event_type, event_source, event_args) {
      var clickpoint = event_args.location;
      var intersects = check_polygon(clickpoint, utah);
❷     if (intersects) {
        msg = "You clicked in Utah!";
      }
      else {
        msg = "That's not Utah!";
      }
❸     var m = new mxn.Marker(clickpoint);
      m.setInfoBubble(msg);
      mapstraction.addMarker(m);
      m.openBubble();
    });
  }</pre><p>The first few lines create the new map, center it on Utah, and add zoom controls. Then we need to wait for the user to click somewhere on the map ❶. When is the user clicks, we initiate an inline, anonymous function, with the click point passed as an argument, as shown in <a class="xref" href="ch05s02.html" title="#27: The User Clicks the Map">#27: The User Clicks the Map</a> in <a class="xref" href="ch05s02.html" title="#27: The User Clicks the Map">#27: The User Clicks the Map</a>.</p><p>The difficult work of checking for whether a point is within a polygon is passed off to the <code class="literal">check_polygon</code> function. This function, which we wrote in a previous section, returns either <code class="literal">true</code> or <code class="literal">false</code>. If the function returns true ❷, we create a text variable to tell the user "You clicked in Utah!" Otherwise, the user gets a message saying "That's not Utah!"</p><p>Now we need to report the click and the outcome. We do this by creating a marker at the click point ❸ and putting the text inside a message box. Then we add the marker to the page and open the message box.</p><p>Try it out for yourself or see <a class="xref" href="ch06s10.html#you_can_apostrophy_t_trick_mathmthat_poi" title="Figure 6-13. You can't trick math—that point is outside of Utah!">Figure 6-13</a>. See if you can trick the test by clicking in the NE corner of the state, where Wyoming appears to intrude into Utah's bounding box. Sure enough, if you click outside of Utah, you'll see the correct message. Ditto when clicking inside of Utah. The hit test gets the right answer every time.</p><div class="figure"><a id="you_can_apostrophy_t_trick_mathmthat_poi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7533"/><img src="httpatomoreillycomsourcenostarchimages672073.png.jpg" alt="You can't trick math—that point is outside of Utah!"/></div></div><p class="title">Figure 6-13. You can't trick math—that point is outside of Utah!</p></div></div></div>
<div class="sect1" title="#46: Get Nearest Locations from Your Own Database"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_46_colon_get_nearest_locat"/>#46: Get Nearest Locations from Your Own Database</h1></div></div></div><p>Earlier in this chapter, I showed how to calculate the distance between two points and how to determine the closest marker to a point. Arguably more useful is what we'll be doing in this project: getting the nearest location to a point from a list of many possibilities stored in a database.<a id="IDX-CHP-6-0095" class="indexterm"/><a id="IDX-CHP-6-0096" class="indexterm"/><a id="IDX-CHP-6-0097" class="indexterm"/></p><p>To look up locations in a database, we need to have something in the database in the first place. For this example, we'll use the database table from <a class="xref" href="ch09s05.html" title="#63: Store Locations to a Database">#63: Store Locations to a Database</a> in <a class="xref" href="ch09s04.html#install_mysql_yourself" title="Install MySQL Yourself">Install MySQL Yourself</a>. Although we're using MySQL as an engine, most databases will work with the SQL statements here. <span class="emphasis"><em>Structured query language (SQL)</em></span> is a syntax to communicate with a database server.</p><p>Because we're looking for the nearest locations to a single point, we need to determine what that point is. I've chosen a point near me in Portland, Oregon, with a latitude of 45.517 and a longitude of −122.649. Now we'll plug this into the Haversine formula—that's the same bit of trigonometry we used in JavaScript, but this time we'll use SQL.</p><p>From either the MySQL command interpreter or phpMyAdmin, type the following query:<a id="IDX-CHP-6-0098" class="indexterm"/></p><a id="I_programlisting6_d1e7570"/><pre class="programlisting">SET @earthRadius = 6371;
SET @lat = 45.517;
SET @lon = −122.649;
SET @radLat = RADIANS(@lat);
SET @radLon = RADIANS(@lon);
SET @cosLat = COS(@radLat);
SET @sinLat = SIN(@radLat);
SELECT *,
  <strong class="userinput"><code>( @earthRadius❶ * ACOS( @cosLat * cosRadLat *</code></strong>
  <strong class="userinput"><code>COS( radLon - @radLon ) + @sinLat *</code></strong>
  <strong class="userinput"><code>sinRadLat ) ) AS dist</code></strong>
FROM places
ORDER BY dist;</pre><p>We select all the fields from the places table, plus an additional field, as described by the entire section in bold. That's a lot of code! It calculates the distance between our point and the points in the database using the latitude and longitude values stored with each place.</p><p>The distance, which becomes a column named <code class="literal">dist</code>, is expressed in kilometers. As with the previous implementation of the Haversine formula, we multiply by the radius of the earth, which is 6371 km. For miles, replace the number ❶ with its mile equivalent: 3958.</p><p>When you run this SQL query, your results will be the same as those shown in <a class="xref" href="ch06s11.html#results_of_nearest_place_sql" title="Table 6-2. Results of Nearest Place SQL">Table 6-2</a>. Because we ordered by the distance, the places nearest to our point come first in the table. Therefore, the nearest place to the point we selected is Old Faithful.</p><div class="table"><a id="results_of_nearest_place_sql"/><p class="title">Table 6-2. Results of Nearest Place SQL</p><div class="table-contents"><table summary="Results of Nearest Place SQL" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>ID</p></th><th style="text-align: left" valign="bottom"><p>Name</p></th><th style="text-align: left" valign="bottom"><p>Latitude</p></th><th style="text-align: left" valign="bottom"><p>Longitude</p></th><th style="text-align: left" valign="bottom"><p>Distance</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>Old Faithful Geyser</p></td><td style="text-align: left" valign="top"><p>44.4605</p></td><td style="text-align: left" valign="top"><p>− 110.828</p></td><td style="text-align: left" valign="top"><p>936.12</p></td></tr><tr><td style="text-align: left" valign="top"><p>2</p></td><td style="text-align: left" valign="top"><p>St. Louis Arch</p></td><td style="text-align: left" valign="top"><p>38.6247</p></td><td style="text-align: left" valign="top"><p>− 90.1851</p></td><td style="text-align: left" valign="top"><p>2765.97</p></td></tr></tbody></table></div></div></div></body></html>