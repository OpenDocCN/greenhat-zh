<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;STORAGE WITH XEN"><div class="titlepage"><div><div><h1 class="title"><a id="storage_with_xen"/>Chapter 4. STORAGE WITH XEN</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e3595"/><img src="httpatomoreillycomsourcenostarchimages333191.png.jpg" alt="image with no caption"/></div></div><p>Throughout this book, so far, we've talked about Xen mostly as an integrated whole, a complete virtualization <span class="emphasis"><em>solution</em></span>, to use marketing's word. The reality is a bit more complex than that. Xen itself is only one component of a platform that aims to free users from having to work with real hardware. The Xen hypervisor virtualizes a processor (along with several other basic components, as outlined in <a class="xref" href="ch02.html" title="Chapter 2. GETTING STARTED">Chapter 2</a>), but it relies on several underlying technologies to provide seamless abstractions of the resources a computer needs. This distinction is clearest in the realm of storage, where Xen has to work closely with a virtualized storage layer to provide the capabilities we expect of a virtual machine.</p><p>By that we mean that Xen, combined with appropriate storage mechanisms, provides near total hardware independence. The user can run the Xen machine anywhere, move the instance about almost at will, add storage freely, save the filesystem state cleanly, and remove it easily after it's done.</p><p>Sounds good? Let's get started.</p><div class="sect1" title="Storage: The Basics"><div class="titlepage"><div><div><h1 class="title"><a id="storage_the_basics"/>Storage: The Basics</h1></div></div></div><p>The first thing to know about <a id="idx-CHP-4-0265" class="indexterm"/>storage—before we dive into configuration on the dom0 side—is how to communicate its <a id="idx-CHP-4-0266" class="indexterm"/>existence to the domain. DomUs find their storage by <a id="idx-CHP-4-0267" class="indexterm"/>examining the domU config file for a <code class="literal">disk=</code> line. Usually it'll look something like this:</p><a id="I_programlisting4_d1e3637"/><pre class="programlisting">disk = [
      'phy:/dev/cleopatra/menas,sda,w',
      'phy:/dev/cleopatra/menas_swap,sdb,w'
]</pre><p>This line defines two devices, which appear to the domU as <code class="literal">sda</code> and <code class="literal">sdb</code>. Both are physical,<sup>[<a id="CHP-4-FNOTE-1" href="#ftn.CHP-4-FNOTE-1" class="footnote">26</a>]</sup> as indicated by the <code class="literal">phy:</code> prefix—other storage backends have their own prefixes, such as <code class="literal">file:</code> and <code class="literal">tap:</code> for file-backed devices. You can mix and match backing device types as you like—we used to provide a pair of <code class="literal">phy:</code> volumes and a file-backed read-only "rescue" image.</p><p>We call this a line, but it's really more of a stanza—you can put the strings on separate lines, indent them with tabs, and put spaces after the commas if you think that makes it more readable. In this case, we're using LVM, with a volume group named <span class="emphasis"><em>cleopatra</em></span> and a pair of logical volumes called <span class="emphasis"><em>menas</em></span> and <span class="emphasis"><em>menas_swap</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="note-15"/>Note</h3><p><span class="emphasis"><em>By convention, we'll tend to use the same name for a domain, its devices, and its config file. Thus, here, the logical volumes</em></span> menas <span class="emphasis"><em>and</em></span> menas_swap <span class="emphasis"><em>belong to the domain</em></span> menas, <span class="emphasis"><em>which has the config file</em></span> /etc/xen/menas <span class="emphasis"><em>and network interfaces with similar names. This helps to keep everything organized</em></span>.</p></div><p>You can examine the storage attached to a domain by using the <code class="literal">xm block-list</code> command—for example:<a id="idx-CHP-4-0269" class="indexterm"/></p><a id="I_programlisting4_d1e3709"/><pre class="programlisting"># xm block-list menas
Vdev  BE handle state evt-ch ring-ref BE-path
2049   0     0     4      6      8     /local/domain/0/backend/vbd/1/2049
2050   0     0     4      7      9     /local/domain/0/backend/vbd/1/2050</pre><p>Now, armed with this knowledge, we can move on to creating backing storage in the dom0.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-1" href="#CHP-4-FNOTE-1" class="para">26</a>] </sup>As you may gather, a <span class="emphasis"><em>physical</em></span> device is one that can be accessed via the block device semantics, rather than necessarily a discrete piece of hardware. The prefix instructs Xen to treat the device as a basic block device, rather than providing the extra translation required for a <a id="idx-CHP-4-0268" class="indexterm"/>file-backed image.</p></div></div></div>
<div class="sect1" title="Varying Types of Storage"><div class="titlepage"><div><div><h1 class="title"><a id="varying_types_of_storage"/>Varying Types of Storage</h1></div></div></div><p>It should come as little surprise, this being the world of open source, that Xen supports many different storage options, each with its own strengths, weaknesses, and design philosophy. These options broadly fall into the categories of <span class="emphasis"><em>file based</em></span> and <span class="emphasis"><em>device based</em></span>.</p><p>Xen can use a <span class="emphasis"><em>file</em></span> as a block device. This has the advantage of being simple, easy to move, mountable from the host OS with minimal effort, and easy to manage. It also used to be very slow, but this problem has mostly vanished with the advent of the <a id="idx-CHP-4-0270" class="indexterm"/>blktap driver. The <a id="idx-CHP-4-0271" class="indexterm"/>file-based block devices differ in the means by which Xen accesses them (basic loopback versus blktap) and the internal format (AIO, QCOW, etc.).</p><p>Xen can also perform <a id="idx-CHP-4-0272" class="indexterm"/>I/O to a <span class="emphasis"><em>physical</em></span> device. This has the obvious drawback of being difficult to scale beyond your ability to add physical devices to the machine. The physical device, however, can be anything the kernel has a driver for, including hardware RAID, fibre channel, MD, network block devices, or <a id="idx-CHP-4-0273" class="indexterm"/>LVM. Because Xen accesses these devices via DMA (direct memory access) between the device driver and the Xen instance, mapping <a id="idx-CHP-4-0274" class="indexterm"/>I/O directly into the guest OS's memory region, a domU can access physical devices at near-native speeds.</p><p>No matter what, though, all storage backends look the same from within the Xen virtual domain. The hypervisor exports a Xen VBD (virtual block device) to the domU, which in turn presents the device to the guest OS with an administrator-defined mapping to traditional Unix device nodes. Usually this will be a device of the form <code class="literal">hdx</code> or <code class="literal">sdx</code>, although many distros now use <code class="literal">xvdx</code> for <span class="emphasis"><em>xen virtual disk</em></span>. (The <code class="literal">hd</code> and <code class="literal">sd</code> devices generally work, as well.)</p><p>We recommend blktap (a specialized form of file backend) and LVM <a id="idx-CHP-4-0275" class="indexterm"/>for storage backends. These both work, offer good manageability, can be resized and moved freely, and support some mechanism for the sort of things we expect of <a id="idx-CHP-4-0276" class="indexterm"/>filesystems now that we Live In The Future. blktap is easy to set up and good for testing, while LVM is scalable and good for production.</p><p>None of this is particularly Xen-specific. LVM is actually used (outside of Xen) by default for the root device on many distros, notably Red Hat, because of the management advantages that come with an abstracted storage layer. blktap is simply a Xen-specific mechanism for using a file as a block device, just like the traditional block loop driver. It's superior to the loop mechanism because it allows for vastly improved performance and more versatile filesystem formats, such as QCOW, but it's not fundamentally different from the administrator's perspective.</p><p>Let's get to it.</p></div>
<div class="sect1" title="Basic Setup: Files"><div class="titlepage"><div><div><h1 class="title"><a id="basic_setup_files"/>Basic Setup: Files</h1></div></div></div><p>For people who don't want the hassle and overhead of LVM, Xen supports fast and efficient <a id="idx-CHP-4-0277" class="indexterm"/>file-backed block devices using the blktap driver and library.</p><p>blktap (blk being the worn-down stub of "block" after being typed hundreds of times) includes a kernel driver and a userspace daemon. The kernel driver directly maps the blocks contained by the backing file, avoiding much of the indirection involved in mounting a file via loopback. It works with many file formats used for virtual block devices, including the basic "raw" image format obtainable by <code class="literal">dd</code> ing a block device.</p><p>You can create a file <a id="idx-CHP-4-0278" class="indexterm"/>using the <code class="literal">dd</code> command:</p><a id="I_programlisting4_d1e3824"/><pre class="programlisting"># dd if=/dev/zero of=/opt/xen/anthony.img bs=1M count=1024</pre><div class="note" title="Note"><h3 class="title"><a id="note-16"/>Note</h3><p><span class="emphasis"><em>Your version of dd might require slightly different syntax—for example, it might require you to specify the block size in bytes</em></span>.<a id="idx-CHP-4-0279" class="indexterm"/></p></div><p>Now <code class="literal">dd</code> will chug away for a bit, <a id="idx-CHP-4-0280" class="indexterm"/>copying zeroes to a file. Eventually it'll finish:</p><a id="I_programlisting4_d1e3845"/><pre class="programlisting">1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB) copied, 15.1442 seconds, 70.9 MB/s</pre><p>Thus armed with a <a id="idx-CHP-4-0281" class="indexterm"/>filesystem image, you can attach it using the tap driver, make a filesystem on it, and <a id="idx-CHP-4-0282" class="indexterm"/>mount it as usual with the <code class="literal">mount</code> command.</p><a id="I_programlisting4_d1e3862"/><pre class="programlisting"># xm block-attach 0 tap:aio:/opt/xen/anthony.img /dev/xvda1 w 0
# mkfs /dev/xvda1
# mount /dev/xvda1 /mnt/</pre><p>First, we use the <code class="literal">xm(8)</code> command to attach the block device to <a id="idx-CHP-4-0283" class="indexterm"/>domain 0. In this case the <code class="literal">xm</code> command is followed by the block-attach subcommand, with the arguments <code class="literal">&lt;domain id to attach the device to&gt; &lt;backend device&gt; &lt;frontend device&gt; &lt;mode&gt;</code> and optionally <code class="literal">[backend domain id]</code>. To decompose our example, we are <a id="idx-CHP-4-0284" class="indexterm"/>attaching <em class="filename">anthony.img</em> read/write using the tap:aio driver to <span class="emphasis"><em>/dev/xvda1</em></span> in domain 0 using domain 0 to mediate access (because we tend to avoid using non-dom0 driver domains). When the file is attached as <span class="emphasis"><em>/dev/xvda1</em></span>, we can create a filesystem on it and mount it as with any block device.<a id="idx-CHP-4-0285" class="indexterm"/></p><p>Now that it's mounted, you can put something in it. (See <a class="xref" href="ch03.html" title="Chapter 3. PROVISIONING DOMUS">Chapter 3</a> for details.) In this case, we'll just copy over a <a id="idx-CHP-4-0286" class="indexterm"/>filesystem tree that we happen to have lying around:</p><a id="I_programlisting4_d1e3910"/><pre class="programlisting"># cp -a /opt/xen/images/centos-4.4/* /mnt/</pre><p>Add a <code class="literal">disk=</code> line to the domU config (in our example, <span class="emphasis"><em>/etc/xen/anthony</em></span>) to reflect the filesystem:</p><a id="I_programlisting4_d1e3920"/><pre class="programlisting">disk = ['tap:aio:/opt/xen/anthony.img']</pre><p>Now you should be able to start the domain with its new root device:</p><a id="I_programlisting4_d1e3924"/><pre class="programlisting"># xm create -c anthony</pre><p>Watch the console and bask in its soothing glow.</p><div class="sidebar"><a id="mounting_partitions_within_a_file-backed"/><p class="title">MOUNTING PARTITIONS WITHIN A FILE-BACKED VBD</p><p>There's nothing that keeps you from partitioning a <a id="idx-CHP-4-0287" class="indexterm"/>virtual block device as if it were a hard drive. However, if something goes wrong and you need to mount the subpartitions from <a id="idx-CHP-4-0288" class="indexterm"/>within dom0, it can be harder to recover. The standard mount <code class="literal">-o loop filename /mnt</code> won't work, and neither will something like <code class="literal">mount /dev/xvda1 /mnt</code> (even if the device is attached as <code class="literal">/dev/xvda</code>, Xen will not automatically scan <a id="idx-CHP-4-0289" class="indexterm"/>for a partition table and create appropriate devices).<a id="idx-CHP-4-0290" class="indexterm"/></p><p><code class="literal">kpartx</code> will solve this problem. It reads the partition table <a id="idx-CHP-4-0291" class="indexterm"/>of a block device and adds mappings for the device mapper, which then provides device file-style interfaces to the partitions. After that, you can mount them as usual.<a id="idx-CHP-4-0292" class="indexterm"/></p><p>Let's say you've got an image with a partition table that describes two partitions:</p><a id="I_programlisting4_d1e3979"/><pre class="programlisting"># xm block-attach 0 tap:aio:/path/to/anthony.img /dev/xvda w 0
# kpartx -av /dev/xvda</pre><p><code class="literal">kpartx</code> will then find the two partitions and create <span class="emphasis"><em>/dev/mapper/xvda1</em></span> and <span class="emphasis"><em>/dev/mapper/xvda2</em></span>. Now you should be able to mount and use the newly created device nodes as usual.</p></div><div class="sect2" title="LVM: Device-Independent Physical Devices"><div class="titlepage"><div><div><h2 class="title"><a id="lvm_device-independent_physical_devices"/>LVM: Device-Independent Physical Devices</h2></div></div></div><p>Flat files are well and good, but they're not as robust as simply providing each domain with its own physical volume (or volumes). The best way to use Xen's physical device support is, in our opinion, LVM.</p><p>LVM, short for <span class="emphasis"><em>logical volume management</em></span>, is Linux's answer to VxFS's storage pools or Windows Dynamic Disks. It is what the marketing people call <span class="emphasis"><em>enterprise grade</em></span>. In keeping with the software mantra that "all problems can be solved by adding another layer of abstraction," LVM aims to abstract away the idea of "disks" to improve manageability.</p><p>Instead, LVM (as one might guess from the name) operates on logical volumes. This higher-level view allows the administrator much more flexibility—storage can be moved around and reallocated with near impunity. Even better, from Xen's perspective, there's no difference between an LVM logical volume and a traditional partition.</p><p>Sure, setting up LVM is a bit more work up front, but it'll save you some headaches down the road when you have eight domUs on that box and you are trying to erase the partition for the third one. Using LVM and naming the logical volume to correspond to the domU name makes it quite a bit harder to embarrass yourself by erasing the wrong partition.<sup>[<a id="CHP-4-FNOTE-2" href="#ftn.CHP-4-FNOTE-2" class="footnote">27</a>]</sup></p><div class="sidebar"><a id="qcow"/><p class="title">QCOW</p><p>Up <a id="idx-CHP-4-0293" class="indexterm"/>to this point, we've talked exclusively about the "raw" file <a id="idx-CHP-4-0294" class="indexterm"/>format—but it's not the only option. One possible replacement is the QCOW format used by the <a id="idx-CHP-4-0295" class="indexterm"/>QEMU project. It's got a lot to recommend it—a fast, robust format that supports sparse allocation, encryption, compression, and copy-on-write. We like it, but support isn't quite mature yet, so we're not recommending it as your primary storage option.</p><p>Nonetheless, it might be fun to try. To start working with QCOW, it'll be convenient to have QEMU. (While Xen includes some <a id="idx-CHP-4-0296" class="indexterm"/>of the QEMU tools, the full package includes more functionality.) Download it from <a class="ulink" href="http://www.nongnu.org/qemu/download.html">http://www.nongnu.org/qemu/download.html</a>. As usual, we recommend the source install, especially because the QEMU folks eschew standard package management for their binary distribution.</p><p>Install QEMU via the standard process:</p><a id="I_programlisting4_d1e4046"/><pre class="programlisting"># tar zxvf &lt;qemu source package&gt;
# cd &lt;qemu source directory&gt;
# ./configure
# make
# su
# make install</pre><p>QEMU includes the <code class="literal">qemu-img</code> utility, which is used to create and manipulate the various sorts of image files that QEMU supports, including QCOW, vmdk, raw, and others.</p><a id="I_programlisting4_d1e4053"/><pre class="programlisting"># qemu-img create -f qcow enobarbus.qcow 1024M</pre><p>This command creates an image in QCOW format (<code class="literal">-f qcow</code>) with a size of 1,024MB. Of course, you'll want to replace the filename and size with appropriate values for your application.</p><p>You can also convert a raw image to a QCOW image with the <code class="literal">img2qcow</code> utility, which is included as part of the Xen distribution:</p><a id="I_programlisting4_d1e4065"/><pre class="programlisting"># img2qcow enobarbus.qcow enobarbus.img</pre><p>You can use the QCOW image directly as a domain's root disk with the tap driver. Configure the guest domain to use the QCOW image as its root filesystem. In the domain's config file under <span class="emphasis"><em>/etc/xen</em></span>, add a <code class="literal">disk=</code> line similar to:</p><a id="I_programlisting4_d1e4076"/><pre class="programlisting">disk = [ 'tap:qcow:/opt/xen/enobarbus/enobarbus.qcow,sda1,w' ]</pre><p>You can extend this line with another disk, thus:</p><a id="I_programlisting4_d1e4080"/><pre class="programlisting">disk = [ 'tap:qcow:/opt/xen/enobarbus/enobarbus.qcow,sda1,w' ,
'tap:qcow:/opt/xen/enobarbus/enobarbus_disk2.qcow,sdb1,w']</pre></div><div class="sect3" title="Basic Setup: LVM"><div class="titlepage"><div><div><h3 class="title"><a id="basic_setup_lvm"/>Basic Setup: LVM</h3></div></div></div><p>The high-level unit that LVM operates on is the <span class="emphasis"><em>volume group</em></span>, or <span class="emphasis"><em>VG</em></span>. Each group maps <span class="emphasis"><em>physical extents</em></span> (disk regions of configurable size) to <span class="emphasis"><em>logical extents</em></span>. The physical extents are hosted on what LVM refers to as <span class="emphasis"><em>physical volumes</em></span>, or <span class="emphasis"><em>PVs</em></span>. Each VG can contain one or more of these, and the PVs themselves can be any sort of block device supported by the kernel. The logical <a id="idx-CHP-4-0297" class="indexterm"/>extents, reasonably enough, are on <span class="emphasis"><em>logical volumes</em></span>, abbreviated <span class="emphasis"><em>LVs</em></span>. These are the devices that LVM actually presents <a id="idx-CHP-4-0298" class="indexterm"/>to the system as usable <a id="idx-CHP-4-0299" class="indexterm"/>block devices.<a id="idx-CHP-4-0300" class="indexterm"/><a id="idx-CHP-4-0301" class="indexterm"/><a id="idx-CHP-4-0302" class="indexterm"/><a id="idx-CHP-4-0303" class="indexterm"/></p><p>As we're fond of saying, there really is no substitute <a id="idx-CHP-4-0304" class="indexterm"/>for experience. Here's a five-minute illustrated tutorial in setting up logical volumes (see <a class="xref" href="ch04s03.html#this_diagram_shows_a_single_vg_with_two_" title="Figure 4-1. This diagram shows a single VG with two PVs. From this VG, we've carved out three logical volumes, lv1, lv2, and lv3. lv1 and lv3 are being used by domUs, one of which treats the entire volume as a single partition and one of which breaks the LV into subpartitions for / and /var.">Figure 4-1</a>).</p><div class="figure"><a id="this_diagram_shows_a_single_vg_with_two_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4156"/><img src="httpatomoreillycomsourcenostarchimages333209.png.jpg" alt="This diagram shows a single VG with two PVs. From this VG, we've carved out three logical volumes, lv1, lv2, and lv3. lv1 and lv3 are being used by domUs, one of which treats the entire volume as a single partition and one of which breaks the LV into subpartitions for / and /var."/></div></div><p class="title">Figure 4-1. This diagram shows a single VG with two PVs. From this VG, we've carved out three logical volumes, lv1, lv2, and lv3. lv1 and lv3 are being used by domUs, one of which treats the entire volume as a single partition and one of which breaks the LV into subpartitions for / and /var.</p></div><p>Begin with some hard drives. In this example, we'll use two SATA disks.<a id="idx-CHP-4-0305" class="indexterm"/></p><div class="note" title="Note"><h3 class="title"><a id="note-17"/>Note</h3><p><span class="emphasis"><em>Given that Xen is basically a server technology, it would probably be most sensible to use RAID-backed redundant storage, rather than actual hard drives. They could also be partitions on drives, network block devices, UFS-formatted optical media … whatever sort of block device you care to mention. We're going to give instructions using a partition on two hard drives, however. These instructions will also hold if you're just using one drive</em></span>.<a id="idx-CHP-4-0306" class="indexterm"/></p></div><div class="warning" title="Warning"><h3 class="title"><a id="warning-1"/>Warning</h3><p><span class="emphasis"><em>Note that we are going to repartition and format these drives, which will destroy all data on them</em></span>.</p></div><p>First, we partition the drives and set the type to <span class="emphasis"><em>Linux LVM</em></span>. Although this isn't strictly necessary—you can use the entire drive as a PV, if desired—it's generally considered good Unix hygiene. Besides, you'll need to partition if you want to use only a portion of the disk for LVM, which is a fairly common scenario. (For example, if you want to boot from one of the physical disks that you're using with LVM, you will need a separate <span class="emphasis"><em>/boot</em></span> partition.)</p><p>So, in this example, we have two disks, sda and sdb. We want the first 4GB of each drive to be used as LVM physical volumes, so we'll partition them with <code class="literal">fdisk</code> and set the type to 8e (Linux LVM).</p><p>If any partitions on the disk are in use, you will need to reboot to get the kernel to reread the partition table. (We think this is ridiculous, by the way. Isn't this supposed to be the future?)</p><p>Next, make sure that you've got LVM and that it's LVM2, because LVM1 is deprecated.<sup>[<a id="CHP-4-FNOTE-3" href="#ftn.CHP-4-FNOTE-3" class="footnote">28</a>]</sup></p><a id="I_programlisting4_d1e4202"/><pre class="programlisting"># vgscan --version
LVM version:        2.02.23 (2007-03-08)
Library version:    1.02.18 (2007-02-13)
Driver version:     4.5.0</pre><p>You might need to load the driver. If <code class="literal">vgscan</code> complains that the driver is missing, run:<a id="idx-CHP-4-0307" class="indexterm"/></p><a id="I_programlisting4_d1e4212"/><pre class="programlisting"># modprobe dm_mod</pre><p>In this case, <code class="literal">dm</code> stands <a id="idx-CHP-4-0308" class="indexterm"/>for <span class="emphasis"><em>device mapper</em></span>, which is a low-level volume manager that functions as the backend for LVM.</p><p>Having established that all three of these components are working, create physical volumes as illustrated in <a class="xref" href="ch04s03.html#this_diagram_shows_a_single_block_device" title="Figure 4-2. This diagram shows a single block device after pvcreate has been run on it. It's mostly empty, except for a small identifier on the front.">Figure 4-2</a>.</p><a id="I_programlisting4_d1e4232"/><pre class="programlisting"># <a id="idx-CHP-4-0309" class="indexterm"/>pvcreate /dev/sda1
# pvcreate /dev/sdb1</pre><div class="figure"><a id="this_diagram_shows_a_single_block_device"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4241"/><img src="httpatomoreillycomsourcenostarchimages333211.png.jpg" alt="This diagram shows a single block device after pvcreate has been run on it. It's mostly empty, except for a small identifier on the front."/></div></div><p class="title">Figure 4-2. This diagram shows a single block device after pvcreate has been run on it. It's mostly empty, except for a small identifier on the front.</p></div><p>Bring these components together into a volume group by running <code class="literal">vgcreate</code>. Here we'll create a volume group named <span class="emphasis"><em>cleopatra</em></span> on the devices sda1 and sdb1:<a id="idx-CHP-4-0310" class="indexterm"/><a id="idx-CHP-4-0311" class="indexterm"/></p><a id="I_programlisting4_d1e4262"/><pre class="programlisting"># vgcreate cleopatra /dev/sda1 /dev/sdb1</pre><p>Finally, make volumes from the volume group <a id="idx-CHP-4-0312" class="indexterm"/>using <code class="literal">lvcreate</code>, as shown in <a class="xref" href="ch04s03.html#lvcreate_creates_a_logical_volume_devvgl" title="Figure 4-3. lvcreate creates a logical volume, /dev/vg/lvol, by chopping some space out of the LV, which is transparently mapped to possibly discontinuous physical extents on PVs.">Figure 4-3</a>. Think of it as a more powerful and versatile form of partitioning.</p><a id="I_programlisting4_d1e4277"/><pre class="programlisting"># lvcreate -L &lt;length&gt; -m1 --corelog -n menas cleopatra</pre><p>Here we've created a mirrored logical volume that keeps its logs in core (rather than on a separate physical device). Note that this step takes a group name rather than a device node. Also, the mirror is purely for illustrative purposes—it's not required if you're using some sort of redundant device, such as hardware RAID or MD. Finally, it's an administrative convenience to give LVs human-readable names using the <code class="literal">-n</code> option. It's not required but quite recommended.</p><div class="figure"><a id="lvcreate_creates_a_logical_volume_devvgl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4288"/><img src="httpatomoreillycomsourcenostarchimages333213.png" alt="lvcreate creates a logical volume, /dev/vg/lvol, by chopping some space out of the LV, which is transparently mapped to possibly discontinuous physical extents on PVs."/></div></div><p class="title">Figure 4-3. lvcreate creates a logical volume, /dev/vg/lvol, by chopping some space out of the LV, which is transparently mapped to possibly discontinuous physical extents on PVs.</p></div><p>Create a filesystem using your favorite filesystem-creation tool:</p><a id="I_programlisting4_d1e4295"/><pre class="programlisting"># mkfs /dev/cleopatra/menas</pre><p>At this point, the LV is ready to mount and access, just as if it were a normal disk.</p><a id="I_programlisting4_d1e4299"/><pre class="programlisting"># mount /dev/cleopatra/menas /mnt/hd</pre><p>To make the new device a suitable root <a id="idx-CHP-4-0313" class="indexterm"/>for a Xen domain, copy a filesystem into it. We used one from <a class="ulink" href="http://stacklet.com/">http://stacklet.com/</a>—we just mounted their root filesystem and copied it over to our new volume.</p><a id="I_programlisting4_d1e4311"/><pre class="programlisting"># mount -o loop gentoo.img /mnt/tmp/
# cp -a /mnt/tmp/* /mnt/hd</pre><p>Finally, to use it with Xen, we can specify the logical volume to the guest domain just as we would any physical device. (Note that here we're back to the same example we started the chapter with.)</p><a id="I_programlisting4_d1e4315"/><pre class="programlisting">disk = ['phy:/dev/cleopatra/menas,sda1,w']</pre><p>At this point, start the machine. Cross your fingers, wave a dead chicken, perform the accustomed ritual. In this case our deity is propitiated by an <code class="literal">xm create</code>. Standards have come down in the past few millennia.</p><a id="I_programlisting4_d1e4323"/><pre class="programlisting"># xm create menas</pre></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-2" href="#CHP-4-FNOTE-2" class="para">27</a>] </sup>This example is not purely academic.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-3" href="#CHP-4-FNOTE-3" class="para">28</a>] </sup>This is unlikely to be a problem unless you are using Slackware.</p></div></div></div>
<div class="sect1" title="Enlarge Your Disk"><div class="titlepage"><div><div><h1 class="title"><a id="enlarge_your_disk"/>Enlarge Your Disk</h1></div></div></div><p>Both <a id="idx-CHP-4-0314" class="indexterm"/>file-backed images and LVM <a id="idx-CHP-4-0315" class="indexterm"/>disks can be expanded transparently from the dom0. We're going to assume that disk space is so plentiful that you will never need to shrink an image.<a id="I_indexterm4_d1e4342" class="indexterm"/><a id="I_indexterm4_d1e4347" class="indexterm"/></p><p>Be sure to stop the domain before attempting to resize its underlying filesystem. For one thing, all of the user-space resize tools that we know of won't attempt to resize a mounted filesystem. For another, the Xen hypervisor won't pass along changes to the underlying block device's size without restarting the domain. Most important, even if you were able to resize the backing store with the domain running, data corruption would almost certainly result.</p><div class="sect2" title="File-Backed Images"><div class="titlepage"><div><div><h2 class="title"><a id="file-backed_images"/>File-Backed Images</h2></div></div></div><p>The principle behind augmenting <a id="idx-CHP-4-0316" class="indexterm"/>file-backed images is simple: We append more bits to the file, then expand the filesystem.<a id="idx-CHP-4-0317" class="indexterm"/></p><p>First, make sure that nothing is <a id="idx-CHP-4-0318" class="indexterm"/>using the file. Stop any domUs that have it mounted. Detach it from the dom0. Failure to do this will likely result in filesystem corruption.</p><p>Next, use <code class="literal">dd</code> to add some bits to the end. In this case we're directing 1GB from our <span class="emphasis"><em>/dev/zero</em></span> bit hose to <em class="filename">anthony.img</em>. (Note that not specifying an output file causes <code class="literal">dd</code> to write to stdout.)</p><a id="I_programlisting4_d1e4390"/><pre class="programlisting"># dd if=/dev/zero bs=1M count=1024 &gt;&gt; /opt/xen/anthony.img</pre><p>Use <code class="literal">resize2fs</code> to extend the filesystem (or the equivalent tool for your choice of filesystem).<a id="idx-CHP-4-0319" class="indexterm"/></p><a id="I_programlisting4_d1e4400"/><pre class="programlisting"># e2fsck -f /opt/xen/anthony.img
# resize2fs /opt/xen/anthony.img</pre><p><code class="literal">resize2fs</code> will default to making the filesystem the size of the underlying device if there's no partition table.</p><p>If the image contains partitions, you'll need to rearrange those before resizing the filesystem. Use <code class="literal">fdisk</code> to delete the partition that you wish to resize and recreate it, making sure that the starting cylinder remains the same.</p></div><div class="sect2" title="LVM"><div class="titlepage"><div><div><h2 class="title"><a id="lvm"/>LVM</h2></div></div></div><p>It's just as easy, or perhaps even easier, to use LVM to expand <a id="idx-CHP-4-0320" class="indexterm"/>storage. LVM was designed from the beginning to increase the flexibility of storage devices, so it includes an easy mechanism to extend a volume (as well as shrink and move).<a id="idx-CHP-4-0321" class="indexterm"/></p><p>If there's free space in the volume group, simply issue the command:</p><a id="I_programlisting4_d1e4429"/><pre class="programlisting"># lvextend -L +1G /dev/cleopatra/charmian</pre><p>If the volume group is full, you'll need to expand it. Just add a disk to the machine and extend the vg:</p><a id="I_programlisting4_d1e4433"/><pre class="programlisting"># <a id="idx-CHP-4-0322" class="indexterm"/>vgextend /dev/cleopatra /dev/sdc1</pre><p>Finally, just as in the previous example, handle the filesystem-level expansion—we'll present this one <a id="idx-CHP-4-0323" class="indexterm"/>using ReiserFS.</p><a id="I_programlisting4_d1e4447"/><pre class="programlisting"># resize_reiserfs -s +1G /dev/cleopatra/charmian</pre></div></div>
<div class="sect1" title="Copy-on-Write and Snapshots"><div class="titlepage"><div><div><h1 class="title"><a id="copy-on-write_and_snapshots"/>Copy-on-Write and Snapshots</h1></div></div></div><p>One <a id="idx-CHP-4-0324" class="indexterm"/>of the other niceties that a real <a id="idx-CHP-4-0325" class="indexterm"/>storage option gives you is <a id="idx-CHP-4-0326" class="indexterm"/>copy-on-write, which means that, rather than the domU overwriting a file when it's changed, the backend instead transparently writes a copy elsewhere.<sup>[<a id="CHP-4-FNOTE-4" href="#ftn.CHP-4-FNOTE-4" class="footnote">29</a>]</sup> As a corollary, the original filesystem remains as a <span class="emphasis"><em>snapshot</em></span>, with all modifications directed to the copy-on-write clone.<a id="idx-CHP-4-0328" class="indexterm"/><a id="idx-CHP-4-0329" class="indexterm"/></p><p>This snapshot provides the ability to save a filesystem's state, taking a snapshot of it at a given time or at set intervals. There are two useful things about snapshots: for one, they allow for easy recovery from user error.<sup>[<a id="CHP-4-FNOTE-5" href="#ftn.CHP-4-FNOTE-5" class="footnote">30</a>]</sup> For another, they give you a checkpoint that's known to be consistent—it's something that you can conveniently back up and move elsewhere. This eliminates the need to take servers offline for backups, such as we had to do in the dark ages.</p><p>CoW likewise has a bunch of uses. Of these, the most fundamental implication for Xen is that it can dramatically reduce the on-disk overhead of each virtual machine—rather than using a simple file as a block device or a logical volume, many machines can share a single base filesystem image, only requiring disk space to write their changes to that filesystem.</p><p>CoW also comes with its own disadvantages. First, there's a speed penalty. The CoW infrastructure slows disk access down quite a bit compared with writing directly to the device, for both reading and writing.</p><p>If you're using sparse allocation for CoW volumes, the speed penalty becomes greater due to the overhead of allocating and remapping blocks. This leads to fragmentation, which carries its own set of performance penalties. CoW can also lead to the administrative problem of oversubscription; by making it possible to oversubscribe disk space, it makes life much harder if you accidentally run out. You can avoid all of this by simply allocating space in advance.</p><p>There's also a trade-off in terms of administrative complexity, as with most interesting features. Ultimately, you, the Xen administrator, have to decide how much complexity is worth having.</p><p>We'll discuss device mapper snapshots, as used by <a id="idx-CHP-4-0330" class="indexterm"/>LVM because they're the implementation that we're most familiar with. For shared storage, we'll focus on NFS and go into more detail on shared storage systems in <a class="xref" href="ch09.html" title="Chapter 9. XEN MIGRATION">Chapter 9</a>. We also outline a CoW solution with UnionFS in <a class="xref" href="ch07.html" title="Chapter 7. HOSTING UNTRUSTED USERS UNDER XEN: LESSONS FROM THE TRENCHES">Chapter 7</a>. Finally, you might want to try QCOW block devices—although we haven't had much luck with them, your mileage may vary.<a id="I_indexterm4_d1e4521" class="indexterm"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-4" href="#CHP-4-FNOTE-4" class="para">29</a>] </sup>This is traditionally abbreviated <a id="idx-CHP-4-0327" class="indexterm"/>CoW, partly because it's shorter, but mostly because "cow" is an inherently funny word. Just ask Wikipedia.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-5" href="#CHP-4-FNOTE-5" class="para">30</a>] </sup>It's not as hard you might suppose to <code class="literal">rm</code> your home directory.</p></div></div></div>
<div class="sect1" title="LVM and Snapshots"><div class="titlepage"><div><div><h1 class="title"><a id="lvm_and_snapshots"/>LVM and Snapshots</h1></div></div></div><p><a id="idx-CHP-4-0331" class="indexterm"/>LVM snapshots are designed more to <span class="emphasis"><em>back up</em></span> and <span class="emphasis"><em>checkpoint</em></span> a filesystem than as a means of long-term storage. It's important to keep LVM snapshots relatively fresh—or, in other words, make sure to drop them when your backup is done.<sup>[<a id="CHP-4-FNOTE-6" href="#ftn.CHP-4-FNOTE-6" class="footnote">31</a>]</sup></p><p>Snapshot volumes can also be used as read-write <a id="idx-CHP-4-0333" class="indexterm"/>backing store for domains, especially in situations where you just want to generate a quick domU for testing, based on some preexisting disk image. The LVM documentation notes that you can create a basic image, snapshot it multiple times, and modify each snapshot slightly for another domain. In this case, LVM snapshots would act like a block-level UnionFS. However, note that when a snapshot fills up, it's immediately dropped by the kernel. This may lead to data loss. The basic procedure for adding an LVM snapshot is simple: Make sure that you have some unused space in your volume group, and create a snapshot volume for it.</p><div class="sidebar"><a id="the_xen_l_ivecd_revisited_copy-on-write_"/><p class="title">THE XEN L IVECD REVISITED: COPY-ON-WRITE IN ACTION</p><p>The Xen LiveCD actually is a pretty nifty release. One of its neatest features is the ability to automatically create <a id="idx-CHP-4-0334" class="indexterm"/>copy-on-write block devices when a Xen domain starts, based on read-only images on the CD.<a id="idx-CHP-4-0335" class="indexterm"/></p><p>The implementation uses the device mapper to set up block devices and snapshots based on flat files, and is surprisingly simple.</p><p>First, the basic storage is defined with a line like this in the domain config file:</p><a id="I_programlisting4_d1e4575"/><pre class="programlisting">disk=['<a id="idx-CHP-4-0336" class="indexterm"/>cow:/mnt/cdrom/rootfs.img 30,sda1,w']</pre><p>Note the use of the <code class="literal">cow:</code> prefix, which we haven't mentioned yet. This is actually a custom prefix rather than part of the normal Xen package.</p><p>We can add custom prefixes like cow: because <span class="emphasis"><em>/etc/xen/scripts/create_block_device</em></span> falls through to a script with a name of the form <span class="emphasis"><em>block-[type]</em></span> if it finds an unknown device type—in this case, cow. The <span class="emphasis"><em>block-cow</em></span> script expects one argument, either <code class="literal">create or destroy</code>, which the domain builder provides when it calls the script. <span class="emphasis"><em>block-cow</em></span> then calls either the <span class="emphasis"><em>create_cow or destroy_cow</em></span> script, as appropriate.</p><p>The real setup takes place in a script, <span class="emphasis"><em>/usr/sbin/create_cow</em></span>. This script essentially uses the device mapper to create a copy-on-write device based on an LVM snapshot,<sup>[<a id="CHP-4-FNOTE-7" href="#ftn.CHP-4-FNOTE-7" class="footnote">32</a>]</sup> which it presents to the domain. We won't reproduce it here, but it's a good example of how standard Linux features can form the basis for complex, abstracted functions. In other words, a good hack.</p></div><p>First, check to see whether you have the driver <code class="literal">dm_snapshot</code>. Most modern distros ship with this driver built as a loadable module. (If it's not built, go to your Linux kernel source tree and compile it.)<a id="idx-CHP-4-0337" class="indexterm"/></p><a id="I_programlisting4_d1e4627"/><pre class="programlisting"># locate dm_snapshot.ko</pre><p>Manually load it if necessary.</p><a id="I_programlisting4_d1e4631"/><pre class="programlisting"># modprobe dm_snapshot</pre><p>Create the snapshot <a id="idx-CHP-4-0338" class="indexterm"/>using the <code class="literal">lvcreate</code> command with the <code class="literal">-s</code> option to indicate "snapshot." The other parameters specify a length and name as in an ordinary logical volume. The final parameter specifies the <span class="emphasis"><em>origin</em></span>, or volume being snapshotted.</p><a id="I_programlisting4_d1e4650"/><pre class="programlisting"># lvcreate -s -L 100M -n pompei.snap /dev/cleopatra/pompei</pre><p>This snapshot then appears to be a frozen image <a id="idx-CHP-4-0339" class="indexterm"/>of the filesystem—writes will happen as normal on the original volume, but the snapshot will retain changed files as they were when the snapshot was taken, up to the maximum capacity of the snapshot.</p><p>When making a snapshot, the length indicates the maximum amount of changed data that the snapshot will be able to store. If the snapshot fills up, it'll be dropped automatically by the kernel driver and will become unusable.</p><p>For a sample script that uses an <a id="idx-CHP-4-0340" class="indexterm"/>LVM snapshot to back up a Xen instance, see <a class="xref" href="ch07.html" title="Chapter 7. HOSTING UNTRUSTED USERS UNDER XEN: LESSONS FROM THE TRENCHES">Chapter 7</a>.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-6" href="#CHP-4-FNOTE-6" class="para">31</a>] </sup>Even if you add no data to the snapshot itself, it can run out of space (and corrupt itself) just keeping up <a id="idx-CHP-4-0332" class="indexterm"/>with changes in the main LV.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-7" href="#CHP-4-FNOTE-7" class="para">32</a>] </sup>More properly, a device mapper snapshot, which LVM snapshots are based on. LVM snapshots are device mapper snapshots, but device mapper snapshots can be based on any pair of block devices, LVM or not. The LVM tools provide a convenient frontend to the arcane commands used by <code class="literal">dmsetup</code>.</p></div></div></div>
<div class="sect1" title="Storage and Migration"><div class="titlepage"><div><div><h1 class="title"><a id="storage_and_migration"/>Storage and Migration</h1></div></div></div><p>These two storage <a id="idx-CHP-4-0341" class="indexterm"/>techniques—flat files and LVM—lend themselves well to easy and automated <span class="emphasis"><em>cold migration</em></span>, in which the administrator halts the domain, copies the domain's config file and <a id="idx-CHP-4-0342" class="indexterm"/>backing storage to another physical machine, and restarts the domain.<a id="idx-CHP-4-0343" class="indexterm"/><a id="idx-CHP-4-0344" class="indexterm"/></p><p>Copying over a file-based backend is as simple as copying any file over the <a id="idx-CHP-4-0345" class="indexterm"/>network. Just drop it onto the new box in its corresponding place in the filesystem, and start the machine.</p><p>Copying an LVM is a bit more involved, but it is still straightforward: Make the target device, mount it, and move the files in whatever fashion you care to.</p><p>Check <a class="xref" href="ch09.html" title="Chapter 9. XEN MIGRATION">Chapter 9</a> for more details on this sort of migration.</p><div class="sect2" title="Network Storage"><div class="titlepage"><div><div><h2 class="title"><a id="network_storage"/>Network Storage</h2></div></div></div><p>These two storage methods only apply to locally accessible storage. Live migration, in which a domain is moved from one machine to another without being halted, requires one other piece of this puzzle: The filesystem must be accessible over the network to multiple machines. This is an area of active development, with several competing solutions. Here we'll discuss <a id="idx-CHP-4-0346" class="indexterm"/>NFS-based storage. We will address other solutions, including ATA over Ethernet <a id="idx-CHP-4-0347" class="indexterm"/>and iSCSI, in <a class="xref" href="ch09.html" title="Chapter 9. XEN MIGRATION">Chapter 9</a>.<a id="idx-CHP-4-0348" class="indexterm"/></p><div class="sect3" title="NFS"><div class="titlepage"><div><div><h3 class="title"><a id="nfs"/>NFS</h3></div></div></div><p>NFS is older than we are, and it is used by organizations of all sizes. It's easy to set up and relatively easy to administer. Most operating systems can interact with it. For these reasons, it's probably the easiest, cheapest, and fastest way to set up a live migration-capable Xen domain.</p><p>The idea is to marshal Xen's <a id="idx-CHP-4-0349" class="indexterm"/>networking metaphor: The domains are connected (in the default setup) to a virtual <a id="idx-CHP-4-0350" class="indexterm"/>network switch. Because the dom0 is also attached to this switch, it can act as an NFS server for the domUs.</p><p>In this case we're exporting a directory tree—neither a physical device nor a file. NFS server setup is quite simple, and it's cross platform, so you can use any NFS device you like. (We prefer FreeBSD-based NFS servers, but NetApp and several other companies produce fine NFS appliances. As we might have mentioned, we've had poor luck using Linux as an NFS server.) Simply export your OS image. In our example, on the FreeBSD NFS server at 192.0.2.7, we have a full Slackware image at <span class="emphasis"><em>/usr/xen/images/slack</em></span>. Our <span class="emphasis"><em>/etc/exports</em></span> looks a bit like this:</p><a id="I_programlisting4_d1e4759"/><pre class="programlisting">/usr/xen/images/slack   -maproot=0 192.0.2.222</pre><p>We leave further server-side setup to your doubtless extensive experience with NFS. One easy refinement would be to make / read-only and shared, then export read-write VM-specific <span class="emphasis"><em>/var</em></span> and <span class="emphasis"><em>/home</em></span> partitions—but in the simplest case, just export a full image.</p><div class="note" title="Note"><h3 class="title"><a id="note-18"/>Note</h3><p><span class="emphasis"><em>Although NFS does imply a performance hit, it's important to recall that Xen's network buffers and disk buffers are provided by the same paravirtualized device infrastructure, and so the actual network hardware is not involved. There is increased overhead in transversing the networking stack, but performance is usually better than gigabit Ethernet, so it is not as bad as you might think</em></span>.</p></div><p>Now configure the client (<code class="literal">CONFIG_IP_PNP=y</code>). First, you'll need to make some changes to the domU's kernel to enable root on NFS:</p><a id="I_programlisting4_d1e4779"/><pre class="programlisting">networking-&gt;
networking options-&gt;
ip: kernel level autoconfiguration</pre><p>If you want to do everything via <a id="idx-CHP-4-0351" class="indexterm"/>DHCP (although you should probably still specify a MAC address in your domain config file), add DHCP support under that tree: <code class="literal">CONFIG_IP_PNP_DHCP</code>: or <code class="literal">CONFIG_IP_PNP_BOOTP</code> if you're old school. If you are okay specifying the IP in your domU config file, skip that step.<a id="idx-CHP-4-0352" class="indexterm"/></p><p>Now you need to enable support for root on NFS. Make sure NFS support is Y <a id="idx-CHP-4-0353" class="indexterm"/>and not M; that is, <code class="literal">CONFIG_NFS_FS=Y</code>. Next, enable root over NFS: <code class="literal">CONFIG_ROOT_NFS=Y</code>. In <span class="emphasis"><em>menuconfig</em></span>, you can find that option under:</p><a id="I_programlisting4_d1e4814"/><pre class="programlisting">File systems -&gt;
  <a id="idx-CHP-4-0354" class="indexterm"/>Network File Systems -&gt;
    NFS file system support -&gt;
      Root over NFS</pre><p>Note that <span class="emphasis"><em>menuconfig</em></span> won't give you the option of selecting root over NFS until you select kernel-level IP autoconfiguration.</p><p>Build the kernel as normal and install it somewhere where Xen can load it. Most likely this isn't what you want for a dom0 kernel, so make sure to avoid overwriting the boot kernel.</p><p>Now configure the domain that you're going <a id="idx-CHP-4-0355" class="indexterm"/>to boot over NFS. Edit the domain's config file:</p><a id="I_programlisting4_d1e4835"/><pre class="programlisting"># Root device for nfs.
root = "/dev/nfs"

# The nfs server.
nfs_server = '38.99.2.7'

# Root directory on the nfs server.
nfs_root   = '/usr/xen/images/slack'

netmask="255.255.255.0"
gateway="38.99.2.1"
ip="38.99.2.222"</pre><p>Note that we're just adding extra Linux kernel configuration to the domain config—values not used by Xen will be passed to the kernel command line. You can also explicitly put this configuration in the "extra" parameter. If you want to set the IP address via DHCP, you can replace the last three lines above with:</p><a id="I_programlisting4_d1e4839"/><pre class="programlisting">dhcp="dhcp"</pre><p>You can then use DHCP to specify the NFS server and NFS root as well in the usual manner. Boot the domain and you're done. Because the <a id="idx-CHP-4-0356" class="indexterm"/>storage is accessible to any machine on the <a id="idx-CHP-4-0357" class="indexterm"/>network, Xen's live migration should work as well.<a id="I_indexterm4_d1e4853" class="indexterm"/><a id="I_indexterm4_d1e4858" class="indexterm"/></p></div></div></div>
<div class="sect1" title="Closing Suggestions"><div class="titlepage"><div><div><h1 class="title"><a id="closing_suggestions"/>Closing Suggestions</h1></div></div></div><p>This might seem like a bewildering, or even excessive, variety of storage options, but all of these have their places—be it in a hosting environment, or on the desktop, or in a storage pool for utility computing. The recommendations we've made in this chapter are a start, but in the end the best advice we can offer is to try all of these and see what works best. Find the right trade-off between ease of administration and scalability.</p><p>Finally, you can combine and extend many of these options. For example, the Xen LiveCD uses flat images with LVM snapshots. Depending on your application, the best solution might be simple filesystem images or a combination of software RAID and LVM. Keep experimenting and see what fits best. These are all examples of the flexibility of Xen's standards-based architecture, which relies on user-extensible scripts to define available storage using easily understood semantics. In <a class="xref" href="ch05.html" title="Chapter 5. NETWORKING">Chapter 5</a>, we'll look at how these same principles apply to Xen's network setup.</p></div></body></html>