- en: Chapter 16. Meterpreter Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metasploit’s powerful scripting environment lets you add features or options
    to Meterpreter. In this chapter, you’ll learn the basics of Meterpreter scripting,
    some useful native calls, and learn how to run these commands from within Meterpreter.
    We’ll cover two ways to leverage Meterpreter scripting. The first method is somewhat
    outdated but still important, because not all scripts have been converted. The
    second method is nearly identical to the one discussed in [Chapter 13](part0017.html#building_your_own_module),
    so we won’t cover it in detail in this chapter. (Special thanks to Carlos Perez
    [darkoperator] for his contributions to this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter Scripting Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Meterpreter scripts are located under the Framework root under *scripts/meterpreter/*.
    To show a listing of all scripts, press the tab key in a Meterpreter shell, enter
    **`run`**, and press tab again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dissect a simple Meterpreter script and then build our own. We’ll explore
    the `multi_meter_inject` script that injects Meterpreter shells into different
    processes. To begin, take a look at this script in Meterpreter to see what flags
    and syntax are included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first option is the `-m` flag ![](../images/00002.gif), which automatically
    sets up a new handler for us on the return connection. We would not need to set
    this option if we were going to use the same port (for example, 443). Next we
    specify the process IDs (PIDs) ![](../images/00004.gif) that we need and the shells
    into which they will be injected.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter executes in memory only. When we inject into a process, we are injecting
    Meterpreter into the memory space of that process. This allows us to remain stealthy,
    never reading or writing files to disk, while ultimately having multiple shells
    available to us.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the IP address ![](../images/00005.gif) and port number ![](../images/00006.gif)
    on the attacking machine to which we want the new Meterpreter session to connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We issue the `ps` command within Meterpreter to get a list of running processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll inject our new Meterpreter shell into the *iexplorer.exe* ![](../images/00002.gif)
    process. This will spawn a second Meterpreter console completely within memory
    and will never write data to the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the `multi_meter_inject` command using some of the switches we reviewed
    earlier to see if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As this output indicates, our command was successful and a new Meterpreter session
    has been opened, as shown at ![](../images/00002.gif).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what this script can do, let’s examine how it works.
    We’ll break the script into chunks to help us parse its commands and overall structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, variables and definitions are defined and the flags we want to pass
    to Meterpreter are set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of this section of script, notice that several variables are
    defined for later use. For example, `pid = nil` at ![](../images/00002.gif) creates
    a PID variable but its value is not set. The `@exec_opts = Rex::Parser::Arguments.new(`
    section at ![](../images/00004.gif) defines the additional help commands and flags
    that will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section defines functions that we will call later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the function `usage` at ![](../images/00002.gif) will be called
    when the `-h` flag is set. You can call a number of Meterpreter functions directly
    from the Meterpreter API. This functionality simplifies certain tasks, such as
    injecting into a new process with the `def inject` function, as shown at ![](../images/00004.gif).
  prefs: []
  type: TYPE_NORMAL
- en: The next important element is the `host_process.memory.allocate` call at ![](../images/00005.gif),
    which will allow us to allocate memory space for our Meterpreter payload. We then
    write the memory to our process using `host_process.memory.write` at ![](../images/00006.gif)
    and create a new thread using `host_process.thread.create` at ![](../images/00007.gif).
  prefs: []
  type: TYPE_NORMAL
- en: Next we define the multi-handler that handles the connections based on the selected
    payload, as shown in boldface in the following output. (The default is Meterpreter,
    so the multi-handler will handle Meterpreter sessions unless otherwise specified.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `pay = client.framework.payloads.create(payload)` call in the following
    section allows us to create a payload from the Metasploit Framework. Because we
    know this is a Meterpreter payload, Metasploit will automatically generate it
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The next option spawns a process using Notepad by default. If we didn’t specify
    a process, it would have created a Notepad process for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The boldfaced call lets us execute any command on the operating system. Notice
    that `Hidden` is set to `true`. This means that the user on the other side (the
    target) will not see anything; if Notepad is opened, it will run without the target
    user’s knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we call our functions, throw if statements, and start the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we go through a couple of checks, make sure the syntax is correct,
    and inject our new Meterpreter session into our PID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Meterpreter API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During a penetration test, you might be unable to find an existing script that
    matches what you need in order to perform a required task. If you understand the
    basic concepts of programming, it should be relatively easy for you to pick up
    the Ruby syntax and use it to write additional scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start off with a basic print statement that uses the interactive Ruby
    shell, also known as `irb`. From the Meterpreter console, issue the **`irb`**
    command and begin typing commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After you are inside the interactive shell, you can use it to test the different
    API calls from Meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Printing Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the `print_line()` call, which will print the output and add
    a carriage return at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next call is `print_status()` and is used most often in the scripting language.
    This call will provide a carriage return and print the status of whatever is executing,
    with a `[*]` prefixed at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next call is `print_good()`, which is used to provide the results of an
    action or to indicate that the action was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next call is `print_error()`, which is used to provide an error message
    or to indicate that an action was not possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Base API Calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Meterpreter includes many API calls that you can use in your scripts to provide
    additional functionality or customization. You can use several reference points
    for these API calls. The one most often used by scripting newbies looks at how
    the Meterpreter console user interface (UI) uses the calls; these can be used
    as a base to continue writing scripts. To access this code, read the files under
    */opt/framework3/msf3/lib/rex/post/meterpreter/ui/console/command_dispatcher/*
    in Back|Track. If you create a listing of the folder contents, you can see the
    files that contain various commands that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Within these scripts are the various Meterpreter core, desktop interaction,
    privileged operations, and many more commands. Review these scripts to become
    intimately familiar with how Meterpreter operates within a compromised system.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter Mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Meterpreter mixins are a series of calls that represent the most common
    tasks undertaken in a Meterpreter script. These calls are not available in `irb`
    and can be used only when creating a script for Meterpreter. Following is a list
    of some of the most notable calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`cmd_exec(cmd)`** Executes the given command as hidden and channelized.
    The output of the command is provided as a multiline string. |'
  prefs: []
  type: TYPE_TB
- en: '| **`eventlog_clear(evt = "")`** Clears a given event log or all event logs
    if none is given. Returns an array of event logs that were cleared. |'
  prefs: []
  type: TYPE_TB
- en: '| **`eventlog_list()`** Enumerates the event logs and returns an array containing
    the names of the event logs. |'
  prefs: []
  type: TYPE_TB
- en: '| **`file_local_digestmd5(file2md5)`** Returns a string with the MD5 checksum
    of a given local file. |'
  prefs: []
  type: TYPE_TB
- en: '| **`file_local_digestsha1(file2sha1)`** Returns a string with the SHA1 checksum
    of a given local file. |'
  prefs: []
  type: TYPE_TB
- en: '| **`file_local_digestsha2(file2sha2)`** Returns a string with the SHA256 checksum
    of a given local file. |'
  prefs: []
  type: TYPE_TB
- en: '| **`file_local_write(file2wrt, data2wrt)`** Writes a given string to a specified
    file. |'
  prefs: []
  type: TYPE_TB
- en: '| **`is_admin?()`** Identifies whether or not the user is an admin. Returns
    `true` if the user is an admin and `false` if not. |'
  prefs: []
  type: TYPE_TB
- en: '| **`is_uac_enabled?()`** Determines whether User Account Control (UAC) is
    enabled on the system. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_createkey(key)`** Creates a given registry key and returns `true`
    if successful. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_deleteval(key,valname)`** Deletes a registry value given the
    key and value name. Returns `true` if successful. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_delkey(key)`** Deletes a given registry key and returns `true`
    if successful. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_enumkeys(key)`** Enumerates the subkeys of a given registry key
    and returns an array of subkeys. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_enumvals(key)`** Enumerates the values of a given registry key
    and returns an array of value names. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_getvaldata(key,valname)`** Returns the data of a given registry
    key and its value. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_getvalinfo(key,valname)`** Returns the data and type of a given
    registry key and its value. |'
  prefs: []
  type: TYPE_TB
- en: '| **`registry_setvaldata(key,valname,data,type)`** Sets the data for a given
    value and type of data on the target registry. Returns `true` if successful. |'
  prefs: []
  type: TYPE_TB
- en: '| **`service_change_startup(name,mode)`** Changes a given service startup mode.
    The name and the mode must be provided. The mode is a string set with either a
    corresponding auto, manual, or disable setting. The service name is case sensitive.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`service_create(name, display_name, executable_on_host,startup=2)`** Function
    for the creation of a service that runs its own process. Its parameters are the
    service name as a string, the display name as a string, the path of the executable
    on the host that will execute at startup as a string, and the startup type as
    an integer: `2` for Auto, `3` for Manual, or `4` for Disable (default is Auto).
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`service_delete(name)`** Function for deleting a service by deleting the
    key in the registry. |'
  prefs: []
  type: TYPE_TB
- en: '| **`service_info(name)`** Gets Windows service information. The information
    is returned in a hash with display name, startup mode, and command executed by
    the service. The service name is case sensitive. Hash keys are `Name`, `Start`,
    `Command`, and `Credentials`. |'
  prefs: []
  type: TYPE_TB
- en: '| **`service_list()`** Lists all Windows services present. Returns an array
    containing the services’ names. |'
  prefs: []
  type: TYPE_TB
- en: '| **`service_start(name)`** Function for service startup. Returns `0` if the
    service is started, `1` if the service is already started, and `2` if service
    is disabled. |'
  prefs: []
  type: TYPE_TB
- en: '| **`service_stop(name)`** Function for stopping a service. Returns `0` if
    the service is stopped successfully, `1` if the service is already stopped or
    disabled, and `2` if the service cannot be stopped. |'
  prefs: []
  type: TYPE_TB
- en: You should understand the basics regarding the Meterpreter mixin calls that
    you can use to add functionality to your custom script.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Writing Meterpreter Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating Meterpreter scripts, you need to understand the following rules
    before you begin your first script and if you want them to be committed to the
    Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Use only instance, local, and constant variables; never use global or class
    variables because they might interfere with the Framework variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use hard tabs for indenting; do not use spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For code blocks, do not use `{}`. Instead, use `do` and `end`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When declaring functions, always write a comment before the declaration and
    provide a brief description of its purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use `sleep`; use `"select(nil, nil, nil, <time>)"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use `puts` or any other standard output calls; instead use `print`, `print_line`,
    `print_status`, `print_error`, and `print_good`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always include an `-h` option that will print a description and the purpose
    of the script and show the available options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your script is meant for a specific operating system or Meterpreter platform,
    make sure it runs only on those platforms and prints out an error message for
    an unsupported OS or platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Your Own Meterpreter Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up your favorite editor and create a new file called *execute_upload.rb*,
    located in *scripts/meterpreter/*. We’ll start by adding comments to the top of
    the file to let everyone know the purpose of this script and to define our options
    for the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This should look somewhat familiar, because it’s almost exactly the same as
    the example from Carlos Perez that appeared earlier in the chapter. The help message
    is defined with `-h` at ![](../images/00002.gif), and `-r` and `-p` are specified
    for the remote IP address ![](../images/00004.gif) and port number ![](../images/00005.gif)
    we’ll need for our new Meterpreter executable. Note that a `true` statement is
    included; this indicates that these fields are required.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the variables we want to use throughout the script. We’ll call
    the `Rex::Text.rand_text_alpha` function to create a unique executable name every
    time it’s called. This is efficient, because we don’t want to assign an executable
    name statically, which would “antivirus fingerprint” the attack. We’ll also configure
    each argument so that it either assigns a value or prints information with, for
    example, the `-h`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we broke out each argument and assigned values or print information
    back to the user. The `rhost = val` ![](../images/00002.gif) means “take the value
    presented from the user when `-r` was input.” The `rport = val.to_i` ![](../images/00004.gif)
    simply assigns the value as an integer (it will always need to be an integer for
    a port number).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next series, we define everything we need to create our payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We define our payload as a `windows/meterpreter/reverse_tcp` at ![](../images/00002.gif),
    generate the payload calling the `client.framework.payloads.create(payload)` at
    ![](../images/00004.gif), and specify the necessary parameters to create the multi-handler.
    These are all the required fields we need to set our payload using the `LHOST`
    and `LPORT` options and create a listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we create our executable (*win32pe meterpreter*), upload it to our target
    machine, and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The variables called `#{`*`something`*`}` have already been defined within the
    script and will be called later. Notice that we already defined `tempdir` and
    `filename`. Moving into the script, we first include an if statement to detect
    whether the platform we are targeting is a Windows-based system ![](../images/00002.gif);
    otherwise, the attack won’t run. We then expand the temp directory ![](../images/00004.gif)
    on the target machine; this would be the equivalent of *%TEMP%*. Next we create
    a new file on the system and write out the new *EXE* we just generated from the
    `::Msf::Util::EXE.to_win32pe` ![](../images/00005.gif) call. Remember that we
    set the `session.sys.process.execute` to `Hidden` so that the target user won’t
    see anything pop up on his side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this all together, our final script should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our newly created Meterpreter script, let’s launch Metasploit,
    get into Meterpreter, and execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Success! We have created a Meterpreter script and successfully executed it to
    spawn a new Meterpreter shell. This is a small example of the power and flexibility
    of the Meterpreter scripting language and Ruby in general.
  prefs: []
  type: TYPE_NORMAL
- en: One important element to discuss briefly (as mentioned earlier) is the move
    to convert Meterpreter scripts to a format similar to the Metasploit modules.
    We’ll use a small demo of a module built for bypassing the Windows 7 UAC. Windows
    Vista and later introduced a feature similar to `sudo` in UNIX- and Linux-based
    systems. With this feature, a user is assigned limited account permissions until
    administrative-level permissions are necessary. When the user needs admin rights
    to perform a task, a prompt appears, telling the user that admin rights are required
    and are being used. The ultimate goal of this feature is to protect against a
    compromise or virus infection and to limit exposure only to one user account.
  prefs: []
  type: TYPE_NORMAL
- en: In December 2010, Dave Kennedy and Kevin Mitnick released a new Meterpreter
    module that bypassed the Windows UAC component by injecting a payload into a process
    that had a trusted publisher certificate and was considered “UAC Safe.” When injecting
    into the process, a DLL can be called, running under the context of that UAC Safe
    process, which then executes commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use the post exploitation modules, which can be used to
    bypass UAC. We first start the *multi/handler* module with the `-j` flag, which
    allows us to accept multiple Meterpreter shells. Notice in this example that when
    we try to run the `getsystem` command, it fails because it is being blocked by
    Windows UAC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can’t bridge over to a system-level account, because UAC is blocking
    us. We need to get around UAC to obtain system-level privileges and ultimately
    become an administrator so that we can further compromise the machine. We press
    ctrl-Z to back out, keeping the session active. Then we use the new format to
    run post modules and bypass the Windows UAC functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We could also have executed `run` instead of `use` within the Meterpreter console
    and it would have leveraged the default options and executed without having to
    set up the various options.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the preceding example that we succeed in gaining system-level rights
    on a target machine with UAC enabled. This small example demonstrates how the
    post exploitation modules will ultimately be set up and converted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script works simply by uploading a previously compiled executable to the
    target machine and then running it. Take a look at the post exploitation module
    for a better idea of what’s going on behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We won’t cover all the details of the post exploitation module because it is
    nearly identical to the attack shown in [Chapter 13](part0017.html#building_your_own_module).
    Carefully walk through each line, and then try to build and run your own module.
  prefs: []
  type: TYPE_NORMAL
- en: Walk through existing Meterpreter scripts and look at the different commands,
    calls, and functions that can be used to create your own script. If you come up
    with a great idea for a new script, submit it to the Metasploit development team
    — who knows; it might be a script that others can use!
  prefs: []
  type: TYPE_NORMAL
