["```\n  #a/usr/bin/env ruby\n  # radio_player1.rb\n\n❶ PLAY_FILE_PROC = lambda do |filename|    *Callbacks*\n    puts \"I'm playing #{filename}.\"\n  end\n\n❷ DONT_PLAY_FILE_PROC = lambda do |filename|\n    puts \"I'm not playing #{filename}. So there.\"\n  end\n\n❸ class RadioPlayer\n\n❹   DIRS_TO_IGNORE = ['.', '..', 'CVS']    *CVS*\n\n❺   PICK_FROM_DIR_PROC = lambda do |dir, callback_proc, dir_filter|\n\n      puts \"I'm inside #{dir}\" if $DEBUG\n❻       (Dir.open(dir).entries - DIRS_TO_IGNORE).sort.each do |filename|\n\n❼         if ((filename =~ dir_filter) or not dir_filter)\n            item = \"#{dir}/#{filename}\"\n            puts \"#{item} passes the filter\" if $DEBUG\n\n❽           if File.directory?(item)\n              puts \"#{item} is a directory\" if $DEBUG\n              PICK_FROM_DIR_PROC.call(\n                item, callback_proc, dir_filter\n              )\n          else\n            puts \"#{item} is a file\" if $DEBUG\n            callback_proc.call(item)\n          end\n\n        end\n\n      end\n\n    end\n\n❾   def self.walk(dir, callback_proc, dir_filter=nil)\n      puts\n      puts \"I'm walking #{dir} using filter #{dir_filter.inspect}\" if $DEBUG\n      PICK_FROM_DIR_PROC.call(dir, callback_proc, dir_filter)\n    end\n\n  end\n\n❿ dir = 'extras/soundfiles'\n  callback   = (ARGV[0] == 'play') ? PLAY_FILE_PROC : DONT_PLAY_FILE_PROC\n  dir_filter = ARGV[1] ? Regexp.new(ARGV[1]) : nil\n  RadioPlayer.walk(dir, callback, dir_filter)\n  puts\n```", "```\n$ ls -R extras/soundfiles/\nextras/soundfiles/:\n01-Neal_And_Jack_And_Me.ogg  CVS  legal  promo\nextras/soundfiles/CVS:\nEntries  Repository  Root\n\nextras/soundfiles/legal:\nCVS  legal1  legal2\n\nextras/soundfiles/legal/CVS:\nCVS  Entries  Repository  Root\n\nextras/soundfiles/legal/CVS/CVS:\nEntries  Repository  Root\n\nextras/soundfiles/promo:\nCVS  promo1  promo2\n\nextras/soundfiles/promo/CVS:\nCVS  Entries  Repository  Root\n\nextras/soundfiles/promo/CVS/CVS:\nEntries  Repository  Root\n```", "```\n$ ruby -w radio_player1.rb\n\nI'm not playing extras/soundfiles/01-Neal_And_Jack_And_Me.ogg. So there.\nI'm not playing extras/soundfiles/legal/legal1\\. So there.\nI'm not playing extras/soundfiles/legal/legal2\\. So there.\nI'm not playing extras/soundfiles/promo/promo1\\. So there.\nI'm not playing extras/soundfiles/promo/promo2\\. So there.\n```", "```\n$ ruby -w radio_player1.rb play legal\n\nI'm playing extras/soundfiles/legal/legal1.\nI'm playing extras/soundfiles/legal/legal2.\n```", "```\n$ ruby -w radio_player1.rb play\n\nI'm playing extras/soundfiles/01-Neal_And_Jack_And_Me.ogg.\nI'm playing extras/soundfiles/legal/legal1.\nI'm playing extras/soundfiles/legal/legal2.\nI'm playing extras/soundfiles/promo/promo1.\nI'm playing extras/soundfiles/promo/promo2.\n```", "```\n  #a/usr/bin/env ruby\n  # radio_player2.rb\n\n❶ LOG_FILE = '/tmp/radio_player2.log'\n\n❷ PLAYERS = {\n    '.mp3' => 'mpg321',\n    '.ogg' => 'ogg123',\n    ''     => 'ls'\n  }\n\n❸ # these are variables, local to Kernel.\n  # They work just as well as constants.\n  play_file_proc = lambda do |filename|    *Callbacks*\n❹   ext = File.extname(filename)\n❺   system(\"#{PLAYERS[ext]} #{filename}\") if PLAYERS[ext]\n❻   File.open(LOG_FILE, 'a') do |log|\n      log.puts([Time.now, filename].join(\"\\t\") + \"\\n\")\n    end\n  end\n\n  dont_play_file_proc = lambda do |filename|\n    puts \"I'm not playing #{filename}. So there.\"\n  end\n\n  class RadioPlayer\n\n    DIRS_TO_IGNORE = ['.', '..', 'CVS']\n\n    PICK_FROM_DIR_PROC = lambda do |dir, callback_proc, dir_filter|\n\n      (Dir.open(dir).entries - DIRS_TO_IGNORE).sort.each do |filename|\n\n        if ((filename =~ dir_filter) or not dir_filter)\n          item = \"#{dir}/#{filename}\"\n\n          if File.directory?(item)\n            PICK_FROM_DIR_PROC.call(\n              item, callback_proc, dir_filter\n            )\n          else\n            callback_proc.call(item)\n          end\n\n        end\n\n      end\n\n    end\n\n    def self.walk(dir, callback_proc, dir_filter=nil)\n      puts\n      PICK_FROM_DIR_PROC.call(dir, callback_proc, dir_filter)\n    end\n\n  end\n\n  dir = 'extras/soundfiles'\n  callback   = (ARGV[0] == 'play') ? play_file_proc : dont_play_file_proc\n  dir_filter = ARGV[1] ? Regexp.new(ARGV[1]) : nil\n  RadioPlayer.walk(dir, callback, dir_filter)\n  puts\n```", "```\n$ ruby -w radio_player2.rb play\n\nAudio Device:   OSS audio driver output\n\nPlaying: extras/soundfiles/01-Neal_And_Jack_And_Me.ogg\nOgg Vorbis stream: 2 channel, 44100 Hz\nTitle: Neal and Jack and Me\nArtist: King Crimson\nAlbum: Beat\nDate: 1982\nTrack number: 01\nTracktotal: 08\nGenre: Prog Rock\nComposer: Belew, Bruford, Fripp, Levin\nMusicbrainz_albumid: 5ddbe867-ebce-445d-a175-d90516e426da\nMusicbrainz_albumartistid: b38225b8-8e5f-42aa-bcdc-7bae5b5bdab3\nMusicbrainz_artistid: b38225b8-8e5f-42aa-bcdc-7bae5b5bdab3\nMusicbrainz_trackid: 30a23275-11ef-4f07-bdc8-0192ae34e67d\nDone.\nextras/soundfiles/legal/legal1\nextras/soundfiles/legal/legal2\nextras/soundfiles/promo/promo1\nextras/soundfiles/promo/promo2\n```", "```\n$ ruby -w radio_player2.rb play legal\n\nextras/soundfiles/legal/legal1\nextras/soundfiles/legal/legal2\n```", "```\n$ ruby -w radio_player2.rb dont legal\n\nI'm not playing extras/soundfiles/legal/legal1\\. So there.\nI'm not playing extras/soundfiles/legal/legal2\\. So there.\n```", "```\n  =begin rdoc\n  This is intended for use with to_lang.rb\n  =end\n\n❶ module Representable_In_English\n\n  =begin rdoc\n  Return a <b>Hash</b> whose keys are <b>Integer</b>s and whose values\n  are the words representing the same values.\n  =end\n❷   def create_english()\n      need_ones_in_english.merge(dont_need_ones_in_english)\n\n    end\n\n❸   def special_replacements_in_english(num_as_string)\n      add_hyphens_to_tens(num_as_string).strip\n    end\n\n❹   def to_english()    *Syntactic Sugar*\n      to_lang('english')\n    end\n\n❺   alias :to_en :to_english\n\n❻   private\n\n❼   def add_hyphens_to_tens(num_as_string)\n      num_as_string.sub(/ty/, 'ty-').sub(/-?- ?/, '-')\n    end\n\n❽   def need_ones_in_english()\n      return {\n        10 ** 9 => 'billion',\n        10 ** 6 => 'million',\n        10 ** 3 => 'thousand',\n        100     => 'hundred',\n      }\n    end\n\n❾   def dont_need_ones_in_english()\n      return {\n        90 => 'ninety',\n        80 => 'eighty',\n        70 => 'seventy',\n        60 => 'sixty',\n        50 => 'fifty',\n        40 => 'forty',\n        30 => 'thirty',\n        20 => 'twenty',\n        19 => 'nineteen',\n        18 => 'eighteen',\n        17 => 'seventeen',\n        16 => 'sixteen',\n        15 => 'fifteen',\n        14 => 'fourteen',\n        13 => 'thirteen',\n        12 => 'twelve',\n        11 => 'eleven',\n        10 => 'ten',\n         9 => 'nine',\n         8 => 'eight',\n         7 => 'seven',\n         6 => 'six',\n         5 => 'five',\n         4 => 'four',\n         3 => 'three',\n         2 => 'two',\n         1 => 'one',\n         0 => '',\n      }\n    end\n\n  end\n```", "```\n  =begin rdoc\n  This is intended for use with to_lang.rb\n  =end\n\n❶ module Representable_In_Spanish\n\n  =begin rdoc\n  Return a <b>Hash</b> whose keys are <b>Integer</b>s and whose values\n  are the words representing the same values.\n  =end\n❷   def create_spanish()\n      need_ones_in_spanish.merge(dont_need_ones_in_spanish)\n    end\n\n❸   def special_replacements_in_spanish(num_as_string)\n      add_hyphens_to_tens(num_as_string).strip\n    end\n\n❹   def to_spanish()    *Syntactic Sugar*\n      to_lang('spanish')\n    end\n\n❺   alias :to_es :to_spanish\n\n❻   private\n\n❼   def add_hyphens_to_tens(num_as_string)\n      num_as_string.sub(/ta/, 'ta-').sub(/-?- ?/, '-')\n    end\n\n❽   def need_ones_in_spanish()\n      return {\n        10 ** 12 => 'billon',\n        10 ** 9  => 'mil millones',\n        10 ** 6  => 'millon',\n        10 ** 3  => 'mil',\n        100      => 'ciento',\n      }\n    end\n\n❾   def dont_need_ones_in_spanish()\n      return {\n        90 => 'noventa',\n        80 => 'ochenta',\n        70 => 'setenta',\n        60 => 'sesenta',\n        50 => 'cincuenta',\n        40 => 'cuarenta',\n        30 => 'treinta',\n        20 => 'veinte',\n        19 => 'diecinueve',\n        18 => 'dieciocho',\n        17 => 'diecisiete',\n        16 => 'dieciseis',\n        15 => 'quince',\n        14 => 'catorce',\n        13 => 'trece',\n        12 => 'doce',\n        11 => 'once',\n        10 => 'deiz',\n         9 => 'nueve',\n         8 => 'ocho',\n         7 => 'siete',\n         6 => 'seis',\n         5 => 'cinco',\n         4 => 'cuatro',\n         3 => 'tres',\n         2 => 'dos',\n         1 => 'uno',\n         0 => '', # 'cero'\n       }\n     end\n\n  end\n```", "```\n  #!/usr/bin/env ruby -w\n  # to_lang.rb\n\n  =begin rdoc\n  Implement representation of numbers in human languages:\n  1 => 'one',\n  2 => 'two',\n  etc.\n\n  This is an generalized extension of ideas shown for the\n  specific case of roman numerals in roman_numeral.rb\n\n  Note that similar work has already been done at\n  http://www.deveiate.org/projects/Linguistics/wiki/English\n  This version focuses only on converting numbers to multiple\n  language targets, and pedantically considers \"and\" to be\n  the pronunciation of the decimal point.\n  =end\n\n  class Integer\n\n❶   require 'representable_in_english'    *Requiring Our Own Mixins*\n    require 'representable_in_spanish'\n\n❷   include Representable_In_English\n    include Representable_In_Spanish\n\n❸   EMPTY_STRING = ''\n    SPACE        = ' '\n\n❹   @@lang_of ||= Hash.new()\n\n❺   def need_ones?(lang)    *The **`send`** Method*\n      send(\"need_ones_in_#{lang}\").keys.include?(self)\n    end\n\n❻   def to_lang(lang)\n      return EMPTY_STRING if self.zero?\n\n      @@lang_of[lang] ||= send(\"create_#{lang}\")\n\n      base      = get_base(lang)\n      mult      = (self / base).to_i\n      remaining = (self - (mult * base))\n\n      raw_output = [\n        mult_prefix(base, mult, lang),\n        @@lang_of[lang][base],\n        remaining.to_lang(lang)\n      ].join(SPACE)\n\n      return send(\n      \"special_replacements_in_#{lang}\",\n      raw_output)\n    end\n\n❼   private\n\n❽   def get_base(lang)\n      return self if @@lang_of[lang][self]\n      @@lang_of[lang].keys.sort.reverse.detect do |k|\n        k <= self\n      end\n    end\n\n❾   def mult_prefix(base, mult, lang)\n      return mult.to_lang(lang) if mult > 1\n      return 1.to_lang(lang)    if base.need_ones?(lang)\n      return EMPTY_STRING\n    end\n\n  end\n```", "```\n@@lang_of = if (lang == 'english')\n  create_english()\nelse\n  create_spanish()\nend\n```", "```\n#!/usr/bin/env ruby\n# test_lang.rb\n\nrequire 'to_lang'\nrequire 'test/unit'\n\nclass Tester < Test::Unit::TestCase\n\n  def test_langs()\n\n    tests = {\n      'en' => {\n        1     => 'one',\n        5     => 'five',\n        9     => 'nine',\n        11    => 'eleven',\n        51    => 'fifty one',\n        100   => 'one hundred',\n        101   => 'one hundred one',\n        257   => 'two hundred fifty seven',\n        1000  => 'one thousand',\n        1001  => 'one thousand one',\n        90125 => 'ninety thousand one hundred twenty five',\n      },\n      'es' => {\n        1     => 'uno',\n        5     => 'cinco',\n        9     => 'nueve',\n        11    => 'once',\n        51    => 'cincuenta-uno',\n        100   => 'uno ciento',\n        101   => 'uno ciento uno',\n        257   => 'dos ciento cincuenta-siete',\n        1000  => 'uno mil',\n        1001  => 'uno mil uno',\n        90125 => 'noventa-mil uno ciento veinte cinco',\n      }\n    }\n    %w[ en es ].each do |lang|\n      general_tester( tests, lang )\n    end\n  end\n\n  private\n\n  def general_tester(tests, lang)\n    tests[lang].each_key do |num|\n      assert_equal( num.send(\"to_#{lang}\"), tests[lang][num] )\n    end\n  end\n\nend\n```", "```\nLoaded suite tests/test_lang\nStarted\n.\nFinished in 0.004543 seconds.\n\n1 tests, 22 assertions, 0 failures, 0 errors\n```", "```\n#!/usr/bin/env ruby    ***`Symbol.to_proc`***\nclass Symbol\n  def to_proc()\n    Proc.new { |obj, *args| obj.send(self, *args) }\n  end\nend\n```", "```\na.send(push, some_item)\na.push(some_item)\n```", "```\nirb -r symbol.rb\nirb(main):001:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):002:0> digits.inject(&:+)\n=> 45\nirb(main):003:0> digits.map(&:inspect)\n=> [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nirb(main):004:0> require 'to_lang'\n=> true\nirb(main):005:0> digits.map(&:to_en)\n=> [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n\"nine\"]\n```"]