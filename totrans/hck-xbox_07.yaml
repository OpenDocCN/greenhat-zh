- en: Chapter 7 -
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 -
- en: A Brief Primer on Security
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全简明指南
- en: Hacking the Xbox requires security hacking in addition to hardware and firmware
    hacking, as you discovered in the last chapter. We will go over some of the possible
    motivations behind adding sophisticated security to something as mundane as a
    gaming machine, and then we will dive into the basic principals and algorithms
    necessary to understand and appreciate the Xbox’s security mechanisms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客攻击Xbox需要除了硬件和固件黑客攻击之外的安全黑客攻击，正如你在上一章中发现的那样。我们将探讨在像游戏机这样平凡的事物上添加复杂安全性的可能动机，然后我们将深入了解理解和欣赏Xbox安全机制所需的基本原理和算法。
- en: '**Who Needs Security, Anyways?**'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**谁需要安全，毕竟？**'
- en: 'The video game console is a toy for most people: it’s low cost, consumer electronics.
    Why did Microsoft go through such pains to secure their system? In the game of
    security hacking, quite frequently understanding the motive of the securer is
    helpful in finding weaknesses that you can exploit.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏机对大多数人来说只是一个玩具：它成本低廉，属于消费电子产品。为什么微软要费这么大的劲来确保他们的系统安全？在安全黑客游戏中，了解安全者的动机通常有助于发现可以利用的弱点。
- en: Cryptography is not security. Cryptography is a means to an end for security,
    but real security involves the entire system architecture, including the end users.
    As Kevin Mitnick said in a recent Slashdot interview, “. . . security is not a
    product that can be purchased off the shelf, but consists of policies, people,
    processes, and technology.”¹ I believe that security is *fundamentally* a social
    concept. In practice, you can open your windows and leave the front door locked
    and people won’t just walk in through your window or pick your doorlock, even
    though both are relatively easy tasks. Locked doors and open windows work because
    a locked door is mostly a symbolic measure; it forces an intruder to make a conscious
    act of violation in order to enter a house, and that alone is enough to separate
    criminals from well-doers. Sony’s Playstation console has a good example of front-door
    lock security. The mechanism used to copy-protect their games is simple, involves
    no cryptography, and is easily overridden with easily installed, inexpensive hardware
    modifications. Despite this, sales numbers indicate that purchasing Playstation
    games has not gone out of style; the front-door lock is working.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学不是安全。密码学是实现安全的一种手段，但真正的安全涉及整个系统架构，包括最终用户。正如凯文·米特尼克在最近的Slashdot访谈中所说，“……安全不是可以现成购买的产品，而是由政策、人员、流程和技术组成的。”¹我相信安全从根本上讲是一个社会概念。在实践中，你可以打开窗户，但锁上门，人们不会仅仅通过窗户走进来或撬锁，尽管这两项任务相对简单。锁着的门和开着的窗户之所以有效，是因为锁着的门主要是一种象征性的措施；它迫使入侵者做出违反规定的自觉行为才能进入房屋，而这本身就足以将罪犯与好人区分开来。索尼的PlayStation游戏机就是一个很好的前门锁安全例子。他们用来复制保护游戏的方法很简单，不涉及密码学，而且可以通过安装便宜且容易的硬件修改来轻松绕过。尽管如此，销售数据显示购买PlayStation游戏仍然很流行；前门锁是有效的。
- en: Microsoft employs a variation of front-door lock style security. Video games
    for the Xbox are distributed using the (so far) uncopyable DVD-9 format, a single-sided,
    dual layer media format. User-writeable DVDs, on the other hand, are always in
    DVD-5 format, a single-sided, single layer media format. DVD-9 capable burners
    are not likely to be available soon due to the difficulty in making a writing
    system capable of burning one layer without affecting the integrity of the other
    layer. Thus, by distributing security data between the two layers of a DVD-9 disk
    and requiring a game executable to come from DVD-9 media, Microsoft has a fairly
    effective front-door lock on its video games. By judiciously requiring the DVD-9
    format, Microsoft has pretty much forced any potential game copier into a realm
    where some kind of hardware modification is necessary.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 微软采用了前门锁式安全的一种变体。Xbox游戏使用的是（到目前为止）不可复制的DVD-9格式，这是一种单面双层媒体格式。另一方面，用户可写的DVD总是采用DVD-5格式，这是一种单面单层媒体格式。由于制作能够在不影响另一层完整性的情况下烧录单层的写入系统很困难，因此DVD-9兼容的刻录机可能不会很快出现。因此，通过在DVD-9盘的两层之间分配安全数据，并要求游戏可执行文件来自DVD-9媒体，微软对其视频游戏实施了一种相当有效的“前门锁”。通过巧妙地要求DVD-9格式，微软几乎迫使任何潜在的盗版游戏者进入一个需要某种硬件修改的领域。
- en: Why then would Microsoft risk investing in such a complex security scheme on
    the Xbox? Is Microsoft’s main motivation really to quell piracy? It is quite possible
    that in fact the primary reason for the rest of the Xbox security system—the secure
    boot sectors, signed executables, trust relationships and encrypted/authenticated
    network protocols — lies not in antipiracy measures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，微软为什么要冒险在 Xbox 上投资如此复杂的加密方案呢？微软的主要动机真的是为了遏制盗版吗？实际上，Xbox 安全系统其余部分——安全引导扇区、签名可执行文件、信任关系和加密/认证网络协议——的主要理由可能并不在于反盗版措施。
- en: One possible motivation for all the security is to prevent the use of the Xbox
    console for any purpose other than gaming. The Xbox console is in the unique position
    of being an almost 100 percent stock PC. Unlike the Gamecube and the Playstation2,
    there is an enormous body of software that seems like it should just run on the
    Xbox, given the right BIOS programming. To make matters worse, Microsoft loses
    much more money on its console hardware than its competitors. Some estimate that
    its losses may be as high as $200 per console, assuming the most recent retail
    price of $199\. Hence, it is in Microsoft’s interest to try and ensure that it
    is not selling subsidized GNU/Linux boxes. However, even this is probably not
    Microsoft’s main goal. The Xbox’s 64 MB of main memory, lack of a keyboard or
    mouse out of the box, and a fairly slow processor by today’s standards makes it
    less appealing than, for example, the $200 Microtel PC available at Walmart as
    of late 2002\. In addition, Microsoft has deep pockets; if the Xbox gained market
    traction and outsold Sony’s Playstation2, Microsoft would only have to stomach
    a few billion dollars of upfront loss — relatively small in comparison to the
    roughly $40 billion cash-pile on which it sits. Thus, it is quite possible that
    the critical mission of Xbox security is not to prevent alternative console uses
    or to deter piracy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些安全措施的一个可能动机是为了防止将 Xbox 游戏机用于除游戏以外的任何目的。Xbox 游戏机处于一个独特的位置，它几乎是一个 100% 的库存
    PC。与 Gamecube 和 Playstation2 不同，有一大批软件似乎应该在 Xbox 上运行，只要进行适当的 BIOS 编程。更糟糕的是，与竞争对手相比，微软在游戏机硬件上的亏损要多得多。有些人估计，其亏损可能高达每台
    200 美元，假设最新的零售价为 199 美元。因此，对微软来说，确保它不是在销售补贴的 GNU/Linux 硬件盒很有兴趣。然而，这甚至可能不是微软的主要目标。Xbox
    的 64 MB 主内存、没有键盘或鼠标以及相对较慢的处理器（按照今天的标准），使得它不如 2002 年晚些时候在沃尔玛出售的 200 美元 Microtel
    PC 有吸引力。此外，微软财大气粗；如果 Xbox 在市场上取得成功，并且销量超过索尼的 Playstation2，微软只需承担数十亿美元的初期亏损——与它坐拥的大约
    400 亿美元现金储备相比，这个数字相对较小。因此，Xbox 安全性的关键任务可能不是防止替代游戏机使用或阻止盗版。
- en: Perhaps the real reason for the complex security of the Xbox is to ensure the
    success of Xbox Live, Microsoft’s on-line gaming service. Microsoft’s marketing
    hype and PR statements indicate that it is betting on the success of Xbox Live
    to drive hardware sales. Furthermore, Xbox Live is a subscription service, and
    one year from its launch users will have to pay a monthly fee. If Microsoft can
    get its subscribers hooked on Xbox Live, then all of a sudden the Xbox business
    looks quite profitable, even if a substantial amount of money is lost up-front
    on the hardware. The trick is, of course, hook Xbox users on Xbox Live. Billed
    as the “Disneyland of on-line gaming,” the goal of Xbox Live is to provide a well-executed
    and fair gaming experience. Central to the value proposition of Xbox Live that
    there are no cheaters. In order to ensure that nobody is cheating, users must
    be forced to authenticate themselves against a registry maintained by Xbox Live,
    and their game state must be kept secure and unmodifiable. In addition, game software
    must be unpatched. Even more crucial is the fact that you only need a few cheaters
    to ruin the gaming experience of an entire user base. All of a sudden, the front-door
    security protections offered by the DVD-9 format seem inadequate. The odds are
    against you if you betting the success of a business on the morality and honor
    of a user base of millions of twenty-something hardcore male gamers with a reasonable
    amount of computer savvy distributed throughout. The hardware must be trustable,
    network connections secure, and executables signed and sealed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 也许Xbox复杂安全性的真正原因是为了确保Xbox Live的成功，这是微软的在线游戏服务。微软的市场炒作和公关声明表明，它正在押注Xbox Live的成功来推动硬件销售。此外，Xbox
    Live是一项订阅服务，从其推出之日起，用户将不得不支付每月费用。如果微软能让其订阅者对Xbox Live上瘾，那么突然之间，Xbox业务看起来非常有利可图，即使在前端硬件上损失了大量资金。当然，关键是要让Xbox用户对Xbox
    Live上瘾。被誉为“在线游戏的迪士尼乐园”，Xbox Live的目标是提供执行良好且公平的游戏体验。Xbox Live的价值主张的核心是没有任何作弊者。为了确保没有人作弊，用户必须被迫通过Xbox
    Live维护的注册表进行身份验证，并且他们的游戏状态必须保持安全且不可修改。此外，游戏软件必须未经修补。更重要的是，只需要少数几个作弊者就能破坏整个用户群体的游戏体验。如果你把企业的成功赌在数百万二十多岁的硬核男性玩家身上，他们分布广泛，具有一定的计算机知识，那么你面临的几率是相当不利的。硬件必须可信，网络连接安全，可执行文件必须签名并密封。
- en: The statement that the hardware must be trustable bears repeating. Given an
    untrustable user base, the only way to establish a trust relationship with clients
    is if a seed of trust exists in every piece of hardware. Hence, Microsoft must
    include in every client a piece of tamper-proof hardware that enables some kind
    of attestation. Attestation is the ability to prove that some piece of data, such
    as a player’s identity or game state, is in fact generated by untainted software
    and hardware. The tamper-proof hardware does not have to implement the attestation
    function directly, but it must at least ensure that the system is in a trustable
    state before attestation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件必须可信这一说法值得反复强调。考虑到用户基础不可信，与客户建立信任关系的唯一途径是确保每一件硬件中都有一个信任的种子。因此，微软必须在每个客户端中包含一块防篡改的硬件，以实现某种形式的证明。证明是指能够证明某些数据，例如玩家的身份或游戏状态，实际上是由未受污染的软件和硬件生成的。防篡改的硬件不必直接实现证明功能，但它必须至少确保在证明之前系统处于可信状态。
- en: There are many ways to ensure that hardware is trustable. The brute-force method
    is to make the entire piece of hardware physically secure. Automated Teller Machines
    are prime examples of hardware that is physically secure. Sealed in thick sheet
    metal and covered with intrusion sensors, it is difficult to physically penetrate
    and modify the hardware of an ATM. Stil , hile effective, this is an impractical
    and expensive solution for a video game console. A more economical solution is
    to use a small piece of trusted tamper-proof hardware that can make “measurements”
    on the rest of the system. These sorts of measurements are typically accomplished
    through the use of a cryptographic hash function. If all of these trust measurements
    conform with the expected values, then one might be able to conclude that the
    entire system is trustable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保硬件可信任有许多方法。最简单的方法是使整个硬件物理上安全。自动取款机（ATM）是物理安全的硬件的典型例子。密封在厚金属板中，并覆盖有入侵传感器，很难物理穿透和修改ATM的硬件。然而，虽然这种方法有效，但对于游戏机来说，这是一个不切实际且昂贵的解决方案。一个更经济的方法是使用一小块可信任的防篡改硬件，可以对系统其余部分进行“测量”。这类测量通常通过使用加密哈希函数来完成。如果所有这些信任度量都与预期值相符，那么可以得出结论，整个系统是可信任的。
- en: I say might because this scheme is still vulnerable to man-in-the-middle attacks
    where a hacker sends spoofed valid data in response to a measurement query. Man-in-the-middle
    attacks refer to a general class of attacks where an adversary can freely modify
    and control the information being passed between two parties. Because of the man-in-the-middle
    weakness, it does not make sense to use an extremely sophisticated tamperproof
    module to make the system measurements. A single packaged silicon chip is probably
    good enough, as it is typically easier to intercept and spoof the measurement
    data going past on a printed circuit board than it is to penetrate the epoxy package
    of a chip and modify the chip’s circuitry.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“可能”，因为这个方案仍然容易受到中间人攻击，黑客会向测量查询发送伪造的有效数据。中间人攻击指的是一类攻击，其中攻击者可以自由修改和控制两个当事人之间传递的信息。由于中间人弱点，使用极其复杂的防篡改模块进行系统测量是没有意义的。一个封装的硅芯片可能就足够了，因为通常更容易拦截和伪造在印刷电路板上传输的测量数据，而不是穿透芯片的环氧封装并修改芯片的电路。
- en: The trust measurement system can be implemented using a measure-once approach.
    Starting with the processor cold-boot sequence, every piece of code is measured
    for trust before execution. If the processor never executes untrusted code, then
    what is there not to trust? This scheme requires a very simple tamper-proof hardware
    module — a tamper-proof ROM that stores the cold-boot code, a “seed” of trust.
    The type of cryptography used for the measurement and verification process is
    typically a combination of hashes and public-key cryptography. Public-key cryptography
    is preferred for this application because the private key required to generate
    a valid code segment is a secret kept by only the hardware vendor. Again, this
    scheme is vulnerable to many kinds of man-in-the-middle attacks, as well as pure
    cryptographic attacks and attacks on the implementation of the system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 信任度量系统可以使用一次测量方法实现。从处理器的冷启动序列开始，每一段代码在执行前都会进行信任度测量。如果处理器从未执行过不受信任的代码，那么还有什么不信任的呢？这个方案需要一个非常简单的防篡改硬件模块——一个防篡改的只读存储器（ROM），它存储着冷启动代码，作为信任的“种子”。用于测量和验证过程的加密类型通常是哈希和公钥加密的组合。在这个应用中，公钥加密更受欢迎，因为生成有效代码段所需的私钥只由硬件供应商保密保存。再次强调，这个方案容易受到许多中间人攻击，以及纯加密攻击和对系统实现的攻击。
- en: '**A Brief Primer on Cryptography**'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**密码学简明指南**'
- en: '**ci·pher** ( *n*): **1 a**: ZERO **b**: one that has no weight, worth, or
    influence : NONENTITY. **2 a**: a method of transforming text in order to conceal
    its meaning — compare to CODE ²'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**cipher** ( *n*): **1 a**: 零 **b**: 没有重量、价值或影响力的人 : 非实体。**2 a**: 转换文本以隐藏其意义的方法——与“code”²比较'
- en: Ciphers provide no security on their own. More specifically, ciphers only provide
    security if the key is secure, if the algorithm is strong, and if there are no
    back doors into the system. If someone hands you a CD-ROM encrypted with a strong
    cipher and locks you in a padded room with a supercomputer, the sun will probably
    go supernova before you can decrypt the CD-ROM. On the other hand, if you could
    observe and probe the machine as it was working to encrypt the CD-ROM, the encryption
    is moot. You could get the enciphering key by eavesdropping the keyboard. Or,
    you could dump the contents of the computer’s memory and obtain the plaintext
    without knowing the key.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 密码本身并不提供安全性。更具体地说，只有当密钥安全、算法强大且系统中没有后门时，密码才提供安全性。如果有人给你一个用强大密码加密的CD-ROM，并把你锁在一个填充的房间里，超级计算机可能在你解密CD-ROM之前就会发生超新星爆炸。另一方面，如果你能够观察并探测到机器在加密CD-ROM时的操作，那么加密就毫无意义了。你可以通过监听键盘来获取加密密钥。或者，你可以转储计算机内存的内容，从而在不了解密钥的情况下获得明文。
- en: The situation with the Xbox is similar to the latter. Ultimately, the Xbox must
    access and run the programs presented to it on valid disks. Furthermore, the Pentium
    CPU used in the Xbox cannot tell the difference between an authorized instruction
    and an unauthorized instruction. Finally, the user has full access to probe and
    modify the Xbox hardware. Thus, even if the Xbox uses strong ciphers, the security
    of keys is questionable, and there may be back doors into the system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Xbox的情况与后者类似。最终，Xbox必须访问和运行在有效磁盘上提供的程序。此外，Xbox中使用的Pentium CPU无法区分授权指令和未授权指令。最后，用户可以完全访问探测和修改Xbox硬件。因此，即使Xbox使用强大的密码，密钥的安全性也值得怀疑，系统中可能存在后门。
- en: This section will briefly describe the kinds of cryptographic algorithms used
    in the Xbox. We will focus on the practical implications and implementation issues
    of these algorithms. You will need to understand these algorithms in order to
    appreciate the available attacks on the Xbox security system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要介绍Xbox中使用的加密算法种类。我们将关注这些算法的实际影响和实现问题。为了理解Xbox安全系统中的可用攻击，您需要了解这些算法。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '![](../Images/index-123_1.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/index-123_1.png)'
- en: '**I make no pretense of addressing the theoretical aspects** **of cryptography;
    those are beyond me and beyond the** **scope of the book. Instead, I refer interested
    readers to** **Bruce Schneier’s excellent book, *Applied Cryptography*** **(John
    Wiley & Sons); most of my knowledge in cryptogra****phy comes from that book.
    Readers who are already famil****iar with cryptography should be able to skim
    or skip the** **remainder of this chapter.**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**我并不假装要讨论密码学的理论方面；那些超出了我的能力，也超出了本书的范围。相反，我将有兴趣的读者推荐到布鲁斯·施奈尔（Bruce Schneier）的优秀著作《应用密码学》（John
    Wiley & Sons）；我大部分关于密码学的知识都来自这本书。对于已经熟悉密码学的读者，应该能够快速浏览或跳过本章的剩余部分。**'
- en: '**Classes of Cryptographic Algorithms**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**密码学算法类别**'
- en: 'There are a few important classes of cryptographic algorithms used in the Xbox.
    These are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Xbox中使用了几个重要的密码学算法类别。这些包括：
- en: • Hashes
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: • 散列
- en: • Symmetric ciphers
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: • 对称加密
- en: • Public key ciphers
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: • 公钥加密
- en: '*Hashes* come in several varieties. Hashes of the cryptographic variety are
    used to summarize or “digest” a large amount of data. The summary is a number
    of fixed length, typically around 100 to 200 bits long, while the source data
    can be of almost any size. The most important property of a hash is that it is
    a one-way computation. In other words, it is easy to compute the hash, but it
    is very difficult (see the sidebar “Very Difficult Problems” to understand exactly
    what this means) to derive sequences of data whose hash digest are identical or
    to determine anything about the original data from the hash.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*散列*有多种类型。密码学散列用于总结或“摘要”大量数据。这个总结是一个固定长度的数字，通常长度在100到200位之间，而源数据几乎可以是任何大小。散列最重要的特性是它是一个单向计算。换句话说，计算散列很容易，但要推导出具有相同散列摘要的数据序列或从散列中确定有关原始数据的任何信息是非常困难的（参见侧边栏“非常困难的问题”以了解这究竟意味着什么）。'
- en: The strength of a hash against finding two sequences of data that hash to the
    same value is referred to as its *collision resistance*, and in general, a good
    n-bit hash requires about 2n/2 random data sequences to be hashed and compared
    in order to cause a collision. Since hashes are designed to be very easy to compute
    and very collision-resistant, they are often used to detect whether a bit has
    been changed in large regions of secure data. For many applications, it is sufficient
    to include just an encrypted hash of a message in lieu of expending the computational
    effort to encrypt the whole message.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数抵御找到两个哈希值相同的序列数据的强度被称为其*抗碰撞性*，一般来说，一个好的n位哈希函数需要大约2^n/2个随机数据序列进行哈希和比较，以引起碰撞。由于哈希函数被设计得非常容易计算和具有很高的抗碰撞性，因此它们常用于检测在大型安全数据区域中是否有位发生变化。对于许多应用来说，只需包含消息的加密哈希值，而不是花费计算努力加密整个消息，就足够了。
- en: '*Symmetric ciphers* are algorithms that have encryption and decryption keys
    that can be easily derived from one another. Most of the time, the encryption
    and decryption keys are the same. Symmetric ciphers use a *mixing function* to
    combine a *key schedule* with data that has been processed by some*cryptographic
    function*. This mixing may be repeated several times over a single block of data
    as in a block cipher, or it may occur once as in a stream cipher. All of the basic
    functions in a symmetric cipher are computationally simple, so symmetric ciphers
    are the preferred method for encrypting bulk data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*对称加密*是那些加密和解密密钥可以很容易地从对方推导出来的算法。大多数情况下，加密和解密密钥是相同的。对称加密使用*混合函数*将*密钥调度表*与经过某些*密码函数*处理过的数据进行组合。这种混合可能在单个数据块上重复多次，如在分组密码中，或者可能只发生一次，如在流密码中。对称加密中的所有基本函数在计算上都很简单，因此对称加密是加密大量数据的首选方法。'
- en: Typical examples of mixing functions are XORs, modular additions and modular
    multiplications. The simplest function, XOR, has the property that any number
    XOR itself is zero. The XOR operation is often denoted with a ⊕ symbol. The XOR
    operation also has all the usual properties of arithmetic (commutative, associative,
    distributive, etc.), so
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 混合函数的典型例子有异或（XOR）、模加和模乘。最简单的函数是异或，它具有任何数与自身进行异或运算结果为零的性质。异或运算通常用符号⊕表示。异或运算也具有所有通常的算术性质（交换律、结合律、分配律等），因此
- en: (A ⊕ B) ⊕ B = A ⊕ (B ⊕ B) = A ⊕ 0 = A
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: (A ⊕ B) ⊕ B = A ⊕ (B ⊕ B) = A ⊕ 0 = A
- en: Thus, if A were a message and B were a key, (A ⊕ B) would be the ciphertext,
    and the plaintext can be recovered by simply performing an XOR with B again.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果A是消息，B是密钥，(A ⊕ B)将是密文，通过再次对B进行异或运算，可以简单地恢复明文。
- en: A *key schedule* is an algorithm that takes a relatively short key and expands
    its information over a long series of bits. Key schedules are used to help diffuse
    the key data over a larger block of data so the relationship between the ciphertext
    and the key is obscured.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*密钥调度表*是一种算法，它将一个相对较短的关键字扩展到一系列较长的位上。密钥调度表用于帮助将密钥数据扩散到更大的数据块上，以掩盖密文与密钥之间的关系。'
- en: '**Very Difficult Problems**'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**非常困难的问题**'
- en: Cryptographic functions are all based on mathematical algorithms whose results
    are easy to compute given all the operands, but whose operands are very difficult
    to compute given just the result. The security of a cryptographic function is
    precisely the difficulty of computing these operands given just the results. Let
    us take a moment and explore what it means to be very difficult.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 密码函数都是基于数学算法的，给定所有操作数时，其结果容易计算，但给定仅结果时，其操作数却非常难以计算。密码函数的安全性正是给定仅结果时计算这些操作数的难度。让我们花一点时间来探讨什么是非常困难。
- en: Consider the symmetric cipher AES. It uses a 128-bit key, and so far, it is
    strong against all known analytical cryptographic attacks, such as differential
    and linear cryptanalysis. When I say it is strong against analysis X, I mean that
    it will require at least as many operations to recover the key or plaintext using
    a brute-force search as it would using analysis X. A brute-force search is when
    I take a very fast computer and try every one of the 2^(128) possible keys in
    order to recover the original data. Most cryptographic algorithms in common use
    today are strong against all known cryptanalysis techniques, so the important
    number to understand is the strength of a brute-force attack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以对称加密算法AES为例。它使用128位密钥，到目前为止，它对所有已知的分析性密码攻击都表现出强大的抵抗力，例如差分和线性密码分析。当我提到它对分析X有抵抗力时，我的意思是使用暴力搜索恢复密钥或明文至少需要与使用分析X一样多的操作。暴力搜索是指我使用一个非常快的计算机，尝试所有2^(128)可能的密钥，以恢复原始数据。今天大多数常用的加密算法都对所有已知的密码分析技术有抵抗力，所以重要的是要了解暴力破解攻击的强度。
- en: As it turns out, older algorithms such as DES, a 56-bit cipher is not a very
    difficult problem. It is fairly easy to build a machine using FPGAs (Field Programmable
    Gate Arrays) that can crack keys at an economy of about 2^(22) keys/second/dollar
    (2^(22) is about four million). Note that this number increases with time at a
    rate equivalent to Moore’s Law. Today, if you are willing to wait about a week
    for each key, you can recover them for about the price of a nice car. Let’s hope
    that banks do not use DES to encrypt their account data!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，像DES这样的旧算法，一个56位的加密算法并不是一个很难的问题。使用FPGA（现场可编程门阵列）构建一个能够以大约2^(22)密钥/秒/美元的经济效益破解密钥的机器相当容易（2^(22)大约是四百万）。请注意，这个数字随着时间的推移以与摩尔定律相当的速度增加。今天，如果你愿意等待大约一周的时间来破解每个密钥，你就可以以一辆好车的价格来恢复它们。让我们希望银行不要使用DES来加密他们的账户数据！
- en: The successor to DES, AES, is a cipher that can use 128, 192, or 56-bit keys.
    These keys are large enough to be considered impervious to brute-force attacks
    (i.e., a very difficult problem). According to the AES Q&A published by NIST (http://csrc.nist.gov/encryption/aes/aesfact.html),
    a machine powerful enough to recover one DES key per second through brute force
    (trying on average 255 keys per second) would still require 149 trillion years
    to recover a 128-bit AES key. My favorite analysis of the strength of 256-bit
    keys against brute force attacks comes from Bruce Schneier’s Applied Cryptography.
    In his book, he uses an argument based on the amount of energy required to crack
    a 256-bit key. It turns out that even with a thermodynamically ideal computer,
    it would require over 32 times the annual energy output of our sun to just count
    to 2^(192), much less do anything useful with that count. (I must stress that
    all of this assumes that the most efficient attack is brute force. Who knows,
    maybe someone will discover a weakness in the algorithm that can be used to mount
    a much more efficient attack. New analysis techniques are constantly being invented
    that slowly chips away at the strength of a cipher.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DES的继任者AES，是一种可以使用128位、192位或56位密钥的加密算法。这些密钥足够大，以至于被认为是无法通过暴力破解攻击（即一个非常困难的问题）来攻破的。根据NIST（http://csrc.nist.gov/encryption/aes/aesfact.html）发布的AES问答，一个足够强大的机器，每秒通过暴力破解恢复一个DES密钥（平均每秒尝试255个密钥），仍然需要149万亿年的时间来恢复一个128位的AES密钥。我最喜欢的关于256位密钥对抗暴力破解攻击强度的分析来自布鲁斯·施奈尔的《应用密码学》。在他的书中，他使用了一个基于破解256位密钥所需能量的论点。结果是，即使是一个热力学上理想的计算机，也需要超过我们太阳年能量的32倍才能计算出2^(192)，更不用说做任何有用的事情了。（我必须强调，所有这些都假设最有效的攻击是暴力破解。谁知道呢，也许有人会发现算法中的弱点，可以用来发起更有效的攻击。新的分析技术不断被发明，逐渐削弱了加密算法的强度。）
- en: Public key ciphers, on the other hand, are based on a wide variety of difficult
    to reverse mathematical operations, such as prime number multiplication and modular
    exponentiation. As a result, the key space for many public key ciphers is sparse,
    so more key bits are required for equivalent symmetric cipher security. As an
    example, key lengths in the RSA public-key cipher are typically several thousands
    of bits long.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，公钥加密算法基于各种难以逆转的数学运算，例如素数乘法和模幂运算。因此，许多公钥加密算法的密钥空间很稀疏，所以需要更多的密钥位才能达到与对称加密算法相当的安全性。例如，RSA公钥加密算法的密钥长度通常有几千位长。
- en: The exact correlation between the security of RSA public key lengths and symmetric
    cipher key lengths is unknown. The security of RSA is thought to be the difficulty
    of factoring the products of large prime numbers; however, there may be other
    attacks yet to be discovered on the algorithm. Even so, the effective difficulty
    of factoring the product of large primes is reduced not only by advances in computing
    technology (Moore’s Law), but also by advances in number theory, such as the invention
    and refinement of the Quadratic Sieve and the General Number Field Sieve. In August
    1999, a group of researches used the Number Field Sieve to factor a 512-bit prime
    number in 7.4 calendar months, including the time required to set up the factorizing
    run¹. In addition, new technologies such as quantum computing promise to enable
    the factorization of prime numbers in polynomial time. I wouldn’t hold your breath,
    however; there is still debate as to whether it is possible to build a quantum
    computer large enough to factor an interesting prime. As of today, RSA Security,
    Inc. recommends key lengths of 1024 bits for most corporate uses, and 2048 bits
    for “extremely valuable keys”². Bruce Schneier estimates in the second edition
    of Applied Cryptography that a 2304 bit public key length gives the equivalent
    security of a 128 bit symmetric key, and that a 1792 bit public key length corresponds
    to about a 112 bit symmetric key.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: RSA公钥长度与对称密钥长度之间的确切相关性尚不清楚。RSA的安全性被认为是大素数乘积分解的难度；然而，可能还有其他尚未发现的算法攻击。即便如此，分解大素数乘积的有效难度不仅因计算技术的进步（摩尔定律）而降低，还因数论方面的进步而降低，例如二次筛和一般数域筛法的发明和改进。1999年8月，一组研究人员使用数域筛法在7.4个月内分解了一个512位的素数，包括设置分解运行所需的时间¹。此外，新技术如量子计算有望在多项式时间内实现素数的分解。然而，我并不抱有太大希望；关于是否能够构建足够大的量子计算机来分解有趣的素数，目前仍存在争议。截至今天，RSA
    Security，Inc.建议大多数企业使用1024位的密钥长度，对于“极其宝贵的密钥”则建议2048位²。布鲁斯·施奈尔在《应用密码学》的第二版中估计，2304位的公钥长度提供了相当于128位对称密钥的安全性，而1792位的公钥长度则相当于大约112位的对称密钥。
- en: As you read about the Xbox security scheme, keep in mind these basic guidelines
    about how difficult it can be to crack these security schemes using brute-force
    methods. Time after time, messages are posted on hacking forums and bulletin boards
    asking, “why don’t we start a distributed key search effort for these keys?” Now
    you know the answer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读有关Xbox安全方案的内容时，请记住这些关于使用暴力破解法破解这些安全方案可能有多困难的基本指南。一次又一次，黑客论坛和公告板上贴出消息询问：“我们为什么不为这些密钥启动分布式密钥搜索工作？”现在你知道答案了。
- en: ¹ http://www.rsasecurity.com/rsalabs/challenges/factoring/rsa155.html
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ http://www.rsasecurity.com/rsalabs/challenges/factoring/rsa155.html
- en: ² http://www.rsasecurity.com/rsalabs/faq/3-1-5.html
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ² http://www.rsasecurity.com/rsalabs/faq/3-1-5.html
- en: A typical cryptographic function as used in a symmetric block cipher consists
    of a set of carefully designed substitutions, permutations, compressions and expansions.
    These functions serve to confuse and diffuse the plaintext. Subtle changes in
    any piece of a cryptographic function typically have a profound effect on the
    security of a cipher.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在对称分组密码中使用的典型加密函数由一组精心设计的替换、置换、压缩和扩展组成。这些函数的作用是混淆和扩散明文。加密函数任何一部分的细微变化通常都会对密码的安全性产生深远的影响。
- en: The fact that the encryption and decryption keys are closely related in a symmetric
    cipher makes them difficult to use in certain security applications. For example,
    if I wish to distribute an encrypted document to a mailing list, everyone on the
    mailing list must also effectively know my encryption key if they can read the
    document. In addition, initiating contact with a remote party is difficult, because
    at some point I have to transmit a key to them. Someone observing the transmission
    medium could steal the key and read, forge, and modify all subsequent messages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在对称密码中，加密和解密密钥密切相关，这使得它们在特定的安全应用中难以使用。例如，如果我想将加密文档分发给一个邮件列表，那么邮件列表上的每个人如果能够阅读文档，就必须有效地知道我的加密密钥。此外，与远程方建立联系也很困难，因为我在某个时候必须向他们传输密钥。有人观察传输介质可能会窃取密钥并读取、伪造和修改所有后续消息。
- en: '*Public key ciphers* are algorithms that use a different key for encryption
    and decryption. They are also referred to as asymmetric ciphers for this reason.
    The big advantage of public key ciphers is that one of the keys can be kept a
    secret. This allows data exchange with untrusted users without giving the untrusted
    user the ability to forge or read other protected content. The down side of public
    key algorithms is that they typically require more complex computations and are
    thus slower than symmetric ciphers. Public key ciphers also tend to require longer
    keys for equivalent security. As a result, if a large amount of data is to be
    exchanged, public key ciphers are often used to encrypt a key for a symmetric
    cipher that is used to encrypt the bulk of the data. This symmetric cipher key
    can be unique to each transaction and hence it is often referred to as a “session
    key.”'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*公钥密码*是使用不同密钥进行加密和解密的算法。因此，它们也被称为非对称密码。公钥密码的一个主要优点是其中一个密钥可以保密。这允许与不受信任的用户进行数据交换，而不给不受信任的用户伪造或读取其他受保护内容的能力。公钥算法的缺点是它们通常需要更复杂的计算，因此比对称密码慢。公钥密码也倾向于需要更长的密钥才能达到等效的安全性。因此，如果需要交换大量数据，通常使用公钥密码来加密用于加密大量数据的对称密码的密钥。这个对称密码密钥可以针对每次交易是唯一的，因此它通常被称为“会话密钥。”'
- en: '**SHA-1 Hash**'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SHA-1 散列**'
- en: 'SHA-1 is the Secure Hash Algorithm recommended by the Federal government in
    FIPS publication 180-1 (http://www.itl.nist.gov/fipspubs/fip180-1.htm). Devised
    by the NSA and based on Ronald L. Rivest’s MD4 message digest algorithm, SHA-1
    works on messages of any length less than 264 bits in length, and it produces
    a 160 bit output. The SHA-1 hash algorithm starts with a deterministic 160-bit
    seed state; this state is blended with a block of 512 bits of message data over
    four rounds. Each round consists of a series of non-linear functions, rotations,
    shifts and XORs. The result of a round is used to seed the next round’s computation.
    In general, 280 random messages need to be generated, hashed and “simultaneously”
    compared in order to find two messages that have the same hash value (i.e., a
    hash collision). Finding two random messages that have the same hash is known
    as the “birthday attack,” named after the probabilistic phenomenon called the
    “birthday paradox”: the probability that two people share the same birthday in
    a room of 23 people is better than 50%. On the other hand, 2160 random messages
    need to be generated, hashed and compared in order to find a message that hashes
    to the same value as a specific message. Thus, the strength of a hash function
    depends heavily upon the manner in which it is used.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1 是联邦政府在 FIPS 出版物 180-1（http://www.itl.nist.gov/fipspubs/fip180-1.htm）中推荐的安全散列算法。由
    NSA 设计，基于 Ronald L. Rivest 的 MD4 消息摘要算法，SHA-1 可以处理长度小于 264 位的任何消息，并生成 160 位的输出。SHA-1
    散列算法从确定性的 160 位种子状态开始；这个状态在四个回合中与 512 位的消息数据块混合。每一轮由一系列非线性函数、旋转、移位和异或操作组成。每一轮的结果被用来作为下一轮计算的种子。一般来说，需要生成
    280 个随机消息，进行散列和“同时”比较，以找到具有相同散列值的两个消息（即散列冲突）。找到具有相同散列值的两个随机消息被称为“生日攻击”，这个名字来源于被称为“生日悖论”的概率现象：在
    23 人的房间里，两个人共享同一生日的机会超过 50%。另一方面，需要生成 2160 个随机消息，进行散列和比较，以找到散列值与特定消息相同的消息。因此，散列函数的强度在很大程度上取决于其使用方式。
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Listing 7-1**: TEA Algorithm in ANSI C³'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7-1**：TEA 算法在 ANSI C³ 中'
- en: '**TEA**'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**TEA**'
- en: TEA, or tiny encryption algorithm, was developed by David Wheeler and Roger
    Needham at the Computer Laboratory of Cambridge University. (The developers have
    a web page for TEA at http://vader.brad.ac.uk/tea/tea.shtml; much of the material
    presented here is gleaned from that page.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: TEA，或小型加密算法，是由剑桥大学计算机实验室的 David Wheeler 和 Roger Needham 开发的。（开发者有一个关于 TEA 的网页
    http://vader.brad.ac.uk/tea/tea.shtml；这里展示的大部分材料都是从该页面上获取的。）
- en: As its name implies, TEA is a compact, fast encryption algorithm suitable for
    encrypting real-time data streams and embedded applications where processor performance
    and storage space is tight. TEA has a 128-bit key and it operates on 64-bits of
    data at a time, and each of its 32 rounds uses only shifts, XORs and additions.
    (The algorithm, given in Listing 7-1 and Figure 7-2, is optimized for implementation
    on 32-bit general-purpose processors.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，TEA是一个紧凑、快速的加密算法，适合加密实时数据流和处理器性能和存储空间紧张的应用。TEA有一个128位的密钥，它一次操作64位数据，并且它的每个32轮都只使用位移、XOR和加法。（该算法，如列表7-1和图7-2所示，是针对32位通用处理器优化的。）
- en: '![figure_7-1](../Images/figure_7-1.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7-1](../Images/figure_7-1.png)'
- en: '**Figure 7-1**: Tea cipher usage scenarios.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-1**：TEA密码的使用场景。'
- en: '![figure_7-2](../Images/figure_7-2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7-2](../Images/figure_7-2.png)'
- en: '**Figure 7-2**: Inner structure of TEA. This diagram depicts a single round
    of TEA, which is repeated 32 times for the full cipher. The key schedule is described
    in the boxes on the right for use as both a cipher and as a hashing function.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-2**：TEA的内部结构。此图描述了TEA的单轮，它被重复32次以完成整个密码。密钥调度在右侧的框中描述，用于作为密码和哈希函数。'
- en: The bantam TEA algorithm is believed to be quite secure when used to encrypt
    and decrypt data. However, TEA is not used for encryption in the Xbox; it is actually
    used as a hash function by operating the cipher in a modified Davies-Meyer mode.
    The region to be hashed is divided into 64-bit blocks. These source data blocks
    are used as half of the key input to TEA. The other half of the key input comes
    from the result of the previous TEA operation, and the first TEA operation uses
    a magic number as its input.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 人们认为，当用于加密和解密数据时，bantam TEA算法相当安全。然而，在Xbox中并没有使用TEA进行加密；实际上，它通过在修改后的Davies-Meyer模式下运行密码，作为哈希函数使用。要哈希的区域被分为64位块。这些源数据块被用作TEA密钥输入的一半。密钥输入的另一半来自前一个TEA操作的结果，第一个TEA操作使用一个魔术数字作为其输入。
- en: The result is a 64-bit hash function, as depicted in Figure 7-1\. This hash
    is weak against birthday attacks, especially given the computational efficiency
    of TEA, as only 2^(32) message pairs need to be tested on average to find a collision.
    Even though a birthday attack does not apply in the Xbox’s usage scenario, the
    Xbox runs the hash twice, each time with a different magic number seed, and concatenates
    the results to generate a single 128-bit hash value — probably in an attempt to
    foil brute-force attacks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个64位的哈希函数，如图7-1所示。这个哈希函数对生日攻击比较脆弱，尤其是在TEA的计算效率下，平均只需要测试2^(32)个消息对来找到碰撞。尽管生日攻击在Xbox的使用场景中不适用，但Xbox运行哈希两次，每次使用不同的魔术数字种子，并将结果连接起来生成一个单一的128位哈希值——这可能是为了防止暴力攻击。
- en: 'Unfortunately, TEA has a weakness in its key schedule: every TEA key has four
    related keys. In other words, for every key, you can generate three other keys
    that produce the same ciphertext result with the same input data. Related-key
    generation is as simple as complementing pairs of key bits (bits 31 and 63 is
    one pair, bits 95 and 127 are the other pair). This makes TEA unsuitable for use
    as a hash function, and this weakness is well documented in the paper “Key-schedule
    cryptanalysis of IDEA, G-DES, GOST, SAFER, and triple-DES,” by John Kelsey, Bruce
    Schneier, and David Wagner, presented many years ago at CRYPTO 1996\. This weakness
    was later leveraged by a team headed by Andy Green to break the second version
    of the Xbox security scheme.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，TEA在其密钥调度中有一个弱点：每个TEA密钥都有四个相关密钥。换句话说，对于每个密钥，你可以生成三个其他密钥，这些密钥使用相同的输入数据产生相同的密文结果。相关密钥生成就像补全密钥位的对（位31和63是一对，位95和127是另一对）。这使得TEA不适合用作哈希函数，这个弱点在John
    Kelsey、Bruce Schneier和David Wagner撰写的论文“IDEA、G-DES、GOST、SAFER和三重DES的密钥调度密码分析”中得到了很好的记录，这篇论文是在多年前的CRYPTO
    1996会议上提出的。这个弱点后来被Andy Green领导的一个团队利用，以破解Xbox安全方案的第二个版本。
- en: '**RC-4**'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**RC-4**'
- en: RC-4 (Ron’s Code or Rivest Cipher 4) is a variable key-length stream cipher
    by Ron Rivest. The heart of RC-4 is the keystream generator. It can be thought
    of as a cryptographic pseudo-random number generator (CPRNG). The output of the
    CPRNG is XOR’d one byte at a time with a plaintext stream to generate the ciphertext.
    Decryption is accomplished in a similar fashion. Loosely speaking, the generator
    is “seeded” with a value (the key) of up to 256 bytes (2048 bits) long. If the
    key is shorter than 256 bytes, it is repeated to fill out the 256 bytes before
    use as a seed; this enables variable-length keys. In the Xbox, the key is 16 bytes
    (128 bits) in length, and thus the cipher is dubbed RC-4/128.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: RC-4（罗恩的代码或Rivest密码4）是由罗恩·里韦斯特提出的一种可变密钥长度的流密码。RC-4的核心是密钥流生成器。它可以被认为是一个密码学伪随机数生成器（CPRNG）。CPRNG的输出逐字节与明文流进行XOR运算以生成密文。解密以类似的方式完成。简单来说，生成器通过一个值（密钥）进行“初始化”，该值最长可达256字节（2048位）。如果密钥短于256字节，它将被重复以填充256字节，然后作为种子使用；这允许密钥长度可变。在Xbox中，密钥长度为16字节（128位），因此该加密算法被称为RC-4/128。
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Listing 7-2**: RC-4 code in C, from original Usenet posting.⁴'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表7-2**：RC-4的C语言代码，来自原始Usenet帖子。⁴'
- en: RC-4 is thought to be a strong cipher, although there are a few known weaknesses
    in the key scheduling algorithm that can be leveraged in poorly designed cryptosystems,
    such as WEP. Scott Fluhrer, Itsik Mantin, and Adi Shamir document these weaknesses
    in a paper titled “Weaknesses in the Key Scheduling Algorithm of RC4,” presented
    at the Eighth Annual Workshop on Selected Areas in Cryptography (August 2001).
    None of these weaknesses can be applied against the Xbox’s implementation of RC-4.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: RC-4被认为是一种强大的加密算法，尽管在密钥调度算法中存在一些已知的弱点，这些弱点可以在设计不良的加密系统中被利用，例如WEP。斯科特·弗卢勒、伊齐克·曼丁和艾迪·沙米尔在题为“RC4密钥调度算法的弱点”的论文中记录了这些弱点，该论文是在2001年第八届密码学选区年度研讨会（8月）上提出的。这些弱点中没有任何一个可以应用于Xbox对RC-4的实现。
- en: There is, however, a potential problem in the way that RC-4 is used in the first
    version of the Xbox security. RC-4 is used on the Xbox to encipher a stream of
    x86 code, and no significant check is performed on the deciphered code to ensure
    the integrity of the plaintext. This means that changes in the ciphertext wil
    lead to changes in the code that the Xbox executes. The trick is to figure out
    a change in the ciphertext that leads to a meaningful code modification. Since
    RC-4 encrypts one byte at a time and x86 opcodes can be as short as a single byte,
    it requires no more than 2⁸ = 256 iterations to “brute force” an instruction into
    a single known location by mutating the ciphertext.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Xbox安全性的第一版中，RC-4的使用方式存在一个潜在问题。RC-4在Xbox上用于加密一系列x86代码，并且对解密后的代码没有进行任何显著的检查以确保明文的完整性。这意味着密文中的变化将导致Xbox执行的代码发生变化。关键是找出密文中导致代码有意义修改的变化。由于RC-4一次加密一个字节，而x86操作码可以短至一个字节，因此通过变异密文最多需要2⁸
    = 256次迭代来“暴力破解”一个指令到单个已知位置。
- en: Determing which location to brute force can be tricky, but I suspect a lot of
    information could be derived by mutating ciphertext bits and observing what happens
    to the pattern of instruction fetches, even with the caches turned on. The goal
    would be to try and identify the location of a jump opcode’s operands and to modify
    the jump destination such that the secured program jumps into an unsecured region
    of memory. The process would be similar to playing the classic board game “Battleship.”
    Keep in mind that the attack is so easy that guessing through a kilobyte of code
    only requires a maximum of 218 iterations. The guessing process could be automated
    by integrating a logic analyzer with a ROM emulator via a control script running
    on a host computer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要暴力破解的位置可能很棘手，但我怀疑通过变异密文位并观察指令提取模式的改变，即使开启缓存，也能推导出大量信息。目标将是尝试识别跳转操作码操作数的位置，并修改跳转目标，使得受保护程序跳入内存中的非受保护区域。这个过程类似于玩经典的桌面游戏“战舰”。记住，攻击如此简单，猜测一个千字节代码只需要最多218次迭代。通过在主机计算机上运行的控制脚本将逻辑分析仪与ROM仿真器集成，可以自动化猜测过程。
- en: The history behind RC-4 is actually quite interesting. RC-4 was invented in
    1987 by Ron Rivest, and was kept as a trade secret by RSA Security, Inc. until
    it was released in 1994 by an anonymous post to a cypherpunks mailing list (see
    Listing 7-2). As a result of RC-4’s virtues of simplicity and robustness, it has
    found its way into numerous applications, including WEP, SSL, SQL, and CDPD. While
    the source code for RC-4 is widely distributed and well known, the cipher is still
    the intellectual property of RSA Security. I wouldn’t recommend integrating it
    into a commercial product without first obtaining a license from RSA Security.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: RC-4背后的历史实际上非常有趣。RC-4是在1987年由Ron Rivest发明的，并被RSA Security公司作为商业机密保留，直到1994年通过一个匿名帖子发布到一个密码朋克邮件列表（见列表7-2）。由于RC-4的简单性和健壮性，它被广泛应用于多个应用中，包括WEP、SSL、SQL和CDPD。尽管RC-4的源代码广泛分发且众所周知，但该加密算法仍然是RSA
    Security的知识产权。在没有首先从RSA Security获得许可的情况下，我不建议将其集成到商业产品中。
- en: '![figure_7-3](../Images/figure_7-3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7-3](../Images/figure_7-3.png)'
- en: '**Figure 7-3**: Use of RSA with session keys.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-3**：使用会话密钥的RSA。'
- en: '![figure_7-4](../Images/figure_7-4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![figure_7-4](../Images/figure_7-4.png)'
- en: '**Figure 7-4**: RSA used to implement digital signatures.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-4**：RSA用于实现数字签名。'
- en: '**RSA**'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**RSA**'
- en: RSA is a public-key algorithm devised by Ron Rivest, Adi Shamir and Leonard
    Adleman in 1977\. In a public-key algorithm, two distinct keys are used, a public
    key and a private key. As their names imply, the private key must be kept secret,
    while the public key can be freely distributed. The math behind RSA is briefly
    described in the sidebar titled “The RSA Algorithm.” You need not understand the
    details of the math behind RSA to grasp how RSA is used in the context of the
    Xbox.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: RSA是由Ron Rivest、Adi Shamir和Leonard Adleman在1977年设计的一种公钥算法。在公钥算法中，使用两个不同的密钥，即公钥和私钥。正如它们的名称所暗示的，私钥必须保密，而公钥可以自由分发。RSA背后的数学原理在标题为“RSA算法”的侧边栏中简要描述。您不需要理解RSA背后的数学细节，就可以理解RSA在Xbox环境中的应用。
- en: Brute-force attacks are currently thought to be infeasible on RSA with keylengths
    in excess of about a thousand bits. Also note that one cannot be too cavalier
    about how RSA is integrated into a cryptosystem. There are some attacks against
    protocols that use RSA, such as tricking the private key holder into signing carefully
    crafted messages that can then be used to derive the signer’s private key.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前认为，在超过约一千位长度的密钥上对RSA进行暴力攻击是不可行的。同时请注意，对RSA如何集成到加密系统中不能过于轻率。存在一些针对使用RSA的协议的攻击，例如诱使私钥持有者签署精心设计的消息，然后可以使用这些消息推导出签名者的私钥。
- en: Encrypting a message using RSA is as simple as invoking RSA on a message. However,
    RSA encryption works on message blocks that are too short and the encryption process
    is too slow to be practical for most messages. Thus, RSA is typically used to
    encrypt a single-use random key, called a session key, for a fast symmetric cipher
    such as AES that is then used to encrypt the bulk message. This process is illustrated
    in Figure 7-3.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSA加密消息就像在消息上调用RSA一样简单。然而，RSA加密是在消息块上进行的，这些块太短，加密过程也太慢，以至于对于大多数消息来说不实用。因此，RSA通常用于加密一个单次使用的随机密钥，称为会话密钥，然后使用这个会话密钥加密大量消息。这个过程在图7-3中进行了说明。
- en: 'In addition to encryption, RSA enables digital signatures. A digital signature
    allows parties exchanging messages over an insecure medium to guarantee that messages
    are not forged and are not modified. The message does not have to be encrypted.
    A typical digital signature protocol works as follows: The sender computes a hash
    of the message to be sent. This hash is then encrypted with the sender’s private
    key and included with the message plaintext. The receiver decrypts the encrypted
    message hash using the sender’s public key, and compares this hash against a locally
    computed hash of the received message. If the decrypted hash sent with the message
    and the locally computed hash agree, then the receiver could conclude that the
    message is authentic and unaltered. This process is outlined in Figure 7-4.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加密之外，RSA还支持数字签名。数字签名允许在不安全介质上交换消息的各方保证消息没有被伪造且未被修改。消息不必被加密。一个典型的数字签名协议的工作方式如下：发送者计算要发送的消息的哈希值。然后，使用发送者的私钥加密这个哈希值，并将其与消息明文一起包含。接收者使用发送者的公钥解密加密的消息哈希，并将其与接收到的消息的本地计算的哈希值进行比较。如果与消息一起发送的解密哈希值和本地计算的哈希值一致，那么接收者可以得出结论，该消息是真实的且未被篡改。这个过程在图7-4中进行了概述。
- en: '**The RSA Algorithm**'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**RSA算法**'
- en: The RSA algorithm was patented by the Massachusetts Institute of Technology
    and exclusively licensed to RSA Data Security, Inc in 1983\. The patent on the
    RSA algorithm has since expired in September 2000\. Thus, today RSA is free to
    use in any application. Many excellent tutorials and educational examples using
    RSA can now be found on the Internet. Perform a Google search using the keywords
    “RSA algorithm” to find some of these examples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RSA算法于1983年由麻省理工学院获得专利，并独家许可给RSA数据安全公司。RSA算法的专利已于2000年9月到期。因此，今天RSA可以在任何应用中免费使用。现在互联网上可以找到许多使用RSA的出色教程和教育示例。使用关键词“RSA算法”进行谷歌搜索，以找到其中的一些示例。
- en: 'The RSA algorithm is as follows (adapted from http://world.std.com/~franl/crypto/rsa-guts.html):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RSA算法如下（改编自http://world.std.com/~franl/crypto/rsa-guts.html）：
- en: 1\. Find two large (thousands of bits long) prime numbers, “P” and “Q”.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 找到两个大（数千位长）的质数，“P”和“Q”。
- en: 2\. Choose “E” such that E > 1, E < PQ, and E is relatively prime to (P-1)(Q-1).
    E does not have to be prime, but it must be odd. **The pair of E and PQ are the
    public key.**
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 选择“E”，使得1 < E < PQ，并且E与(P-1)(Q-1)互质。E不必是质数，但它必须是奇数。**E和PQ的这对组合是公钥**。
- en: 3\. Compute “D” such that (DE - 1) is evenly divisible by (P-1)(Q-1). This can
    be accomplished by finding an integer X which causes D = (X(P-1)(Q-1) + 1)/E to
    be an integer. **D is** **the private key.**
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 计算“D”，使得(DE - 1)能被(P-1)(Q-1)整除。这可以通过找到一个整数X，使得D = (X(P-1)(Q-1) + 1)/E是一个整数来实现。**D是**
    **私钥**。
- en: 4\. Plaintext “T” is encrypted using the function
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 明文“T”使用以下函数进行加密
- en: C = (T^E) mod PQ
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: C = (T^E) mod PQ
- en: 5\. Ciphertext “C” is decrypted using the function
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 使用以下函数解密密文“C”
- en: T = (C^D) mod PQ
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: T = (C^D) mod PQ
- en: Note that T < PQ. Messages larger than PQ must be broken down into a sequence
    of smaller messages, and very short messages must be padded with carefully selected
    values to foil dictionary attacks, among other things.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意T < PQ。大于PQ的消息必须分解成一系列较小的消息，而非常短的消息必须用精心选择的值填充，以防止字典攻击等问题。
- en: If this protocol sounds complex to you, it is. There are a lot of places where
    things can go wrong. The receiver could have a false copy of the sender’s public
    key. The sender could have had his private key compromised. The hash could have
    weaknesses. Employing digital signatures in an adversarial environment requires
    attention to detail at all levels of the system design.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个协议听起来很复杂，那么它确实很复杂。有很多地方可能会出错。接收者可能拥有发送者公钥的虚假副本。发送者的私钥可能已被泄露。哈希可能存在弱点。在对抗性环境中使用数字签名需要在系统设计的所有层面上注意细节。
- en: In the Xbox, digital signatures are used to control the distribution and sale
    of programs for the console. Microsoft is effectively in control of both the sender
    and the receiver of messages. The receivers — Xbox consoles — are programmed to
    only run programs that are digitally signed by Microsoft. In an ideal world, this
    guarantees that Microsoft has the final word on who can or cannot run programs
    on the console, and hackers cannot modify games to insert viruses, Trojan horses,
    or back doors. Saved games are also sealed using encryption, and as a result,
    it is nominally impossible to hack a game and cheat by patching the executable
    or by jacking up your character stats.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xbox中，数字签名用于控制控制台程序的发行和销售。微软实际上控制着消息的发送者和接收者。接收者——Xbox控制台——被编程为只能运行由微软数字签名的程序。在理想的世界里，这保证了微软对谁可以在控制台上运行程序或不能运行程序有最终决定权，黑客无法修改游戏以插入病毒、特洛伊木马或后门。保存的游戏也使用加密进行密封，因此，名义上不可能通过修补可执行文件或提高角色统计数据来破解游戏并作弊。
- en: Clearly, a pivotal issue in hacking the Xbox console is their implementation
    of the digital signature system. The Xbox uses a SHA-1 hash with 2048-bit RSA
    keys, making the chance of a successful brute force attack very, very slim. Of
    course, the probability is zero if you never try, but the odds are stacked against
    you (see the sidebar “Very Difficult Problems”). You’ll have better luck trying
    to win the lottery. This is by no mistake; the discovery of the private key would
    make game copying trivial and developers would not have to pay royalties to Microsoft
    (legally, they may be obligated but there is no technical reason preventing them).
    Given that this key is probably worth a few billion dollars to Microsoft, it is
    quite likely that no single human knows the full key, as rubber-hose (beatings)
    and green-paper (bribery) cryptanalysis techniques tend to be quite effective
    on humans. (Do *not* discount real “brute force” as a possibility if you are trying
    to protect an extremely valuable secret!) Products such as BBN’s SignAssure™ certificate
    authority management system ensure the physical security of high-value keys and
    implement secret-sharing schemes that require multiple trusted users to activate
    the machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，破解Xbox游戏机的关键问题在于其数字签名系统的实现。Xbox使用SHA-1散列和2048位RSA密钥，这使得成功暴力破解攻击的可能性非常非常小。当然，如果你从未尝试过，概率为零，但成功的几率对你来说很小（参见侧边栏“非常困难的问题”）。你尝试赢得彩票的机会可能会更大。这绝非偶然；私钥的发现将使游戏复制变得简单，开发者不必向微软支付版税（从法律上讲，他们可能负有义务，但没有技术上的理由阻止他们）。鉴于这个密钥可能对微软价值数十亿美元，很可能没有单个人类知道完整的密钥，因为橡皮管（殴打）和绿纸（贿赂）密码分析技术对人类来说通常非常有效。（如果你试图保护极其宝贵的秘密，不要低估真正的“暴力破解”！）像BBN的SignAssure™证书管理机构这样的产品确保了高价值密钥的物理安全，并实施了需要多个可信用户激活机器的秘密共享方案。
- en: As mentioned previously, there are a few known viable attacks against RSA, but
    not all of them apply in the Xbox scenario, as they rely on groups of users or
    require chosen-ciphertext. In addition, the list of weaknesses is widely known
    and most implementations of digital signatures implement the proper countermeasures
    to protect against such attacks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，存在一些针对RSA的已知可行攻击，但并非所有这些攻击都适用于Xbox场景，因为它们依赖于用户群体或需要选择密文。此外，弱点列表是广为人知的，大多数数字签名实现都采取了适当的对策来保护免受此类攻击。
- en: '**The Rest of the Picture**'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**图片的其余部分**'
- en: An effective security system needs good key management, strong protocols, and
    in the case of the Xbox, physical security in addition to strong ciphers and hashes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的安全系统需要良好的密钥管理、强大的协议，以及对于Xbox来说，除了强大的加密和散列算法之外，还需要物理安全。
- en: Key management is perhaps one of the most difficult system implementation tasks
    that face any security architect. Ultimately, the decryption keys need to go into
    the hands of a user. The user interface must be designed so that the average user
    with minimum training does not accidentally leak key information. As ciphers become
    stronger, the easiest path of attack is increasingly through the user. Eavesdropping
    through surveillance videos, social engineering, or even analyzing the pattern
    of sounds made by the keyboard as a password is typed will probably yield more
    information per unit effort about a passphrase than cryptanalysis. Public key
    cryptography partially helps solve the problem of key distribution, but public
    key fingerprints should be compared in person to rule out the possibility of man-in-the-middle
    attacks. Public key cryptography also does not prevent someone with physical access
    to the client machine from eaves dropping on the decrypted output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥管理可能是任何安全架构师面临的最困难系统实现任务之一。最终，解密密钥需要落入用户手中。用户界面必须设计得让经过最少培训的普通用户不会意外泄露密钥信息。随着加密算法的增强，攻击的最简单途径越来越多地是通过用户。通过监控视频进行监听、社会工程学，甚至分析键盘按键时产生的声音模式作为密码，可能会在单位努力中获得关于通行证的信息，这比密码分析更有可能。公钥密码学部分解决了密钥分发的问题，但公钥指纹应该亲自比较，以排除中间人攻击的可能性。公钥密码学也不能防止有人物理访问客户端机器，从而监听解密后的输出。
- en: In addition, protocol attacks find weaknesses in the way keys and data are manipulated,
    or in the way strong ciphers are used. The WEP attack on RC-4 and Mike Bond and
    Ross Anderson’s attack on the IBM 4758 Cryptoprocessor are both examples of protocol
    attacks. The red flags for potential protocol attacks are systems that implement
    backward-compatibility measures, and systems that are implemented by engineers
    whose primary job is not crypto-security.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，协议攻击发现了在处理密钥和数据的方式，或者在强加密算法的使用方式中存在的弱点。对RC-4的WEP攻击以及Mike Bond和Ross Anderson对IBM
    4758密码处理器的攻击都是协议攻击的例子。潜在协议攻击的红旗是实施向后兼容性措施的系统和由那些主要工作不是密码安全工程师实施的系统。
- en: Finally, in a system like the Xbox where one of the goals is to establish a
    trustable client, back doors and buffer-overrun attacks are also viable attacks
    on the trust state of a machine. No widely used commercial processors embed execution
    privileges within instruction streams or data tags. Processors blindly execute
    any piece of code that it is instructed to jump to, whether or not the jump was
    induced through a transient hardware failure or through maliciously placed code.
    Periodic hashes on the machine state can be used to counter this deficiency, but
    even then the state checks can be spoofed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在像Xbox这样的系统中，其中一个目标是建立一个可信赖的客户端，后门和缓冲区溢出攻击也是对机器信任状态的有效攻击。没有广泛使用的商用处理器在指令流或数据标签中嵌入执行权限。处理器盲目地执行任何它被指示跳转的代码，无论这种跳转是通过瞬时的硬件故障还是通过恶意放置的代码引起的。机器状态的周期性散列可以用来弥补这种不足，但即便如此，状态检查也可能被欺骗。
- en: As discussed in the beginning of this chapter, establishing the trust state
    of a client also requires a piece of tamper-resistant hardware to carry the seed
    of trust. The amount of physical security must be enough to make it uneconomical
    to defeat the security once, and robust enough such that one instance of broken
    security does not enable trivial attacks on the remainder of the consoles. Some
    of the trade-offs when designing physical security as well as the decisions made
    by Microsoft to this end are discussed in the next chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所讨论的，建立客户端的信任状态还需要一个防篡改的硬件部件来携带信任的种子。物理安全必须足够，使得一次破坏安全变得不经济，并且足够强大，以至于一次安全破坏不会使对其他控制台进行简单攻击变得容易。在下一章中，将讨论设计物理安全时的权衡以及微软为此做出的决策。
- en: The moral of this chapter is that security requires a well-designed *system*.
    Although ciphers have become strong enough to make brute-force attacks moot, systems
    have grown in complexity. This complexity increases the likelihood of a viable
    protocol or back door attack, yet does little to save users from the more traditional
    eavesdropping, rubber-hose and user-error attacks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的寓意是，安全需要设计良好的**系统**。尽管加密算法已经足够强大，使得暴力攻击变得无关紧要，但系统的复杂性却在增加。这种复杂性增加了可行协议或后门攻击的可能性，但几乎没有帮助用户免受更传统的窃听、橡皮管攻击和用户错误攻击。
- en: '* * *'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ http://interviews.slashdot.org/article.pl?sid=03/02/04/2233250&mode=nocomment&tid=103&tid=123&tid=172
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ http://interviews.slashdot.org/article.pl?sid=03/02/04/2233250&mode=nocomment&tid=103&tid=123&tid=172
- en: ² Merriam-Webster OnLine Dictionary (www.webster.com).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ² Merriam-Webster 在线词典 (www.webster.com)。
- en: ³ Code is from http://vader.brad.ac.uk/tea/source.shtml#ansi
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 代码来自 http://vader.brad.ac.uk/tea/source.shtml#ansi
- en: ⁴ Code from http://www.cc.jyu.fi/~paasivir/crypt/rciv/rc4article.txt. Minor
    white-space modifications to make it all fit on one page. The swap byte function
    definition is also not included, but you can guess what it does by its name.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 代码来自 http://www.cc.jyu.fi/~paasivir/crypt/rciv/rc4article.txt。对空白进行了轻微的修改，以便全部内容都能适应一页。交换字节函数的定义也没有包含，但你可以通过其名称猜测其功能。
