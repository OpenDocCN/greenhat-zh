- en: Chapter 0x600. COUNTERMEASURES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The golden poison dart frog secretes an extremely toxic poison—one frog can
    emit enough to kill 10 adult humans. The only reason these frogs have such an
    amazingly powerful defense is that a certain species of snake kept eating them
    and developing a resistance. In response, the frogs kept evolving stronger and
    stronger poisons as a defense. One result of this co-evolution is that the frogs
    are safe against all other predators. This type of co-evolution also happens with
    hackers. Their exploit techniques have been around for years, so it's only natural
    that defensive countermeasures would develop. In response, hackers find ways to
    bypass and subvert these defenses, and then new defense techniques are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'This cycle of innovation is actually quite beneficial. Even though viruses
    and worms can cause quite a bit of trouble and costly interruptions for businesses,
    they force a response, which fixes the problem. Worms replicate by exploiting
    existing vulnerabilities in flawed software. Often these flaws are undiscovered
    for years, but relatively benign worms such as CodeRed or Sasser force these problems
    to be fixed. As with chickenpox, it''s better to suffer a minor outbreak early
    instead of years later when it can cause real damage. If it weren''t for Internet
    worms making a public spectacle of these security flaws, they might remain unpatched,
    leaving us vulnerable to an attack from someone with more malicious goals than
    just replication. In this way, worms and viruses can actually strengthen security
    in the long run. However, there are more proactive ways to strengthen security.
    Defensive countermeasures exist which try to nullify the effect of an attack,
    or prevent the attack from happening. A countermeasure is a fairly abstract concept;
    this could be a security product, a set of policies, a program, or simply just
    an attentive system administrator. These defensive countermeasures can be separated
    into two groups: those that try to detect the attack and those that try to protect
    the vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: Countermeasures That Detect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first group of countermeasures tries to detect the intrusion and respond
    in some way. The detection process could be anything from an administrator reading
    logs to a program sniffing the network. The response might include killing the
    connection or process automatically, or just the administrator scrutinizing everything
    from the machine's console.
  prefs: []
  type: TYPE_NORMAL
- en: As a system administrator, the exploits you know about aren't nearly as dangerous
    as the ones you don't. The sooner an intrusion is detected, the sooner it can
    be dealt with and the more likely it can be contained. Intrusions that aren't
    discovered for months can be cause for concern.
  prefs: []
  type: TYPE_NORMAL
- en: The way to detect an intrusion is to anticipate what the attacking hacker is
    going to do. If you know that, then you know what to look for. Countermeasures
    that detect can look for these attack patterns in log files, network packets,
    or even program memory. After an intrusion is detected, the hacker can be expunged
    from the system, any filesystem damage can be undone by restoring from backup,
    and the exploited vulnerability can be identified and patched. Detecting countermeasures
    are quite powerful in an electronic world with backup and restore capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: For the attacker, this means detection can counteract everything he does. Since
    the detection might not always be immediate, there are a few "smash and grab"
    scenarios where it doesn't matter; however, even then it's better not to leave
    tracks. Stealth is one of the hacker's most valuable assets. Exploiting a vulnerable
    program to get a root shell means you can do whatever you want on that system,
    but avoiding detection additionally means no one knows you're there. The combination
    of "God mode" and invisibility makes for a dangerous hacker. From a concealed
    position, passwords and data can be quietly sniffed from the network, programs
    can be backdoored, and further attacks can be launched on other hosts. To stay
    hidden, you simply need to anticipate the detection methods that might be used.
    If you know what they are looking for, you can avoid certain exploit patterns
    or mimic valid ones. The co-evolutionary cycle between hiding and detecting is
    fueled by thinking of the things the other side hasn't thought of.
  prefs: []
  type: TYPE_NORMAL
- en: System Daemons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have a realistic discussion of exploit countermeasures and bypass methods,
    we first need a realistic exploitation target. A remote target will be a server
    program that accepts incoming connections. In Unix, these programs are usually
    system daemons. A daemon is a program that runs in the background and detaches
    from the controlling terminal in a certain way. The term *daemon* was first coined
    by MIT hackers in the 1960s. It refers to a molecule-sorting demon from an 1867
    thought experiment by a physicist named James Maxwell. In the thought experiment,
    Maxwell's demon is a being with the supernatural ability to effortlessly perform
    difficult tasks, apparently violating the second law of thermodynamics. Similarly,
    in Linux, system daemons tirelessly perform tasks such as providing SSH service
    and keeping system logs. Daemon programs typically end with a *d* to signify they
    are daemons, such as *sshd* or *syslogd*.
  prefs: []
  type: TYPE_NORMAL
- en: With a few additions, the tinyweb.c code on [A Tinyweb Server](ch04s02.html#a_tinyweb_server
    "A Tinyweb Server") can be made into a more realistic system daemon. This new
    code uses a call to the `daemon()` function, which will spawn a new background
    process. This function is used by many system daemon processes in Linux, and its
    man page is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: System daemons run detached from a controlling terminal, so the new tinyweb
    daemon code writes to a log file. Without a controlling terminal, system daemons
    are typically controlled with signals. The new tinyweb daemon program will need
    to catch the terminate signal so it can exit cleanly when killed.
  prefs: []
  type: TYPE_NORMAL
- en: Crash Course in Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signals provide a method of interprocess communication in Unix. When a process
    receives a signal, its flow of execution is interrupted by the operating system
    to call a signal handler. Signals are identified by a number, and each one has
    a default signal handler. For example, when CTRL-C is typed in a program's controlling
    terminal, an interrupt signal is sent, which has a default signal handler that
    exits the program. This allows the program to be interrupted, even if it is stuck
    in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Custom signal handlers can be registered using the `signal()` function. In the
    example code below, several signal handlers are registered for certain signals,
    whereas the main code contains an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: signal_example.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When this program is compiled and executed, signal handlers are registered,
    and the program enters an infinite loop. Even though the program is stuck looping,
    incoming signals will interrupt execution and call the registered signal handlers.
    In the output below, signals that can be triggered from the controlling terminal
    are used. The `signal_handler()` function, when finished, returns execution back
    into the interrupted loop, whereas the `sigint_handler()` function exits the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Specific signals can be sent to a process using the `kill` command. By default,
    the `kill` command sends the terminate signal (`SIGTERM`) to a process. With the
    `-l` command-line switch, `kill` lists all the possible signals. In the output
    below, the `SIGUSR1` and `SIGUSR2` signals are sent to the signal_example program
    being executed in another terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `SIGKILL` signal is sent using `kill -9`. This signal's handler
    cannot be changed, so `kill -9` can always be used to kill processes. In the other
    terminal, the running signal_example shows the signals as they are caught and
    the process is killed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Signals themselves are pretty simple; however, interprocess communication can
    quickly become a complex web of dependencies. Fortunately, in the new tinyweb
    daemon, signals are only used for clean termination, so the implementation is
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Tinyweb Daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This newer version of the tinyweb program is a system daemon that runs in the
    background without a controlling terminal. It writes its output to a log file
    with timestamps, and it listens for the terminate (`SIGTERM`) signal so it can
    shut down cleanly when it's killed.
  prefs: []
  type: TYPE_NORMAL
- en: These additions are fairly minor, but they provide a much more realistic exploit
    target. The new portions of the code are shown in bold in the listing below.
  prefs: []
  type: TYPE_NORMAL
- en: tinywebd.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This daemon program forks into the background, writes to a log file with timestamps,
    and cleanly exits when it is killed. The log file descriptor and connection-receiving
    socket are declared as globals so they can be closed cleanly by the `handle_shutdown()`
    function. This function is set up as the callback handler for the terminate and
    interrupt signals, which allows the program to exit gracefully when it's killed
    with the `kill` command.
  prefs: []
  type: TYPE_NORMAL
- en: The output below shows the program compiled, executed, and killed. Notice that
    the log file contains timestamps as well as the shutdown message when the program
    catches the terminate signal and calls `handle_shutdown()`to exit gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This tinywebd program serves HTTP content just like the original tinyweb program,
    but it behaves as a system daemon, detaching from the controlling terminal and
    writing to a log file. Both programs are vulnerable to the same overflow exploit;
    however, the exploitation is only the beginning. Using the new tinyweb daemon
    as a more realistic exploit target, you will learn how to avoid detection after
    the intrusion.
  prefs: []
  type: TYPE_NORMAL
- en: Tools of the Trade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a realistic target in place, let's jump back over to the attacker's side
    of the fence. For this kind of attack, exploit scripts are an essential tool of
    the trade. Like a set of lock picks in the hands of a professional, exploits open
    many doors for a hacker. Through careful manipulation of the internal mechanisms,
    the security can be entirely sidestepped.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we've written exploit code in C and manually exploited
    vulnerabilities from the command line. The fine line between an exploit program
    and an exploit tool is a matter of finalization and reconfigurability. Exploit
    programs are more like guns than tools. Like a gun, an exploit program has a singular
    utility and the user interface is as simple as pulling a trigger. Both guns and
    exploit programs are finalized products that can be used by unskilled people with
    dangerous results. In contrast, exploit tools usually aren't finished products,
    nor are they meant for others to use. With an understanding of programming, it's
    only natural that a hacker would begin to write his own scripts and tools to aid
    exploitation. These personalized tools automate tedious tasks and facilitate experimentation.
    Like conventional tools, they can be used for many purposes, extending the skill
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: tinywebd Exploit Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the tinyweb daemon, we want an exploit tool that allows us to experiment
    with the vulnerabilities. As in the development of our previous exploits, GDB
    is used first to figure out the details of the vulnerability, such as offsets.
    The offset to the return address will be the same as in the original tinyweb.c
    program, but a daemon program presents added challenges. The daemon call forks
    the process, running the rest of the program in the child process, while the parent
    process exits. In the output below, a breakpoint is set after the `daemon()` call,
    but the debugger never hits it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the program is run, it just exits. In order to debug this program, GDB
    needs to be told to follow the child process, as opposed to following the parent.
    This is done by setting `follow-fork-mode` to `child`. After this change, the
    debugger will follow execution into the child process, where the breakpoint can
    be hit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It's good to know how to debug child processes, but since we need specific stack
    values, it's much cleaner and easier to attach to a running process. After killing
    any stray a.out processes, the tinyweb daemon is started back up and then attached
    to with GDB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The execution pauses while the tinyweb daemon waits for a connection. Once again,
    a connection is made to the webserver using a browser to advance the code execution
    to the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The debugger shows that the request buffer starts at `0xbffff5c0` and the stored
    return address is at `0xbffff7dc`, which means the offset is 540 bytes. The safest
    place for the shellcode is near the middle of the 500-byte request buffer. In
    the output below, an exploit buffer is created that sandwiches the shellcode between
    a NOP sled and the return address repeated 32 times. The 128 bytes of repeated
    return address keep the shellcode out of unsafe stack memory, which might be overwritten.
    There are also unsafe bytes near the beginning of the exploit buffer, which will
    be overwritten during null termination. To keep the shellcode out of this range,
    a 100-byte NOP sled is put in front of it. This leaves a safe landing zone for
    the execution pointer, with the shellcode at `0xbffff624`. The following output
    exploits the vulnerability using the loopback shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the offset to the return address is 540 bytes, 544 bytes are needed to
    overwrite the address. With the loopback shellcode at 83 bytes and the overwritten
    return address repeated 32 times, simple arithmetic shows that the NOP sled needs
    to be 333 bytes to align everything in the exploit buffer properly. netcat is
    run in listen mode with an ampersand (&) appended to the end, which sends the
    process to the background. This listens for the connection back from the shellcode
    and can be resumed later with the command `fg` (foreground). On the LiveCD, the
    at (@) symbol in the command prompt will change color if there are background
    jobs, which can also be listed with the `jobs` command. When the exploit buffer
    is piped into netcat, the `-w` option is used to tell it to time out after one
    second. Afterward, the backgrounded netcat process that received the connectback
    shell can be resumed.
  prefs: []
  type: TYPE_NORMAL
- en: All this works fine, but if a shellcode of different size is used, the NOP sled
    size must be recalculated. All these repetitive steps can be put into a single
    shell script.
  prefs: []
  type: TYPE_NORMAL
- en: The BASH shell allows for simple control structures. The `if` statement at the
    beginning of this script is just for error checking and displaying the usage message.
    Shell variables are used for the offset and overwrite return address, so they
    can be easily changed for a different target. The shellcode used for the exploit
    is passed as a command-line argument, which makes this a useful tool for trying
    out a variety of shellcodes.
  prefs: []
  type: TYPE_NORMAL
- en: xtool_tinywebd.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this script repeats the return address an additional thirty-third
    time, but it uses 128 bytes (32 `x` 4) for calculating the sled size. This puts
    an extra copy of the return address past where the offset dictates. Sometimes
    different compiler options will move the return address around a little bit, so
    this makes the exploit more reliable. The output below shows this tool being used
    to exploit the tinyweb daemon once again, but with the port-binding shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that the attacking side is armed with an exploit script, consider what happens
    when it's used. If you were the administrator of the server running the tinyweb
    daemon, what would be the first signs that you were hacked?
  prefs: []
  type: TYPE_NORMAL
- en: Log Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the two most obvious signs of intrusion is the log file. The log file
    keptby the tinyweb daemon is one of the first places to look into when troubleshooting
    a problem. Even though the attacker's exploits were successful, the log file keeps
    a painfully obvious record that something is up.
  prefs: []
  type: TYPE_NORMAL
- en: Log Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: tinywebd Log File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course in this case, after the attacker gains a root shell, he can just edit
    the log file since it's on the same system. On secure networks, however, copies
    of logs are often sent to another secure server. In extreme cases, logs are sent
    to a printer for hard copy, so there is a physical record. These types of countermeasures
    prevent tampering with the logs after successful exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Blend In with the Crowd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though the log files themselves cannot be changed, occasionally what gets
    logged can be. Log files usually contain many valid entries, whereas exploit attempts
    stick out like a sore thumb. The tinyweb daemon program can be tricked into logging
    a valid-looking entry for an exploit attempt. Look at the source code and see
    if you can figure out how to do this before continuing on. The idea is to make
    the log entry look like a valid web request, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of camouflage is very effective at large enterprises with extensive
    log files, since there are so many valid requests to hide among: It''s easier
    to blend in at a crowded mall than an empty street. But how exactly do you hide
    a big, ugly exploit buffer in the proverbial sheep''s clothing?'
  prefs: []
  type: TYPE_NORMAL
- en: There's a simple mistake in the tinyweb daemon's source code that allows the
    request buffer to be truncated early when it's used for the log file output, but
    not when copying into memory. The `recv_line()` function uses `\r\n` as the delimiter;
    however, all the other standard string functions use a null byte for the delimiter.
    These string functions are used to write to the log file, so by strategically
    using both delimiters, the data written to the log can be partially controlled.
  prefs: []
  type: TYPE_NORMAL
- en: The following exploit script puts a valid-looking request in front of the rest
    of the exploit buffer. The NOP sled is shrunk to accommodate the new data.
  prefs: []
  type: TYPE_NORMAL
- en: xtool_tinywebd_stealth.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This new exploit buffer uses the null byte delimiter to terminate the fake request
    camouflage. A null byte won't stop the `recv_line()` function, so the rest of
    the exploit buffer is copied to the stack. Since the string functions used to
    write to the log use a null byte for termination, the fake request is logged and
    the rest of the exploit is hidden. The following output shows this exploit script
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The connection used by this exploit creates the following log file entries on
    the server machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Even though the logged IP address cannot be changed using this method, the request
    itself appears valid, so it won't attract too much attention.
  prefs: []
  type: TYPE_NORMAL
- en: Overlooking the Obvious
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world scenario, the other obvious sign of intrusion is even more apparent
    than log files. However, when testing, this is something that is easily overlooked.
    If log files seem like the most obvious sign of intrusion to you, then you are
    forgetting about the loss of service. When the tinyweb daemon is exploited, the
    process is tricked into providing a remote root shell, but it no longer processes
    web requests. In a real-world scenario, this exploit would be detected almost
    immediately when someone tries to access the website.
  prefs: []
  type: TYPE_NORMAL
- en: A skilled hacker can not only crack open a program to exploit it, he can also
    put the program back together again and keep it running. The program continues
    to process requests and it seems like nothing happened.
  prefs: []
  type: TYPE_NORMAL
- en: One Step at a Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complex exploits are difficult because so many different things can go wrong,
    with no indication of the root cause. Since it can take hours just to track down
    where the error occurred, it's usually better to break a complex exploit down
    into smaller parts. The end goal is a piece of shellcode that will spawn a shell
    yet keep the tinyweb server running. The shell is interactive, which causes some
    complications, so let's deal with that later. For now, the first step should be
    figuring out how to put the tinyweb daemon back together after exploiting it.
    Let's begin by writing a piece of shellcode that does something to prove it ran
    and then puts the tinyweb daemon back together so it can process further web requests.
  prefs: []
  type: TYPE_NORMAL
- en: Since the tinyweb daemon redirects standard out to /dev/null, writing to standard
    out isn't a reliable marker for shellcode. One simple way to prove the shellcode
    ran is to create a file. This can be done by making a call to `open()`, and then
    `close()`. Of course, the `open()` call will need the appropriate flags to create
    a file. We could look through the include files to figure out what `O_CREAT` and
    all the other necessary defines actually are and do all the bitwise math for the
    arguments, but that's sort of a pain in the ass. If you recall, we've done something
    like this already—the notetaker program makes a call to `open()`which will create
    a file if it didn't exist. The strace program can be used on any program to show
    every system call it makes. In the output below, this is used to verify that the
    arguments to `open()` in C match up with the raw system calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When run through strace, the notetaker binary's suid-bit isn't used, so it doesn't
    have permission to open the data file. That doesn't matter, though; we just want
    to make sure the arguments to the `open()` system call match the arguments to
    the `open()` call in C. Since they match, we can safely use the values passed
    to the `open()` function in the notetaker binary as the arguments for the `open()`
    system call in our shellcode. The compiler has already done all the work of looking
    up the defines and mashing them together with a bitwise OR operation; we just
    need to find the call arguments in the disassembly of the notetaker binary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the arguments to a function call will be pushed to the stack in
    reverse. In this case, the compiler decided to use `mov DWORD PTR[esp+`*`offset`*],*`value_to_push_to_stack`*
    instead of `push` instructions, but the structure built on the stack is equivalent.
    The first argument is a pointer tothe name of the file in EAX, the second argument
    (`put at [esp+4]`) is `0x441`, and the third argument (`put at [esp+8]`) is `0x180`.
    This means that `O_WRONLY|O_CREAT|O_APPEND` turns out to be `0x441` and `S_IRUSR|S_IWUSR`
    is 0x180\. The following shellcode uses these values to create a file called Hacked
    in the root filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: mark.s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The shellcode opens a file to create it and then immediately closes the file.
    Finally, it calls exit to avoid an infinite loop. The output below shows this
    new shellcode being used with the exploit tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Putting Things Back Together Again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To put things back together again, we just need to repair any collateral damage
    caused by the overwrite and/or shellcode, and then jump execution back into the
    connection accepting loop in `main()`. The disassembly of `main()` in the output
    below shows that we can safely return to the addresses `0x08048f64`,`0x08048f65`,
    or `0x08048fb7` to get back into the connection accept loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: All three of these addresses basically go to the same place. Let's use `0x08048fb7`
    since this is the original return address used for the call to `handle_connection()`.
    However, there are other things we need to fix first. Look at the function prologue
    and epilogue for `handle_connection()`. These are the instructions that set up
    and remove the stack frame structures on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the function, the function prologue saves the current values
    of the EBP and EBX registers by pushing them to the stack, and sets EBP to the
    current value of ESP so it can be used as a point of reference for accessing stack
    variables. Finally, `0x644` bytes are saved on the stack for these stack variables
    by subtracting from ESP. The function epilogue at the end restores ESP by adding
    `0x644` back to it and restores the saved values of EBX and EBP by popping them
    from the stack back into the registers.
  prefs: []
  type: TYPE_NORMAL
- en: The overwrite instructions are actually found in the `recv_line()` function;
    however, they write to data in the `handle_connection()` stack frame, so the overwrite
    itself happens in `handle_connection()`. The return address that we overwrite
    is pushed to the stack when `handle_connection()` is called, so the saved values
    for EBP and EBX pushed to the stack in the function prologue will be between the
    return address and the corruptible buffer. This means that EBP and EBX will get
    mangled when the function epilogue executes. Since we don't gain control of the
    program's execution until the return instruction, all the instructions between
    the overwrite and the return instruction must be executed. First, we need to assess
    how much collateral damage is done by these extra instructions after the overwrite.
    The assembly instruction `int3` creates the byte `0xcc`, which is literally a
    debugging breakpoint. The shellcode below uses an `int3` instruction instead of
    exiting. This breakpoint will be caught by GDB, allowing us to examine the exact
    state of the program after the shellcode executes.
  prefs: []
  type: TYPE_NORMAL
- en: mark_break.s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To use this shellcode, first get GDB set up to debug the tinyweb daemon. In
    the output below, a breakpoint is set right before `handle_connection()` is called.
    The goal is to restore the mangled registers to their original state found at
    this breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the output above, a breakpoint is set right before `handle_connection()`
    is called (shown in bold). Then, in another terminal window, the exploit tool
    is used to throw the new shellcode at it. This will advance execution to the breakpoint
    in the other terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Back in the debugging terminal, the first breakpoint is encountered. Some important
    stack registers are displayed, which show the stack setup before (and after) the
    `handle_connection()` call. Then, execution continues to the `int3` instruction
    in the shellcode, which acts like a breakpoint. Then these stack registers are
    checked again to view their state at the moment the shellcode begins to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This output shows that EBX and EBP are changed at the point the shellcode begins
    execution. However, an inspection of the instructions in `main()`'s disassembly
    shows that EBX isn't actually used. The compiler probably saved this register
    to the stack due to some rule about calling convention, even though it isn't really
    used. EBP, however, is used heavily, since it's the point of reference for all
    local stack variables. Because the original saved value of EBP was overwritten
    by our exploit, the original value must be recreated. When EBP is restored to
    its original value, the shellcode should be able to do its dirty work and then
    return back into `main()` as usual. Since computers are deterministic, the assembly
    instructions will clearly explain how to do all this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A quick glance at the function prologue for `main()` shows that EBP should be
    `0x68` bytes larger than ESP. Since ESP wasn't damaged by our exploit, we can
    restore the value for EBP by adding `0x68` to ESP at the end of our shellcode.
    With EBP restored to the proper value, the program execution can be safely returned
    into the connection-accepting loop. The proper return address for the `handle_connection()`
    call is the instruction found after the call at `0x08048fb7`. The following shellcode
    uses this technique.
  prefs: []
  type: TYPE_NORMAL
- en: mark_restore.s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When assembled and used in an exploit, this shellcode will restore the tinyweb
    daemon's execution after marking the filesystem. The tinyweb daemon doesn't even
    know that something happened.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Child Laborers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the difficult part is figured out, we can use this technique to silently
    spawn a root shell. Since the shell is interactive, but we still want the process
    to handle web requests, we need to fork to a child process. The `fork()` call
    creates a child process that is an exact copy of the parent, except that it returns
    `0` in the child process and the new process ID in the parent process. We want
    our shellcode to fork and the child process to serve up the root shell, while
    the parent process restores tinywebd's execution. In the shellcode below, several
    instructions are added to the start of loopback_shell.s. First, the fork syscall
    is made, and the return value is put in the EAX register. The next few instructions
    test to see if EAX is zero. If EAX is zero, we jump to `child_process` to spawn
    the shell. Otherwise, we're in the parent process, so the shellcode restores execution
    into tinywebd.
  prefs: []
  type: TYPE_NORMAL
- en: loopback_shell_restore.s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The following listing shows this shellcode in use. Multiple jobs are used instead
    of multiple terminals, so the netcat listener is sent to the background by ending
    the command with an ampersand (&). After the shell connects back, the `fg` command
    brings the listener back to the foreground. The process is then suspended by hitting
    CTRL-Z, which returns to the BASH shell. It might be easier for you to use multiple
    terminals as you are following along, but job control is useful to know for those
    times when you don't have the luxury of multiple terminals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this shellcode, the connect-back root shell is maintained by a separate
    child process, while the parent process continues to serve web content.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Camouflage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current stealth exploit only camouflages the web request; however, the IP
    address and timestamp are still written to the log file. This type of camouflage
    will make the attacks harder to find, but they are not invisible. Having your
    IP address written to logs that could be kept for years might lead to trouble
    in the future. Since we're mucking around with the insides of the tinyweb daemon
    now, we should be able to hide our presence even better.
  prefs: []
  type: TYPE_NORMAL
- en: Spoofing the Logged IP Address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IP address written to the log file comes from the `client_addr_ptr`, which
    is passed to `handle_connection()`.
  prefs: []
  type: TYPE_NORMAL
- en: Code Segment from tinywebd.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To spoof the IP address, we just need to inject our own `sockaddr_in` structure
    and overwrite the `client_addr_ptr` with the address of the injected structure.
    The best way to generate a `sockaddr_in` structure for injection is to write a
    little C program that creates and dumps the structure. The following source code
    builds the struct using command-line arguments and then writes the struct data
    directly to file descriptor 1, which is standard output.
  prefs: []
  type: TYPE_NORMAL
- en: addr_struct.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This program can be used to inject a `sockaddr_in` structure. The output below
    shows the program being compiled and executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To integrate this into our exploit, the address structure is injected after
    the fake request but before the NOP sled. Since the fake request is 15 bytes long
    and we know the buffer starts at `0xbffff5c0`, the fake address will be injected
    at `0xbfffff5cf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Since the `client_addr_ptr` is passed as a second function argument, it will
    be on the stack two dwords after the return address. The following exploit script
    injects a fake address structure and overwrites `client_addr_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: xtool_tinywebd_spoof.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The best way to explain exactly what this exploit script does is to watch tinywebd
    from within GDB. In the output below, GDB is used to attach to the running tinywebd
    process, breakpoints are set before the overflow, and the IP portion of the log
    buffer is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then, from another terminal, the new spoofing exploit is used to advance execution
    in the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Back in the debugging terminal, the first breakpoint is hit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: At the first breakpoint, `client_addr_ptr` is shown to be at `0xbffff7e4` and
    pointing to `0xbffff810`. This is found in memory on the stack two dwords after
    the return address. The second breakpoint is after the overwrite, so the `client_addr_ptr`
    at `0xbffff7e4` is shown to be overwritten with the address of the injected `sockaddr_in`
    structure at `0xbffff5cf`. From here, we can peek at the `log_buffer` before it's
    written out to the log to verify the address injection worked.
  prefs: []
  type: TYPE_NORMAL
- en: Logless Exploitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, we want to leave no trace at all. In the setup on the LiveCD, technically
    you can just delete the log files after you get a root shell. However, let's assume
    this program is part of a secure infrastructure where the log files are mirrored
    to a secure logging server that has minimal access or maybe even a line printer.
    In these cases, deleting the log files after the fact is not an option. The `timestamp()`
    function in the tinyweb daemon tries to be secure by writing directly to an open
    file descriptor. We can't stop this function from being called, and we can't undo
    the write it does to the log file. This would be a fairly effective countermeasure;
    however, it was implemented poorly. In fact, in the previous exploit, we stumbled
    upon this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `logfd` is a global variable, it is also passed to `handle_connection()`as
    a function argument. From the discussion of functional context, you should remember
    that this creates another stack variable with the same name, `logfd`.Since this
    argument is found right after the `client_addr_ptr` on the stack, it gets partially
    overwritten by the null terminator and the extra `0x0a` byte found at the end
    of the exploit buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As long as the log file descriptor doesn't happen to be 2560 (`0x0a00` in hexadecimal),
    every time `handle_connection()` tries to write to the log it will fail. This
    effect can be quickly explored using strace. In the output below, strace is used
    with the `-p` command-line argument to attach to a running process. The `-e trace=write`
    argument tells strace to only look at write calls. Once again, the spoofing exploit
    tool is used in another terminal to connect and advance execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This output clearly shows the attempts to write to the log file failing. Normally,
    we wouldn't be able to overwrite the `logfd` variable, since the `client_addr_ptr`
    is in the way. Carelessly mangling this pointer will usually lead to a crash.
    But since we've made sure this variable points to valid memory (our injected spoofed
    address structure), we're free to overwrite the variables that lie beyond it.
    Since the tinyweb daemon redirects standard out to /dev/null, the next exploit
    script will overwrite the passed `logfd` variable with `1`, for standard output.
    This will still prevent entries from being written to the log file but in a much
    nicer way—without errors.
  prefs: []
  type: TYPE_NORMAL
- en: xtool_tinywebd_silent.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When this script is used, the exploit is totally silent and nothing is written
    to the log file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice the log file's size and access time remain the same. Using this technique,
    we can exploit tinywebd without leaving any trace in the log files. In addition,
    the write calls execute cleanly, as everything is written to /dev/null. This is
    shown by strace in the output below, when the silent exploit tool is run in another
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The Whole Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, details can be hidden in the bigger picture. A single host usually
    exists within some sort of infrastructure. Countermeasures such as intrusion detection
    systems (IDS) and intrusion prevention systems (IPS) can detect abnormal network
    traffic. Even simple log files on routers and firewalls can reveal abnormal connections
    that are indicative of an intrusion. In particular, the connection to port 31337
    used in our connect-back shellcode is a big red flag. We could change the port
    to something that looks less suspicious; however, simply having a webserver open
    outbound connections could be a red flag by itself. A highly secure infrastructure
    might even have the firewall setup with egress filters to prevent outbound connections.
    In these situations, opening a new connection is either impossible or will be
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: Socket Reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our case, there's really no need to open a new connection, since we already
    have an open socket from the web request. Since we're mucking around inside the
    tinyweb daemon, with a little debugging we can reuse the existing socket for the
    root shell. This prevents additional TCP connections from being logged and allows
    exploitation in cases where the target host cannot open outbound connections.
    Take a look at the source code from tinywebd.c shown below.
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt from tinywebd.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the `sockfd` passed to `handle_connection()` will inevitably
    be overwritten so we can overwrite `logfd`. This overwrite happens before we gain
    control of the program in the shellcode, so there's no way to recover the previous
    value of `sockfd`. Luckily, `main()` keeps another copy of the socket's file descriptor
    in `new_sockfd`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After the breakpoint is set and the program continues, the silent exploit tool
    is used from another terminal to connect and advance execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This debugging output shows that `new_sockfd` is stored at `0xbffff83c` within
    main's stack frame. Using this, we can create shellcode that uses the socket file
    descriptor stored here instead of creating a new connection.
  prefs: []
  type: TYPE_NORMAL
- en: While we could just use this address directly, there are many little things
    that can shift stack memory around. If this happens and the shellcode is using
    a hard-coded stack address, the exploit will fail. To make the shellcode more
    reliable, take a cue from how the compiler handles stack variables. If we use
    an address relative to ESP, then even if the stack shifts around a bit, the address
    of `new_sockfd` will still be correct since the offset from ESP will be the same.
    As you may remember from debugging with the `mark_break` shellcode, ESP was `0xbffff7e0`.
    Using this value for ESP, the offset is shown to be `0x5c` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The following shellcode reuses the existing socket for the root shell.
  prefs: []
  type: TYPE_NORMAL
- en: socket_reuse_restore.s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To effectively use this shellcode, we need another exploitation tool that lets
    us send the exploit buffer but keeps the socket out for further I/O. This second
    exploit script adds an additional `cat -` command to the end of the exploit buffer.
    The dash argument means standard input. Running cat on standard input is somewhat
    useless in itself, but when the command is piped into netcat, this effectively
    ties standard input and output to netcat's network socket. The script below connects
    to the target, sends the exploit buffer, and then keeps the socket open and gets
    further input from the terminal. This is done with just a few modifications (shown
    in bold) to the silent exploit tool.
  prefs: []
  type: TYPE_NORMAL
- en: xtool_tinywebd_reuse.sh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When this tool is used with the socket_reuse_restore shellcode, the root shell
    will be served up using the same socket used for the web request. The following
    output demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By reusing the existing socket, this exploit is even quieter since it doesn't
    create any additional connections. Fewer connections mean fewer abnormalities
    for any countermeasures to detect.
  prefs: []
  type: TYPE_NORMAL
- en: Payload Smuggling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aforementioned network IDS or IPS systems can do more than just track connections—they
    can also inspect the packets themselves. Usually, these systems are looking for
    patterns that would signify an attack. For example, a simple rule looking for
    packets that contain the string `/bin/sh` would catch a lot of packets containing
    shellcode. Our `/bin/sh` string is already slightly obfuscated since it's pushed
    to the stack in four-byte chunks, but a network IDS could also look for packets
    that contain the strings `/bin` and `//sh`.
  prefs: []
  type: TYPE_NORMAL
- en: These types of network IDS signatures can be fairly effective at catching script
    kiddies who are using exploits they downloaded from the Internet. However, they
    are easily bypassed with custom shellcode that hides any telltale strings.
  prefs: []
  type: TYPE_NORMAL
- en: String Encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To hide the string, we will simply add 5 to each byte in the string. Then, after
    the string has been pushed to the stack, the shellcode will subtract 5 from each
    string byte on the stack. This will build the desired string on the stack so it
    can be used in the shellcode, while keeping it hidden during transit. The output
    below shows the calculation of the encoded bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The following shellcode pushes these encoded bytes to the stack and then decodes
    them in a loop. Also, two `int3` instructions are used to put breakpoints in the
    shellcode before and after the decoding. This is an easy way to see what's going
    on with GDB.
  prefs: []
  type: TYPE_NORMAL
- en: encoded_sockreuserestore_dbg.s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The decoding loop uses the EDX register as a counter. It begins at 8 and counts
    down to 0, since 8 bytes need to be decoded. Exact stack addresses don't matter
    in this case since the important parts are all relatively addressed, so the output
    below doesn't bother attaching to an existing tinywebd process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Since the breakpoints are actually part of the shellcode, there is no need to
    set one from GDB. From another terminal, the shellcode is assembled and used with
    the socket-reusing exploit tool.
  prefs: []
  type: TYPE_NORMAL
- en: From Another Terminal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Back in the GDB window, the first `int3` instruction in the shellcode is hit.
    From here, we can verify that the string decodes properly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now that the decoding has been verified, the `int3` instructions can be removed
    from the shellcode. The following output shows the final shellcode being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How to Hide a Sled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NOP sled is another signature easy to detect by network IDSes and IPSes.
    Large blocks of `0x90` aren't that common, so if a network security mechanism
    sees something like this, it's probably an exploit. To avoid this signature, we
    can use different single-byte instructions instead of NOP. There are several one-byte
    instructions—the increment and decrement instructions for various registers—that
    are also printable ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Hex | ASCII |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| inc eax | `0x40` | @ |'
  prefs: []
  type: TYPE_TB
- en: '| inc ebx | `0x43` | C |'
  prefs: []
  type: TYPE_TB
- en: '| inc ecx | `0x41` | A |'
  prefs: []
  type: TYPE_TB
- en: '| inc ecx | `0x42` | B |'
  prefs: []
  type: TYPE_TB
- en: '| dec eax | `0x48` | H |'
  prefs: []
  type: TYPE_TB
- en: '| dec ebx | `0x4B` | K |'
  prefs: []
  type: TYPE_TB
- en: '| dec ecx | `0x49` | I |'
  prefs: []
  type: TYPE_TB
- en: '| dec edx | `0x4A` | J |'
  prefs: []
  type: TYPE_TB
- en: Since we zero out these registers before we use them, we can safely use a random
    combination of these bytes for the NOP sled. Creating a new exploit tool that
    uses random combinations of the bytes `@, C, A, B, H, K, I`, and `J` instead of
    a regular NOP sled will be left as an exercise for the reader. The easiest way
    to do this would be by writing a sled-generation program in C, which is used with
    a BASH script. This modification will hide the exploit buffer from IDSes that
    look for a NOP sled.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer Restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes a program will place certain restrictions on buffers. This type of
    data sanity-checking can prevent many vulnerabilities. Consider the following
    example program, which is used to update product descriptions in a fictitious
    database. The first argument is the product code, and the second is the updated
    description. This program doesn't actually update a database, but it does have
    an obvious vulnerability in it.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer Restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: update_info.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Despite the vulnerability, the code does make an attempt at security. The length
    of the product ID argument is restricted, and the contents of the description
    argument are limited to printable characters. In addition, the unused environment
    variables and program arguments are cleared out for security reasons. The first
    argument (`id`) is too small for shellcode, and since the rest of the stack memory
    is cleared out, there's only one place left.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This output shows a sample usage and then tries to exploit the vulnerable `strcpy()`
    call. Although the return address can be overwritten using the first argument
    (`id`), the only place we can put shellcode is in the second argument (`desc`).
    However, this buffer is checked for nonprintable bytes. The debugging output below
    confirms that this program could be exploited, if there was a way to put shellcode
    in the description argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The printable input validation is the only thing stopping exploitation. Like
    airport security, this input validation loop inspects everything coming in. And
    while it's not possible to avoid this check, there are ways to smuggle illicit
    data past the guards.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic Printable ASCII Shellcode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphic shellcode refers to any shellcode that changes itself. The encoding
    shellcode from the previous section is technically polymorphic, since it modifies
    the string it uses while it's running. The new NOP sled uses instructions that
    assemble into printable ASCII bytes. There are other instructions that fall into
    this printable range (from `0x33` to `0x7e`); however, the total set is actually
    rather small.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to write shellcode that will get past the printable character check.
    Trying to write complex shellcode with such a limited instruction set would simply
    be masochistic, so instead, the printable shellcode will use simple methods to
    build more complex shellcode on the stack. In this way, the printable shellcode
    will actually be instructions to make the real shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is figuring out a way to zero out registers. Unfortunately, the
    XOR instruction on the various registers doesn't assemble into the printable ASCII
    character range. One option is to use the AND bitwise operation, which assembles
    into the percent character (%) when using the EAX register. The assembly instruction
    of `and eax, 0x41414141` will assemble to the printable machine code of `%AAAA`,
    since `0x41` in hexadecimal is the printable character *A*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An AND operation transforms bits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Since the only case where the result is 1 is when both bits are 1, if two inverse
    values are ANDed onto EAX, EAX will become zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Thus, by using two printable 32-bit values that are bitwise inverses of each
    other, the EAX register can be zeroed without using any null bytes, and the resulting
    assembled machine code will be printable text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: So `%JONE%501:` in machine code will zero out the EAX register. Interesting.
    Some other instructions that assemble into printable ASCII characters are shown
    in the box below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Amazingly, these instructions, combined with the `AND eax` instruction, are
    sufficient to build loader code that will inject the shellcode onto the stack
    and then execute it. The general technique is, first, to set ESP back behind the
    executing loader code (in higher memory addresses), and then to build the shellcode
    from end to start by pushing values onto the stack, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Since the stack grows up (from higher memory addresses to lower memory addresses),
    the ESP will move backward as values are pushed to the stack, and the EIP will
    move forward as the loader code executes. Eventually, EIP and ESP will meet up,
    and the EIP will continue executing into the freshly built shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254398.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x600-1.
  prefs: []
  type: TYPE_NORMAL
- en: First, ESP must be set behind the printable loader shellcode. A little debugging
    with GDB shows that after gaining control of program execution, ESP is 555 bytes
    before the start of the overflow buffer (which will contain the loader code).
    The ESP register must be moved so it's after the loader code, while still leaving
    room for the new shellcode and for the loader shellcode itself. About 300 bytes
    should be enough room for this, so let's add 860 bytes to ESP to put it 305 bytes
    past the start of the loader code. This value doesn't need to be exact, since
    provisions will be made later to allow for some slop. Since the only usable instruction
    is subtraction, addition can be simulated by subtracting so much from the register
    that it wraps around. The register only has 32 bits of space, so adding 860 to
    a register is the same as subtracting 860 from 2^(32), or 4,294,966,436\. However,
    this subtraction must only use printable values, so we split it up across three
    instructions that all use printable operands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As the GDB output confirms, subtracting these three values from a 32-bit number
    is the same as adding 860 to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The goal is to subtract these values from ESP, not EAX, but the instruction
    `sub esp` doesn't assemble into a printable ASCII character. So the current value
    of ESP must be moved into EAX for the subtraction, and then the new value of EAX
    must be moved back into ESP.
  prefs: []
  type: TYPE_NORMAL
- en: However, since neither `mov esp, eax` nor `mov eax, esp` assemble into printable
    ASCII characters, this exchange must be done using the stack. By pushing the value
    from the source register to the stack and then popping it off into the destination
    register, the equivalent of a `mov` *`dest, source`* instruction can be accomplished
    with `push` *`source`* and `pop` *`dest`*. Fortunately, the `pop` and `push` instructions
    for both EAX and ESP registers assemble into printable ASCII characters, so this
    can all be done using printable ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the final set of instructions to add 860 to ESP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This means that `TX-3399-Purr-!TTT-P\` will add 860 to ESP in machine code.
    So far, so good. Now the shellcode must be built.
  prefs: []
  type: TYPE_NORMAL
- en: First, EAX must be zeroed out; this is easy now that a method has been discovered.
    Then, by using more `sub` instructions, the EAX register must be set to the last
    four bytes of the shellcode, in reverse order. Since the stack normally grows
    upward (toward lower memory addresses) and builds with a FILO ordering, the first
    value pushed to the stack must be the last four bytes of the shellcode. These
    bytes must be in reverse order, due to the little-endian byte ordering. The following
    output shows a hexadecimal dump of the standard shellcode used in the previous
    chapters, which will be built by the printable loader code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the last four bytes are shown in bold; the proper value for the
    EAX register is `0x80cde189`. This is easy to do by using `sub` instructions to
    wrap the value around. Then, EAX can be pushed to the stack. This moves ESP up
    (toward lower memory addresses) to the end of the newly pushed value, ready for
    the next four bytes of shellcode (shown in italic in the preceding shellcode).
    More `sub` instructions are used to wrap EAX around to `0x53e28951,` and this
    value is then pushed to the stack. As this process is repeated for each four-byte
    chunk, the shellcode is built from end to start, toward the executing loader code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Eventually, the beginning of the shellcode is reached, but there are only three
    bytes (shown in italic in the preceding shellcode) left after pushing `0x99c931db`
    to the stack. This situation is alleviated by inserting one singlebyte NOP instruction
    at the beginning of the code, resulting in the value `0x31c03190` being pushed
    to the stack—`0x90` is machine code for NOP.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these four-byte chunks of the original shellcode is generated with the
    printable subtraction method used earlier. The following source code is a program
    to help calculate the necessary printable values.
  prefs: []
  type: TYPE_NORMAL
- en: printable_helper.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When this program is run, it expects two arguments—the start and the end values
    for EAX. For the printable loader shellcode, EAX is zeroed out to start with,
    and the end value should be `0x80cde189`. This value corresponds to the last four
    bytes from shellcode.bin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The output above shows the printable values needed to wrap the zeroed EAX register
    around to `0x80cde189` (shown in bold). Next, EAX should be wrapped around again
    to `0x53e28951` for the next four bytes of the shellcode (building backwards).
    This process is repeated until all the shellcode is built. The code for the entire
    process is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: printable.s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: At the end, the shellcode has been built somewhere after the loader code, most
    likely leaving a gap between the newly built shellcode and the executing loader
    code. This gap can be bridged by building a NOP sled between the loader code and
    the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, `sub` instructions are used to set EAX to `0x90909090`, and EAX
    is repeatedly pushed to the stack. With each `push` instruction, four NOP instructions
    are tacked onto the beginning of the shellcode. Eventually, these NOP instructions
    will build right over the executing `push` instructions of the loader code, allowing
    the EIP and program execution to flow over the sled into the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: This assembles into a printable ASCII string, which doubles as executable machine
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This printable ASCII shellcode can now be used to smuggle the actual shellcode
    past the input-validation routine of the update_info program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Neat. In case you weren't able to follow everything that just happened there,
    the output below watches the execution of the printable shellcode in GDB. The
    stack addresses will be slightly different, changing the return addresses, but
    this won't affect the printable shellcode—it calculates its location based on
    ESP, giving it this versatility.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The first nine instructions add 860 to ESP and zero out the EAX register The
    next eight instructions push the last eight bytes of the shellcode to the stack
    in four-byte chunks. This process is repeated in the next 32 instructions to build
    the entire shellcode on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Now with the shellcode completely constructed on the stack, EAX is set to `0x90909090`.
    This is pushed to the stack repeatedly to build a NOP sled to bridge the gap between
    the end of the loader code and the newly constructed shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now the execution pointer (EIP) can flow over the NOP bridge into the constructed
    shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Printable shellcode is a technique that can open some doors. It and all the
    other techniques we discussed are just building blocks that can be used in a myriad
    of different combinations. Their application requires some ingenuity on your part.
    Be clever and beat them at their own game.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening Countermeasures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exploit techniques demonstrated in this chapter have been around for ages.
    It was only a matter of time for programmers to come up with some clever protection
    methods. An exploit can be generalized as a three-step process: First, some sort
    of memory corruption; then, a change in control flow; and finally, execution of
    the shellcode.'
  prefs: []
  type: TYPE_NORMAL
- en: Nonexecutable Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications never need to execute anything on the stack, so an obvious
    defense against buffer overflow exploits is to make the stack nonexecutable. When
    this is done, shellcode inserted anywhere on the stack is basically useless. This
    type of defense will stop the majority of exploits out there, and it is becoming
    more popular. The latest version of OpenBSD has a nonexecutable stack by default,
    and a nonexecutable stack is available in Linux through PaX, a kernel patch.
  prefs: []
  type: TYPE_NORMAL
- en: ret2libc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, there exists a technique used to bypass this protective countermeasure.
    This technique is known as *returning into libc*. libc is a standard C library
    that contains various basic functions, such as `printf()` and `exit()`. These
    functions are shared, so any program that uses the `printf()` function directs
    execution into the appropriate location in libc. An exploit can do the exact same
    thing and direct a program's execution into a certain function in libc. The functionality
    of such an exploit is limited by the functions in libc, which is a significant
    restriction when compared to arbitrary shellcode. However, nothing is ever executed
    on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Returning into system()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest libc functions to return into is `system()`. As you recall,
    this function takes a single argument and executes that argument with /bin/sh.
    This function only needs a single argument, which makes it a useful target. For
    this example, a simple vulnerable program will be used.
  prefs: []
  type: TYPE_NORMAL
- en: vuln.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this program must be compiled and setuid root before it's truly vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The general idea is to force the vulnerable program to spawn a shell, without
    executing anything on the stack, by returning into the libc function `system()`.
    If this function is supplied with the argument of `/bin/sh`, this should spawn
    a shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the location of the `system()` function in libc must be determined.
    This will be different for every system, but once the location is known, it will
    remain the same until libc is recompiled. One of the easiest ways to find the
    location of a libc function is to create a simple dummy program and debug it,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Here, a dummy program is created that uses the `system()` function. After it's
    compiled, the binary is opened in a debugger and a breakpoint is set at the beginning.
    The program is executed, and then the location of the `system()` function is displayed.
    In this case, the `system()` function is located at `0xb7ed0d80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with that knowledge, we can direct program execution into the `system()`
    function of libc. However, the goal here is to cause the vulnerable program to
    execute `system("/bin/sh")` to provide a shell, so an argument must be supplied.
    When returning into libc, the return address and function arguments are read off
    the stack in what should be a familiar format: the return address followed by
    the arguments. On the stack, the return-into-libc call should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254392.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 0x600-2.
  prefs: []
  type: TYPE_NORMAL
- en: Directly after the address of the desired libc function is the address to which
    execution should return after the libc call. After that, all of the function arguments
    come in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it doesn't really matter where the execution returns to after
    the libc call, since it will be opening an interactive shell. Therefore, these
    four bytes can just be a placeholder value of `FAKE`. There is only one argument,
    which should be a pointer to the string `/bin/sh`. This string can be stored anywhere
    in memory; an environment variable is an excellent candidate. In the output below,
    the string is prefixed with several spaces. This will act similarly to a NOP sled,
    providing us with some wiggle room, since `system(" /bin/sh")` is the same as
    `system(" /bin/sh")`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: So the `system()` address is `0xb7ed0d80`, and the address for the `/bin/sh`
    string will be `0xbffffe5b` when the program is executed. That means the return
    address on the stack should be overwritten with a series of addresses, beginning
    with `0xb7ecfd80`, followed by `FAKE` (since it doesn't matter where execution
    goes after the `system()` call), and concluding with `0xbffffe5b`.
  prefs: []
  type: TYPE_NORMAL
- en: A quick binary search shows that the return address is probably overwritten
    by the eighth word of the program input, so seven words of dummy data are used
    for spacing in the exploit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The exploit can be expanded upon by making chained libc calls, if needed. The
    return address of `FAKE` used in the example can be changed to direct program
    execution. Additional libc calls can be made, or execution can be directed into
    some other useful section in the program's existing instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Randomized Stack Space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another protective countermeasure tries a slightly different approach. Instead
    of preventing execution on the stack, this countermeasure randomizes the stack
    memory layout. When the memory layout is randomized, the attacker won't be able
    to return execution into waiting shellcode, since he won't know where it is.
  prefs: []
  type: TYPE_NORMAL
- en: This countermeasure has been enabled by default in the Linux kernel since 2.6.12,
    but this book's LiveCD has been configured with it turned off. To turn this protection
    on again, echo `1` to the /proc filesystem as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: With this countermeasure turned on, the notesearch exploit no longer works,
    since the layout of the stack is randomized. Every time a program starts, the
    stack begins at a random location. The following example demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: Randomized Stack Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: aslr_demo.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This program has an obvious buffer overflow vulnerability in it. However with
    ASLR turned on, exploitation isn't that easy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the location of the buffer on the stack changes with every run. We
    can still inject the shellcode and corrupt memory to overwrite the return address,
    but we don't know where the shellcode is in memory. The randomization changes
    the location of everything on the stack, including environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This type of protection can be very effective in stopping exploits by the average
    attacker, but it isn't always enough to stop a determined hacker. Can you think
    of a way to successfully exploit this program under these conditions?
  prefs: []
  type: TYPE_NORMAL
- en: Investigations with BASH and GDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since ASLR doesn't stop the memory corruption, we can still use a bruteforcing
    BASH script to figure out the offset to the return address from the beginning
    of the buffer. When a program exits, the value returned from the main function
    is the exit status. This status is stored in the BASH variable $?, which can be
    used to detect whether the program crashed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Using BASH's `if` statement logic, we can stop our brute-forcing script when
    it crashes the target. The `if` statement block is contained between the keywords
    `then` and `fi`; the white space in the `if` statement is required. The `break`
    statement tells the script to break out of the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Knowing the proper offset will let us overwrite the return address. However,
    we still cannot execute shellcode since its location is randomized. Using GDB,
    let's look at the program just as it's about to return from the main function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The breakpoint is set at the last instruction of `main`. This instruction returns
    EIP to the return address stored on the stack. When an exploit overwrites the
    return address, this is the last instruction where the original program has control.
    Let's take a look at the registers at this point in the code for a couple of different
    trial runs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Despite the randomization between runs, notice how similar the address in ESP
    is to the address of the buffer (shown in bold). This makes sense, since the stack
    pointer points to the stack and the buffer is on the stack. ESP's value and the
    buffer's address are changed by the same random value, because they are relative
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: GDB's `stepi` command steps the program forward in execution by a single instruction.
    Using this, we can check ESP's value after the `ret` instruction has executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Single stepping shows that the `ret` instruction increases the value of ESP
    by 4\. Subtracting the value of ESP from the address of the buffer, we find that
    ESP is pointing 80 bytes (or 20 words) from the start of the buffer. Since the
    return address's offset was 19 words, this means that after `main`'s final `ret`
    instruction, ESP points to stack memory found directly after the return address.
    This would be useful if there was a way to control EIP to go where ESP is pointing
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Bouncing Off linux-gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique described below doesn't work with Linux kernels starting from
    2.6.18\. This technique gained some popularity and, of course, the developers
    patched the problem. The kernel used in the included LiveCD is 2.6.20, so the
    output below is from the machine loki, which is running a 2.6.17 Linux kernel.
    Even though this particular technique doesn't work on the LiveCD, the concepts
    behind it can be applied in other useful ways.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bouncing off linux-gate* refers to a shared object, exposed by the kernel,
    which looks like a shared library. The program ldd shows a program''s shared library
    dependencies. Do you notice anything interesting about the linux-gate library
    in the output below?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Even in different programs and with ASLR enabled, linux-gate.so.1 is always
    present at the same address. This is a virtual dynamically shared object used
    by the kernel to speed up system calls, which means it's needed in every process.
    It is loaded straight from the kernel and doesn't exist anywhere on disk.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is that every process has a block of memory containing linux-gate's
    instructions, which are always at the same location, even with ASLR. We are going
    to search this memory space for a certain assembly instruction, `jmp esp`. This
    instruction will jump EIP to where ESP is pointing.
  prefs: []
  type: TYPE_NORMAL
- en: First, we assemble the instruction to see what it looks like in machine code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Using this information, a simple program can be written to find this pattern
    in the program's own memory.
  prefs: []
  type: TYPE_NORMAL
- en: find_jmpesp.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program is compiled and run, it shows that this instruction exists
    at `0xffffe777`. This can be further verified using GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together, if we overwrite the return address with the address
    `0xffffe777`, then execution will jump into linux-gate when the main function
    returns. Since this is a `jmp esp` instruction, execution will immediately jump
    back out of linux-gate to wherever ESP happens to be pointing. From our previous
    debugging, we know that at the end of the main function, ESP is pointing to memory
    directly after the return address. So if shellcode is put here, EIP should bounce
    right into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This technique can also be used to exploit the notesearch program, as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The initial estimate of 35 words was off, since the program still crashed with
    the slightly smaller exploit buffer. But it is in the right ballpark, so a manual
    tweak (or a more accurate way to calculate the offset) is all that is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, bouncing off linux-gate is a slick trick, but it only works with older
    Linux kernels. Back on the LiveCD, running Linux 2.6.20, the useful instruction
    is no longer found in the usual address space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Without the `jmp esp` instruction at a predictable address, there is no easy
    way to bounce off of linux-gate. Can you think of a way to bypass ASLR to exploit
    aslr_demo on the LiveCD?
  prefs: []
  type: TYPE_NORMAL
- en: Applied Knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Situations like this are what makes hacking an art. The state of computer security
    is a constantly changing landscape, and specific vulnerabilities are discovered
    and patched every day. However, if you understand the concepts of the core hacking
    techniques explained in this book, you can apply them in new and inventive ways
    to solve the problem du jour. Like LEGO bricks, these techniques can be used in
    millions of different combinations and configurations. As with any art, the more
    you practice these techniques, the better you'll understand them. With this understanding
    comes the wisdom to guesstimate offsets and recognize memory segments by their
    address ranges.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the problem is still ASLR. Hopefully, you have a few bypass ideas
    you might want to try out now. Don't be afraid to use the debugger to examine
    what is actually happening. There are probably several ways to bypass ASLR, and
    you may invent a new technique. If you don't find a solution, don't worry—I'll
    explain a method in the next section. But it's worthwhile to think about this
    problem a little on your own before reading ahead.
  prefs: []
  type: TYPE_NORMAL
- en: A First Attempt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In fact, I had written this chapter before linux-gate was fixed in the Linux
    kernel, so I had to hack together an ASLR bypass. My first thought was to leverage
    the `execl()` family of functions. We've been using the `execve()`function in
    our shellcode to spawn a shell, and if you pay close attention (or just read the
    man page), you'll notice the `execve()` function replaces the currently running
    process with the new process image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: It seems like there could be a weakness here if the memory layout is randomized
    only when the process is started. Let's test this hypothesis with a piece of code
    that prints the address of a stack variable and then executes aslr_demo using
    an `execl()` function.
  prefs: []
  type: TYPE_NORMAL
- en: aslr_execl.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: When this program is compiled and executed, it will `execl()` aslr_demo, which
    also prints the address of a stack variable (buffer). This lets us compare the
    memory layouts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The first result looks very promising, but further attempts show that there
    is some degree of randomization happening when the new process is executed with
    `execl()`. I'm sure this wasn't always the case, but the progress of open source
    is rather constant. This isn't much of a problem though, since we have ways to
    deal with that partial uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the Odds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `execl()` at least limits the randomness and gives us a ballpark address
    range. The remaining uncertainty can be handled with a NOP sled. A quick examination
    of aslr_demo shows that the overflow buffer needs to be 80 bytes to overwrite
    the stored return address on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Since we will probably want a rather large NOP sled, in the following exploit
    the NOP sled and the shellcode will be put after the return address overwrite.
    This allows us to inject as much of a NOP sled as needed. In this case, a thousand
    bytes or so should be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: aslr_execl_exploit.c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This code should make sense to you. The value `200` is added to the return address
    to skip over the first 90 bytes used for the overwrite, so execution lands somewhere
    in the NOP sled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, occasionally the randomization causes the exploit to fail, but
    it only needs to succeed once. This leverages the fact that we can try the exploit
    as many times as we want. The same technique will work with the notesearch exploit
    while ASLR is running. Try writing an exploit to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Once the basic concepts of exploiting programs are understood, countless variations
    are possible with a little bit of creativity. Since the rules of a program are
    defined by its creators, exploiting a supposedly secure program is simply a matter
    of beating them at their own game. New clever methods, such as stack guards and
    IDSs, try to compensate for these problems, but these solutions aren't perfect
    either. A hacker's ingenuity tends to find holes in these systems. Just think
    of the things they didn't think of.
  prefs: []
  type: TYPE_NORMAL
