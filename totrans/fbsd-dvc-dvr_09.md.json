["```\n#include <sys/param.h>\n#include <sys/module.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/malloc.h>\n#include <sys/syslog.h>\n\n#include <machine/bus.h>\n#include <sys/rman.h>\n#include <machine/resource.h>\n\n#include <dev/ppbus/ppbconf.h>\n#include \"ppbus_if.h\"\n#include <dev/ppbus/ppbio.h>\n#include <dev/ppbus/ppb_1284.h>\n\n#include <dev/ppbus/lpt.h>\n#include <dev/ppbus/lptio.h>\n\n#define LPT_NAME        \"lpt\"           /* official driver name.        */\n#define LPT_INIT_READY  4               /* wait up to 4 seconds.        */\n#define LPT_PRI         (PZERO + 8)     /* priority.                    */\n#define BUF_SIZE        1024            /* sc_buf size.                 */\n#define BUF_STAT_SIZE   32              /* sc_buf_stat size.            */\n\nstruct lpt_data {\n        short                   sc_state;\n        char                    sc_primed;\n        struct callout          sc_callout;\n        u_char                  sc_ticks;\n        int                     sc_irq_rid;\n        struct resource        *sc_irq_resource;\n        void                   *sc_irq_cookie;\n        u_short                 sc_irq_status;\n        void                   *sc_buf;\n        void                   *sc_buf_stat;\n        char                   *sc_cp;\n        device_t                sc_dev;\n        struct cdev            *sc_cdev;\n        struct cdev            *sc_cdev_bypass;\n        char                    sc_flags;\n        u_char                  sc_control;\n        short                   sc_transfer_count;\n};\n\n/* bits for sc_state. */\n#define LP_OPEN         (1 << 0)        /* device is open.              */\n#define LP_ERROR        (1 << 2)        /* error received from printer. */\n#define LP_BUSY         (1 << 3)        /* printer is busy writing.     */\n#define LP_TIMEOUT      (1 << 5)        /* timeout enabled.             */\n#define LP_INIT         (1 << 6)        /* initializing in lpt_open.    */\n#define LP_INTERRUPTED  (1 << 7)        /* write call was interrupted.  */\n#define LP_HAVEBUS      (1 << 8)        /* driver owns the bus.         */\n\n/* bits for sc_ticks. */\n#define LP_TOUT_INIT    10              /* initial timeout: 1/10 sec.   */\n#define LP_TOUT_MAX     1               /* max timeout: 1/1 sec.        */\n\n/* bits for sc_irq_status. */\n#define LP_HAS_IRQ      0x01            /* we have an IRQ available.    */\n#define LP_USE_IRQ      0x02            /* our IRQ is in use.           */\n#define LP_ENABLE_IRQ   0x04            /* enable our IRQ on open.      */\n#define LP_ENABLE_EXT   0x10            /* enable extended mode.        */\n\n/* bits for sc_flags. */\n#define LP_NO_PRIME     0x10            /* don't prime the printer.     */\n#define LP_PRIME_OPEN   0x20            /* prime on every open.         */\n#define LP_AUTO_LF      0x40            /* automatic line feed.         */\n#define LP_BYPASS       0x80            /* bypass printer ready checks. */\n\n/* masks to interrogate printer status. */\n#define LP_READY_MASK   (LPS_NERR | LPS_SEL | LPS_OUT | LPS_NBSY)\n#define LP_READY        (LPS_NERR | LPS_SEL |           LPS_NBSY)\n\n/* used in polling code. */\n#define LPS_INVERT      (LPS_NERR | LPS_SEL |           LPS_NACK | LPS_NBSY)\n#define LPS_MASK        (LPS_NERR | LPS_SEL | LPS_OUT | LPS_NACK | LPS_NBSY)\n#define NOT_READY(bus)  ((ppb_rstr(bus) ^ LPS_INVERT) & LPS_MASK)\n#define MAX_SPIN        20              /* wait up to 20 usec.          */\n#define MAX_SLEEP       (hz * 5)        /* timeout while waiting.       */\n\nstatic d_open_t                 lpt_open;\nstatic d_close_t                lpt_close;\nstatic d_read_t                 lpt_read;\nstatic d_write_t                lpt_write;\nstatic d_ioctl_t                lpt_ioctl;\n\nstatic struct cdevsw lpt_cdevsw = {\n        .d_version =            D_VERSION,\n        .d_open =               lpt_open,\n        .d_close =              lpt_close,\n        .d_read =               lpt_read,\n        .d_write =              lpt_write,\n        .d_ioctl =              lpt_ioctl,\n        .d_name =               LPT_NAME\n};\n\nstatic devclass_t lpt_devclass;\n\nstatic void\nlpt_identify(driver_t *driver, device_t parent)\n{\n...\n}\n\nstatic int\nlpt_request_ppbus(device_t dev, int how)\n{\n...\n}\n\nstatic int\nlpt_release_ppbus(device_t dev)\n{\n...\n}\n\nstatic int\nlpt_port_test(device_t ppbus, u_char data, u_char mask)\n{\n...\n}\n\nstatic int\nlpt_detect(device_t dev)\n{\n...\n}\n\nstatic int\nlpt_probe(device_t dev)\n{\n...\n}\n\nstatic void\nlpt_intr(void *arg)\n{\n...\n}\n\nstatic int\nlpt_attach(device_t dev)\n{\n...\n}\n\nstatic int\nlpt_detach(device_t dev)\n{\n...\n}\n\nstatic void\nlpt_timeout(void *arg)\n{\n...\n}\n\nstatic int\nlpt_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n{\n...\n}\n\nstatic int\nlpt_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n{\n...\n}\n\nstatic int\nlpt_read(struct cdev *dev, struct uio *uio, int ioflag)\n{\n...\n}\n\nstatic int\nlpt_push_bytes(struct lpt_data *sc)\n{\n...\n}\n\nstatic int\nlpt_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n...\n}\n\nstatic int\nlpt_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n    struct thread *td)\n{\n...\n}\n\nstatic device_method_t lpt_methods[] = {\n        DEVMETHOD(device_identify,      lpt_identify),\n        DEVMETHOD(device_probe,         lpt_probe),\n        DEVMETHOD(device_attach,        lpt_attach),\n        DEVMETHOD(device_detach,        lpt_detach),\n        { 0, 0 }\n};\n\nstatic driver_t lpt_driver = {\n        LPT_NAME,\n        lpt_methods,\n        sizeof(struct lpt_data)\n};\n\nDRIVER_MODULE(lpt, ppbus, lpt_driver, lpt_devclass, 0, 0);\nMODULE_DEPEND(lpt, ppbus, 1, 1, 1);\n```", "```\nstatic void\nlpt_identify(driver_t *driver, device_t parent)\n{\n        device_t dev;\n\n        dev = device_find_child(parent, LPT_NAME, −1);\n        if (!dev)\n               BUS_ADD_CHILD(parent, 0, LPT_NAME, −1);\n}\n```", "```\nstatic int\nlpt_probe(device_t dev)\n{\n        if (!lpt_detect(dev))\n                return (ENXIO);\n\n        device_set_desc(dev, \"Printer\");\n\n        return (BUS_PROBE_SPECIFIC);\n}\n```", "```\nstatic int\nlpt_detect(device_t dev)\n{\n        device_t ppbus = device_get_parent(dev);\n      static u_char test[18] = {\n                0x55,                   /* alternating zeros.   */\n                0xaa,                   /* alternating ones.    */\n                0xfe, 0xfd, 0xfb, 0xf7,\n                0xef, 0xdf, 0xbf, 0x7f, /* walking zero.        */\n                0x01, 0x02, 0x04, 0x08,\n                0x10, 0x20, 0x40, 0x80  /* walking one.         */\n        };\n        int i, error, success = 1;      /* assume success.      */\n\n      ppb_lock(ppbus);\n\n        error = lpt_request_ppbus(dev, PPB_DONTWAIT);\n        if (error) {\n                ppb_unlock(ppbus);\n                device_printf(dev, \"cannot allocate ppbus (%d)!\\n\", error);\n                return (0);\n        }\n\n        for (i = 0; i < 18; i++)\n                if (!lpt_port_test(ppbus, test[i], 0xff)) {\n                        success = 0;\n                        break;\n                }\n\n      ppb_wdtr(ppbus, 0);\n      ppb_wctr(ppbus, 0);\n\n      lpt_release_ppbus(dev);\n      ppb_unlock(ppbus);\n\n        return (success);\n}\n```", "```\nstatic int\nlpt_port_test(device_t ppbus, u_char data, u_char mask)\n{\n        int temp, timeout = 10000;\n\n        data &= mask;\n      ppb_wdtr(ppbus, data);\n\n        do {\n                DELAY(10);\n                temp = ppb_rdtr(ppbus) & mask;\n        } while (temp != data && --timeout);\n\n      return (temp == data);\n}\n```", "```\nstatic int\nlpt_attach(device_t dev)\n{\n        device_t ppbus = device_get_parent(dev);\n        struct lpt_data *sc = device_get_softc(dev);\n        int error, unit = device_get_unit(dev);\n\n      sc->sc_primed = 0;\n      ppb_init_callout(ppbus, &sc->sc_callout, 0);\n\n        ppb_lock(ppbus);\n        error = lpt_request_ppbus(dev, PPB_DONTWAIT);\n        if (error) {\n                ppb_unlock(ppbus);\n                device_printf(dev, \"cannot allocate ppbus (%d)!\\n\", error);\n                return (0);\n        }\n\n      ppb_wctr(ppbus, LPC_NINIT);\n\n        lpt_release_ppbus(dev);\n        ppb_unlock(ppbus);\n\n        /* Declare our interrupt handler. */\n        sc->sc_irq_rid = 0;\n        sc->sc_irq_resource = bus_alloc_resource_any(dev, SYS_RES_IRQ,\n            &sc->sc_irq_rid, RF_ACTIVE | RF_SHAREABLE);\n\n        /* Register our interrupt handler. */\n        if (sc->sc_irq_resource) {\n                error = bus_setup_intr(dev, sc->sc_irq_resource,\n                    INTR_TYPE_TTY | INTR_MPSAFE, NULL, lpt_intr,\n                    sc, &sc->sc_irq_cookie);\n                if (error) {\n                        bus_release_resource(dev, SYS_RES_IRQ,\n                            sc->sc_irq_rid, sc->sc_irq_resource);\n                        device_printf(dev,\n                            \"unable to register interrupt handler\\n\");\n                        return (error);\n                }\n\n              sc->sc_irq_status = LP_HAS_IRQ | LP_USE_IRQ | LP_ENABLE_IRQ;\n                device_printf(dev, \"interrupt-driven port\\n\");\n        } else {\n                sc->sc_irq_status = 0;\n                device_printf(dev, \"polled port\\n\");\n        }\n\n      sc->sc_buf = malloc(BUF_SIZE, M_DEVBUF, M_WAITOK);\n      sc->sc_buf_stat = malloc(BUF_STAT_SIZE, M_DEVBUF, M_WAITOK);\n\n        sc->sc_dev = dev;\n\n        sc->sc_cdev = make_dev(&lpt_cdevsw, unit, UID_ROOT, GID_WHEEL, 0600,\n            LPT_NAME \"%d\", unit);\n        sc->sc_cdev->si_drv1 = sc;\n        sc->sc_cdev->si_drv2 = 0;\n\n        sc->sc_cdev_bypass = make_dev(&lpt_cdevsw, unit, UID_ROOT, GID_WHEEL,\n            0600, LPT_NAME \"%d.ctl\", unit);\n        sc->sc_cdev_bypass->si_drv1 = sc;\n        sc->sc_cdev_bypass->si_drv2 = (void *)LP_BYPASS;\n\n        return (0);\n}\n```", "```\nstatic int\nlpt_detach(device_t dev)\n{\n        device_t ppbus = device_get_parent(dev);\n        struct lpt_data *sc = device_get_softc(dev);\n\n      destroy_dev(sc->sc_cdev_bypass);\n      destroy_dev(sc->sc_cdev);\n\n        ppb_lock(ppbus);\n      lpt_release_ppbus(dev);\n        ppb_unlock(ppbus);\n\n      callout_drain(&sc->sc_callout);\n\n        if (sc->sc_irq_resource) {\n               bus_teardown_intr(dev, sc->sc_irq_resource,\n                    sc->sc_irq_cookie);\n               bus_release_resource(dev, SYS_RES_IRQ, sc->sc_irq_rid,\n                    sc->sc_irq_resource);\n        }\n\n      free(sc->sc_buf_stat, M_DEVBUF);\n      free(sc->sc_buf, M_DEVBUF);\n\n        return (0);\n}\n```", "```\nstatic int\nlpt_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n{\n        struct lpt_data *sc = dev->si_drv1;\n        device_t lpt_dev = sc->sc_dev;\n        device_t ppbus = device_get_parent(lpt_dev);\n        int try, error;\n\n        if (!sc)\n                return (ENXIO);\n\n        ppb_lock(ppbus);\n      if (sc->sc_state) {\n                ppb_unlock(ppbus);\n                return (EBUSY);\n        } else\n                sc->sc_state |= LP_INIT;\n\n      sc->sc_flags = (uintptr_t)dev->si_drv2;\n        if (sc->sc_flags & LP_BYPASS) {\n                sc->sc_state = LP_OPEN;\n                ppb_unlock(ppbus);\n                return (0);\n        }\n\n        error = lpt_request_ppbus(lpt_dev, PPB_WAIT | PPB_INTR);\n        if (error) {\n                sc->sc_state = 0;\n                ppb_unlock(ppbus);\n                return (error);\n        }\n\n        /* Use our IRQ? */\n        if (sc->sc_irq_status & LP_ENABLE_IRQ)\n                sc->sc_irq_status |= LP_USE_IRQ;\n        else\n                sc->sc_irq_status &= ˜LP_USE_IRQ;\n\n        /* Reset printer. */\n        if ((sc->sc_flags & LP_NO_PRIME) == 0)\n                if ((sc->sc_flags & LP_PRIME_OPEN) || sc->sc_primed == 0) {\n                      ppb_wctr(ppbus, 0);\n                        sc->sc_primed++;\n                        DELAY(500);\n                }\n\n      ppb_wctr(ppbus, LPC_SEL | LPC_NINIT);\n\n        /* Wait until ready--printer should be running diagnostics. */\n        try = 0;\n      do {\n                /* Give up? */\n                if (try++ >= (LPT_INIT_READY * 4)) {\n                        lpt_release_ppbus(lpt_dev);\n                        sc->sc_state = 0;\n                        ppb_unlock(ppbus);\n                        return (EBUSY);\n                }\n\n                /* Wait 1/4 second. Give up if we get a signal. */\n                if (ppb_sleep(ppbus, lpt_dev, LPT_PRI | PCATCH, \"lpt_open\",\n                    hz / 4) != EWOULDBLOCK) {\n                        lpt_release_ppbus(lpt_dev);\n                        sc->sc_state = 0;\n                        ppb_unlock(ppbus);\n                        return (EBUSY);\n                }\n        } while ((ppb_rstr(ppbus) & LP_READY_MASK) != LP_READY);\n\n      sc->sc_control = LPC_SEL | LPC_NINIT;\n        if (sc->sc_flags & LP_AUTO_LF)\n              sc->sc_control |= LPC_AUTOL;\n        if (sc->sc_irq_status & LP_USE_IRQ)\n              sc->sc_control |= LPC_ENA;\n\n        ppb_wctr(ppbus, sc->sc_control);\n\n        sc->sc_state &= ˜LP_INIT;\n        sc->sc_state |= LP_OPEN;\n        sc->sc_transfer_count = 0;\n\n        if (sc->sc_irq_status & LP_USE_IRQ) {\n                sc->sc_state |= LP_TIMEOUT;\n                sc->sc_ticks = hz / LP_TOUT_INIT;\n                callout_reset(&sc->sc_callout, sc->sc_ticks,\n                   lpt_timeout, sc);\n        }\n\n        lpt_release_ppbus(lpt_dev);\n        ppb_unlock(ppbus);\n\n        return (0);\n}\n```", "```\nstatic int\nlpt_read(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        struct lpt_data *sc = dev->si_drv1;\n        device_t lpt_dev = sc->sc_dev;\n        device_t ppbus = device_get_parent(lpt_dev);\n        int num, error = 0;\n\n      if (sc->sc_flags & LP_BYPASS)\n                return (EPERM);\n\n        ppb_lock(ppbus);\n        error = ppb_1284_negociate(ppbus, PPB_NIBBLE, 0);\n        if (error) {\n                ppb_unlock(ppbus);\n                return (error);\n        }\n\n        num = 0;\n        while (uio->uio_resid) {\n                error = ppb_1284_read(ppbus, PPB_NIBBLE,\n sc->sc_buf_stat,\n                    min(BUF_STAT_SIZE, uio->uio_resid), &num);\n                if (error)\n                        goto end_read;\n\n              if (!num)\n                        goto end_read;\n\n                ppb_unlock(ppbus);\n                error = uiomove(sc->sc_buf_stat, num, uio);\n                ppb_lock(ppbus);\n                if (error)\n                        goto end_read;\n        }\n\nend_read:\n        ppb_1284_terminate(ppbus);\n        ppb_unlock(ppbus);\n        return (error);\n}\n```", "```\nstatic int\nlpt_write(struct cdev *dev, struct uio *uio, int ioflag)\n{\n        struct lpt_data *sc = dev->si_drv1;\n        device_t lpt_dev = sc->sc_dev;\n        device_t ppbus = device_get_parent(lpt_dev);\n        register unsigned num;\n        int error;\n\n        if (sc->sc_flags & LP_BYPASS)\n                return (EPERM);\n\n        ppb_lock(ppbus);\n        error = lpt_request_ppbus(lpt_dev, PPB_WAIT | PPB_INTR);\n        if (error) {\n                ppb_unlock(ppbus);\n                return (error);\n        }\n\n      sc->sc_state &= ˜LP_INTERRUPTED;\n        while ((num = min(BUF_SIZE, uio->uio_resid))) {\n                sc->sc_cp = sc->sc_buf;\n\n                ppb_unlock(ppbus);\n                error = uiomove(sc->sc_cp, num, uio);\n                ppb_lock(ppbus);\n                if (error)\n                        break;\n\n              sc->sc_transfer_count = num;\n\n              if (sc->sc_irq_status & LP_ENABLE_EXT) {\n                        error = ppb_write(ppbus, sc->sc_cp,\n                            sc->sc_transfer_count, 0);\n                        switch (error) {\n                        case 0:\n                                sc->sc_transfer_count = 0;\n                                break;\n                        case EINTR:\n                                sc->sc_state |= LP_INTERRUPTED;\n                                ppb_unlock(ppbus);\n                                return (error);\n                        case EINVAL:\n                                log(LOG_NOTICE,\n                                    \"%s: extended mode not available\\n\",\n                                    device_get_nameunit(lpt_dev));\n                                break;\n                        default:\n                                ppb_unlock(ppbus);\n                                return (error);\n                        }\n                } else while ((sc->sc_transfer_count > 0) &&\n                             (sc->sc_irq_status & LP_USE_IRQ)) {\n                        if (!(sc->sc_state & LP_BUSY))\n                              lpt_intr(sc);\n\n                        if (sc->sc_state & LP_BUSY) {\n                                error = ppb_sleep(ppbus, lpt_dev,\n                                    LPT_PRI | PCATCH, \"lpt_write\", 0);\n                                if (error) {\n                                        sc->sc_state |= LP_INTERRUPTED;\n                                        ppb_unlock(ppbus);\n                                        return (error);\n                                }\n                        }\n                }\n\n                if (!(sc->sc_irq_status & LP_USE_IRQ) &&\n                     (sc->sc_transfer_count)) {\n                        error = lpt_push_bytes(sc);\n                        if (error) {\n                                ppb_unlock(ppbus);\n                                return (error);\n                        }\n                }\n        }\n\n        lpt_release_ppbus(lpt_dev);\n        ppb_unlock(ppbus);\n\n        return (error);\n}\n```", "```\nstatic void\nlpt_intr(void *arg)\n{\n        struct lpt_data *sc = arg;\n        device_t lpt_dev = sc->sc_dev;\n        device_t ppbus = device_get_parent(lpt_dev);\n        int i, status = 0;\n\n      for (i = 0; i < 100 &&\n             ((status = ppb_rstr(ppbus)) & LP_READY_MASK) != LP_READY; i++)\n                ;       /* nothing. */\n\n        if ((status & LP_READY_MASK) == LP_READY) {\n              sc->sc_state = (sc->sc_state | LP_BUSY) & ˜LP_ERROR;\n              sc->sc_ticks = hz / LP_TOUT_INIT;\n\n                if (sc->sc_transfer_count) {\n                      ppb_wdtr(ppbus, *sc->sc_cp++);\n                      ppb_wctr(ppbus, sc->sc_control | LPC_STB);\n                        ppb_wctr(ppbus, sc->sc_control);\n\n                        if (--(sc->sc_transfer_count) > 0)\n                               return;\n                }\n\n              sc->sc_state &= ˜LP_BUSY;\n\n                if (!(sc->sc_state & LP_INTERRUPTED))\n                      wakeup(lpt_dev);\n\n                return;\n        } else {\n                if (((status & (LPS_NERR | LPS_OUT)) != LPS_NERR) &&\n                    (sc->sc_state & LP_OPEN))\n                        sc->sc_state |= LP_ERROR;\n        }\n}\n```", "```\nstatic void\nlpt_timeout(void *arg)\n{\n        struct lpt_data *sc = arg;\n        device_t lpt_dev = sc->sc_dev;\n\n      if (sc->sc_state & LP_OPEN) {\n                sc->sc_ticks++;\n                if (sc->sc_ticks > hz / LP_TOUT_MAX)\n                        sc->sc_ticks = hz / LP_TOUT_MAX;\n              callout_reset(&sc->sc_callout, sc->sc_ticks,\n                    lpt_timeout, sc);\n        } else\n                sc->sc_state &= ˜LP_TIMEOUT;\n\n        if (sc->sc_state & LP_ERROR)\n              sc->sc_state &= ˜LP_ERROR;\n\n      if (sc->sc_transfer_count)\n              lpt_intr(sc);\n        else {\n                sc->sc_state &= ˜LP_BUSY;\n                wakeup(lpt_dev);\n        }\n}\n```", "```\nstatic int\nlpt_push_bytes(struct lpt_data *sc)\n{\n        device_t lpt_dev = sc->sc_dev;\n        device_t ppbus = device_get_parent(lpt_dev);\n        int error, spin, tick;\n        char ch;\n\n      while (sc->sc_transfer_count > 0) {\n                ch = *sc->sc_cp;\n                sc->sc_cp++;\n                sc->sc_transfer_count--;\n\n              for (spin = 0; NOT_READY(ppbus) && spin < MAX_SPIN; spin++)\n                        DELAY(1);\n\n                if (spin >= MAX_SPIN) {\n                        tick = 0;\n                        while (NOT_READY(ppbus)) {\n                                tick = tick + tick + 1;\n                                if (tick > MAX_SLEEP)\n                                        tick = MAX_SLEEP;\n\n                                error = ppb_sleep(ppbus, lpt_dev, LPT_PRI,\n                                    \"lpt_poll\", tick);\n                                if (error != EWOULDBLOCK)\n                                        return (error);\n                        }\n                }\n\n              ppb_wdtr(ppbus, ch);\n              ppb_wctr(ppbus, sc->sc_control | LPC_STB);\n                ppb_wctr(ppbus, sc->sc_control);\n        }\n\n        return (0);\n}\n```", "```\nstatic int\nlpt_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n{\n        struct lpt_data *sc = dev->si_drv1;\n        device_t lpt_dev = sc->sc_dev;\n        device_t ppbus = device_get_parent(lpt_dev);\n        int error;\n\n        ppb_lock(ppbus);\n\n      if (sc->sc_flags & LP_BYPASS)\n                goto end_close;\n\n        error = lpt_request_ppbus(lpt_dev, PPB_WAIT | PPB_INTR);\n        if (error) {\n                ppb_unlock(ppbus);\n                return (error);\n        }\n\n      if (!(sc->sc_state & LP_INTERRUPTED) &&\n           (sc->sc_irq_status & LP_USE_IRQ))\n                while ((ppb_rstr(ppbus) & LP_READY_MASK) != LP_READY ||\n                   sc->sc_transfer_count)\n                        if (ppb_sleep(ppbus, lpt_dev, LPT_PRI | PCATCH,\n                            \"lpt_close\", hz) != EWOULDBLOCK)\n                                break;\n\n      sc->sc_state &= ˜LP_OPEN;\n      callout_stop(&sc->sc_callout);\n      ppb_wctr(ppbus, LPC_NINIT);\n\n        lpt_release_ppbus(lpt_dev);\n\n end_close:\n      sc->sc_state = 0;\n      sc->sc_transfer_count = 0;\n        ppb_unlock(ppbus);\n        return (0);\n}\n```", "```\n#define LPT_IRQ         _IOW('p', 1, long)\n```", "```\nstatic int\nlpt_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag,\n    struct thread *td)\n{\n        struct lpt_data *sc = dev->si_drv1;\n        device_t lpt_dev = sc->sc_dev;\n        device_t ppbus = device_get_parent(lpt_dev);\n        u_short old_irq_status;\n        int error = 0;\n\n        switch (cmd) {\n      case LPT_IRQ:\n                ppb_lock(ppbus);\n                if (sc->sc_irq_status & LP_HAS_IRQ) {\n                        old_irq_status = sc->sc_irq_status;\n                        switch (*(int *)data) {\n                        case 0:\n                              sc->sc_irq_status &= ˜LP_ENABLE_IRQ;\n                                break;\n                        case 1:\n                                sc->sc_irq_status &= ˜LP_ENABLE_EXT;\n                              sc->sc_irq_status |= LP_ENABLE_IRQ;\n                                break;\n                        case 2:\n                                sc->sc_irq_status &= ˜LP_ENABLE_IRQ;\n                              sc->sc_irq_status |= LP_ENABLE_EXT;\n                                break;\n                        case 3:\n                              sc->sc_irq_status &= ˜LP_ENABLE_EXT;\n                                break;\n                        default:\n                                break;\n                        }\n\n                        if (old_irq_status != sc->sc_irq_status)\n                                log(LOG_NOTICE,\n                                    \"%s: switched to %s %s mode\\n\",\n                                    device_get_nameunit(lpt_dev),\n                                    (sc->sc_irq_status & LP_ENABLE_IRQ) ?\n                                    \"interrupt-driven\" : \"polled\",\n                                    (sc->sc_irq_status & LP_ENABLE_EXT) ?\n                                    \"extended\" : \"standard\");\n                } else\n                        error = EOPNOTSUPP;\n\n                ppb_unlock(ppbus);\n                break;\n        default:\n                error = ENODEV;\n                break;\n        }\n\n        return (error);\n}\n```", "```\nstatic int\nlpt_request_ppbus(device_t dev, int how)\n{\n        device_t ppbus = device_get_parent(dev);\n        struct lpt_data *sc = device_get_softc(dev);\n        int error;\n\n        ppb_assert_locked(ppbus);\n\n      if (sc->sc_state & LP_HAVEBUS)\n               return (0);\n\n        error = ppb_request_bus(ppbus, dev, how);\n        if (!error)\n               sc->sc_state |= LP_HAVEBUS;\n\n        return (error);\n}\n```", "```\nstatic int\nlpt_release_ppbus(device_t dev)\n{\n        device_t ppbus = device_get_parent(dev);\n        struct lpt_data *sc = device_get_softc(dev);\n        int error = 0;\n\n        ppb_assert_locked(ppbus);\n\n      if (sc->sc_state & LP_HAVEBUS) {\n                error = ppb_release_bus(ppbus, dev);\n                if (!error)\n                       sc->sc_state &= ˜LP_HAVEBUS;\n        }\n\n        return (error);\n}\n```"]