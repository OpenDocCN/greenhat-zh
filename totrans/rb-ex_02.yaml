- en: Chapter 2. Amusements and Simple Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the previous chapter, you should now be relatively comfortable with irb
    and how Ruby deals with various expressions. Now we’ll try some Ruby programs
    that are stored in separate files and executed outside of irb. You can download
    all of these programs at [http://www.nostarch.com/ruby.htm](http://www.nostarch.com/ruby.htm).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll run our programs with the `ruby` command, so when we want to run a script
    called `check_payday.rb`, we’ll type `ruby check_payday.rb` either at the shell
    in a Unix-like system or at the command prompt in Windows. We’ll also generally
    use the `-w` option, which means *turn warnings on*, making our example above
    become `ruby -w check_payday.rb`. It’s just a safer way to operate, and it is
    especially useful when learning a new language. We’ll also occasionally see Ruby
    Documentation (RDoc), which allows us to put relatively complex comments directly
    into our source code. We’ll discuss that in relation to the `99bottles.rb` example,
    where we first use it.
  prefs: []
  type: TYPE_NORMAL
- en: '#1 Is It Payday? (check_payday.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is a simple utility that I use to remind myself when a payday is
    approaching. It is very much in the quick-and-dirty style, and intentionally so.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Line ❶ is a hint to the computer that this program is in Ruby. The line at ❷
    is a comment meant for human readers that tells the name of the program. In Ruby,
    comments start with the `#` character and last until the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We define two constants at ❸. While constants only need to *start* with a capital
    letter, I like to use all caps to make them stand out. (This is a common convention
    in many languages and a good habit to get into.)
  prefs: []
  type: TYPE_NORMAL
- en: The names of the constants `DAYS_IN_PAY_PERIOD` and `SECONDS_IN_A_DAY` should
    give you a good sense of what they mean—specifically, the number of days in a
    pay period and the number of seconds in a day. I get paid every two weeks, which
    is the same as every 14 days.
  prefs: []
  type: TYPE_NORMAL
- en: The definition for `SECONDS_IN_A_DAY` uses multiplication (`60 * 60 * 24`),
    which is acceptable Ruby syntax, as you know from your experiments in irb. Representing
    these specific numbers as the result of multiplication instead of as one big final
    result is also more human readable, because a person reading this code will see
    and understand the relationship among 60 seconds in a minute, 60 minutes in an
    hour, and 24 hours in a day.
  prefs: []
  type: TYPE_NORMAL
- en: Why bother to define constants with more characters than the values they hold?
    While it doesn’t make a huge difference in this program, it’s a good habit to
    get into for larger programs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Constants are a very good idea. They allow you to avoid one of the sins of
    programming called* magic numbers, *which are examples of one of two programming
    sins: a literal value used repeatedly, or a literal value whose use is not obvious,
    even if it’s only used once. Defining such a value once with a meaningful name
    makes your code more readable to both other programmers and yourself, after you’ve
    forgotten everything about your program. Again, constants are a very good idea*.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having defined our constants, we define a variable at ❹ called `matching_date`
    using Ruby’s built-in `Time.local` method. This method takes 10 items as arguments,
    in order: seconds, minutes, hours, day of the month, month, year, day of the week,
    day number within the year (1 through 366), whether the date is within daylight
    saving time, and a three-letter code for the time zone. The values used here are
    for September 22, 2006, which is a day that happened to be a payday for me. The
    day number within a year has a maximum of 366 instead of 365, because leap years
    have 366 days.'
  prefs: []
  type: TYPE_NORMAL
- en: At ❺, we get the `current_date` using Ruby’s built-in `Time.new` method, and
    then subtract `matching_date` from it to get the difference, in seconds. Because
    we are much more interested in the difference in days rather than the difference
    in seconds, we divide the `difference_in_seconds` by the number of `SECONDS_IN_A_DAY`
    to get the difference in days, and then we round down by converting that result
    into an Integer with the `to_i` method. That gives us a useful value for our `difference_in_days`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `difference_in_days` variable tells us the number of days since the last
    payday. However, because we really want our cash, we are more interested in how
    long we have to wait until the next payday. To find out, at ❻ we subtract the
    number of days since our last payday (the `difference_in_days` variable) from
    the number of `DAYS_IN_A_PAY_PERIOD` to get a new variable at ❼ called `days_to_wait`.
  prefs: []
  type: TYPE_NORMAL
- en: If `days_to_wait` has a value of zero, today must be payday, so at ❽ we output
    that information using Ruby’s built-in method `puts`. The `puts` method, which
    stands for *put string*, prints its String argument (`‘Payday today.’`, in our
    script) followed by an automatic carriage return, also called a *newline*. If
    `days_to_wait` is not zero, we use `puts` again to tell how many days we have
    to wait for payday, and as a convenience, we add the letter s to the word `day`
    if the number of days is plural.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*We call both *`print`* and *`puts`* without parentheses enclosing the argument(s).
    This is perfectly legal, unless there would be some ambiguity about either the
    boundaries of an expression or the specific arguments to a method*.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s the whole program. There are more elegant ways to accomplish some of
    the tasks that this program does, but it introduces some new concepts, such as
    Constants, the `puts` method, and Dates. You can run it yourself and compare what
    it outputs to what your own actual pay schedule is, altering the `matching_day`
    variable accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Readers familiar with crontab may find it interesting that I run this on my
    machine with the following crontab entry: *`ruby ~/scripts/check_payday.rb | mutt
    -s “payday” kbaird`**.'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your result should be a message along the lines of *Payday in 10 days*, depending
    on the day you run the program.
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Random Signature Generator (random_sig.rb and random_sig-windows.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next script generates dynamic content for email signatures, adding standard
    information, like a name and email address, to a random quotation drawn from a
    known file. The Unix and Windows versions need to be slightly different, so they
    have been separated into two distinct files. I’ll talk about the Unix version
    first, but will include the source code for both files. In this example, we’ll
    also see how Ruby handles complex assignments. That’s a lot of information to
    cover.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At ❶, we assign a value to a variable called `filename`, but the value that
    goes into it is somewhat more complex than a single straightforward number or
    String. `ARGV` is an example of an environment variable. Environment variables
    are described in [Chapter 1](ch01.html "Chapter 1. Interactive Ruby and the Ruby
    Environment"). For historical reasons, `ARGV` stands for *Argument Vector* and
    is an Array of the command-line arguments to any program when it is run.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not the whole line, though. Just as the equals sign is an operator that
    puts a value into something, the double-bar (`||`) is an operator that means *or*.
    Let’s use irb to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An expression with the `||` operator evaluates whatever is to the left of it.
    If it is true, the whole expression has that value, whatever possible true value
    it happens to be. If the left side is false, the whole expression has the value
    on the right of the `||`, whatever that value is—`true, false, nil`, whatever.
    Missing arguments are `nil`, and `nil` evaluates to `false` when tested by `||`.
    The elements of `ARGV` start counting with zero, just like all Arrays in Ruby
    (and many other languages). Our `filename` variable is either the first argument
    to this program, or if there is no argument, it’s set to all of that business
    within the parentheses: `(ENV[‘HOME’] + ‘/scripts/sig_quotes.txt’)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Windows users will need to use *`(ENV[‘HOMEDRIVE’] + ENV[‘HOMEPATH’])`* instead
    of *`ENV[‘HOME’]`*. We’ll talk more about that in the Windows version of the script*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV` is an environment variable, as the abbreviation suggests, and the parentheses
    indicate expression boundaries, just as in a math expression, like `(5 + 2) *
    2 = 14`. `ENV[‘HOME’]` is simply a way for you to get to the directory that belongs
    to a specific user. For my username, *kbaird*, this would be something like `/home/kbaird`,
    or `/Users/kbaird` under Mac OS X. The home directory is analogous to the My Documents
    folder in Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV[‘HOME’]` is a String, and in our expression, we add it to the String `‘/scripts/sig_quotes.txt’`.
    All this means is that our filename has a default value of `sig_quotes.txt`, within
    the `scripts` directory, within the user’s home directory. Now we know the name
    of the file to read quotations from, so let’s use it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby creates new external File objects with `File.new()`, which takes two arguments:
    the name of the file and the manner in which you want to use that file. In this
    case, we want to read from the file, so at ❷ we give it a second argument of `‘r’`,
    which naturally stands for *read*. We call this file `quotations_file` and read
    its lines into a variable called `file_lines`. Since we’re now done with the file,
    we can close it, which we do at ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: The new variable `file_lines` is an Array with each line of the quotations file
    as a single element. What do we do when we want longer quotations? We’ve taken
    care of that at ❹ by combining those lines into a String with our old friend the
    `to_s` method, and turning it back into an Array with a method called `split`,
    which takes a breakpoint argument to break a String into chunks. Let’s see it
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our program, we’re breaking on a double line break, which is represented
    in Ruby, as in many other languages, with `\n\n`. We now have a variable called
    `quotations`, which is an Array, each member of which is a quotation from our
    external file.
  prefs: []
  type: TYPE_NORMAL
- en: We want to choose a random quotation, and elements of Arrays are conveniently
    stored with indices, so a very appropriate way to choose a random element from
    an Array is to generate a random number within the range of the Array’s indices,
    and then read the element out of the Array at that index. That’s precisely what
    we do at ❺ with the `rand` method, into which we pass the `size` of the quotations
    Array. We place the specific quotation chosen into a variable at ❻ with the apt
    name `quotation`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a quotation, what can we do with it? We want to write it out
    to our signature file. We usually print things with `puts`, which we used in [#1
    Is It Payday? (check_payday.rb)](ch02.html#sharp1_is_it_payday_check_paydayrb
    "#1 Is It Payday? (check_payday.rb)") on page 14\. Let’s try it out in a new irb
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that `puts` outputs whatever argument you give it, but the value
    it *returns* is `nil`. It’s important to keep that distinction in mind. If you
    use `puts` on a file, it will print its argument to that file instead of printing
    to the screen. We already know that we can read from external files with a second
    argument of `‘r’`. Similarly, we can write to an external file with a second argument
    of `‘w’`, which is the way we open `signature_file` at ❼. Let’s take a look at
    the way `puts` behaves in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `puts` method continues to return `nil`, but take a look at a new file called
    `test_file` inside your home directory. It should now contain the text *Write
    some content*, proving that `puts` can easily print to a file, as well. Note that
    we use a filename that means *The file called .signature within the user’s home
    directory*, which is the traditional location for email signature files. All that’s
    left is to write a standard header at ❽, add the randomly-chosen quotation, and
    then close the signature file.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a Unix-like operating system, you can put a call to this program
    in a crontab,^([[8](#ftn.CHP-2-FNOTE-1)]) as I do on my Debian machine. Windows
    users can modify the script to write a signature file with whatever name they
    choose, and then change the settings of their email program to use that signature
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is run with `ruby -w random_sig.rb` (to assume the default `sig_quotes.txt`
    file), or `ruby -w random_sig.rb` *`some_file`*, replacing *`some_file`* with
    the name of your preferred version of `sig_quotes.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are my results. The `$` denotes a bash prompt on my GNU/Linux system. I
    add an additional `cat ~/.signature` (which just shows the contents of `~/.signature`)
    to show the results, since the script writes to that file instead of printing
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look at the Windows source code below, and try to figure out the changes
    before continuing on to my explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only significant differences relate to the filesystem, which is how the
    operating system and programs access your machine’s hard drive, CD-ROM drive,
    and so on. Windows uses a separate drive letter, which is represented by `ENV[‘HOMEDRIVE’]`,
    and a path within that drive letter, which is represented by `ENV[‘HOMEPATH’]`.
    Because of the greater complexity of the Windows definition of *home*, we have
    put it into a variable in this version of the script at ❶. The only other differences
    are the use of backslashes rather than forward slashes at ❷ and ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#CHP-2-FNOTE-1)]) A crontab is just a way for Unix machines to schedule
    operations. If you use a Unix-like operating system, just execute `man crontab`
    at the shell. If you use Windows, you can use Windows Scheduler with a batch file.
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The 99 Bottles of Beer Song (99bottles.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script demonstrates basic Object Orientation by singing (okay, printing)
    the “99 Bottles of Beer” song. The content of the example may be a bit contrived,
    but the program itself reveals a great deal about naming conventions in Ruby.
    We’ll be defining a Wall, on which there are bottles, the number of which repeatedly
    drops by one.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the code. Classes are the basic building blocks in Ruby, so it’s worthwhile
    for anyone curious about the language to understand them in some depth. We’ve
    already seen some built-in classes (String, Integer, and Array), so they’re not
    a fundamentally new concept for you at this point. What is new is the ability
    to define completely novel classes of your own, as we do below.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We define classes using the keyword *class* followed by whatever name we choose,
    which we do at ❶ for the class `Wall`. Classes must start with an uppercase letter,
    and it is traditional to use mixed case, as in *MultiWordClassName*. Our class
    is called *Wall*, which conjures up a real-world object in a reader’s mind. This
    is the wall in the song on which the bottles sit.
  prefs: []
  type: TYPE_NORMAL
- en: It is also traditional to define a class in a file with the same name by using
    all lowercase letters and underscores between the words, if the name consists
    of multiple words (i.e., `multi_word_class_name.rb`). This is just a convention,
    but it is a widely followed one, and if you decide to use Rails, using this convention
    will make your life much easier.
  prefs: []
  type: TYPE_NORMAL
- en: If our wall just sat there and did nothing, there would be little point in creating
    it. We want our wall to be able to take some sort of action. These actions are
    methods, just like those we’ve already encountered. We’ve already defined functions
    with the `def` keyword. Now we’ll do so within a class—this attaches the function
    we’re defining to that class, making it a *method* of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Every class should have a method called `initialize`, which is what that class
    uses when it creates itself. From the outside, we call the method `new`, but the
    class itself uses the name `initialize`. (We’ll talk about why that distinction
    exists shortly.) Our wall’s `initialize` method, defined at ❷, takes one argument
    called `num_of_bottles`. It then sets the value of a variable called `@bottles`
    equal to whatever `num_of_bottles` is. Why does `@bottles` have the @ sign in
    front of it? The @ sign is how Ruby indicates that something is what’s called
    an *instance variable*.
  prefs: []
  type: TYPE_NORMAL
- en: An *instance variable* is just a characteristic of some thing. If we have a
    class called Person, each person could have characteristics like a name, an age,
    a gender, and so on. These characteristics are all good examples of instance variables,
    because they could (and do) differ from person to person. Just as a Person has
    an age, a Wall has a certain number of bottles on it. Our wall happens to have
    99 bottles on it, because we’ve told it to have that many. Let’s try a different
    number of bottles in irb. You can bring external content into an irb session with
    the `-r` command-line flag, which stands for *require*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the returned value that `@bottles` is set to 10 in the case
    of our new variable, `other_wall`. Both `wall` and `other_wall` are examples (or
    instances) of the class Wall. They differ in key ways, such as the number of bottles
    they hold.
  prefs: []
  type: TYPE_NORMAL
- en: All we want to do when we create a new wall is set its number of bottles, so
    at ❸ we declare the end of the method after setting the value of `@bottles`. After
    we’ve created our wall, we’ll ask the wall if it has any bottles left. We will
    implement this with a method called `empty?`, which we define at ❹. Note the question
    mark, which is a perfectly legitimate part of the method’s name. Ruby has inherited
    a tradition from its ancestor Lisp of naming methods with a question mark when
    they return either *true* or *false*. Such methods that only return a Boolean
    are called *predicates*. It should be clear that a wall is either empty or not
    empty, so the `empty?` method is a predicate, since it will return either `true`
    or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: We also include some RDoc at ❹, before the definition of the `empty?` method.
    The way to indicate RDoc comments is to have the text `=begin rdoc` flush left,
    with no whitespace before it. Ruby will consider everything after `=begin rdoc`
    and before `=end`, also flush left with no preceding whitespace, to be a comment
    meant to be read by a human, not something to be executed. RDoc allows HTML-like
    tagging, as shown in the boldfaced `Boolean` in our script. RDoc also allows a
    variety of other markup options, which we’ll discuss in greater detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The instance variable `@bottles` is a number, represented as an instance of
    Integer in Ruby. Integers have a built-in method called `zero?`, which simply
    tells us whether or not that Integer is zero. This is an example of a predicate
    that was already there for us to use, and it follows the question mark naming
    convention. Our definition of `empty?` for the class Wall also uses parentheses
    to show that it doesn’t accept any arguments. It’s often a good idea to refer
    to methods using parentheses, even in cases like this where there are no arguments
    involved. The main reason for doing so is to make it clear that you’re dealing
    with a method and not a variable. Since you can define both methods and variables,
    and both are made of lowercase letters, the parentheses help Ruby distinguish
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: A song is made to be sung, so we want to tell the Wall how to do so. We’ll define
    a method at ❺ called `sing_one_verse!`. Just as `empty?` uses a question mark,
    `sing_one_verse!` ends with an exclamation point (also called a *bang*), which
    indicates that the method is destructive. *Destructive* methods change the state
    of their object, which means that they perform some action on their object that
    persists after the method has been called.
  prefs: []
  type: TYPE_NORMAL
- en: The verse that `sing_one_verse!` has the responsibility to output has some internal
    repetition, so it only makes sense to break up that repetition and abstract it.
    We do this with the `sing` method, which takes an optional String argument called
    `extra`. This optional argument represents any additions to some boilerplate about
    the number of bottles remaining. The one-line expression at ❼, inside the `sing`
    method, has some things we haven’t seen before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we want to have the value of an expression appear inside a String.
    This process is called *interpolation*, and Ruby does it, as we’ll show here in
    irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we use double quotation marks and wrap an expression within `#{}`, the
    expression is evaluated before it is inserted into the String. When we use single
    quotation marks or omit the `#{}` wrapper, all the text simply appears literally,
    even if that text happens to be a valid expression, such as the name of a variable.
    The combination of double quotation marks and the `#{}` wrapper is a way to tell
    Ruby that you want interpolation to occur.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you want to have double quotation marks within a String that uses interpolation,
    you can use %Q, like this: *`%Q[I am an interpolating String. Call me “#{ ‘Ishmael’
    }”.]`*. Note that the delimiter does not have to be a bracket and could be conceivably
    any character. Common choices are* *`[`*, {‘, and *`!`*.'
  prefs: []
  type: TYPE_NORMAL
- en: The `sing` method also does some testing based on the number of bottles left.
    This determines the specific output that it returns. Critical to this is the fact
    that we can interpolate any expression, not just variables. The first expression
    within the interpolation at ❼ is a test that checks if the value of `@bottles`
    is greater than zero. If it is, that first expression evaluates to `@bottles`,
    otherwise it evaluates to the String `‘no more’`. We do this with what we call
    the *ternary operator*. Let’s look at the ternary operator a bit in irb as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The ternary operator examines whatever is to the left of the question mark;
    it evaluates to whatever immediately follows the question mark if the examined
    expression is true, and evaluates to whatever follows the colon otherwise. You
    can think of it as another way to implement flow control that is sometimes more
    convenient than an `if` test. The next expression at ❼ that uses a ternary evaluates
    to either the word *bottle* or the word *bottles*, as appropriate in English for
    the number of bottles the wall currently has. We then concatenate information
    that says that these are bottles of beer, rather than some other liquid, and add
    the `extra` argument. Since the argument defaults to the empty string, and concatenating
    the empty string onto something has no visible effect, we’re safe when there is
    no argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Actually, this is just* a *ternary operator. It just happens to be the most
    common one, and therefore, it often gets special naming treatment. It is the only
    built-in ternary operator in Ruby*.'
  prefs: []
  type: TYPE_NORMAL
- en: After singing a verse, we take a bottle of beer down with `take_one_down!`,
    the method defined at ❽, again named with a bang. We’ve grouped together the actions
    of taking a bottle away and reporting that fact, which seems to make sense, conceptually.
    Since Ruby methods return the last expression evaluated, this method returns the
    String `‘take one down, pass it around, ’`, which gets incorporated into the entire
    verse inside `sing_one_verse!`.
  prefs: []
  type: TYPE_NORMAL
- en: We finish all of these method definitions with the `end` keyword, and use `end`
    again to finish the class definition. So we’re done—except for the word *private*,
    which we define at ❻. To see how this works, let’s open up irb again and instantiate
    a new Wall.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The only class that can access methods that we’ve defined after the appearance
    of the word *private* is the class itself. The other methods that can be accessed
    from the outside are called *public* methods. Why the distinction? It allows us
    to define an interface for an object that doesn’t change. We can mess around under
    the hood and change everything about how the class actually accomplishes its responsibilities,
    while no one outside the class has any idea that anything has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Using classes in this way is especially useful when working on larger projects
    with other programmers. You can define your class, complete with public methods
    that your other team members know about, and write little stub versions of those
    methods that return legal values with some temporary hard-coded approach. This
    allows your colleagues to start work on their classes, which might depend on the
    output of your class’ methods, even before you have written the real versions
    of those methods. This is very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the `new` versus `initialize` distinction we saw earlier is a public
    versus private distinction. The `initialize` method is automatically private,
    and the (public) `new` method of any object automatically calls the (private)
    `initialize` method of that same object. That’s why we create an `initialize`
    method when we write completely new classes.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try this one out in irb with `irb -r 99bottles.rb`. Note that this will
    output all 99 verses of this song, so don’t be surprised when you see it happen.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a brief section of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#4 Sound File Player (shuffle_play.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this script, we’ll make a program that plays music files in a shuffled order.
    We explored classes in the previous example, and we’ll learn more about them here.
    What happens when we want to have a class that is very similar to an existing
    class? We have several options.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This version is fairly Unix-centric. You can download a Windows version that
    uses the Winamp player at* [http://www.nostarch.com/ruby.htm](http://www.nostarch.com/ruby.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: In Ruby, we know that everything is an object, which is just another way of
    saying that it’s a member (or instance) of a class. We know about well-defined
    classes like Arrays, Strings, Integers, and so on. All of these are what we call
    *open classes*, meaning that we can add code to existing classes. For example,
    we could change all of the Arrays in our programs so that they have a new method,
    and that change would affect any and all Arrays. We don’t have to create a new
    special type of Array to add this hypothetical new method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Old hands at Object Orientation will recognize the creation of a new type
    of class that is otherwise similar to an existing class as using* inheritance.
    *We’ll address inheritance in Ruby in a later chapter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Our shuffle player will need to deal with a list of files. The built-in class
    Array is very well-suited to acting as a list of items, so we’ll base our player
    around an Array of files. In doing so, we’ll also add some behavior to all Arrays
    that will make it easier to deal with the shuffled playback we want to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use two different class definitions in this example: one in which we open
    the Array class to add behavior to it, and another in which we create a completely
    novel class called `ShufflePlayer`. One key method that we add to the Array class
    at ❶ is `shuffle`. Arrays already have two methods that are very handy: `sort_by`
    and `rand`. You’ll notice that `sort_by` is followed by the opening brace character
    (`{`), then the `rand` method, then the closing brace (`}`). This content between
    the opening and closing braces is a *block*, which is central to how Ruby transforms
    or iterates over collections of data, like Arrays (among other things). The `sort_by`
    method is a sorting operation that takes a block argument, which determines the
    manner in which the sorting should occur. By calling the `rand` method within
    our block, we ask our Array to sort its elements randomly, which is how Arrays
    accomplish the `shuffle` method after Ruby reads this method definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Perlers (or JAPHs) might be interested to know that *`sort_by`* uses a Schwartzian
    Transform under the hood. Also, the numbers generated by *`random`* are technically*
    pseudo-random, *not truly random. The difference isn’t critical for the purposes
    of this script*.'
  prefs: []
  type: TYPE_NORMAL
- en: All Arrays can now shuffle themselves in our code. This is all we need for our
    Array, but since this book is about informing people about Ruby as much as it
    is about accomplishing tasks like playing shuffled audio files, we’ll continue
    the discussion. Our Arrays will also be able to shuffle themselves with a method
    defined at ❷ called `shuffle!`, similar to but distinct from the method called
    `shuffle` (without the bang). You recently learned that methods with an ending
    bang are destructive, meaning that they change state in the calling object. We
    accomplish this change of state by using the `replace` method, which transforms
    the calling object into whatever argument it receives. The `shuffle` method returns
    a shuffled version of the calling Array. Since we pass that shuffled Array into
    the `replace` method, it is a very simple way to create a destructive method called
    `shuffle!`, which is precisely what we’ve done.
  prefs: []
  type: TYPE_NORMAL
- en: It’s very easy to add the `random_element` method, as well, which we do at ❸.
    Since a shuffled version of an Array is in a random order (by definition), returning
    any member out of that shuffled Array will produce a random element. Here we return
    the first element, but we could return the last element, or any other element.
    Returning the first element is a good choice, though, because an Array with any
    members at all will definitely have a first member.
  prefs: []
  type: TYPE_NORMAL
- en: With a few short methods, we’ve dramatically added to the capabilities of all
    Arrays. We’ll make use of those capabilities within our new `ShufflePlayer` class.
    Since `ShufflePlayer` is a completely new class, we need to define its `initialize`
    method (❹), which takes an argument called `files` and assigns it into an instance
    variable called `@files`. If you look at ❽, near the end of the program, you see
    that we instantiate a new `ShufflePlayer` with `ARGV` as the files argument.
  prefs: []
  type: TYPE_NORMAL
- en: Once a `ShufflePlayer` exists, we want it to play files in shuffled order. We
    do so with the `play` method, defined at ❺. Within `ShufflePlayer, @files` is
    an Array of filenames. We opened up the Array class, adding the `shuffle` method
    to all Arrays. Therefore, `@files` can call the method `shuffle` on itself. Since
    it’s a public method, other objects can call `shuffle` on Arrays, as well. That’s
    what `ShufflePlayer` does in our example. Since the return value of the `shuffle`
    method is also an Array, it can also call all of the methods of an Array, including
    `shuffle` again. Instead of reshuffling, however, we’ll call a method called `each`,
    which takes a block describing what to do to or with each element of the Array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We delimit blocks with braces, right? Sometimes. We could have implemented
    our `play` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, I chose to do it as I did to demonstrate the different ways you can
    use blocks in your code. Blocks can either start with `{` and end with `}`, or
    start with `do` and end with `end`. Different Ruby coders have different ideas
    about how best to notate blocks, but the convention seems to be that the brace
    delimiters are more appropriate for one-line blocks, and the `do` and `end` delimiters
    are more appropriate for multi-line blocks. This is the convention I will use
    in this book, and the one I use in my personal code. Ruby itself, however, doesn’t
    really care.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The different ways of delineating blocks have different precedences, for those
    who are curious. This means that Ruby will evaluate blocks delineated with *`{`*
    and *`}`* before evaluating blocks delineated with *`do`* and *`end`*. This fits
    well with how they are commonly used*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we call `each`, we have the word *file* within two pipe characters.
    Ruby coders who like American football sometimes call this the *goalpost*. The
    *goalpost* just tells the code within the `each` method what each element should
    be called within the block. Conceptually, it resembles an argument to a method,
    and later in the book, we’ll blur that distinction even more. In this case, we’re
    asking the `ShufflePlayer` to loop through each element of `@files`, call that
    element `file`, and call some method called `play_file`, taking `file` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Since we never need to call `play_file` from the outside, we can make it a private
    method, as shown at ❻. All `play_file` does is take an argument called `file`
    and use a method called `system` at ❼ in order to play that file argument using
    the `ogg123` program. As you might guess, `system` goes outside of Ruby and asks
    the operating system to do something—like play an audio file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*I have a large number of files in Ogg Vorbis audio format, so I use the ogg123
    program to play them. You can certainly replace ogg123 with mpg321 or any other
    command-line audio player*.'
  prefs: []
  type: TYPE_NORMAL
- en: The `play_file` method makes several assumptions, of course. It assumes that
    every file it’s asked to play will be playable with `ogg123`. It assumes that
    a command like `ogg123` *`some_file_name`* will be understandable by the operating
    system. Most glaringly, it assumes that there is a program called `ogg123` on
    the computer that runs this program. I wrote this program to play audio files
    on my computer at work, where it was safe for me to make these assumptions. This
    allowed the program to be much shorter, because it didn’t have to worry about
    checking for the existence of `ogg123`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You run this script as either `ruby -w shuffle_play.rb` *`some_ogg_files`* or
    `./shuffle_play.rb` *`some_ogg_files`*.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that I have explained our script, let’s try it out. These examples are within
    a bash shell in Linux, and use the long-winded version of `shuffle_play.rb`. The
    specific output you’ll see will depend heavily on the files you choose to play
    (represented by *`some_ogg_files`* in [Running the Script](ch02s04.html#running_the_script-id002
    "Running the Script") above). Since the shuffling is pseudo-random, successive
    runs will also probably be different, even on the same set of files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on another directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the bash shell expands the filenames from *.ogg before it
    ever gets to Ruby. All of those files are the arguments to our `ShufflePlayer`,
    which then plays them all in shuffled order, meaning that once it’s done with
    one file, it continues on to all the others without repeating any files. We’ll
    look at another approach to shuffled playback of audio files in two programs designed
    for radio station use later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Incidentally, if you’re interested in shorter programs, this entire program
    could be replaced by these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You could just have the second line if you always called the program as an argument
    to the Ruby interpreter, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I don’t think that extreme brevity at the expense of clarity is a goal to strive
    for, however, and I won’t be coding toward that end in this book. Brevity is particularly
    inappropriate for a book that means to teach people about programming, except
    to demonstrate alternative formats for the same functionality, as done here.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was new in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants versus magic numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions with the `||` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV[‘HOME’]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External file access, both reading and writing, using `File.new`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting Strings into Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing with `puts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating (pseudo-)random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Ruby programs at the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and instantiating new Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instance variables: `@i_am_an_instance_variable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ruby method naming conventions: predicate?, destructive!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to RDoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expression interpolation within Strings: `“#{interpolate_me}”`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ternary operator: (`expression ? if_true : if_false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ARGV`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `each` method with blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `system` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s a great deal of non-trivial information. If you’re relatively new to
    programming, have made it this far, and feel fairly comfortable with the content
    up to this point, you’ve accomplished something significant and praiseworthy.
    Congratulations. If you’re an old hand, hopefully this chapter has given you a
    good idea of how Ruby does some things you’ve already done in other languages.
  prefs: []
  type: TYPE_NORMAL
