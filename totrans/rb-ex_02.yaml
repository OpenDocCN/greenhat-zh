- en: Chapter 2. Amusements and Simple Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 娱乐和简单实用工具
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: From the previous chapter, you should now be relatively comfortable with irb
    and how Ruby deals with various expressions. Now we’ll try some Ruby programs
    that are stored in separate files and executed outside of irb. You can download
    all of these programs at [http://www.nostarch.com/ruby.htm](http://www.nostarch.com/ruby.htm).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，你应该现在对irb和Ruby如何处理各种表达式相对熟悉了。现在我们将尝试一些存储在单独文件中并在irb之外执行Ruby程序。你可以在[http://www.nostarch.com/ruby.htm](http://www.nostarch.com/ruby.htm)下载所有这些程序。
- en: We’ll run our programs with the `ruby` command, so when we want to run a script
    called `check_payday.rb`, we’ll type `ruby check_payday.rb` either at the shell
    in a Unix-like system or at the command prompt in Windows. We’ll also generally
    use the `-w` option, which means *turn warnings on*, making our example above
    become `ruby -w check_payday.rb`. It’s just a safer way to operate, and it is
    especially useful when learning a new language. We’ll also occasionally see Ruby
    Documentation (RDoc), which allows us to put relatively complex comments directly
    into our source code. We’ll discuss that in relation to the `99bottles.rb` example,
    where we first use it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ruby`命令来运行我们的程序，所以当我们想要运行名为`check_payday.rb`的脚本时，我们将在Unix-like系统的shell中或Windows的命令提示符中键入`ruby
    check_payday.rb`。我们通常还会使用`-w`选项，这意味着*开启警告*，使我们的示例变为`ruby -w check_payday.rb`。这仅仅是一种更安全的操作方式，而且在学习新语言时特别有用。我们偶尔也会看到Ruby文档（RDoc），它允许我们将相对复杂的注释直接放入源代码中。我们将在`99bottles.rb`示例中讨论这一点，我们第一次使用它。
- en: '#1 Is It Payday? (check_payday.rb)'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#1 是否是发工资日？（check_payday.rb）'
- en: This script is a simple utility that I use to remind myself when a payday is
    approaching. It is very much in the quick-and-dirty style, and intentionally so.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是一个简单的实用工具，我用它来提醒自己何时发工资。它非常简单直接，而且是故意这样做的。
- en: The Code
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How It Works
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Line ❶ is a hint to the computer that this program is in Ruby. The line at ❷
    is a comment meant for human readers that tells the name of the program. In Ruby,
    comments start with the `#` character and last until the end of the line.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ❶行是给计算机的一个提示，表明这个程序是用Ruby编写的。❷行的注释是为了人类读者而写的，它说明了程序的名字。在Ruby中，注释从`#`字符开始，直到行尾。
- en: Defining Constants
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义常量
- en: We define two constants at ❸. While constants only need to *start* with a capital
    letter, I like to use all caps to make them stand out. (This is a common convention
    in many languages and a good habit to get into.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第❸行定义了两个常量。虽然常量只需要*以大写字母开头*，但我喜欢使用全部大写字母来使它们更加突出。（这在许多语言中是一个常见的约定，也是一个好习惯。）
- en: The names of the constants `DAYS_IN_PAY_PERIOD` and `SECONDS_IN_A_DAY` should
    give you a good sense of what they mean—specifically, the number of days in a
    pay period and the number of seconds in a day. I get paid every two weeks, which
    is the same as every 14 days.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`DAYS_IN_PAY_PERIOD`和`SECONDS_IN_A_DAY`的名称应该能让你很好地理解它们的意义——具体来说，就是工资周期中的天数和一天中的秒数。我每两周发一次工资，也就是14天。
- en: The definition for `SECONDS_IN_A_DAY` uses multiplication (`60 * 60 * 24`),
    which is acceptable Ruby syntax, as you know from your experiments in irb. Representing
    these specific numbers as the result of multiplication instead of as one big final
    result is also more human readable, because a person reading this code will see
    and understand the relationship among 60 seconds in a minute, 60 minutes in an
    hour, and 24 hours in a day.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`SECONDS_IN_A_DAY`的定义使用了乘法（`60 * 60 * 24`），这是你从irb中的实验中知道的Ruby语法。将这些特定数字表示为乘法的结果而不是一个大的最终结果，也更容易阅读，因为阅读这段代码的人会看到并理解一分钟中的60秒、一小时中的60分钟和一天中的24小时之间的关系。'
- en: Why bother to define constants with more characters than the values they hold?
    While it doesn’t make a huge difference in this program, it’s a good habit to
    get into for larger programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要用比它们所持有的值更多的字符来定义常量呢？虽然在这个程序中这并没有太大的区别，但对于更大的程序来说，这是一个好习惯。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Constants are a very good idea. They allow you to avoid one of the sins of
    programming called* magic numbers, *which are examples of one of two programming
    sins: a literal value used repeatedly, or a literal value whose use is not obvious,
    even if it’s only used once. Defining such a value once with a meaningful name
    makes your code more readable to both other programmers and yourself, after you’ve
    forgotten everything about your program. Again, constants are a very good idea*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量是一个非常不错的想法。它们允许你避免编程中的一个罪恶，即*魔法数字*，*这是两种编程罪恶之一：重复使用的字面值，或者使用不明显的字面值，即使它只使用一次。用有意义的名称定义这样的值一次，可以使你的代码在程序员自己和其他程序员看来都更容易阅读，在你已经忘记了程序的所有内容之后。再次强调，常量是一个非常不错的想法*。'
- en: Defining Variables
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义变量
- en: 'Having defined our constants, we define a variable at ❹ called `matching_date`
    using Ruby’s built-in `Time.local` method. This method takes 10 items as arguments,
    in order: seconds, minutes, hours, day of the month, month, year, day of the week,
    day number within the year (1 through 366), whether the date is within daylight
    saving time, and a three-letter code for the time zone. The values used here are
    for September 22, 2006, which is a day that happened to be a payday for me. The
    day number within a year has a maximum of 366 instead of 365, because leap years
    have 366 days.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的常量后，我们使用 Ruby 的内置 `Time.local` 方法定义了一个变量，该变量在❹处被命名为 `matching_date`。此方法接受
    10 个参数，顺序为：秒、分钟、小时、月份中的天数、月份、年份、星期中的天数、年内天数（1 到 366）、日期是否在夏令时内，以及时区的三位字母代码。这里使用的值是
    2006 年 9 月 22 日，那天恰好是我的发薪日。年内天数最多为 366 而不是 365，因为闰年有 366 天。
- en: At ❺, we get the `current_date` using Ruby’s built-in `Time.new` method, and
    then subtract `matching_date` from it to get the difference, in seconds. Because
    we are much more interested in the difference in days rather than the difference
    in seconds, we divide the `difference_in_seconds` by the number of `SECONDS_IN_A_DAY`
    to get the difference in days, and then we round down by converting that result
    into an Integer with the `to_i` method. That gives us a useful value for our `difference_in_days`
    variable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在❺处，我们使用 Ruby 的内置 `Time.new` 方法获取 `current_date`，然后从其中减去 `matching_date` 以得到差值，单位为秒。因为我们更感兴趣的是天数差而不是秒数差，所以我们把
    `difference_in_seconds` 除以 `SECONDS_IN_A_DAY` 的数量来得到天数差，然后我们通过将结果转换为 Integer 来向下取整，这样我们就得到了
    `difference_in_days` 变量中的一个有用的值。
- en: The `difference_in_days` variable tells us the number of days since the last
    payday. However, because we really want our cash, we are more interested in how
    long we have to wait until the next payday. To find out, at ❻ we subtract the
    number of days since our last payday (the `difference_in_days` variable) from
    the number of `DAYS_IN_A_PAY_PERIOD` to get a new variable at ❼ called `days_to_wait`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference_in_days` 变量告诉我们自上次发薪以来有多少天。然而，因为我们真的想要我们的现金，所以我们更感兴趣的是我们还需要等待多久才能到下一次发薪。为了找出答案，在❻处，我们从上次发薪以来的天数（`difference_in_days`
    变量）中减去 `DAYS_IN_A_PAY_PERIOD` 的数量，以得到一个新的变量，在❼处被命名为 `days_to_wait`。'
- en: If `days_to_wait` has a value of zero, today must be payday, so at ❽ we output
    that information using Ruby’s built-in method `puts`. The `puts` method, which
    stands for *put string*, prints its String argument (`‘Payday today.’`, in our
    script) followed by an automatic carriage return, also called a *newline*. If
    `days_to_wait` is not zero, we use `puts` again to tell how many days we have
    to wait for payday, and as a convenience, we add the letter s to the word `day`
    if the number of days is plural.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `days_to_wait` 的值为零，今天必须是发薪日，所以在❽处我们使用 Ruby 的内置方法 `puts` 输出该信息。`puts` 方法代表
    *输出字符串*，它会打印其字符串参数（在我们的脚本中是 `‘Payday today.’`），然后自动换行，也称为 *换行符*。如果 `days_to_wait`
    不为零，我们再次使用 `puts` 来告知我们还需要等待多少天才能发薪，并且为了方便，如果天数是复数，我们在 `day` 这个词后面加上字母 s。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*We call both *`print`* and *`puts`* without parentheses enclosing the argument(s).
    This is perfectly legal, unless there would be some ambiguity about either the
    boundaries of an expression or the specific arguments to a method*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用不带括号的 `print` 和 `puts`。这是完全合法的，除非表达式或方法的特定参数存在歧义*。'
- en: That’s the whole program. There are more elegant ways to accomplish some of
    the tasks that this program does, but it introduces some new concepts, such as
    Constants, the `puts` method, and Dates. You can run it yourself and compare what
    it outputs to what your own actual pay schedule is, altering the `matching_day`
    variable accordingly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是整个程序。完成这个程序的一些任务有更优雅的方法，但它引入了一些新的概念，例如常量、`puts`方法和日期。您可以亲自运行它，并将它输出的结果与您自己的实际发薪日表进行比较，相应地调整`matching_day`变量。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Readers familiar with crontab may find it interesting that I run this on my
    machine with the following crontab entry: *`ruby ~/scripts/check_payday.rb | mutt
    -s “payday” kbaird`**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*熟悉crontab的读者可能会发现，我在我的机器上使用以下crontab条目来运行这个脚本：* `ruby ~/scripts/check_payday.rb
    | mutt -s “payday” kbaird`**。'
- en: The Results
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Your result should be a message along the lines of *Payday in 10 days*, depending
    on the day you run the program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果应该是一条类似*“10天后发薪日”*的消息，具体取决于您运行程序的日子。
- en: '#2 Random Signature Generator (random_sig.rb and random_sig-windows.rb)'
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#2 随机签名生成器（random_sig.rb和random_sig-windows.rb）'
- en: The next script generates dynamic content for email signatures, adding standard
    information, like a name and email address, to a random quotation drawn from a
    known file. The Unix and Windows versions need to be slightly different, so they
    have been separated into two distinct files. I’ll talk about the Unix version
    first, but will include the source code for both files. In this example, we’ll
    also see how Ruby handles complex assignments. That’s a lot of information to
    cover.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本为电子邮件签名生成动态内容，将标准信息，如姓名和电子邮件地址，添加到从已知文件中随机抽取的引语中。Unix和Windows版本需要略有不同，因此它们被分离成两个不同的文件。我将首先讨论Unix版本，但会包含两个文件中的源代码。在这个例子中，我们还将看到Ruby如何处理复杂的赋值。这需要覆盖很多信息。
- en: The Code
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How It Works
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: At ❶, we assign a value to a variable called `filename`, but the value that
    goes into it is somewhat more complex than a single straightforward number or
    String. `ARGV` is an example of an environment variable. Environment variables
    are described in [Chapter 1](ch01.html "Chapter 1. Interactive Ruby and the Ruby
    Environment"). For historical reasons, `ARGV` stands for *Argument Vector* and
    is an Array of the command-line arguments to any program when it is run.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们给一个名为`filename`的变量赋值，但放入其中的值比一个简单的数字或字符串要复杂得多。`ARGV`是一个环境变量的例子。由于历史原因，`ARGV`代表*Argument
    Vector*，它是任何程序在运行时命令行参数的数组。
- en: That’s not the whole line, though. Just as the equals sign is an operator that
    puts a value into something, the double-bar (`||`) is an operator that means *or*.
    Let’s use irb to see how it works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是整行。正如等号是一个将值放入某物的运算符一样，双竖线（`||`）是一个表示“或”的运算符。让我们使用irb来看看它是如何工作的。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An expression with the `||` operator evaluates whatever is to the left of it.
    If it is true, the whole expression has that value, whatever possible true value
    it happens to be. If the left side is false, the whole expression has the value
    on the right of the `||`, whatever that value is—`true, false, nil`, whatever.
    Missing arguments are `nil`, and `nil` evaluates to `false` when tested by `||`.
    The elements of `ARGV` start counting with zero, just like all Arrays in Ruby
    (and many other languages). Our `filename` variable is either the first argument
    to this program, or if there is no argument, it’s set to all of that business
    within the parentheses: `(ENV[‘HOME’] + ‘/scripts/sig_quotes.txt’)`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`||`运算符的表达式评估其左侧的内容。如果左侧为真，整个表达式的值就是该值，无论它碰巧是哪个可能的真值。如果左侧为假，整个表达式的值就是`||`右侧的值，无论该值是什么——`true`、`false`、`nil`，无论什么。缺少的参数是`nil`，并且当通过`||`测试时，`nil`评估为`false`。`ARGV`的元素从零开始计数，就像Ruby中的所有数组（以及许多其他语言）一样。我们的`filename`变量要么是程序的第一个参数，要么如果没有参数，它就设置为括号内的所有内容：`(ENV[‘HOME’]
    + ‘/scripts/sig_quotes.txt’)`。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Windows users will need to use *`(ENV[‘HOMEDRIVE’] + ENV[‘HOMEPATH’])`* instead
    of *`ENV[‘HOME’]`*. We’ll talk more about that in the Windows version of the script*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Windows用户需要使用* `(ENV[‘HOMEDRIVE’] + ENV[‘HOMEPATH’])` *代替* `ENV[‘HOME’]`*。我们将在脚本的Windows版本中详细讨论这一点。'
- en: '`ENV` is an environment variable, as the abbreviation suggests, and the parentheses
    indicate expression boundaries, just as in a math expression, like `(5 + 2) *
    2 = 14`. `ENV[‘HOME’]` is simply a way for you to get to the directory that belongs
    to a specific user. For my username, *kbaird*, this would be something like `/home/kbaird`,
    or `/Users/kbaird` under Mac OS X. The home directory is analogous to the My Documents
    folder in Windows.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV` 是一个环境变量，正如其缩写所暗示的，括号表示表达式边界，就像在数学表达式中一样，例如 `(5 + 2) * 2 = 14`。`ENV[''HOME'']`
    简单来说就是让你到达属于特定用户的目录。对于我的用户名 *kbaird*，这可能是 `/home/kbaird`，或者在 Mac OS X 下的 `/Users/kbaird`。家目录在
    Windows 中类似于我的文档文件夹。'
- en: '`ENV[‘HOME’]` is a String, and in our expression, we add it to the String `‘/scripts/sig_quotes.txt’`.
    All this means is that our filename has a default value of `sig_quotes.txt`, within
    the `scripts` directory, within the user’s home directory. Now we know the name
    of the file to read quotations from, so let’s use it.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV[''HOME'']` 是一个字符串，在我们的表达式中，我们将其添加到字符串 `‘/scripts/sig_quotes.txt’`。这全部意味着我们的文件名有一个默认值
    `sig_quotes.txt`，位于 `scripts` 目录下，位于用户的家目录中。现在我们知道了读取引言的文件名，所以让我们使用它。'
- en: 'Ruby creates new external File objects with `File.new()`, which takes two arguments:
    the name of the file and the manner in which you want to use that file. In this
    case, we want to read from the file, so at ❷ we give it a second argument of `‘r’`,
    which naturally stands for *read*. We call this file `quotations_file` and read
    its lines into a variable called `file_lines`. Since we’re now done with the file,
    we can close it, which we do at ❸.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用 `File.new()` 创建新的外部文件对象，它接受两个参数：文件的名称以及你想要使用该文件的方式。在这种情况下，我们想要从文件中读取，所以在
    ❷ 我们给它第二个参数 `‘r’`，它自然代表 *read*。我们称这个文件为 `quotations_file`，并将它的行读取到一个名为 `file_lines`
    的变量中。由于我们现在已经完成了文件操作，我们可以关闭它，我们在 ❸ 处这样做。
- en: The new variable `file_lines` is an Array with each line of the quotations file
    as a single element. What do we do when we want longer quotations? We’ve taken
    care of that at ❹ by combining those lines into a String with our old friend the
    `to_s` method, and turning it back into an Array with a method called `split`,
    which takes a breakpoint argument to break a String into chunks. Let’s see it
    in action.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 新变量 `file_lines` 是一个数组，其中每个元素都是引言文件的单独一行。当我们想要更长的引言时，我们已经在 ❹ 处处理了这个问题，通过使用我们老朋友
    `to_s` 方法将这些行组合成一个字符串，然后使用一个名为 `split` 的方法将其转换回数组，该方法接受一个断点参数来将字符串分割成块。让我们看看它是如何工作的。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our program, we’re breaking on a double line break, which is represented
    in Ruby, as in many other languages, with `\n\n`. We now have a variable called
    `quotations`, which is an Array, each member of which is a quotation from our
    external file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们是在双行断处进行分割，这在 Ruby 中表示为 `\n\n`，正如在许多其他语言中一样。我们现在有一个名为 `quotations`
    的变量，它是一个数组，其中的每个成员都是来自外部文件的引言。
- en: We want to choose a random quotation, and elements of Arrays are conveniently
    stored with indices, so a very appropriate way to choose a random element from
    an Array is to generate a random number within the range of the Array’s indices,
    and then read the element out of the Array at that index. That’s precisely what
    we do at ❺ with the `rand` method, into which we pass the `size` of the quotations
    Array. We place the specific quotation chosen into a variable at ❻ with the apt
    name `quotation`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要选择一个随机的引言，数组的元素可以通过索引方便地存储，所以从数组中选择一个随机元素的一个非常合适的方法是在数组的索引范围内生成一个随机数，然后从数组中读取该索引处的元素。这正是我们在
    ❺ 处使用 `rand` 方法所做的事情，我们将 `quotations` 数组的 `size` 传递给它。我们将选定的特定引言放入一个名为 ❻ 的变量中，命名为
    `quotation`。
- en: Now that we have a quotation, what can we do with it? We want to write it out
    to our signature file. We usually print things with `puts`, which we used in [#1
    Is It Payday? (check_payday.rb)](ch02.html#sharp1_is_it_payday_check_paydayrb
    "#1 Is It Payday? (check_payday.rb)") on page 14\. Let’s try it out in a new irb
    session.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了引言，我们可以用它做什么呢？我们想要将其写入我们的签名文件。我们通常使用 `puts` 来打印东西，就像我们在第 14 页的 [#1 Is
    It Payday? (check_payday.rb)](ch02.html#sharp1_is_it_payday_check_paydayrb "#1
    Is It Payday? (check_payday.rb)") 中使用的 [check_payday.rb](ch02.html#sharp1_is_it_payday_check_paydayrb)
    一样。让我们在一个新的 irb 会话中试试。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll notice that `puts` outputs whatever argument you give it, but the value
    it *returns* is `nil`. It’s important to keep that distinction in mind. If you
    use `puts` on a file, it will print its argument to that file instead of printing
    to the screen. We already know that we can read from external files with a second
    argument of `‘r’`. Similarly, we can write to an external file with a second argument
    of `‘w’`, which is the way we open `signature_file` at ❼. Let’s take a look at
    the way `puts` behaves in irb.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`puts`会输出你给出的任何参数，但它返回的值是`nil`。记住这个区别很重要。如果你在文件上使用`puts`，它将打印其参数到该文件而不是打印到屏幕。我们已经知道我们可以使用第二个参数`‘r’`从外部文件中读取。同样，我们可以使用第二个参数`‘w’`将数据写入外部文件，这是我们在第❽处打开`signature_file`的方式。让我们看看`puts`在irb中的行为。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `puts` method continues to return `nil`, but take a look at a new file called
    `test_file` inside your home directory. It should now contain the text *Write
    some content*, proving that `puts` can easily print to a file, as well. Note that
    we use a filename that means *The file called .signature within the user’s home
    directory*, which is the traditional location for email signature files. All that’s
    left is to write a standard header at ❽, add the randomly-chosen quotation, and
    then close the signature file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`puts`方法继续返回`nil`，但看看你主目录内新创建的名为`test_file`的文件。它现在应该包含文本*Write some content*，这证明`puts`也可以轻松地将内容打印到文件中。注意我们使用的文件名意味着*用户主目录中的.file签名文件*，这是电子邮件签名文件的传统位置。剩下要做的就是写入标准标题在第❽，然后添加随机选择的引语，最后关闭签名文件。'
- en: If you use a Unix-like operating system, you can put a call to this program
    in a crontab,^([[8](#ftn.CHP-2-FNOTE-1)]) as I do on my Debian machine. Windows
    users can modify the script to write a signature file with whatever name they
    choose, and then change the settings of their email program to use that signature
    file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用类Unix操作系统，你可以将对该程序的调用放入crontab中，^([[8](#ftn.CHP-2-FNOTE-1))) 就像我在我Debian机器上做的那样。Windows用户可以修改脚本以写入他们选择的任何名称的签名文件，然后更改他们电子邮件程序的设置以使用该签名文件。
- en: Running the Script
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: This is run with `ruby -w random_sig.rb` (to assume the default `sig_quotes.txt`
    file), or `ruby -w random_sig.rb` *`some_file`*, replacing *`some_file`* with
    the name of your preferred version of `sig_quotes.txt`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ruby -w random_sig.rb`（假设默认的`sig_quotes.txt`文件）运行此脚本，或者使用`ruby -w random_sig.rb`
    *`some_file`*，将*`some_file`*替换为你喜欢的`sig_quotes.txt`版本名称。
- en: The Results
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Here are my results. The `$` denotes a bash prompt on my GNU/Linux system. I
    add an additional `cat ~/.signature` (which just shows the contents of `~/.signature`)
    to show the results, since the script writes to that file instead of printing
    to the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的结果。`$` 表示我的GNU/Linux系统上的bash提示符。我额外添加了`cat ~/.signature`（它只显示`~/.signature`的内容）来显示结果，因为脚本将写入该文件而不是打印到屏幕上。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Hacking the Script
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: Take a look at the Windows source code below, and try to figure out the changes
    before continuing on to my explanation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的Windows源代码，在继续我的解释之前，试着找出变化。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only significant differences relate to the filesystem, which is how the
    operating system and programs access your machine’s hard drive, CD-ROM drive,
    and so on. Windows uses a separate drive letter, which is represented by `ENV[‘HOMEDRIVE’]`,
    and a path within that drive letter, which is represented by `ENV[‘HOMEPATH’]`.
    Because of the greater complexity of the Windows definition of *home*, we have
    put it into a variable in this version of the script at ❶. The only other differences
    are the use of backslashes rather than forward slashes at ❷ and ❸.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的重大差异与文件系统有关，这是操作系统和程序访问你的机器硬盘、CD-ROM驱动器等的方式。Windows使用单独的驱动器字母，它由`ENV[‘HOMEDRIVE’]`表示，以及该驱动器字母内的路径，它由`ENV[‘HOMEPATH’]`表示。由于Windows对*家*的定义更加复杂，我们在脚本中将它放入了一个变量中在第❶。唯一的其他差异是在第❷和❸处使用反斜杠而不是正斜杠。
- en: '* * *'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[8](#CHP-2-FNOTE-1)]) A crontab is just a way for Unix machines to schedule
    operations. If you use a Unix-like operating system, just execute `man crontab`
    at the shell. If you use Windows, you can use Windows Scheduler with a batch file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-2-FNOTE-1))) crontab只是Unix机器安排操作的一种方式。如果你使用类Unix操作系统，只需在shell中执行`man
    crontab`即可。如果你使用Windows，可以使用批处理文件配合Windows计划任务。
- en: '#3 The 99 Bottles of Beer Song (99bottles.rb)'
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#3 啤酒瓶歌（99bottles.rb）'
- en: This script demonstrates basic Object Orientation by singing (okay, printing)
    the “99 Bottles of Beer” song. The content of the example may be a bit contrived,
    but the program itself reveals a great deal about naming conventions in Ruby.
    We’ll be defining a Wall, on which there are bottles, the number of which repeatedly
    drops by one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本通过（好吧，打印）“99 瓶啤酒”这首歌来演示基本的面向对象。示例的内容可能有点牵强，但程序本身揭示了 Ruby 中许多命名约定的信息。我们将定义一个
    Wall，上面有瓶子，其数量会反复减一。
- en: Here’s the code. Classes are the basic building blocks in Ruby, so it’s worthwhile
    for anyone curious about the language to understand them in some depth. We’ve
    already seen some built-in classes (String, Integer, and Array), so they’re not
    a fundamentally new concept for you at this point. What is new is the ability
    to define completely novel classes of your own, as we do below.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码。类是 Ruby 中的基本构建块，所以对于任何对这种语言感兴趣的人来说，深入理解它们是很有价值的。我们已经看到了一些内置的类（String、Integer
    和 Array），所以在这个阶段它们对你来说不是一个全新的概念。新的地方在于能够定义完全新颖的类，就像我们下面做的那样。
- en: The Code
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How It Works
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: We define classes using the keyword *class* followed by whatever name we choose,
    which we do at ❶ for the class `Wall`. Classes must start with an uppercase letter,
    and it is traditional to use mixed case, as in *MultiWordClassName*. Our class
    is called *Wall*, which conjures up a real-world object in a reader’s mind. This
    is the wall in the song on which the bottles sit.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关键字 `class` 后跟我们所选择的任何名称来定义类，我们在 ❶ 处为类 `Wall` 做了这样的事情。类必须以大写字母开头，并且传统上使用混合大小写，例如
    *MultiWordClassName*。我们的类叫做 *Wall*，这会在读者的脑海中唤起一个现实世界的对象。这是歌曲中瓶子放置的墙壁。
- en: It is also traditional to define a class in a file with the same name by using
    all lowercase letters and underscores between the words, if the name consists
    of multiple words (i.e., `multi_word_class_name.rb`). This is just a convention,
    but it is a widely followed one, and if you decide to use Rails, using this convention
    will make your life much easier.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样传统的是，如果类名由多个单词组成，则在文件中使用所有小写字母和单词之间的下划线来定义类（即 `multi_word_class_name.rb`）。这只是个约定，但它是一个广泛遵循的约定，如果你决定使用
    Rails，遵循这个约定将使你的生活变得更加容易。
- en: If our wall just sat there and did nothing, there would be little point in creating
    it. We want our wall to be able to take some sort of action. These actions are
    methods, just like those we’ve already encountered. We’ve already defined functions
    with the `def` keyword. Now we’ll do so within a class—this attaches the function
    we’re defining to that class, making it a *method* of that class.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的墙壁只是坐那里什么也不做，那么创建它的意义就很小了。我们希望我们的墙壁能够执行某种动作。这些动作是方法，就像我们之前遇到的那样。我们已经使用
    `def` 关键字定义了函数。现在我们将在类内部这样做——这会将我们正在定义的函数附加到该类上，使其成为该类的 *方法*。
- en: Every class should have a method called `initialize`, which is what that class
    uses when it creates itself. From the outside, we call the method `new`, but the
    class itself uses the name `initialize`. (We’ll talk about why that distinction
    exists shortly.) Our wall’s `initialize` method, defined at ❷, takes one argument
    called `num_of_bottles`. It then sets the value of a variable called `@bottles`
    equal to whatever `num_of_bottles` is. Why does `@bottles` have the @ sign in
    front of it? The @ sign is how Ruby indicates that something is what’s called
    an *instance variable*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都应该有一个名为 `initialize` 的方法，这是该类在创建自身时使用的方法。从外部来看，我们称这个方法为 `new`，但类本身使用的是 `initialize`
    这个名字。（我们很快就会讨论为什么存在这种区别。）我们的墙壁 `initialize` 方法，在 ❷ 处定义，接受一个名为 `num_of_bottles`
    的参数。然后它将一个名为 `@bottles` 的变量的值设置为 `num_of_bottles` 的值。为什么 `@bottles` 前面有一个 @ 符号？@
    符号是 Ruby 表示某个东西是一个所谓的 *实例变量* 的方式。
- en: An *instance variable* is just a characteristic of some thing. If we have a
    class called Person, each person could have characteristics like a name, an age,
    a gender, and so on. These characteristics are all good examples of instance variables,
    because they could (and do) differ from person to person. Just as a Person has
    an age, a Wall has a certain number of bottles on it. Our wall happens to have
    99 bottles on it, because we’ve told it to have that many. Let’s try a different
    number of bottles in irb. You can bring external content into an irb session with
    the `-r` command-line flag, which stands for *require*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例变量*只是某些事物的特征。如果我们有一个名为`Person`的类，每个人都可以有诸如姓名、年龄、性别等特征。这些特征都是实例变量的好例子，因为它们可以（并且确实）因人而异。就像`Person`有一个年龄一样，`Wall`有一个特定的瓶子数量。我们的墙恰好有99个瓶子，因为我们告诉它要有那么多。让我们在irb中尝试不同的瓶子数量。你可以使用带有`-r`命令行标志的外部内容，该标志代表*require*。'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see from the returned value that `@bottles` is set to 10 in the case
    of our new variable, `other_wall`. Both `wall` and `other_wall` are examples (or
    instances) of the class Wall. They differ in key ways, such as the number of bottles
    they hold.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从返回值中我们可以看出，在我们的新变量`other_wall`的情况下，`@bottles`被设置为10。`wall`和`other_wall`都是`Wall`类的一个例子（或实例）。它们在关键方面有所不同，例如它们能容纳的瓶子数量。
- en: All we want to do when we create a new wall is set its number of bottles, so
    at ❸ we declare the end of the method after setting the value of `@bottles`. After
    we’ve created our wall, we’ll ask the wall if it has any bottles left. We will
    implement this with a method called `empty?`, which we define at ❹. Note the question
    mark, which is a perfectly legitimate part of the method’s name. Ruby has inherited
    a tradition from its ancestor Lisp of naming methods with a question mark when
    they return either *true* or *false*. Such methods that only return a Boolean
    are called *predicates*. It should be clear that a wall is either empty or not
    empty, so the `empty?` method is a predicate, since it will return either `true`
    or `false`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的墙时，我们只想设置它的瓶子数量，所以在❸处，我们在设置`@bottles`的值后声明方法的结束。在我们创建我们的墙之后，我们将询问墙是否还有剩余的瓶子。我们将通过一个名为`empty?`的方法来实现这一点，我们在❹处定义它。注意问号，它是方法名称的一个完全合法的部分。Ruby从其祖先Lisp那里继承了一种传统，即当方法返回`true`或`false`时，用问号命名方法。仅返回布尔值的这些方法被称为*predicates*。很明显，墙要么是空的，要么不是空的，所以`empty?`方法是一个predicates，因为它将返回`true`或`false`。
- en: We also include some RDoc at ❹, before the definition of the `empty?` method.
    The way to indicate RDoc comments is to have the text `=begin rdoc` flush left,
    with no whitespace before it. Ruby will consider everything after `=begin rdoc`
    and before `=end`, also flush left with no preceding whitespace, to be a comment
    meant to be read by a human, not something to be executed. RDoc allows HTML-like
    tagging, as shown in the boldfaced `Boolean` in our script. RDoc also allows a
    variety of other markup options, which we’ll discuss in greater detail later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`empty?`方法的定义之前，也包含了一些RDoc注释❹。表示RDoc注释的方式是将文本`=begin rdoc`左对齐，前面没有空格。Ruby会将`=begin
    rdoc`之后和`=end`之前的所有内容，也左对齐且前面没有前置空格，视为供人类阅读的注释，而不是要执行的内容。RDoc允许使用类似HTML的标签，正如我们脚本中加粗的`Boolean`所示。RDoc还允许使用各种其他标记选项，我们将在稍后更详细地讨论。
- en: The instance variable `@bottles` is a number, represented as an instance of
    Integer in Ruby. Integers have a built-in method called `zero?`, which simply
    tells us whether or not that Integer is zero. This is an example of a predicate
    that was already there for us to use, and it follows the question mark naming
    convention. Our definition of `empty?` for the class Wall also uses parentheses
    to show that it doesn’t accept any arguments. It’s often a good idea to refer
    to methods using parentheses, even in cases like this where there are no arguments
    involved. The main reason for doing so is to make it clear that you’re dealing
    with a method and not a variable. Since you can define both methods and variables,
    and both are made of lowercase letters, the parentheses help Ruby distinguish
    between the two.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量`@bottles`是一个数字，在Ruby中表现为Integer的实例。整数有一个内置的方法叫做`zero?`，它简单地告诉我们这个整数是否为零。这是一个已经为我们准备好的、遵循问号命名约定的predicates的例子。我们为`Wall`类定义的`empty?`也使用括号来表示它不接受任何参数。在没有任何参数的情况下，通常引用方法时使用括号是一个好主意。这样做的主要原因是为了清楚地表明你正在处理一个方法，而不是一个变量。由于你可以定义方法和变量，并且两者都由小写字母组成，括号有助于Ruby区分两者。
- en: A song is made to be sung, so we want to tell the Wall how to do so. We’ll define
    a method at ❺ called `sing_one_verse!`. Just as `empty?` uses a question mark,
    `sing_one_verse!` ends with an exclamation point (also called a *bang*), which
    indicates that the method is destructive. *Destructive* methods change the state
    of their object, which means that they perform some action on their object that
    persists after the method has been called.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一首歌是为了被唱的，所以我们要告诉 Wall 如何做到这一点。我们将在 ❺ 处定义一个名为 `sing_one_verse!` 的方法。就像 `empty?`
    使用问号一样，`sing_one_verse!` 以感叹号结尾（也称为 *bang*），这表示该方法是有破坏性的。*有破坏性* 的方法会改变它们对象的状态，这意味着它们在调用方法后会对对象执行一些持续的动作。
- en: The verse that `sing_one_verse!` has the responsibility to output has some internal
    repetition, so it only makes sense to break up that repetition and abstract it.
    We do this with the `sing` method, which takes an optional String argument called
    `extra`. This optional argument represents any additions to some boilerplate about
    the number of bottles remaining. The one-line expression at ❼, inside the `sing`
    method, has some things we haven’t seen before.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`sing_one_verse!` 负责输出的诗句有一些内部重复，所以只有将其分解并抽象出来才有意义。我们通过 `sing` 方法来做这件事，该方法接受一个可选的字符串参数，称为
    `extra`。这个可选参数代表对关于剩余瓶子数量的某些样板文本的任何添加。在 `sing` 方法内部的 ❼ 行中有一个一行表达式，其中包含一些我们之前没有看到的东西。'
- en: 'Sometimes we want to have the value of an expression appear inside a String.
    This process is called *interpolation*, and Ruby does it, as we’ll show here in
    irb:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们希望在字符串中显示表达式的值。这个过程被称为 *插值*，Ruby 会这样做，就像我们在这里用 irb 展示的那样：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we use double quotation marks and wrap an expression within `#{}`, the
    expression is evaluated before it is inserted into the String. When we use single
    quotation marks or omit the `#{}` wrapper, all the text simply appears literally,
    even if that text happens to be a valid expression, such as the name of a variable.
    The combination of double quotation marks and the `#{}` wrapper is a way to tell
    Ruby that you want interpolation to occur.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用双引号并将表达式包裹在 `#{}` 中时，表达式在插入到字符串之前会被评估。当我们使用单引号或省略 `#{}` 包装器时，所有文本都会以字面意义出现，即使这些文本碰巧是有效的表达式，比如变量的名称。双引号和
    `#{}` 包装器的组合是一种告诉 Ruby 你想要进行插值的方式。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you want to have double quotation marks within a String that uses interpolation,
    you can use %Q, like this: *`%Q[I am an interpolating String. Call me “#{ ‘Ishmael’
    }”.]`*. Note that the delimiter does not have to be a bracket and could be conceivably
    any character. Common choices are* *`[`*, {‘, and *`!`*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想在使用插值的字符串中包含双引号，你可以使用 %Q，如下所示：* `%Q[I am an interpolating String. Call
    me “#{ ‘Ishmael’ }”.]`*. 注意，分隔符不必是括号，理论上可以是任何字符。常见的选项有 *`[`*，`{‘` 和 *`!`*。'
- en: The `sing` method also does some testing based on the number of bottles left.
    This determines the specific output that it returns. Critical to this is the fact
    that we can interpolate any expression, not just variables. The first expression
    within the interpolation at ❼ is a test that checks if the value of `@bottles`
    is greater than zero. If it is, that first expression evaluates to `@bottles`,
    otherwise it evaluates to the String `‘no more’`. We do this with what we call
    the *ternary operator*. Let’s look at the ternary operator a bit in irb as well.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`sing` 方法还会根据剩余瓶子的数量进行一些测试。这决定了它返回的具体输出。对此至关重要的是，我们可以插值任何表达式，而不仅仅是变量。插值中的第一个表达式在
    ❼ 处是一个测试，检查 `@bottles` 的值是否大于零。如果是，第一个表达式计算结果为 `@bottles`，否则计算结果为字符串 `‘no more’`。我们通过所谓的
    *三元运算符* 来做这件事。让我们在 irb 中也稍微看看三元运算符。'
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The ternary operator examines whatever is to the left of the question mark;
    it evaluates to whatever immediately follows the question mark if the examined
    expression is true, and evaluates to whatever follows the colon otherwise. You
    can think of it as another way to implement flow control that is sometimes more
    convenient than an `if` test. The next expression at ❼ that uses a ternary evaluates
    to either the word *bottle* or the word *bottles*, as appropriate in English for
    the number of bottles the wall currently has. We then concatenate information
    that says that these are bottles of beer, rather than some other liquid, and add
    the `extra` argument. Since the argument defaults to the empty string, and concatenating
    the empty string onto something has no visible effect, we’re safe when there is
    no argument.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符检查问号左边的表达式；如果检查的表达式为真，则评估为问号后面的表达式，否则评估为冒号后面的表达式。你可以将其视为实现流程控制的一种方式，有时比`if`测试更方便。在下一行代码中，使用三元运算符的表达式评估为单词*bottle*或单词*bottles*，这取决于墙上当前有多少瓶啤酒。然后我们附加信息说明这些是啤酒瓶，而不是其他液体，并添加`extra`参数。由于参数默认为空字符串，将空字符串附加到某个东西上没有明显效果，所以当没有参数时我们很安全。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Actually, this is just* a *ternary operator. It just happens to be the most
    common one, and therefore, it often gets special naming treatment. It is the only
    built-in ternary operator in Ruby*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，这只是一个三元运算符。它恰好是最常见的一个，因此经常得到特殊的命名处理。这是Ruby中唯一的内置三元运算符*。'
- en: After singing a verse, we take a bottle of beer down with `take_one_down!`,
    the method defined at ❽, again named with a bang. We’ve grouped together the actions
    of taking a bottle away and reporting that fact, which seems to make sense, conceptually.
    Since Ruby methods return the last expression evaluated, this method returns the
    String `‘take one down, pass it around, ’`, which gets incorporated into the entire
    verse inside `sing_one_verse!`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在唱完一段歌词后，我们用`take_one_down!`这个方法来喝下一瓶啤酒，这个方法在第❽处定义，同样以感叹号命名。我们将取走一瓶啤酒并报告这一事实的动作组合在一起，这在概念上似乎是有道理的。由于Ruby方法返回最后一个表达式评估的结果，这个方法返回字符串`‘take
    one down, pass it around, ’`，这个字符串被整合到整个歌词中的`sing_one_verse!`方法内部。
- en: We finish all of these method definitions with the `end` keyword, and use `end`
    again to finish the class definition. So we’re done—except for the word *private*,
    which we define at ❻. To see how this works, let’s open up irb again and instantiate
    a new Wall.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`end`关键字结束所有这些方法定义，并再次使用`end`来结束类的定义。所以我们已经完成了——除了在第❻处定义的单词*private*。为了了解这是如何工作的，让我们再次打开irb并实例化一个新的Wall对象。
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only class that can access methods that we’ve defined after the appearance
    of the word *private* is the class itself. The other methods that can be accessed
    from the outside are called *public* methods. Why the distinction? It allows us
    to define an interface for an object that doesn’t change. We can mess around under
    the hood and change everything about how the class actually accomplishes its responsibilities,
    while no one outside the class has any idea that anything has changed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在单词*private*出现之后定义的方法才能被该类本身访问。其他可以从外部访问的方法被称为*public*方法。为什么要有这种区分？这是因为它允许我们为对象定义一个不变的接口。我们可以在内部随意修改并改变类实际完成其职责的方式，而外部的人却没有任何意识到有任何变化。
- en: Using classes in this way is especially useful when working on larger projects
    with other programmers. You can define your class, complete with public methods
    that your other team members know about, and write little stub versions of those
    methods that return legal values with some temporary hard-coded approach. This
    allows your colleagues to start work on their classes, which might depend on the
    output of your class’ methods, even before you have written the real versions
    of those methods. This is very convenient.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用类在与其他程序员一起进行大型项目开发时特别有用。你可以定义你的类，包括其他团队成员所知的公共方法，并编写那些方法的小型占位符版本，这些方法返回一些临时硬编码的合法值。这允许你的同事在你编写这些方法的实际版本之前，就开始他们的类的工作，这些类可能依赖于你的类方法的输出。这非常方便。
- en: By the way, the `new` versus `initialize` distinction we saw earlier is a public
    versus private distinction. The `initialize` method is automatically private,
    and the (public) `new` method of any object automatically calls the (private)
    `initialize` method of that same object. That’s why we create an `initialize`
    method when we write completely new classes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们之前看到的 `new` 与 `initialize` 的区别是公共与私有的区别。`initialize` 方法默认是私有的，任何对象的（公共的）`new`
    方法会自动调用该对象（私有的）`initialize` 方法。这就是为什么我们在编写全新的类时创建一个 `initialize` 方法。
- en: Running the Script
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Let’s try this one out in irb with `irb -r 99bottles.rb`. Note that this will
    output all 99 verses of this song, so don’t be surprised when you see it happen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 irb 中尝试这个 `irb -r 99bottles.rb`。请注意，这将输出这首歌的所有 99 首诗，所以当你看到它发生时不要感到惊讶。
- en: The Results
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s a brief section of the output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出的一部分简短说明：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#4 Sound File Player (shuffle_play.rb)'
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#4 声音文件播放器（shuffle_play.rb）'
- en: In this script, we’ll make a program that plays music files in a shuffled order.
    We explored classes in the previous example, and we’ll learn more about them here.
    What happens when we want to have a class that is very similar to an existing
    class? We have several options.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们将创建一个以随机顺序播放音乐文件的程序。我们在前面的例子中探讨了类，我们将在这里了解更多关于它们的内容。当我们想要一个与现有类非常相似的类时会发生什么？我们有几种选择。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This version is fairly Unix-centric. You can download a Windows version that
    uses the Winamp player at* [http://www.nostarch.com/ruby.htm](http://www.nostarch.com/ruby.htm).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个版本相当侧重于 Unix。您可以在[http://www.nostarch.com/ruby.htm](http://www.nostarch.com/ruby.htm)下载一个使用
    Winamp 播放器的 Windows 版本*。'
- en: In Ruby, we know that everything is an object, which is just another way of
    saying that it’s a member (or instance) of a class. We know about well-defined
    classes like Arrays, Strings, Integers, and so on. All of these are what we call
    *open classes*, meaning that we can add code to existing classes. For example,
    we could change all of the Arrays in our programs so that they have a new method,
    and that change would affect any and all Arrays. We don’t have to create a new
    special type of Array to add this hypothetical new method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，我们知道一切都是对象，这仅仅是一种说法，即它是类的一个成员（或实例）。我们了解诸如 Arrays、Strings、Integers 等定义良好的类。所有这些都是我们所说的
    *开放类*，这意味着我们可以向现有类中添加代码。例如，我们可以更改我们程序中的所有 Arrays，使它们拥有一个新方法，这个更改将影响任何和所有的 Arrays。我们不必创建一个新的特殊类型的
    Array 来添加这个假设的新方法。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Old hands at Object Orientation will recognize the creation of a new type
    of class that is otherwise similar to an existing class as using* inheritance.
    *We’ll address inheritance in Ruby in a later chapter*.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*经验丰富的面向对象开发者会认出，创建一个与现有类相似但属于新类型的新类，这相当于使用*继承。*我们将在后面的章节中讨论 Ruby 中的继承*。'
- en: Our shuffle player will need to deal with a list of files. The built-in class
    Array is very well-suited to acting as a list of items, so we’ll base our player
    around an Array of files. In doing so, we’ll also add some behavior to all Arrays
    that will make it easier to deal with the shuffled playback we want to implement.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理一个文件列表。内置的类 Array 非常适合作为项目列表，因此我们将我们的播放器基于一个文件数组。这样做的同时，我们也会给所有数组添加一些行为，这将使得实现我们想要的随机播放更容易。
- en: The Code
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How It Works
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We use two different class definitions in this example: one in which we open
    the Array class to add behavior to it, and another in which we create a completely
    novel class called `ShufflePlayer`. One key method that we add to the Array class
    at ❶ is `shuffle`. Arrays already have two methods that are very handy: `sort_by`
    and `rand`. You’ll notice that `sort_by` is followed by the opening brace character
    (`{`), then the `rand` method, then the closing brace (`}`). This content between
    the opening and closing braces is a *block*, which is central to how Ruby transforms
    or iterates over collections of data, like Arrays (among other things). The `sort_by`
    method is a sorting operation that takes a block argument, which determines the
    manner in which the sorting should occur. By calling the `rand` method within
    our block, we ask our Array to sort its elements randomly, which is how Arrays
    accomplish the `shuffle` method after Ruby reads this method definition.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了两种不同的类定义：一种是我们向Array类添加行为，另一种是我们创建了一个全新的类，称为`ShufflePlayer`。我们在❶处向Array类添加的一个关键方法是`shuffle`。数组已经有两个非常方便的方法：`sort_by`和`rand`。你会注意到`sort_by`后面跟着一个开括号字符（`{`），然后是`rand`方法，然后是闭括号（`}`）。这个开括号和闭括号之间的内容是一个*块*，这是Ruby转换或迭代数据集合（如数组等）的核心。`sort_by`方法是一个排序操作，它接受一个块参数，该参数决定了排序的方式。通过在我们的块中调用`rand`方法，我们要求我们的数组随机排序其元素，这就是数组在Ruby读取这个方法定义后如何实现`shuffle`方法的原因。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Perlers (or JAPHs) might be interested to know that *`sort_by`* uses a Schwartzian
    Transform under the hood. Also, the numbers generated by *`random`* are technically*
    pseudo-random, *not truly random. The difference isn’t critical for the purposes
    of this script*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*佩尔勒斯（或JAPHs）可能会感兴趣的是，*`sort_by`* 在底层使用的是Schwartzian变换。此外，*`random`* 生成的数字在技术上*是伪随机数，*而不是真正的随机数。对于这个脚本的用途来说，这种区别并不关键。'
- en: All Arrays can now shuffle themselves in our code. This is all we need for our
    Array, but since this book is about informing people about Ruby as much as it
    is about accomplishing tasks like playing shuffled audio files, we’ll continue
    the discussion. Our Arrays will also be able to shuffle themselves with a method
    defined at ❷ called `shuffle!`, similar to but distinct from the method called
    `shuffle` (without the bang). You recently learned that methods with an ending
    bang are destructive, meaning that they change state in the calling object. We
    accomplish this change of state by using the `replace` method, which transforms
    the calling object into whatever argument it receives. The `shuffle` method returns
    a shuffled version of the calling Array. Since we pass that shuffled Array into
    the `replace` method, it is a very simple way to create a destructive method called
    `shuffle!`, which is precisely what we’ve done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的数组都可以在我们的代码中自行打乱了。这就是我们对数组所需的一切，但既然这本书旨在向人们介绍Ruby，就像它旨在完成像播放打乱音频文件这样的任务一样，我们将继续讨论。我们的数组也将能够使用在❷处定义的`shuffle!`方法自行打乱，这个方法与不带感叹号的`shuffle`方法类似，但有所不同。你最近了解到，以感叹号结尾的方法是破坏性的，意味着它们会改变调用对象的状态。我们通过使用`replace`方法来实现这种状态变化，该方法将调用对象转换为它接收的任何参数。`shuffle`方法返回调用数组的打乱版本。由于我们将那个打乱数组传递给`replace`方法，这是一种创建破坏性方法`shuffle!`的非常简单的方式，这正是我们所做的。
- en: It’s very easy to add the `random_element` method, as well, which we do at ❸.
    Since a shuffled version of an Array is in a random order (by definition), returning
    any member out of that shuffled Array will produce a random element. Here we return
    the first element, but we could return the last element, or any other element.
    Returning the first element is a good choice, though, because an Array with any
    members at all will definitely have a first member.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`random_element`方法也非常简单，我们在❸处这样做。由于数组的打乱版本是随机顺序（根据定义），从这个打乱数组中返回任何成员都会产生一个随机元素。在这里，我们返回第一个元素，但我们可以返回最后一个元素，或者任何其他元素。返回第一个元素是一个不错的选择，因为任何包含成员的数组肯定会有一个第一个成员。
- en: With a few short methods, we’ve dramatically added to the capabilities of all
    Arrays. We’ll make use of those capabilities within our new `ShufflePlayer` class.
    Since `ShufflePlayer` is a completely new class, we need to define its `initialize`
    method (❹), which takes an argument called `files` and assigns it into an instance
    variable called `@files`. If you look at ❽, near the end of the program, you see
    that we instantiate a new `ShufflePlayer` with `ARGV` as the files argument.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个简短的方法，我们极大地增强了所有数组的功能。我们将在新的 `ShufflePlayer` 类中使用这些功能。由于 `ShufflePlayer`
    是一个全新的类，我们需要定义它的 `initialize` 方法（❹），它接受一个名为 `files` 的参数并将其赋值给一个名为 `@files` 的实例变量。如果你查看
    ❽，在程序末尾附近，你会看到我们用 `ARGV` 作为文件参数实例化了一个新的 `ShufflePlayer`。
- en: Once a `ShufflePlayer` exists, we want it to play files in shuffled order. We
    do so with the `play` method, defined at ❺. Within `ShufflePlayer, @files` is
    an Array of filenames. We opened up the Array class, adding the `shuffle` method
    to all Arrays. Therefore, `@files` can call the method `shuffle` on itself. Since
    it’s a public method, other objects can call `shuffle` on Arrays, as well. That’s
    what `ShufflePlayer` does in our example. Since the return value of the `shuffle`
    method is also an Array, it can also call all of the methods of an Array, including
    `shuffle` again. Instead of reshuffling, however, we’ll call a method called `each`,
    which takes a block describing what to do to or with each element of the Array.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `ShufflePlayer`，我们希望它以随机顺序播放文件。我们通过定义在 ❺ 的 `play` 方法来实现这一点。在 `ShufflePlayer`
    中，`@files` 是一个包含文件名的数组。我们扩展了数组类，为所有数组添加了 `shuffle` 方法。因此，`@files` 可以对自己调用 `shuffle`
    方法。由于它是一个公共方法，其他对象也可以对数组调用 `shuffle`。这就是 `ShufflePlayer` 在我们的例子中所做的。由于 `shuffle`
    方法的返回值也是一个数组，它也可以调用数组的所有方法，包括再次调用 `shuffle`。然而，我们不会重新洗牌，而是调用一个名为 `each` 的方法，它接受一个描述如何对数组中的每个元素进行操作的块。
- en: 'We delimit blocks with braces, right? Sometimes. We could have implemented
    our `play` method like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用大括号来划分块，对吧？有时候。我们可以像这样实现我们的 `play` 方法：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, I chose to do it as I did to demonstrate the different ways you can
    use blocks in your code. Blocks can either start with `{` and end with `}`, or
    start with `do` and end with `end`. Different Ruby coders have different ideas
    about how best to notate blocks, but the convention seems to be that the brace
    delimiters are more appropriate for one-line blocks, and the `do` and `end` delimiters
    are more appropriate for multi-line blocks. This is the convention I will use
    in this book, and the one I use in my personal code. Ruby itself, however, doesn’t
    really care.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我选择这样做是为了展示你可以在代码中使用块的不同方式。块可以以 `{` 开始并以 `}` 结束，或者以 `do` 开始并以 `end` 结束。不同的
    Ruby 程序员对如何最好地表示块有不同的看法，但似乎约定是，大括号分隔符更适合单行块，而 `do` 和 `end` 分隔符更适合多行块。这就是我在这本书中使用的约定，也是我在个人代码中使用的约定。然而，Ruby
    本身并不真正关心这一点。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The different ways of delineating blocks have different precedences, for those
    who are curious. This means that Ruby will evaluate blocks delineated with *`{`*
    and *`}`* before evaluating blocks delineated with *`do`* and *`end`*. This fits
    well with how they are commonly used*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*划分块的不同方式有不同的优先级，对于那些好奇的人来说。这意味着 Ruby 会先评估用 *`{`* 和 *`}`* 划分的块，然后再评估用 *`do`*
    和 *`end`* 划分的块。这与它们常用的方式非常吻合*。'
- en: Note that when we call `each`, we have the word *file* within two pipe characters.
    Ruby coders who like American football sometimes call this the *goalpost*. The
    *goalpost* just tells the code within the `each` method what each element should
    be called within the block. Conceptually, it resembles an argument to a method,
    and later in the book, we’ll blur that distinction even more. In this case, we’re
    asking the `ShufflePlayer` to loop through each element of `@files`, call that
    element `file`, and call some method called `play_file`, taking `file` as an argument.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们调用 `each` 时，在两个管道字符中有单词 *file*。喜欢美式足球的 Ruby 程序员有时称这为 *goalpost*。*goalpost*
    只是告诉 `each` 方法中的代码每个元素在块中应该被称为什么。从概念上讲，它类似于方法的一个参数，在本书的后面，我们将进一步模糊这个区别。在这种情况下，我们要求
    `ShufflePlayer` 遍历 `@files` 的每个元素，将该元素称为 `file`，并调用一个名为 `play_file` 的方法，该方法接受
    `file` 作为参数。
- en: Since we never need to call `play_file` from the outside, we can make it a private
    method, as shown at ❻. All `play_file` does is take an argument called `file`
    and use a method called `system` at ❼ in order to play that file argument using
    the `ogg123` program. As you might guess, `system` goes outside of Ruby and asks
    the operating system to do something—like play an audio file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从不需要在外部调用 `play_file`，我们可以将其设为一个私有方法，如❻所示。`play_file` 所做的只是接受一个名为 `file`
    的参数，并使用 `system` 方法在❻处调用，以便使用 `ogg123` 程序播放该文件参数。正如你可能猜到的，`system` 超出了 Ruby 的范围，并请求操作系统执行某些操作——比如播放音频文件。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I have a large number of files in Ogg Vorbis audio format, so I use the ogg123
    program to play them. You can certainly replace ogg123 with mpg321 or any other
    command-line audio player*.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*我有很多 Ogg Vorbis 音频格式的文件，所以我使用 ogg123 程序来播放它们。你当然可以用 mpg321 或任何其他命令行音频播放器替换
    ogg123*。'
- en: The `play_file` method makes several assumptions, of course. It assumes that
    every file it’s asked to play will be playable with `ogg123`. It assumes that
    a command like `ogg123` *`some_file_name`* will be understandable by the operating
    system. Most glaringly, it assumes that there is a program called `ogg123` on
    the computer that runs this program. I wrote this program to play audio files
    on my computer at work, where it was safe for me to make these assumptions. This
    allowed the program to be much shorter, because it didn’t have to worry about
    checking for the existence of `ogg123`, and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`play_file` 方法当然做了一些假设。它假设它被要求播放的每个文件都可以用 `ogg123` 播放。它假设像 `ogg123` *`some_file_name`*
    这样的命令可以被操作系统理解。最明显的是，它假设在运行此程序的计算机上有一个名为 `ogg123` 的程序。我编写这个程序是为了在我的工作电脑上播放音频文件，在那里我可以安全地做出这些假设。这使得程序变得更短，因为它不必担心检查
    `ogg123` 的存在等问题。'
- en: Running the Script
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: You run this script as either `ruby -w shuffle_play.rb` *`some_ogg_files`* or
    `./shuffle_play.rb` *`some_ogg_files`*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `ruby -w shuffle_play.rb` *`some_ogg_files`* 或 `./shuffle_play.rb` *`some_ogg_files`*
    来运行这个脚本。
- en: The Results
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Now that I have explained our script, let’s try it out. These examples are within
    a bash shell in Linux, and use the long-winded version of `shuffle_play.rb`. The
    specific output you’ll see will depend heavily on the files you choose to play
    (represented by *`some_ogg_files`* in [Running the Script](ch02s04.html#running_the_script-id002
    "Running the Script") above). Since the shuffling is pseudo-random, successive
    runs will also probably be different, even on the same set of files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经解释了我们的脚本，让我们来试一试。这些示例是在 Linux 的 bash shell 中，并使用 `shuffle_play.rb` 的长版本。你将看到的特定输出将严重取决于你选择的要播放的文件（如[运行脚本](ch02s04.html#running_the_script-id002
    "运行脚本")中所示，用 *`some_ogg_files`* 表示）。由于随机排序是伪随机的，连续运行的结果也可能不同，即使在同一组文件上。
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or on another directory:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在其他目录下：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In these examples, the bash shell expands the filenames from *.ogg before it
    ever gets to Ruby. All of those files are the arguments to our `ShufflePlayer`,
    which then plays them all in shuffled order, meaning that once it’s done with
    one file, it continues on to all the others without repeating any files. We’ll
    look at another approach to shuffled playback of audio files in two programs designed
    for radio station use later in the book.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，bash shell 在到达 Ruby 之前会先展开 *.ogg 文件名。所有这些文件都是我们 `ShufflePlayer` 的参数，然后它会以随机顺序播放它们，这意味着一旦处理完一个文件，它会继续播放其他所有文件，而不会重复任何文件。我们将在本书后面的章节中探讨为广播电台使用设计的两个程序中另一种音频文件的随机播放方法。
- en: Hacking the Script
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: 'Incidentally, if you’re interested in shorter programs, this entire program
    could be replaced by these two lines:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的是，如果你对更短的程序感兴趣，整个程序可以被这两行代码替换：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You could just have the second line if you always called the program as an argument
    to the Ruby interpreter, like
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你总是将程序作为 Ruby 解释器的参数调用，那么你可以只保留第二行。
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I don’t think that extreme brevity at the expense of clarity is a goal to strive
    for, however, and I won’t be coding toward that end in this book. Brevity is particularly
    inappropriate for a book that means to teach people about programming, except
    to demonstrate alternative formats for the same functionality, as done here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我认为以牺牲清晰度为代价的极端简洁性并不是一个值得追求的目标，而且在这本书中，我不会朝着这个方向编写代码。简洁性对于一本旨在教授人们编程知识的书来说尤其不合适，除非是为了展示相同功能的替代格式，就像这里所做的那样。
- en: Chapter Recap
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: What was new in this chapter?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有什么新内容？
- en: Dates
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: Constants versus magic numbers
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量与魔法数字
- en: Expressions with the `||` operator
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `||` 操作符的表达式
- en: '`ENV[‘HOME’]`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV[‘HOME’]`'
- en: External file access, both reading and writing, using `File.new`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `File.new` 进行外部文件访问，包括读取和写入
- en: Splitting Strings into Arrays
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串拆分为数组
- en: Printing with `puts`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `puts` 打印
- en: Generating (pseudo-)random numbers
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成（伪）随机数
- en: Running Ruby programs at the command line
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行中运行 Ruby 程序
- en: Defining and instantiating new Classes
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和实例化新的类
- en: 'Instance variables: `@i_am_an_instance_variable`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量：`@i_am_an_instance_variable`
- en: 'Ruby method naming conventions: predicate?, destructive!'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 方法命名约定：predicate?，destructive!
- en: Introduction to RDoc
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDoc 简介
- en: 'Expression interpolation within Strings: `“#{interpolate_me}”`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串内的表达式插值：`“#{interpolate_me}”`
- en: 'Ternary operator: (`expression ? if_true : if_false`)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '三元运算符：（`expression ? if_true : if_false`）'
- en: Access control
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Open classes
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放类
- en: Using `ARGV`
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ARGV`
- en: Using the `each` method with blocks
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有代码块的 `each` 方法
- en: The `system` method
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system` 方法'
- en: That’s a great deal of non-trivial information. If you’re relatively new to
    programming, have made it this far, and feel fairly comfortable with the content
    up to this point, you’ve accomplished something significant and praiseworthy.
    Congratulations. If you’re an old hand, hopefully this chapter has given you a
    good idea of how Ruby does some things you’ve already done in other languages.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大堆非平凡的信息。如果你是相对编程新手，已经走到这一步，并且对到目前为止的内容感到相当舒适，你已经取得了显著和值得赞扬的成就。恭喜你。如果你是老手，希望这一章能给你一个很好的想法，了解
    Ruby 是如何处理你在其他语言中已经做过的某些事情的。
