- en: Chapter 9. More Input and More Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the concepts behind Haskell’s I/O, we can start doing
    fun stuff with it. In this chapter, we’ll interact with files, make random numbers,
    deal with command-line arguments, and more. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Files and Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Armed with the knowledge about how I/O actions work, we can move on to reading
    and writing files with Haskell. But first, let’s take a look at how we can use
    Haskell to easily process streams of data. A *stream* is a succession of pieces
    of data entering or exiting a program over time. For instance, when you’re inputting
    characters into a program via the keyboard, those characters can be thought of
    as a stream.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802620.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Input Redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many interactive programs get the user’s input via the keyboard. However, it’s
    often more convenient to get the input by feeding the contents of a text file
    to the program. To achieve this, we use *input redirection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input redirection will come in handy with our Haskell programs, so let’s take
    a look at how it works. To begin, create a text file that contains the following
    little haiku, and save it as *haiku.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, the haiku sucks—what of it? If anyone knows of any good haiku tutorials,
    let me know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll write a little program that continuously gets a line from the input
    and then prints it back in all uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Save this program as *capslocker.hs* and compile it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of inputting lines via the keyboard, we’ll have *haiku.txt* be the
    input by redirecting it into our program. To do that, we add a `<` character after
    our program name and then specify the file that we want to act as the input. Check
    it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What we’ve done is pretty much equivalent to running `capslocker`, typing our
    haiku at the terminal, and then issuing an end-of-file character (usually done
    by pressing ctrl-D). It’s like running `capslocker` and saying, “Wait, don’t read
    from the keyboard. Take the contents of this file instead!”
  prefs: []
  type: TYPE_NORMAL
- en: Getting Strings from Input Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at an I/O action that makes processing input streams easier
    by allowing us to treat them as normal strings: `getContents`. `getContents` reads
    everything from the standard input until it encounters an end-of-file character.
    Its type is `getContents :: IO String`. What’s cool about `getContents` is that
    it does lazy I/O. This means that when we do `foo <- getContents`, `getContents`
    doesn’t read all of the input at once, store it in memory, and then bind it to
    `foo`. No, `getContents` is lazy! It will say, “Yeah yeah, I’ll read the input
    from the terminal later as we go along, when you really need it!”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our *capslocker.hs* example, we used `forever` to read the input line by
    line and then print it back in uppercase. If we opt to use `getContents`, it takes
    care of the I/O details for us, such as when to read input and how much of that
    input to read. Because our program is about taking some input and transforming
    it into some output, we can make it shorter by using `getContents`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We run the `getContents` I/O action and name the string it produces `contents`.
    Then we map `toUpper` over that string and print that result to the terminal.
    Keep in mind that because strings are basically lists, which are lazy, and `getContents`
    is I/O lazy; it won’t try to read all of the content at once and store that into
    memory before printing out the caps-locked version. Rather, it will print out
    the caps-locked version as it reads, because it will read a line from the input
    only when it must.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, it works. What if we just run `capslocker` and try to type in the lines
    ourselves? (To exit the program, just press ctrl-D.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pretty nice! As you can see, it prints our caps-locked input line by line.
  prefs: []
  type: TYPE_NORMAL
- en: When the result of `getContents` is bound to `contents`, it’s not represented
    in memory as a real string, but more like a promise that the string will be produced
    eventually. When we map `toUpper` over `contents`, that’s also a promise to map
    that function over the eventual contents. Finally, when `putStr` happens, it says
    to the previous promise, “Hey, I need a caps-locked line!” It doesn’t have any
    lines yet, so it says to `contents`, “How about getting a line from the terminal?”
    And that’s when `getContents` actually reads from the terminal and gives a line
    to the code that asked it to produce something tangible. That code then maps `toUpper`
    over that line and gives it to `putStr`, which prints the line. And then `putStr`
    says, “Hey, I need the next line—come on!” This repeats until there’s no more
    input, which is signified by an end-of-file character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make a program that takes some input and prints out only those lines
    that are shorter than 10 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We’ve made the I/O part of our program as short as possible. Because our program
    is supposed to print something based on some input, we can implement it by reading
    the input contents, running a function on them, and then printing out what that
    function gives back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shortLinesOnly` function takes a string, like `"short\nlooooooong\nbort"`.
    In this example, that string has three lines: two of them are short, and the middle
    one is long. It applies the `lines` function to that string, which converts it
    to `["short", "looooooong", "bort"]`. That list of strings is then filtered so
    that only those lines that are shorter than 10 characters remain in the list,
    producing `["short", "bort"]`. Finally, `unlines` joins that list into a single
    newline-delimited string, giving `"short\nbort"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s give it a go. Save the following text as *shortlines.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we’ll compile our program, which we saved as *shortlinesonly.hs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To test it, we’re going to redirect the contents of *shortlines.txt* into our
    program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that only the short lines were printed to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pattern of getting some string from the input, transforming it with a function,
    and outputting the result is so common that there is a function that makes that
    job even easier, called `interact`. `interact` takes a function of type `String
    -> String` as a parameter and returns an I/O action that will take some input,
    run that function on it, and then print out the function’s result. Let’s modify
    our program to use `interact`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can use this program either by redirecting a file into it or by running it
    and then giving it input from the keyboard, line by line. Its output is the same
    in both cases, but when we’re doing input via the keyboard, the output is interspersed
    with what we typed in, just as when we manually typed in our input to our `capslocker`
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a program that continuously reads a line and then outputs whether
    or not that line is a palindrome. We could just use `getLine` to read a line,
    tell the user if it’s a palindrome, and then run `main` all over again. But it’s
    simpler if we use `interact`. When using `interact`, think about what you need
    to do to transform some input into the desired output. In our case, we want to
    replace each line of the input with either `"palindrome"` or `"not a palindrome"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This program is pretty straightforward. First, it turns a string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'into an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it maps the lambda over it, giving the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `unlines` joins that list into a single, newline-delimited string. Now
    we just make a main I/O action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Even though we created a program that transforms one big string of input into
    another, it acts as if we made a program that does it line by line. That’s because
    Haskell is lazy, and it wants to print the first line of the result string, but
    it can’t because it doesn’t have the first line of the input yet. So as soon as
    we give it the first line of input, it prints the first line of the output. We
    get out of the program by issuing an end-of-line character.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use this program by just redirecting a file into it. Create the
    following file and save it as *words.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we get by redirecting it into our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, we get the same output as if we had run our program and put in the words
    ourselves at the standard input. We just don’t see the input that our program
    gets because that input came from the file.
  prefs: []
  type: TYPE_NORMAL
- en: So now you see how lazy I/O works and how we can use it to our advantage. You
    can just think in terms of what the output is supposed to be for some given input
    and write a function to do that transformation. In lazy I/O, nothing is eaten
    from the input until it absolutely must be, because what we want to print right
    now depends on that input.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Writing Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve worked with I/O by printing stuff to the terminal and reading
    from it. But what about reading and writing files? Well, in a way, we’ve already
    been doing that.
  prefs: []
  type: TYPE_NORMAL
- en: One way to think about reading from the terminal is that it’s like reading from
    a (somewhat special) file. The same goes for writing to the terminal— it’s kind
    of like writing to a file. We can call these two files *stdout* and *stdin*, meaning
    standard output and standard input, respectively. Writing to and reading from
    files is very much like writing to the standard output and reading from the standard
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start off with a really simple program that opens a file called *girlfriend.txt*,
    which contains a verse from Avril Lavigne’s hit song “Girlfriend,” and just prints
    out to the terminal. Here’s *girlfriend.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run it, we get the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over this line by line. The first line is just four exclamations, to
    get our attention. In the second line, Avril tells us that she doesn’t like our
    current partner of the female persuasion. The third line serves to emphasize that
    disapproval, and the fourth line suggests we should go about finding a suitable
    replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also go over the program line by line. Our program is several I/O actions
    glued together with a `do` block. In the first line of the `do` block is a new
    function called `openFile`. It has the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`openFile` takes a file path and an `IOMode` and returns an I/O action that
    will open a file and yield the file’s associated handle as its result. `FilePath`
    is just a type synonym for `String`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`IOMode` is a type that’s defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Just like our type that represents the seven possible values for the days of
    the week, this type is an enumeration that represents what we want to do with
    our opened file. Notice that this type is `IOMode` and not `IO Mode`. `IO Mode`
    would be the type of I/O action that yields a value of some type `Mode` as its
    result. `IOMode` is just a simple enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802622.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, `openFile` returns an I/O action that will open the specified file
    in the specified mode. If we bind that action’s result to something, we get a
    `Handle`, which represents where our file is. We’ll use that handle so we know
    which file to read from.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we have a function called `hGetContents`. It takes a `Handle`,
    so it knows which file to get the contents from, and returns an `IO String`—an
    I/O action that holds contents of the file as its result. This function is pretty
    much like `getContents`. The only difference is that `getContents` will automatically
    read from the standard input (that is, from the terminal), whereas `hGetContents`
    takes a file handle that tells it which file to read from. In all other respects,
    they work the same.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `getContents`, `hGetContents` won’t attempt to read all the file at
    once and store it in memory but will read the content only as needed. This is
    really cool because we can treat `contents` as the whole content of the file,
    but it’s not really loaded in memory. So if this were a really huge file, doing
    `hGetContents` wouldn’t choke up our memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note the difference between a handle and the actual contents of the file. A
    handle just points to our current position in the file. The contents are what’s
    actually in the file. If you imagine your whole filesystem as a really big book,
    the handle is like a bookmark that shows where you’re currently reading (or writing).
  prefs: []
  type: TYPE_NORMAL
- en: With `putStr contents`, we print the contents out to the standard output, and
    then we do `hClose`, which takes a handle and returns an I/O action that closes
    the file. You need to close the file yourself after opening it with `openFile`!
    Your program may terminate if you try to open a file whose handle hasn’t been
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the withFile Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way of working with the contents of a file as we just did is to use
    the `withFile` function, which has the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It takes a path to a file, an `IOMode`, and a function that takes a handle and
    returns some I/O action. Then it returns an I/O action that will open that file,
    do something with the file, and close it. Furthermore, if anything goes wrong
    while we’re operating on our file, `withFile` makes sure that the file handle
    gets closed. This might sound a bit complicated, but it’s really simple, especially
    if we use lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our previous example rewritten to use `withFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`(\handle -> ...)` is the function that takes a handle and returns an I/O action,
    and it’s usually done like this, with a lambda. It needs to take a function that
    returns an I/O action, rather than just taking an I/O action to do and then closing
    the file, because the I/O action that we would pass to it wouldn’t know on which
    file to operate. This way, `withFile` opens the file and then passes the handle
    to the function we gave it. It gets an I/O action back from that function and
    then makes an I/O action that’s just like the original action, but it also makes
    sure that the file handle gets closed, even if something goes awry.'
  prefs: []
  type: TYPE_NORMAL
- en: It's Bracket Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, if a piece of code calls `error` (such as when we try to apply `head`
    to an empty list) or if something goes very wrong when doing input and output,
    our program terminates, and we see some sort of error message. In such circumstances,
    we say that an *exception* gets raised. The `withFile` function makes sure that
    despite an exception being raised, the file handle is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of scenario comes up often. We acquire some resource (like a file
    handle), and we want to do something with it, but we also want to make sure that
    the resource gets released (for example, the file handle is closed). Just for
    such cases, the `Control.Exception` module offers the `bracket` function. It has
    the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802624.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Its first parameter is an I/O action that acquires a resource, such as a file
    handle. Its second parameter is a function that releases that resource. This function
    gets called even if an exception has been raised. The third parameter is a function
    that also takes that resource and does something with it. The third parameter
    is where the main stuff happens, like reading from a file or writing to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `bracket` is all about acquiring a resource, doing something with it,
    and making sure it gets released, implementing `withFile` is really easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter that we pass to `bracket` opens the file, and its result
    is a file handle. The second parameter takes that handle and closes it. `bracket`
    makes sure that this happens even if an exception is raised. Finally, the third
    parameter to `bracket` takes a handle and applies the function `f` to it, which
    takes a file handle and does stuff with that handle, like reading from or writing
    to the corresponding file.
  prefs: []
  type: TYPE_NORMAL
- en: Grab the Handles!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as `hGetContents` works like `getContents` but for a specific file, functions
    like `hGetLine`, `hPutStr`, `hPutStrLn`, `hGetChar`, and so on work just like
    their counterparts without the `h` but take only a handle as a parameter and operate
    on that specific file instead of on standard input or standard output. For example,
    `putStrLn` takes a string and returns an I/O action that will print out that string
    to the terminal and a newline after it. `hPutStrLn` takes a handle and a string
    and returns an I/O action that will write that string to the file associated with
    the handle and then put a newline after it. In the same vein, `hGetLine` takes
    a handle and returns an I/O action that reads a line from its file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading files and then treating their contents as strings is so common that
    we have three nice little functions to make our work even easier: `readFile`,
    `writeFile`, and `appendFile.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readFile` function has a type signature of `readFile :: FilePath -> IO
    String`. (Remember that `FilePath` is just a fancy name for `String`.) `readFile`
    takes a path to a file and returns an I/O action that will read that file (lazily,
    of course) and bind its contents to something as a string. It’s usually more handy
    than calling `openFile` and then calling `hGetContents` with the resulting handle.
    Here’s how we could have written our previous example with `readFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Because we don’t get a handle with which to identify our file, we can’t close
    it manually, so Haskell does that for us when we use `readFile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `writeFile` function has a type of `writeFile :: FilePath -> String ->
    IO ()`. It takes a path to a file and a string to write to that file and returns
    an I/O action that will do the writing. If such a file already exists, it will
    be stomped down to zero length before being written to. Here’s how to turn *girlfriend.txt*
    into a caps-locked version and write it to *girlfriendcaps.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `appendFile` function has the same type signature as `writeFile` and acts
    almost the same way. The only difference is that `appendFile` doesn’t truncate
    the file to zero length if it already exists. Instead, it appends stuff to the
    end of that file.
  prefs: []
  type: TYPE_NORMAL
- en: To-Do Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s put the `appendFile` function to use by making a program that adds a
    task to a text file that lists stuff that we have to do. We’ll assume that the
    file is named *todo.txt* and that it contains one task per line. Our program will
    take a line from the standard input and add it to our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we added the `"\n"` to the end of each line, because `getLine` doesn’t
    give us a newline character at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file as *appendtodo.hs*, compile it, and then run it a few times and
    give it some to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`cat` is a program on Unix-type systems that can be used to print text files
    to the terminal. On Windows systems, you can use your favorite text editor to
    see what’s inside *todo.txt* at any given time.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already made a program to add a new item to our to-do list in *todo.txt*.
    Now let’s make a program to remove an item. We’ll use a few new functions from
    `System.Directory` and one new function from `System.IO`, which will all be explained
    after the code listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we read *todo.txt* and bind its contents to `contents`. Then we split
    the contents into a list of strings, with one line for each string. So `todoTasks`
    is now something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We zip the numbers from `0` onward and that list with a function that takes
    a number (like `3`) and a string (like `"hey"`) and returns a new string (like
    `"3 - hey"`). Now `numberedTasks` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We then use `mapM_ putStrLn numberedTasks` to print each task on a separate
    line, ask the user which one to delete, and wait for the user to enter a number.
    Let’s say we want to delete number `1` (`Dust the dog`), so we punch in `1`. `numberString`
    is now `"1"`, and because we want a number rather than a string, we apply `read`
    to that to get `1` and use a `let` to bind that to `number`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the `delete` and `!!` functions from `Data.List`? `!!` returns an element
    from a list with some index. `delete` deletes the first occurrence of an element
    in a list and returns a new list without that occurrence. `(todoTasks !! number)`
    results in `"Dust the dog"`. We delete the the first occurrence of `"Dust the
    dog"` from `todoTasks` and then join that into a single line with `unlines` and
    name that `newTodoItems`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we use a function that we haven’t met before, from `System.IO`: `openTempFile`.
    Its name is pretty self-explanatory. It takes a path to a temporary directory
    and a template name for a file and opens a temporary file. We used `"."` for the
    temporary directory, because `.` denotes the current directory on just about any
    operating system. We used `"temp"` as the template name for the temporary file,
    which means that the temporary file will be named *temp* plus some random characters.
    It returns an I/O action that makes the temporary file, and the result in that
    I/O action is a pair of values: the name of the temporary file and a handle. We
    could just open a normal file called *todo2.txt* or something like that, but it’s
    better practice to use `openTempFile` so you know you’re probably not overwriting
    anything.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a temporary file opened, we write `newTodoItems` to it. The
    old file is unchanged, and the temporary file contains all the lines that the
    old one does, except the one we deleted.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we close both the original and the temporary files, and remove the
    original one with `removeFile`, which takes a path to a file and deletes it. After
    deleting the old *todo.txt*, we use `renameFile` to rename the temporary file
    to *todo.txt*. `removeFile` and `renameFile` (which are both in `System.Directory`)
    take file paths, not handles, as their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this as *deletetodo.hs*, compile it, and try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see which items remain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah, cool! Let’s delete one more item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And examining the file, we see that only one item remains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, everything is working. However, there’s one thing that about this program
    that’s kind of off. If something goes wrong after we open our temporary file,
    the program terminates, but the temporary file doesn’t get cleaned up. Let’s remedy
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure our temporary file is cleaned up in case of a problem, we’re going
    to use the `bracketOnError` function from `Control.Exception`. It’s very similar
    to `bracket`, but whereas the `bracket` will acquire a resource and then make
    sure that some cleanup always gets done after we’ve used it, `bracketOnError`
    performs the cleanup only if an exception has been raised. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Instead of just using `openTempFile` normally, we use it with `bracketOnError`.
    Next, we write what we want to happen if an error occurs; that is, we want to
    close the temporary handle and remove the temporary file. Finally, we write what
    we want to do with the temporary file while things are going well, and these lines
    are the same as they were before. We write the new items, close the temporary
    handle, remove our current file, and rename the temporary file.
  prefs: []
  type: TYPE_NORMAL
- en: Command-Line Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with command-line arguments is pretty much a necessity if you want to
    make a script or application that runs on a terminal. Luckily, Haskell’s standard
    library has a nice way of getting command-line arguments for a program.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we made one program for adding an item to our to-do
    list and one program for removing an item. A problem with them is that we just
    hardcoded the name of our to-do file. We decided that the file will be named *todo.txt*
    and that users will never have a need for managing several to-do lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802626.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One solution is to always ask the users which file they want to use as their
    to-do list. We used that approach when we wanted to know which item to delete.
    It works, but it’s not the ideal solution because it requires the users to run
    the program, wait for the program to ask them something, and then give the program
    some input. That’s called an *interactive* program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difficult bit with interactive command-line programs is this: What if you
    want to automate the execution of that program, as with a script? It’s harder
    to make a script that interacts with a program than a script that just calls one
    or more programs. That’s why we sometimes want users to tell a program what they
    want when they run the program, instead of having the program ask the user once
    it’s running. And what better way to have the users tell the program what they
    want it to do when they run it than via command-line arguments?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `System.Environment` module has two cool I/O actions that are useful for
    getting command-line arguments: `getArgs` and `getProgName`. `getArgs` has a type
    of `getArgs :: IO [String]` and is an I/O action that will get the arguments that
    the program was run with and yield a list of those arguments. `getProgName` has
    a type of `getProgName :: IO String` and is an I/O action that yields the program
    name. Here’s a small program that demonstrates how these two work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we bind the command-line arguments to `args` and program name to `progName`.
    Next, we use `putStrLn` to print all the program’s arguments and then the name
    of the program itself. Let’s compile this as `arg-test` and try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: More Fun with To-Do Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, we made one program for adding tasks and an entirely
    separate program for deleting them. Now we’re going to join that into a single
    program, and whether it adds or deletes items will depend on the command-line
    arguments we pass to it. We’ll also make it able to operate on different files,
    not just *todo.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll call our program `todo`, and it will be able to do three different things:'
  prefs: []
  type: TYPE_NORMAL
- en: View tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add a task to the *todo.txt* file, we enter it at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the tasks, we enter the `view` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a task, we use its index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: A Multitasking Task List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start by making a function that takes a command in the form of a string,
    like `"add"` or `"view"`, and returns a function that takes a list of arguments
    and returns an I/O action that does what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll define `main` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the arguments and bind them to `(command:argList)`. This means
    that the first argument will be bound to `command`, and the rest of the arguments
    will be bound to `argList`. In the next line of our `main` block, we apply the
    `dispatch` function to the command, which results in the `add`, `view`, or `remove`
    function. We then apply that function to `argList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we call our program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`command` is `"add"`, and `argList` is `["todo.txt", "Find the magic sword
    of power"]`. That way, the second pattern match of the `dispatch` function will
    succeed, and it will return the `add` function. Finally, we apply that to `argList`,
    which results in an I/O action that adds the item to our to-do list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s implement the `add`, `view`, and `remove` functions. Let’s start
    with `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We might call our program like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `"add"` will be bound to `command` in the first pattern match in the `main`
    block, whereas `["todo.txt", "Find the magic sword of power"]` will be passed
    to the function that we get from the `dispatch` function. So, because we’re not
    dealing with bad input right now, we just pattern match against a list with those
    two elements immediately and return an I/O action that appends that line to the
    end of the file, along with a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s implement the list-viewing functionality. If we want to view the
    items in a file, we do `./todo view todo.txt`. So in the first pattern match,
    `command` will be `"view"`, and `argList` will be `["todo.txt"]`. Here’s the function
    in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When we made our `deletetodo` program, which could only delete items from a
    to-do list, it had the ability to display the items in a to-do list, so this code
    is very similar to that part of the previous program.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’re going to implement `remove`. It’s very similar to the program
    that only deleted the tasks, so if you don’t understand how deleting an item here
    works, review [Deleting Items](ch09s03.html#deleting_items "Deleting Items") in
    [Deleting Items](ch09s03.html#deleting_items "Deleting Items"). The main difference
    is that we’re not hardcoding the filename as *todo.txt* but instead getting it
    as an argument. We’re also getting the target task number as an argument, rather
    than prompting the user for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We opened the file based on `fileName` and opened a temporary file, deleted
    the line with the index that the user wants to delete, wrote that to the temporary
    file, removed the original file, and renamed the temporary file back to `fileName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the whole program in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To summarize our solution, we made a `dispatch` function that maps from commands
    to functions that take some command-line arguments in the form of a list and return
    an I/O action. We see what the `command` is, and based on that, we get the appropriate
    function from the `dispatch` function. We call that function with the rest of
    the command-line arguments to get back an I/O action that will do the appropriate
    thing, and then just perform that action. Using higher-order functions allows
    us to just tell the `dispatch` function to give us the appropriate function, and
    then tell that function to give us an I/O action for some command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try our app!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Another cool thing about using the `dispatch` function is that it’s easy to
    add functionality. Just add an extra pattern to `dispatch` and implement the corresponding
    function, and you’re laughing! As an exercise, you can try implementing a `bump`
    function that will take a file and a task number and return an I/O action that
    bumps that task to the top of the to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Bad Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could extend this program to make it fail a bit more gracefully in the case
    of bad input, instead of printing out an ugly error message from Haskell. We can
    start by adding a catchall pattern at the end the `dispatch` function and making
    it return a function that ignores the argument list and tells us that such a command
    doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We might also add catchall patterns to the `add`, `view`, and `remove` functions,
    so that the program tells users if they have supplied the wrong number of arguments
    to a given command. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If `add` is applied to a list that doesn’t have exactly two elements, the first
    pattern match will fail, but the second one will succeed, helpfully informing
    users of their erronous ways. We can add a catchall pattern like this to `view`
    and `remove` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we haven’t covered all of the cases where our input is bad. For instance,
    suppose we run our program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it will crash, because we use the `(command:argList)` pattern
    in our `do` block, but that doesn’t consider the possibility that there are no
    arguments at all! We also don’t check to see if the file we’re operating on exists
    before trying to open it. Adding these precautions isn’t hard, but it is a bit
    tedious, so making this program completely idiot-proof is left as an exercise
    to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times while programming, you need to get some random data (well, *pseudo*-random
    data, since we all know that the only true source of randomness is a monkey on
    a unicycle with cheese in one hand and its butt in the other). For example, you
    may be making a game where a die needs to be thrown, or you need to generate some
    data to test your program. In this section, we’ll take a look at how to make Haskell
    generate seemingly random data and why we need external input to generate values
    that are random enough.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802628.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most programming languages have functions that give you back some random number.
    Each time you call that function, you retrieve a different random number. How
    about Haskell? Well, remember that Haskell is a purely functional language. That
    means it has referential transparency. And *that* means a function, if given the
    same parameters twice, must produce the same result twice. That’s really cool,
    because it allows us to reason about programs, and it enables us to defer evaluation
    until we really need it. However, this makes it a bit tricky for getting random
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It’s not very useful as a random number function, because it will always return
    `4`. (Even though I can assure you that the `4` is completely random, because
    I used a die to determine it.)
  prefs: []
  type: TYPE_NORMAL
- en: How do other languages make seemingly random numbers? Well, they take some initial
    data, like the current time, and based on that, generate numbers that are seemingly
    random. In Haskell, we can generate random numbers by making a function that takes
    as its parameter some initial data, or randomness, and produces a random number.
    We use I/O to bring randomness into our program from outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `System.Random` module. It has all the functions that satisfy our
    need for randomness. Let’s just dive into one of the functions it exports: `random`.
    Here is its type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoa! We have some new type classes in this type declaration! The `RandomGen`
    type class is for types that can act as sources of randomness. The `Random` type
    class is for types whose values can be random. We can generate random Boolean
    values by randomly producing either `True` or `False`. We can also generate numbers
    that are random. Can a function take on a random value? I don’t think so! If we
    try to translate the type declaration of `random` to English, we get something
    like this: It takes a random generator (that’s our source of randomness) and returns
    a random value and a new random generator. Why does it also return a new generator
    as well as a random value? Well, you’ll see in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: To use our `random` function, we need to get our hands on one of those random
    generators. The `System.Random` module exports a cool type, namely `StdGen`, which
    is an instance of the `RandomGen` type class. We can make a `StdGen` manually,
    or we can tell the system to give us one based on a multitude of (sort of) random
    stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually make a random generator, use the `mkStdGen` function. It has a
    type of `mkStdGen :: Int -> StdGen`. It takes an integer, and based on that, gives
    us a random generator. Okay then, let’s try using `random` and `mkStdGen` in tandem
    to get a (hardly) random number.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: What’s this? Ah, right, the `random` function can return a value of any type
    that’s part of the `Random` type class, so we need to inform Haskell which type
    we want. Also let’s not forget that it returns a random value and a random generator
    in a pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Finally, a number that looks kind of random! The first component of the tuple
    is our number, and the second component is a textual representation of our new
    random generator. What happens if we call random with the same random generator
    again?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we get the same result for the same parameters. So let’s try giving
    it a different random generator as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Great, a different number! We can use the type annotation to get different types
    back from that function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Tossing a Coin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s make a function that simulates tossing a coin three times. If `random`
    didn’t return a new generator along with a random value, we would need to make
    this function take three random generators as a parameter and return coin tosses
    for each of them. But if one generator can make a random value of type `Int` (which
    can take on a load of different values), it should be able to make three coin
    tosses (which can have only eight different end results). So this is where `random`
    returning a new generator along with a value comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll represent a coin with a simple `Bool`: `True` is tails, and `False` is
    heads.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We call `random` with the generator we got as a parameter to get a coin and
    a new generator. Then we call it again, only this time with our new generator,
    to get the second coin. We do the same for the third coin. Had we called it with
    the same generator every time, all the coins would have had the same value, so
    we would get only `(False, False, False)` or `(True, True, True)` as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we didn’t need to call `random gen :: (Bool, StdGen)`. Since we
    already specified that we want Booleans in the type declaration of the function,
    Haskell can infer that we want a Boolean value in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: More Random Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we want to flip more coins? For that, there’s a function called `randoms`,
    which takes a generator and returns an infinite sequence of values based on that
    generator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Why doesn’t `randoms` return a new generator as well as a list? We could implement
    the `randoms` function very easily like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is a recursive definition. We get a random value and a new generator from
    the current generator, and then make a list that has the value as its head and
    random numbers based on the new generator as its tail. Because we need to be able
    to potentially generate an infinite amount of numbers, we can’t give the new random
    generator back.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could make a function that generates a finite stream of numbers and a new
    generator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is a recursive definition. We say that if we want zero numbers,
    we just return an empty list and the generator that was given to us. For any other
    number of random values, we first get one random number and a new generator. That
    will be the head. Then we say that the tail will be `n - 1` numbers generated
    with the new generator. Then we return the head and the rest of the list joined
    and the final generator that we got from getting the `n - 1` random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want a random value in some sort of range? All the random integers
    so far were outrageously big or small. What if we want to throw a die? Well, we
    use `randomR` for that purpose. It has this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This means that it’s kind of like `random`, but it takes as its first parameter
    a pair of values that set the lower and upper bounds, and the final value produced
    will be within those bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also `randomRs`, which produces a stream of random values within our
    defined ranges. Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: It looks like a super secret password, doesn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Randomness and I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering what this section has to do with I/O. We haven’t done anything
    concerning I/O so far. We’ve always made our random number generator manually
    by creating it with some arbitrary integer. The problem is that if we do that
    in our real programs, they will always return the same random numbers, which is
    no good for us. That’s why `System.Random` offers the `getStdGen` I/O action,
    which has a type of `IO StdGen`. It asks the system for some initial data and
    uses it to jump-start the *global generator*. `getStdGen` fetches that global
    random generator when you bind it to something.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple program that generates a random string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'But you need to be careful. Just performing `getStdGen` twice will ask the
    system for the same global generator twice. Suppose we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We will get the same string printed out twice!
  prefs: []
  type: TYPE_NORMAL
- en: The best way to get two different strings is to use the `newStdGen` action,
    which splits our current random generator into two generators. It updates the
    global random generator with one of them and yields the other as its result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Not only do we get a new random generator when we bind `newStdGen` to something,
    but the global one gets updated as well. This means that if we do `getStdGen`
    again and bind it to something, we’ll get a generator that’s not the same as `gen`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a little program that will make the user guess which number it’s thinking
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802630.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We make a function `askForNumber`, which takes a random number generator and
    returns an I/O action that will prompt you for a number, and then tell you if
    you guessed it right.
  prefs: []
  type: TYPE_NORMAL
- en: In `askForNumber`, we first generate a random number and a new generator based
    on the generator that we got as a parameter and call them `randNumber` and `newGen`.
    (For this example, let’s say that the number generated was 7.) Then we tell the
    user to guess which number we’re thinking of. We perform `getLine` and bind its
    result to `numberString`. When the user enters `7`, `numberString` becomes `"7"`.
    Next, we use `when` to check if the string the user entered is an empty string.
    If it isn’t, the action consisting of the `do` block that is passed to `when`
    is performed. We use `read` on `numberString` to convert it to a number, so `number`
    is now `7`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the user enters some input that `read` can’t parse (like `"haha"`), our program
    will crash with an ugly error message. If you don’t want your program to crash
    on erronous input, use `reads`, which returns an empty list when it fails to read
    a string. When it succeeds, it returns a singleton list with a tuple that has
    your desired value as one component and a string with what it didn’t consume as
    the other. Try it!
  prefs: []
  type: TYPE_NORMAL
- en: We check if the number that we entered is equal to the one generated randomly
    and give the user the appropriate message. Then we perform `askForNumber` recursively,
    but this time with the new generator that we got. This gives us an I/O action
    that’s just like the one we performed, except that it depends on a different generator.
  prefs: []
  type: TYPE_NORMAL
- en: '`main` consists of just getting a random generator from the system and calling
    `askForNumber` with it to get the initial action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our program in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s another way to make this same program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: It’s very similar to the previous version, but instead of making a function
    that takes a generator and then calls itself recursively with the new updated
    generator, we do all the work in `main`. After telling the user whether he was
    correct in his guess, we update the global generator and then call `main` again.
    Both approaches are valid, but I like the first one more since it does less stuff
    in `main` and also provides a function I can reuse easily.
  prefs: []
  type: TYPE_NORMAL
- en: Bytestrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are certainly useful. So far, we’ve used them pretty much everywhere.
    There are a multitude of functions that operate on them, and Haskell’s laziness
    allows us to exchange the `for` and `while` loops of other languages for filtering
    and mapping over lists. Since evaluation will happen only when it really needs
    to, things like infinite lists (and even infinite lists of infinite lists!) are
    no problem for us. That’s why lists can also be used to represent streams, either
    when reading from the standard input or when reading from files. We can just open
    a file and read it as a string, even though it will be accessed only when the
    need arises.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802632.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, processing files as strings has one drawback: It tends to be slow.
    Lists are really lazy. Remember that a list like `[1,2,3,4]` is syntactic sugar
    for `1:2:3:4:[]`. When the first element of the list is forcibly evaluated (say
    by printing it), the rest of the list `2:3:4:[]` is still just a promise of a
    list, and so on. We call that promise a *thunk*.'
  prefs: []
  type: TYPE_NORMAL
- en: A thunk is basically a deferred computation. Haskell achieves its laziness by
    using thunks and computing them only when it must, instead of computing everything
    up front. So you can think of lists as promises that the next element will be
    delivered once it really has to be, and along with it, the promise of the element
    after it. It doesn’t take a big mental leap to conclude that processing a simple
    list of numbers as a series of thunks might not be the most efficient technique
    in the world.
  prefs: []
  type: TYPE_NORMAL
- en: That overhead doesn’t bother us most of the time, but it turns out to be a liability
    when reading big files and manipulating them. That’s why Haskell has *bytestrings*.
    Bytestrings are sort of like lists, only each element is one byte (or 8 bits)
    in size. The way they handle laziness is also different.
  prefs: []
  type: TYPE_NORMAL
- en: Strict and Lazy Bytestrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bytestrings come in two flavors: strict and lazy. Strict bytestrings reside
    in `Data.ByteString`, and they do away with the laziness completely. There are
    no thunks involved. A strict bytestring represents a series of bytes in an array.
    You can’t have things like infinite strict bytestrings. If you evaluate the first
    byte of a strict bytestring, you must evaluate the whole thing.'
  prefs: []
  type: TYPE_NORMAL
- en: The other variety of bytestrings resides in `Data.ByteString.Lazy`. They’re
    lazy, but not quite as lazy as lists. Since there are as many thunks in a list
    as there are elements, they are kind of slow for some purposes. Lazy bytestrings
    take a different approach. They are stored in chunks (not to be confused with
    thunks!), and each chunk has a size of 64KB. So if you evaluate a byte in a lazy
    bytestring (by printing it, for example), the first 64KB will be evaluated. After
    that, it’s just a promise for the rest of the chunks. Lazy bytestrings are kind
    of like lists of strict bytestrings, with a size of 64KB. When you process a file
    with lazy bytestrings, it will be read chunk by chunk. This is cool because it
    won’t cause the memory usage to skyrocket, and the 64KB probably fits neatly into
    your CPU’s L2 cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look through the documentation for `Data.ByteString.Lazy`, you will
    see that it has a lot of functions with the same names as the ones from `Data.List`,
    but the type signatures have `ByteString` instead of `[a]` and `Word8` instead
    of `a`. These functions are similar to the ones that work on lists. Because the
    names are the same, we’re going to do a qualified import in a script and then
    load that script into GHCi to play with bytestrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '`B` has lazy bytestring types and functions, whereas `S` has strict ones. We’ll
    mostly be using the lazy versions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pack` function has the type signature `pack :: [Word8] -> ByteString`.
    This means that it takes a list of bytes of type `Word8` and returns a `ByteString`.
    You can think of it as taking a list, which is lazy, and making it less lazy,
    so that it’s lazy only at 64KB intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Word8` type is like `Int`, but it represents an unsigned 8-bit number.
    This means that it has a much smaller range of only 0 to 255\. And just like `Int`,
    it’s in the `Num` type class. For instance, we know that the value `5` is polymorphic
    in that it can act like any numeric type, including `Word8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we pack lists of numbers into bytestrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We packed only a handful of values into a bytestring, so they fit inside one
    chunk. `Empty` is like `[]` for lists—they both represent an empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you don’t need to specify that your numbers are of type `Word8`,
    because the type system can make numbers choose that type. If you try to use a
    big number like `336` as a `Word8`, it will just wrap around to `80`.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to examine a bytestring byte by byte, we need to unpack it. The
    `unpack` function is the inverse of `pack`. It takes a bytestring and turns it
    into a list of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also go back and forth between strict and lazy bytestrings. The `toChunks`
    function takes a lazy bytestring and converts it to a list of strict ones. The
    `fromChunks` function takes a list of strict bytestrings and converts it to a
    lazy bytestring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This is good if you have a lot of small strict bytestrings and you want to process
    them efficiently without joining them into one big strict bytestring in memory
    first.
  prefs: []
  type: TYPE_NORMAL
- en: The bytestring version of `:` is called `cons`. It takes a byte and a bytestring
    and puts the byte at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The bytestring modules have a load of functions that are analogous to those
    in `Data.List`, including, but not limited to, `head`, `tail`, `init`, `null`,
    `length`, `map`, `reverse`, `foldl`, `foldr`, `concat`, `takeWhile`, `filter`,
    and so on. For a complete listing of bytestring functions, check out the documentation
    for the bytestring package at [http://hackage.haskell.org/package/bytestring/](http://hackage.haskell.org/package/bytestring/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The bytestring modules also have functions that have the same name and behave
    the same as some functions found in `System.IO`, but `Strings` are replaced with
    `ByteStrings`. For instance, the `readFile` function in `System.IO` has this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readFile` function from the bytestring modules has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re using strict bytestrings and you attempt to read a file, all of that
    file will be read into memory at once! With lazy bytestrings, the file will be
    read in neat chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Files with Bytestrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s make a program that takes two filenames as command-line arguments and
    copies the first file into the second file. Note that `System.Directory` already
    has a function called `copyFile`, but we’re going to implement our own file-copying
    function and program anyway. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: To begin, in `main`, we just get the command-line arguments and call our `copy`
    function, which is where the magic happens. One way to do this would be to just
    read from one file and write to another. But if something goes wrong (such as
    we don’t have enough disk space to copy the file), we’ll be left with a messed-up
    file. So we’ll write to a temporary file first. Then if something goes wrong,
    we can just delete that file.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use `B.readFile` to read the contents of our source file. Then we
    use `bracketOnError` to set up our error handling. We acquire the resource with
    `openTempFile "." "temp"`, which yields a tuple that consists of a temporary filename
    and a handle. Next, we say what we want to happen if an error occurs. If something
    goes wrong, we close the handle and remove the temporary file. Finally, we do
    the copying itself. We use `B.hPutStr` to write the contents to our temporary
    file. We close the temporary file and rename it to what we want it to be in the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we just used `B.readFile` and `B.hPutStr` instead of their regular
    variants. We didn’t need to use special bytestring functions for opening, closing,
    and renaming files. We just need to use the bytestring functions when reading
    and writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: A program that doesn’t use bytestrings could look just like this. The only difference
    is that we used `B.readFile` and `B.writeFile` instead of `readFile` and `writeFile`.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, you can convert a program that uses normal strings to a program
    that uses bytestrings just by doing the necessary imports and then putting the
    qualified module names in front of some functions. Sometimes, you need to convert
    functions that you wrote to work on strings so that they work on bytestrings,
    but that’s not hard.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you need better performance in a program that reads a lot of data into
    strings, give bytestrings a try. Chances are you’ll get some good performance
    boosts with very little effort on your part. I usually write programs using normal
    strings and then convert them to use bytestrings if the performance is not satisfactory.
  prefs: []
  type: TYPE_NORMAL
