- en: Chapter 6. User Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This one can log in,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*this other can get email;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*never give out root.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) While computer intrusions
    over the Internet make headlines, a system administrator’s greatest security threats
    often come from a system’s own users. Maybe they won’t ship your data to a crime
    syndicate, but disgruntled and incompetent users will crash your servers given
    the chance—sometimes out of malice, but more often out of ignorance. Think about
    security as the combination of confidentiality, integrity, and availability, and
    it will immediately become clear how users with unrestricted system access can
    damage security.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite what you might have learned from the Bastard Operator from Hell, the
    system exists for the users, and proper management of those users’ accounts is
    absolutely necessary. In this chapter, we’ll cover one of the systems administrator’s
    most common tasks: managing users by adding, removing, configuring, and modifying
    user accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: The Root Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, there has been a trend toward using the privileged root account
    for everyday tasks on systems that have only a single user.^([[13](#ftn.id330569)])
    Using a privileged account to read your email and browse the Web increases your
    risks from both user errors and malicious attacks. While a careless keystroke
    by a regular user will generate only a `permission denied` error, that same keystroke
    by root might render your system unusable and destroy all your data. Even if you’re
    the only person using your OpenBSD system, you must use an unprivileged user account
    for day-to-day tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If an intruder compromises an unprivileged account, the potential damage is
    limited only by that user’s permissions. If the compromised account handles your
    email and web bookmarks, you might suffer only personal embarrassment. But if
    that account handles system administration tasks, your intruder can inflict unlimited
    system damage and send you scurrying for your backup. Using a regular account
    for day-to-day tasks means that you can take extra steps to restrict the root
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Perform all tasks with the minimum level of privilege necessary. If you don’t
    need root access to perform a task, don’t use it! For example, OpenBSD’s web server
    runs as the specific user `www`, rather than as root. If an intruder breaks into
    your web server and gains access your system as the `www` user, he can damage
    only the files the `www` user has permission to write to. Likewise, if the web
    server software goes into an error state and starts deleting files at random,
    this same principle limits the files it can delete. The least privilege approach
    protects the system from both intruders and its own software.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems that give every user privileged access have more problems
    as a result. Virus effectiveness, unexpected misconfiguration, and even crashes
    can be traced back to unnecessary privileged access. OpenBSD might be the most
    secure operating system in the world, but all those fancy security features can’t
    protect you from poor system administration practices.
  prefs: []
  type: TYPE_NORMAL
- en: Using the root account for routine tasks also creates bad habits. People under
    pressure perform what they practice. If you use root on your desktop for routine
    work, you’ll need to fight your habits to perform routine tasks when you work
    on a production server. This sort of sloppiness inevitably breeds security problems.
    Even on my OpenBSD desktop, where I’m the only user, I do everything as a regular
    user specifically to develop and maintain good sysadmin habits.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenBSD uses many of the standard UNIX user- and password-management programs,
    such as `passwd(1)` and `vipw(8)`. It also includes a friendly interactive user-creation
    program, `adduser(8)`. We’ll cover `adduser` first, and then look at some of the
    more advanced tools.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users Interactively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only the root user can run `adduser`. If you start `adduser` at the command
    line without specifying any options, it drops you into a friendly interactive
    dialog where you can create new users.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring adduser
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first time `adduser` runs, it asks a series of questions to determine its
    default settings. It saves these default settings, but you can change the defaults
    later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: adduser first asks for your preferred default shell. It reads */etc/shells*
    to see all the shells installed on your system. Though I’ve long used tcsh, I
    usually start new users with the OpenBSD standard of ksh **1**. That way, they
    have a shell that more closely resembles what is used by the rest of the world,
    and they quickly learn that I cannot answer questions about their shell.
  prefs: []
  type: TYPE_NORMAL
- en: Next, adduser asks for your default login class. I’ll cover login classes later
    in this chapter. For now, assign new users to the default login class at **2**.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a default OpenBSD installation, your user home directories are on
    the */home* partition. If not, specify the default home directory at **3**.
  prefs: []
  type: TYPE_NORMAL
- en: User accounts need configuration dotfiles (*.shrc*, *.login*, *.profile*, and
    so on). If you have a directory containing customized dotfiles, tell adduser about
    it at **4**. Otherwise, just accept the default.
  prefs: []
  type: TYPE_NORMAL
- en: Though OpenBSD doesn’t include a welcome message by default, you can put one
    on the system so new users will have an email waiting for them on their first
    login. Give adduser the full path to the file containing your welcome message
    at **5**.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you create user accounts, you might want to provide a password
    when you create the user account. Accounts created without passwords are disabled
    until a password is assigned. If you won’t be assigning passwords when creating
    accounts, you can tell adduser not to prompt you for them at **6**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can choose the encryption algorithm used to hash user passwords,
    which are stored in */etc/master.passwd*. Unless you have specific interoperability
    needs or otherwise know what you’re doing, accept the default at **7**.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, adduser will use these chosen defaults. If you want to modify the
    defaults later on, change them in */etc/adduser.conf*. Read the adduser(8) man
    page for a complete list of configuration file options.
  prefs: []
  type: TYPE_NORMAL
- en: Creating User Accounts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve set your default options, run adduser again to create user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Start by assigning a username. Many people are irrationally attached to particular
    usernames, and it’s polite to ask them if they have a preference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you have a username, you’ll get a chance to enter the user’s real name
    or the account’s intended purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The shell you specify is a matter of user preference. The list of shells is
    taken from */etc/shells*, with the addition of the `nologin` option. Users can
    change their shell unless you specifically prevent that, so don’t worry too much
    about which shell you assign.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, choose a user ID (UID) number. By default, UID numbering starts at 1000,
    and `adduser` uses the lowest available number. You can change this if needed
    to match some local standard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By default, new users are assigned to a group with the same name as their username.
    Each user can be assigned to only a single login group (or primary group), but
    you can assign user accounts to multiple secondary groups if needed. If you want
    this user to be able to use the root account, invite the user to the `wheel` group.
    Other common groups include `staff`, `users`, and `operator`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Choose a login class for the user. If you don’t understand login classes yet,
    accept the default. I recommend assigning administrative users—for example, those
    in the `wheel` group—to the `staff` class. If you’re a desktop user, you want
    to be in the `staff` login class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you set `adduser` to ask for passwords, it will ask you for a password, and
    then ask again to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now `adduser` displays everything you selected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Either accept or reject the user at this point. If you accept, `adduser` will
    create the new user and ask if you want to create another user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users Noninteractively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to create many users, you probably don’t want to spend your day
    looping through `adduser` dialogs. If you have scripts, cron jobs, or web interfaces
    that add user accounts, you’ll want to create users noninteractively. `adduser`’s
    `-batch` flag enables this. When you use batch mode, `adduser` takes four additional
    arguments: the username, the groups the username belongs to, the full name, and
    the password in encrypted format.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To create our user `pkdick` in batch mode, we would run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note here is that `pkdick`’s password is *not* `NotThePassword`.
    `adduser` expects us to provide a random salt that hashes to the string `NotThePassword`,
    not the password itself. For instructions on how to generate encrypted passwords,
    see [Passwords and Batch Mode](ch06.html#passwords_and_batch_mode "Passwords and
    Batch Mode").
  prefs: []
  type: TYPE_NORMAL
- en: Groups in Batch Mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, new users are assigned a primary group with the same name as their
    login name. In batch mode, you must specify additional groups desired on the command
    line. Our example user `pkdick` is created with the login group of `pkdick`. If
    you want to set a different login group for a particular user, use the `-group`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You’ll need to add the user to another group. Here, I gave `jgballard` the login
    group of `guest` and added him to the group `customers`.
  prefs: []
  type: TYPE_NORMAL
- en: To assign a user to multiple groups, separate the groups using commas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The end result here is that `jgballard` is assigned to the `jgballard` primary
    group and added to the `customers` and `sftp-only` secondary groups.
  prefs: []
  type: TYPE_NORMAL
- en: Passwords and Batch Mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you actually follow any of the previous examples, you’ll create an account
    with no known password. Modern Unix-like operating systems don’t store passwords
    in readable format; instead, passwords are stored as a hash of the password and
    a random salt. When you assign a password to a user, the system takes the password,
    adds the salt, and performs some horrible computations to generate a hash of the
    password. The system then stores that hash and salt in the */etc/master.passwd*
    file. When you attempt to log in, the login process takes your password, adds
    the salt, and computes the hash of that combination. If the computed hash matches
    what’s stored in */etc/master.passwd*, the login is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: The examples create an account with a password hash of `NotThePassword`. Because
    this isn’t a legitimate hash, no entered password will match it. We need to provide
    a pregenerated encrypted password, enter an unencrypted password, and let `adduser`
    calculate the hash for us, or create an account without a password.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account without a password is the simplest option. OpenBSD will
    disable the account until you assign a password to it, but this is acceptable
    for accounts used to run daemons, or if you have a help desk staff to assist new
    users in setting passwords. To create an account without a password, simply omit
    the password from the account-creation process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to enter an unencrypted password on the command line, use the `-unencrypted`
    option. Put this option before the `-batch` option. For example, to give Phil’s
    account the password `IsThePassword`, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This account now has a password of `IsThePassword`. You might use this inside
    a script or when no one is around to look over your shoulder. The password will
    appear in the system’s process list, however, so any users on the system can see
    the password if they’re quick enough to notice.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to generate a prehashed password using `encrypt(1)`. By default,
    `encrypt` gives you a blank line. When you enter a word, it returns the hash of
    that word. It defaults to using the encryption algorithm defined in the `default`
    login class. (For the past several years, this has been Blowfish.) You can enter
    any number of words, and each will be hashed separately. Press CTRL-C to exit
    `encrypt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you’re encrypting only one password or creating passwords interactively,
    give the `-p` option to `encrypt`. This gives you a non-echoing password prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Other Batch Mode Options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I frequently create administrator accounts with one set of standards and unprivileged
    accounts with another. I create sysadmin accounts by hand using `adduser` in interactive
    mode (I don’t create sysadmin accounts very often). Someone else creates unprivileged
    user accounts using an `adduser` batch mode script I wrote. *adduser.conf* contains
    the default settings for sysadmins, which I then override in the script. This
    approach requires less of my organic memory and ensures that unprivileged accounts
    are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: All of these options must appear on the command line before the `-batch` argument.
    `adduser` treats everything after `-batch` as account information.
  prefs: []
  type: TYPE_NORMAL
- en: The `-noconfig` option tells `adduser` to not read defaults from *adduser.conf*.
    Using this option in a script guarantees that sysadmin-friendly defaults in *adduser.conf*
    don’t leak into unprivileged accounts.
  prefs: []
  type: TYPE_NORMAL
- en: The `-dotdir` option specifies a directory for user dotfiles. All files in this
    directory are copied to the new user’s home directory. I often have special dotfiles
    for unprivileged users.
  prefs: []
  type: TYPE_NORMAL
- en: The `-home` option tells `adduser` where to create the new user’s home directory.
    This is not the actual home directory, but the base directory where the home directory
    will be created. For example, if all of your web server customers have home directories
    on the */www* partition, you might use `-home /www`.
  prefs: []
  type: TYPE_NORMAL
- en: To assign a nondefault login class, use the `-class` option.
  prefs: []
  type: TYPE_NORMAL
- en: The `-message` option gives a path to the new user message. To turn off a default
    of sending a message, use `-message no`.
  prefs: []
  type: TYPE_NORMAL
- en: To assign a shell, use `-shell` and the shell name as it appears in */etc/shells*,
    or `nologin` to disable logins.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you want to assign your batch-created users UIDs in a specific range.
    Maybe all of your customers have a UID above 10000, while sysadmins have a UID
    in the thousands. Specify a minimum UID with `-uid_start` and a maximum with `-uid_end`.
    If available, the login group created will be given a GID equal to the UID.
  prefs: []
  type: TYPE_NORMAL
- en: User Account Restrictions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: User accounts are subject to the following restrictions, fully documented in
    `adduser(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: Usernames can contain characters (preferably lowercase) and digits, as well
    as nonleading hyphens, periods, underscores, and a trailing `$`. Usernames can
    be no longer than 31 characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full names cannot contain a colon (`:`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other values must exist in the relevant files: shells must appear in */etc/shells*,
    login classes in */etc/login.conf*, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing User Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Removing unneeded user accounts is just as important as adding new ones. Use
    `rmuser(8)` to delete accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `rmuser` command displays the account entry from */etc/passwd*, giving you
    a chance to verify that you really want to delete this particular user. Read the
    account’s real name, and verify that you’re deleting the correct account. Next,
    `rmuser` asks if you want to delete the user’s home directory. If you suspect
    that you might need some files from that user account, you could choose to keep
    the directory around for a while. It automatically deletes the user’s cron jobs
    and incoming mail file.
  prefs: []
  type: TYPE_NORMAL
- en: Editing User Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You create users with privileges based on the knowledge you have at the time.
    The information you have is probably wrong, so get comfortable with editing users.
    In most cases, `chpass(1)` does everything you need in a user-friendly way.
  prefs: []
  type: TYPE_NORMAL
- en: Users can edit their own accounts by running `chpass` without any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, users can update their shell or change their directory information. Many
    applications ignore the directory information (phone numbers and office location)
    stored in */etc/passwd*, but in some places, it’s important. Make changes, save,
    and exit.
  prefs: []
  type: TYPE_NORMAL
- en: If you run `chpass` as root, giving a username as an argument, you get a very
    different picture.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can forcibly change the user’s password (although there are better
    ways to do this), shell, UID, password expiration, and so on, in addition to all
    of the user’s directory information.
  prefs: []
  type: TYPE_NORMAL
- en: Changes made through `chpass` affect only */etc/passwd*, */etc/master.passwd*,
    and */etc/group*. If you change a user’s UID, GID, or home directory, you must
    also make the corresponding changes to the files the user owns and his home directory;
    otherwise, the user’s account won’t work correctly. If */etc/passwd* lists your
    home directory as */newhome/mwlucas* in */etc/passwd*, but your files are in */home/mwlucas*,
    you’ll have trouble on your hands.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can’t edit */etc/master.passwd* or */etc/passwd* with just any
    text editor; you need to use tools that manage the corresponding password databases.
    If you insist on editing the password file by hand, you can use `vipw(8)` to directly
    edit */etc/passwd*. If you’re not familiar with `vipw`, stick with `chpass`. The
    most common use for `vipw` is when the password file is damaged, and the most
    common way someone damages the password file is by using `vipw`.
  prefs: []
  type: TYPE_NORMAL
- en: Login Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user’s shell can be used to limit what a user can do, but OpenBSD provides
    very specific access controls with login classes. Login classes, set in */etc/login.conf*,
    define the resources and information accessible to users. Login classes also let
    you control password length and expiration times, as well as external authentication
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Each user is assigned to a class, and each class places limits on available
    resources. When you change the limits on a class, the new limits are applied to
    each user the next time the user logs in. Define a user’s class when creating
    the account, or change it with `chpass`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, *login.conf* offers two classes for users, one class for daemons,
    and a few special-case classes. The `default` user class gives the user wide-ranging
    access to system resources and is suitable for machines with a limited number
    of shell users. The `staff` user class gives the user no restrictions on memory
    use, sets very high limits on the number of processes a user can run concurrently,
    and allows the user to log in even when logins are forbidden.
  prefs: []
  type: TYPE_NORMAL
- en: If these two classes meet your needs, and if you won’t be using an alternative
    authentication protocol like Remote Authentication Dial In User Service (RADIUS)
    or Kerberos, you can skip this section. If not, read on.
  prefs: []
  type: TYPE_NORMAL
- en: Login Class Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each class definition consists of a series of variable assignments describing
    the class’s resource limits, authentication, and environment. Each variable assignment
    in the class definition begins and ends with a colon. The backslash character
    indicates that the class continues on the next line, which makes the file more
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the definition of the `default` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `default` class has several variables. Some of these have fairly obvious
    interpretations. For example, the `path` variable at **1** assigns a default command
    search path to the user’s shell, usually visible to the user as `$PATH`. The `umask`
    setting at **2** assigns a default umask to the user’s shell. The user can override
    both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Other settings, such as `datasize-max` and `maxproc-max` at **3**, are harder
    to define by guesswork. We’ll go through some of the more commonly used values
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Similar in behavior to the `termcap` `tc` variables at **4** used to configure
    serial console clients in [Chapter 5](ch05.html "Chapter 5. The Boot Process"),
    the `default` class copies settings from the entries `auth-defaults` and `auth-ftp-defaults`
    elsewhere in *login.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: Some variables don’t require a value to trigger behavior; these values trigger
    a specified behavior simply by adding them to *login.conf*. For example, the presence
    of `requirehome` means that the user must have a valid home directory to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Changing login.conf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On many BSD systems, you must transform the *login.conf* file to a program-friendly
    database file, *login.conf.db*, with `cap_mkdb(8)`. OpenBSD doesn’t require this.
    Programs that check login classes first look for the login class database, and
    if they don’t find it, they directly parse *login.conf*. You can use `cap_mkdb`
    to create such a database, which will very slightly improve the performance of
    software that checks *login.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that once you create this database, you must rebuild it every time you
    edit *login.conf*. Database values in *login.conf.db* will always override your
    *login.conf* settings. Alternatively, you can remove *login.conf.db* and force
    programs to always parse *login.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend skipping `cap_mkdb` on modern hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Legal Values for login.conf Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *login.conf* variables accept only very specific values, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A full path to a text file or a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comma-separated list of environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comma-separated list of values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number (put a 0x in front of the number for hexadecimal, or a 0 in front for
    octal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A space-separated list of pathnames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A size, in bytes (default), kilobytes (K), megabytes (M), gigabytes (G), or
    512-byte blocks (T)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A time in some combination of seconds (assumed if no unit is given), minutes
    (m), hours (h), days (d), weeks (w), or years (y)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables that use pathnames accept the special symbols tilde (`~`) and dollar
    sign (`$`). A tilde followed by a slash or the user’s login name, or at the end
    of a pathname represents the user’s home directory. You can use `~/bin` to represent
    a `bin` directory in the user’s home directory. The dollar sign represents the
    username. For example, you might use `/var/mail/$` to represent the user’s incoming
    mail file.
  prefs: []
  type: TYPE_NORMAL
- en: Some variables require particular types of values. A path to the user’s home
    directory must be a full path, while the amount of memory a user can allocate
    must be a size. In most cases, legitimate answers are fairly obvious, but check
    `login.conf(5)` for a full listing of acceptable values.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Resource Limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resource limits allow you to control the amount of system resources any one
    user can monopolize at any one time. If several hundred users are logged in to
    one machine, and one user decides to compile LibreOffice, that person will consume
    far more than his fair share of processor time, memory, and I/O. By limiting the
    resources any one user can use, you can make the system more responsive for all
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Resource limits were more commonly used back when computing facilities were
    very expensive and departments received bills for the amount of computing time
    they used. These days, utilization accounting isn’t so important. It’s generally
    cheaper to buy more computing power than it is to configure accounting or resource
    limits. That said, if you have a buggy daemon that sometimes leaks and starts
    to soak up CPU time or memory, giving it a login class can prevent it from devouring
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-1](ch06.html#some_login_conf_resource_limits "Table 6-1. Table 6-1:
    Some login.conf Resource Limits") lists some resource-limiting *login.conf* variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1. Table 6-1: Some login.conf Resource Limits'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `coredumpsize` | Maximum size of a core dump file |'
  prefs: []
  type: TYPE_TB
- en: '| `cputime` | Maximum CPU time any one process can use |'
  prefs: []
  type: TYPE_TB
- en: '| `datasize` | Maximum data size per process |'
  prefs: []
  type: TYPE_TB
- en: '| `filesize` | Maximum size of any one file |'
  prefs: []
  type: TYPE_TB
- en: '| `maxproc` | Maximum number of processes |'
  prefs: []
  type: TYPE_TB
- en: '| `memorylocked` | Maximum locked-in core memory use per process |'
  prefs: []
  type: TYPE_TB
- en: '| `memoryuse` | Maximum core memory use per process |'
  prefs: []
  type: TYPE_TB
- en: '| `openfiles` | Maximum open file descriptors per process |'
  prefs: []
  type: TYPE_TB
- en: '| `stacksize` | Maximum stack size per process |'
  prefs: []
  type: TYPE_TB
- en: '| `vmemoryuse` | Maximum virtual memory use per process |'
  prefs: []
  type: TYPE_TB
- en: Resource limits are generally set per process. If you permit each process 200MB
    of RAM and allow 40 processes per user, you’ve just allocated each user 8GB of
    memory. Perhaps your system has a lot of memory, but does it really have that
    much?
  prefs: []
  type: TYPE_NORMAL
- en: All resource-limiting variables except `vmemoryuse` support maximum and current
    (advisory) limits. Users are warned by the system when they exceed current limits
    and cannot exceed the maximum limits. This works well on a cooperative system,
    where multiple users share resources but need to be notified when they are approaching
    their limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a current limit, add `-cur` to the variable name. To make a maximum
    limit, add `-max`. For example, to set a current and maximum limit on the number
    of processes a user can have, use this definition in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A user in this class will receive a warning when he uses more than 50 processes
    and will not be able to use more than 60 processes. If you do not specify a limit
    as current or maximum, it acts as both.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Shell Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can define environment settings in a user class. This can work better than
    setting them in the default shell profile, because changes affect all users immediately
    upon their next login. This setting will impact all user shells, even those that
    don’t read *.profile* or *.cshrc*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-2](ch06.html#some_login_conf_environment_variables "Table 6-2. Table
    6-2: Some login.conf Environment Variables") lists popular user class variables
    that affect the user environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2. Table 6-2: Some login.conf Environment Variables'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `hushlogin` | If present, no system information is given out during login.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ignorenologin` | User can log in even when */etc/nologin* file is present.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `nologin` | Path to a file. If the file exists, when a user tries to log
    in, the file contents are displayed and login is denied. |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | Default command search path. |'
  prefs: []
  type: TYPE_TB
- en: '| `priority` | User’s priority (nice) level. See `renice(1)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `requirehome` | If present, user must have valid home directory to log in.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setenv` | A comma-separated list of environment variables and values. |'
  prefs: []
  type: TYPE_TB
- en: '| `shell` | User shell. Overrides user shell selection in */etc/passwd*. The
    user’s `$SHELL` environment variable reflects */etc/passwd*, resulting in an inconsistent
    environment. Playing games with this is an excellent way to annoy your users.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `term` | Default terminal type, if environment can’t figure out terminal
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `umask` | Initial umask. Should always start with a 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `welcome` | Path to a file containing the login message. |'
  prefs: []
  type: TYPE_TB
- en: Password and Login Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the user environment, which can be configured in several different places,
    many password controls can be configured only via the user class. The password
    controls affect only the local password database, not Lightweight Directory Access
    Protocol (LDAP), Kerberos, RADIUS, or other remote password databases.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at some commonly used password controls.
  prefs: []
  type: TYPE_NORMAL
- en: '**`localcipher`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This controls the password hashing method used in */etc/master.passwd*. The
    default is Blowfish. Don’t change the password hashing method unless you’re trying
    to be compatible with a specific foreign Unix-like operating system. See `login.conf(5)`
    for the list of supported hashing algorithms.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`login-backoff`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This controls how quickly a user can struggle to remember his password. After
    this many unsuccessful login attempts, `login(1)` slows down how quickly it offers
    a new username and password prompt.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`passwordcheck`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This gives the full path to an external program that checks new passwords for
    quality. OpenBSD passes the password to the program on standard input. The program
    is expected to return a 0 if the password is adequate and a 1 if the password
    is inadequate. OpenBSD includes a very simple and limited password-quality checker;
    if you need a password-quality checker, check out `passwdqc` (*/usr/ports/security/passwdqc*).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`passwordtries`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the number of times `passwd(1)` uses the password-quality checker. If
    the user cannot come up with a sufficiently complicated password in this many
    tries, the new password is accepted anyway. If this is set to 0, a new password
    is accepted only when it passes the quality check.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`minpasswordlen`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the minimum length of a new password. Password length is not a measure
    of quality—a stream of 128 `A` characters is still a lousy password, but it might
    help you meet site requirements.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`passwordtime`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the maximum age of a password, in seconds. Use this to require regular
    password changes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`password-warn`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the length of time, in seconds, before `login(1)` begins warning the
    user of an expiring password.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`password-dead`**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the length of time, in seconds, after password expiration when the user
    may log in one last time, just to reset his own password. If the user does not
    reset his password, he cannot log in. This is a last-chance grace period; if the
    user blows this chance, sysadmin intervention is required to reset the password.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Changing Authentication Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD supports many different authentication mechanisms, such as the local
    password file, Kerberos, S/Key, RADIUS, and so on. Specify the authentication
    method desired in the user class definition, and OpenBSD will use it. This system
    behind this is called *BSD Authentication*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an authentication mechanism does not configure the authentication mechanism.
    For example, configuring a login class to authenticate via Kerberos doesn’t magically
    establish a Kerberos domain. If the specified authentication method is unavailable,
    classes configured to use that method will be unable to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Not all authentication methods interoperate with all protocols. For example,
    while SSH works with physical tokens, it doesn’t work with the `lchpass` authentication
    protocol, which allows users to change their password but disallows logins. Review
    the man page for each authentication method for details.
  prefs: []
  type: TYPE_NORMAL
- en: Some authentication methods require additional configuration. For example, if
    you want to use RADIUS authentication, you must tell your system where to find
    your RADIUS server. The special *login.conf* variables and their use are documented
    in the authentication method’s man page.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-3](ch06.html#bsd_authentication_methods "Table 6-3. Table 6-3: BSD
    Authentication Methods") lists the authentication methods supported by OpenBSD’s
    built-in BSD Authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-3. Table 6-3: BSD Authentication Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Man Page | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `activ` | `login_activ(8)` | Authenticate via ActivCard token |'
  prefs: []
  type: TYPE_TB
- en: '| `chpass` | `login_chpass(8)` | Change password, no shell |'
  prefs: []
  type: TYPE_TB
- en: '| `crypto` | `login_crypto(8)` | Authenticate via CRYPTOCard token |'
  prefs: []
  type: TYPE_TB
- en: '| `krb5` | `login_krb5(8)` | Authenticate via Kerberos |'
  prefs: []
  type: TYPE_TB
- en: '| `krb5-or-pwd` | `login_krb5-or-pwd(8)` | Try Kerberos, then local password
    database |'
  prefs: []
  type: TYPE_TB
- en: '| `lchpass` | `login_lchpass(8)` | Change local password |'
  prefs: []
  type: TYPE_TB
- en: '| `passwd` | `login_passwd(8)` | Authenticate against local password file |'
  prefs: []
  type: TYPE_TB
- en: '| `radius` | `login_radius(8)` | Authenticate against RADIUS server |'
  prefs: []
  type: TYPE_TB
- en: '| `reject` | `login_reject(8)` | Request a password, then deny the login |'
  prefs: []
  type: TYPE_TB
- en: '| `skey` | `login_skey(8)` | Authenticate via S/Key |'
  prefs: []
  type: TYPE_TB
- en: '| `snk` | `login_snk(8)` | Authenticate via SecureNet token |'
  prefs: []
  type: TYPE_TB
- en: '| `token` | `login_token(8)` | Authenticate via X9.9 token |'
  prefs: []
  type: TYPE_TB
- en: '| `yubikey` | `login_yubikey(8)` | Authenticate via Yubico YubiKey token |'
  prefs: []
  type: TYPE_TB
- en: The ports collection (discussed in [Chapter 13](ch13.html "Chapter 13. Software
    Management")) contains a few additional login methods, such as fingerprint scanners
    (*sysutils/login_fingerprint*), OATH one-time passwords (*sysutils/login_oath*),
    and LDAP integration (*sysutils/login_ldap*). You can also create your own custom
    authentication methods; see `login.conf(5)` for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the authentication method using the `auth` variable in *login.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Users in a class with this set try to authenticate via an X9.9 token. If that’s
    not possible, the system falls back on the local password database.
  prefs: []
  type: TYPE_NORMAL
- en: BSD Authentication supports different authentication methods for different daemons.
    You can specify a service name after the `auth` keyword, indicating that this
    set of authentication methods applies to only that particular service. You’ll
    frequently see login classes like `auth-ssh` and `auth-su`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of sample entries from the default *login.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This defines the class `auth-defaults`, with only one entry. By default, users
    in this class first use password authentication, and then S/Key authentication.
    The `auth-ftp-defaults` class defines `auth-ftp` as using the password database,
    and only the password database.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, I mentioned that the default class included two other
    classes. These are the `auth-defaults` and `auth-ftp-defaults` classes. Every
    other login class in the default *login.conf* file includes them by reference.
    If you change the authentication methods used by the `auth-defaults` class, that
    change will apply to every other login class.
  prefs: []
  type: TYPE_NORMAL
- en: Using Login Classes for RADIUS Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have a long-running love/hate relationship with RADIUS. It’s the lowest common
    denominator of authentication protocols. Just about every operating system and
    hardware device supports it, but it’s a finicky protocol with innumerable edge
    cases. Luckily, configuring OpenBSD as a RADIUS client is simple. Any RADIUS server
    can provide authentication services for OpenBSD.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to use another login service, such as LDAP or Kerberos, rather
    than RADIUS. But in certain cases, for certain users, RADIUS is adequate. RADIUS
    combined with Microsoft’s Internet Authentication Service gives you easy password
    synchronization with the local Windows domain and reduces your support load.
  prefs: []
  type: TYPE_NORMAL
- en: First, read `login_radius(8)`, and then configure your RADIUS server to permit
    access from your OpenBSD host. To configure RADIUS authentication, you need the
    RADIUS server’s IP address, the port RADIUS runs on, and a shared secret. (For
    historical reasons, it’s best to specify the RADIUS port explicitly rather than
    relying on */etc/services*.) In our example, the RADIUS server is 192.0.2.2, the
    port is 1812, and the secret is the string `Insubordination88`.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a directory to hold the server configuration file and set its
    permissions appropriately, as per `login_radius(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the file */etc/raddb/servers*. This file should contain a server
    and its secret, each on one line. Our *servers* file has only one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now change *login.conf* to use RADIUS by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `auth-defaults` class is OpenBSD’s default authentication class. If we change
    it, we change how every other class authenticates. We set the `auth` type to `radius`,
    and set the port and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately upon saving the file, OpenBSD will try to authenticate all user
    accounts against the RADIUS server. You might want to change the `auth-ftp` class
    to match.^([[14](#ftn.id472953)])
  prefs: []
  type: TYPE_NORMAL
- en: Until you confirm everything is working, keep an SSH session logged in as root
    so you can change *login.conf*. Otherwise, you might lock yourself out of the
    system, or at least out of the root account. If you can’t get into the system,
    you’ll need to reboot into single-user mode and edit *login.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the authentication scheme for all users might not be desirable, either.
    You might want `authpf(8)` users to authenticate against RADIUS, but have users
    in the `staff` class authenticate against the local password database. Perhaps
    you don’t want your root account to authenticate via RADIUS, so you need an `auth-su`
    login class that points at the local password database. Using login classes, you
    can configure user authentication to fit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Unprivileged User Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An unprivileged user account is a user account with no privileges to any programs
    or files. Many programs run as unprivileged users or use unprivileged users to
    perform specific duties. These unprivileged users get only the rights needed to
    perform a limited task.
  prefs: []
  type: TYPE_NORMAL
- en: “Only the rights needed to perform a limited task” sounds like every user account,
    doesn’t it? That’s true, but the account used by the least privileged human being
    still has more rights than many programs need. Any user with shell access usually
    has a home directory. Users can create files in their home directory, run text
    editors, process email, run scripts, and compile (if not install) software. An
    average shell user needs these minimal privileges, but programs do not. By having
    a program run as a very restricted user, you control the amount of damage the
    software or intruders can do to the system.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes several unprivileged users out of the box. Take a look at */etc/passwd*,
    and you’ll see accounts like `sshd`, `named`, `_ntp`, and so on. These are all
    unprivileged accounts used by specific server daemons. Examine them, and you’ll
    find several common characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Unprivileged users do not have normal home directories. Most share the home
    directory of */var/empty*, which is owned by root and contains nothing except
    a logging socket. Having a home directory the user cannot write to makes the account
    less flexible, but is good enough for most server daemons. If these users do own
    files on the system, file permissions are usually set so that the user cannot
    write to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, no one should ever log in to the system with these accounts. If
    the `named` user account is reserved for the DNS subsystem, why would anyone actually
    need to log in as that account? Unprivileged users are assigned a shell that specifically
    forbids logging in: */sbin/nologin*.'
  prefs: []
  type: TYPE_NORMAL
- en: How does all this enhance system security? Let’s pick on the web server, a common
    intrusion vector, as an example. OpenBSD runs its web server as the user `www`.
    Suppose an intruder discovers a security flaw in your website and can use this
    to make the web server execute arbitrary code. This is a security nightmare; our
    intruder can now make the server program do absolutely anything within its power.
    But what, exactly, is within the web server’s power?
  prefs: []
  type: TYPE_NORMAL
- en: A command prompt permits much more mischief and mayhem than a website, so the
    intruder will probably try to access a command prompt on the system. The `www`
    user has a shell that specifically disallows a command prompt. While this doesn’t
    categorically prevent the intruder from getting a command prompt, it does make
    it much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: But our intruder is clever. Through really excellent intrusion skills, he makes
    the web server open a high-numbered port that dumps clients into a root shell.
    He now has access to a command prompt and can wreak untold damage … or can he?
  prefs: []
  type: TYPE_NORMAL
- en: He has no home directory, and no permissions to create one. Any files he wants
    to store must go into a globally accessible directory such as */tmp* or */var/tmp*,
    increasing his visibility. The web server configuration file is not owned by the
    `www` user. Even if the intruder has a path into the web server, he cannot reconfigure
    it. He can’t change the website files, as the `www` user doesn’t own them. The
    `www` user doesn’t have access to anything on the system, actually. Additionally,
    OpenBSD’s built-in web server `chroot`s itself. Having broken into the web server
    program, the intruder now must escape the `chroot` and penetrate a privileged
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Can he penetrate your system? Possibly, but it will be much more difficult.
    If he is specifically targeting you or your company, he might go to the trouble.
    If he is just looking for easy meat, however, he will probably give up and go
    bother someone running a Linux or Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: Using unprivileged users doesn’t solve all security problems, mind you. The
    compromised `www` user can view web application source files. If your application
    is badly written or has database passwords hardcoded into hidden files, you’re
    still in trouble. But if you don’t use poorly written applications and you’ve
    kept your system updated and patched, the intruder will have a very hard time
    penetrating the rest of your server.
  prefs: []
  type: TYPE_NORMAL
- en: The nobody Account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first unprivileged account was `nobody`. It was created for use by the Network
    File System (NFS, discussed in [Chapter 9](ch09.html "Chapter 9. More Filesystems"))
    to map files owned by root on foreign systems. Decades ago, people started using
    `nobody` as a generic unprivileged user, running web servers, proxy servers, and
    other daemons as `nobody`. While this was better than running those programs as
    root, it’s still poor practice. If an intruder penetrated one of those programs,
    he would gain access to all processes owned by `nobody`. Our hypothetical web
    server intruder would suddenly have access not only to the web server, but also
    to the database, NFS, or anything else running as `nobody`!
  prefs: []
  type: TYPE_NORMAL
- en: Every daemon that needs to run as a user needs its own unprivileged accounts—the
    whole point of using unprivileged users is to minimize the damage one piece of
    software can inflict. Use them liberally. OpenBSD provides discrete unprivileged
    users for services as small as `finger(1)` and the audio system. Follow this example.
  prefs: []
  type: TYPE_NORMAL
- en: _username
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you take a look at */etc/passwd*, you’ll see that many unprivileged users
    have an underscore before their name, such as `_syslogd`, `_ldapd`, and `_dhcp`.
    This is an OpenBSD convention for identifying unprivileged users. Most add-on
    software also uses unprivileged usernames beginning with an underscore, such as
    `_mysql` and `_postgresql`.
  prefs: []
  type: TYPE_NORMAL
- en: Not all unprivileged usernames start with an underscore, however. Some of these
    are legacy users that OpenBSD retains for compatibility reasons, such as `nobody`.
    Others have a long history or support inflexible software, and changing them would
    be more annoyance than it’s worth.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of an underscore means that a user is unprivileged. The absence
    of an underscore means nothing; the user might be a normal account or it might
    be unprivileged. If you create your own unprivileged users, you don’t need to
    include a leading underscore, but doing so will help other system administrators
    understand what the user does.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Unprivileged Users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are common settings used for unprivileged users. You can change any of
    these as needed for your application.
  prefs: []
  type: TYPE_NORMAL
- en: '****username****. Assign a username related to the user’s functions, so that
    you’ll easily recognize it. Giving an unprivileged user a username like `_fgcrl`
    might seem like a good way to conceal its purpose, but it will confuse your sysadmins
    and an intruder will quickly figure it out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****home directory****. */var/empty* is a common setting for unprivileged users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****shell****. */sbin/nologin* is a common setting for unprivileged users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****UID/GID****. Choose a specific range of UIDs and GIDs for your custom unprivileged
    users. OpenBSD reserves all UIDs below 1000 for system-assigned unprivileged users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****full name****. Assign a name describing the user’s role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****password****. Use `chpass(1)` to assign the user a single asterisk as their
    encrypted password. This disables the account password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These settings make your unprivileged user very unprivileged indeed. You can
    set all of these options except the password using `adduser(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to create, manage, and use user accounts, let’s
    discuss how to manage privileged users.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#id330569)]) This probably leaked through from the Microsoft culture,
    where for many years, every user had administrative access.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#id472953)]) Or you might not want to make this change. FTP transmits
    passwords in clear text, so you might want to use a separate password source for
    FTP connections. Why transmit passwords securely over one protocol, while transmitting
    them insecurely on a neighboring port?
  prefs: []
  type: TYPE_NORMAL
