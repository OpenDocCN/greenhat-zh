- en: Chapter 6. User Management
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第六章 用户管理
- en: '*This one can log in,*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个账户可以登录，*'
- en: '*this other can get email;*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个账户可以收邮件；*'
- en: '*never give out root.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*永远不要泄露root权限。*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) While computer intrusions
    over the Internet make headlines, a system administrator’s greatest security threats
    often come from a system’s own users. Maybe they won’t ship your data to a crime
    syndicate, but disgruntled and incompetent users will crash your servers given
    the chance—sometimes out of malice, but more often out of ignorance. Think about
    security as the combination of confidentiality, integrity, and availability, and
    it will immediately become clear how users with unrestricted system access can
    damage security.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](http://atomoreilly.com/source/nostarch/images/1616079.png) 虽然互联网上的计算机入侵成为头条新闻，但系统管理员最大的安全威胁通常来自系统自身的用户。他们可能不会将您的数据发送到犯罪集团，但不满和不称职的用户会抓住机会破坏您的服务器——有时是出于恶意，但更常见的是出于无知。将安全视为机密性、完整性和可用性的组合，您会立即明白不受限制的系统访问权限的用户如何损害安全。'
- en: 'Despite what you might have learned from the Bastard Operator from Hell, the
    system exists for the users, and proper management of those users’ accounts is
    absolutely necessary. In this chapter, we’ll cover one of the systems administrator’s
    most common tasks: managing users by adding, removing, configuring, and modifying
    user accounts.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可能从《地狱中的糟糕操作员》中学到了什么，但系统是为用户而存在的，并且正确管理这些用户的账户是绝对必要的。在本章中，我们将介绍系统管理员最常见的任务之一：通过添加、删除、配置和修改用户账户来管理用户。
- en: The Root Account
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Root账户
- en: In recent years, there has been a trend toward using the privileged root account
    for everyday tasks on systems that have only a single user.^([[13](#ftn.id330569)])
    Using a privileged account to read your email and browse the Web increases your
    risks from both user errors and malicious attacks. While a careless keystroke
    by a regular user will generate only a `permission denied` error, that same keystroke
    by root might render your system unusable and destroy all your data. Even if you’re
    the only person using your OpenBSD system, you must use an unprivileged user account
    for day-to-day tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，有一种趋势是在只有单个用户的系统上使用特权的root账户进行日常任务。[^([13](#ftn.id330569))] 使用特权账户阅读您的电子邮件和浏览网页会增加您因用户错误和恶意攻击而面临的风险。虽然普通用户的疏忽按键只会产生一个`权限拒绝`错误，但root用户的相同按键可能会使您的系统无法使用并破坏所有数据。即使您是唯一使用OpenBSD系统的人，您也必须使用无特权的用户账户进行日常任务。
- en: If an intruder compromises an unprivileged account, the potential damage is
    limited only by that user’s permissions. If the compromised account handles your
    email and web bookmarks, you might suffer only personal embarrassment. But if
    that account handles system administration tasks, your intruder can inflict unlimited
    system damage and send you scurrying for your backup. Using a regular account
    for day-to-day tasks means that you can take extra steps to restrict the root
    account.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果入侵者破坏了一个无特权的账户，潜在的损害仅限于该用户的权限。如果被破坏的账户处理您的电子邮件和网页书签，您可能只会遭受个人尴尬。但如果该账户处理系统管理任务，入侵者可以造成无限的系统损害并迫使您寻找备份。使用常规账户进行日常任务意味着您可以采取额外步骤来限制root账户。
- en: Perform all tasks with the minimum level of privilege necessary. If you don’t
    need root access to perform a task, don’t use it! For example, OpenBSD’s web server
    runs as the specific user `www`, rather than as root. If an intruder breaks into
    your web server and gains access your system as the `www` user, he can damage
    only the files the `www` user has permission to write to. Likewise, if the web
    server software goes into an error state and starts deleting files at random,
    this same principle limits the files it can delete. The least privilege approach
    protects the system from both intruders and its own software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用执行任务所需的最小权限级别。如果您不需要root权限来执行任务，就不要使用它！例如，OpenBSD的Web服务器以特定用户`www`的身份运行，而不是以root身份。如果入侵者入侵您的Web服务器并以`www`用户身份访问您的系统，他只能损坏`www`用户有权限写入的文件。同样，如果Web服务器软件进入错误状态并开始随机删除文件，这个相同的原则限制了它可以删除的文件。最小权限方法可以保护系统免受入侵者和自身软件的损害。
- en: Operating systems that give every user privileged access have more problems
    as a result. Virus effectiveness, unexpected misconfiguration, and even crashes
    can be traced back to unnecessary privileged access. OpenBSD might be the most
    secure operating system in the world, but all those fancy security features can’t
    protect you from poor system administration practices.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Using the root account for routine tasks also creates bad habits. People under
    pressure perform what they practice. If you use root on your desktop for routine
    work, you’ll need to fight your habits to perform routine tasks when you work
    on a production server. This sort of sloppiness inevitably breeds security problems.
    Even on my OpenBSD desktop, where I’m the only user, I do everything as a regular
    user specifically to develop and maintain good sysadmin habits.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenBSD uses many of the standard UNIX user- and password-management programs,
    such as `passwd(1)` and `vipw(8)`. It also includes a friendly interactive user-creation
    program, `adduser(8)`. We’ll cover `adduser` first, and then look at some of the
    more advanced tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users Interactively
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only the root user can run `adduser`. If you start `adduser` at the command
    line without specifying any options, it drops you into a friendly interactive
    dialog where you can create new users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Configuring adduser
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first time `adduser` runs, it asks a series of questions to determine its
    default settings. It saves these default settings, but you can change the defaults
    later.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: adduser first asks for your preferred default shell. It reads */etc/shells*
    to see all the shells installed on your system. Though I’ve long used tcsh, I
    usually start new users with the OpenBSD standard of ksh **1**. That way, they
    have a shell that more closely resembles what is used by the rest of the world,
    and they quickly learn that I cannot answer questions about their shell.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Next, adduser asks for your default login class. I’ll cover login classes later
    in this chapter. For now, assign new users to the default login class at **2**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: If you have a default OpenBSD installation, your user home directories are on
    the */home* partition. If not, specify the default home directory at **3**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: User accounts need configuration dotfiles (*.shrc*, *.login*, *.profile*, and
    so on). If you have a directory containing customized dotfiles, tell adduser about
    it at **4**. Otherwise, just accept the default.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Though OpenBSD doesn’t include a welcome message by default, you can put one
    on the system so new users will have an email waiting for them on their first
    login. Give adduser the full path to the file containing your welcome message
    at **5**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you create user accounts, you might want to provide a password
    when you create the user account. Accounts created without passwords are disabled
    until a password is assigned. If you won’t be assigning passwords when creating
    accounts, you can tell adduser not to prompt you for them at **6**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can choose the encryption algorithm used to hash user passwords,
    which are stored in */etc/master.passwd*. Unless you have specific interoperability
    needs or otherwise know what you’re doing, accept the default at **7**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: From now on, adduser will use these chosen defaults. If you want to modify the
    defaults later on, change them in */etc/adduser.conf*. Read the adduser(8) man
    page for a complete list of configuration file options.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Creating User Accounts
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve set your default options, run adduser again to create user accounts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Start by assigning a username. Many people are irrationally attached to particular
    usernames, and it’s polite to ask them if they have a preference.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have a username, you’ll get a chance to enter the user’s real name
    or the account’s intended purpose.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The shell you specify is a matter of user preference. The list of shells is
    taken from */etc/shells*, with the addition of the `nologin` option. Users can
    change their shell unless you specifically prevent that, so don’t worry too much
    about which shell you assign.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, choose a user ID (UID) number. By default, UID numbering starts at 1000,
    and `adduser` uses the lowest available number. You can change this if needed
    to match some local standard.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, new users are assigned to a group with the same name as their username.
    Each user can be assigned to only a single login group (or primary group), but
    you can assign user accounts to multiple secondary groups if needed. If you want
    this user to be able to use the root account, invite the user to the `wheel` group.
    Other common groups include `staff`, `users`, and `operator`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Choose a login class for the user. If you don’t understand login classes yet,
    accept the default. I recommend assigning administrative users—for example, those
    in the `wheel` group—to the `staff` class. If you’re a desktop user, you want
    to be in the `staff` login class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you set `adduser` to ask for passwords, it will ask you for a password, and
    then ask again to confirm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now `adduser` displays everything you selected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Either accept or reject the user at this point. If you accept, `adduser` will
    create the new user and ask if you want to create another user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users Noninteractively
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to create many users, you probably don’t want to spend your day
    looping through `adduser` dialogs. If you have scripts, cron jobs, or web interfaces
    that add user accounts, you’ll want to create users noninteractively. `adduser`’s
    `-batch` flag enables this. When you use batch mode, `adduser` takes four additional
    arguments: the username, the groups the username belongs to, the full name, and
    the password in encrypted format.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To create our user `pkdick` in batch mode, we would run this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One thing to note here is that `pkdick`’s password is *not* `NotThePassword`.
    `adduser` expects us to provide a random salt that hashes to the string `NotThePassword`,
    not the password itself. For instructions on how to generate encrypted passwords,
    see [Passwords and Batch Mode](ch06.html#passwords_and_batch_mode "Passwords and
    Batch Mode").
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Groups in Batch Mode
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, new users are assigned a primary group with the same name as their
    login name. In batch mode, you must specify additional groups desired on the command
    line. Our example user `pkdick` is created with the login group of `pkdick`. If
    you want to set a different login group for a particular user, use the `-group`
    flag.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll need to add the user to another group. Here, I gave `jgballard` the login
    group of `guest` and added him to the group `customers`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: To assign a user to multiple groups, separate the groups using commas.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The end result here is that `jgballard` is assigned to the `jgballard` primary
    group and added to the `customers` and `sftp-only` secondary groups.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Passwords and Batch Mode
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you actually follow any of the previous examples, you’ll create an account
    with no known password. Modern Unix-like operating systems don’t store passwords
    in readable format; instead, passwords are stored as a hash of the password and
    a random salt. When you assign a password to a user, the system takes the password,
    adds the salt, and performs some horrible computations to generate a hash of the
    password. The system then stores that hash and salt in the */etc/master.passwd*
    file. When you attempt to log in, the login process takes your password, adds
    the salt, and computes the hash of that combination. If the computed hash matches
    what’s stored in */etc/master.passwd*, the login is permitted.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The examples create an account with a password hash of `NotThePassword`. Because
    this isn’t a legitimate hash, no entered password will match it. We need to provide
    a pregenerated encrypted password, enter an unencrypted password, and let `adduser`
    calculate the hash for us, or create an account without a password.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account without a password is the simplest option. OpenBSD will
    disable the account until you assign a password to it, but this is acceptable
    for accounts used to run daemons, or if you have a help desk staff to assist new
    users in setting passwords. To create an account without a password, simply omit
    the password from the account-creation process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want to enter an unencrypted password on the command line, use the `-unencrypted`
    option. Put this option before the `-batch` option. For example, to give Phil’s
    account the password `IsThePassword`, enter the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This account now has a password of `IsThePassword`. You might use this inside
    a script or when no one is around to look over your shoulder. The password will
    appear in the system’s process list, however, so any users on the system can see
    the password if they’re quick enough to notice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to generate a prehashed password using `encrypt(1)`. By default,
    `encrypt` gives you a blank line. When you enter a word, it returns the hash of
    that word. It defaults to using the encryption algorithm defined in the `default`
    login class. (For the past several years, this has been Blowfish.) You can enter
    any number of words, and each will be hashed separately. Press CTRL-C to exit
    `encrypt`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 `encrypt(1)` 生成预散列密码。默认情况下，`encrypt` 会给你一个空行。当你输入一个单词时，它会返回该单词的散列值。它默认使用在
    `default` 登录类中定义的加密算法。（过去几年一直是Blowfish。）你可以输入任意数量的单词，每个单词都会单独散列。按 CTRL-C 退出 `encrypt`。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you’re encrypting only one password or creating passwords interactively,
    give the `-p` option to `encrypt`. This gives you a non-echoing password prompt.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只加密一个密码或交互式创建密码，给 `encrypt` 选项提供 `-p`。这会给你一个非回显的密码提示。
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Other Batch Mode Options
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他批量模式选项
- en: I frequently create administrator accounts with one set of standards and unprivileged
    accounts with another. I create sysadmin accounts by hand using `adduser` in interactive
    mode (I don’t create sysadmin accounts very often). Someone else creates unprivileged
    user accounts using an `adduser` batch mode script I wrote. *adduser.conf* contains
    the default settings for sysadmins, which I then override in the script. This
    approach requires less of my organic memory and ensures that unprivileged accounts
    are consistent.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用 `adduser` 的交互模式手动创建管理员账户（我不经常创建系统管理员账户）。其他人使用我编写的 `adduser` 批量模式脚本来创建非特权用户账户。*adduser.conf*
    包含系统管理员的默认设置，然后我在脚本中覆盖这些设置。这种方法需要我更少的有机记忆，并确保非特权账户的一致性。
- en: All of these options must appear on the command line before the `-batch` argument.
    `adduser` treats everything after `-batch` as account information.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都必须出现在 `-batch` 参数之前的命令行上。`adduser` 将 `-batch` 之后的所有内容视为账户信息。
- en: The `-noconfig` option tells `adduser` to not read defaults from *adduser.conf*.
    Using this option in a script guarantees that sysadmin-friendly defaults in *adduser.conf*
    don’t leak into unprivileged accounts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`-noconfig` 选项告诉 `adduser` 不要从 *adduser.conf* 中读取默认值。在脚本中使用此选项可以确保 *adduser.conf*
    中的系统管理员友好默认值不会泄露到非特权账户中。'
- en: The `-dotdir` option specifies a directory for user dotfiles. All files in this
    directory are copied to the new user’s home directory. I often have special dotfiles
    for unprivileged users.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`-dotdir` 选项指定用户点文件的目录。此目录中的所有文件都将复制到新用户的家目录中。我经常为非特权用户准备特殊的点文件。'
- en: The `-home` option tells `adduser` where to create the new user’s home directory.
    This is not the actual home directory, but the base directory where the home directory
    will be created. For example, if all of your web server customers have home directories
    on the */www* partition, you might use `-home /www`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`-home` 选项告诉 `adduser` 在哪里创建新用户的家目录。这并不是实际的家目录，而是家目录将被创建的基础目录。例如，如果你的所有网站服务器客户的家目录都在
    */www* 分区上，你可能使用 `-home /www`。'
- en: To assign a nondefault login class, use the `-class` option.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配非默认登录类，使用 `-class` 选项。
- en: The `-message` option gives a path to the new user message. To turn off a default
    of sending a message, use `-message no`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`-message` 选项提供新用户消息的路径。要关闭默认发送消息，使用 `-message no`。'
- en: To assign a shell, use `-shell` and the shell name as it appears in */etc/shells*,
    or `nologin` to disable logins.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配一个 shell，使用 `-shell` 和 */etc/shells* 中显示的 shell 名称，或者使用 `nologin` 来禁用登录。
- en: Perhaps you want to assign your batch-created users UIDs in a specific range.
    Maybe all of your customers have a UID above 10000, while sysadmins have a UID
    in the thousands. Specify a minimum UID with `-uid_start` and a maximum with `-uid_end`.
    If available, the login group created will be given a GID equal to the UID.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你想为批量创建的用户分配特定范围内的 UIDs。也许所有客户都有一个大于 10000 的 UID，而系统管理员有一个千位数的 UID。使用 `-uid_start`
    指定最小 UID，使用 `-uid_end` 指定最大 UID。如果可用，创建的登录组将被分配一个与 UID 相等的 GID。
- en: User Account Restrictions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户账户限制
- en: User accounts are subject to the following restrictions, fully documented in
    `adduser(8)`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用户账户受到以下限制，这些限制在 `adduser(8)` 中有详细说明。
- en: Usernames can contain characters (preferably lowercase) and digits, as well
    as nonleading hyphens, periods, underscores, and a trailing `$`. Usernames can
    be no longer than 31 characters.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名可以包含字符（最好是小写）和数字，以及非开头的连字符、点、下划线和结尾的 `$`。用户名长度不能超过 31 个字符。
- en: Full names cannot contain a colon (`:`).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全名不能包含冒号 (`:`)。
- en: 'Other values must exist in the relevant files: shells must appear in */etc/shells*,
    login classes in */etc/login.conf*, and so on.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing User Accounts
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Removing unneeded user accounts is just as important as adding new ones. Use
    `rmuser(8)` to delete accounts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `rmuser` command displays the account entry from */etc/passwd*, giving you
    a chance to verify that you really want to delete this particular user. Read the
    account’s real name, and verify that you’re deleting the correct account. Next,
    `rmuser` asks if you want to delete the user’s home directory. If you suspect
    that you might need some files from that user account, you could choose to keep
    the directory around for a while. It automatically deletes the user’s cron jobs
    and incoming mail file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Editing User Accounts
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You create users with privileges based on the knowledge you have at the time.
    The information you have is probably wrong, so get comfortable with editing users.
    In most cases, `chpass(1)` does everything you need in a user-friendly way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Users can edit their own accounts by running `chpass` without any arguments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, users can update their shell or change their directory information. Many
    applications ignore the directory information (phone numbers and office location)
    stored in */etc/passwd*, but in some places, it’s important. Make changes, save,
    and exit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If you run `chpass` as root, giving a username as an argument, you get a very
    different picture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, you can forcibly change the user’s password (although there are better
    ways to do this), shell, UID, password expiration, and so on, in addition to all
    of the user’s directory information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Changes made through `chpass` affect only */etc/passwd*, */etc/master.passwd*,
    and */etc/group*. If you change a user’s UID, GID, or home directory, you must
    also make the corresponding changes to the files the user owns and his home directory;
    otherwise, the user’s account won’t work correctly. If */etc/passwd* lists your
    home directory as */newhome/mwlucas* in */etc/passwd*, but your files are in */home/mwlucas*,
    you’ll have trouble on your hands.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can’t edit */etc/master.passwd* or */etc/passwd* with just any
    text editor; you need to use tools that manage the corresponding password databases.
    If you insist on editing the password file by hand, you can use `vipw(8)` to directly
    edit */etc/passwd*. If you’re not familiar with `vipw`, stick with `chpass`. The
    most common use for `vipw` is when the password file is damaged, and the most
    common way someone damages the password file is by using `vipw`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Login Classes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user’s shell can be used to limit what a user can do, but OpenBSD provides
    very specific access controls with login classes. Login classes, set in */etc/login.conf*,
    define the resources and information accessible to users. Login classes also let
    you control password length and expiration times, as well as external authentication
    mechanisms.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Each user is assigned to a class, and each class places limits on available
    resources. When you change the limits on a class, the new limits are applied to
    each user the next time the user logs in. Define a user’s class when creating
    the account, or change it with `chpass`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: By default, *login.conf* offers two classes for users, one class for daemons,
    and a few special-case classes. The `default` user class gives the user wide-ranging
    access to system resources and is suitable for machines with a limited number
    of shell users. The `staff` user class gives the user no restrictions on memory
    use, sets very high limits on the number of processes a user can run concurrently,
    and allows the user to log in even when logins are forbidden.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: If these two classes meet your needs, and if you won’t be using an alternative
    authentication protocol like Remote Authentication Dial In User Service (RADIUS)
    or Kerberos, you can skip this section. If not, read on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Login Class Definitions
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each class definition consists of a series of variable assignments describing
    the class’s resource limits, authentication, and environment. Each variable assignment
    in the class definition begins and ends with a colon. The backslash character
    indicates that the class continues on the next line, which makes the file more
    readable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the definition of the `default` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `default` class has several variables. Some of these have fairly obvious
    interpretations. For example, the `path` variable at **1** assigns a default command
    search path to the user’s shell, usually visible to the user as `$PATH`. The `umask`
    setting at **2** assigns a default umask to the user’s shell. The user can override
    both of these.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Other settings, such as `datasize-max` and `maxproc-max` at **3**, are harder
    to define by guesswork. We’ll go through some of the more commonly used values
    in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Similar in behavior to the `termcap` `tc` variables at **4** used to configure
    serial console clients in [Chapter 5](ch05.html "Chapter 5. The Boot Process"),
    the `default` class copies settings from the entries `auth-defaults` and `auth-ftp-defaults`
    elsewhere in *login.conf*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Some variables don’t require a value to trigger behavior; these values trigger
    a specified behavior simply by adding them to *login.conf*. For example, the presence
    of `requirehome` means that the user must have a valid home directory to log in.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Changing login.conf
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On many BSD systems, you must transform the *login.conf* file to a program-friendly
    database file, *login.conf.db*, with `cap_mkdb(8)`. OpenBSD doesn’t require this.
    Programs that check login classes first look for the login class database, and
    if they don’t find it, they directly parse *login.conf*. You can use `cap_mkdb`
    to create such a database, which will very slightly improve the performance of
    software that checks *login.conf*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that once you create this database, you must rebuild it every time you
    edit *login.conf*. Database values in *login.conf.db* will always override your
    *login.conf* settings. Alternatively, you can remove *login.conf.db* and force
    programs to always parse *login.conf*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: I recommend skipping `cap_mkdb` on modern hardware.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Legal Values for login.conf Variables
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *login.conf* variables accept only very specific values, including the
    following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: A full path to a text file or a program
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comma-separated list of environment variables
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comma-separated list of values
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number (put a 0x in front of the number for hexadecimal, or a 0 in front for
    octal)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A space-separated list of pathnames
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A size, in bytes (default), kilobytes (K), megabytes (M), gigabytes (G), or
    512-byte blocks (T)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A time in some combination of seconds (assumed if no unit is given), minutes
    (m), hours (h), days (d), weeks (w), or years (y)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables that use pathnames accept the special symbols tilde (`~`) and dollar
    sign (`$`). A tilde followed by a slash or the user’s login name, or at the end
    of a pathname represents the user’s home directory. You can use `~/bin` to represent
    a `bin` directory in the user’s home directory. The dollar sign represents the
    username. For example, you might use `/var/mail/$` to represent the user’s incoming
    mail file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Some variables require particular types of values. A path to the user’s home
    directory must be a full path, while the amount of memory a user can allocate
    must be a size. In most cases, legitimate answers are fairly obvious, but check
    `login.conf(5)` for a full listing of acceptable values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Setting Resource Limits
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resource limits allow you to control the amount of system resources any one
    user can monopolize at any one time. If several hundred users are logged in to
    one machine, and one user decides to compile LibreOffice, that person will consume
    far more than his fair share of processor time, memory, and I/O. By limiting the
    resources any one user can use, you can make the system more responsive for all
    users.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Resource limits were more commonly used back when computing facilities were
    very expensive and departments received bills for the amount of computing time
    they used. These days, utilization accounting isn’t so important. It’s generally
    cheaper to buy more computing power than it is to configure accounting or resource
    limits. That said, if you have a buggy daemon that sometimes leaks and starts
    to soak up CPU time or memory, giving it a login class can prevent it from devouring
    the system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-1](ch06.html#some_login_conf_resource_limits "Table 6-1. Table 6-1:
    Some login.conf Resource Limits") lists some resource-limiting *login.conf* variables.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1. Table 6-1: Some login.conf Resource Limits'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `coredumpsize` | Maximum size of a core dump file |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `cputime` | Maximum CPU time any one process can use |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `datasize` | Maximum data size per process |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `filesize` | Maximum size of any one file |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `maxproc` | Maximum number of processes |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `memorylocked` | Maximum locked-in core memory use per process |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `memoryuse` | Maximum core memory use per process |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `openfiles` | Maximum open file descriptors per process |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `stacksize` | Maximum stack size per process |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `vmemoryuse` | Maximum virtual memory use per process |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: Resource limits are generally set per process. If you permit each process 200MB
    of RAM and allow 40 processes per user, you’ve just allocated each user 8GB of
    memory. Perhaps your system has a lot of memory, but does it really have that
    much?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: All resource-limiting variables except `vmemoryuse` support maximum and current
    (advisory) limits. Users are warned by the system when they exceed current limits
    and cannot exceed the maximum limits. This works well on a cooperative system,
    where multiple users share resources but need to be notified when they are approaching
    their limit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a current limit, add `-cur` to the variable name. To make a maximum
    limit, add `-max`. For example, to set a current and maximum limit on the number
    of processes a user can have, use this definition in the class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A user in this class will receive a warning when he uses more than 50 processes
    and will not be able to use more than 60 processes. If you do not specify a limit
    as current or maximum, it acts as both.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Shell Environment
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can define environment settings in a user class. This can work better than
    setting them in the default shell profile, because changes affect all users immediately
    upon their next login. This setting will impact all user shells, even those that
    don’t read *.profile* or *.cshrc*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-2](ch06.html#some_login_conf_environment_variables "Table 6-2. Table
    6-2: Some login.conf Environment Variables") lists popular user class variables
    that affect the user environment.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2. Table 6-2: Some login.conf Environment Variables'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `hushlogin` | If present, no system information is given out during login.
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `ignorenologin` | User can log in even when */etc/nologin* file is present.
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `nologin` | Path to a file. If the file exists, when a user tries to log
    in, the file contents are displayed and login is denied. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `path` | Default command search path. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `priority` | User’s priority (nice) level. See `renice(1)`. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `requirehome` | If present, user must have valid home directory to log in.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| `setenv` | A comma-separated list of environment variables and values. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `shell` | User shell. Overrides user shell selection in */etc/passwd*. The
    user’s `$SHELL` environment variable reflects */etc/passwd*, resulting in an inconsistent
    environment. Playing games with this is an excellent way to annoy your users.
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `term` | Default terminal type, if environment can’t figure out terminal
    type. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `umask` | Initial umask. Should always start with a 0. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `welcome` | Path to a file containing the login message. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: Password and Login Options
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the user environment, which can be configured in several different places,
    many password controls can be configured only via the user class. The password
    controls affect only the local password database, not Lightweight Directory Access
    Protocol (LDAP), Kerberos, RADIUS, or other remote password databases.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at some commonly used password controls.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**`localcipher`**'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This controls the password hashing method used in */etc/master.passwd*. The
    default is Blowfish. Don’t change the password hashing method unless you’re trying
    to be compatible with a specific foreign Unix-like operating system. See `login.conf(5)`
    for the list of supported hashing algorithms.
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`login-backoff`**'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This controls how quickly a user can struggle to remember his password. After
    this many unsuccessful login attempts, `login(1)` slows down how quickly it offers
    a new username and password prompt.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`passwordcheck`**'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This gives the full path to an external program that checks new passwords for
    quality. OpenBSD passes the password to the program on standard input. The program
    is expected to return a 0 if the password is adequate and a 1 if the password
    is inadequate. OpenBSD includes a very simple and limited password-quality checker;
    if you need a password-quality checker, check out `passwdqc` (*/usr/ports/security/passwdqc*).
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`passwordtries`**'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the number of times `passwd(1)` uses the password-quality checker. If
    the user cannot come up with a sufficiently complicated password in this many
    tries, the new password is accepted anyway. If this is set to 0, a new password
    is accepted only when it passes the quality check.
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`minpasswordlen`**'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the minimum length of a new password. Password length is not a measure
    of quality—a stream of 128 `A` characters is still a lousy password, but it might
    help you meet site requirements.
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`passwordtime`**'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the maximum age of a password, in seconds. Use this to require regular
    password changes.
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`password-warn`**'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the length of time, in seconds, before `login(1)` begins warning the
    user of an expiring password.
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`password-dead`**'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the length of time, in seconds, after password expiration when the user
    may log in one last time, just to reset his own password. If the user does not
    reset his password, he cannot log in. This is a last-chance grace period; if the
    user blows this chance, sysadmin intervention is required to reset the password.
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Changing Authentication Methods
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD supports many different authentication mechanisms, such as the local
    password file, Kerberos, S/Key, RADIUS, and so on. Specify the authentication
    method desired in the user class definition, and OpenBSD will use it. This system
    behind this is called *BSD Authentication*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Setting an authentication mechanism does not configure the authentication mechanism.
    For example, configuring a login class to authenticate via Kerberos doesn’t magically
    establish a Kerberos domain. If the specified authentication method is unavailable,
    classes configured to use that method will be unable to log in.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Not all authentication methods interoperate with all protocols. For example,
    while SSH works with physical tokens, it doesn’t work with the `lchpass` authentication
    protocol, which allows users to change their password but disallows logins. Review
    the man page for each authentication method for details.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Some authentication methods require additional configuration. For example, if
    you want to use RADIUS authentication, you must tell your system where to find
    your RADIUS server. The special *login.conf* variables and their use are documented
    in the authentication method’s man page.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-3](ch06.html#bsd_authentication_methods "Table 6-3. Table 6-3: BSD
    Authentication Methods") lists the authentication methods supported by OpenBSD’s
    built-in BSD Authentication.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-3. Table 6-3: BSD Authentication Methods'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Man Page | Description |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `activ` | `login_activ(8)` | Authenticate via ActivCard token |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| `chpass` | `login_chpass(8)` | Change password, no shell |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| `crypto` | `login_crypto(8)` | Authenticate via CRYPTOCard token |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| `krb5` | `login_krb5(8)` | Authenticate via Kerberos |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| `krb5-or-pwd` | `login_krb5-or-pwd(8)` | Try Kerberos, then local password
    database |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| `lchpass` | `login_lchpass(8)` | Change local password |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| `passwd` | `login_passwd(8)` | Authenticate against local password file |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| `radius` | `login_radius(8)` | Authenticate against RADIUS server |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `reject` | `login_reject(8)` | Request a password, then deny the login |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `skey` | `login_skey(8)` | Authenticate via S/Key |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `snk` | `login_snk(8)` | Authenticate via SecureNet token |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `token` | `login_token(8)` | Authenticate via X9.9 token |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `yubikey` | `login_yubikey(8)` | Authenticate via Yubico YubiKey token |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: The ports collection (discussed in [Chapter 13](ch13.html "Chapter 13. Software
    Management")) contains a few additional login methods, such as fingerprint scanners
    (*sysutils/login_fingerprint*), OATH one-time passwords (*sysutils/login_oath*),
    and LDAP integration (*sysutils/login_ldap*). You can also create your own custom
    authentication methods; see `login.conf(5)` for details.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the authentication method using the `auth` variable in *login.conf*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Users in a class with this set try to authenticate via an X9.9 token. If that’s
    not possible, the system falls back on the local password database.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: BSD Authentication supports different authentication methods for different daemons.
    You can specify a service name after the `auth` keyword, indicating that this
    set of authentication methods applies to only that particular service. You’ll
    frequently see login classes like `auth-ssh` and `auth-su`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of sample entries from the default *login.conf* file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This defines the class `auth-defaults`, with only one entry. By default, users
    in this class first use password authentication, and then S/Key authentication.
    The `auth-ftp-defaults` class defines `auth-ftp` as using the password database,
    and only the password database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, I mentioned that the default class included two other
    classes. These are the `auth-defaults` and `auth-ftp-defaults` classes. Every
    other login class in the default *login.conf* file includes them by reference.
    If you change the authentication methods used by the `auth-defaults` class, that
    change will apply to every other login class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Using Login Classes for RADIUS Authentication
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have a long-running love/hate relationship with RADIUS. It’s the lowest common
    denominator of authentication protocols. Just about every operating system and
    hardware device supports it, but it’s a finicky protocol with innumerable edge
    cases. Luckily, configuring OpenBSD as a RADIUS client is simple. Any RADIUS server
    can provide authentication services for OpenBSD.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to use another login service, such as LDAP or Kerberos, rather
    than RADIUS. But in certain cases, for certain users, RADIUS is adequate. RADIUS
    combined with Microsoft’s Internet Authentication Service gives you easy password
    synchronization with the local Windows domain and reduces your support load.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: First, read `login_radius(8)`, and then configure your RADIUS server to permit
    access from your OpenBSD host. To configure RADIUS authentication, you need the
    RADIUS server’s IP address, the port RADIUS runs on, and a shared secret. (For
    historical reasons, it’s best to specify the RADIUS port explicitly rather than
    relying on */etc/services*.) In our example, the RADIUS server is 192.0.2.2, the
    port is 1812, and the secret is the string `Insubordination88`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: First, create a directory to hold the server configuration file and set its
    permissions appropriately, as per `login_radius(8)`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now create the file */etc/raddb/servers*. This file should contain a server
    and its secret, each on one line. Our *servers* file has only one line:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now change *login.conf* to use RADIUS by default.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `auth-defaults` class is OpenBSD’s default authentication class. If we change
    it, we change how every other class authenticates. We set the `auth` type to `radius`,
    and set the port and the server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Immediately upon saving the file, OpenBSD will try to authenticate all user
    accounts against the RADIUS server. You might want to change the `auth-ftp` class
    to match.^([[14](#ftn.id472953)])
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Until you confirm everything is working, keep an SSH session logged in as root
    so you can change *login.conf*. Otherwise, you might lock yourself out of the
    system, or at least out of the root account. If you can’t get into the system,
    you’ll need to reboot into single-user mode and edit *login.conf*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Changing the authentication scheme for all users might not be desirable, either.
    You might want `authpf(8)` users to authenticate against RADIUS, but have users
    in the `staff` class authenticate against the local password database. Perhaps
    you don’t want your root account to authenticate via RADIUS, so you need an `auth-su`
    login class that points at the local password database. Using login classes, you
    can configure user authentication to fit your specific needs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Unprivileged User Accounts
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An unprivileged user account is a user account with no privileges to any programs
    or files. Many programs run as unprivileged users or use unprivileged users to
    perform specific duties. These unprivileged users get only the rights needed to
    perform a limited task.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: “Only the rights needed to perform a limited task” sounds like every user account,
    doesn’t it? That’s true, but the account used by the least privileged human being
    still has more rights than many programs need. Any user with shell access usually
    has a home directory. Users can create files in their home directory, run text
    editors, process email, run scripts, and compile (if not install) software. An
    average shell user needs these minimal privileges, but programs do not. By having
    a program run as a very restricted user, you control the amount of damage the
    software or intruders can do to the system.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes several unprivileged users out of the box. Take a look at */etc/passwd*,
    and you’ll see accounts like `sshd`, `named`, `_ntp`, and so on. These are all
    unprivileged accounts used by specific server daemons. Examine them, and you’ll
    find several common characteristics.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Unprivileged users do not have normal home directories. Most share the home
    directory of */var/empty*, which is owned by root and contains nothing except
    a logging socket. Having a home directory the user cannot write to makes the account
    less flexible, but is good enough for most server daemons. If these users do own
    files on the system, file permissions are usually set so that the user cannot
    write to them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, no one should ever log in to the system with these accounts. If
    the `named` user account is reserved for the DNS subsystem, why would anyone actually
    need to log in as that account? Unprivileged users are assigned a shell that specifically
    forbids logging in: */sbin/nologin*.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: How does all this enhance system security? Let’s pick on the web server, a common
    intrusion vector, as an example. OpenBSD runs its web server as the user `www`.
    Suppose an intruder discovers a security flaw in your website and can use this
    to make the web server execute arbitrary code. This is a security nightmare; our
    intruder can now make the server program do absolutely anything within its power.
    But what, exactly, is within the web server’s power?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: A command prompt permits much more mischief and mayhem than a website, so the
    intruder will probably try to access a command prompt on the system. The `www`
    user has a shell that specifically disallows a command prompt. While this doesn’t
    categorically prevent the intruder from getting a command prompt, it does make
    it much more difficult.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符比网站能造成更多的破坏和混乱，所以入侵者可能会尝试访问系统上的命令提示符。`www` 用户有一个不允许命令提示符的 shell。虽然这并不能完全阻止入侵者获得命令提示符，但它确实使这个过程变得更加困难。
- en: But our intruder is clever. Through really excellent intrusion skills, he makes
    the web server open a high-numbered port that dumps clients into a root shell.
    He now has access to a command prompt and can wreak untold damage … or can he?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的入侵者很聪明。通过真正出色的入侵技巧，他让 Web 服务器打开一个高编号端口，将客户端放入 root shell 中。现在他有了访问命令提示符的能力，可以造成无法估量的破坏……但他能吗？
- en: He has no home directory, and no permissions to create one. Any files he wants
    to store must go into a globally accessible directory such as */tmp* or */var/tmp*,
    increasing his visibility. The web server configuration file is not owned by the
    `www` user. Even if the intruder has a path into the web server, he cannot reconfigure
    it. He can’t change the website files, as the `www` user doesn’t own them. The
    `www` user doesn’t have access to anything on the system, actually. Additionally,
    OpenBSD’s built-in web server `chroot`s itself. Having broken into the web server
    program, the intruder now must escape the `chroot` and penetrate a privileged
    program.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 他没有家目录，也没有创建一个目录的权限。他想要存储的任何文件都必须放入全局可访问的目录，例如 */tmp* 或 */var/tmp*，这增加了他的可见性。Web
    服务器配置文件不是由 `www` 用户拥有的。即使入侵者有进入 Web 服务器的路径，他也不能重新配置它。他不能更改网站文件，因为 `www` 用户并不拥有它们。实际上，`www`
    用户无法访问系统上的任何东西。此外，OpenBSD 内置的 Web 服务器会将自己 `chroot`。入侵者已经进入了 Web 服务器程序，现在他必须逃离
    `chroot` 并渗透一个特权程序。
- en: Can he penetrate your system? Possibly, but it will be much more difficult.
    If he is specifically targeting you or your company, he might go to the trouble.
    If he is just looking for easy meat, however, he will probably give up and go
    bother someone running a Linux or Windows system.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 他能渗透你的系统吗？可能，但会困难得多。如果他专门针对你或你的公司，他可能会费这个劲。然而，如果他只是在寻找容易的目标，他可能会放弃，去烦扰那些运行 Linux
    或 Windows 系统的人。
- en: Using unprivileged users doesn’t solve all security problems, mind you. The
    compromised `www` user can view web application source files. If your application
    is badly written or has database passwords hardcoded into hidden files, you’re
    still in trouble. But if you don’t use poorly written applications and you’ve
    kept your system updated and patched, the intruder will have a very hard time
    penetrating the rest of your server.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非特权用户并不能解决所有安全问题，请注意。被破坏的 `www` 用户可以查看 Web 应用程序源文件。如果你的应用程序编写得不好，或者数据库密码硬编码在隐藏文件中，你仍然会遇到麻烦。但如果你不使用编写不良的应用程序，并且已经保持了系统的更新和修补，入侵者将很难渗透你的服务器其他部分。
- en: The nobody Account
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无权限账户
- en: The first unprivileged account was `nobody`. It was created for use by the Network
    File System (NFS, discussed in [Chapter 9](ch09.html "Chapter 9. More Filesystems"))
    to map files owned by root on foreign systems. Decades ago, people started using
    `nobody` as a generic unprivileged user, running web servers, proxy servers, and
    other daemons as `nobody`. While this was better than running those programs as
    root, it’s still poor practice. If an intruder penetrated one of those programs,
    he would gain access to all processes owned by `nobody`. Our hypothetical web
    server intruder would suddenly have access not only to the web server, but also
    to the database, NFS, or anything else running as `nobody`!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个非特权账户是 `nobody`。它是为了使用网络文件系统（NFS，在第 9 章中讨论）来映射外系统上 root 所拥有的文件而创建的。[第 9 章](ch09.html
    "第 9 章。更多文件系统")。几十年前，人们开始将 `nobody` 作为通用非特权用户使用，以 `nobody` 身份运行 Web 服务器、代理服务器和其他守护进程。虽然这比以
    root 身份运行那些程序要好，但这仍然是一种不良做法。如果入侵者渗透了那些程序之一，他将能够访问 `nobody` 所拥有的所有进程。我们假设的 Web
    服务器入侵者突然不仅能够访问 Web 服务器，还能访问数据库、NFS 或任何以 `nobody` 身份运行的程序！
- en: Every daemon that needs to run as a user needs its own unprivileged accounts—the
    whole point of using unprivileged users is to minimize the damage one piece of
    software can inflict. Use them liberally. OpenBSD provides discrete unprivileged
    users for services as small as `finger(1)` and the audio system. Follow this example.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每个需要以用户身份运行的守护进程都需要自己的无权限账户——使用无权限用户的主要目的是最小化单个软件可能造成的损害。要广泛使用它们。OpenBSD为从 `finger(1)`
    到音频系统这样的服务提供了离散的无权限用户。遵循这个例子。
- en: _username
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: _用户名
- en: If you take a look at */etc/passwd*, you’ll see that many unprivileged users
    have an underscore before their name, such as `_syslogd`, `_ldapd`, and `_dhcp`.
    This is an OpenBSD convention for identifying unprivileged users. Most add-on
    software also uses unprivileged usernames beginning with an underscore, such as
    `_mysql` and `_postgresql`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 */etc/passwd*，你会看到许多无权限用户的名字前有一个下划线，例如 `_syslogd`、`_ldapd` 和 `_dhcp`。这是OpenBSD用于识别无权限用户的约定。大多数附加软件也使用以下划线开头的无权限用户名，例如
    `_mysql` 和 `_postgresql`。
- en: Not all unprivileged usernames start with an underscore, however. Some of these
    are legacy users that OpenBSD retains for compatibility reasons, such as `nobody`.
    Others have a long history or support inflexible software, and changing them would
    be more annoyance than it’s worth.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有无权限用户名都以下划线开头。其中一些是OpenBSD为了兼容性保留的遗留用户，例如 `nobody`。其他用户有悠久的历史或支持不灵活的软件，更改它们可能弊大于利。
- en: The presence of an underscore means that a user is unprivileged. The absence
    of an underscore means nothing; the user might be a normal account or it might
    be unprivileged. If you create your own unprivileged users, you don’t need to
    include a leading underscore, but doing so will help other system administrators
    understand what the user does.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的存在意味着用户没有权限。没有下划线则没有任何意义；用户可能是一个普通账户，也可能是一个没有权限的账户。如果你创建了没有权限的用户，你不需要包含一个前置下划线，但这样做将有助于其他系统管理员理解该用户的作用。
- en: Creating Unprivileged Users
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建无权限用户
- en: Here are common settings used for unprivileged users. You can change any of
    these as needed for your application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于无权限用户的常见设置。你可以根据需要更改这些设置以适应你的应用程序。
- en: '****username****. Assign a username related to the user’s functions, so that
    you’ll easily recognize it. Giving an unprivileged user a username like `_fgcrl`
    might seem like a good way to conceal its purpose, but it will confuse your sysadmins
    and an intruder will quickly figure it out.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****用户名****。分配一个与用户功能相关的用户名，这样你就可以轻松识别它。给无权限用户一个像 `_fgcrl` 这样的用户名可能看起来是一种隐藏其目的的好方法，但它会混淆你的系统管理员，入侵者会很快发现它。'
- en: '****home directory****. */var/empty* is a common setting for unprivileged users.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****家目录****。*/var/empty* 是无权限用户的常见设置。'
- en: '****shell****. */sbin/nologin* is a common setting for unprivileged users.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****shell****。*/sbin/nologin* 是无权限用户的常见设置。'
- en: '****UID/GID****. Choose a specific range of UIDs and GIDs for your custom unprivileged
    users. OpenBSD reserves all UIDs below 1000 for system-assigned unprivileged users.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****UID/GID****。为你的自定义无权限用户选择一个特定的UID和GID范围。OpenBSD为系统分配的无权限用户保留了所有低于1000的UID。'
- en: '****full name****. Assign a name describing the user’s role.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****全名****。分配一个描述用户角色的名称。'
- en: '****password****. Use `chpass(1)` to assign the user a single asterisk as their
    encrypted password. This disables the account password.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****密码****。使用 `chpass(1)` 为用户分配一个单个星号作为加密密码。这将禁用账户密码。'
- en: These settings make your unprivileged user very unprivileged indeed. You can
    set all of these options except the password using `adduser(8)`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置确实使你的无权限用户非常没有权限。你可以使用 `adduser(8)` 设置除密码之外的所有这些选项。
- en: Now that you understand how to create, manage, and use user accounts, let’s
    discuss how to manage privileged users.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何创建、管理和使用用户账户，让我们讨论如何管理有权限的用户。
- en: '* * *'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[13](#id330569)]) This probably leaked through from the Microsoft culture,
    where for many years, every user had administrative access.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#id330569)]) 这可能是从微软文化中泄露出来的，在许多年里，每个用户都有管理权限。
- en: ^([[14](#id472953)]) Or you might not want to make this change. FTP transmits
    passwords in clear text, so you might want to use a separate password source for
    FTP connections. Why transmit passwords securely over one protocol, while transmitting
    them insecurely on a neighboring port?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#id472953)]) 或者你可能不想进行这个更改。FTP 以明文形式传输密码，因此你可能想为FTP连接使用单独的密码源。为什么在一个协议上安全地传输密码，而在相邻的端口上不安全地传输？
