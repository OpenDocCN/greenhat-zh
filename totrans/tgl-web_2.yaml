- en: Part I. Anatomy of the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first part of this book focuses on the principal concepts that govern the
    operation of web browsers, namely, the protocols, document formats, and programming
    languages that make it all tick. Because all the familiar, user-visible security
    mechanisms employed in modern browsers are profoundly intertwined with these inner
    workings, the bare internals deserve a fair bit of attention before we wander
    off deeper into the woods.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. It Starts with a URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most recognizable hallmark of the Web is a simple text string known as the
    *Uniform Resource Locator (URL)*. Each well-formed, fully qualified URL is meant
    to conclusively address and uniquely identify a single resource on a remote server
    (and in doing so, implement a couple of related, auxiliary functions). The URL
    syntax is the cornerstone of the address bar, the most important user interface
    (UI) security indicator in every browser.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to true URLs used for content retrieval, several classes of *pseudo-URLs*
    use a similar syntax to provide convenient access to browser-level features, including
    the integrated scripting engine, several special document-rendering modes, and
    so on. Perhaps unsurprisingly, these pseudo-URL actions can have a significant
    impact on the security of any site that decides to link to them.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to figure out how a particular URL will be interpreted by the browser,
    and the side effects it will have, is one of the most basic and common security
    tasks attempted by humans and web applications alike, but it can be a problematic
    one. The generic URL syntax, the work of Tim Berners-Lee, is codified primarily
    in RFC 3986;^([[94](pr03.html#ftn.CHP-2-FT-1)]) its practical uses on the Web
    are outlined in RFCs 1738,^([[95](pr03.html#ftn.CHP-2-FT-2)]) 2616,^([[96](pr03.html#ftn.CHP-2-FT-3)])
    and a couple of other, less-significant standards. These documents are remarkably
    detailed, resulting in a fairly complex parsing model, but they are not precise
    enough to lead to harmonious, compatible implementations in all client software.
    In addition, individual software vendors have chosen to deviate from the specifications
    for their own reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a closer look at how the humble URL works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform Resource Locator Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Figure 2-1](ch02.html#structure_of_an_absolute_url "Figure 2-1. Structure
    of an absolute URL") shows the format of a *fully qualified absolute URL*, one
    that specifies all information required to access a particular resource and that
    does not depend in any way on where the navigation began. In contrast, a *relative
    URL*, such as *../file.php?text=hello+world*, omits some of this information and
    must be interpreted in the context of a base URL associated with the current browsing
    context.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structure of an absolute URL](httpatomoreillycomsourcenostarchimages949989.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1. Structure of an absolute URL
  prefs: []
  type: TYPE_NORMAL
- en: The segments of the absolute URL seem intuitive, but each comes with a set of
    gotchas, so let’s review them now.
  prefs: []
  type: TYPE_NORMAL
- en: Scheme Name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *scheme name* is a case-insensitive string that ends with a single colon,
    indicating the protocol to be used to retrieve the resource. The official registry
    of valid URL schemes is maintained by the *Internet Assigned Numbers Authority*
    (*IANA*), a body more widely known for its management of the IP address space.^([[97](pr03.html#ftn.CHP-2-FT-4)])
    IANA’s current list of valid scheme names includes several dozen entries such
    as *http:*, *https:*, and *ftp:*; in practice, a much broader set of schemes is
    informally recognized by common browsers and third-party applications, some which
    have special security consequences. (Of particular interest are several types
    of pseudo-URLs, such as *data:* or *javascript:*, as discussed later in this chapter
    and throughout the remainder of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before they can do any further parsing, browsers and web applications need
    to distinguish fully qualified absolute URLs from relative ones. The presence
    of a valid scheme in front of the address is meant to be the key difference, as
    defined in RFC 1738: In a compliant absolute URL, only the alphanumerics “+”,
    “−”, and “.” may appear before the required “:”. In practice, however, browsers
    deviate from this guidance a bit. All ignore leading newlines and white spaces.
    Internet Explorer ignores the entire nonprintable character range of ASCII codes
    0x01 to 0x1F. Chrome additionally skips 0x00, the NUL character. Most implementations
    also ignore newlines and tabs in the middle of scheme names, and Opera accepts
    high-bit characters in the string.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of these incompatibilities, applications that depend on the ability
    to differentiate between relative and absolute URLs must conservatively reject
    any anomalous syntax—but as we will soon find out, even this is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: Indicator of a Hierarchical URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to comply with the generic syntax rules laid out in RFC 1738, every
    absolute, hierarchical URL is required to contain the fixed string “//” right
    before the authority section. If the string is missing, the format and function
    of the remainder of the URL is undefined for the purpose of that specification
    and must be treated as an opaque, scheme-specific value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An example of a nonhierarchical URL is the *mailto:* protocol, used to specify
    email addresses and possibly a subject line (*mailto:*[user@example.com?subject=Hello+world](mailto:user@example.com?subject=Hello+world)).
    Such URLs are passed down to the default mail client without making any further
    attempt to parse them.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a generic, hierarchical URL syntax is, in theory, an elegant
    one. It ought to enable applications to extract some information about the address
    without knowing how a particular scheme works. For example, without a preconceived
    notion of the *wacky-widget:* protocol, and by applying the concept of generic
    URL syntax alone, the browser could decide that [http://example.com/test1/](http://example.com/test1/)
    and *wacky-widget://example.com/test2/* reference the same, trusted remote host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regrettably, the specification has an interesting flaw: The aforementioned
    RFC says nothing about what the implementer should do when encountering URLs where
    the scheme is known to be nonhierarchical but where a “//” prefix still appears,
    or vice versa. In fact, a reference parser implementation provided in RFC 1630
    contains an unintentional loophole that gives a counterintuitive meaning to the
    latter class of URLs. In RFC 3986, published some years later, the authors sheepishly
    acknowledge this flaw and permit implementations to try to parse such URLs for
    compatibility reasons. As a consequence, many browsers interpret the following
    examples in unexpected ways:'
  prefs: []
  type: TYPE_NORMAL
- en: http:example.com/ In Firefox, Chrome, and Safari, this address may be treated
    identically to [http://example.com/](http://example.com/) when no fully qualified
    base URL context exists and as a relative reference to a directory named *example.com*
    when a valid base URL is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: javascript://example.com/%0Aalert(1) This string is interpreted as a valid nonhierarchical
    pseudo-URL in all modern browsers, and the JavaScript *alert(1)* code will execute,
    showing a simple dialog window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mailto://user@example.com Internet Explorer accepts this URL as a valid nonhierarchical
    reference to an email address; the “//” part is simply skipped. Other browsers
    disagree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credentials to Access the Resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The credentials portion of the URL is optional. This location can specify a
    username, and perhaps a password, that may be required to retrieve the data from
    the server. The method through which these credentials are exchanged is not specified
    as a part of the abstract URL syntax, and it is always protocol specific. For
    those protocols that do not support authentication, the behavior of a credential-bearing
    URL is simply undefined.
  prefs: []
  type: TYPE_NORMAL
- en: When no credentials are supplied, the browser will attempt to fetch the resource
    anonymously. In the case of HTTP and several other protocols, this means not sending
    any authentication data; for FTP, it involves logging into a guest account named
    *ftp* with a bogus password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most browsers accept almost any characters, other than general URL section
    delimiters, in this section with two exceptions: Safari, for unclear reasons,
    rejects a broader set of characters, including “<”, “>”, “{”, and “}”, while Firefox
    also rejects newlines.^([[10](#ftn.CHP-2-FN-1)])'
  prefs: []
  type: TYPE_NORMAL
- en: Server Address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For all fully qualified hierarchical URLs, the server address section must specify
    a case-insensitive DNS name (such as *example.com*), a raw IPv4 address (such
    as *127.0.0.1*), or an IPv6 address in square brackets (such as *[0:0:0:0:0:0:0:1]*),
    indicating the location of a server hosting the requested resource. Firefox will
    also accept IPv4 addresses and hostnames in square brackets, but other implementations
    reject them immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the RFC permits only canonical notations for IP addresses, standard
    C libraries used by most applications are much more relaxed, accepting noncanonical
    IPv4 addresses that mix octal, decimal, and hexadecimal notation or concatenate
    some or all of the octets into a single integer. As a result, the following options
    are recognized as equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: http://127.0.0.1/ This is a canonical representation of an IPv4 address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: http://0x7f.1/ This is a representation of the same address that uses a hexadecimal
    number to represent the first octet and concatenates all the remaining octets
    into a single decimal value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: http://017700000001/ The same address is denoted using a 0-prefixed octal value,
    with all octets concatenated into a single 32-bit integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A similar laid-back approach can be seen with DNS names. Theoretically, DNS
    labels need to conform to a very narrow character set (specifically, alphanumerics,
    “.”, and “-”, as defined in RFC 1035^([[98](pr03.html#ftn.CHP-2-FT-5)])), but
    many browsers will happily ask the underlying operating system resolver to look
    up almost anything, and the operating system will usually also not make a fuss.
    The exact set of characters accepted in the hostname and passed to the resolver
    varies from client to client. Safari is most rigorous, while Internet Explorer
    is the most permissive. Perhaps of note, several control characters in the 0x0A-0x0D
    and 0xA0-0xAD ranges are ignored by most browsers in this portion of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One fascinating behavior of the URL parsers in all of the mainstream browsers
    is their willingness to treat the character “![](httpatomoreillycomsourcenostarchimages949991.png)”
    (ideographic full stop, Unicode point U+3002) identically to a period in hostnames
    but not anywhere else in the URL. This is reportedly because certain Chinese keyboard
    mappings make it much easier to type this symbol than the expected 7-bit ASCII
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Server Port
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This server port is an optional section that describes a nonstandard network
    port to connect to on the previously specified server. Virtually all application-level
    protocols supported by browsers and third-party applications use TCP or UDP as
    the underlying transport method, and both TCP and UDP rely on 16-bit port numbers
    to separate traffic between unrelated services running on a single machine. Each
    scheme is associated with a default port on which servers for that protocol are
    customarily run (80 for HTTP, 21 for FTP, and so on), but the default can be overridden
    at the URL level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interesting and unintended side effect of this feature is that browsers can
    be tricked into sending attacker-supplied data to random network services that
    do not speak the protocol the browser expects them to. For example, one may point
    a browser to [http://mail.example.com:25/](http://mail.example.com:25/), where
    25 is a port used by the Simple Mail Transfer Protocol (SMTP) service rather than
    HTTP. This fact has caused a range of security problems and prompted a number
    of imperfect workarounds, as discussed in more detail in [Part II](pt02.html "Part II. Browser
    Security Features") of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical File Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next portion of the URL, the hierarchical file path, is envisioned as a
    way to identify a specific resource to be retrieved from the server, such as */documents/2009/my_diary.txt*.
    The specification quite openly builds on top of the Unix directory semantics,
    mandating the resolution of “/../” and “/./” segments in the path and providing
    a directory-based method for sorting out relative references in non-fully qualified
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the filesystem model must have seemed like a natural choice in the 1990s,
    when web servers acted as simple gateways to a collection of static files and
    the occasional executable script. But since then, many contemporary web application
    frameworks have severed any remaining ties with the filesystem, interfacing directly
    with database objects or registered locations in resident program code. Mapping
    these data structures to well-behaved URL paths is possible but not always practiced
    or practiced carefully. All of this makes automated content retrieval, indexing,
    and security testing more complicated than it should be.
  prefs: []
  type: TYPE_NORMAL
- en: Query String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The query string is an optional section used to pass arbitrary, nonhierarchical
    parameters to the resource earlier identified by the path. One common example
    is passing user-supplied terms to a server-side script that implements the search
    functionality, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Most web developers are accustomed to a particular layout of the query string;
    this familiar format is generated by browsers when handling HTML-based forms and
    follows this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly, such layout is not mandated in the URL RFCs. Instead, the query
    string is treated as an opaque blob of data that may be interpreted by the final
    recipient as it sees fit, and unlike the path, it is not encumbered with specific
    parsing rules.
  prefs: []
  type: TYPE_NORMAL
- en: Hints of the commonly used format can be found in an informational RFC 1630,^([[99](pr03.html#ftn.CHP-2-FT-6)])
    in a mail-related RFC 2368,^([[100](pr03.html#ftn.CHP-2-FT-7)]) and in HTML specifications
    dealing with forms.^([[101](pr03.html#ftn.CHP-2-FT-8)]) None of this is binding,
    and therefore, while it may be impolite, it is not a mistake for web applications
    to employ arbitrary formats for whatever data they wish to put in that part of
    the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fragment ID is an opaque value with a role similar to the query string but
    that provides optional instructions for the client application rather than the
    server. (In fact, the value is not supposed to be sent to the server at all.)
    Neither the format nor function of the fragment ID is clearly specified in the
    RFCs, but it is hinted that it may be used to address “subresources” in the retrieved
    document or to provide other document-specific rendering cues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, fragment identifiers have only a single sanctioned use in the
    browser: that of specifying the name of an anchor HTML element for in-document
    navigation. The logic is simple. If an anchor name is supplied in the URL and
    a matching HTML tag can be located, the document will be scrolled to that location
    for viewing; otherwise, nothing happens. Because the information is encoded in
    the URL, this particular view of a lengthy document could be easily shared with
    others or bookmarked. In this use, the meaning of a fragment ID is limited to
    scrolling an existing document, so there is no need to retrieve any new data from
    the server when only this portion of the URL is updated in response to user actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This interesting property has led to another, more recent and completely ad
    hoc use of this value: to store miscellaneous state information needed by client-side
    scripts. For example, consider a map-browsing application that puts the currently
    viewed map coordinates in the fragment identifier so that it will know to resume
    from that same location if the link is bookmarked or shared. Unlike updating the
    query string, changing the fragment ID on-the-fly will not trigger a time-consuming
    page reload, making this data-storage trick a killer feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together Again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the aforementioned URL segments is delimited by certain reserved characters:
    slashes, colons, question marks, and so on. To make the whole approach usable,
    these delimiting characters should not appear anywhere in the URL for any other
    purpose. With this assumption in mind, imagine a sample algorithm to split absolute
    URLs into the aforementioned functional parts in a manner at least vaguely consistent
    with how browsers accomplish this task. A reasonably decent example of such an
    algorithm could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 1: Extract the scheme name**.'
  prefs: []
  type: TYPE_NORMAL
- en: Scan for the first “:” character. The part of the URL to its left is the scheme
    name. Bail out if the scheme name does not conform to the expected set of characters;
    the URL may need to be treated as a relative one if so.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 2: Consume the hierarchical URL identifier**.'
  prefs: []
  type: TYPE_NORMAL
- en: The string “//” should follow the scheme name. Skip it if found; bail out if
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some parsing contexts, implementations will be just as happy with zero, one,
    or even three or more slashes instead of two, for usability reasons. In the same
    vein, from its inception, Internet Explorer accepted backslashes (\) in lieu of
    slashes in any location in the URL, presumably to assist inexperienced users.^([[11](#ftn.CHP-2-FN-2)])
    All browsers other than Firefox eventually followed this trend and recognize URLs
    such as *http:\\example.com\*.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 3: Grab the authority section**.'
  prefs: []
  type: TYPE_NORMAL
- en: Scan for the next “/”, “?”, or “#”, whichever comes first, to extract the authority
    section from the URL. As mentioned above, most browsers will also accept “\” as
    a delimiter in place of a forward slash, which may need to be accounted for. The
    semicolon (;) is another acceptable authority delimiter in browsers other than
    Internet Explorer and Safari; the reason for this decision is unknown.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 3A: Find the credentials, if any**.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the authority section is extracted, locate the at symbol (@) in the substring.
    If found, the leading snippet constitutes login credentials, which should be further
    tokenized at the first occurrence of a colon (if present) to split the login and
    password data.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 3B: Extract the destination address**.'
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the authority section is the destination address. Look for
    the first colon to separate the hostname from the port number. A special case
    is needed for bracket-enclosed IPv6 addresses, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 4: Identify the path (if present)**.'
  prefs: []
  type: TYPE_NORMAL
- en: If the authority section is followed immediately by a forward slash—or for some
    implementations, a backslash or semicolon, as noted earlier—scan for the next
    “?”, “#”, or end-of-string, whichever comes first. The text in between constitutes
    the path section, which should be normalized according to Unix path semantics.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 5: Extract the query string (if present)**.'
  prefs: []
  type: TYPE_NORMAL
- en: If the last successfully parsed segment is followed by a question mark, scan
    for the next “#” character or end-of-string, whichever comes first. The text in
    between is the query string.
  prefs: []
  type: TYPE_NORMAL
- en: '**STEP 6: Extract the fragment identifier (if present)**.'
  prefs: []
  type: TYPE_NORMAL
- en: If the last successfully parsed segment is followed by “#”, everything from
    that character to the end-of-string is the fragment identifier. Either way, you’re
    done!
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm may seem mundane, but it reveals subtle details that even seasoned
    programmers normally don’t think about. It also illustrates that it is extremely
    difficult for casual users to understand how a particular URL may be parsed. Let''s
    start with this fairly simple case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The target of this URL—a concatenated IP address that decodes to 10.0.0.1—is
    not readily apparent to a nonexpert, and many users would believe they are visiting
    *example.com* instead.^([[12](#ftn.CHP-2-FN-3)]) But all right, that was an easy
    one! So let’s have a peek at this syntax instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Firefox, that URL will take the user to *coredump.cx*, because *example.com\*
    will be interpreted as a valid value for the login field. In almost all other
    browsers, “\” will be interpreted as a path delimiter, and the user will land
    on *example.com* instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'An even more frustrating example exists for Internet Explorer. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft’s browser permits “;” in the hostname and successfully resolves this
    label, thanks to the appropriate configuration of the *coredump.cx* domain. Most
    other browsers will autocorrect the URL to *http://example.com/;.coredump.cx*
    and take the user to *example.com* instead (except for Safari, where the syntax
    causes an error). If this looks messy, remember that we are just getting started
    with how browsers work!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[10](#CHP-2-FN-1)]) This is possibly out of the concern for FTP, which transmits
    user credentials without any encoding; in this protocol, a newline transmitted
    as is would be misinterpreted by the server as the beginning of a new FTP command.
    Other browsers may transmit FTP credentials in noncompliant percent-encoded form
    or simply strip any problematic characters later on.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#CHP-2-FN-2)]) Unlike UNIX-derived operating systems, Microsoft Windows
    uses backslashes instead of slashes to delimit file paths (say, *c:\windows\system32\calc.exe*).
    Microsoft probably tried to compensate for the possibility that users would be
    confused by the need to type a different type of a slash on the Web or hoped to
    resolve other possible inconsistencies with *file:* URLs and similar mechanisms
    that would be interfacing directly with the local filesystem. Other Windows filesystem
    specifics (such as case insensitivity) are not replicated, however.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[12](#CHP-2-FN-3)]) This particular @-based trick was quickly embraced to
    facilitate all sorts of online fraud targeted at casual users. Attempts to mitigate
    its impact ranged from the heavy-handed and oddly specific (e.g., disabling URL-based
    authentication in Internet Explorer or crippling it with warnings in Firefox)
    to the fairly sensible (e.g., hostname highlighting in the address bar of several
    browsers).
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Characters and Percent Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The URL-parsing algorithm outlined in the previous section relies on the assumption
    that certain reserved, syntax-delimiting characters will not appear literally
    in the URL in any other capacity (that is, they won’t be a part of the username,
    request path, and so on). These generic, syntax-disrupting delimiters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The RFC also names a couple of lower-tier delimiters without giving them any
    specific purpose, presumably to allow scheme- or application-specific features
    to be implemented within any of the top-level sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All of the above characters are in principle off-limits, but there are legitimate
    cases where one would want to include them in the URL (for example, to accommodate
    arbitrary search terms entered by the user and passed to the server in the query
    string). Therefore, rather than ban them, the standard provides a method to encode
    all spurious occurrences of these values. The method, simply called *percent encoding*
    or *URL encoding*, substitutes characters with a percent sign (`%`) followed by
    two hexadecimal digits representing a matching ASCII value. For example, “`/`”
    will be encoded as *%2F* (uppercase is customary but not enforced). It follows
    that to avoid ambiguity, the naked percent sign itself must be encoded as *%25*.
    Any intermediaries that handle existing URLs (browsers and web applications included)
    are further compelled never to attempt to decode or encode reserved characters
    in relayed URLs, because the meaning of such a URL may suddenly change.
  prefs: []
  type: TYPE_NORMAL
- en: Regrettably, the immutability of reserved characters in existing URLs is at
    odds with the need to respond to any URLs that are technically illegal because
    they misuse these characters and that are encountered by the browser in the wild.
    This topic is not covered by the specifications at all, which forces browser vendors
    to improvise and causes cross-implementation inconsistencies. For example, should
    the URL *http://a@b@c/* be translated to *http://a@b%40c/* or perhaps to *http://a%40b@c/*?
    Internet Explorer and Safari think the former makes more sense; other browsers
    side with the latter view.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining characters not in the reserved set are not supposed to have any
    particular significance within the URL syntax itself. However, some (such as nonprintable
    ASCII control characters) are clearly incompatible with the idea that URLs should
    be human readable and transport-safe. Therefore, the RFC outlines a confusingly
    named subset of *unreserved* characters (consisting of alphanumerics, “`-`”, “`.`”,
    “`_`”, and “`˜`”) and says that only this subset and the reserved characters in
    their intended capacity are formally allowed to appear in the URL as is.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Curiously, these unreserved characters are only *allowed* to appear in an unescaped
    form; they are not *required* to do so. User agents may encode or decode them
    at whim, and doing so does not change the meaning of the URL at all. This property
    brings up yet another way to confuse users: the use of noncanonical representations
    of unreserved characters. Specifically, all of the following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://example.com/](http://example.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*http://%65xample.%63om/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/*^([[13](#ftn.CHP-2-FN-4)])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of otherwise nonreserved, printable characters are excluded from the
    so-called unreserved set. Because of this, strictly speaking, the RFCs require
    them to be unconditionally percent encoded. However, since browsers are not explicitly
    tasked with the enforcement of this rule, it is not taken very seriously. In particular,
    all browsers allow “`^`”, “`{`”, “`|`”, and “`}`” to appear in URLs without escaping
    and will send these characters to the server as is. Internet Explorer further
    permits “`<`”, “`>`”, and “`` ` ``” to go through; Internet Explorer, Firefox,
    and Chrome all accept “`\`”; Chrome and Internet Explorer will permit a double
    quote; and Opera and Internet Explorer both pass the nonprintable character 0x7F
    (DEL) as is.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, contrary to the requirements spelled out in the RFC, most browsers also
    do not encode fragment identifiers at all. This poses an unexpected challenge
    to client-side scripts that rely on this string and expect certain potentially
    unsafe characters never to appear literally. We will revisit this topic in [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts").
  prefs: []
  type: TYPE_NORMAL
- en: Handling of Non-US-ASCII Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many languages used around the globe rely on characters outside the basic, 7-bit
    ASCII character set or the default 8-bit code page traditionally used by all PC-compatible
    systems (CP437). Heck, some languages depend on alphabets that are not based on
    Latin at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accommodate the needs of an often-ignored but formidable non-English
    user base, various 8-bit code pages with an alternative set of high-bit characters
    were devised long before the emergence of the Web: ISO 8859-1, CP850, and Windows
    1252 for Western European languages; ISO 8859-2, CP852, and Windows 1250 for Eastern
    and Central Europe; and KOI8-R and Windows 1251 for Russia. And, because several
    alphabets could not be accommodated in the 256-character space, we saw the rise
    of complex variable-width encodings, such as Shift JIS for katakana.'
  prefs: []
  type: TYPE_NORMAL
- en: The incompatibility of these character maps made it difficult to exchange documents
    between computers configured for different code pages. By the early 1990s, this
    growing problem led to the creation of *Unicode*—a sort of universal character
    set, too large to fit within 8 bits but meant to encompass practically all regional
    scripts and specialty pictographs known to man. Unicode was followed by UTF-8,
    a relatively simple, variable-width representation of these characters, which
    was theoretically safe for all applications capable of handling traditional 8-bit
    formats. Unfortunately, UTF-8 required more bytes to encode high-bit characters
    than did most of its competitors, and to many users, this seemed wasteful and
    unnecessary. Because of this criticism, it took well over a decade for UTF-8 to
    gain traction on the Web, and it only did so long after all the relevant protocols
    had solidified.
  prefs: []
  type: TYPE_NORMAL
- en: 'This unfortunate delay had some bearing on the handling of URLs that contain
    user input. Browsers needed to accommodate such use very early on, but when the
    developers turned to the relevant standards, they found no meaningful advice.
    Even years later, in 2005, the RFC 3986 had just this to say:'
  prefs: []
  type: TYPE_NORMAL
- en: In local or regional contexts and with improving technology, users might benefit
    from being able to use a wider range of characters; such use is not defined by
    this specification.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Percent-encoded octets . . . may be used within a URI to represent characters
    outside the range of the US-ASCII coded character set if this representation is
    allowed by the scheme or by the protocol element in which the URI is referenced.
    Such a definition should specify the character encoding used to map those characters
    to octets prior to being percent-encoded for the URI.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alas, despite this wishful thinking, none of the remaining standards addressed
    this topic. It was always possible to put raw high-bit characters in a URL, but
    without knowing the code page they should be interpreted in, the server would
    not be able to tell if that *%B1* was supposed to mean “±”, “ą”, or some other
    squiggly character specific to the user’s native script.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, browser vendors have not taken the initiative and come up with a consistent
    solution to this problem. Most browsers internally transcode URL path segments
    to UTF-8 (or ISO 8859-1, if sufficient), but then they generate the query string
    in the code page of the referring page instead. In certain cases, when URLs are
    entered manually or passed to certain specialized APIs, high-bit characters may
    be also downgraded to their 7-bit US-ASCII look-alikes, replaced with question
    marks, or even completely mangled due to implementation flaws.
  prefs: []
  type: TYPE_NORMAL
- en: 'Poorly implemented or not, the ability to pass non-English characters in query
    strings and paths scratched an evident itch. The traditional percent-encoding
    approach left just one URL segment completely out in the cold: High-bit input
    could not be allowed as is when specifying the name of the destination server,
    because at least in principle, the well-established DNS standard permitted only
    period-delimited alphanumerics and dashes to appear in domain names—and while
    nobody adhered to the rules, the set of exceptions varied from one name server
    to another.'
  prefs: []
  type: TYPE_NORMAL
- en: An astute reader might wonder why this limitation would matter; that is, why
    was it important to have localized domain names in non-Latin alphabets, too? That
    question may be difficult to answer now. Quite simply, several folks thought a
    lack of these encodings would prevent businesses and individuals around the world
    from fully embracing and enjoying the Web—and, rightly or not, they were determined
    to make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pursuit led to the formation of the Internationalized Domain Names in
    Applications (IDNA). First, RFC 3490,^([[102](pr03.html#ftn.CHP-2-FT-9)]) which
    outlined a rather contrived scheme to encode arbitrary Unicode strings using alphanumerics
    and dashes, and then RFC 3492,^([[103](pr03.html#ftn.CHP-2-FT-10)]) which described
    a way to apply this encoding to DNS labels using a format known as *Punycode*.
    Punycode looked roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A compliant browser presented with a technically illegal URL that contained
    a literal non-US-ASCII character anywhere in the hostname was supposed to transform
    the name to Punycode before performing a DNS lookup. Consequently, when presented
    with Punycode in an existing URL, it should put a decoded, human-readable form
    of the string in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Combining all these incompatible encoding strategies can make for an amusing
    mix. Consider this example URL of a made-up Polish-language towel shop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages949993.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of all the URL-based encoding approaches, IDNA soon proved to be the most problematic.
    In essence, the domain name in the URL shown in the browser’s address bar is one
    of the most important security indicators on the Web, as it allows users to quickly
    differentiate sites they trust and have done business with from the rest of the
    Internet. When the hostname shown by the browser consists of 38 familiar and distinctive
    characters, only fairly careless victims will be tricked into thinking that their
    favorite *examp*l*e.com* domain and an impostor *examp*1*e.com* site are the same
    thing. But IDNA casually and indiscriminately extended these 38 characters to
    some 100,000 glyphs supported by Unicode, many of which look exactly alike and
    are separated from each other based on functional differences alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'How bad is it? Let’s consider Cyrillic, for example. This alphabet has a number
    of homoglyphs that look practically identical to their Latin counterparts but
    that have completely different Unicode values and resolve to completely different
    Punycode DNS names:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Latin | a | c | e | i | j | o | p | s | x | y |'
  prefs: []
  type: TYPE_TB
- en: '| U+0061 | U+0063 | U+0065 | U+0069 | U+006A | U+006F | U+0070 | U+0073 | U+0078
    | U+0079 |'
  prefs: []
  type: TYPE_TB
- en: '| Cyrillic | a | c | e | i | j | o | p | s | x | y |'
  prefs: []
  type: TYPE_TB
- en: '| U+0430 | U+0441 | U+0435 | U+0456 | U+0458 | U+043E | U+0440 | U+0455 | U+0445
    | U+0443 |'
  prefs: []
  type: TYPE_TB
- en: When IDNA was proposed and first implemented in browsers, nobody seriously considered
    the consequences of this issue. Browser vendors apparently assumed that DNS registrars
    would prevent people from registering look-alike names, and registrars figured
    it was the browser vendors’ problem to have unambiguous visuals in the address
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2002 the significance of the problem was finally recognized by all parties
    involved. That year, Evgeniy Gabrilovich and Alex Gontmakher published “The Homograph
    Attack,”^([[104](pr03.html#ftn.CHP-2-FT-11)]) a paper exploring the vulnerability
    in great detail. They noted that any registrar-level work-arounds, even if implemented,
    would have a fatal flaw. An attacker could always purchase a wholesome top-level
    domain and then, on his own name server, set up a subdomain record that, with
    the IDNA transformation applied, would decode to a string visually identical to
    *example.com/* (the last character being merely a nonfunctional look-alike of
    the actual ASCII slash). The result would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages949995.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is nothing that a registrar can do to prevent this attack, and the ball
    is in the browser vendors’ court. But what options do they have, exactly?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, there aren’t many. We now realize that the poorly envisioned
    IDNA standard cannot be fixed in a simple and painless way. Browser developers
    have responded to this risk by reverting to incomprehensible Punycode when a user’s
    locale does not match the script seen in a particular DNS label (which causes
    problems when browsing foreign sites or when using imported or simply misconfigured
    computers); permitting IDNA only in certain country-specific, top-level domains
    (ruling out the use of internationalized domain names in *.com* and other high-profile
    TLDs); and blacklisting certain “bad” characters that resemble slashes, periods,
    white spaces, and so forth (a fool’s errand, given the number of typefaces used
    around the world).
  prefs: []
  type: TYPE_NORMAL
- en: These measures are drastic enough to severely hinder the adoption of internationalized
    domain names, probably to a point where the standard’s lingering presence causes
    more security problems than it brings real usability benefits to non-English users.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#CHP-2-FN-4)]) Similar noncanonical encodings were widely used for various
    types of social engineering attacks, and consequently, various countermeasures
    have been deployed through the years. As usual, some of these countermeasures
    are disruptive (for example, Firefox flat out rejects percent-encoded text in
    hostnames), and some are fairly good (such as the forced “canonicalization” of
    the address bar by decoding all the unnecessarily encoded text for display purposes).
  prefs: []
  type: TYPE_NORMAL
- en: Common URL Schemes and Their Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s leave the bizarre world of URL parsing behind us and go back to the basics.
    Earlier in this chapter, we implied that certain schemes may have unexpected security
    consequences and that because of this, any web application handling user-supplied
    URLs must be cautious. To explain this point a bit better, it is useful to review
    all the URL schemes commonly supported in a typical browser environment. These
    can be combined into four basic groups.
  prefs: []
  type: TYPE_NORMAL
- en: Browser-Supported, Document-Fetching Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These schemes, handled internally by the browser, offer a way to retrieve arbitrary
    content using a particular transport protocol and then display it using common,
    browser-level rendering logic. This is the most rudimentary and the most expected
    function of a URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of commonly supported schemes in this category is surprisingly short:
    *http:* (RFC 2616), the primary transport mode used on the Web and the focus of
    the next chapter of this book; *https:*, an encrypted version of HTTP (RFC 2818^([[105](pr03.html#ftn.CHP-2-FT-12)]));
    and *ftp:*, an older file transfer protocol (RFC 959^([[106](pr03.html#ftn.CHP-2-FT-13)])).
    All browsers also support *file:* (previously also known as *local:*), a system-specific
    method for accessing the local filesystem or NFS and SMB shares. (This last scheme
    is usually not directly accessible through Internet-originating pages, though.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two additional, obscure cases also deserve a brief mention: built-in support
    for the *gopher:* scheme, one of the failed predecessors of the Web (RFC 1436^([[107](pr03.html#ftn.CHP-2-FT-14)])),
    which is still present in Firefox, and *shttp:*, an alternative, failed take on
    HTTPS (RFC 2660^([[108](pr03.html#ftn.CHP-2-FT-15)])), still recognized in Internet
    Explorer (but today, simply aliased to HTTP).'
  prefs: []
  type: TYPE_NORMAL
- en: Protocols Claimed by Third-Party Applications and Plug-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For these schemes, matching URLs are simply dispatched to external, specialized
    applications that implement functionality such as media playback, document viewing,
    or IP telephony. At this point, the involvement of the browser (mostly) ends.
  prefs: []
  type: TYPE_NORMAL
- en: Scores of external protocol handlers exist today, and it would take another
    thick book to cover them all. Some of the most common examples include the *acrobat:*
    scheme, predictably routed to Adobe Acrobat Reader; *callto:* and *sip:* schemes
    claimed by all sorts of instant messengers and telephony software; *daap:*, *itpc:*,
    and *itms:* schemes used by Apple iTunes; *mailto:*, *news:*, and *nntp:* protocols
    claimed by mail and Usenet clients; *mmst:*, *mmsu:*, *msbd:*, and *rtsp:* protocols
    for streaming media players; and so on. Browsers are sometimes also included on
    the list. The previously mentioned *firefoxurl:* scheme launches Firefox from
    within another browser, while *cf:* gives access to Chrome from Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, when these schemes appear in URLs, they usually have no impact
    on the security of the web applications that allow them to go through (although
    this is not guaranteed, especially in the case of plug-in-supported content).
    It is worth noting that third-party protocol handlers tend to be notoriously buggy
    and are sometimes abused to compromise the operating system. Therefore, restricting
    the ability to navigate to mystery protocols is a common courtesy to the user
    of any reasonably trustworthy website.
  prefs: []
  type: TYPE_NORMAL
- en: Nonencapsulating Pseudo-Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array of protocols is reserved to provide convenient access to the browser’s
    scripting engine and other internal functions, without actually retrieving any
    remote content and perhaps without establishing an isolated document context to
    display the result. Many of these pseudo-protocols are highly browser-specific
    and are either not directly accessible from the Internet or are incapable of doing
    harm. However, there are several important exceptions to this rule.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the best-known exception is the *javascript:* scheme (in earlier years,
    also available under aliases such as *livescript:* or *mocha:* in Netscape browsers).
    This scheme gives access to the JavaScript-programming engine in the context of
    the currently viewed website. In Internet Explorer, *vbscript:* offers similar
    capabilities through the proprietary Visual Basic interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important case is the *data:* protocol (RFC 2397^([[109](pr03.html#ftn.CHP-2-FT-16)])),
    which permits short, inline documents to be created without any extra network
    requests and sometimes inherits much of their operating context from the referring
    page. An example of a *data:* URL is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These externally accessible pseudo-URLs are of acute significance to site security.
    When navigated to, their payload may execute in the context of the originating
    domain, possibly stealing sensitive data or altering the appearance of the page
    for the affected user. We’ll discuss the specific capabilities of browser scripting
    languages in [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts"), but as
    you might expect, they are substantial. (URL context inheritance rules, on the
    other hand, are the focus of [Chapter 10](ch10.html "Chapter 10. Origin Inheritance").)
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating Pseudo-Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This special class of pseudo-protocols may be used to prefix any other URL
    in order to force a special decoding or rendering mode for the retrieved resource.
    Perhaps the best-known example is the *view-source:* scheme supported by Firefox
    and Chrome, used to display the pretty-printed source of an HTML page. This scheme
    is used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Other protocols that function similarly include *jar:*, which allows content
    to be extracted from ZIP files on the fly in Firefox; *wyciwyg:* and *view-cache:*,
    which give access to cached pages in Firefox and Chrome respectively; an oddball
    *feed:* scheme, which is meant to access news feeds in Safari;^([[110](pr03.html#ftn.CHP-2-FT-17)])
    and a host of poorly documented protocols associated with the Windows help subsystem
    and other components of Microsoft Windows (*hcp:*, *its:*, *mhtml:*, *mk:*, *ms-help:*,
    *ms-its:*, and *ms-itss:*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The common property of many encapsulating protocols is that they allow the
    attacker to hide the actual URL that will be ultimately interpreted by the browser
    from naïve filters: `view-source:javascript:` (or even `view-source:view-source:javascript:`)
    followed by malicious code is a simple way to accomplish this. Some security restrictions
    may be present to limit such trickery, but they should not be relied upon. Another
    significant problem, recurring especially with Microsoft’s *mhtml:*, is that using
    the protocol may ignore some of the content directives provided by the server
    on HTTP level, possibly leading to widespread misery.^([[111](pr03.html#ftn.CHP-2-FT-18)])'
  prefs: []
  type: TYPE_NORMAL
- en: Closing Note on Scheme Detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sheer number of pseudo-protocols is the primary reason why web applications
    need to carefully screen user-supplied URLs. The wonky and browser-specific URL-parsing
    patterns, coupled with the open-ended nature of the list of supported schemes,
    means that it is unsafe to simply blacklist known bad schemes; for example, a
    check for *javascript:* may be circumvented if this keyword is spliced with a
    tab or a newline, replaced with *vbscript:*, or prefixed with another encapsulating
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Resolution of Relative URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relative URLs have been mentioned on several occasions earlier in the chapter,
    and they deserve some additional attention at this point, too. The reason for
    their existence is that on almost every web page on the Internet, a considerable
    number of URLs will reference resources hosted on that same server, perhaps in
    the same directory. It would be inconvenient and wasteful to require a fully qualified
    URL to appear in the document every time such a reference is needed, so short,
    relative URLs (such as *../other_file.txt*) are used instead. The missing details
    are inferred from the URL of the referring document.
  prefs: []
  type: TYPE_NORMAL
- en: Because relative URLs are allowed to appear in exactly the same scenarios in
    which any absolute URL may appear, a method to distinguish between the two is
    necessary within the browser. Web applications also benefit from the ability to
    make the distinction, because most types of URL filters may want to scrutinize
    absolute URLs only and allow local references through as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification may make this task seem very simple: If the URL string does
    not begin with a valid scheme name followed by a semicolon and, preferably, a
    valid “//” sequence, it should be interpreted as a relative reference. And if
    no context for parsing such a relative URL exists, it should be rejected. Everything
    else is a safe relative link, right?'
  prefs: []
  type: TYPE_NORMAL
- en: Predictably, it’s not as easy as it seems. First, as outlined in previous sections,
    the accepted set of characters in a valid scheme name, and the patterns accepted
    in lieu of “//”, vary from one implementation to another. Perhaps more interestingly,
    it is a common misconception that relative links can point only to resources on
    the same server; quite a few other, less-obvious variants of relative URLs exist.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a quick peek at the known classes of relative URLs to better illustrate
    this possibility.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheme, but no authority present** (http:foo.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: This infamous loophole is hinted at in RFC 3986 and attributed to an oversight
    in one of the earlier specs. While said specs descriptively classified such URLs
    as (invalid) absolute references, they also provided a promiscuous reference-parsing
    algorithm keen on interpreting them incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter interpretation, these URLs would set a new protocol and path,
    query, or fragment ID but have the authority section copied over from the referring
    location. This syntax is accepted by several browsers, but inconsistently. For
    example, in some cases, *http:foo.txt* may be treated as a relative reference,
    while *https:example.com* may be parsed as an absolute one!
  prefs: []
  type: TYPE_NORMAL
- en: '**No scheme, but authority present** (//example.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is another notoriously confusing but at least well-documented quirk. While
    */example.com* is areference to a local resource on the current server, the standard
    compels browsers to treat *//example.com* as a very different case: a reference
    to a different authority over the current protocol. In this scenario, the scheme
    will be copied over from the referring location, and all other URL details will
    be derived from the relative URL.'
  prefs: []
  type: TYPE_NORMAL
- en: '**No scheme, no authority, but path present** (../notes.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the most common variant of a relative link. Protocol and authority information
    is copied over from the referring URL. If the relative URL does not start with
    a slash, the path will also be copied over up to the rightmost “/”. For example,
    if the base URL is [http://www.example.com/files/](http://www.example.com/files/),
    the path is the same, but in [http://www.example.com/files/index.html](http://www.example.com/files/index.html),
    the filename is truncated. The new path is then appended, and standard path normalization
    follows on the concatenated value. The query string and fragment ID are derived
    only from the relative URL.
  prefs: []
  type: TYPE_NORMAL
- en: '**No scheme, no authority, no path, but query string present** (?search=bunnies)'
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, protocol, authority, and path information are copied verbatim
    from the referring URL. The query string and fragment ID are derived from the
    relative URL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Only fragment ID present** (#bunnies)'
  prefs: []
  type: TYPE_NORMAL
- en: All information except for the fragment ID is copied verbatim from the referring
    URL; only the fragment ID is substituted. Following this type of relative URL
    does not cause the page to be reloaded under normal circumstances, as noted earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the risk of potential misunderstandings between application-level
    URL filters and the browser when handling these types of relative references,
    it is a good design practice never to output user-supplied relative URLs verbatim.
    Where feasible, they should be explicitly rewritten to absolute references, and
    all security checks should be carried out against the resulting fully qualified
    address instead.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Constructing Brand-New URLs Based on User Input
  prefs: []
  type: TYPE_NORMAL
- en: '**If you allow user-supplied data in path, query, or fragment ID:** If one
    of the section delimiters manages to get through without proper escaping, the
    URL may have a different effect from what you intended (for example, linking one
    of the user-visible HTML buttons to the wrong server-side action). It is okay
    to err on the side of caution: When inserting an attacker-controlled field value,
    you can simply percent-escape everything but alphanumerics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If you allow user-supplied scheme name or authority section:** This is a
    major code injection and phishing risk! Apply the relevant input-validation rules
    outlined below.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Designing URL Input Filters
  prefs: []
  type: TYPE_NORMAL
- en: '**Relative URLs:** Disallow or explicitly rewrite them to absolute references
    to avoid trouble. Anything else is very likely unsafe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheme name:** Permit only known prefixes, such as *http://*, *https://*,
    or *ftp://*. Do not use blacklisting instead; it is extremely unsafe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authority section:** Hostname should contain only alphanumerics, “-”, and
    “.” and can only be followed by “/”, “?”, “#”, or end-of-string. Allowing anything
    else will backfire. If you need to examine the hostname, make sure to make a proper
    right-hand substring match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In rare cases, you might need to account for IDNA, IPv6 bracket notation, port
    numbers, or HTTP credentials in the URL. If so, you must fully parse the URL,
    validate all sections and reject anomalous values, and reserialize them into a
    nonambiguous, canonical, well-escaped representation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When Decoding Parameters Received Through URLs
  prefs: []
  type: TYPE_NORMAL
- en: Do not assume that any particular character will be escaped just because the
    standard says so or because your browser does it. Before echoing back any URL-derived
    values or putting them inside database queries, new URLs, and so on, scrub them
    carefully for dangerous characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 3. Hypertext Transfer Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next essential concept we need to discuss is the Hypertext Transfer Protocol
    (HTTP): the core transfer mechanism of the Web and the preferred method for exchanging
    URL-referenced documents between servers and clients. Despite having hypertext
    in its name, HTTP and the actual hypertext content (the HTML language) often exist
    independent of each other. That said, they are intertwined in sometimes surprising
    ways.'
  prefs: []
  type: TYPE_NORMAL
- en: The history of HTTP offers interesting insight into its authors’ ambitions and
    the growing relevance of the Internet. Tim Berners-Lee’s earliest 1991 draft of
    the protocol (HTTP/0.9^([[112](pr03.html#ftn.CHP-3-FT-1)])) was barely one and
    a half pages long, and it failed to account for even the most intuitive future
    needs, such as extensibility needed to transmit non-HTML data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Five years and several iterations of the specification later, the first official
    HTTP/1.0 standard (RFC 1945^([[113](pr03.html#ftn.CHP-3-FT-2)])) tried to rectify
    many of these shortcomings in about 50 densely packed pages of text. Fast-forward
    to 1999, and in HTTP/1.1 (RFC 2616^([[114](pr03.html#ftn.CHP-3-FT-3)])), the seven
    credited authors attempted to anticipate almost every possible use of the protocol,
    creating an opus over 150 pages long. That’s not all: As of this writing, the
    current work on HTTPbis,^([[115](pr03.html#ftn.CHP-3-FT-4)]) essentially a replacement
    for the HTTP/1.1 specification, comes to 360 pages or so. While much of the gradually
    accumulated content is irrelevant to the modern Web, this progression makes it
    clear that the desire to tack on new features far outweighs the desire to prune
    failed ones.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, all clients and servers support a not-entirely-accurate superset of HTTP/1.0,
    and most can speak a reasonably complete dialect of HTTP/1.1, with a couple of
    extensions bolted on. Despite the fact that there is no practical need to do so,
    several web servers, and all common browsers, also maintain backward compatibility
    with HTTP/0.9.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Syntax of HTTP Traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a glance, HTTP is a fairly simple, text-based protocol built on top of TCP/IP.^([[14](#ftn.CHP-3-FN-1)])
    Every HTTP session is initiated by establishing a TCP connection to the server,
    typically to port 80, and then issuing a request that outlines the requested URL.
    In response, the server returns the requested file and, in the most rudimentary
    use case, tears down the TCP connection immediately thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original HTTP/0.9 protocol provided no room for any additional metadata
    to be exchanged between the participating parties. The client request always consisted
    of a single line, starting with GET, followed by the URL path and query string,
    and ending with a single CRLF newline (ASCII characters 0x0D 0x0A; servers were
    also advised to accept a lone LF). A sample HTTP/0.9 request might have looked
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In response to this message, the server would have immediately returned the
    appropriate HTML payload. (The specification required servers to wrap lines of
    the returned document at 80 characters, but this advice wasn’t really followed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP/0.9 approach has a number of substantial deficiencies. For example,
    it offers no way for browsers to communicate users’ language preferences, supply
    a list of supported document types, and so on. It also gives servers no way to
    tell a client that the requested file could not be found, that it has moved to
    a different location, or that the returned file is not an HTML document to begin
    with. Finally, the scheme is not kind to server administrators: When the transmitted
    URL information is limited to only the path and query strings, it is impossible
    for a server to host multiple websites, distinguished by their hostnames, under
    one IP address—and unlike DNS records, IP addresses don’t come cheap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix these shortcomings (and to make room for future tweaks), HTTP/1.0
    and HTTP/1.1 standards embrace a slightly different conversation format: The first
    line of a request is modified to include protocol version information, and it
    is followed by zero or more *name: value* pairs (also known as *headers*), each
    occupying a separate line. Common request headers included in such requests are
    *User-Agent* (browser version information), *Host* (URL hostname), *Accept* (supported
    MIME document types^([[15](#ftn.CHP-3-FN-2)])), *Accept-Language* (supported language
    codes), and *Referer* (a misspelled field indicating the originating page for
    the request, if known).'
  prefs: []
  type: TYPE_NORMAL
- en: These headers are terminated with a single empty line, which may be followed
    by any payload the client wishes to pass to the server (the length of which must
    be explicitly specified with an additional *Content-Length* header). The contents
    of the payload are opaque from the perspective of the protocol itself; in HTML,
    this location is commonly used for submitting form data in one of several possible
    formats, though this is in no way a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, a simple HTTP/1.1 request may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The server is expected to respond to this query by opening with a line that
    specifies the supported protocol version, a numerical status code (used to indicate
    error conditions and other special circumstances), and an optional, human-readable
    status message. A set of self-explanatory headers comes next, ending with an empty
    line. The response continues with the contents of the requested resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: RFC 2616 also permits the response to be compressed in transit using one of
    three supported methods (*gzip*, *compress*, *deflate*), unless the client explicitly
    opts out by providing a suitable *Accept-Encoding* header.
  prefs: []
  type: TYPE_NORMAL
- en: The Consequences of Supporting HTTP/0.9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Despite the improvements made in HTTP/1.0 and HTTP/1.1, the unwelcome legacy
    of the “dumb” HTTP/0.9 protocol lives on, even if it is normally hidden from view.
    The specification for HTTP/1.0 is partly to blame for this, because it requested
    that all future HTTP clients and servers support the original, half-baked draft.
    Specifically, section 3.1 says:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/1.0 clients must . . . understand any valid response in the format of HTTP/0.9
    or HTTP/1.0.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In later years, RFC 2616 attempted to backtrack on this requirement (section
    19.6: “It is beyond the scope of a protocol specification to mandate compliance
    with previous versions.”), but acting on the earlier advice, all modern browsers
    continue to support the legacy protocol as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why this pattern is dangerous, recall that HTTP/0.9 servers reply
    with nothing but the requested file. There is no indication that the responding
    party actually understands HTTP and wishes to serve an HTML document. With this
    in mind, let’s analyze what happens if the browser sends an HTTP/1.1 request to
    an unsuspecting SMTP service running on port 25 of *example.com*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the SMTP server doesn’t understand what is going on, it’s likely to
    respond this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All browsers willing to follow the RFC are compelled to accept these messages
    as the body of a valid HTTP/0.9 response and assume that the returned document
    is, indeed, HTML. These browsers will interpret the quoted attacker-controlled
    snippet appearing in one of the error messages as if it comes from the owners
    of a legitimate website at *example.com*. This profoundly interferes with the
    browser security model discussed in [Part II](pt02.html "Part II. Browser Security
    Features") of this book and, therefore, is pretty bad.
  prefs: []
  type: TYPE_NORMAL
- en: Newline Handling Quirks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting aside the radical changes between HTTP/0.9 and HTTP/1.0, several other
    core syntax tweaks were made later in the game. Perhaps most notably, contrary
    to the letter of earlier iterations, HTTP/1.1 asks clients not only to honor newlines
    in the CRLF and LF format but also to recognize a lone CR character. Although
    this recommendation is disregarded by the two most popular web servers (IIS and
    Apache), it is followed on the client side by all browsers except Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting inconsistency makes it easier for application developers to forget
    that not only LF but also CR characters must be stripped from any attacker-controlled
    values that appear anywhere in HTTP headers. To illustrate the problem, consider
    the following server response, where a user-supplied and insufficiently sanitized
    value appears in one of the headers, as highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To Internet Explorer, this response may appear as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the class of vulnerabilities related to HTTP header newline smuggling—be
    it due to this inconsistency or just due to a failure to filter any type of a
    newline—is common enough to have its own name: *header injection* or *response
    splitting*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another little-known and potentially security-relevant tweak is support for
    multiline headers, a change introduced in HTTP/1.1\. According to the standard,
    any header line that begins with a whitespace is treated as a continuation of
    the previous one. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Multiline headers are recognized in client-issued requests by IIS and Apache,
    but they are not supported by Internet Explorer, Safari, or Opera. Therefore,
    any implementation that relies on or simply permits this syntax in any attacker-influenced
    setting may be in trouble. Thankfully, this is rare.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proxies are used by many organizations and Internet service providers to intercept,
    inspect, and forward HTTP requests on behalf of their users. This may be done
    to improve performance (by allowing certain server responses to be cached on a
    nearby system), to enforce network usage policies (for example, to prevent access
    to porn), or to offer monitored and authenticated access to otherwise separated
    network environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conventional HTTP proxies depend on explicit browser support: The application
    needs to be configured to make a modified request to the proxy system, instead
    of attempting to talk to the intended destination. To request an HTTP resource
    through such a proxy, the browser will normally send a request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The key difference between the above example and the usual syntax is the presence
    of a fully qualified URL in the first line of the request ([http://www.fuzzybunnies.com/](http://www.fuzzybunnies.com/)),
    instructing the proxy where to connect to on behalf of the user. This information
    is somewhat redundant, given that the *Host* header already specifies the hostname;
    the only reason for this overlap is that the mechanisms evolved independent of
    each other. To avoid being fooled by co-conspiring clients and servers, proxies
    should either correct any mismatching *Host* headers to match the request URL
    or associate cached content with a particular URL-*Host* pair and not just one
    of these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many HTTP proxies also allow browsers to request non-HTTP resources, such as
    FTP files or directories. In these cases, the proxy will wrap the response in
    HTTP, and perhaps convert it to HTML if appropriate, before returning it to the
    user.^([[16](#ftn.CHP-3-FN-3)]) That said, if the proxy does not understand the
    requested protocol, or if it is simply inappropriate for it to peek into the exchanged
    data (for example, inside encrypted sessions), a different approach must be used.
    A special type of a request, CONNECT, is reserved for this purpose but is not
    further explained in the HTTP/1.1 RFC. The relevant request syntax is instead
    outlined in a separate, draft-only specification from 1998.^([[116](pr03.html#ftn.CHP-3-FT-5)])
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the proxy is willing and able to connect to the requested destination, it
    acknowledges this request with a specific HTTP response code, and the role of
    this protocol ends. At that point, the browser will begin sending and receiving
    raw binary data within the established TCP stream; the proxy, in turn, is expected
    to forward the traffic between the two endpoints indiscriminately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hilariously, due to a subtle omission in the draft spec, many browsers have
    incorrectly processed the nonencrypted, proxy-originating error responses returned
    during an attempt to establish an encrypted connection. The affected implementations
    interpreted such plaintext responses as though they originated from the destination
    server over a secure channel. This glitch effectively eliminated all assurances
    associated with the use of encrypted communications on the Web. It took over a
    decade to spot and correct the flaw.^([[117](pr03.html#ftn.CHP-3-FT-6)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Several other classes of lower-level proxies do not use HTTP to communicate
    directly with the browser but nevertheless inspect the exchanged HTTP messages
    to cache content or enforce certain rules. The canonical example of this is a
    transparent proxy that silently intercepts traffic at the TCP/IP level. The approach
    taken by transparent proxies is unusually dangerous: Any such proxy can look at
    the destination IP and the *Host* header sent in the intercepted connection, but
    it has no way of immediately telling if that destination IP is genuinely associated
    with the specified server name. Unless an additional lookup and correlation is
    performed, co-conspiring clients and servers can have a field day with this behavior.
    Without these additional checks, the attacker simply needs to connect to his or
    her home server and send a misleading *Host:* [www.google.com](http://www.google.com)
    header to have the response cached for all other users as though genuinely coming
    from [www.google.com](http://www.google.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Resolution of Duplicate or Conflicting Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite being relatively verbose, RFC 2616 does a poor job of explaining how
    a compliant parser should resolve potential ambiguities and conflicts in the request
    or response data. Section 19.2 of this RFC (“Tolerant Applications”) recommends
    relaxed and error-tolerant parsing of certain fields in “unambiguous” cases, but
    the meaning of the term itself is, shall we say, not particularly unambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, because of a lack of specification-level advice, roughly half
    of all browsers will favor the first occurrence of a particular HTTP header, and
    the rest will favor the last one, ensuring that almost every header injection
    vulnerability, no matter how constrained, is exploitable for at least some percentage
    of targeted users. On the server side, the situation is similarly random: Apache
    will honor the first *Host* header seen, while IIS will completely reject a request
    with multiple instances of this field.'
  prefs: []
  type: TYPE_NORMAL
- en: On a related note, the relevant RFCs contain no explicit prohibition on mixing
    potentially conflicting HTTP/1.0 and HTTP/1.1 headers and no requirement for HTTP/1.0
    servers or clients to ignore all HTTP/1.1 syntax. Because of this design, it is
    difficult to predict the outcome of indirect conflicts between HTTP/1.0 and HTTP/1.1
    directives that are responsible for the same thing, such as *Expires* and *Cache-Control*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in some rare cases, header conflict resolution is outlined in the
    spec very clearly, but the purpose of permitting such conflicts to arise in the
    first place is much harder to understand. For example, HTTP/1.1 clients are required
    to send the *Host* header on all requests, but servers (not just proxies!) are
    also required to recognize absolute URLs in the first line of the request, as
    opposed to the traditional path- and query-only method. This rule permits a curiosity
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, section 5.2 of RFC 2616 instructs clients to disregard the nonfunctional
    (but still mandatory!) *Host* header, and many implementations follow this advice.
    The problem is that underlying applications are likely to be unaware of this quirk
    and may instead make somewhat important decisions based on the inspected header
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When complaining about the omissions in the HTTP RFCs, it is important to recognize
    that the alternatives can be just as problematic. In several scenarios outlined
    in that RFC, the desire to explicitly mandate the handling of certain corner cases
    led to patently absurd outcomes. One such example is the advice on parsing dates
    in certain HTTP headers, at the request of section 3.3 in RFC 1945\. The resulting
    implementation (the *prtime.c* file in the Firefox codebase^([[118](pr03.html#ftn.CHP-3-FT-7)]))
    consists of close to 2,000 lines of extremely confusing and unreadable C code
    just to decipher the specified date, time, and time zone in a sufficiently fault-tolerant
    way (for uses such as deciding cache content expiration).
  prefs: []
  type: TYPE_NORMAL
- en: Semicolon-Delimited Header Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several HTTP headers, such as *Cache-Control* or *Content-Disposition*, use
    a semicolon-delimited syntax to cram several separate *name=value* pairs into
    a single line. The reason for allowing this nested notation is unclear, but it
    is probably driven by the belief that it will be a more efficient or a more intuitive
    approach that using several separate headers that would always have to go hand
    in hand.
  prefs: []
  type: TYPE_NORMAL
- en: Some use cases outlined in RFC 2616 permit *quoted-string* as the right-hand
    parameter in such pairs. *Quoted-string* is a syntax in which a sequence of arbitrary
    printable characters is surrounded by double quotes, which act as delimiters.
    Naturally, the quote mark itself cannot appear inside the string, but—importantly—a
    semicolon or a whitespace may, permitting many otherwise problematic values to
    be sent as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately for developers, Internet Explorer does not cope with the *quoted-string*
    syntax particularly well, effectively rendering this encoding scheme useless.
    The browser will parse the following line (which is meant to indicate that the
    response is a downloadable file rather than an inline document) in an unexpected
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In Microsoft’s implementation, the filename will be truncated at the semicolon
    character and will appear to be *evil_file.exe*. This behavior creates a potential
    hazard to any application that relies on examining or appending a “safe” filename
    extension to an attacker-controlled filename and otherwise correctly checks for
    the quote character and newlines in this string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An additional *quoted-pair* mechanism is provided to allow quotes (and any other
    characters) to be used safely in the string when prefixed by a backslash. This
    mechanism appears to be specified incorrectly, however, and not supported by any
    major browser except for Opera. For *quoted-pair* to work properly, stray “\”
    characters would need to be banned from the *quoted-string*, which isn’t the case
    in RFC 2616\. *Quoted-pair* also permits any *CHAR*-type token to be quoted, including
    newlines, which is incompatible with other HTTP-parsing rules.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that when duplicate semicolon-delimited fields are found
    in a single HTTP header, their order of precedence is not defined by the RFC.
    In the case of *filename=* in *Content-Disposition*, all mainstream browsers use
    the first occurrence. But there is little consistency elsewhere. For example,
    when extracting the *URL=* value from the *Refresh* header (used to force reloading
    the page after a specified amount of time), Internet Explorer 6 will fall back
    to the last instance, yet all other browsers will prefer the first one. And when
    handling *Content-Type*, Internet Explorer, Safari, and Opera will use the first
    *charset=* value, while Firefox and Chrome will rely on the last.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Food for thought: A fascinating but largely non-security-related survey of
    dozens of inconsistencies associated with the handling of just a single HTTP header—*Content-Disposition*—can
    be found on a page maintained by Julian Reschke: [http://greenbytes.de/tech/tc2231/](http://greenbytes.de/tech/tc2231/).'
  prefs: []
  type: TYPE_NORMAL
- en: Header Character Set and Encoding Schemes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the documents that laid the groundwork for URL handling, all subsequent
    HTTP specs have largely avoided the topic of dealing with non-US-ASCII characters
    inside header values. There are several plausible scenarios where non-English
    text may legitimately appear in this context (for example, the filename in *Content-Disposition*),
    but when it comes to this, the expected browser behavior is essentially undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Originally, RFC 1945 permitted the TEXT token (a primitive broadly used to
    define the syntax of other fields) to contain 8-bit characters, providing the
    following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The RFC followed up with cryptic advice: When non-US-ASCII characters are encountered
    in a TEXT field, clients and servers *may* interpret them as ISO-8859-1, the standard
    Western European code page, but they don’t have to. Later, RFC 2616 copied and
    pasted the same specification of TEXT tokens but added a note that non-ISO-8859-1
    strings must be encoded using a format outlined in RFC 2047,^([[119](pr03.html#ftn.CHP-3-FT-8)])
    originally created for email communications. Fair enough; in this simple scheme,
    the encoded string opens with a “=?” prefix, followed by a character-set name,
    a “?q?” or “?b?” encoding-type indicator (*quoted-printable*^([[17](#ftn.CHP-3-FN-4)])
    or *base64*,^([[18](#ftn.CHP-3-FN-5)]) respectively), and lastly the encoded string
    itself. The sequence ends with a “?=” terminator. An example of this may be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RFC should also have stated that any spurious “=?...?=” patterns must never
    be allowed as is in the relevant headers, in order to avoid unintended decoding
    of values that were not really encoded to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, the support for this RFC 2047 encoding is spotty. It is recognized in
    some headers by Firefox and Chrome, but other browsers are less cooperative. Internet
    Explorer chooses to recognize URL-style percent encoding in the *Content-Disposition*
    field instead (a habit also picked up by Chrome) and defaults to UTF-8 in this
    case. Firefox and Opera, on the other hand, prefer supporting a peculiar percent-encoded
    syntax proposed in RFC 2231,^([[120](pr03.html#ftn.CHP-3-FT-9)]) a striking deviation
    from how HTTP syntax is supposed to look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Astute readers may notice that there is no single encoding scheme supported
    by all browsers at once. This situation prompts some web application developers
    to resort to using raw high-bit values in the HTTP headers, typically interpreted
    as UTF-8, but doing so is somewhat unsafe. In Firefox, for example, a long-standing
    glitch causes UTF-8 text to be mangled when put in the *Cookie* header, permitting
    attacker-injected cookie delimiters to materialize in unexpected places.^([[121](pr03.html#ftn.CHP-3-FT-10)])
    In other words, there are no easy and robust solutions to this mess.
  prefs: []
  type: TYPE_NORMAL
- en: When discussing character encodings, the problem of handling of the NUL character
    (0x00) probably deserves a mention. This character, used as a string terminator
    in many programming languages, is technically prohibited from appearing in HTTP
    headers (except for the aforementioned, dysfunctional *quoted-pair* syntax), but
    as you may recall, parsers are encouraged to be tolerant. When this character
    is allowed to go through, it is likely to have unexpected side effects. For example,
    *Content-Disposition* headers are truncated at NUL by Internet Explorer, Firefox,
    and Chrome but not by Opera or Safari.
  prefs: []
  type: TYPE_NORMAL
- en: Referer Header Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, HTTP requests may include a *Referer*
    header. This header contains the URL of a document that triggered the current
    navigation in some way. It is meant to help with certain troubleshooting tasks
    and to promote the growth of the Web by emphasizing cross-references between related
    web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the header may also reveal some information about user browsing
    habits to certain unfriendly parties, and it may leak sensitive information that
    is encoded in the URL query parameters on the referring page. Due to these concerns,
    and the subsequent poor advice on how to mitigate them, the header is often misused
    for security or policy enforcement purposes, but it is not up to the task. The
    main problem is that there is no way to differentiate between a client that is
    not providing the header because of user privacy preferences, one that is not
    providing it because of the type of navigation taking place, and one that is deliberately
    tricked into hiding this information by a malicious referring site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, this header is included in most HTTP requests (and preserved across
    HTTP-level redirects), except in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: After organically entering a new URL into the address bar or opening a bookmarked
    page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the navigation originates from a pseudo-URL document, such as *data:* or
    *javascript:*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the request is a result of redirection controlled by the *Refresh* header
    (but not a *Location*-based one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the referring site is encrypted but the requested page isn’t. According
    to RFC 2616 section 15.1.2, this is done for privacy reasons, but it does not
    make a lot of sense. The *Referer* string is still disclosed to third parties
    when one navigates from one encrypted domain to an unrelated encrypted one, and
    rest assured, the use of encryption is not synonymous with trustworthiness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user decides to block or spoof the header by tweaking browser settings
    or installing a privacy-oriented plug-in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As should be apparent, four out of five of these conditions can be purposefully
    induced by any rogue site.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#CHP-3-FN-1)]) *Transmission Control Protocol (TCP)* is one of the core
    communications protocols of the Internet, providing the transport layer to any
    application protocols built on top of it. TCP offers reasonably reliable, peer-acknowledged,
    ordered, session-based connectivity between networked hosts. In most cases, the
    protocol is also fairly resilient against blind packet spoofing attacks attempted
    by other, nonlocal hosts on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#CHP-3-FN-2)]) MIME type (aka *Internet media type*) is a simple, two-component
    value identifying the class and format of any given computer file. The concept
    originated in RFC 2045 and RFC 2046, where it served as a way to describe email
    attachments. The registry of official values (such as *text/plain* or *audio/mpeg*)
    is currently maintained by IANA, but ad hoc types are fairly common.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#CHP-3-FN-3)]) In this case, some HTTP headers supplied by the client
    may be used internally by the proxy, but they will not be transmitted to the non-HTTP
    endpoint, which creates some interesting, if non-security-relevant, protocol ambiguities.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#CHP-3-FN-4)]) *Quoted-printable* is a simple encoding scheme that replaces
    any nonprintable or otherwise illegal characters with the equal sign (=) followed
    by a 2-digit hexadecimal representation of the 8-bit character value to be encoded.
    Any stray equal signs in the input text must be replaced with “=3D” as well.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#CHP-3-FN-5)]) *Base64* is a non-human-readable encoding that encodes
    arbitrary 8-bit input using a 6-bit alphabet of case-sensitive alphanumerics,
    “+”, and “/”. Every 3 bytes of input map to 4 bytes of output. If the input does
    not end at a 3-byte boundary, this is indicated by appending one or two equal
    signs at the end of the output string.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Request Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The original HTTP/0.9 draft provided a single method (or “verb”) for requesting
    a document: GET. The subsequent proposals experimented with an increasingly bizarre
    set of methods to permit interactions other than retrieving a document or running
    a script, including such curiosities as SHOWMETHOD, CHECKOUT, or—why not—SPACEJUMP.^([[122](pr03.html#ftn.CHP-3-FT-11)])'
  prefs: []
  type: TYPE_NORMAL
- en: Most of these thought experiments have been abandoned in HTTP/1.1, which settles
    on a more manageable set of eight methods. Only the first two request types—GET
    and POST—are of any significance to most of the modern Web.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GET method is meant to signify information retrieval. In practice, it is
    used for almost all client-server interactions in the course of a normal browsing
    session. Regular GET requests carry no browser-supplied payloads, although they
    are not strictly prohibited from doing so.
  prefs: []
  type: TYPE_NORMAL
- en: The expectation is that GET requests should not have, to quote the RFC, “significance
    of taking an action other than retrieval” (that is, they should make no persistent
    changes to the state of the application). This requirement is increasingly meaningless
    in modern web applications, where the application state is often not even managed
    entirely on the server side; consequently, the advice is widely ignored by application
    developers.^([[19](#ftn.CHP-3-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In HTTP/1.1, clients may ask the server for any set of possibly noncontiguous
    or overlapping fragments of the target document by specifying the *Range* header
    on GET (and, less commonly, on some other types of requests). The server is not
    obliged to comply, but where the mechanism is available, browsers may use it to
    resume aborted downloads.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The POST method is meant for submitting information (chiefly HTML forms) to
    the server for processing. Because POST actions may have persistent side effects,
    many browsers ask the user to confirm before reloading any content retrieved with
    POST, but for the most part, GET and POST are used in a quasi-interchangeable
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: POST requests are commonly accompanied by a payload, the length of which is
    indicated by the *Content-Length* header. In the case of plain HTML, the payload
    may consist of URL-encoded or MIME-encoded form data (a format detailed in [Chapter 4](ch04.html
    "Chapter 4. Hypertext Markup Language")), although again, the syntax is not constrained
    at the HTTP level in any special way.
  prefs: []
  type: TYPE_NORMAL
- en: HEAD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HEAD is a rarely used request type that is essentially identical to GET but
    that returns only the HTTP headers, and not the actual payload, for the requested
    content. Browsers generally do not issue HEAD requests on their own, but the method
    is sometimes employed by search engine bots and other automated tools, for example,
    to probe for the existence of a file or to check its modification time.
  prefs: []
  type: TYPE_NORMAL
- en: OPTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OPTIONS is a metarequest that returns the set of supported methods for a particular
    URL (or “*”, meaning the server in general) in a response header. The OPTIONS
    method is almost never used in practice, except for server fingerprinting; because
    of its limited value, the returned information may not be very accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the sake of completeness, we need to note that OPTIONS requests are also
    a cornerstone of a proposed cross-domain request authorization scheme, and as
    such, they may gain some prominence soon. We will revisit this scheme, and explore
    many other upcoming browser security features, in [Chapter 16](ch16.html "Chapter 16. New
    and Upcoming Security Features").
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A PUT request is meant to allow files to be uploaded to the server at the specified
    target URL. Because browsers do not support PUT, intentional file-upload capabilities
    are almost always implemented through POST to a server-side script, rather than
    with this theoretically more elegant approach.
  prefs: []
  type: TYPE_NORMAL
- en: That said, some nonweb HTTP clients and servers may use PUT for their own purposes.
    Just as interestingly, some web servers may be misconfigured to process PUT requests
    indiscriminately, creating an obvious security risk.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DELETE is a self-explanatory method that complements PUT (and that is equally
    uncommon in practice).
  prefs: []
  type: TYPE_NORMAL
- en: TRACE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TRACE is a form of “ping” request that returns information about all the proxy
    hops involved in processing a request and echoes the original request as well.
    TRACE requests are not issued by web browsers and are seldom used for legitimate
    purposes. TRACE’s primary use is for security testing, where it may reveal interesting
    details about the internal architecture of HTTP servers in a remote network. Precisely
    for this reason, the method is often disabled by server administrators.
  prefs: []
  type: TYPE_NORMAL
- en: CONNECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CONNECT method is reserved for establishing non-HTTP connections through
    HTTP proxies. It is not meant to be issued directly to servers. If the support
    for CONNECT request is enabled accidentally on a particular server, it may pose
    a security risk by offering an attacker a way to tunnel TCP traffic into an otherwise
    protected network.
  prefs: []
  type: TYPE_NORMAL
- en: Other HTTP Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of other request methods may be employed by other nonbrowser applications
    or browser extensions; the most popular set of HTTP extensions may be WebDAV,
    an authoring and version-control protocol described in RFC 4918.^([[123](pr03.html#ftn.CHP-3-FT-12)])
  prefs: []
  type: TYPE_NORMAL
- en: Further, the *XMLHttpRequest* API nominally allows client-side JavaScript to
    make requests with almost arbitrary methods to the originating server—although
    this last functionality is heavily restricted in certain browsers (we will look
    into this in [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic")).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#CHP-3-FN-6)]) There is an anecdotal (and perhaps even true) tale of
    an unfortunate webmaster by the name of John Breckman. According to the story,
    John’s website has been accidentally deleted by a search engine-indexing robot.
    The robot simply unwittingly discovered an unauthenticated, GET-based administrative
    interface that John had built for his site . . . and happily followed every “delete”
    link it could find.
  prefs: []
  type: TYPE_NORMAL
- en: Server Response Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Section 10 of RFC 2616 lists nearly 50 status codes that a server may choose
    from when constructing a response. About 15 of these are used in real life, and
    the rest are used to indicate increasingly bizarre or unlikely states, such as
    “402 Payment Required” or “415 Unsupported Media Type.” Most of the RFC-listed
    states do not map cleanly to the behavior of modern web applications; the only
    reason for their existence is that somebody hoped they eventually would.
  prefs: []
  type: TYPE_NORMAL
- en: A few codes are worth memorizing because they are common or carry special meaning,
    as discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: '200-299: Success'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This range of status codes is used to indicate a successful completion of a
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 OK**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a normal response to a successful GET or POST. The browser will display
    the subsequently returned payload to the user or will process it in some other
    context-specific way.
  prefs: []
  type: TYPE_NORMAL
- en: '**204 No Content**'
  prefs: []
  type: TYPE_NORMAL
- en: This code is sometimes used to indicate a successful request to which no verbose
    response is expected. A 204 response aborts navigation to the URL that triggered
    it and keeps the user on the originating page.
  prefs: []
  type: TYPE_NORMAL
- en: '**206 Partial Content**'
  prefs: []
  type: TYPE_NORMAL
- en: This code is like 200, except that it is returned by servers in response to
    range requests. The browser must already have a portion of the document (or it
    would not have issued a range request) and will normally inspect the *Content-Range*
    response header to reassemble the document before further processing it.
  prefs: []
  type: TYPE_NORMAL
- en: '300-399: Redirection and Other Status Messages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These codes are used to communicate a variety of states that do not indicate
    an error but that require special handling on the browser end:'
  prefs: []
  type: TYPE_NORMAL
- en: '**301 Moved Permanently, 302 Found, 303 See Other**'
  prefs: []
  type: TYPE_NORMAL
- en: This response instructs the browser to retry the request at a new location,
    specified in the *Location* response header. Despite the distinctions made in
    the RFC, when encountering any of these response codes, all modern browsers replace
    POST with GET, remove the payload, and then resubmit the request automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redirect messages may contain a payload, but if they do, this message will not
    be shown to the user unless the redirection is not possible (for example, because
    of a missing or unsupported *Location* value). In fact, in some browsers, display
    of the message may be suppressed even in that scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '**304 Not Modified**'
  prefs: []
  type: TYPE_NORMAL
- en: This nonredirect response instructs the client that the requested document hasn’t
    been modified in relation to the copy the client already has. This response is
    seen after conditional requests with headers such as *If-Modified-Since*, which
    are issued to revalidate the browser document cache. The response body is not
    shown to the user. (If the server responds this way to an unconditional request,
    the result will be browser-specific and may be hilarious; for example, Opera will
    pop up a nonfunctional download prompt.)
  prefs: []
  type: TYPE_NORMAL
- en: '**307 Temporary Redirect**'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to 302, but unlike with other modes of redirection, browsers will not
    downgrade POST to GET when following a 307 redirect. This code is not commonly
    used in web applications, and some browsers do not behave very consistently when
    handling it.
  prefs: []
  type: TYPE_NORMAL
- en: '400-499: Client-Side Error'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This range of codes is used to indicate error conditions caused by the behavior
    of the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '**400 Bad Request (and related messages)**'
  prefs: []
  type: TYPE_NORMAL
- en: The server is unable or unwilling to process the request for some unspecified
    reason. The response payload will usually explain the problem to some extent and
    will be typically handled by the browser just like a 200 response.
  prefs: []
  type: TYPE_NORMAL
- en: More specific variants, such as “411 Length Required,” “405 Method Not Allowed,”
    or “414 Request-URI Too Long,” also exist. It’s anyone’s guess as to why not specifying
    *Content-Length* when required has a dedicated 411 response code but not specifying
    *Host* deserves only a generic 400 one.
  prefs: []
  type: TYPE_NORMAL
- en: '**401 Unauthorized**'
  prefs: []
  type: TYPE_NORMAL
- en: This code means that the user needs to provide protocol-level HTTP authentication
    credentials in order to access the resource. The browser will usually prompt the
    user for login information next, and it will present a response body only if the
    authentication process is unsuccessful. This mechanism will be explained in more
    detail shortly, in [HTTP Authentication](ch03s08.html "HTTP Authentication") in
    [HTTP Authentication](ch03s08.html "HTTP Authentication").
  prefs: []
  type: TYPE_NORMAL
- en: '**403 Forbidden**'
  prefs: []
  type: TYPE_NORMAL
- en: The requested URL exists but can’t be accessed for reasons other than incorrect
    HTTP authentication. Reasons may involve insufficient filesystem permissions,
    a configuration rule that prevents this request from being processed, or insufficient
    credentials of some sort (e.g., invalid cookies or an unrecognized source IP address).
    The response will usually be shown to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '**404 Not Found**'
  prefs: []
  type: TYPE_NORMAL
- en: The requested URL does not exist. The response body is typically shown to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: '500-599: Server-Side Error'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a class of error messages returned in response to server-side problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**500 Internal Server Error, 503 Service Unavailable, and so on**'
  prefs: []
  type: TYPE_NORMAL
- en: The server is experiencing a problem that prevents it from fulfilling the request.
    This may be a transient condition, a result of misconfiguration, or simply the
    effect of requesting an unexpected location. The response is normally shown to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency of HTTP Code Signaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because there is no immediately observable difference between returning most
    2xx, 4xx, and 5xx codes, these values are not selected with any special zeal.
    In particular, web applications are notorious for returning “200 OK” even when
    an application error has occurred and is communicated on the resulting page. (This
    is one of the many factors that make automated testing of web applications much
    harder than it needs to be.)
  prefs: []
  type: TYPE_NORMAL
- en: On rare occasions, new and not necessarily appropriate HTTP codes are invented
    for specific uses. Some of these are standardized, such as a couple of messages
    introduced in the WebDAV RFC.^([[124](pr03.html#ftn.CHP-3-FT-13)]) Others, such
    as Microsoft’s Microsoft Exchange “449 Retry With” status, are not.
  prefs: []
  type: TYPE_NORMAL
- en: Keepalive Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Originally, HTTP sessions were meant to happen in one shot: Make one request
    for each TCP connection, rinse, and repeat. The overhead of repeatedly completing
    a three-step TCP handshake (and forking off a new process in the traditional Unix
    server design model) soon proved to be a bottleneck, so HTTP/1.1 standardized
    the idea of keepalive sessions instead.'
  prefs: []
  type: TYPE_NORMAL
- en: The existing protocol already gave the server an understanding of where the
    client request ended (an empty line, optionally followed by *Content-Length* bytes
    of data), but to continue using the existing connection, the client also needed
    to know the same about the returned document; the termination of a connection
    could no longer serve as an indicator. Therefore, keepalive sessions require the
    response to include a *Content-Length* header too, always specifying the amount
    of data to follow. Once this many payload bytes are received, the client knows
    it is okay to send a second request and begin waiting for another response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although very beneficial from a performance standpoint, the way this mechanism
    is designed exacerbates the impact of HTTP request and response-splitting bugs.
    It is deceptively easy for the client and the server to get out of sync on which
    response belongs to which request. To illustrate, let’s consider a server that
    thinks it is sending a single HTTP response, structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The client, on the other hand, may see two responses and associate the first
    one with its most current request and the second one with the yet-to-be-issued
    query^([[20](#ftn.CHP-3-FN-7)]) (which may even be addressed to a different hostname
    on the same IP):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If this response is seen by a caching HTTP proxy, the incorrect result may also
    be cached globally and returned to other users, which is really bad news. A much
    safer design for keepalive sessions would involve specifying the length of both
    the headers and the payload up front or using a randomly generated and unpredictable
    boundary to delimit every response. Regrettably, the design does neither.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keepalive connections are the default in HTTP/1.1 unless they are explicitly
    turned off (*Connection: close*) and are supported by many HTTP/1.0 servers when
    enabled with a *Connection: keep-alive* header. Both servers and browsers can
    limit the number of concurrent requests serviced per connection and can specify
    the maximum amount of time an idle connection is kept around.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[20](#CHP-3-FN-7)]) In principle, clients could be designed to sink any unsolicited
    server response data before issuing any subsequent requests in a keepalive session,
    limiting the impact of the attack. This proposal is undermined by the practice
    of HTTP pipelining, however; for performance reasons, some clients are designed
    to dump multiple requests at once, without waiting for a complete response in
    between.
  prefs: []
  type: TYPE_NORMAL
- en: Chunked Data Transfers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The significant limitation of *Content-Length*-based keepalive sessions is the
    need for the server to know in advance the exact size of the returned response.
    This is a pretty simple task when dealing with static files, as the information
    is already available in the filesystem. When serving dynamically generated data,
    the problem is more complicated, as the output must be cached in its entirety
    before it is sent to the client. The challenge becomes insurmountable if the payload
    is very large or is produced gradually (think live video streaming). In these
    cases, precaching to compute payload size is simply out of the question.
  prefs: []
  type: TYPE_NORMAL
- en: 'In response to this challenge, RFC 2616 section 3.6.1 gives servers the ability
    to use *Transfer-Encoding: chunked*, a scheme in which the payload is sent in
    portions as it becomes available. The length of every portion of the document
    is declared up front using a hexadecimal integer occupying a separate line, but
    the total length of the document is indeterminate until a final zero-length chunk
    is seen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample chunked response may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are no significant downsides to supporting chunked data transfers, other
    than the possibility of pathologically large chunks causing integer overflows
    in the browser code or needing to resolve mismatches between *Content-Length*
    and chunk length. (The specification gives precedence to chunk length, although
    any attempts to handle this situation gracefully appear to be ill-advised.) All
    the popular browsers deal with these conditions properly, but new implementations
    need to watch their backs.
  prefs: []
  type: TYPE_NORMAL
- en: Caching Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For reasons of performance and bandwidth conservation, HTTP clients and some
    intermediaries are eager to cache HTTP responses for later reuse. This must have
    seemed like a simple task in the early days of the Web, but it is increasingly
    fraught with peril as the Web encompasses ever more sensitive, user-specific information
    and as this information is updated more and more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: RFC 2616 section 13.4 states that GET requests responded to with a range of
    HTTP codes (most notably, “200 OK” and “301 Moved Permanently”) may be implicitly
    cached in the absence of any other server-provided directives. Such a response
    may be stored in the cache indefinitely, and may be reused for any future requests
    involving the same request method and destination URL, even if other parameters
    (such as *Cookie* headers) differ. There is a prohibition against caching requests
    that use HTTP authentication (see [HTTP Authentication](ch03s08.html "HTTP Authentication")
    in [HTTP Authentication](ch03s08.html "HTTP Authentication")), but other authentication
    methods, such as cookies, are not recognized in the spec.
  prefs: []
  type: TYPE_NORMAL
- en: When a response is cached, the implementation may opt to revalidate it before
    reuse, but doing so is not required most of the time. Revalidation is achieved
    by request with a special conditional header, such as *If-Modified-Since* (followed
    by a date recorded on the previously cached response) or *If-None-Match* (followed
    by an opaque *ETag* header value that the server returned with an earlier copy).
    The server may respond with a “304 Not Modified” code or return a newer copy of
    the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Date/If-Modified-Since* and *ETag/If-None-Match* header pairs, when coupled
    with *Cache-Control: private*, offer a convenient and entirely unintended way
    for websites to store long-lived, unique tokens in the browser.^([[125](pr03.html#ftn.CHP-3-FT-14)])
    The same can also be achieved by depositing a unique token inside a cacheable
    JavaScript file and returning “304 Not Modified” to all future conditional requests
    to the token-generating location. Unlike purpose-built mechanisms such as HTTP
    cookies (discussed in the next section), users have very little control over what
    information is stored in the browser cache, under what circumstances, and for
    how long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit caching is highly problematic, and therefore, servers almost always
    should resort to using explicit HTTP-caching directives. To assist with this,
    HTTP/1.0 provides an *Expires* header that specifies the date by which the cached
    copy should be discarded; if this value is equal to the *Date* header provided
    by the server, the response is noncacheable. Beyond that simple rule, the connection
    between *Expires* and *Date* is unspecified: It is not clear whether *Expires*
    should be compared to the system clock on the caching system (which is problematic
    if the client and server clocks are not in sync) or evaluated based on the *Expires
    - Date* delta (which is more robust, but which may stop working if *Date* is accidentally
    omitted). Firefox and Opera use the latter interpretation, while other browsers
    prefer the former one. In most browsers, an invalid *Expires* value also inhibits
    caching, but depending on it is a risky bet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP/1.0 clients can also include a *Pragma: no-cache* request header, which
    may be interpreted by the proxy as an instruction to obtain a new copy of the
    requested resource, instead of returning an existing one. Some HTTP/1.0 proxies
    also recognize a nonstandard *Pragma: no-cache* response header as an instruction
    not to make a copy of the document.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, HTTP/1.1 embraces a far more substantial approach to caching directives,
    introducing a new *Cache-Control* header. The header takes values such as *public*
    (the document is cacheable publicly), *private* (proxies are not permitted to
    cache), *no-cache* (which is a bit confusing—the response may be cached but should
    not be reused for future requests),^([[21](#ftn.CHP-3-FN-8)]) and *no-store* (absolutely
    no caching at all). Public and private caching directives may be accompanied with
    a qualifier such as *max-age*, specifying the maximum time an old copy should
    be kept, or *must-revalidate*, requesting a conditional request to be made before
    content reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, it is typically necessary for servers to return both HTTP/1.0
    and HTTP/1.1 caching directives, because certain types of legacy commercial proxies
    do not understand *Cache-Control* correctly. In order to reliably prevent caching
    over HTTP, it may be necessary to use the following set of response headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When these caching directives disagree, the behavior is difficult to predict:
    Some browsers will favor HTTP/1.1 directives and give precedence to *no-cache*,
    even if it is mistakenly followed by *public*; others don’t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another risk of HTTP caching is associated with unsafe networks, such as public
    Wi-Fi networks, which allow an attacker to intercept requests to certain URLs
    and return modified, long-cacheable contents on requests to the victim. If such
    a poisoned browser cache is then reused on a trusted network, the injected content
    will unexpectedly resurface. Perversely, the victim does not even have to visit
    the targeted application: A reference to a carefully chosen sensitive domain can
    be injected by the attacker into some other context. There are no good solutions
    to this problem yet; purging your browser cache after visiting Starbucks may be
    a very good idea.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[21](#CHP-3-FN-8)]) The RFC is a bit hazy in this regard, but it appears
    that the intent is to permit the cached document to be used for purposes such
    as operating the “back” and “forward” navigation buttons in a browser but not
    when a proper page load is requested. Firefox follows this approach, while all
    other browsers consider *no-cache* and *no-store* to be roughly equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Cookie Semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP cookies are not a part of RFC 2616, but they are one of the more important
    protocol extensions used on the Web. The cookie mechanism allows servers to store
    short, opaque *name=value* pairs in the browser by sending a *Set-Cookie* response
    header and to receive them back on future requests via the client-supplied *Cookie*
    parameter. Cookies are by far the most popular way to maintain sessions and authenticate
    user requests; they are one of the four canonical forms of *ambient authority*^([[22](#ftn.CHP-3-FN-9)])
    on the Web (the other forms being built-in HTTP authentication, IP checking, and
    client certificates).
  prefs: []
  type: TYPE_NORMAL
- en: Originally implemented in Netscape by Lou Montulli around 1994, and described
    in a brief four-page draft document,^([[126](pr03.html#ftn.CHP-3-FT-15)]) the
    mechanism has not been outlined in a proper standard in the last 17 years. In
    1997, RFC 2109^([[127](pr03.html#ftn.CHP-3-FT-16)]) attempted to document the
    status quo, but somewhat inexplicably, it also proposed a number of sweeping changes
    that, to this day, make this specification substantially incompatible with the
    actual behavior of any modern browser. Another ambitious effort—*Cookie2*—made
    an appearance in RFC 2965,^([[128](pr03.html#ftn.CHP-3-FT-17)]) but a decade later,
    it still has virtually no browser-level support, a situation that is unlikely
    to change. A new effort to write a reasonably accurate cookie specification—RFC
    6265^([[129](pr03.html#ftn.CHP-3-FT-18)])—was wrapped up shortly before the publication
    of this book, finally ending this specification-related misery.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the prolonged absence of any real standards, the actual implementations
    evolved in very interesting and sometimes incompatible ways. In practice, new
    cookies can be set using *Set-Cookie* headers followed by a single *name=value*
    pair and a number of optional semicolon-delimited parameters defining the scope
    and lifetime of the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: '**Expires**'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the expiration date for a cookie in a format similar to that used
    for *Date* or *Expires* HTTP headers. If a cookie is served without an explicit
    expiration date, it is typically kept in memory for the duration of a browser
    session (which, especially on portable computers with suspend functionality, can
    easily span several weeks). Definite-expiry cookies may be routinely saved to
    disk and persist across sessions, unless a user’s privacy settings explicitly
    prevent this possibility.
  prefs: []
  type: TYPE_NORMAL
- en: '**Max-age**'
  prefs: []
  type: TYPE_NORMAL
- en: This alternative, RFC-suggested expiration mechanism is not supported in Internet
    Explorer and therefore is not used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain**'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter allows the cookie to be scoped to a domain broader than the hostname
    that returned the *Set-Cookie* header. The exact rules and security consequences
    of this scoping mechanism are explored in [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Contrary to what is implied in RFC 2109, it is not possible to scope cookies
    to a specific hostname when using this parameter. For example, *domain=example.com*
    will always match [www.example.com](http://www.example.com) as well. Omitting
    *domain* is the only way to create host-scoped cookies, but even this approach
    is not working as expected in Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Path**'
  prefs: []
  type: TYPE_NORMAL
- en: Allows the cookie to be scoped to a particular request path prefix. This is
    not a viable security mechanism for the reasons explained in [Chapter 9](ch09.html
    "Chapter 9. Content Isolation Logic"), but it may be used for convenience, to
    prevent identically named cookies used in various parts of the application from
    colliding with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure attribute**'
  prefs: []
  type: TYPE_NORMAL
- en: Prevents the resulting cookie from being sent over nonencrypted connections.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpOnly attribute**'
  prefs: []
  type: TYPE_NORMAL
- en: Removes the ability to read the cookie through the *document.cookie* API in
    JavaScript. This is a Microsoft extension, although it is now supported by all
    mainstream browsers.
  prefs: []
  type: TYPE_NORMAL
- en: When making future requests to a domain for which valid cookies are found in
    the cookie jar, browsers will combine all applicable *name=value* pairs into a
    single, semicolon-delimited *Cookie* header, without any additional metadata,
    and return them to the server. If too many cookies need to be sent on a particular
    request, server-enforced header size limits will be exceeded, and the request
    may fail; there is no method for recovering from this condition, other than manually
    purging the cookie jar.
  prefs: []
  type: TYPE_NORMAL
- en: Curiously, there is no explicit method for HTTP servers to delete unneeded cookies.
    However, every cookie is uniquely identified by a name-domain-path tuple (the
    *secure* and *httponly* attributes are ignored), which permits an old cookie of
    a known scope to be simply overwritten. Furthermore, if the overwriting cookie
    has an *expires* date in the past, it will be immediately dropped, effectively
    giving a contrived way to purge the data.
  prefs: []
  type: TYPE_NORMAL
- en: Although RFC 2109 requires multiple comma-separated cookies to be accepted within
    a single *Set-Cookie* header, this approach is dangerous and is no longer supported
    by any browser. Firefox allows multiple cookies to be set in a single step via
    the *document.cookie* JavaScript API, but inexplicably, it requires newlines as
    delimiters instead. No browser uses commas as *Cookie* delimiters, and recognizing
    them on the server side should be considered unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference between the spec and reality is that cookie values
    are supposed to use the *quoted-string* format outlined in HTTP specs (see [Semicolon-Delimited
    Header Values](ch03.html#semicolon-delimited_header_values "Semicolon-Delimited
    Header Values") in [Semicolon-Delimited Header Values](ch03.html#semicolon-delimited_header_values
    "Semicolon-Delimited Header Values")), but only Firefox and Opera recognize this
    syntax in practice. Reliance on *quoted-string* values is therefore unsafe, and
    so is allowing stray quote characters in attacker-controlled cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are not guaranteed to be particularly reliable. User agents enforce
    modest settings on the number and size of cookies permitted per domain and, as
    a misguided privacy feature, may also restrict their lifetime. Because equally
    reliable user tracking may be achieved by other means, such as the *ETag/If-None-Match*
    behavior outlined in the previous section, the efforts to restrict cookie-based
    tracking probably do more harm than good.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[22](#CHP-3-FN-9)]) *Ambient authority* is a form of access control based
    on a global and persistent property of the requesting entity, rather than any
    explicit form of authorization that would be valid only for a specific action.
    A user-identifying cookie included indiscriminately on every outgoing request
    to a remote site, without any consideration for why this request is being made,
    falls into that category.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP authentication, as specified in RFC 2617,^([[130](pr03.html#ftn.CHP-3-FT-19)])
    is the original credential-handling mechanism envisioned for web applications,
    one that is now almost completely extinct. The reasons for this outcome might
    have been the inflexibility of the associated browser-level UIs, the difficulty
    of accommodating more sophisticated non-password-based authentication schemes,
    or perhaps the inability to exercise control over how long credentials are cached
    and what other domains they are shared with.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the basic scheme is fairly simple. It begins with the browser making
    an unauthenticated request, to which the server responds with a “401 Unauthorized”
    code.^([[23](#ftn.CHP-3-FN-10)]) The server must also include a *WWW-Authenticate*
    HTTP header, specifying the requested authentication method, the *realm* string
    (an arbitrary identifier to which the entered credentials should be bound), and
    other method-specific parameters, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: The client is expected to obtain the credentials in one way or the other, encode
    them in the *Authorization* header, and retry the original request with this header
    included. According to the specification, for performance reasons, the same *Authorization*
    header may also be included on subsequent requests to the same server path prefix
    without the need for a second *WWW-Authenticate* challenge. It is also permissible
    to reuse the same credentials in response to any *WWW-Authenticate* challenges
    elsewhere on the server, if the *realm* string and the authentication method match.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, this advice is not followed very closely: Other than Safari and
    Chrome, most browsers ignore the *realm* string or take a relaxed approach to
    path matching. On the flip side, all browsers scope cached credentials not only
    to the destination server but also to a specific protocol and port, a practice
    that offers some security benefits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two credential-passing methods specified in the original RFC are known
    as *basic* and *digest*. The first one essentially sends the passwords in plaintext,
    encoded as *base64*. The other computes a one-time cryptographic hash that protects
    the password from being viewed in plaintext and prevents the *Authorization* header
    from being replayed later. Unfortunately, modern browsers support both methods
    and do not distinguish between them in any clear way. As a result, attackers can
    simply replace the word *digest* with *basic* in the initial request to obtain
    a clean, plaintext password as soon as the user completes the authentication dialog.
    Surprisingly, section 4.8 of the RFC predicted this risk and offered some helpful
    yet ultimately ignored advice:'
  prefs: []
  type: TYPE_NORMAL
- en: User agents should consider measures such as presenting a visual indication
    at the time of the credentials request of what authentication scheme is to be
    used, or remembering the strongest authentication scheme ever requested by a server
    and produce a warning message before using a weaker one. It might also be a good
    idea for the user agent to be configured to demand Digest authentication in general,
    or from specific sites.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In addition to these two RFC-specified authentication schemes, some browsers
    also support less-common methods, such as Microsoft’s *NTLM* and *Negotiate*,
    used for seamless authentication with Windows domain credentials.^([[131](pr03.html#ftn.CHP-3-FT-20)])
  prefs: []
  type: TYPE_NORMAL
- en: Although HTTP authentication is seldom encountered on the Internet, it still
    casts a long shadow over certain types of web applications. For example, when
    an external, attacker-supplied image is included in a thread on a message board,
    and the server hosting that image suddenly decides to return “401 Unauthorized”
    on some requests, users viewing the thread will be presented out of the blue with
    a somewhat cryptic password prompt. After double-checking the address bar, many
    will probably confuse the prompt for a request to enter their forum credentials,
    and these will be immediately relayed to the attacker’s image-hosting server.
    Oops.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[23](#CHP-3-FN-10)]) The terms *authentication* and *authorization* appear
    to be used interchangeably in this RFC, but they have a distinctive meaning elsewhere
    in information security. *Authentication* is commonly used to refer to the process
    of proving your identity, whereas *authorization* is the process of determining
    whether your previously established credentials permit you to carry out a specific
    privileged action.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol-Level Encryption and Client Certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As should now be evident, all information in HTTP sessions is exchanged in
    plaintext over the network. In the 1990s, this would not have been a big deal:
    Sure, plaintext exposed your browsing choices to nosy ISPs, and perhaps to another
    naughty user on your office network or an overzealous government agency, but that
    seemed no worse than the behavior of SMTP, DNS, or any other commonly used application
    protocol. Alas, the growing popularity of the Web as a commerce platform has aggravated
    the risk, and substantial network security regression caused by the emergence
    of inherently unsafe public wireless networks put another nail in that coffin.'
  prefs: []
  type: TYPE_NORMAL
- en: After several less successful hacks, a straightforward solution to this problem
    was proposed in RFC 2818:^([[132](pr03.html#ftn.CHP-3-FT-21)]) Why not encapsulate
    normal HTTP requests within an existing, multipurpose Transport Layer Security
    (TLS, aka SSL) mechanism developed several years earlier? This transport method
    leverages public key cryptography^([[24](#ftn.CHP-3-FN-11)]) to establish a confidential,
    authenticated communication channel between the two endpoints, without requiring
    any HTTP-level tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: In order to allow web servers to prove their identity, every HTTPS-enabled web
    browser ships with a hefty set of public keys belonging to a variety of *certificate
    authorities*. Certificate authorities are organizations that are trusted by browser
    vendors to cryptographically attest that a particular public key belongs to a
    particular site, hopefully after validating the identity of the person who requests
    such attestation and after verifying his claim to the domain in question.
  prefs: []
  type: TYPE_NORMAL
- en: The set of trusted organizations is diverse, arbitrary, and not particularly
    well documented, which often prompts valid criticisms. But in the end, the system
    usually does the job reasonably well. Only a handful of bloopers have been documented
    so far (including a recent high-profile compromise of a company named Comodo^([[133](pr03.html#ftn.CHP-3-FT-22)])),
    and no cases of widespread abuse of CA privileges are on the record.
  prefs: []
  type: TYPE_NORMAL
- en: As to the actual implementation, when establishing a new HTTPS connection, the
    browser receives a signed public key from the server, verifies the signature (which
    can’t be forged without having access to the CA’s private key), checks that the
    signed *cn* (common name) or *subjectAltName* fields in the certificate indicate
    that this certificate is issued for the server the browser wants to talk to, and
    confirms that the key is not listed on a public revocation list (for example,
    due to being compromised or obtained fraudulently). If everything checks out,
    the browser can proceed by encrypting messages to the server with that public
    key and be certain that only that specific party will be able to decrypt them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the client remains anonymous: It generates a temporary encryption
    key, but that process does not prove the client’s identity. Such a proof can be
    arranged, though. Client certificates are embraced internally by certain organizations
    and are adopted on a national level in several countries around the world (e.g.,
    for e-government services). Since the usual purpose of a client certificate is
    to provide some information about the real-world identity of the user, browsers
    usually prompt before sending them to newly encountered sites, for privacy reasons;
    beyond that, the certificate may act as yet another form of ambient authority.'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that although HTTPS as such is a sound scheme that resists
    both passive and active attackers, it does very little to hide the evidence of
    access to a priori public information. It does not mask the rough HTTP request
    and response sizes, traffic directions, and timing patterns in a typical browsing
    session, thus making it possible for unsophisticated, passive attackers to figure
    out, for example, which embarrassing page on Wikipedia is being viewed by the
    victim over an encrypted channel. In fact, in one extreme case, Microsoft researchers
    illustrated the use of such packet profiling to reconstruct user keystrokes in
    an online application.^([[134](pr03.html#ftn.CHP-3-FT-23)])
  prefs: []
  type: TYPE_NORMAL
- en: Extended Validation Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days of HTTPS, many public certificate authorities relied on fairly
    pedantic and cumbersome user identity and domain ownership checks before they
    would sign a certificate. Unfortunately, in pursuit of convenience and in the
    interest of lowering prices, some now require little more than a valid credit
    card and the ability to put a file on the destination server in order to complete
    the verification process. This approach renders most of the certificate fields
    other than *cn* and *subjectAltName* untrustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this problem, a new type of certificate, tagged using a special
    flag, is being marketed today at a significantly higher price: *Extended Validation
    SSL (EV SSL)*. These certificates are expected not only to prove domain ownership
    but also more reliably attest to the identity of the requesting party, following
    a manual verification process. EV SSL is recognized by all modern browsers by
    making portion of the address bar blue or green. Although having this tier of
    certificates is valuable, the idea of coupling a higher-priced certificate with
    an indicator that vaguely implies a “higher level of security” is often criticized
    as a cleverly disguised money-making scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: Error-Handling Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an ideal world, HTTPS connections that involve a suspicious certificate error,
    such as a grossly mismatched hostname or an unrecognized certification authority,
    should simply result in a failure to establish the connection. Less-suspicious
    errors, such as a recently expired certificate or a hostname mismatch, perhaps
    could be accompanied by just a gentle warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, most browsers have indiscriminately delegated the responsibility
    for understanding the problem to the user, trying hard (and ultimately failing)
    to explain cryptography in layman’s terms and requiring the user to make a binary
    decision: Do you actually want to see this page or not? ([Figure 3-1](ch03s09.html#an_example_certificate_warning_dialog_in
    "Figure 3-1. An example certificate warning dialog in the still-popular Internet
    Explorer 6") shows one such prompt.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example certificate warning dialog in the still-popular Internet Explorer
    6](httpatomoreillycomsourcenostarchimages949997.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1. An example certificate warning dialog in the still-popular Internet
    Explorer 6
  prefs: []
  type: TYPE_NORMAL
- en: 'The language and appearance of SSL warnings has evolved through the years toward
    increasingly dumbed-down (but still problematic) explanations of the problem and
    more complicated actions required to bypass the warning. This trend may be misguided:
    Studies show that over 50 percent of even the most frightening and disruptive
    warnings are clicked through.^([[135](pr03.html#ftn.CHP-3-FT-24)]) It is easy
    to blame the users, but ultimately, we may be asking them the wrong questions
    and offering exactly the wrong choices. Simply, if it is believed that clicking
    through the warning is advantageous in some cases, offering to open the page in
    a clearly labeled “sandbox” mode, where the harm is limited, would be a more sensible
    solution. And if there is no such belief, any override capabilities should be
    eliminated entirely (a goal sought by *Strict Transport Security*, an experimental
    mechanism that will be discussed in [Chapter 16](ch16.html "Chapter 16. New and
    Upcoming Security Features")).'
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Handling User-Controlled Filenames in Content-Disposition Headers
  prefs: []
  type: TYPE_NORMAL
- en: '**If you do not need non-Latin characters:** Strip or substitute any characters
    except for alphanumerics, “.”, “-”, and “_”. To protect your users against potentially
    harmful or deceptive filenames, you may also want to confirm that at least the
    first character is alphanumeric and substitute all but the rightmost period with
    something else (e.g., an underscore).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that allowing quotes, semicolons, backslashes, and control characters
    (0x00-0x1F) will introduce vulnerabilities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**If you need non-Latin names:** You must use RFC 2047, RFC 2231, or URL-style
    percent encoding in a browser-dependent manner. Make sure to filter out control
    characters (0x00-0x1F) and escape any semicolons, backslashes, and quotes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Putting User Data in HTTP Cookies
  prefs: []
  type: TYPE_NORMAL
- en: '**Percent-encode everything except for alphanumerics**. Better yet, use base64\.
    Stray quote characters, control characters (0x00-0x1F), high-bit characters (0x80-0xFF),
    commas, semicolons, and backslashes may allow new cookie values to be injected
    or the meaning and scope of existing cookies to be altered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Sending User-Controlled Location Headers
  prefs: []
  type: TYPE_NORMAL
- en: '**Consult the cheat sheet in [Chapter 2](ch02.html "Chapter 2. It Starts with
    a URL")**. Parse and normalize the URL, and confirm that the scheme is on a whitelist
    of permissible values and that you are comfortable redirecting to the specified
    host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that any control and high-bit characters are escaped properly. Use
    Punycode for hostnames and percent-encoding for the remainder of the URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When Sending User-Controlled Redirect Headers
  prefs: []
  type: TYPE_NORMAL
- en: '**Follow the advice provided for Location**. Note that semicolons are unsafe
    in this header and cannot be escaped reliably, but they also happen to have a
    special meaning in some URLs. Your choice is to reject such URLs altogether or
    to percent-encode the “;” character, thereby violating the RFC-mandated syntax
    rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Constructing Other Types of User-Controlled Requests or Responses
  prefs: []
  type: TYPE_NORMAL
- en: '**Examine the syntax and potential side effects of the header in question**.
    In general, be mindful of control and high-bit characters, commas, quotes, backslashes,
    and semicolons; other characters or strings may be of concern on a case-by-case
    basis. Escape or substitute these values as appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When building a new HTTP client, server, or proxy:** Do not create a new
    implementation unless you absolutely have to. If you can’t help it, read this
    chapter thoroughly and aim to mimic an existing mainstream implementation closely.
    If possible, ignore the RFC-provided advice about fault tolerance and bail out
    if you encounter any syntax ambiguities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[24](#CHP-3-FN-11)]) Public key cryptography relies on asymmetrical encryption
    algorithms to create a pair of keys: a private one, kept secret by the owner and
    required to decrypt messages, and a public one, broadcast to the world and useful
    only to encrypt traffic to that recipient, not to decrypt it.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Hypertext Markup Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Hypertext Markup Language (HTML) is the primary method of authoring online
    documents. One of the earliest written accounts of this language is a brief summary
    posted on the Internet by Tim Berners-Lee in 1991.^([[136](pr03.html#ftn.CHP-4-FT-1)])
    His proposal outlines an SGML-derived syntax that allows text documents to be
    annotated with inline hyperlinks and several types of layout aids. In the following
    years, this specification evolved gradually under the direction of Sir Berners-Lee
    and Dan Connolly, but it wasn’t until 1995, at the onset of the First Browser
    Wars, that a reasonably serious and exhaustive specification of the language (HTML
    2.0) made it to RFC 1866.^([[137](pr03.html#ftn.CHP-4-FT-2)])
  prefs: []
  type: TYPE_NORMAL
- en: 'From that point on, all hell broke loose: For the next few years, competing
    browser vendors kept introducing all sorts of flashy, presentation-oriented features
    and tweaked the language to their liking. Several attempts to amend the original
    RFC have been undertaken, but ultimately the IETF-managed standardization approach
    proved to be too inflexible. The newly formed World Wide Web Consortium took over
    the maintenance of the language and eventually published the HTML 3.2 specification
    in 1997.^([[138](pr03.html#ftn.CHP-4-FT-3)])'
  prefs: []
  type: TYPE_NORMAL
- en: The new specification tried to reconcile the differences in browser implementations
    while embracing many of the bells and whistles that appealed to the public, such
    as customizable text colors and variable typefaces. Ultimately, though, HTML 3.2
    proved to be a step back for the clarity of the language and had only limited
    success in catching up with the facts.
  prefs: []
  type: TYPE_NORMAL
- en: In the following years, the work on HTML 4 and 4.01^([[139](pr03.html#ftn.CHP-4-FT-4)])
    focused on pruning HTML of all accumulated excess and on better explaining how
    document elements should be interpreted and rendered. It also defined an alternative,
    strict XHTML syntax derived from XML, which was much easier to consistently parse
    but more punishing to write. Despite all this work, however, only a small fraction
    of all websites on the Internet could genuinely claim compliance with any of these
    standards, and little or no consistency in parsing modes and error recovery could
    be seen on the client end. Consequently, some of the work on improving the core
    language fizzled out, and the W3C turned its attention to stylesheets, the Document
    Object Model, and other more abstract or forward-looking challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 2000s, some of the low-level work has been revived under the banner
    of HTML5,^([[140](pr03.html#ftn.CHP-4-FT-5)]) an ambitious project to normalize
    almost every aspect of the language syntax and parsing, define all the related
    APIs, and more closely police browser behavior in general. Time will tell if it
    will be successful; until then, the language itself, and each of the four leading
    parsing engines,^([[25](#ftn.CHP-4-FN-1)]) come with their own set of frustrating
    quirks.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Concepts Behind HTML Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a purely theoretical standpoint, HTML relies on a fairly simple syntax:
    a hierarchical structure of tags, *name=value* tag parameters, and text nodes
    (forming the actual document body) in between. For example, a simple document
    with a title, a heading, and a hyperlink may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax puts some constraints on what may appear inside a parameter value
    or inside the document body. Five characters—angle brackets, single and double
    quotes, and an ampersand—are reserved as the building blocks of the HTML markup,
    and these need to be avoided or escaped in some way when used outside of their
    intended function. The most important rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: Stray ampersands (&) should never appear in most sections of an HTML document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both types of angle brackets are obviously problematic inside a tag, unless
    properly quoted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The left angle bracket (<) is a hazard inside a text node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quote characters appearing inside a tag can have undesirable effects, depending
    on their exact location, but are harmless in text nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow these characters to appear in problematic locations without causing
    side effects, an ampersand-based encoding scheme, discussed in [Entity Encoding](ch04s03.html
    "Entity Encoding") in [HTML Parsing Survival Tips](ch04s02.html#html_parsing_survival_tips
    "HTML Parsing Survival Tips"), is provided.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, the availability of such an encoding scheme is not a guarantee of
    its use. The failure to properly filter out or escape reserved characters when
    displaying user-controlled data is the cause of a range of extremely common and
    deadly web application security flaws. A particularly well-known example of this
    is *cross-site scripting (XSS)*, an attack in which malicious, attacker-provided
    JavaScript code is unintentionally echoed back somewhere in the HTML markup, effectively
    giving the attacker full control over the appearance and operation of the targeted
    site.
  prefs: []
  type: TYPE_NORMAL
- en: Document Parsing Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For any HTML document, a top-level *<!DOCTYPE>* directive may be used to instruct
    the browser to parse the file in a manner that at least superficially conforms
    to one of the officially defined standards; to a more limited extent, the same
    signal can be conveyed by the *Content-Type* header, too. Of all the available
    parsing modes, the most striking difference exists between XHTML and traditional
    HTML. In the traditional mode, parsers will attempt to recover from most types
    of syntax errors, including unmatched opening and closing tags. In addition, tag
    and parameter names will be considered case insensitive, parameter values will
    not always need to be quoted, and certain types of tags, such as *<img>*, will
    be closed implicitly. In other words, the following input will be grudgingly tolerated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML mode, on the other hand, is strict: All tags need to be balanced carefully,
    named using the proper case, and closed explicitly. (The XML-specific self-closing
    tag syntax, such as *<img />*, is permitted.) In addition, most syntax mistakes,
    even trivial ones, will result in an error and prevent the document from being
    displayed at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the regular flavor of HTML, XML-based documents may also elegantly incorporate
    sections using other XML-compliant markup formats, such as MathML, a mathematical
    formula markup language. This is done by specifying a different *xmlns* namespace
    setting for a particular tag, with no need for one-off, language-level hacks.
  prefs: []
  type: TYPE_NORMAL
- en: The last important difference worth mentioning here is that traditional HTML
    parsing strategies feature a selection of special modes, entered into after certain
    tags are encountered and exited only when a specific terminator string is seen;
    everything in between is interpreted as non-HTML text. Some examples of such special
    tags include *<style>*, *<script>*, *<textarea>*, or *<xmp>*. In practical implementations,
    these modes are exited only when a literal, case-insensitive match on *</style*,
    *</script*, or a similar matching value, is made; any other markup inside such
    a block will not be interpreted as HTML. (Interestingly, there is one officially
    obsolete tag, *<plaintext>*, that cannot be exited at all; it stays in effect
    for the remainder of the document.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In comparison, the XML mode is more predictable. It generally forbids stray
    “<” and “&” characters inside the document, but it provides a special syntax,
    starting with “<![CDATA[” and ending with “]]>”, as a way to encapsulate any raw
    text inside an arbitrary tag. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The other notable special parsing mode available in both XHTML and normal HTML
    is a comment block. In XML, it quite simply begins with “<!--” and ends with “-->”.
    In the traditional HTML parser in Firefox versions prior to 4, any occurrence
    of “--”, later followed by “>”, is also considered good enough.
  prefs: []
  type: TYPE_NORMAL
- en: The Battle over Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The low-level syntax of the language aside, HTML is also the subject of a fascinating
    conceptual struggle: a clash between the ideology and the reality of the online
    world. Tim Berners-Lee always championed the vision of a *semantic web*, an interconnected
    system of documents in which every functional block, such as a citation, a snippet
    of code, a mailing address, or a heading, has its meaning explained by an appropriate
    machine-readable tag (say, *<cite>*, *<code>*, *<address>*, or *<h1>* to *<h6>*).'
  prefs: []
  type: TYPE_NORMAL
- en: This approach, he and other proponents argued, would make it easier for machines
    to crawl, analyze, and index the content in a meaningful way, and in the near
    future, it would enable computers to reason using the sum of human knowledge.
    According to this philosophy, the markup language should provide a way to stylize
    the appearance of a document, but only as an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: Sir Berners-Lee has never given up on this dream, but in this one regard, the
    actual usage of HTML proved to be very different from what he wished for. Web
    developers were quick to pragmatically distill the essence of HTML 3.2 into a
    handful of presentation-altering but semantically neutral tags, such as *<font>*,
    *<b>*, and *<pre>*, and saw no reason to explain further the structure of their
    documents to the browser. W3C attempted to combat this trend but with limited
    success. Although tags such as *<font>* have been successfully obsoleted and largely
    abandoned in favor of CSS, this is only because stylesheets offered more powerful
    and consistent visual controls. With the help of CSS, the developers simply started
    relying on a soup of semantically agnostic *<span>* and *<div>* tags to build
    everything from headings to user-clickable buttons, all in a manner completely
    opaque to any automated content extraction tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite having had a lasting impact on the design of the language, in some
    ways, the idea of a semantic web may be becoming obsolete: Online content less
    frequently maps to the concept of a single, viewable document, and HTML is often
    reduced to providing a convenient drawing surface and graphic primitives for JavaScript
    applications to build their interfaces with.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[25](#CHP-4-FN-1)]) To process HTML documents, Internet Explorer uses the
    Trident engine (aka MSHTML); Firefox and some derived products use Gecko; Safari,
    Chrome, and several other browsers use WebKit; and Opera relies on Presto. With
    the exception of WebKit, a collaborative open source effort maintained by several
    vendors, these engines are developed largely in-house by their respective browser
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTML Parser Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fundamentals of HTML syntax outlined in the previous sections are usually
    enough to understand the meaning of well-formed HTML and XHTML documents. When
    the XHTML dialect is used, there is little more to the story: The minimal fault-tolerance
    of the parser means that anomalous syntax almost always leads simply to a parsing
    error. Alas, the picture is very different with traditional, laid-back HTML parsers,
    which aggressively second-guess the intent of the page developer even in very
    ambiguous or potentially harmful situations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since an accurate understanding of user-supplied markup is essential to designing
    many types of security filters, let’s have a quick look at some of these behaviors
    and quirks. To begin, consider the following reference snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages949999.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Web developers are usually surprised to learn that this syntax can be drastically
    altered without changing its significance to the browser. For example, Internet
    Explorer will allow an NUL character (0x00) to be inserted in the location marked
    at ![](httpatomoreillycomsourcenostarchimages950001.png), a change that is likely
    to throw all naïve HTML filters off the trail. It is also not widely known that
    the whitespaces at ![](httpatomoreillycomsourcenostarchimages950003.png) and ![](httpatomoreillycomsourcenostarchimages950005.png)
    can be substituted with uncommon vertical tab (0x0B) or form feed (0x0C) characters
    in all browsers and with a nonbreaking UTF-8 space (0xA0) in Opera.^([[26](#ftn.CHP-4-FN-2)])
    Oh, and here''s a really surprising bit: In Firefox, the whitespace at ![](httpatomoreillycomsourcenostarchimages950003.png)
    can also be replaced with a single, regular slash—yet the one at ![](httpatomoreillycomsourcenostarchimages950005.png)
    can’t.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, the location marked ![](httpatomoreillycomsourcenostarchimages950007.png)
    is also of note. In this spot, NUL characters are ignored by most parsers, as
    are many types of whitespaces. Not long ago, WebKit browsers accepted a slash
    in this location, but recent parser improvements have eliminated this quirk.
  prefs: []
  type: TYPE_NORMAL
- en: Quote characters are a yet another topic of interest. Website developers know
    that single and double quotes can be used to put a string containing whitespaces
    or angle brackets in an HTML parameter, but it usually comes as a surprise that
    Internet Explorer also honors backticks (`) instead of real quotes in the location
    marked ![](httpatomoreillycomsourcenostarchimages950009.png). Similarly, few people
    realize that in any browser, an implicit whitespace is inserted after a quoted
    parameter, and that the explicit whitespace at ![](httpatomoreillycomsourcenostarchimages950011.png)
    can therefore be skipped without changing the meaning of the tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The security impact of these patterns is not always easy to appreciate, but
    consider an HTML filter tasked with scrubbing an *<img>* tag with an attacker-controlled
    *title* parameter. Let’s say that in the input markup, this parameter is not quoted
    if it contains no whitespaces and angle brackets—a design that can be seen on
    a popular blogging site. This practice may appear safe at first, but in the following
    two cases, a malicious, injected *onerror* parameter will materialize inside a
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet another wonderful quote-related quirk in Internet Explorer makes this job
    even more complicated. While most browsers recognize quoting only when it is used
    at the beginning of a parameter value, Internet Explorer simply checks for any
    occurrence of an equal sign (=) followed by a quote and will parse this syntax
    in a rather unexpected way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Interactions Between Multiple Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parsing a single tag can be a daunting task, but as you might imagine, anomalous
    arrangements of multiple HTML tags will be even less predictable. Consider the
    following trivial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When presented with such syntax, most browsers only interpret *<i>* and treat
    the “<b” string as an invalid tag parameter. Firefox versions before 4, however,
    would automatically close the *<i>* tag first when encountering an angle bracket
    and, in the end, will interpret both *<i>* and *<b>*. In the spirit of fault tolerance,
    until recently WebKit followed that model, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar behavior can be observed in previous versions of Firefox when dealing
    with tag names that contain invalid characters (in this case, the equal sign).
    Instead of doing its best to ignore the entire block, the parser would simply
    reset and interpret the quoted tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The handling of tags that are not closed before the end of the file is equally
    fascinating. For example, the following snippet will prompt most browsers to interpret
    the *<i>* tag or ignore the entire string, but Internet Explorer and Opera use
    a different backtracking approach and will see *<b>* instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, Firefox versions prior to version 4 engaged in far-fetched reparsing
    whenever particular special tags, such as *<title>*, were not closed before the
    end of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The last two parsing quirks have interesting security consequences in any scenario
    where the attacker may be able to interrupt page load prematurely. Even if the
    markup is otherwise fairly well sanitized, the meaning of the document may change
    in a very unexpected way.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit and Implicit Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To further complicate the job of HTML parsing, some browsers exhibit behaviors
    that can be used to conditionally skip some of the markup in a document. For example,
    in an attempt to help novice users of Microsoft’s Active Server Pages development
    platform, Internet Explorer treats *<% ... %>* blocks as a completely nonstandard
    comment, hiding any markup between these two character sequences. Another Internet
    Explorer-specific feature is explicit conditional expressions interpreted by the
    parser and smuggled inside standard HTML comment blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Many other quirks of this type are related to the idiosyncrasies of SGML and
    XML. For example, due to the comment-handling behavior mentioned earlier in an
    aside, browsers disagree on how to parse !- and ?-directives (such as *<!DOCTYPE>*
    or *<?xml>*), whether to allow XML-style CDATA blocks in non-XHTML modes, and
    on what precedence to give to overlapping special parsing mode tags (such as “*<style><!--
    </style> -->*”).
  prefs: []
  type: TYPE_NORMAL
- en: HTML Parsing Survival Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The set of parsing behaviors discussed in the previous sections is by no means
    exhaustive. In fact, an entire book has been written on this topic: Inquisitive
    readers are advised to grab *Web Application Obfuscation* (Syngress, 2011) by
    Mario Heiderich, Eduardo Alberto Vela Nava, Gareth Heyes, and David Lindsay—and
    then weep about the fate of humanity. The bottom line is that building HTML filters
    that try to block known dangerous patterns, and allow the remaining markup as
    is, is simply not feasible.'
  prefs: []
  type: TYPE_NORMAL
- en: The only reasonable approach to tag sanitization is to employ a realistic parser
    to translate the input document into a hierarchical in-memory document tree, and
    then scrub this representation for all unrecognized tags and parameters, as well
    as any undesirable tag/parameter/value configurations. At that point, the tree
    can be carefully reserialized into a well-formed, well-escaped HTML that will
    not flex any of the error correction muscles in the browser itself. Many developers
    think that a simpler design should be possible, but eventually they discover the
    reality the hard way.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[26](#CHP-4-FN-2)]) The behavior exhibited by Opera is particularly sneaky:
    The Unicode whitespace is not recognized by many standard library functions used
    in server-side HTML sanitizers, such as *isspace(...)* in libc. This increases
    the risk of implementation glitches.'
  prefs: []
  type: TYPE_NORMAL
- en: Entity Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s talk about character encoding again. As noted on the first pages of this
    chapter, certain reserved characters are generally unsafe inside text nodes and
    tag parameter values, and they will often lead to outright syntax errors in XHTML.
    In order to allow such characters to be used safely (and to allow a convenient
    way to embed high-bit text), a simple ampersand-prefixed, semicolon-terminated
    encoding scheme, known as entity encoding, is available to developers.
  prefs: []
  type: TYPE_NORMAL
- en: The most familiar use of this encoding method is the inclusion of certain predefined,
    named entities. Only a handful of these are specified for XML, but several hundred
    more are scattered in HTML specifications and supported by all modern browsers.
    In this approach, *&lt;* is used to insert a left angle bracket; *&gt;* substitutes
    a right angle bracket; *&amp;* replaces the ampersand itself; while, say, *&rarr;*
    is a nice Unicode arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In XHTML documents, additional named entities can be defined using the *<!ENTITY>*
    directive and made to resolve to internally defined strings or to the contents
    of an external file URL. (This last option is obviously unsafe if allowed when
    processing untrusted content; the resulting attack is sometimes called *External
    XML Entity*, or XXE for short.)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the named entities, it is also possible to insert an arbitrary
    ASCII or Unicode character using a decimal *&#number;* notation. In this case,
    *&#60;* maps to a left angle bracket; *&#62;* substitutes a right one; and *&#128569;*
    is, I kid you not, a Unicode 6.0 character named “smiling cat face with tears
    of joy.” Hexadecimal notation can also be used if the number is prefixed with
    “x”. In this variant, the left angle bracket becomes *&#x3c;*, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML parser recognizes entity encoding inside text nodes and parameter
    values and decodes it transparently when building an in-memory representation
    of the document tree. Therefore, the following two cases are functionally identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two examples, on the other hand, will not work as expected, as
    the encoding interferes with the structure of the tag itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The largely transparent behavior of entity encoding makes it important to correctly
    resolve it prior to making any security decisions about the contents of a document
    and, if applicable, to properly restore it in the sanitized output later on. To
    illustrate, the following syntax must be recognized as an absolute reference to
    a *javascript:* pseudo-URL and not to a cryptic fragment ID inside a relative
    resource named “./javascript&”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, even the simple task of recognizing and parsing HTML entities
    can be tricky. In traditional parsing, for example, entities may often be accepted
    even if the trailing semicolon is omitted, as long as the next character is not
    an alphanumeric. (In Firefox, dashes and periods are also accepted in entity names.)
    Numeric entities are even more problematic, as they may have an overlong notation
    with an arbitrary number of trailing zeros. Moreover, if the numerical value is
    higher than 232, the standard size of an integer on many computer architectures,
    the corresponding character may be computed incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers working with XHTML should be aware of a potential pitfall in that
    dialect, too. Although HTML entities are not recognized in most of the special
    parsing modes, XHTML differs from traditional HTML in that tags such as *<script>*
    and *<style>* do not automatically toggle a special parsing mode on their own.
    Instead, an explicit *<![CDATA[...]]>* block around any scripts or stylesheets
    is required to achieve a comparable effect. Therefore, the following snippet with
    an attacker-controlled string (otherwise scrubbed for angle brackets, quotes,
    backslashes, and newlines) is perfectly safe in HTML, but not in XHTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/HTML Integration Semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From [Chapter 3](ch03.html "Chapter 3. Hypertext Transfer Protocol"), we recall
    that HTTP headers may give new meaning to the entire response (*Location*, *Transfer-Encoding*,
    and so on), change the way the payload is presented (*Content-Type*, *Content-Disposition*),
    or affect the client-side environment in other, auxiliary ways (*Refresh*, *Set-Cookie*,
    *Cache-Control*, *Expires*, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: But what if an HTML document is delivered through a non-HTTP protocol or loaded
    from a local file? Clearly, in this case, there is no simple way to express or
    preserve this information. We can part with some of it easily, but parameters
    such as the MIME type or the character set are essential, and losing them forces
    browsers to improvise later on. (Consider, for example, that charsets such as
    UTF-7, UTF-16, and UTF-32 are not ASCII-compatible and, therefore, HTML documents
    can’t even be parsed without determining which of these transformations needs
    to be used.)
  prefs: []
  type: TYPE_NORMAL
- en: The security consequences of the browser-level heuristics used to detect character
    sets and document types will be explored in detail in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms"). Meanwhile, the problem of preserving protocol-level
    information within a document is somewhat awkwardly addressed by a special HTML
    directive, *<meta http-equiv=...>*. By the time the browser examines the markup,
    many content-handling decisions must have already been made, but some tweaks are
    still on the table; for example, it may be possible to adjust the charset to a
    generally compatible value or to specify *Refresh*, *Set-Cookie*, and caching
    directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration of permissible syntax, consider the following directive
    that, when appearing in an 8-bit ASCII document, will clarify for the browser
    that the charset of the document is UTF-8 and not, say, ISO-8859-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On the flip side, all of the following directives will fail, because at this
    point it is too late to switch to an incompatible UTF-32 encoding, change the
    document type to a video format, or execute a redirect instead of parsing the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Be mindful that when *http-equiv* values conflict with each other, or contradict
    the HTTP headers received from the server earlier on, their behavior is not consistent
    and should not be relied upon. For example, the first supported *charset=* value
    usually prevails (and HTTP headers have precedence over *<meta>* in this case),
    but with several conflicting *Refresh* values, the behavior is highly browser-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some browsers will attempt to speculatively extract <meta http-equiv> information
    before actually parsing the document, which may lead to embarrassing mistakes.
    For example, a security bug recently fixed in Firefox 4 caused the browser to
    interpret the following statement as a character set declaration: *<meta http-equiv="Refresh"
    content="10;http://www.example.com/charset=utf-7">*.^([[141](pr03.html#ftn.CHP-4-FT-6)])'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperlinking and Content Inclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important and security-relevant features of HTML is, predictably,
    the ability to link to and embed external content. HTTP-level features such as
    *Location* and *Refresh* aside, this can be accomplished in a couple of straightforward
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Plain Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following markup demonstrates the most familiar and most basic method for
    referencing external content from within a document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This hyperlink may point to any of the browser-recognized schemes, including
    pseudo-URLs (*data:*, *javascript:*, and so on) and protocols handled by external
    applications (such as *mailto:*). Clicking on the text (or any HTML elements)
    nested inside such a *<a href=...>* block will typically prompt the browser to
    navigate away from the linking document and go to the specified location, if meaningfully
    possible for the protocol used.
  prefs: []
  type: TYPE_NORMAL
- en: An optional *target* parameter may be used to target other windows or document
    views for navigation. The parameter must specify the name of the target view.
    If the name cannot be found, or if access is denied, the default behavior is typically
    to open a new window instead. The conditions in which access may be denied are
    the topic of [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules").
  prefs: []
  type: TYPE_NORMAL
- en: 'Four special target names can be used, too (as shown on the left of [Figure 4-1](ch04s05.html#predefined_targets_for_hyperlinks
    "Figure 4-1. Predefined targets for hyperlinks")): *_blank* always opens a brand-new
    window, *_parent* navigates a higher-level view that embeds the link-bearing document
    (if any), and *_top* always navigates the top-level browser window, no matter
    how many document embedding levels are in between. Oh, right, the fourth special
    target, *_self*, is identical to not specifying a value at all and exists for
    no reason whatsoever.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predefined targets for hyperlinks](httpatomoreillycomsourcenostarchimages950013.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. Predefined targets for hyperlinks
  prefs: []
  type: TYPE_NORMAL
- en: Forms and Form-Triggered Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An HTML form can be thought of as an information-gathering hyperlink: When
    the “submit” button is clicked, a dynamic request is constructed on the fly from
    the data collected via any number of input fields. Forms allow user input and
    files to be uploaded to the server, but in almost every other way, the result
    of submitting a form is similar to following a normal link.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple form markup may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The *action* parameter works like the *href* value used for normal links, with
    one minor difference: If the value is absent, the form will be submitted to the
    location of the current document, whereas any destination-free *<a>* links will
    simply not work at all. An optional *target* parameter may also be specified and
    will behave as outlined in the previous section.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unusually, unlike *<a>* tags, forms cannot be nested inside each other, and
    only the top-level *<form>* tag will remain operational in such a case.
  prefs: []
  type: TYPE_NORMAL
- en: When the *method* value is set to GET or is simply not present at all, all the
    nested field names and their current values will be escaped using the familiar
    percent-encoding scheme outlined in [Chapter 2](ch02.html "Chapter 2. It Starts
    with a URL"), but with two rather arbitrary differences. First, the space character
    (0x20) will be substituted with the plus sign, rather than encoded as “%20”. Second,
    following from this, any existing plus signs need to be encoded as “%2B”, or else
    they will be misinterpreted as spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encoded *name=value* pairs are then delimited with ampersands and combined
    into a single string, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The resulting value is inserted into the query part of the destination URL (replacing
    any existing contents of that section) and submitted to the server. The received
    response is then shown to the user in the targeted viewport.
  prefs: []
  type: TYPE_NORMAL
- en: The situation is a bit more complicated if the *method* parameter is set to
    POST. For that type of HTTP request, three data submission formats are available.
    In the default mode (referred to as *application/x-www-form-urlencoded*), the
    message is constructed the same way as for GET but is transmitted in the request
    payload instead, leaving the query string and all other parts of the destination
    URL intact.^([[27](#ftn.CHP-4-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: 'The existence of the second POST submission mode, triggered by specifying *enctype="text/plain"*
    on the *<form>* tag, is difficult to justify. In this mode, field names and values
    will not be percent encoded at all (but, depending on the browser, plus signs
    may be used to substitute for spaces), and a newline delimiter will be used in
    place of an ampersand. The resulting format is essentially useless, as it can’t
    be parsed unambiguously: Form-originating newlines and equal signs are indistinguishable
    from browser inserted ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last mode is triggered with *enctype="multipart/form-data"* and must be
    used whenever submitting user-selected files through a form (which is possible
    with a special *<input type="file">* tag). The resulting request body consists
    of a series of short MIME messages corresponding to every submitted field.^([[28](#ftn.CHP-4-FN-4)])
    These messages are delimited with a client-selected random, unique boundary token
    that should otherwise not appear in the encapsulated data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Despite the seemingly open-ended syntax of the tag, other request methods and
    submission formats are not supported by any browser, and this is unlikely to change.
    For a short while, the HTML5 standard tried to introduce PUT and DELETE methods
    in forms, but this proposal was quickly shot down.
  prefs: []
  type: TYPE_NORMAL
- en: Frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Frames are a form of markup that allows the contents of one HTML document to
    be displayed in a rectangular region of another, embedding page. Several framing
    tags are supported by modern browsers, but the most common way of achieving this
    goal is with a hassle-free and flexible inline frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In traditional HTML documents, this tag puts the parser in one of the special
    parsing modes, and all text between the opening and the closing tag will simply
    be ignored in frame-aware browsers. In legacy browsers that do not understand
    *<iframe>*, the markup between the opening and closing tags is processed normally,
    however, offering a decidedly low-budget, conditional rendering directive. This
    conditional behavior is commonly used to provide insightful advice such as “This
    page must be viewed in a browser that supports frames.”
  prefs: []
  type: TYPE_NORMAL
- en: The frame is a completely separate document view that in many aspects is identical
    to a new browser window. (It even enjoys its own JavaScript execution context.)
    Like browser windows, frames can be equipped with a *name* parameter and then
    targeted from *<a>* and *<form>* tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constraints on the *src* URL for framed content are roughly similar to
    the rules enforced on regular links. This includes the ability to point frames
    to javascript: or to load externally handled protocols that leave the frame empty
    and open the target application in a new process.'
  prefs: []
  type: TYPE_NORMAL
- en: Frames are of special interest to web security, as they allow almost unconstrained
    types of content originating from unrelated websites to be combined onto a single
    page. We will have a second look at the problems associated with this behavior
    in [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules").
  prefs: []
  type: TYPE_NORMAL
- en: Type-Specific Content Inclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to content-agnostic link navigation and document framing, HTML also
    provides multiple ways for a more lightweight inclusion of several predefined
    types of external content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Images**'
  prefs: []
  type: TYPE_NORMAL
- en: Image files can be retrieved and displayed on a page using *<img>* tags, via
    stylesheets, and through a legacy *background=* parameter on markup such as *<body>*
    or *<table>*.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular image type on the Internet is a lossy but very efficient JPEG
    file, followed by lossless and more featured (but slower) PNG. An increasingly
    obsolete lossless GIF format is also supported by every browser, and so is the
    rarely encountered and usually uncompressed Windows bitmap file (BMP). An increasing
    number of rendering engines support SVG, an XML-based vector graphics and animation
    format, too, but the inclusion of such images through the *<img>* tag is subject
    to additional restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: The list of recognized image types can be wrapped up with odds and ends such
    as Windows metafiles (WMF and EMF), Windows Media Photo (WDP and HDP), Windows
    icons (ICO), animated PNG (APNG), TIFF images, and—more recently—WebP. Browser
    support for these is far from universal, however.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cascading stylesheets**'
  prefs: []
  type: TYPE_NORMAL
- en: These text-based files can be loaded with a *<link rel=stylesheet href=...>*
    tag—even though *<style src=...>* would be a more intuitive choice—and may redefine
    the visual aspects of almost any other HTML tag within their parent document (and
    in some cases, even include embedded JavaScript). The syntax and function of CSS
    are the subject of [Chapter 5](ch05.html "Chapter 5. Cascading Style Sheets").
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of the appropriate *charset* value in the *Content-Type* header
    for the downloaded stylesheet, the encoding according to which this subresource
    will be interpreted can be specified by the including party through the *charset*
    parameter of the *<link>* tag.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scripts**'
  prefs: []
  type: TYPE_NORMAL
- en: Scripts are text-based programs included with *<script>* tags and are executed
    in a manner that gives them full control over the host document. The primary scripting
    language for the Web is JavaScript, although an embedded version of Visual Basic
    is also supported in Internet Explorer and can be used at will. [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts") takes an in-depth look at client-side scripts
    and their capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: As with CSS, in the absence of valid *Content-Type* data, the charset according
    to which the script is interpreted may be controlled by the including party.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plug-in content**'
  prefs: []
  type: TYPE_NORMAL
- en: This category spans miscellaneous binary files included with *<embed>* or *<object>*
    tags or via an obsolete, Java-specific *<applet>* tag. Browser plug-in content
    follows its own security rules, which are explored to some extent in [Chapter 8](ch08.html
    "Chapter 8. Content Rendering with Browser Plug-ins") and [Chapter 9](ch09.html
    "Chapter 9. Content Isolation Logic"). In many cases, it is safe to consider plug-in-supported
    content as equivalent to or more powerful than JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard permits certain types of browser-supported documents, such as *text/html*
    or *text/plain*, to be loaded through *<object>* tags, in which case they form
    a close equivalent of *<iframe>*. This functionality is not used in practice,
    and the rationale behind it is difficult to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other supplementary content**'
  prefs: []
  type: TYPE_NORMAL
- en: This category includes various rendering cues that may or may not be honored
    by the browser; they are most commonly provided through *<link>* directives. Examples
    include website icons (known as “favicons”), alternative versions of a page, and
    chapter navigation links.
  prefs: []
  type: TYPE_NORMAL
- en: Several other once-supported content inclusion methods, such as the *<bgsound>*
    tag for background music, were commonplace in the past but have fallen out of
    grace. On the other hand, as a part of HTML5, new tags such as *<video>* and *<audio>*
    are expected to gain popularity soon.
  prefs: []
  type: TYPE_NORMAL
- en: There is relatively little consistency in what URL schemes are accepted for
    type-specific content retrieval. It should be expected that protocols routed to
    external applications will be rejected, as they do not have a sensible meaning
    in this context, but beyond this, not many assumptions should be made. As a security
    precaution, most browsers will also reject scripting-related schemes when loading
    images and stylesheets, although Internet Explorer 6 and Opera do not follow this
    practice. As of this writing, *javascript:* URLs are also permitted on *<embed>*
    and *<applet>* tags in Firefox but not, for example, on *<img>*.
  prefs: []
  type: TYPE_NORMAL
- en: For almost all of the type-specific content inclusion methods, *Content-Type*
    and *Content-Disposition* headers provided by the server will typically be ignored
    (perhaps except for the *charset=* value), as may be the HTTP response code itself.
    It is best to assume that whenever the body of any server-provided resource is
    even vaguely recognizable as one of the data formats enumerated in this section,
    it may be interpreted as such.
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Cross-Site Request Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On all types of cross-domain navigation, the browser will transparently include
    any ambient credentials; consequently, to the server, a request legitimately originating
    from its own client-side code will appear roughly the same as a request originating
    from a rogue third-party site, and it may be granted the same privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that fail to account for this possibility when processing any sensitive,
    state-changing requests are said to be vulnerable to *cross-site request forgery*
    (*XSRF* or *CSRF*). This vulnerability can be mitigated in a number of ways, the
    most common of which is to include a secret user- and session-specific value on
    such requests (as an additional query parameter or a hidden form field). The attacker
    will not be able to obtain this value, as read access to cross-domain documents
    is restricted by the same-origin policy (see [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic")).
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: Good Engineering Hygiene for All HTML Documents
  prefs: []
  type: TYPE_NORMAL
- en: Always output consistent, valid, and browser-supported *Content-Type* and *charset*
    information to prevent the document from being interpreted contrary to your original
    intent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Generating HTML Documents with Attacker-Controlled Bits
  prefs: []
  type: TYPE_NORMAL
- en: This task is difficult to perform consistently across the entire web application,
    and it is one of the most significant sources of web application security flaws.
    Consider using context-sensitive auto-escaping frameworks, such as *JSilver* or
    *CTemplate*, to automate it. If that is not possible, read on.
  prefs: []
  type: TYPE_NORMAL
- en: '**User-supplied content in text body:** Always entity-encode “<”, “>”, and
    “&”. Note that certain other patterns may be dangerous in certain non-ASCII-compatible
    output encodings. If applicable, consult [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that some Unicode metacharacters (e.g., U+202E) alter the direction
    or flow of the subsequent text. It may be desirable to remove them in particularly
    sensitive uses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Tag-specific** style **and** on* **parameters:** Multiple levels of escaping
    are required. This practice is extremely error prone, meaning not really something
    to attempt. If it is absolutely unavoidable, review the cheat sheets in [Chapter 5](ch05.html
    "Chapter 5. Cascading Style Sheets") and [Chapter 6](ch06.html "Chapter 6. Browser-Side
    Scripts").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All other HTML parameter values:** Always use quotes around attacker-controlled
    input. Entity-encode “<”, “>”, “&”, and any stray quotes. Remember that some parameters
    require additional validation. For URLs, see the cheat sheet in [Chapter 2](ch02.html
    "Chapter 2. It Starts with a URL").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never attempt to blacklist known bad values in URLs or any other parameters;
    doing so will backfire and may lead to script execution flaws.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Special parsing modes (e.g.**, <script> **and** <style> **blocks):** For
    values appearing inside quoted strings, replace quote characters, backslash, “<”,
    “>”, and all nonprintable characters with language-appropriate escape codes. For
    values appearing outside strings, exercise extreme caution and allow only carefully
    validated, known, alphanumeric values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In XHTML mode, remember to wrap the entire script section in a CDATA block.
    Avoid cases that require multiple levels of encoding, such as building parameters
    to the JavaScript *eval(...)* function using attacker-supplied strings. Never
    place user-controlled data inside HTML comments, !-type or ?-type tags, and other
    nonessential or unusually parsed blocks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When Converting HTML to Plaintext
  prefs: []
  type: TYPE_NORMAL
- en: A common mistake is to strip only well-formed tags. Remember that all left-angle
    brackets must be removed, even if no matching right-angle bracket is found. To
    minimize the risk of errors, always entity-escape angle brackets and ampersands
    in the generated output, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Writing a Markup Filter for User Content
  prefs: []
  type: TYPE_NORMAL
- en: Read this chapter carefully. Use a reasonably robust HTML parser to build an
    in-memory document tree. Walk the tree, removing any unrecognized or unnecessary
    tags and parameters and scrubbing any undesirable tags/parameters/value combinations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When done, reserialize the document, making sure to apply proper escaping rules
    to parameter values and text content. (See the first tip on this cheat sheet.)
    Be aware of the impact of special parsing modes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because of the somewhat counterintuitive namespace interactions with JavaScript,
    do not allow *name* and *id* parameters on user-supplied markup—at least not without
    reading [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts") first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not attempt to sanitize an existing, serialized document in place. Doing
    so inevitably leads to security problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[27](#CHP-4-FN-3)]) This has the potential for confusion, as the same parameter
    may appear both in the query string and in the POST payload. There is no consistency
    in how various server-side web applications frameworks resolve this conflict.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[28](#CHP-4-FN-4)]) MIME (Multipurpose Internet Mail Extensions) is a data
    format intended for encapsulating and safely transmitting various types of documents
    in email messages. The format makes several unexpected appearances in the browser
    world. For example, *Content-Type* file format identifiers also have unambiguous
    MIME roots.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Cascading Style Sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the Web matured through the 1990s, website developers increasingly needed
    a consistent and flexible way to control the appearance of HTML documents; the
    collection of random, vendor-specific tag parameters available at the time simply
    would not do. After reviewing several competing proposals, W3C eventually settled
    on *Cascading Style Sheets (CSS)*, a fairly simple text-based page appearance
    description language proposed by Håkon Wium Lie.
  prefs: []
  type: TYPE_NORMAL
- en: The initial CSS level 1 specification saw the light of day by the end of 1996,^([[142](pr03.html#ftn.CHP-5-FT-1)])
    but further revisions of this document continued until 2008\. The initial draft
    of CSS level 2 followed in December 1998 and has yet to be finalized as of 2011\.
    The work on the most recent iteration, level 3, started in 2005 and also continues
    to this day. Although most of the individual features envisioned for CSS2 and
    CSS3 have been adopted by all modern browsers after years of trial and error,
    many subtle details vary significantly from one implementation to another, and
    the absence of a finalized standard likely contributes to this.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the differences from one browser to another, CSS is a very powerful
    tool. With only a couple of constraints, stylesheets permit almost every HTML
    tag to be scaled, positioned, and decorated nearly arbitrarily, thereby overcoming
    the constraints originally placed on it by the underlying markup language; in
    some implementations, JavaScript programs can be embedded in the CSS presentation
    directives as well. The job of placing user-controlled values inside stylesheets,
    or recoding any externally provided CSS, is therefore of great interest to web
    application security.
  prefs: []
  type: TYPE_NORMAL
- en: Basic CSS Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stylesheets can be placed in an HTML document in three ways: inlined globally
    for the entire document with a *<style>* block, retrieved from an external URL
    via the *<link rel=stylesheet>* directive, or attached to a specific tag using
    the *style* parameter. In addition, XML-based documents (including XHTML) may
    also leverage a little-known *<?xml-stylesheet href=... ?>* directive to achieve
    the same goal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two methods of inclusion require a fully qualified stylesheet consisting
    of any number of selectors (directives describing which HTML tags the following
    ruleset will apply to) followed by semicolon-delimited *name: value* rules between
    curly brackets. Here is a simple example of such syntax, defining the appearance
    of *<img>*, *<span>*, and *<div>* tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Selectors can reference a particular type of a tag (such as *img*), a period-prefixed
    name of a class of tags (for example, *.photos*, which will apply to all tags
    with an inline *class=photos* parameter), or a combination of both (*img.company_logo*).
    Selector suffixes such as *:hover* or *:visited* may also be used to make the
    selector match only under certain circumstances, such as when the mouse hovers
    over the content or when a particular displayed hyperlink has already been visited
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'So-called *complex selectors*^([[143](pr03.html#ftn.CHP-5-FT-2)]) are an interesting
    feature introduced in CSS2 and extended in CSS3\. They allow any given ruleset
    to apply only to tags with particular strings appearing in parameter values or
    that are positioned in a particular relation to other markup. One example of such
    a selector is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Oh, while we are at it: As evident in this example, C-style *`/*...*/`* comment
    blocks are permitted in CSS syntax anywhere outside a quoted string. On the flip
    side, *`//`*-style comments are not recognized at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Property Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the *{ ... }* block that follows a selector, as well as inside the *style*
    parameter attached to a specific tag, any number of *name: value* rules can be
    used to redefine almost every aspect of how the affected markup is displayed.
    Visibility, shape, color, screen position, rendering order, local or remote typeface,
    and even any additional text (*content* property supported on certain pseudo-classes)
    and mouse cursor shape are all up for grabs.^([[29](#ftn.CHP-5-FN-1)]) Simple
    types of automation, such as counters for numbered lists, are available through
    CSS rules as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Property values can be formatted as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raw text** This method is used chiefly to specify numerical values (with
    optional units), RGB vectors and named colors, and other predefined keywords (“absolute,”
    “left,” “center,” etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quoted strings** Single or double quotes should be placed around any nonkeyword
    values, but there is little consistency in how this rule is enforced. For example,
    quoting is not required around typeface names or certain uses of URLs, but it
    is necessary for the aforementioned *content* property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional notation** Two parameter-related pseudo-functions are mentioned
    in the original CSS specification: *rgb(...)*, for converting individual RGB color
    values into a single color code, and *url(...)*, required for URLs in most but
    not all contexts. On top of this, several more pseudo-functions have been rolled
    out in recent years, including *scale(...)*, *rotate(...)*, or *skew(...)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proprietary *expression(...)* function is also available in Internet Explorer;
    it permits JavaScript statements to be inserted within CSS. This function is one
    of the most important reasons why attacker-controlled stylesheets can be a grave
    security risk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@ Directives and XBL Bindings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to selectors and properties, several @-prefixed directives are recognized
    in stand-alone stylesheets. All of them modify the meaning of the stylesheet;
    for example, by specifying the namespace or the display media that the stylesheet
    should be applied to. But two special directives also affect the behavior of the
    parsing process. The first of these is *@charset*, which sets the charset of the
    current CSS block; the other is *@import*, which inserts an external file into
    the stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *@import* directive itself serves as a good example of the idiosyncrasies
    of CSS parsing; the parser views all of the following examples as equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In Firefox, external content directives, including JavaScript code, may be also
    loaded from an external source using the *-moz-binding* property, a vendor-specific
    way to weave XML Binding Language^([[144](pr03.html#ftn.CHP-5-FT-3)]) files (an
    obscure method of providing automation to XML content) into the document. There
    is some talk of supporting XBL in other browsers, too, at which point the name
    of the property would change and the XSS risk may or may not be addressed in some
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As can be expected, the handling of pseudo-URLs in *@import, url(...)* and other
    CSS-based content inclusion schemes is a potential security risk. While most current
    browsers do not accept scripting-related schemes in these contexts, Internet Explorer
    6 allows them without reservations, thereby creating a code injection vector if
    the URL is not validated carefully enough.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It follows from the discussion in the previous chapter that for any stylesheets
    inlined in HTML documents, HTML parsing is performed first and is completely independent
    of CSS syntax rules. Therefore, it is unsafe to place certain HTML syntax characters
    inside CSS properties, as in the following example, even when quoted properly.
    A common mistake is permitting this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We’ll discuss a way to encode problematic characters in stylesheets shortly,
    but first, let’s have a quick look at another very distinctive property of CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[29](#CHP-5-FN-1)]) The ability to redefine mouse cursors using an arbitrary
    bitmap has predictably resulted in some security bugs. An oversized cursor combined
    with script-based mouse position tracking could be used to obscure or replace
    important elements of the browser UI and trick the user into doing something dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Parser Resynchronization Risks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An undoubtedly HTML-inspired behavior that sets CSS apart from most other languages
    is that compliant parsers are expected to continue after encountering a syntax
    error and restart at the next matching curly bracket (some superficial nesting-level
    tracking is mandated by the spec). In particular, the following stylesheet snippet,
    despite being obviously malformed, will still apply the specified border style
    to all *<img>* tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This unusual behavior creates an opportunity to exploit parser incompatibilities
    in an interesting way: If there is any way to derail a particular CSS implementation
    with inputs that seem valid to other parsers, the resynchronization logic may
    cause the attacked browser to resume parsing at an incorrect location, such as
    in the middle of an attacker-supplied string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A naïve illustration of this issue may be Internet Explorer’s support for multiline
    string literals. In this browser, it is seemingly safe not to scrub CR and LF
    characters in user-supplied CSS strings, so some webmasters may allow it. Unfortunately,
    the same pattern will cause any other browser to resume at an unexpected offset
    and interpret the *evil_rule* ruleset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The support for multiline strings is a Microsoft-specific extension, and the
    aforementioned problem is easily fixed by avoiding such noncompliant syntax to
    begin with. Unfortunately, other desynchronization risks are introduced by the
    standard itself. For example, recall complex selectors: This CSS3 syntax makes
    no sense to pre-CSS3 parsers. In the following example, an older implementation
    may bail out after encountering an unexpected angle bracket and resume parsing
    from the attacker-supplied *evil_rule* instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The still-popular browser Internet Explorer 6 would be vulnerable to this trick.
  prefs: []
  type: TYPE_NORMAL
- en: Character Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make it possible to quote reserved or otherwise problematic characters inside
    strings, CSS offers an unorthodox escaping scheme: a backslash (\) followed by
    one to six hexadecimal digits. For example, according to this scheme, the letter
    *e* may be encoded as “\65”, “\065”, or “\000065”. Alas, only the last syntax,
    “\000065”, will be unambiguous if the next character happens to be a valid hexadecimal
    digit; encoding “teak” as “t\65ak” would not work as expected, because the escape
    sequence would be interpreted as “\65A”, an Arabic sign in the Unicode character
    map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this problem, the specification embraces an awkward compromise: A
    whitespace can follow an escape sequence and will be interpreted as a terminator,
    and then removed from the string (e.g., “t\65 ak”). Regrettably, more familiar
    and predictable fixed-length C-style escape sequences such as *\ x65* cannot be
    used instead.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the numerical escaping scheme, it is also possible to place a
    backslash in front of a character that is not a valid hexadecimal digit. In this
    case, the subsequent character will be treated as a literal. This mechanism is
    useful for encoding quote characters and the backslash itself, but it should not
    be used to escape HTML control characters such as angle brackets. The aforementioned
    precedence of HTML parsing over CSS parsing renders this approach inadequate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a bizarre twist, due to somewhat ambiguous guidance in the W3C drafts, many
    CSS parsers recognize arbitrary escape sequences in locations other than quote-enclosed
    strings. To add insult to injury, in Internet Explorer, the substitution of these
    sequences apparently takes place before the pseudo-function syntax is parsed,
    effectively making the following two examples equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Even more confusingly, in a misguided bid to maintain fault tolerance, Microsoft’s
    implementation does not recognize backslash escape codes inside *url(...)* values;
    this is, once more, to avoid hurting the feelings of users who type the wrong
    type of a slash when specifying a URL.
  prefs: []
  type: TYPE_NORMAL
- en: These and similar quirks make the detection of known dangerous CSS syntax extremely
    error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Loading Remote Stylesheets
  prefs: []
  type: TYPE_NORMAL
- en: You are linking the security of your site to the originating domain of the stylesheet.
    Even in browsers that do not support JavaScript expressions inside stylesheets,
    features such as conditional selectors and *url(...)* references can be used to
    exfiltrate portions of your site.^([[145](pr03.html#ftn.CHP-5-FT-4)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in doubt, make a local copy of the data instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On HTTPS sites, require stylesheets to be served over HTTPS as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Putting Attacker-Controlled Values into CSS
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings and URLs inside stand-alone blocks**. Always use quotes. Backslash-escape
    all control characters (0x00-0x1F), “\”, “<”, “>”, “{“, “}”, and quotes using
    numerical codes. It is also preferable to escape high-bit characters. For URLs,
    consult the cheat sheet in [Chapter 2](ch02.html "Chapter 2. It Starts with a
    URL") to avoid code injection vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings in** style **parameters**. Multiple levels of escaping are involved.
    The process is error prone, so do not attempt it unless absolutely necessary.
    If it is unavoidable, apply the above CSS escaping rules first and then apply
    HTML parameter encoding to the resulting string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonstring attributes**. Allow only whitelisted alphanumeric keywords and
    carefully validated numerical values. Do not attempt to reject known bad patterns
    instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Filtering User-Supplied CSS
  prefs: []
  type: TYPE_NORMAL
- en: Remove all content outside of functional rulesets. Do not preserve or generate
    user-controlled comment blocks, @-directives, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carefully validate selector syntax, permitting only alphanumerics; underscores;
    whitespaces; and correctly positioned colons, periods, and commas before “{”.
    Do not permit complex text-matching selectors; they are unsafe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse and validate every rule in the { ... } block. Permit only whitelisted
    properties with well-understood consequences and confirm that they take expected,
    known safe values. Note that strings passed to certain properties may sometimes
    be interpreted as URLs even in the absence of a *url(...)* wrapper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode every parameter value using the rules outlined earlier in this section.
    Bail out on any syntax abnormalities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that unless specifically prevented from doing so, CSS may position
    user content outside the intended drawing area or redefine the appearance of any
    part of the UI of your application. The safest way to avoid this problem is to
    display the untrusted content inside a separate frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Allowing User-Specified Class Values on HTML Markup
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that user-supplied content can’t reuse class names that are used for
    any part of the application UI. If a separate frame is not being used, it’s advisable
    to maintain separate namespace prefixes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 6. Browser-Side Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first browser scripting engine debuted in Netscape Navigator around 1995,
    thanks to the work of Brendan Eich. The integrated Mocha language, as it was originally
    called, gave web developers the ability to manipulate HTML documents, display
    simple, system-level dialogs, open and reposition browser windows, and use other
    basic types of client-side automation in a hassle-free way.
  prefs: []
  type: TYPE_NORMAL
- en: While iterating through beta releases, Netscape eventually renamed Mocha LiveScript,
    and after an awkward branding deal was struck with Sun Microsystems, JavaScript
    was chosen as the final name. The similarities between Brendan’s Mocha and Sun’s
    Java were few, but the Netscape Corporation bet that this odd marketing-driven
    marriage would secure JavaScript’s dominance in the more lucrative server world.
    It made this sentiment clear in a famously confusing 1995 press release that introduced
    the language to the world and immediately tried to tie it to an impressive range
    of random commercial products:^([[146](pr03.html#ftn.CHP-6-FT-1)])
  prefs: []
  type: TYPE_NORMAL
- en: '**Netscape and Sun Announce JavaScript, the Open, Cross-Platform Object Scripting
    Language for Enterprise Networks and the Internet**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[ . . . ]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Netscape Navigator Gold 2.0 enables developers to create and edit JavaScript
    scripts, while Netscape LiveWire enables JavaScript programs to be installed,
    run and managed on Netscape servers, both within the enterprise and across the
    Internet. Netscape LiveWire Pro adds support for JavaScript connectivity to high-performance
    relational databases from Illustra, Informix, Microsoft, Oracle and Sybase. Java
    and JavaScript support are being built into all Netscape products to provide a
    unified, front-to-back, client/server/tool environment for building and deploying
    live online applications.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Despite Netscape’s misplaced affection for Java, the value of JavaScript for
    client-side programming seemed clear, including to the competition. In 1996 Microsoft
    responded by shipping a near-verbatim copy of JavaScript in Internet Explorer
    3.0 along with a counterproposal of its own: a Visual Basic-derived language dubbed
    VBScript. Perhaps because it was late to the party, and perhaps because of VBScript’s
    clunkier syntax, Microsoft’s alternative failed to gain prominence or even any
    cross-browser support. In the end, JavaScript secured its position in the market,
    and in part due to Microsoft’s failure, no new scripting languages have been attempted
    in mainstream browsers since.'
  prefs: []
  type: TYPE_NORMAL
- en: Encouraged by the popularity of the JavaScript language, Netscape handed over
    some of the responsibility for maintaining it to an independent body, the European
    Computer Manufacturers Association (ECMA). The new overseers successfully released
    ECMAScript, 3rd edition in 1999^([[147](pr03.html#ftn.CHP-6-FT-2)]) but had substantially
    more difficulty moving forward from there. The 4th edition, an ambitious overhaul
    of the language, was eventually abandoned after several years of bickering between
    the vendors, and a scaled-down 5th edition,^([[148](pr03.html#ftn.CHP-6-FT-3)])
    published in 2009, still enjoys only limited (albeit steadily improving) browser
    support. The work on a new iteration, called “Harmony,” begun in 2008, still has
    not been finalized. Absent an evolving and widely embraced standard, vendor-specific
    extensions of the language are common, but they usually cause only pain.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Characteristics of JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a fairly simple language meant to be interpreted at runtime. It
    has vaguely C-influenced syntax (save for pointer arithmetic); a straightforward
    classless object model, said to be inspired by a little-known programming language
    named Self; automatic garbage collection; and weak, dynamic typing.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript as such has no built-in I/O mechanisms. In the browser, limited abilities
    to interact with the host environment are offered through a set of predefined
    methods and properties that map to native code inside the browser, but unlike
    what can be seen in many other programming languages, these interfaces are fairly
    limited and purpose built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the core features of JavaScript are fairly unremarkable and should
    be familiar to developers already experience with C, C++, or, to a lesser extent,
    Java. A simple JavaScript program might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Because it is beyond the scope of this book to provide a more detailed overview
    of the semantics of JavaScript, we’ll summarize only some of its more unique and
    security-relevant properties later in this chapter. For readers looking for a
    more systematic introduction to the language, Marijn Haverbeke’s *Eloquent JavaScript*
    (No Starch Press, 2011) is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: Script Processing Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every HTML document displayed in a browser—be it in a separate window or in
    a frame—is given a separate instance of the JavaScript execution environment,
    complete with an individual namespace for all global variables and functions created
    by the loaded scripts. All scripts executing in the context of a particular document
    share this common sandbox and can also interact with other contexts through browser-supplied
    APIs. Such cross-document interactions must be done in a very explicit way; accidental
    interference is unlikely. Superficially, script-isolation rules are reminiscent
    of the process-compartmentalization model in modern multitasking operating systems
    but a lot less inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a particular execution context, all encountered JavaScript blocks are
    processed individually and almost always in a well-defined order. Each code block
    must consist of any number of self-contained, well-formed syntax units and will
    be processed in three distinct, consequent steps: parsing, function resolution,
    and code execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parsing stage validates the syntax of the script block and, usually, converts
    it to an intermediate binary representation, which can be subsequently executed
    at a more reasonable speed. The code has no global effects until this step completes
    successfully. In case of syntax errors, the entire problematic block is abandoned,
    and the parser proceeds to the next available chunk of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the behavior of a compliant JavaScript parser, consider the following
    HTML snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to what developers schooled in C may be accustomed to, the above sequence
    is not equivalent to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because *<script>* blocks are not concatenated before parsing. Instead,
    the first script segment will simply cause a syntax error (an assignment with
    a missing right-hand value), resulting in the entire block being ignored and not
    reaching execution stage. The fact that the whole segment is abandoned before
    it can have any global side effects also means that the original example is not
    equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This sets JavaScript apart from many other scripting languages such as Bash,
    where the parsing stage is not separated from execution in such a strong way.
  prefs: []
  type: TYPE_NORMAL
- en: What will happen in the original example provided earlier in this section is
    that the first block will be ignored but the second one (*<script>2;</script>*)
    will be parsed properly. That second block will amount to a no-op when executed,
    however, because it uses a pure, numerical expression as a code statement.
  prefs: []
  type: TYPE_NORMAL
- en: Function Resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the parsing stage is completed successfully, the next step involves registering
    every named, global function that the parser found within the currently processed
    block. Past this point, each function found will be reachable from the subsequently
    executed code. Because of this extra pre-execution step, the following syntax
    will work flawlessly (contrary to what programmers may be accustomed to in C or
    C++, *hello_world()* will be registered before the first code statement—a call
    to said function—is executed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the modified example below will not have the desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This modified case will fail with a runtime error because individual blocks
    of code are not processed simultaneously but, rather, are looked at based on the
    order in which they are made available to the JavaScript engine. The block that
    defines *hello_world()* will not yet be parsed when the first block is already
    executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further complicate the picture, the mildly awkward global name resolution
    model outlined here applies only to functions, not to variable declarations. Variables
    are registered sequentially at execution time, in a way similar to other interpreted
    scripting languages. Consequently, the following code sample, which merely replaces
    our global *hello_world()* with an unnamed function assigned to a global variable,
    will not work as planned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the assignment to the *hello_world* variable will not be done
    by the time the *hello_world()* call is attempted.
  prefs: []
  type: TYPE_NORMAL
- en: Code Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once function resolution is completed, the JavaScript engine normally proceeds
    with the ordered execution of all statements outside of function blocks. The execution
    of a script may fail at this point due to an unhandled exception or for a couple
    of other, more esoteric reasons. If such an error is encountered, however, any
    resolved functions within the offending code block will remain callable, and any
    effects of the already executed code will persist in the current scripting context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exception recovery and several other JavaScript execution characteristics are
    illustrated by the following lengthy but interesting code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages950015.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try to follow this example on your own and see if you agree with the annotations
    provided on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'As should be evident from this exercise, any unexpected and unhandled exceptions
    have an unusual consequence: They may leave the application in an inconsistent
    but still potentially executable state. Because exceptions are meant to prevent
    error propagation caused by unanticipated errors, this design is odd—especially
    given that on many other fronts (such as the ban on *goto* statements), JavaScript
    exhibits a more fundamentalist stance.'
  prefs: []
  type: TYPE_NORMAL
- en: Execution Ordering Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to properly analyze the security properties of certain common web application
    design patterns, it is important to understand the JavaScript engine’s execution
    ordering and timing model. Thankfully, this model is remarkably sane.
  prefs: []
  type: TYPE_NORMAL
- en: Virtually all JavaScript living within a particular execution context is executed
    synchronously. The code can’t be reentered due to an external event while it is
    still executing, and there is no support for threads that would be able to simultaneously
    modify any shared memory. While the execution engine is busy, the processing of
    events, timers, page navigation requests, and so on, is postponed; in most cases,
    the entire browser, or at least the HTML renderer, will also remain largely unresponsive.
    Only once the execution stops and the scripting engine enters an idle state will
    the processing of queued events resume. At this point, the JavaScript code may
    be entered again.
  prefs: []
  type: TYPE_NORMAL
- en: Further, JavaScript offers no *sleep(...)* or *pause(...)* function to temporarily
    release the CPU and later resume execution from the same location. Instead, if
    a programmer desires to postpone the execution of a script, it is necessary to
    register a timer to initiate a new execution flow later on. This flow will need
    to start at the beginning of a specified handler function (or at the beginning
    of an ad hoc, self-contained snippet of code provided when setting up a timer).
    Although these design decisions can be annoying, they substantially reduce the
    risk of race conditions in the resulting code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several probably unintentional loopholes in this synchronous execution
    model. One of them is the possibility of code execution while the execution of
    another piece of JavaScript is temporarily suspended after calling *alert(...)*
    or *showModalDialog(...)*. Such corner cases do not come into play very often,
    though.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disruptive, browser-blocking behavior of busy JavaScript loops requires
    the implementation of some mitigation on the browser level. We will explore these
    mitigations in detail in [Chapter 14](ch14.html "Chapter 14. Dealing with Rogue
    Scripts"). For now, suffice it to say that they have another highly unusual consequence:
    Any endless loop may, in fact, terminate, in a fashion similar to throwing an
    unhandled exception. The engine will then return to the idle state but will remain
    operational, the offending code will remain callable, and all timers and event
    handlers will stay in place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When triggered on purpose by the attacker, the ability to unexpectedly terminate
    the execution of CPU-intensive code may put the application in an inconsistent
    state by aborting an operation that the author expects to always complete successfully.
    And that’s not all: Another, closely related consequence of these semantics should
    become evident in [JavaScript Object Notation and Other Data Serializations](ch06.html#javascript_object_notation_and_other_dat
    "JavaScript Object Notation and Other Data Serializations") in [JavaScript Object
    Notation and Other Data Serializations](ch06.html#javascript_object_notation_and_other_dat
    "JavaScript Object Notation and Other Data Serializations").'
  prefs: []
  type: TYPE_NORMAL
- en: Code and Object Inspection Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript language has a rudimentary provision for inspecting the decompiled
    source code of any nonnative functions, simply by invoking the *toString()* or
    *toSource()* method on any function that the developer wishes to examine. Beyond
    that capability, opportunities to inspect the flow of programs are limited. Applications
    may leverage access to the in-memory representation of their host document and
    look up all inlined *<script>* blocks, but there is no direct visibility into
    any remotely loaded or dynamically generated code. Some insight into the call
    stack may also be gained through a nonstandard *caller* property, but there is
    also no way to tell which line of code is being currently executed or which one
    is coming up next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to dynamically create new JavaScript code is a more prominent part
    of the language. It is possible to instruct the engine to synchronously interpret
    strings passed to the built-in *eval(...)* function. For example, this will display
    an alert dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Syntax errors in any input text provided to *eval(...)* will cause this function
    to throw an exception. Similarly, if parsing succeeds, any unhandled exceptions
    thrown by the interpreted code will be passed down to the caller. Finally, in
    the absence of syntax errors or runtime problems, the value of the last statement
    evaluated by the engine while executing the supplied code will be used as the
    return value of *eval(...)* itself.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this function, other browser-level mechanisms can be leveraged
    to schedule deferred parsing and execution of new JavaScript blocks once the execution
    engine returns to the idle state. Examples of such mechanisms include timers (*setTimeout*,
    *setInterval*), event handlers (*onclick*, *onload*, and so on), and interfaces
    to the HTML parser itself (*innerHTML*, *document.write(...)*, and such).
  prefs: []
  type: TYPE_NORMAL
- en: Whereas the ability to inspect the code is somewhat underhanded, runtime object
    introspection capabilities are well developed in JavaScript. Applications are
    permitted to enumerate almost any object method or property using simple *for
    ... in* or *for each ... in* iterators and can leverage operators such as *typeof*,
    *instanceof*, or “strictly equals” (===) and properties such as *length* to gain
    additional insight into the identity of every discovered item.
  prefs: []
  type: TYPE_NORMAL
- en: All of the foregoing features make it largely impossible for scripts running
    in the same context to keep secrets from each other. The functionality also makes
    it more difficult to keep secrets across document contexts, a problem that browser
    vendors had to combat for a very long time—and that, as you’ll learn in [Chapter 11](ch11.html
    "Chapter 11. Life Outside Same-Origin Rules"), is still not completely a thing
    of the past.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Runtime Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the relative simplicity of the JavaScript language, executed scripts
    have many unusual ways of profoundly manipulating the behavior of their own JavaScript
    sandbox. In some rare cases, these behaviors can impact other documents, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Built-Ins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the more unusual tools at the disposal of a rogue script is the ability
    to delete, overwrite, or shadow most of the built-in JavaScript functions and
    virtually all browser-supplied I/O methods. For example, consider the behavior
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: And this is just where the fun begins. In Chrome, Safari, and Opera, it is possible
    to subsequently remove the *eval(...)* function altogether, using the *delete*
    operator. Confusingly, attempting the same in Firefox will restore the original
    built-in function, undoing the effect of the original override. Finally, in Internet
    Explorer, the deletion attempt will generate a belated exception that seems to
    serve no meaningful purpose at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further along these lines, almost every object, including built-ins such as
    *String* or *Array*, has a freely modifiable prototype. This prototype is a master
    object from which all existing and future object instances derive their methods
    and properties (forming a crude equivalent of class inheritance present in more
    fully featured programming languages). The ability to tamper with object prototypes
    can cause rather counterintuitive behavior of newly created objects, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Setters and Getters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More interesting features of the object model available in contemporary dialects
    of JavaScript are *setters* and *getters*: ways to supply custom code that handles
    reading or setting properties of the host object. Although not as powerful as
    operator overloading in C++, these can be used to make existing objects or object
    prototypes behave in even more confusing ways. In the following snippet, the acts
    of setting the object property and reading it back later on are both subverted
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setters and getters were initially developed as a vendor extension but are now
    standardized under ECMAScript edition 5\. The feature is available in all modern
    browsers but not in Internet Explorer 6 or 7.
  prefs: []
  type: TYPE_NORMAL
- en: Impact on Potential Uses of the Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a result of the techniques discussed in the previous two sections, a script
    executing inside a context once tainted by any other untrusted content has no
    reliable way to examine its operating environment or take corrective action; even
    the behavior of simple conditional expressions or loops can’t necessarily be relied
    upon. The proposed enhancements to the language are likely to make the picture
    even more complicated. For example, the failed proposal for ECMAScript edition
    4 featured full-fledged operator overloading, and this idea may return.
  prefs: []
  type: TYPE_NORMAL
- en: Even more interestingly, these design decisions also make it difficult to inspect
    any execution context from outside the per-page sandbox. For example, blind reliance
    on the reliability of the *location* object of a potentially hostile document
    has led to a fair number of security vulnerabilities in browser plug-ins, JavaScript-based
    extensions, and several classes of client-side web application security features.
    These vulnerabilities eventually resulted in the development of browser-level
    workarounds designed to partially protect this specific object against sabotage,
    but most of the remaining object hierarchy is up for grabs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability to tamper with one’s own execution context is limited in the “strict”
    mode of ECMAScript edition 5\. This mode is not fully supported in any browser
    as of this writing, however, and is meant to be an opt-in, discretionary mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Object Notation and Other Data Serializations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very important syntax structure in JavaScript is its very compact and convenient
    in-place object serialization, known as JavaScript Object Notation, or JSON (RFC
    4627^([[149](pr03.html#ftn.CHP-6-FT-4)])). This data format relies on overloading
    the meaning of the curly bracket symbol ({). When such a brace is used to open
    a fully qualified statement, it is treated in a familiar way, as the start of
    a nested code block. In an expression, however, it is assumed to be the beginning
    of a serialized object. The following example illustrates a correct use of this
    syntax and will display a simple prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to the unambiguous serializations of numbers, strings, or arrays,
    the overloading of the curly bracket means that JSON blocks will not be recognized
    properly when used as a standalone statement. This may seem insignificant, but
    it is an advantage: It prevents any server-supplied responses that comply with
    this syntax from being meaningfully included across domains via *<script src=...>*.^([[30](#ftn.CHP-6-FN-1)])
    The listing that follows will cause a syntax error, ostensibly due to an illegal
    quote (![](httpatomoreillycomsourcenostarchimages950001.png)) in what the interpreter
    attempts to treat as a code label,^([[31](#ftn.CHP-6-FN-2)]) and will have no
    measurable side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The inability to include JSON via *<script src=...>* is an interesting property,
    but it is also a fragile one. In particular, wrapping the response in parentheses
    or square brackets, or removing quotes around the labels, will render the syntax
    readily executable in a standalone block, which may have observable side effects.
    Given the rapidly evolving syntax of JavaScript, it is not wise to bank on this
    particular code layout always causing a parsing error in the years to come. That
    said, in many noncritical uses, this level of assurance will be good enough to
    rely on as a simple security mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once retrieved through a channel such as *XMLHttpRequest*, the JSON serialization
    can be quickly and effortlessly converted to an in-memory object using the *JSON.parse(...)*
    function in all common browsers, other than Internet Explorer. Unfortunately,
    for purposes of compatibility with Internet Explorer, and sometimes just out of
    custom, many developers resort to an equally fast yet far more dangerous hack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this syntax is that the *eval(...)* function used to compute
    the “value” of a JSON expression permits not only pure JSON inputs but any other
    well-formed JavaScript syntax to appear in the string. This can have undesirable,
    global side effects. For example, the function call embedded in this faux JSON
    response will execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This behavior creates an additional burden on web developers to accept JSON
    payloads only from trusted sources and always to correctly escape feeds produced
    by their own server-side code. Predictably, failure to do so has contributed a
    fair number of application-level security bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The difficulty of getting *eval(...)* right is embodied by the JSON specification
    (RFC 4627) itself: The allegedly secure parser implementation included in that
    document unintentionally permits rogue JSON responses to freely increment or decrement
    any program variables that happen to consist solely of the letters “a”, “e”, “f”,
    “l”, “n”, “r”, “s”, “t”, “u”, plus digits; that’s enough to spell “unsafe” and
    about 1,000 other common English words. The faulty regular expression legitimized
    in this RFC appears all over the Internet and will continue to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to their ease of use, JSON serializations are ubiquitous in server-to-client
    communications across all modern web applications. The format is rivaled only
    by other, less secure string or array serializations and by JSONP.^([[32](#ftn.CHP-6-FN-3)])
    All of these schemes are incompatible with *JSON.parse(...)*, however, and must
    rely on unsafe *eval(...)* to be converted to in-memory data. The other property
    of these formats is that, unlike proper JSON, they will parse properly when loaded
    with *<script src=...>* on a third-party page. This property is advantageous in
    some rare cases, but mostly it just constitutes an unobvious risk. For example,
    consider that even though loading an array serialization via a *<script>* tag
    normally has no measurable side effects, an attacker could, at least until recent
    improvements, modify the setters on an *Array* prototype to retrieve the supplied
    data. A common but often insufficient practice of prefixing a response with a
    *while(1);* loop to prevent this attack can backfire in interesting ways if you
    recall the possibility of endless loops terminating in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: E4X and Other Syntax Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like HTML, JavaScript is quickly evolving. Some of the changes made to it over
    the years have been fairly radical and may end up turning text formats that were
    previously rejected by the parser into a valid JavaScript code. This, in turn,
    may lead to unexpected data disclosure, especially in conjunction with the extensive
    code and object inspection and modification capabilities discussed earlier in
    this chapter—and the ability to use *<script src=...>* to load cross-domain code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more notable examples of this trend is *ECMAScript for XML* (E4X),^([[150](pr03.html#ftn.CHP-6-FT-5)])
    a completely unnecessary but elegant plan to incorporate XML syntax directly into
    JavaScript as an alternative to JSON-style serializations. In any E4X-compatible
    engine, such as Firefox, the following two snippets of code would be roughly equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The unexpected consequence of E4X is that, under this regime, any well-formed
    XML document suddenly becomes a valid *<script src=...>* target that will parse
    as an expression-as-statement block. Moreover, if an attacker can strategically
    place “{” and “}” characters on an included page, or alter the setters for the
    right object prototype, the attacker may be able to extract user-specific text
    displayed in an unrelated document. The following example illustrates the risk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages950017.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To their credit, after several years of living with the flaw, Firefox developers
    decided to disallow any E4X statements that span the entirety of any parsed script,
    partly closing this loophole. Nevertheless, the fluidity of the language is evident,
    and it casts some doubt on the robustness of using of JSON responses as a defense
    against cross-domain script inclusion. The moment a third meaning is given to
    the “{” symbol or quotes-as-labels start having a purpose, the security of this
    server-to-client data exchange format will be substantially degraded. Be sure
    to plan ahead.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#CHP-6-FN-1)]) Unlike most other content inclusion schemes available
    to scripts (such as *XMLHttpRequest*), *<script src=...>* is not subject to the
    cross-domain security restrictions outlined in [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic"). Therefore, the mechanism is a security risk whenever ambient
    authority credentials, such as cookies, are used by the server to dynamically
    generate user-specific JavaScript code. This class of vulnerabilities is unimaginatively
    referred to as *cross-site script inclusion*, or *XSSI*.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[31](#CHP-6-FN-2)]) Somewhat unexpectedly, JavaScript supports C-style labeled
    statements, such as *my_label: alert(“Hi mom!”)*. This is interesting because
    for philosophical reasons, the language has no support for *goto* and, therefore,
    such a label can’t be meaningfully referenced in most cases.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#CHP-6-FN-3)]) JSONP literally means “JSON with padding” and stands
    for JSON serialization wrapped in some supplementary code that turns it into a
    valid, standalone JavaScript statement for convenience. Common examples may include
    a function call (e.g., *callback_function({ ...JSON data... })*) or a variable
    assignment (*var return_value = { ...JSON data... }*).
  prefs: []
  type: TYPE_NORMAL
- en: Standard Object Hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript execution environment is structured around an implicit root object,
    which is used as the default namespace for all global variables and functions
    created by the program. In addition to a handful of language-mandated built-ins,
    this namespace is prepopulated with a hierarchy of functions that implement input
    and output capabilities in the browser environment. These capabilities include
    manipulating browser windows (*open(...)*, *close()*, *moveTo(...)*, *resizeTo(...)*,
    *focus()*, *blur()*, and such); configuring JavaScript timers (*setTimeout(...)*,
    *setInterval(...)*, and so on); displaying various UI prompts (*alert(...)*, *prompt(...)*,
    *print(...)*); and performing a variety of other vendor-specific and frequently
    risky functions, such as accessing the system clipboard, creating bookmarks, or
    changing the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level object also provides JavaScript references to root objects belonging
    to related contexts, including the parent frame (*parent*), the top-level document
    in the current browser window (*top*), the window that created the current one
    (*opener*), and all subframes of the current document (*frames[]*). Several circular
    references to the current root object itself are also included—say, *window* and
    *self*. In browsers other than Firefox, elements with specified *id* or *name*
    parameters will be automatically registered in this namespace, too, permitting
    syntax such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, in case of any name conflicts with JavaScript variables or built-ins,
    *id* data will not be given precedence, largely avoiding any possible interference
    between otherwise sanitized, user-supplied markup and in-document scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the top-level hierarchy consists primarily of a couple of
    distinguished children objects that group browser API features by theme:'
  prefs: []
  type: TYPE_NORMAL
- en: location **object**
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a collection of properties and methods that allow the program to read
    the URL of the current document or initiate navigation to a new one. This last
    action, in most cases, is lethal to the caller: The current scripting context
    will be destroyed and replaced with a new one shortly thereafter. Updating just
    the fragment identifier (*location.hash*) is an exception to this rule, as explained
    in [Chapter 2](ch02.html "Chapter 2. It Starts with a URL").'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when using *location.** data to construct new strings (HTML and JavaScript
    code in particular), it is unsafe to assume that it is escaped in any specific
    way. Internet Explorer will keep angle brackets as is in the *location.search*
    property (which corresponds to the URL query string). Chrome, on the other hand,
    will escape them, but it will glance over double quotes (`"`) or backslashes.
    Most browsers also do not apply any escaping to the fragment ID.
  prefs: []
  type: TYPE_NORMAL
- en: history **object**
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchy provides several infrequently used methods for moving through
    the per-window browsing history, in a manner similar to clicking the “back” and
    “forward” buttons in the browser UI. It is not possible to directly examine any
    of the previously visited URLs; the only option is to navigate to the history
    blindly by providing numerical offsets, such as *history.go(-2)*. (Some recent
    additions to this hierarchy will be discussed in [Chapter 17](ch17.html "Chapter 17. Other
    Browser Mechanisms of Note").)
  prefs: []
  type: TYPE_NORMAL
- en: screen **object**
  prefs: []
  type: TYPE_NORMAL
- en: A basic API for examining the dimensions of the screen and the browser window,
    monitor DPI, color depth, and so on. This is offered to help websites optimize
    the presentation of a page for a particular display device.
  prefs: []
  type: TYPE_NORMAL
- en: navigator **object**
  prefs: []
  type: TYPE_NORMAL
- en: An interface for querying the browser version, the underlying operating system,
    and the list of installed plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: document **object**
  prefs: []
  type: TYPE_NORMAL
- en: By far the most complex of the hierarchies, this is a doorway to the Document
    Object Model^([[151](pr03.html#ftn.CHP-6-FT-6)]) of the current page; we will
    have a look at this model in the following section. A couple of functions not
    related to document structure also appear under the *document* hierarchy, usually
    due to arbitrary design decisions. Examples include *document.cookie* for manipulating
    cookies, *document.write(...)* for appending HTML to the current page, and *document.execCommand(...)*
    for performing certain WYSIWYG editing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interestingly, the information available through the *navigator* and *screen*
    objects is sufficient to uniquely fingerprint many users with a high degree of
    confidence. This long-known property is emphatically demonstrated by *Panopticlick*,
    a project of the Electronic Frontier Foundation: [https://panopticlick.eff.org/](https://panopticlick.eff.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Several other language-mandated objects offer simple string-processing or arithmetic
    capabilities. For example, *Math.random()* implements an unsafe, predictable pseudo-random
    number generator (a safe PRNG alternative is unfortunately not available at this
    time in most browsers^([[33](#ftn.CHP-6-FN-4)])), while *String.fromCharCode()*
    can be used to convert numerical values into Unicode strings. In privileged execution
    contexts, which are not reachable by normal web applications, a fair number of
    other task-specific objects will also appear.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When accessing any of the browser-supplied objects, it is important to remember
    that while JavaScript does not use NUL-terminated ASCIZ strings, the underlying
    browser (written in C or C++) sometimes will. Therefore, the outcomes of assigning
    NUL-containing strings to various DOM properties, or supplying them to native
    functions, may be unpredictable and inconsistent. Almost all browsers truncate
    assignments to *location.** at NUL, but only some engines will do the same when
    dealing with DOM **.innerHTML*.
  prefs: []
  type: TYPE_NORMAL
- en: The Document Object Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Document Object Model, accessible through the *document* hierarchy, provides
    a structured, in-memory representation of the current document as mapped out by
    the HTML parser. The resulting object tree exposes all HTML elements on the page,
    their tag-specific methods and properties, and the associated CSS data. This representation,
    not the original HTML source, is used by the browser to render and update the
    currently displayed document.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript can access the DOM in a very straightforward way, similarly to any
    normal objects. For example, the following snippet will go to the fifth tag within
    the document’s *<body>* block, look up the first nested subtag, and set that element’s
    CSS color to red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid having to waddle through the DOM tree in order to get to a particular
    deeply nested element, the browser provides several documentwide lookup functions,
    such as *getElementById(...)* and *getElementsByTagName(...)*, as well as partly
    redundant grouping mechanisms such as *frames[]*, *images[]*, or *forms[]*. These
    features permit syntax such as the following two lines of code, both of which
    directly reference an element no matter where in the document hierarchy it happens
    to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'For legacy reasons, the names of certain HTML elements (*<img>*, *<form>*,
    *<embed>*, *<object>*, and *<applet>*) are also directly mapped to the *document*
    namespace, as illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in the more reasonable case of *name* and *id* mapping in the global
    namespace (see previous section), such *document* entries may clobber built-in
    functions and objects such as *getElementById* or *body*. Therefore, permitting
    user-specified tag names, for example for the purpose of constructing forms, can
    be unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to providing access to an abstract representation of the document,
    many DOM nodes may expose properties such as *innerHTML* and *outerHTML*, which
    permit a portion of the document tree to be read back as a well-formed, serialized
    HTML string. Interestingly, the same property can be written to in order to replace
    any portion of the DOM tree with the result of parsing a script-supplied snippet
    of HTML. One example of that last use is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Every assignment to *innerHTML* must involve a well-formed and self-contained
    block of HTML that does not alter the document hierarchy outside the substituted
    fragment. If this condition is not met, the input will be coerced to a well-formed
    syntax before the substitution takes place. Therefore, the following example will
    not work as expected; that is, it will not display “Hi mom!” in bold and will
    not put the remainder of the document in italics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, each of these two assignments will be processed and corrected individually,
    resulting in a behavior equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the *innerHTML* mechanism should be used with
    extreme caution. In addition to being inherently prone to markup injection if
    proper HTML escaping is not observed, browser implementations of the DOM-to-HTML
    serialization algorithms are often imperfect. A recent (now fixed) example of
    such a problem in WebKit^([[152](pr03.html#ftn.CHP-6-FT-7)]) is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the confusion over the semantics of *<textarea>*, this seemingly
    unambiguous input markup, when parsed to a DOM tree and then accessed through
    *innerHTML*, would be incorrectly read back as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In such a situation, even performing a no-op assignment of this serialization
    (such as *some_element.innerHTML += ""*) would lead to unexpected script injection.
    Similar problems tend to plague other browsers, too. For example, Internet Explorer
    developers working on the *innerHTML* code were unaware that MSHTML recognizes
    backticks (`) as quote characters and so ended up handling them incorrectly. In
    their implementation, the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'would be reserialized as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Individual bugs aside, the situation with *innerHTML* is pretty dire: Section
    10.3 of the current draft of HTML5 simply acknowledges that certain script-created
    DOM structures are completely impossible to serialize to HTML and does not require
    browsers to behave sensibly in such a case. *Caveat emptor!*'
  prefs: []
  type: TYPE_NORMAL
- en: Access to Other Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scripts may come into possession of object handles that point to the root hierarchy
    of another scripting context. For example, by default, every context can readily
    reference *parent*, *top*, *opener*, and *frames[]*, all supplied to it in the
    top-level object. Calling the *window.open(...)* function to create a new window
    will also return a reference, and so will an attempt to look up an existing named
    window using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the program holds a handle pointing to another scripting context, it may
    attempt to interact with that context, subject to security checks discussed in
    [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic"). An example of a simple
    interaction might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In the absence of a valid handle, JavaScript-level interaction with an unrelated
    document should not be possible. In particular, there is no way to look up unnamed
    windows opened in completely separate navigation flows, at least until their name
    is explicitly set by one of the visited pages (the *window.name* property permits
    this).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[33](#CHP-6-FN-4)]) There are a recently added *window.crypto.getRandomValues(...)*
    API in Chrome and a currently nonoperational *window.crypto.random(...)* API in
    Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Script Character Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript engines support several familiar, backslash-based string-encoding
    methods that can be employed to escape quote characters, HTML markup, and other
    problematic bits in the embedded text. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'C-style shorthand notation for certain control characters: *\b* for backspace,
    *\t* for horizontal tab, *\v* for vertical tab, *\f* for form feed, *\r* for CR,
    and *\n* for LF. This exact set of escape codes is recognized by both ECMAScript
    and the JSON RFC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three-digit, zero-padded, 8-bit octal character codes with no prefix (such as
    “\145” instead of “e”). This C-inspired syntax is not a part of ECMAScript but
    is in practice supported by all scripting engines, both in normal code and in
    *JSON.parse(...)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-digit, zero-padded, 8-bit hexadecimal character codes, prefixed with “x”
    (“e” becomes “\x65”). Again, this scheme is not endorsed by ECMAScript or RFC
    4627, but having its roots in the C language, it is widely supported in practice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four-digit, zero-padded, 16-bit hexadecimal Unicode values, prefixed with “u”
    (“e” turns into “\u0065”). This format is sanctioned by ECMAScript and RFC 4627
    and is supported by all modern browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A backslash followed by any character other than an octal digit; “b”, “t”, “v”,
    “f”, “r,” or “n” characters used for other predefined escape sequences; and “x”
    or “u”. In this scheme, the subsequent character will be treated as a literal.
    ECMAScript permits this scheme to be used to escape only quotes and the backslash
    character itself, but in practice, any other value is accepted as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach is somewhat error prone, and as in the case of CSS, it should
    not be used to escape angle brackets and other HTML syntax delimiters. This is
    because JavaScript parsing takes place after HTML parsing, and the backslash prefix
    will be not treated in any special way by the HTML parser itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Somewhat inexplicably, Internet Explorer does not recognize the vertical tab
    (“\v”) shorthand, thereby creating one of the more convenient (but very naughty!)
    ways to test for that particular browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Surprisingly, the Unicode-based escaping method (but not the other ones) is
    also recognized outside strings. Although the idea seems arbitrary, the behavior
    is a bit more sensible than with CSS: Escape codes can be used only in identifiers,
    and they will not work as a substitute for any syntax-sensitive symbols. Therefore,
    the following is possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, any attempt to substitute the parentheses or quotes in a
    similar fashion would fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike in some C or C++ implementations, stray multiline string literals are
    not tolerated by any JavaScript engine. That said, despite a strongly worded prohibition
    in ECMAScript specs, there is one exception: A lone backslash at the end of a
    line may be used to join multiline literals seamlessly. This behavior is illustrated
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Code Inclusion Modes and Nesting Risks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As should be evident from the earlier discussions in this chapter, there are
    several ways to execute scripts in the context of the current page. It is probably
    useful to enumerate some of the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline *<script>* blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote scripts loaded with *<script src=...>*^([[34](#ftn.CHP-6-FN-5)])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*javascript:* URLs in various HTML parameters and in CSS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS *expression(...)* syntax and XBL bindings in certain browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers (*onload*, *onerror*, *onclick*, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers (*setTimeout*, *setInterval)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*eval(...)* calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combining these methods often seems natural, but doing so can create very unexpected
    and dangerous parsing chains. For example, consider the transformation that would
    need to be applied to the value inserted by the server in place of *user_string*
    in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: It is often difficult to notice that the value will go through no fewer than
    three rounds of parsing! First, the HTML parser will extract the *onclick* parameter
    and put it into DOM; next, when the button is clicked, the first round of JavaScript
    parsing will extract the *setTimeout(...)* syntax; and finally, one second after
    the initial click, the actual *do_stuff(...)* sequence will be parsed and executed.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in the example above, in order to survive the process, *user_string*
    needs to be double-encoded using JavaScript backslash sequences, and then encoded
    again using HTML entities, in that exact order. Any different approach will likely
    lead to code injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tricky escaping situation is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Even though the initial assignment of *some_value* requires *user_string* to
    be escaped just once, the subsequent ad hoc construction of a second-order script
    in the *setTimeout(...)* parameter introduces a vulnerability if no additional
    escaping is applied beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Such coding patterns happen frequently in JavaScript programs, and they are
    very easy to miss. It is much better to consistently discourage them than to audit
    the resulting code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#CHP-6-FN-5)]) On both types of *<script>* blocks, Microsoft supports
    a pseudo-dialect called *JScript.Encode*. This mode can be selected by specifying
    a *language* parameter on the *<script>* tag and simply permits the actual script
    to be encoded using a trivial alphabet substitution cipher to make it unreadable
    to casual users. The mechanism is completely worthless from the security standpoint,
    as the “encryption” can be reverted easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Living Dead: Visual Basic'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having covered most of the needed ground related to JavaScript, it’s time for
    an honorable mention of the long-forgotten contender for the scripting throne.
    Despite 15 years of lingering in almost complete obscurity, browser-side VBScript
    is still supported in Internet Explorer. In most aspects, Microsoft’s language
    is supposed to be functionally equivalent to JavaScript, and it has access to
    exactly the same Document Object Model APIs and other built-in functions as JavaScript.
    But, as one might expect, some tweaks and extensions are present—for example,
    a couple of VB-specific functions in place of the JavaScript built-ins.
  prefs: []
  type: TYPE_NORMAL
- en: There is virtually no research into the security properties of VBScript, the
    robustness of the parser, or its potential incompatibilities with the modern DOM.
    Anecdotal evidence suggests that the language receives no consistent scrutiny
    on Microsoft’s end, either. For example, the built-in *MsgBox*^([[153](pr03.html#ftn.CHP-6-FT-8)])
    can be used to display modal, always-on-top prompts with a degree of flexibility
    completely unheard of in the JavaScript world, leaving *alert(...)* in the dust.
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to predict how long VBScript will continue to be supported in
    this browser and what unexpected consequences for user and web application security
    it is yet to have. Only time will tell.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Loading Remote Scripts
  prefs: []
  type: TYPE_NORMAL
- en: As with CSS, you are linking the security of your site to the originating domain
    of the script. When in doubt, make a local copy of the data instead. On HTTPS
    sites, require all scripts to be served over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: When Parsing JSON Received from the Server
  prefs: []
  type: TYPE_NORMAL
- en: Rely on *JSON.parse(...)* where supported. Do not use *eval(...)* or the *eval*-based
    implementation provided in RFC 4627\. Both are unsafe, especially when processing
    data from third parties. A later implementation from the author of RFC 4627, *json2.js*,^([[154](pr03.html#ftn.CHP-6-FT-9)])
    is probably okay.
  prefs: []
  type: TYPE_NORMAL
- en: When Putting User-Supplied Data Inside JavaScript Blocks
  prefs: []
  type: TYPE_NORMAL
- en: '**Stand-alone strings in** <script> **blocks:** Backslash-escape all control
    characters (0x00 - 0x1F), “\”, “<”, “>”, and quotes using numerical codes. It
    is also preferable to escape high-bit characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not rely on user-supplied strings to construct dynamic HTML. Always use safe
    DOM features such as *innerText* or *createTextNode(...)* instead. Do not use
    user-supplied strings to construct second-order scripts; avoid *eval(...)*, *setTimeout(...)*,
    and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stand-alone strings in separately served scripts:** Follow the same rules
    as for *<script>* blocks. If your scripts contain any sensitive, user-specific
    information, be sure to account for cross-site script inclusion risks; use reliable
    parser-busting prefixes, such as “)}]'' \n”, near the beginning of a file or,
    at the very minimum, use a proper JSON serialization with no padding or other
    tweaks. Additionally, consult [Chapter 13](ch13.html "Chapter 13. Content Recognition
    Mechanisms") for tips on how to prevent cross-site scripting in non-HTML content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings in inlined event handlers**, javascript: **URLs, and so on:** Multiple
    levels of escaping are involved. Do not attempt this because it is error prone.
    If unavoidable, apply the above JS escaping rules first and then apply HTML or
    URL parameter encoding, as applicable, to the resulting string. Never use in conjunction
    with *eval(...)*, *setTimeout(...)*, *innerHTML*, and such.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonstring content:** Allow only whitelisted alphanumeric keywords and carefully
    validated numerical values. Do not attempt to reject known bad patterns instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Interacting with Browser Objects on the Client Side
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating HTML content on the client side:** Do not resort to *innerHTML*,
    *document.write(...)*, and similar tools because they are prone to introducing
    cross-site scripting flaws, often in unexpected ways. Use safe methods such as
    *createElement(...)* and *appendChild(...)* and properties such as *innerText*
    or *textContent* to construct the document instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relying on user-controlled data:** Make no assumptions about the escaping
    rules applied to any values read back from the browser and, in particular, to
    *location* properties and other external sources of URLs, which are inconsistent
    and vary from one implementation to another. Always do your own escaping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If You Want to Allow User-Controlled Scripts on Your Page
  prefs: []
  type: TYPE_NORMAL
- en: It is virtually impossible to do this safely. Experimental JavaScript rewriting
    frameworks, such as Caja ([http://code.google.com/p/google-caja/](http://code.google.com/p/google-caja/)),
    are the only portable option. Also see [Chapter 16](ch16.html "Chapter 16. New
    and Upcoming Security Features") for information on sandboxed frames, an upcoming
    alternative for embedding untrusted gadgets on web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Non-HTML Document Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to HTML documents, about a dozen other file formats are recognized
    and displayed by the rendering engines of modern web browsers; a list that is
    likely to grow over time.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the powerful scripting capabilities available in some of these formats,
    and because of the antics of browser-content handling, the set of natively supported
    non-HTML inputs deserves a closer examination at this point, even if a detailed
    discussion of some of their less-obvious security consequences—such as *content
    sniffing*—will have to wait until [Part II](pt02.html "Part II. Browser Security
    Features") of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most prosaic type of non-HTML document recognized by every single
    browser is a plaintext file. In this rendering mode, the input is simply displayed
    as is, typically using a nonproportional typeface, and save for optional character
    set transcoding, the data is not altered in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'All browsers recognize plaintext files served with *Content-Type: text/plain*
    in the HTTP headers. In all implementations but Internet Explorer, plaintext is
    also the fallback display method for headerless HTTP/0.9 responses and HTTP/1.*x*
    data with *Content-Type* missing; in both these cases, plaintext is used when
    all other content detection heuristics fail. (Internet Explorer unconditionally
    falls back to HTML rendering, true to the letter of Tim Berners-Lee’s original
    protocol drafts.)'
  prefs: []
  type: TYPE_NORMAL
- en: For the convenience of developers, most browsers also automatically map several
    other MIME types, including *application/javascript* and friends^([[35](#ftn.CHP-7-FN-1)])
    or *text/css*, to plaintext. Interestingly, *application/json*, the value mandated
    for JSON responses in RFC 4627, is not on the list (perhaps because it is seldom
    used in practice).
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext rendering has no specific security consequences. That said, due to
    a range of poor design decisions in other browser components and in third-party
    code, even seemingly harmless non-HTML formats are at a risk of being misidentified
    as, for example, HTML. Attacker-controlled plaintext documents are of special
    concern because their layout is often fairly unconstrained and therefore particularly
    conducive to being misidentified. [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms") dissects these threats and provides advice on how to
    mitigate the risk.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[35](#CHP-7-FN-1)]) The official MIME type for JavaScript is *application/javascript*,
    as per RFC 4329, but about a dozen other values have been used in the past (e.g.,
    *text/javascript, application/x-javascript, application/ecmascript*).
  prefs: []
  type: TYPE_NORMAL
- en: Bitmap Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browser-rendering engines recognize direct navigation to the same set of bitmap
    image formats that are normally supported in HTML documents when loaded via the
    *<img>* tag, including JPEG, PNG, GIF, BMP, and a couple more. When the user navigates
    directly to such a resource, the decoded bitmap is shown in the document window,
    allowing the user little more than the ability to scroll, zoom in and out, and
    save the file to disk.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of *Content-Type* information, images are detected based on file
    header checks. When a *Content-Type* value is present, it is compared with about
    a dozen predefined image types, and the user is routed accordingly. But if an
    attempt to decode the image fails, file headers are used to make a second guess.
    It is therefore possible (but, for the reasons explored in [Chapter 13](ch13.html
    "Chapter 13. Content Recognition Mechanisms"), often unwise) to serve a GIF file
    as *image/jpeg*.
  prefs: []
  type: TYPE_NORMAL
- en: As with text files, bitmap images are a passive resource and carry no unusual
    security risks.^([[36](#ftn.CHP-7-FN-2)]) However, whenever serving user-supplied
    images, remember that attackers will have a degree of control over the data, even
    if the format is carefully validated and scaled or recompressed. Therefore, the
    concerns about such a document format being misinterpreted by a browser or a plug-in
    still remain.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[36](#CHP-7-FN-2)]) Naturally, exploitable coding errors occasionally happen
    in all programs that deal with complex data formats, and image parsers are no
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Audio and Video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a very long time, browsers had no built-in support for playing audio and
    video content, save for an obscure and oft-ridiculed *<bgsound>* tag in Internet
    Explorer, which to this day can be used to play simple MID or WAV files. In the
    absence of real, cross-browser multimedia playback functionality, audio and video
    were almost exclusively the domain of browser plug-ins, whether purpose-built
    (such as Windows Media Player or Apple QuickTime) or generic (Adobe Flash, Microsoft
    Silverlight, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The ongoing work on HTML5 seeks to change this through support for *<audio>*
    and *<video>* tags: convenient, scriptable methods to interface with built-in
    media decoders. Unfortunately, there is substantial vendor-level disagreement
    as to which video formats to support and what patent consequences this decision
    may have. For example, while many browsers already support Ogg Theora (a free,
    open source, but somewhat niche codec), spirited arguments surrounding the merits
    of supporting the very popular but patent- and royalty-encumbered H.264 format
    and the prospects of a new, Google-backed WebM alternative will probably continue
    for the foreseeable future.'
  prefs: []
  type: TYPE_NORMAL
- en: As with other passive media formats (and unlike some types of plug-in-rendered
    content!), neither *<bgsound>* nor HTML5 multimedia are expected to have any unusual
    implications for web application security, as long as the possibility of content
    misidentification is mitigated appropriately.^([[37](#ftn.CHP-7-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[37](#CHP-7-FN-3)]) But some far-fetched interactions between various technologies
    are a distinct possibility. For example, what if the *<audio>* tag supports raw,
    uncompressed audio and is pointed to a sensitive nonaudio document, and then the
    proposed HTML5 microphone API is used by another website to capture the resulting
    waveform and reconstruct the contents of the file?
  prefs: []
  type: TYPE_NORMAL
- en: XML-Based Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Readers who found the handling of the formats discussed so far to be too sane
    for their tastes are in for a well-deserved treat. The largest and definitely
    most interesting family of browser-supported non-HTML document types relies on
    the common XML syntax and provides more than a fair share of interesting surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the formats belonging to this category are forwarded to specialized,
    single-purpose XML analyzers, usually based on the received *Content-Type* value
    or other simple heuristics. But more commonly, the payload is routed to the same
    parser that is relied upon to render XHTML documents and then displayed using
    this common pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter case, the actual meaning of the document is determined by the
    URL-like *xmlns* namespace directives present in the markup itself, and the namespace
    parameter may have nothing to do with the value originally supplied in *Content-Type*.
    Quite simply, there is no mechanism that would prevent a document served as *application/mathml+xml*
    from containing nothing but XHTML markup and beginning with *<html >*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the most common scenario, the namespace for the entire XML file is defined
    only once and is attached to the top-level tag. In principle, however, any number
    of different *xmlns* directives may appear in a single file, giving different
    meanings to each section of the document. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Faced with such input, the general-purpose renderer will usually do its best
    to make sense of all the recognized namespaces and assemble the markup into a
    single, consistent document with a normal Document Object Model representation.
    And, if any one of the recognized namespaces happens to support scripting, any
    embedded scripts will execute, too.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the somewhat counterintuitive *xmlns* handling behavior, *Content-Type*
    is not a suitable way to control how a particular XML document will be parsed;
    the presence of a particular top-level *xmlns* directive is also not a guarantee
    that no other data formats will be honored later on. Any attacker-controlled XML-based
    formats must therefore be handled with care and sanitized very thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Generic XML View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most browsers, a valid XML document with no renderer-recognized namespaces
    present anywhere in the markup will be shown as an interactive, pretty-printed
    representation of the document tree, as shown in [Figure 7-1](ch07s04.html#firefox_displaying_an_xml_document_with
    "Figure 7-1. Firefox displaying an XML document with no recognized namespaces").
    This mode is not particularly useful to end users, but it can aid debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, when any of the namespaces in the document is known to the browser
    (even when the top-level one is not recognized at all!), the document will be
    rendered differently: All recognized markup will work as intended, all unsupported
    tags will simply have no effect, and any text between them will be shown as is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this rendering strategy, consider the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The above example will be rendered as “Hello world!” The first *<u>* tag, with
    no semantics-defining namespace associated with it, will have no visible effect.
    The second one will be understood as an XHTML tag that triggers underlining.
  prefs: []
  type: TYPE_NORMAL
- en: '![Firefox displaying an XML document with no recognized namespaces](httpatomoreillycomsourcenostarchimages950019.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1. Firefox displaying an XML document with no recognized namespaces
  prefs: []
  type: TYPE_NORMAL
- en: The consequences of this fault-tolerant approach to the rendering of unknown
    XML documents and unrecognized namespaces are subtle but fairly important. For
    example, it will not be safe to proxy an unsanitized RSS feed, even though this
    format is typically routed to a specialized renderer and thus not subject to XSS
    risks. Any browser with no built-in RSS reader may fall back to generic rendering
    and then find HTML buried deep inside the feed.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Vector Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scalable Vector Graphics (SVG)^([[155](pr03.html#ftn.CHP-7-FT-1)]) is a quickly
    evolving, XML-based vector graphics format. First published in 2001 by W3C, it
    is noteworthy for its integrated animation capabilities and direct JavaScript
    scripting features. The following example of a vector image draws a circle and
    displays a message when this circle is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The SVG file format is recognized all modern browsers except for Internet Explorer
    prior to 9, and it is handled by the general-purpose XML renderer. SVG images
    can be embedded into XHTML with an appropriate *xmlns* directive or inlined in
    non-XML HTML5 documents using a predefined *<svg>* tag.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, in several browsers the format can also be placed in a stand-alone
    XML document and then viewed directly, or it can be loaded on third-party pages
    via the *<img>* markup. While it is safe to load SVG images via *<img>* (scripting
    should be disabled in this scenario), it is fairly dangerous to host user-supplied
    SVG data because in cases of direct navigation, all embedded scripts will execute
    in the context of the hosting domain. This unexpected problem means that serving
    any externally originating SVG images will require very careful syntax sanitization
    to eliminate non-SVG *xmlns* content from the XML container and to permit only
    certain types of markup in the remainder of the document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Content-Disposition* header on the relevant HTTP responses is a potential
    workaround that permits SVG to be included via *<img>* but not accessed directly.
    This approach is not perfect, but it limits the risk. Using a throwaway domain
    to host such images is another possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Markup Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematical Markup Language (MathML)^([[156](pr03.html#ftn.CHP-7-FT-2)]) is
    a fairly straightforward means to facilitate the semantic, if a bit verbose, representation
    of mathematical equations. The standard was originally proposed by the W3C in
    1998, and it has been substantially refined through the years. Because of its
    somewhat niche application, MathML needed over a decade to gain partial support
    in Opera and Firefox browsers, but it is slowly gaining acceptance today. In the
    browsers that support the language, it may be placed in a standalone file or inline
    in XHTML and HTML5 documents.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike SVG, MathML has no additional security considerations beyond those associated
    with generically handled XML.
  prefs: []
  type: TYPE_NORMAL
- en: XML User Interface Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The XML User Interface Language (XUL)^([[157](pr03.html#ftn.CHP-7-FT-3)]) is
    a presentation markup language created by Mozilla specifically for building browser-based
    applications, rather than documents. XUL exists because although modern HTML is
    often powerful enough to build basic graphical user interfaces, it is not particularly
    convenient for certain specialized tasks that desktop applications excel in, such
    as implementing common dialog windows or system menus.
  prefs: []
  type: TYPE_NORMAL
- en: XUL is not currently supported by any browser other than Firefox and appears
    to be disabled in the recent release, Firefox 6\. In Firefox, it is handled by
    the general-purpose renderer, based on the appropriate *xmlns* namespace. Firefox
    uses XUL for much of its internal UI, but otherwise the language is seldom encountered
    on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: From the standpoint of web application security, Internet-originating XUL documents
    can be considered roughly equivalent to HTML documents. Essentially, the language
    has JavaScript scripting capabilities and allows broad control over the appearance
    of the rendered page. Other than that property, it has no unusual quirks.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless Markup Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wireless Markup Language (WML)^([[158](pr03.html#ftn.CHP-7-FT-4)]) is a largely
    obsolete “optimized” HTML syntax developed in the 1990s by a consortium of mobile
    handset manufacturers and cellular network operators. This XML-based language,
    a part of the Wireless Application Protocol suite (WAP), offered a simplified
    weblike browsing experience for pre-smartphone devices with limited bandwidth
    and CPU resources.^([[38](#ftn.CHP-7-FN-4)]) A simple WML page might have looked
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Because WAP services needed to be engineered independently of normal HTML content
    and had to deal with closed and underspecified client architectures and other
    carrier-imposed restrictions, WML never became as popular as its proponents hoped.
    In almost all developed markets, WML has been displaced by fast, Internet-enabled
    smartphones with fully featured HTML browsers. Nevertheless, the legacy of the
    language lives on, and it is still routed to specialized renderers in Opera and
    in Internet Explorer Mobile.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the browsers that support the format, it is often possible to use WML-based
    scripts. There are two methods to achieve this. The canonical way is to use WMLScript
    (WMLS), a JavaScript-derived execution environment that depends on stand-alone
    script files, coupled with an extremely inconsiderate abuse of fragment IDs for
    an equivalent of possibly attacker-controlled *eval(...)* statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The other method of executing scripts, available in more featured browsers,
    is to simply embed normal *javascript:* URLs or insert *<script>* blocks into
    the WML file.
  prefs: []
  type: TYPE_NORMAL
- en: RSS and Atom Feeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Feeds* are a standardized way for clients to periodically poll sites of interest
    to users (such as their favorite blogs) for machine-readable updates to said sites’
    content. Really Simple Syndication (RSS)^([[159](pr03.html#ftn.CHP-7-FT-5)]) and
    Atom^([[160](pr03.html#ftn.CHP-7-FT-6)]) are two superficially similar but fiercely
    competing XML-based feed formats. The first (RSS) is popular; the second (Atom)
    is said to be good.'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in, specialized RSS and Atom renderers are available in Firefox, Safari,
    and Opera. The determination to route an XML document to these modules is based
    on simple, browser-specific heuristics, such as the top-level tag being named
    *<rss>* or *<feed>* (and not having any conflicting *xmlns* directives). In Firefox,
    RSS parsing may kick in even if *Content-Type* is *image/svg+xml* or *text/html*.
    Safari will happily recognize feeds in even more unrelated MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting feature of both feed formats is that they permit a subset of
    HTML, including CSS, to be embedded in a document in a rather peculiar, indirect
    way: as an entity-escaped text. Here is an example of this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The subset of HTML permitted in RSS and Atom feeds is not well defined, and
    some feed renderers have previously permitted direct scripting or navigation to
    potentially dangerous pseudo-URLs. Perhaps more importantly, however, any browser
    that does not have built-in feed previews may render the file using the generic
    XML parsing approach; if such feeds are not sanitized carefully, script execution
    will ensue.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#CHP-7-FN-4)]) Astute readers will note that XML is not a particularly
    good way to conserve bandwidth or CPU resources. To that effect, the WAP suite
    provides an alternative, binary-only serialization of XML, known as WBXML.
  prefs: []
  type: TYPE_NORMAL
- en: A Note on Nonrenderable File Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of completeness, it should be noted that all modern browsers support
    a number of specialized file formats that remain completely opaque to the renderer
    or to the web application layer but that are nevertheless recognized by a variety
    of in-browser subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed investigation of these formats is beyond the scope of this book,
    but some notable examples include plug-in and extension installation manifests,
    automatic HTTP proxy autoconfiguration files (PAC), installable visual skins,
    Certificate Revocation Lists (CRLs), antimalware site blacklists, and downloadable
    TrueType and OpenType fonts.
  prefs: []
  type: TYPE_NORMAL
- en: The security properties of these mechanisms should be studied individually before
    deciding to allow any of these formats to be served to the user. Save for the
    generic content-hosting considerations outlined in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms"), they are unlikely to harm the hosting web application
    directly, but they may cause problems for users.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Hosting XML-Based Document Formats
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that the payload may be interpreted as XHTML or some other script-enabled
    document type, regardless of the *Content-Type* and the top-level *xmlns* directive.
    Do not allow unconstrained attacker-controlled markup anywhere inside the file.
    Use the *Content-Disposition: attachment* if data is not meant to be viewed directly;
    *<img>* and feeds will still work.'
  prefs: []
  type: TYPE_NORMAL
- en: On All Non-HTML Document Types
  prefs: []
  type: TYPE_NORMAL
- en: 'Use correct, browser-recognized *Content-Type* and *charset* values. Specify
    the *Content-Disposition: attachment* where possible. Verify and constrain output
    syntax. Consult the cheat sheet in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms") to avoid security problems related to content-sniffing
    flaws.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Content Rendering with Browser Plug-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browser plug-ins come in many forms and shapes, but the most common variety
    give the ability to display new file formats in the browser, as if they were HTML.
    The browser simply hands over the retrieved file, provides the helper application
    with a rectangular drawing surface in the document window, and essentially backs
    away from the scene. Such content-rendering plug-ins are clearly distinguished
    from browser extensions, a far more numerous bunch that commonly relies on JavaScript
    code to tweak how the already-supported, in-browser content is presented to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Browser plug-ins have a long and colorful history of security flaws. In fact,
    according to some analysts, 12 out of the 15 most frequently exploited client-side
    vulnerabilities in 2010 could be attributed to the quality of plug-in software.^([[161](pr03.html#ftn.CHP-8-FT-1)])
    Many of these problems are because the underlying parsers were originally not
    meant to handle malicious inputs gracefully and have not benefited from the intense
    scrutiny that the remainder of the Web has been subject to. Other problems stem
    from the unusual security models devised by plug-in developers and the interference
    between these permissions, the traditional design of web browsers, and the commonsense
    expectations of application developers.
  prefs: []
  type: TYPE_NORMAL
- en: We will review some of the security mechanisms used by popular plug-ins in the
    next chapter of this book. Before taking this dive, it makes sense to look at
    the ways plug-ins integrate with other online content and the common functionality
    they offer.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a Plug-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content-rendering plug-ins can be activated in a couple of ways. The most popular
    explicit method is to use *<embed src=...>* or `<`*object data=...>* markup in
    a “host” HTML document, with the *src* or *data* parameter pointing to the URL
    from which the actual plug-in-recognized document is to be retrieved. The dimensions
    and position of the drawable area allocated for the plug-in can be controlled
    with CSS (or with legacy HTML parameters).
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, every *<embed>* or *<object>* tag should be accompanied by
    an additional *type* parameter. The MIME type specified there will be compared
    to the list of MIME types registered by all the active plug-ins, and the retrieved
    file will be routed to the appropriate handler. If no match is found, a warning
    asking the user to download a plug-in should be theoretically displayed instead,
    although most browsers look at other signals before resorting to this unthinkable
    possibility; examining *Content-Type* or the apparent file extension spotted in
    the URL are two common choices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An obsolete *<applet>* tag, used to load Java programs (roughly equivalent to
    *<object type="application/x-java-applet">*), works in a comparable way but unconditionally
    disregards these auxiliary signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional input to the plug-in is commonly passed using *<param>* tags nested
    inside the *<object>* block or through nonstandard additional parameters attached
    to the *<embed>* markup itself. The former, more modern approach may look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: In this content-inclusion mode, the *Content-Type* header returned by the server
    when retrieving the subresource is typically ignored, unless the *type* parameter
    is unknown to the browser. This is an unfortunate design, for reasons that will
    be explained shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The other method for displaying plug-in content involves navigating directly
    to a suitable file. In this case, and in the case of *<embed>* or *<object>* with
    a missing *type* parameter, the *Content-Type* value obtained from the server
    is honored, and it will be compared with the list of plug-in-recognized MIME types.
    If a match is found, the content is routed to the appropriate component. If the
    *Content-Type* lookup fails or the header is missing, some browsers will examine
    the response body for known content signatures; others just give up.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aforementioned content-focused methods aside, several types of plug-ins
    can be loaded directly from within JavaScript or VBScript programs without the
    need to explicitly create any HTML markup or retrieve any external data. Such
    is the case for ActiveX, an infamous script-to-system integration bridge available
    in Internet Explorer. (We will devote some time to ActiveX later in this chapter,
    but first things first.)
  prefs: []
  type: TYPE_NORMAL
- en: The Perils of Plug-in Content-Type Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted in the previous section, in certain scenarios the *Content-Type* parameter
    on a retrieved plug-in-handled file is ignored, and the *type* parameter in the
    corresponding markup on the embedding page is used instead. While this decision
    is somewhat similar to the behavior of other type-specific content-inclusion tags
    (say, *<img>*), as discussed in [Type-Specific Content Inclusion](ch04s05.html#type-specific_content_inclusion
    "Type-Specific Content Inclusion") in [Frames](ch04s05.html#frames "Frames"),
    it has some unique and ultimately disastrous consequences in the plug-in world.
  prefs: []
  type: TYPE_NORMAL
- en: The big problem is that several types of plug-ins are essentially full-fledged
    code execution environments and give the executed applications (*applets*) a range
    of special privileges to interact with the originating domain. For example, a
    Flash file retrieved from [fuzzybunnies.com](http://fuzzybunnies.com) would be
    granted access to its originating domain (complete with a user’s cookies) when
    embedded on the decidedly rogue [bunnyoutlet.com](http://bunnyoutlet.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a scenario, it would seem to be important for [fuzzybunnies.com](http://fuzzybunnies.com)
    to be able to clearly communicate that a particular type of a document is indeed
    meant to be interpreted by a plug-in—and, consequently, that some documents aren’t
    meant to be used this way. Unfortunately, there is no way for this to happen:
    The handling of a retrieved file is fully controlled by the embedding site (in
    our example, by the mean-spirited bullies who own [bunnyoutlet.com](http://bunnyoutlet.com)).
    Therefore, if the originating domain hosts any type of user-controlled content,
    even in a nominally harmless format (such as *text/plain* or *image/jpeg*), the
    owners of [bunnyoutlet.com](http://bunnyoutlet.com) may instruct the browser to
    disregard the existing metadata and route that document to a plug-in of their
    choice. A simple markup to achieve this sinister goal may be'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If this turn of events seems wrong, that’s because it is. Security researchers
    have repeatedly demonstrated that it is quite easy to construct documents that
    are, for example, simultaneously a valid image and a valid plug-in-recognized
    executable. The well-known “GIFAR” vulnerability, discovered in 2008 by Billy
    Rios,^([[162](pr03.html#ftn.CHP-8-FT-2)]) exploited that very trick: It smuggled
    a Java applet inside a perfectly kosher GIF image. In response, Sun Microsystems
    reportedly tightened down the Java JAR file parser to mitigate the risk, but the
    general threat of such mistakes is still very real and will likely rear its ugly
    head once more.'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the decision by some developers to rely on *Content-Type* and
    other signals if the *type* parameter is unrecognized is almost as bad. This decision
    makes it impossible for the well-intentioned [fuzzybunnies.com](http://fuzzybunnies.com)
    to safely embed a harmless video from the rogues at [bunnyoutlet.com](http://bunnyoutlet.com)
    by simply specifying *type="video/x-ms-wmv"*, because if any of the visitors do
    not have a plug-in for that specific media type, [bunnyoutlet.com](http://bunnyoutlet.com)
    will suddenly have a say in what type of plug-in should be loaded on the embedding
    site instead. Some browsers, such as Internet Explorer, Chrome, or Opera, may
    also resort to looking for apparent file extensions present in the URL, which
    can lead to an interesting situation where neither the embedding nor the hosting
    party has real control over how a document is displayed—and quite often only the
    attacker is in charge.
  prefs: []
  type: TYPE_NORMAL
- en: 'A much safer design would require the embedder-controlled *type* parameter
    and the host-controlled *Content-Type* header to match (at least superficially).
    Unfortunately, there is currently no way to make this happen. Several individual
    plug-ins try to play nice (for example, following a 2008 overhaul, Adobe Flash
    rejects applets served with *Content-Disposition: attachment*, as does the built-in
    PDF reader in Chrome), but these improvements are few and far between.'
  prefs: []
  type: TYPE_NORMAL
- en: Document Rendering Helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A significant portion of the plug-in landscape belongs to programs that allow
    certain very traditional, “nonweb” document formats to be shown directly in the
    browser. Some of these programs are genuinely useful: Windows Media Player, RealNetworks
    RealPlayer, and Apple QuickTime have been the backbone of online multimedia playback
    for about a decade, at least until their displacement by Adobe Flash. The merits
    of others are more questionable, however. For example, Adobe Reader and Microsoft
    Office both install in-browser document viewers, increasing the user’s attack
    surface appreciably, though it is unclear whether these viewers offer a real benefit
    over opening the same document in a separate application with one extra click.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in a perfect world, hosting or embedding a PDF or a Word document
    should have no direct consequences for the security of the participating websites.
    Yet, predictably, the reality begs to differ. In 2009, a researcher noted that
    PDF-based forms that submit to *javascript:* URLs can apparently lead to client-side
    code execution on the embedding site.^([[163](pr03.html#ftn.CHP-8-FT-3)]) Perhaps
    even more troubling than this report alone, according to that researcher’s account,
    Adobe initially dismissed the report with the following note: “Our position is
    that, like an HTML page, a PDF file is active content.”'
  prefs: []
  type: TYPE_NORMAL
- en: It is regrettable that the hosting party does not have full control of when
    this active content is detected and executed and that otherwise reasonable webmasters
    may think of PDFs or Word documents as just a fancy way to present text. In reality,
    despite their harmless appearance, in a bid to look cool, many such document formats
    come equipped with their own hyperlinking capabilities or even scripting languages.
    For example, JavaScript code can be embedded in PDF documents, and Visual Basic
    macros are possible in Microsoft Office files. When a script-bearing document
    is displayed on an HTML page, some form of a programmatic plug-in-to-browser bridge
    usually permits a degree of interaction with the embedding site, and the design
    of such bridges can vary from vaguely questionable to outright preposterous.
  prefs: []
  type: TYPE_NORMAL
- en: In one 2007 case, Petko D. Petkov noticed that a site that hosts any PDF documents
    can be attacked simply by providing completely arbitrary JavaScript code in the
    fragment identifier. This string will be executed on the hosting page through
    the plug-in bridge:^([[164](pr03.html#ftn.CHP-8-FT-4)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The two vulnerabilities outlined here are now fixed, but the lesson is that
    special care should be exercised when hosting or embedding any user-supplied documents
    in sensitive domains. The consequences of doing so are not well documented and
    can be difficult to predict.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-in-Based Application Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The boring job of rendering documents is a well-established role for browser
    plug-ins, but several ambitious vendors go well beyond this paradigm. The aim
    of some plug-ins is simply to displace HTML and JavaScript by providing alternative,
    more featured platforms for building interactive web applications. That reasoning
    is not completely without merit: Browsers have long lacked in performance, in
    graphics capabilities, and in multimedia codecs, stifling some potential uses
    of the Web. Reliance on plug-ins is a reasonable short-term way to make a difference.
    On the flip side, when proprietary, patent- and copyright-encumbered plug-ins
    are promoted as the ultimate way to build an online ecosystem, without any intent
    to improve the browsers themselves, the openness of the Web inevitably suffers.
    Some critics, notably Steve Jobs, think that creating a tightly controlled ecosystem
    is exactly what several plug-in vendors, most notably Adobe, aspire to.^([[165](pr03.html#ftn.CHP-8-FT-5)])'
  prefs: []
  type: TYPE_NORMAL
- en: In response to this perceived threat of a hostile takeover of the Web, many
    of the shortcomings that led to the proliferation of alternative application frameworks
    are now being hastily addressed under the vaguely defined umbrella of HTML5; *<video>*
    tags and WebGL^([[39](#ftn.CHP-8-FN-1)]) are the prime examples of this work.
    That said, some of the features available in plug-ins will probably not be captured
    as a part of any browser standard in the immediate future. For example, there
    is currently no serious plan to add inherently dangerous elevated privilege programs
    supported by Java or security-by-obscurity content protection schemes (euphemistically
    called Digital Rights Management, or DRM).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, while the landscape will change dramatically in the coming years,
    we can expect that in one form or another, proprietary web application frameworks
    are here to stay.
  prefs: []
  type: TYPE_NORMAL
- en: Adobe Flash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adobe Flash is a web application framework introduced in 1996, in the heat of
    the First Browser Wars. Before its acquisition by Adobe in 2005, the Flash platform
    was known as Macromedia Flash or Shockwave Flash (hence the *.swf* file extension
    used for Flash files), and it is still sometimes referred to as such.
  prefs: []
  type: TYPE_NORMAL
- en: Flash is a fairly down-to-earth platform built on top of a JavaScript-based
    language dubbed ActionScript.^([[166](pr03.html#ftn.CHP-8-FT-6)]) It includes
    a 2-D vector and bitmap graphics-rendering engine and built-in support for several
    image, video, and audio formats, such as the popular and efficient H.264 codec
    (which is used for much of today’s online multimedia).
  prefs: []
  type: TYPE_NORMAL
- en: 'By most estimates, Flash is installed on around 95 to 99 percent of all desktop
    systems.^([[167](pr03.html#ftn.CHP-8-FT-7)]), ^([[168](pr03.html#ftn.CHP-8-FT-8)])
    This user base is substantially higher than that of any other media player plug-in.
    (Support for the Windows Media Player and QuickTime plug-ins is available on only
    about 60 percent of PCs, despite aggressive bundling strategies, while the increasingly
    unpopular RealPlayer is still clinging to 25 percent.) The market position contributes
    to the product’s most significant and unexpected use: the replacement of all multimedia
    playback plug-ins previously relied upon for streaming video on the Web. Although
    the plug-in is also used for a variety of other jobs (including implementing online
    games, interactive advertisements, and so on), simple multimedia constitutes a
    disproportionately large slice of the pie.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Confusingly, a separate plug-in called Adobe Shockwave Player (without the word
    “Flash”) is also available, which can be used to play back content created with
    Adobe Director. This plug-in is sometimes mistakenly installed in place of or
    alongside Adobe Flash, contributing to an approximately 20 percent install base,^([[169](pr03.html#ftn.CHP-8-FT-9)])
    but it is almost always unnecessary. The security properties of this plug-in are
    not particularly well studied.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of ActionScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The capabilities of ActionScript in SWF files are generally analogous to those
    of JavaScript code embedded on HTML pages with some minor, yet interesting, differences.
    For example, Flash programs are free to enumerate all fonts installed on a system
    and collect other useful system fingerprinting signals not available to normal
    scripts. Flash programs can also use full screen rendering, facilitating UI spoofing
    attacks, and they can request access to input devices such as a camera or a microphone
    (this requires the user’s consent). Flash also tends to ignore browser security
    and privacy settings and uses its own configuration for mechanisms such as in-plug-in
    persistent data storage (although some improvements in this area were announced
    in May 2011).
  prefs: []
  type: TYPE_NORMAL
- en: The remaining features are less surprising. We’ll discuss the network and DOM
    access permissions of Flash applications in more detail in the next chapter, but
    in short, by default, every Flash applet can use the browser HTTP stack (and any
    ambient credentials managed therein) to talk back to its originating server, request
    a limited range of subresources from other sites, and navigate the current browser
    window or open a new one. ActionScript programs may also negotiate browser-level
    access to other currently running Flash applications and, in some cases, access
    the DOM of the embedding page. This last functionality is implemented by injecting
    *eval(...)*-like statements into the target JavaScript context.
  prefs: []
  type: TYPE_NORMAL
- en: ActionScript offers fertile ground for web application vulnerabilities. For
    example, the *getURL(...)* and *navigateToURL(...)* functions, used to navigate
    the browser or open new windows, are sometimes invoked with attacker-controlled
    inputs. Such a use is dangerous. Even though *javascript:* URLs do not have a
    special meaning to Flash, the function will pass such strings to the browser,
    in some cases resulting in script injection on the embedding site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until recently, a related problem was present with other URL-handling APIs,
    such as *loadMovie(...)*. Even though the function did not rely on the browser
    to load the document, it would recognize an internal *asfunction:* scheme, which
    works similarly to *eval(...)* and could be trivially leveraged to perform a call
    to *getURL(...)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The issue with loading scripts from untrusted sources, discussed in [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts"), also has an equivalent in the plug-in word.
    In Flash, it is very unsafe to invoke certain functions that affect the state
    of the ActionScript execution environment (such as the *LoadVars.load(...)*) with
    attacker-controlled URLs, even if the scheme from which the resource is loaded
    is *http:* or *https:*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another commonly overlooked attack surface is the internal, simplified HTML
    parser offered by the Flash plug-in: Basic HTML markup can be assigned to properties
    such as *TextField.htmlText* and *TextArea.htmlText*. It is easy to forget that
    user-supplied content must be escaped correctly in this setting. Failure to do
    so may permit attackers to modify the appearance of the application UI or to inject
    potentially problematic scripting-oriented links.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another class of Flash-related security bugs may arise due to design or
    implementation problems in the plug-in itself. For example, take the *ExternalInterface.call(...)*
    API. It is meant to allow ActionScript to call existing JavaScript functions on
    the embedding page and takes two parameters: the name of the JavaScript function
    to call and an optional string to be passed to this routine. While it is understood
    that the first parameter should not be attacker controlled, it appears to be safe
    to put user data in the second one. In fact, the documentation provides the following
    code snippet outlining this specific use case:^([[170](pr03.html#ftn.CHP-8-FT-10)])'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'This call will result in the following *eval(...)* statement being injected
    on the embedding page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing the code behind this call, the authors of the plug-in remembered
    to use backslash escaping when outputting the second parameter: *hello"world*
    becomes *hello\"world*. Unfortunately, they overlooked the need to escape any
    stray backslash characters, too. Because of this, if the value of *input.text*
    is set to the following string, the embedded script will unexpectedly execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'I contacted Adobe about this particular problem in March 2010\. Over a year
    later, its response was this: “We have not made any change to this behavior for
    backwards compatibility reasons.”'
  prefs: []
  type: TYPE_NORMAL
- en: That seems unfortunate.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Silverlight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Silverlight is a versatile development platform built on the Windows
    Presentation Foundation, a GUI framework that is a part of Microsoft’s .NET stack.
    It debuted in 2007 and combines an Extensible Application Markup Language (XAML)^([[171](pr03.html#ftn.CHP-8-FT-11)])
    (Microsoft’s alternative to Mozilla’s XUL) with code written in one of several
    managed .NET languages,^([[40](#ftn.CHP-8-FN-2)]) such as C# or Visual Basic.
  prefs: []
  type: TYPE_NORMAL
- en: Despite substantial design differences and a more ambitious (and confusing)
    architecture, this plug-in is primarily meant to compete with Adobe Flash. Many
    of the features available to Silverlight applications mirror those implemented
    in its competitor, including a nearly identical security model and a similar *eval(...)*-based
    bridge to the embedding page. To Microsoft’s credit, Silverlight does not come
    with an equivalent of the *asfunction:* scheme or with a built-in HTML renderer,
    however.
  prefs: []
  type: TYPE_NORMAL
- en: Silverlight is marketed by Microsoft fairly aggressively, and it is bundled
    with some editions of Internet Explorer. As a result, depending on the source,
    it is believed to have about a 60 to 75 percent desktop penetration.^([[172](pr03.html#ftn.CHP-8-FT-12)])
    Despite its prevalence, Silverlight is used fairly infrequently to develop actual
    web applications, perhaps because it usually offers no compelling advantages over
    its more established counterpart or because its architecture is seen as more contrived
    and platform-specific. (Netflix, a popular video streaming and rental service,
    is one of the very few high-profile websites that actually relies on Silverlight
    for playback on some devices.)
  prefs: []
  type: TYPE_NORMAL
- en: Sun Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java is a programming language coupled with a platform-independent, managed-code
    execution platform. Developed in the early to mid-1990s by James Gosling for Sun
    Microsystems, Java has a well-established role as a server-side programming language
    and a very robust presence in many other niches, including mobile devices. Yet,
    from the beginning, Sun hoped that Java would also occupy a prominent place on
    the browser end.
  prefs: []
  type: TYPE_NORMAL
- en: Java in the browser predated Flash and most similar plug-ins, and the now-obsolete
    *<applet>* tag is a testament to how important and unique and novel this addition
    must have seemed back in its day. Yet, despite this head start, the Java language
    is nearly extinct as an in-browser development platform, and even in its heyday
    it never enjoyed real prominence. It retains a remarkable 80 percent installed
    base, but this high percentage is attributed largely to the fact that the Java
    plug-in is bundled with Java Runtime Environment (JRE), a more practically useful
    and commonly preinstalled component that is required to run normal, desktop Java
    applications on the system without any involvement on the browser end.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for the failure of Java as a browser technology are difficult to
    pinpoint. Perhaps it’s due to the plug-in’s poor startup performance, the clunky
    UI libraries that made it difficult to develop snappy and user-friendly web applications,
    or the history of vicious litigation between Sun and Microsoft that cast a long
    shadow over the future of the language on Microsoft’s operating systems.^([[41](#ftn.CHP-8-FN-3)])
    Whatever the reasons may be, the high install base of Java coupled with its marginal
    use means that the risks it creates far outweigh any potential benefits to the
    users. (The plug-in had close to 80 security vulnerabilities in 2010,^([[173](pr03.html#ftn.CHP-8-FT-13)])
    and the vendor is commonly criticized for patching such bugs very slowly.)
  prefs: []
  type: TYPE_NORMAL
- en: Java’s security policies are somewhat similar to those of other plug-ins, but
    in some aspects, such as its understanding of the same-origin policy or its ability
    to restrict access to the embedding page, it compares unfavorably. (The next chapter
    provides an overview of this.) It is also worth noting that unlike with Flash
    or Silverlight, certain types of cryptographically signed applets may request
    access to potentially dangerous OS features, such as unconstrained networking
    or file access, and only a user’s easily coaxed consent stands in the way.
  prefs: []
  type: TYPE_NORMAL
- en: XML Browser Applications (XBAP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XML Browser Applications (XBAP)^([[174](pr03.html#ftn.CHP-8-FT-14)]) is Microsoft’s
    heavy-handed foray into the world of web application frameworks, attempted in
    the years during which the battle over Java started going sour and before the
    company released Silverlight.
  prefs: []
  type: TYPE_NORMAL
- en: XBAP is reminiscent of Silverlight in that it leverages the same Windows Presentation
    Foundation and .NET architecture. However, instead of being a self-contained and
    snappy browser plug-in, it depends on the large and unwieldy .NET runtime, in
    a manner similar to the Java plug-in’s dependence on JRE. It executes the managed
    code in a separate process called *PresentationHost.exe*, often loading extensive
    dependencies at initialization time. By Microsoft’s own admission, the load time
    of a medium-size previously uncached application could easily reach 10 seconds
    or more. When the technology premiered in 2002, most users were already expecting
    Internet applications to be far more responsive than that.
  prefs: []
  type: TYPE_NORMAL
- en: The security model of XBAP applications is poorly documented and has not been
    researched to date, perhaps due to XBAP’s negligible real-world use and obtuse,
    multilayer architecture. One would reasonably expect that XBAP’s security properties
    would parallel the model eventually embraced for Silverlight, but with broader
    access to certain .NET libraries and UI widgets. And, apparently as a result of
    copying from Sun, XBAP programs can also be given elevated privileges when loaded
    from the local filesystem or signed with a cryptographic certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft bundled XBAP plug-ins with its .NET framework to the point of silently
    installing nonremovable Windows Presentation Foundation plug-ins—not only in Internet
    Explorer but also in the competing Firefox and Chrome. This move stirred some
    well-deserved controversy, especially once the first vulnerability reports started
    pouring in. (Mozilla even temporarily disabled the plug-in through an automated
    update to protect its users.) Still, despite such bold and questionable moves
    to popularize it, nobody actually wanted to write XBAP applets, and inch by inch,
    the technology followed Java into the dustbin of history.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, Microsoft appeared to acknowledge this failure and chose to focus
    on Silverlight instead. Beginning with Internet Explorer 9, XBAP is disabled by
    default for Internet-originating content, and the dubious Firefox and Chrome plug-ins
    are no longer automatically pushed to users. Nevertheless, it seems reasonable
    to assume that at least 10 percent of all Internet users may be still browsing
    with a complex, partly abandoned, and largely unnecessary plug-in installed on
    their machines and will continue to do so for the next couple of years.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[39](#CHP-8-FN-1)]) WebGL is a fairly recent attempt to bring OpenGL-based
    3D graphics to JavaScript applications. The first specification of the standard
    appeared in March 2011, and wide browser-level support is expected to follow.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[40](#CHP-8-FN-2)]) Managed code is not executed directly by the CPU (which
    would be inherently unsafe, because CPUs are not designed to enforce web security
    rules). Rather, it is compiled to an intermediate binary form and then interpreted
    at runtime by a specialized virtual machine. This approach is faster than interpreting
    scripts at runtime and permits custom security policy enforcement as the program
    is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[41](#CHP-8-FN-3)]) The legal battles started in 1997, when Microsoft decided
    to roll out its own (and in some ways, superior) version of the Java virtual machine.
    Sun Microsystems sued, hoping to win an injunction that would force Microsoft
    to bundle Sun’s version instead. The two companies initially settled in 2001,
    but shortly thereafter they headed back to court. In the final settlement in 2004,
    Sun walked away with $1.6 billion in cash, but Windows users were not getting
    any Java runtime at all.
  prefs: []
  type: TYPE_NORMAL
- en: ActiveX Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, ActiveX is the successor to Object Linking and Embedding (OLE),
    a 1990 technology that made it possible for programs to reuse components of other
    applications in a standardized, language-independent way. A simple use case for
    ActiveX would be a spreadsheet application wishing to embed an editable vector
    image from a graphics-editing program or a simple game that wants to embed a video
    player.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is not controversial, but by the mid-1990s Microsoft had decided that
    ActiveX made sense in the browser, too. After all, wouldn’t websites want to benefit
    from the same Windows components that desktop applications could rely on? The
    approach violates the idea of nurturing an open, OS-independent web, but it’s
    otherwise impressive, as illustrated by the following JavaScript example that
    casually creates, edits, and saves an Excel spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Standards compliance aside, Microsoft’s move to ActiveX proved disastrous from
    a security standpoint. Many of the exposed ActiveX components were completely
    unprepared to behave properly when interacting with untrusted environments, and
    over the next 15 years, researchers discovered several hundred significant security
    vulnerabilities in web-accessible ActiveX controls. Heck, the simple observation
    that Firefox does not support this technology helped bolster its security image
    at the onset of the Second Browser Wars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite this fiasco, Microsoft stood by ActiveX defiantly, investing in gradually
    limiting the number of controls that could be accessed from the Internet and fixing
    the bugs in those it considered essential. Not until Internet Explorer 9 did Microsoft
    finally decide to let go: Internet Explorer 9 disables all ActiveX access by default,
    requiring several extra clicks to use it when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The wisdom of delegating the choice to the user is unclear, especially since
    the permission granted to a site extends not only to legitimate content on that
    website but also to any payloads injected due to application bugs such as XSS.
    Still, Internet Explorer 9 is some improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Living with Other Plug-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered almost all general-purpose browser plug-ins in use today.
    Although there is a long tail of specialized or experimental plug-ins, their use
    is fairly insignificant and not something that we need to take into account when
    surveying the overall health of the online ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Well, with one exception. An unspecified but probably significant percentage
    of online users can be expected to have an assortment of web-exposed browser plug-ins
    or ActiveX controls that they never knowingly installed, or that they were forced
    to install even though it’s doubtful that they would ever benefit from the introduced
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This inexcusable practice is sometimes embraced by otherwise reputable and trusted
    companies. For example, Adobe forces users who wish to download Adobe Flash to
    also install GetRight, a completely unnecessary third-party download utility.
    Microsoft does the same with Akamai Download Manager on its developer-oriented
    website, complete with a hilarious justification (emphasis mine):^([[175](pr03.html#ftn.CHP-8-FT-15)])
  prefs: []
  type: TYPE_NORMAL
- en: What is the Akamai Download Manager and why do I *have* to use it?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To help you download large files with reduced chance of interruption, some downloads
    require the use of the Akamai Download Manager.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The primary concern with software installed this way and exposed directly to
    malicious input from anywhere on the Internet is that unless it is designed with
    extreme care, it is likely to have vulnerabilities (and sure enough, both GetRight
    and Akamai Download Manager had some). Therefore, the risks of browsing with a
    completely unnecessary plug-in that only served a particular purpose once or twice
    far outweigh the purported (and usually unwanted) benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Security Engineering Cheat Sheet
  prefs: []
  type: TYPE_NORMAL
- en: When Serving Plug-in-Handled Files
  prefs: []
  type: TYPE_NORMAL
- en: '**Data from trusted sources:** Data from trusted sources is generally safe
    to host, but remember that security vulnerabilities in Flash, Java, or Silverlight
    applets, or in the Adobe Reader JavaScript engine, may impact the security of
    your domain. Avoid processing user-supplied URLs and generating or modifying user-controlled
    HTML from within plug-in-executed applets. Exercise caution when using the JavaScript
    bridge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-controlled simple multimedia:** User-controlled multimedia is relatively
    safe to host, but be sure to validate and constrain the format, use the correct
    *Content-Type*, and consult the cheat sheet in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms") to avoid security problems caused by content-sniffing
    flaws.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-controlled document formats:** These are not inherently unsafe, but
    they have an increased risk of contributing security problems due to plug-in design
    flaws. Consider hosting from a dedicated domain when possible. If you need to
    authenticate the request to an isolated domain, do so with a single-use request
    token instead of by relying on cookies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-controlled active applications:** These are unsafe to host in sensitive
    domains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Embedding Plug-in-Handled Files
  prefs: []
  type: TYPE_NORMAL
- en: Always make sure that plug-in content on HTTPS sites is also loaded over HTTPS,^([[42](#ftn.CHP-8-FN-4)])
    and always explicitly specify the *type* parameter on *<object>* or *<embed>*.
    Note that because of the non-authoritative handling of *type* parameters, restraint
    must be exercised when embedding plug-in content from untrusted sources, especially
    on highly sensitive sites.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple multimedia:** It is generally safe to load simple multimedia from
    third-party sources, with the caveats outlined above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document formats:** These are usually safe, but they carry a greater potential
    for plug-in and browser content-handling issues than simple multimedia. Exercise
    caution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flash and Silverlight:** In principle, Flash and Silverlight apps can be
    embedded safely from external sources if the appropriate security flags are present
    in the markup. If the flags are not specified correctly, you may end up tying
    the security of your site to that of the provider of the content. Consult the
    cheat sheet in [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic") for
    advice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java:** Java always ties the security of your service to that of the provider
    of the content, because DOM access to the embedding page can’t be reliably restricted.
    See [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic"). Do not load Java
    apps from untrusted sites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If You Want to Write a New Browser Plug-in or ActiveX Component
  prefs: []
  type: TYPE_NORMAL
- en: Unless you are addressing an important, common-use case that will benefit a
    significant fraction of the Internet, please reconsider. If you are scratching
    an important itch, consider doing it in a peer-reviewed, standardized manner as
    a part of HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[42](#CHP-8-FN-4)]) If loading an HTTP-delivered applet on an HTTPS page
    is absolutely unavoidable, it is safer to place it inside an intermediate HTTP
    frame rather than directly inside the HTTPS document, as this prevents the applet-to-JavaScript
    bridge from being leveraged for attacks.
  prefs: []
  type: TYPE_NORMAL
