- en: Part I. Anatomy of the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。网络解剖学
- en: The first part of this book focuses on the principal concepts that govern the
    operation of web browsers, namely, the protocols, document formats, and programming
    languages that make it all tick. Because all the familiar, user-visible security
    mechanisms employed in modern browsers are profoundly intertwined with these inner
    workings, the bare internals deserve a fair bit of attention before we wander
    off deeper into the woods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分专注于支配网络浏览器操作的原理性概念，即使一切运转的协议、文档格式和编程语言。因为所有现代浏览器中使用的熟悉、用户可见的安全机制都与这些内部工作紧密相连，所以在深入森林之前，我们应该给予这些裸露的内部相当多的关注。
- en: Chapter 2. It Starts with a URL
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。一切从URL开始
- en: The most recognizable hallmark of the Web is a simple text string known as the
    *Uniform Resource Locator (URL)*. Each well-formed, fully qualified URL is meant
    to conclusively address and uniquely identify a single resource on a remote server
    (and in doing so, implement a couple of related, auxiliary functions). The URL
    syntax is the cornerstone of the address bar, the most important user interface
    (UI) security indicator in every browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网络最显著的特征是被称为*统一资源定位符（URL）*的简单文本字符串。每个格式良好、完全合格的URL旨在最终确定地定位和唯一标识远程服务器上的单个资源（并在这样做的同时实现一些相关的辅助功能）。URL语法是地址栏的基石，是每个浏览器中最重要用户界面（UI）安全指示器。
- en: In addition to true URLs used for content retrieval, several classes of *pseudo-URLs*
    use a similar syntax to provide convenient access to browser-level features, including
    the integrated scripting engine, several special document-rendering modes, and
    so on. Perhaps unsurprisingly, these pseudo-URL actions can have a significant
    impact on the security of any site that decides to link to them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于内容检索的真实URL之外，还有几类*伪URL*使用类似的语法来提供方便地访问浏览器级功能，包括集成脚本引擎、几个特殊的文档渲染模式等。也许不出所料，这些伪URL操作可以对决定链接到它们的任何网站的安全性产生重大影响。
- en: The ability to figure out how a particular URL will be interpreted by the browser,
    and the side effects it will have, is one of the most basic and common security
    tasks attempted by humans and web applications alike, but it can be a problematic
    one. The generic URL syntax, the work of Tim Berners-Lee, is codified primarily
    in RFC 3986;^([[94](pr03.html#ftn.CHP-2-FT-1)]) its practical uses on the Web
    are outlined in RFCs 1738,^([[95](pr03.html#ftn.CHP-2-FT-2)]) 2616,^([[96](pr03.html#ftn.CHP-2-FT-3)])
    and a couple of other, less-significant standards. These documents are remarkably
    detailed, resulting in a fairly complex parsing model, but they are not precise
    enough to lead to harmonious, compatible implementations in all client software.
    In addition, individual software vendors have chosen to deviate from the specifications
    for their own reasons.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 确定特定URL将被浏览器如何解释及其副作用的能力，是人类和Web应用尝试的最基本和最常见的安全任务之一，但它可能是一个有问题的任务。通用URL语法，由蒂姆·伯纳斯-李的工作，主要在RFC
    3986中编码；^([[94](pr03.html#ftn.CHP-2-FT-1)])其Web上的实际用途在RFC 1738，^([[95](pr03.html#ftn.CHP-2-FT-2)])
    2616，^([[96](pr03.html#ftn.CHP-2-FT-3)])和其他几个不那么重要的标准中概述。这些文件非常详细，导致了一个相当复杂的解析模型，但它们并不足够精确，以至于在所有客户端软件中都能导致和谐、兼容的实现。此外，各个软件供应商出于自己的原因选择偏离规范。
- en: Let’s have a closer look at how the humble URL works in practice.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个谦逊的URL在实际中是如何工作的。
- en: Uniform Resource Locator Structure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一资源定位符结构
- en: '[Figure 2-1](ch02.html#structure_of_an_absolute_url "Figure 2-1. Structure
    of an absolute URL") shows the format of a *fully qualified absolute URL*, one
    that specifies all information required to access a particular resource and that
    does not depend in any way on where the navigation began. In contrast, a *relative
    URL*, such as *../file.php?text=hello+world*, omits some of this information and
    must be interpreted in the context of a base URL associated with the current browsing
    context.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-1](ch02.html#structure_of_an_absolute_url "图2-1. 绝对URL的结构")显示了*完全合格的绝对URL*的格式，它指定了访问特定资源所需的所有信息，并且不依赖于导航开始的任何位置。相比之下，*相对URL*，例如*../file.php?text=hello+world*省略了一些信息，并且必须在与当前浏览上下文相关的基础URL的上下文中进行解释。'
- en: '![Structure of an absolute URL](httpatomoreillycomsourcenostarchimages949989.png.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![绝对URL的结构](httpatomoreillycomsourcenostarchimages949989.png.jpg)'
- en: Figure 2-1. Structure of an absolute URL
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1. 绝对URL的结构
- en: The segments of the absolute URL seem intuitive, but each comes with a set of
    gotchas, so let’s review them now.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对URL的各个部分看起来很直观，但每个部分都伴随着一些陷阱，所以现在让我们来回顾一下。
- en: Scheme Name
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方案名称
- en: The *scheme name* is a case-insensitive string that ends with a single colon,
    indicating the protocol to be used to retrieve the resource. The official registry
    of valid URL schemes is maintained by the *Internet Assigned Numbers Authority*
    (*IANA*), a body more widely known for its management of the IP address space.^([[97](pr03.html#ftn.CHP-2-FT-4)])
    IANA’s current list of valid scheme names includes several dozen entries such
    as *http:*, *https:*, and *ftp:*; in practice, a much broader set of schemes is
    informally recognized by common browsers and third-party applications, some which
    have special security consequences. (Of particular interest are several types
    of pseudo-URLs, such as *data:* or *javascript:*, as discussed later in this chapter
    and throughout the remainder of this book.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*方案名称* 是一个不区分大小写的字符串，以单个冒号结尾，表示用于检索资源的协议。有效URL方案的官方注册由 *互联网数字分配机构* (*IANA*)
    维护，该机构更广为人知的是其对于IP地址空间的管理。[97](pr03.html#ftn.CHP-2-FT-4)] IANA当前的有效方案名称列表包括数十个条目，如
    *http:*、*https:* 和 *ftp:*；在实践中，更广泛的方案集合被常见的浏览器和第三方应用程序非正式地认可，其中一些方案具有特殊的网络安全后果。（特别值得注意的是几种伪URL类型，如
    *data:* 或 *javascript:*，这些将在本章后面和本书的其余部分进行讨论。）'
- en: 'Before they can do any further parsing, browsers and web applications need
    to distinguish fully qualified absolute URLs from relative ones. The presence
    of a valid scheme in front of the address is meant to be the key difference, as
    defined in RFC 1738: In a compliant absolute URL, only the alphanumerics “+”,
    “−”, and “.” may appear before the required “:”. In practice, however, browsers
    deviate from this guidance a bit. All ignore leading newlines and white spaces.
    Internet Explorer ignores the entire nonprintable character range of ASCII codes
    0x01 to 0x1F. Chrome additionally skips 0x00, the NUL character. Most implementations
    also ignore newlines and tabs in the middle of scheme names, and Opera accepts
    high-bit characters in the string.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何进一步的解析之前，浏览器和Web应用程序需要区分完全限定的绝对URL和相对URL。地址前存在有效方案的存在意味着这是关键的区别，如RFC 1738中定义：在一个符合规范的绝对URL中，只有字母数字“+”、“−”和“.”可以出现在必需的“:”之前。然而，在实践中，浏览器对此指导有一些偏差。所有浏览器都忽略了前导的新行和空白字符。Internet
    Explorer忽略了ASCII码0x01到0x1F的非打印字符范围。Chrome还跳过了0x00，即空字符。大多数实现也忽略了方案名称中间的新行和制表符，而Opera接受字符串中的高位字符。
- en: Because of these incompatibilities, applications that depend on the ability
    to differentiate between relative and absolute URLs must conservatively reject
    any anomalous syntax—but as we will soon find out, even this is not enough.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些不兼容性，依赖于区分相对和绝对URL的应用程序必须保守地拒绝任何异常的语法——但正如我们很快就会发现的，即使这样也不够。
- en: Indicator of a Hierarchical URL
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次化URL的指示符
- en: In order to comply with the generic syntax rules laid out in RFC 1738, every
    absolute, hierarchical URL is required to contain the fixed string “//” right
    before the authority section. If the string is missing, the format and function
    of the remainder of the URL is undefined for the purpose of that specification
    and must be treated as an opaque, scheme-specific value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合RFC 1738中规定的通用语法规则，每个绝对、层次化URL都必须包含固定字符串“//”，位于授权部分之前。如果该字符串缺失，该规范中剩余URL的格式和功能是未定义的，必须将其视为不透明的、方案特定的值。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An example of a nonhierarchical URL is the *mailto:* protocol, used to specify
    email addresses and possibly a subject line (*mailto:*[user@example.com?subject=Hello+world](mailto:user@example.com?subject=Hello+world)).
    Such URLs are passed down to the default mail client without making any further
    attempt to parse them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非层次化URL的例子是 *mailto:* 协议，用于指定电子邮件地址和可能的主题行（*mailto:*[user@example.com?subject=Hello+world](mailto:user@example.com?subject=Hello+world)）。此类URL在传递给默认邮件客户端时不会进行任何进一步的解析尝试。
- en: The concept of a generic, hierarchical URL syntax is, in theory, an elegant
    one. It ought to enable applications to extract some information about the address
    without knowing how a particular scheme works. For example, without a preconceived
    notion of the *wacky-widget:* protocol, and by applying the concept of generic
    URL syntax alone, the browser could decide that [http://example.com/test1/](http://example.com/test1/)
    and *wacky-widget://example.com/test2/* reference the same, trusted remote host.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用、分层的URL语法的概念在理论上是非常优雅的。它应该能够使应用程序在不知道特定方案如何工作的情况下提取关于地址的一些信息。例如，在没有预先设定的关于*wacky-widget:*协议的概念，仅通过应用通用URL语法的概念，浏览器可以决定[http://example.com/test1/](http://example.com/test1/)和*wacky-widget://example.com/test2/*引用的是同一个，可信任的远程主机。
- en: 'Regrettably, the specification has an interesting flaw: The aforementioned
    RFC says nothing about what the implementer should do when encountering URLs where
    the scheme is known to be nonhierarchical but where a “//” prefix still appears,
    or vice versa. In fact, a reference parser implementation provided in RFC 1630
    contains an unintentional loophole that gives a counterintuitive meaning to the
    latter class of URLs. In RFC 3986, published some years later, the authors sheepishly
    acknowledge this flaw and permit implementations to try to parse such URLs for
    compatibility reasons. As a consequence, many browsers interpret the following
    examples in unexpected ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，该规范有一个有趣的缺陷：上述RFC没有提及当遇到方案已知为非分层但仍然出现“//”前缀的URL时，实现者应该做什么，反之亦然。实际上，RFC 1630中提供的一个参考解析器实现中包含了一个无意中的漏洞，给后一类URL赋予了反直觉的含义。在几年后发布的RFC
    3986中，作者尴尬地承认了这个缺陷，并允许实现者出于兼容性原因尝试解析这样的URL。因此，许多浏览器以意想不到的方式解释了以下示例：
- en: http:example.com/ In Firefox, Chrome, and Safari, this address may be treated
    identically to [http://example.com/](http://example.com/) when no fully qualified
    base URL context exists and as a relative reference to a directory named *example.com*
    when a valid base URL is available.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http:example.com/ 在Firefox、Chrome和Safari中，当没有完全限定的基本URL上下文存在时，这个地址可能被处理成与[http://example.com/](http://example.com/)相同，当有有效的基本URL时，它被视为对名为*example.com*的目录的相对引用。
- en: javascript://example.com/%0Aalert(1) This string is interpreted as a valid nonhierarchical
    pseudo-URL in all modern browsers, and the JavaScript *alert(1)* code will execute,
    showing a simple dialog window.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javascript://example.com/%0Aalert(1) 这个字符串在所有现代浏览器中被解释为有效的非分层伪URL，并且JavaScript
    *alert(1)*代码将被执行，显示一个简单的对话框窗口。
- en: mailto://user@example.com Internet Explorer accepts this URL as a valid nonhierarchical
    reference to an email address; the “//” part is simply skipped. Other browsers
    disagree.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mailto://user@example.com Internet Explorer接受这个URL作为对电子邮件地址的有效非分层引用；“//”部分被简单地跳过。其他浏览器持不同意见。
- en: Credentials to Access the Resource
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源访问凭据
- en: The credentials portion of the URL is optional. This location can specify a
    username, and perhaps a password, that may be required to retrieve the data from
    the server. The method through which these credentials are exchanged is not specified
    as a part of the abstract URL syntax, and it is always protocol specific. For
    those protocols that do not support authentication, the behavior of a credential-bearing
    URL is simply undefined.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: URL的凭据部分是可选的。此位置可以指定一个用户名，也许还需要一个密码，这些信息可能是从服务器检索数据所必需的。这些凭据交换的方法不是抽象URL语法的组成部分，并且总是特定于协议。对于不支持认证的协议，带有凭据的URL的行为是未定义的。
- en: When no credentials are supplied, the browser will attempt to fetch the resource
    anonymously. In the case of HTTP and several other protocols, this means not sending
    any authentication data; for FTP, it involves logging into a guest account named
    *ftp* with a bogus password.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有提供凭据时，浏览器将尝试匿名获取资源。在HTTP和几个其他协议的情况下，这意味着不发送任何认证数据；对于FTP，这涉及到使用名为*ftp*的虚假密码登录到访客账户。
- en: 'Most browsers accept almost any characters, other than general URL section
    delimiters, in this section with two exceptions: Safari, for unclear reasons,
    rejects a broader set of characters, including “<”, “>”, “{”, and “}”, while Firefox
    also rejects newlines.^([[10](#ftn.CHP-2-FN-1)])'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器接受除了一般URL部分分隔符之外几乎任何字符，在这个部分有两个例外：由于不明原因，Safari拒绝了一组更广泛的字符，包括“<”，“>”，“{”，和“}”，而Firefox也拒绝换行符.^([[10](#ftn.CHP-2-FN-1)])
- en: Server Address
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器地址
- en: For all fully qualified hierarchical URLs, the server address section must specify
    a case-insensitive DNS name (such as *example.com*), a raw IPv4 address (such
    as *127.0.0.1*), or an IPv6 address in square brackets (such as *[0:0:0:0:0:0:0:1]*),
    indicating the location of a server hosting the requested resource. Firefox will
    also accept IPv4 addresses and hostnames in square brackets, but other implementations
    reject them immediately.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有完全限定的分层URL，服务器地址部分必须指定一个不区分大小写的DNS名称（例如 *example.com*），一个原始IPv4地址（例如 *127.0.0.1*），或一个方括号中的IPv6地址（例如
    *[0:0:0:0:0:0:0:1]*），以指示托管请求资源的服务器位置。Firefox也将接受方括号中的IPv4地址和主机名，但其他实现会立即拒绝它们。
- en: 'Although the RFC permits only canonical notations for IP addresses, standard
    C libraries used by most applications are much more relaxed, accepting noncanonical
    IPv4 addresses that mix octal, decimal, and hexadecimal notation or concatenate
    some or all of the octets into a single integer. As a result, the following options
    are recognized as equivalent:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RFC只允许IP地址的规范表示法，但大多数应用程序使用的标准C库要宽松得多，接受混合八进制、十进制和十六进制表示的非规范IPv4地址，或者将某些或所有八位字节连接成一个单一整数。因此，以下选项被视为等效：
- en: http://127.0.0.1/ This is a canonical representation of an IPv4 address.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://127.0.0.1/ 这是IPv4地址的一个规范表示。
- en: http://0x7f.1/ This is a representation of the same address that uses a hexadecimal
    number to represent the first octet and concatenates all the remaining octets
    into a single decimal value.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://0x7f.1/ 这是一种使用十六进制数表示第一个八位字节，并将所有剩余的八位字节连接成一个单一十进制值的地址表示。
- en: http://017700000001/ The same address is denoted using a 0-prefixed octal value,
    with all octets concatenated into a single 32-bit integer.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://017700000001/ 使用0前缀的八进制值表示相同的地址，所有八位字节连接成一个单一的32位整数。
- en: A similar laid-back approach can be seen with DNS names. Theoretically, DNS
    labels need to conform to a very narrow character set (specifically, alphanumerics,
    “.”, and “-”, as defined in RFC 1035^([[98](pr03.html#ftn.CHP-2-FT-5)])), but
    many browsers will happily ask the underlying operating system resolver to look
    up almost anything, and the operating system will usually also not make a fuss.
    The exact set of characters accepted in the hostname and passed to the resolver
    varies from client to client. Safari is most rigorous, while Internet Explorer
    is the most permissive. Perhaps of note, several control characters in the 0x0A-0x0D
    and 0xA0-0xAD ranges are ignored by most browsers in this portion of the URL.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的轻松态度也可以在DNS名称中看到。理论上，DNS标签需要符合一个非常窄的字符集（具体来说，是字母数字、“.”和“-”，如RFC 1035定义），但许多浏览器都会愉快地请求底层操作系统的解析器查找几乎任何内容，而操作系统通常也不会对此大惊小怪。主机名和传递给解析器的字符集的确切集合因客户端而异。Safari最为严格，而Internet
    Explorer最为宽容。值得注意的是，0x0A-0x0D和0xA0-0xAD范围内的几个控制字符在大多数浏览器中在这个URL部分被忽略。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One fascinating behavior of the URL parsers in all of the mainstream browsers
    is their willingness to treat the character “![](httpatomoreillycomsourcenostarchimages949991.png)”
    (ideographic full stop, Unicode point U+3002) identically to a period in hostnames
    but not anywhere else in the URL. This is reportedly because certain Chinese keyboard
    mappings make it much easier to type this symbol than the expected 7-bit ASCII
    value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个令人着迷的行为是所有主流浏览器中的URL解析器都愿意将字符“![](httpatomoreillycomsourcenostarchimages949991.png)”（汉字句号，Unicode点U+3002）与主机名中的句点同等对待，但在URL的其他地方则不是。据报道，这是因为某些中文键盘映射使得输入这个符号比预期的7位ASCII值要容易得多。
- en: Server Port
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端口
- en: This server port is an optional section that describes a nonstandard network
    port to connect to on the previously specified server. Virtually all application-level
    protocols supported by browsers and third-party applications use TCP or UDP as
    the underlying transport method, and both TCP and UDP rely on 16-bit port numbers
    to separate traffic between unrelated services running on a single machine. Each
    scheme is associated with a default port on which servers for that protocol are
    customarily run (80 for HTTP, 21 for FTP, and so on), but the default can be overridden
    at the URL level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器端口是一个可选部分，描述了在之前指定的服务器上连接的非标准网络端口。几乎所有的浏览器和第三方应用程序支持的应用层协议都使用TCP或UDP作为底层传输方法，而TCP和UDP都依赖于16位端口号来区分运行在单个机器上的无关服务之间的流量。每个方案都与该协议服务器通常运行的默认端口相关联（HTTP为80，FTP为21等），但默认值可以在URL级别被覆盖。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An interesting and unintended side effect of this feature is that browsers can
    be tricked into sending attacker-supplied data to random network services that
    do not speak the protocol the browser expects them to. For example, one may point
    a browser to [http://mail.example.com:25/](http://mail.example.com:25/), where
    25 is a port used by the Simple Mail Transfer Protocol (SMTP) service rather than
    HTTP. This fact has caused a range of security problems and prompted a number
    of imperfect workarounds, as discussed in more detail in [Part II](pt02.html "Part II. Browser
    Security Features") of this book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性的一个有趣且未预料到的副作用是，浏览器可以被欺骗，向随机网络服务发送攻击者提供的数据，而这些服务并不使用浏览器期望它们使用的协议。例如，可以将浏览器指向
    [http://mail.example.com:25/](http://mail.example.com:25/)，其中25是Simple Mail Transfer
    Protocol (SMTP)服务使用的端口，而不是HTTP。这一事实导致了各种安全问题，并促使许多不完美的解决方案，这些解决方案在本书的[第二部分](pt02.html
    "第二部分。浏览器安全特性")中进行了更详细的讨论。
- en: Hierarchical File Path
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次化文件路径
- en: The next portion of the URL, the hierarchical file path, is envisioned as a
    way to identify a specific resource to be retrieved from the server, such as */documents/2009/my_diary.txt*.
    The specification quite openly builds on top of the Unix directory semantics,
    mandating the resolution of “/../” and “/./” segments in the path and providing
    a directory-based method for sorting out relative references in non-fully qualified
    URLs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: URL的下一部分，即层次化文件路径，设想为识别要从服务器检索的特定资源的一种方式，例如 */documents/2009/my_diary.txt*。规范相当明确地建立在Unix目录语义之上，要求解析路径中的“/../”和“/./”段，并为非完全限定的URL中的相对引用提供基于目录的方法。
- en: Using the filesystem model must have seemed like a natural choice in the 1990s,
    when web servers acted as simple gateways to a collection of static files and
    the occasional executable script. But since then, many contemporary web application
    frameworks have severed any remaining ties with the filesystem, interfacing directly
    with database objects or registered locations in resident program code. Mapping
    these data structures to well-behaved URL paths is possible but not always practiced
    or practiced carefully. All of this makes automated content retrieval, indexing,
    and security testing more complicated than it should be.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代，使用文件系统模型似乎是一个自然的选择，当时网络服务器只是作为一组静态文件和偶尔的执行脚本的简单网关。但自那时起，许多当代网络应用程序框架已经切断了与文件系统的任何剩余联系，直接与数据库对象或驻留程序代码中注册的位置进行交互。将这些数据结构映射到良好的URL路径是可能的，但并不总是实践或谨慎实践。所有这些都使得自动内容检索、索引和安全测试比应有的要复杂。
- en: Query String
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询字符串
- en: 'The query string is an optional section used to pass arbitrary, nonhierarchical
    parameters to the resource earlier identified by the path. One common example
    is passing user-supplied terms to a server-side script that implements the search
    functionality, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串是一个可选部分，用于将任意、非层次化的参数传递给路径中先前标识的资源。一个常见的例子是将用户提供的术语传递给实现搜索功能的服务器端脚本，例如：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most web developers are accustomed to a particular layout of the query string;
    this familiar format is generated by browsers when handling HTML-based forms and
    follows this syntax:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络开发者习惯于查询字符串的特定布局；这种熟悉的格式是由浏览器在处理基于HTML的表单时生成的，遵循以下语法：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Surprisingly, such layout is not mandated in the URL RFCs. Instead, the query
    string is treated as an opaque blob of data that may be interpreted by the final
    recipient as it sees fit, and unlike the path, it is not encumbered with specific
    parsing rules.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这种布局在URL RFCs中并没有被强制要求。相反，查询字符串被视为一个不透明的数据块，最终接收者可以按照自己的理解进行解释，而且与路径不同，它没有特定的解析规则的限制。
- en: Hints of the commonly used format can be found in an informational RFC 1630,^([[99](pr03.html#ftn.CHP-2-FT-6)])
    in a mail-related RFC 2368,^([[100](pr03.html#ftn.CHP-2-FT-7)]) and in HTML specifications
    dealing with forms.^([[101](pr03.html#ftn.CHP-2-FT-8)]) None of this is binding,
    and therefore, while it may be impolite, it is not a mistake for web applications
    to employ arbitrary formats for whatever data they wish to put in that part of
    the URL.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 常用格式的提示可以在信息RFC 1630中找到，这是一个与邮件相关的RFC 2368，以及处理表单的HTML规范中。[^([[99](pr03.html#ftn.CHP-2-FT-6)])][^([[100](pr03.html#ftn.CHP-2-FT-7)])][^([[101](pr03.html#ftn.CHP-2-FT-8)])]
    这一切都是非约束性的，因此，尽管这可能不太礼貌，但网络应用程序为URL的这一部分使用任意格式并不是错误。
- en: Fragment ID
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段ID
- en: The fragment ID is an opaque value with a role similar to the query string but
    that provides optional instructions for the client application rather than the
    server. (In fact, the value is not supposed to be sent to the server at all.)
    Neither the format nor function of the fragment ID is clearly specified in the
    RFCs, but it is hinted that it may be used to address “subresources” in the retrieved
    document or to provide other document-specific rendering cues.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 片段 ID 是一个不透明的值，其角色类似于查询字符串，但为客户端应用程序提供可选的指令而不是服务器。（实际上，这个值根本不应该发送到服务器。）片段 ID
    的格式和功能在 RFCs 中没有明确规定，但暗示它可以用来定位检索到的文档中的“子资源”或提供其他文档特定的渲染提示。
- en: 'In practice, fragment identifiers have only a single sanctioned use in the
    browser: that of specifying the name of an anchor HTML element for in-document
    navigation. The logic is simple. If an anchor name is supplied in the URL and
    a matching HTML tag can be located, the document will be scrolled to that location
    for viewing; otherwise, nothing happens. Because the information is encoded in
    the URL, this particular view of a lengthy document could be easily shared with
    others or bookmarked. In this use, the meaning of a fragment ID is limited to
    scrolling an existing document, so there is no need to retrieve any new data from
    the server when only this portion of the URL is updated in response to user actions.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在浏览器中，片段标识符只有一个官方用途：指定文档中锚点 HTML 元素的名称，用于文档内导航。逻辑很简单。如果 URL 中提供了锚点名称并且可以找到匹配的
    HTML 标签，则文档将滚动到该位置进行查看；否则，不会发生任何操作。由于信息编码在 URL 中，因此可以轻松与他人共享或书签这种长文档的特定视图。在这种情况下，片段
    ID 的含义仅限于滚动现有文档，因此当仅更新 URL 的这部分以响应用户操作时，无需从服务器检索任何新数据。
- en: 'This interesting property has led to another, more recent and completely ad
    hoc use of this value: to store miscellaneous state information needed by client-side
    scripts. For example, consider a map-browsing application that puts the currently
    viewed map coordinates in the fragment identifier so that it will know to resume
    from that same location if the link is bookmarked or shared. Unlike updating the
    query string, changing the fragment ID on-the-fly will not trigger a time-consuming
    page reload, making this data-storage trick a killer feature.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有趣的属性导致了另一种更近期的、完全临时的使用：存储客户端脚本所需的杂项状态信息。例如，考虑一个地图浏览应用程序，它将当前查看的地图坐标放在片段标识符中，以便在链接被书签或分享时知道从该位置恢复。与更新查询字符串不同，即时更改片段
    ID 不会触发耗时的页面重新加载，这使得这种数据存储技巧成为一个杀手级功能。
- en: Putting It All Together Again
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次将所有内容组合在一起
- en: 'Each of the aforementioned URL segments is delimited by certain reserved characters:
    slashes, colons, question marks, and so on. To make the whole approach usable,
    these delimiting characters should not appear anywhere in the URL for any other
    purpose. With this assumption in mind, imagine a sample algorithm to split absolute
    URLs into the aforementioned functional parts in a manner at least vaguely consistent
    with how browsers accomplish this task. A reasonably decent example of such an
    algorithm could be:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述的每个 URL 段落都由某些保留字符分隔：斜杠、冒号、问号等。为了使整个方法可用，这些分隔字符不应出现在 URL 的任何其他目的中。基于这个假设，想象一个示例算法，将绝对
    URL 分割成上述功能部分，至少在某种程度上与浏览器完成此任务的方式一致。这样一个相当合理的算法示例可能是：
- en: '**STEP 1: Extract the scheme name**.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1：提取方案名称**。'
- en: Scan for the first “:” character. The part of the URL to its left is the scheme
    name. Bail out if the scheme name does not conform to the expected set of characters;
    the URL may need to be treated as a relative one if so.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 查找第一个“:”字符。URL 左侧的部分是方案名称。如果方案名称不符合预期的字符集，则退出；如果这样，URL 可能需要被当作相对 URL 处理。
- en: '**STEP 2: Consume the hierarchical URL identifier**.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2：消费层次 URL 标识符**。'
- en: The string “//” should follow the scheme name. Skip it if found; bail out if
    not.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 方案名称之后应该跟着字符串“//”。如果找到它，则跳过；如果没有找到，则退出。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some parsing contexts, implementations will be just as happy with zero, one,
    or even three or more slashes instead of two, for usability reasons. In the same
    vein, from its inception, Internet Explorer accepted backslashes (\) in lieu of
    slashes in any location in the URL, presumably to assist inexperienced users.^([[11](#ftn.CHP-2-FN-2)])
    All browsers other than Firefox eventually followed this trend and recognize URLs
    such as *http:\\example.com\*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些解析上下文中，为了提高可用性，实现可能会接受零个、一个甚至三个或更多斜杠而不是两个。同样，从其诞生之初，Internet Explorer 就接受在
    URL 的任何位置使用反斜杠 (\) 代替斜杠，这可能是为了帮助不熟练的用户.^([[11](#ftn.CHP-2-FN-2)]) 除了 Firefox 之外的所有浏览器最终都跟随了这个趋势，并识别了如
    *http:\\example.com\* 这样的 URL。
- en: '**STEP 3: Grab the authority section**.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3：获取权限部分**。'
- en: Scan for the next “/”, “?”, or “#”, whichever comes first, to extract the authority
    section from the URL. As mentioned above, most browsers will also accept “\” as
    a delimiter in place of a forward slash, which may need to be accounted for. The
    semicolon (;) is another acceptable authority delimiter in browsers other than
    Internet Explorer and Safari; the reason for this decision is unknown.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描下一个“/”、“?”或“#”，以从 URL 中提取权限部分。如上所述，大多数浏览器也会接受“\”作为正斜杠的替代分隔符，这可能需要考虑。分号 (;)
    也是除 Internet Explorer 和 Safari 之外浏览器中可接受的权限分隔符；做出这一决定的原因尚不清楚。
- en: '**STEP 3A: Find the credentials, if any**.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3A：查找凭证（如果存在）**。'
- en: Once the authority section is extracted, locate the at symbol (@) in the substring.
    If found, the leading snippet constitutes login credentials, which should be further
    tokenized at the first occurrence of a colon (if present) to split the login and
    password data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提取了权限部分，在子字符串中定位到符号 (@)。如果找到，则前导片段构成登录凭证，应进一步在第一个冒号（如果存在）处进行标记，以分割登录和密码数据。
- en: '**STEP 3B: Extract the destination address**.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3B：提取目标地址**。'
- en: The remainder of the authority section is the destination address. Look for
    the first colon to separate the hostname from the port number. A special case
    is needed for bracket-enclosed IPv6 addresses, too.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 权限部分的其余部分是目标地址。寻找第一个冒号以将主机名与端口号分开。对于括号内的 IPv6 地址也需要一个特殊情况。
- en: '**STEP 4: Identify the path (if present)**.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4：识别路径（如果存在）**。'
- en: If the authority section is followed immediately by a forward slash—or for some
    implementations, a backslash or semicolon, as noted earlier—scan for the next
    “?”, “#”, or end-of-string, whichever comes first. The text in between constitutes
    the path section, which should be normalized according to Unix path semantics.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果权限部分后面紧跟着一个正斜杠——或者在某些实现中，如前所述，一个反斜杠或分号，扫描下一个“?”、“#”或字符串末尾，以先到者为准。中间的文本构成路径部分，应根据
    Unix 路径语义进行标准化。
- en: '**STEP 5: Extract the query string (if present)**.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5：提取查询字符串（如果存在）**。'
- en: If the last successfully parsed segment is followed by a question mark, scan
    for the next “#” character or end-of-string, whichever comes first. The text in
    between is the query string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一个成功解析的段后面跟着一个问号，扫描下一个“#”字符或字符串末尾，以先到者为准。中间的文本是查询字符串。
- en: '**STEP 6: Extract the fragment identifier (if present)**.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 6：提取片段标识符（如果存在）**。'
- en: If the last successfully parsed segment is followed by “#”, everything from
    that character to the end-of-string is the fragment identifier. Either way, you’re
    done!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一个成功解析的段后面跟着“#”，则从该字符到字符串末尾的所有内容都是片段标识符。无论如何，你就可以完成了！
- en: 'This algorithm may seem mundane, but it reveals subtle details that even seasoned
    programmers normally don’t think about. It also illustrates that it is extremely
    difficult for casual users to understand how a particular URL may be parsed. Let''s
    start with this fairly simple case:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可能看起来很平凡，但它揭示了即使是经验丰富的程序员通常也不会考虑的微妙细节。它还说明了对于普通用户来说，理解特定 URL 的解析方式极其困难。让我们从一个相当简单的情况开始：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The target of this URL—a concatenated IP address that decodes to 10.0.0.1—is
    not readily apparent to a nonexpert, and many users would believe they are visiting
    *example.com* instead.^([[12](#ftn.CHP-2-FN-3)]) But all right, that was an easy
    one! So let’s have a peek at this syntax instead:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 的目标——一个解码为 10.0.0.1 的连续 IP 地址——对于一个非专家来说并不明显，许多用户会认为他们正在访问 *example.com*，而不是其他地址.^([[12](#ftn.CHP-2-FN-3)])
    好吧，那是一个简单的例子！那么，让我们来看看这个语法：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Firefox, that URL will take the user to *coredump.cx*, because *example.com\*
    will be interpreted as a valid value for the login field. In almost all other
    browsers, “\” will be interpreted as a path delimiter, and the user will land
    on *example.com* instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Firefox 中，该 URL 将用户带到 *coredump.cx*，因为 *example.com\* 被解释为登录字段的合法值。在几乎所有其他浏览器中，“\”
    被解释为路径分隔符，用户将到达 *example.com*。
- en: 'An even more frustrating example exists for Internet Explorer. Consider this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Internet Explorer，还有一个更加令人沮丧的例子。考虑以下情况：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Microsoft’s browser permits “;” in the hostname and successfully resolves this
    label, thanks to the appropriate configuration of the *coredump.cx* domain. Most
    other browsers will autocorrect the URL to *http://example.com/;.coredump.cx*
    and take the user to *example.com* instead (except for Safari, where the syntax
    causes an error). If this looks messy, remember that we are just getting started
    with how browsers work!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的浏览器允许在主机名中使用“;”，并且由于 *coredump.cx* 域的适当配置，成功解析了这个标签。大多数其他浏览器会自动更正 URL 为 *http://example.com/;.coredump.cx*
    并将用户带到 *example.com*（Safari 除外，那里的语法会导致错误）。如果这看起来很混乱，请记住，我们只是刚开始了解浏览器的工作方式！
- en: '* * *'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[10](#CHP-2-FN-1)]) This is possibly out of the concern for FTP, which transmits
    user credentials without any encoding; in this protocol, a newline transmitted
    as is would be misinterpreted by the server as the beginning of a new FTP command.
    Other browsers may transmit FTP credentials in noncompliant percent-encoded form
    or simply strip any problematic characters later on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#CHP-2-FN-1)]) 这可能是出于对 FTP 的担忧，FTP 在传输用户凭据时没有进行编码；在这个协议中，作为 FTP 命令开始的换行符会被服务器错误地解释。其他浏览器可能会以不合规的百分号编码形式传输
    FTP 凭据，或者简单地删除任何有问题的字符。
- en: ^([[11](#CHP-2-FN-2)]) Unlike UNIX-derived operating systems, Microsoft Windows
    uses backslashes instead of slashes to delimit file paths (say, *c:\windows\system32\calc.exe*).
    Microsoft probably tried to compensate for the possibility that users would be
    confused by the need to type a different type of a slash on the Web or hoped to
    resolve other possible inconsistencies with *file:* URLs and similar mechanisms
    that would be interfacing directly with the local filesystem. Other Windows filesystem
    specifics (such as case insensitivity) are not replicated, however.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#CHP-2-FN-2)]) 与基于 UNIX 的操作系统不同，Microsoft Windows 使用反斜杠而不是斜杠来分隔文件路径（例如，*c:\windows\system32\calc.exe*）。微软可能试图通过用户在网络上需要输入不同类型的斜杠而感到困惑的可能性来补偿，或者希望解决与
    *file:* URL 和类似机制的其他可能的矛盾，这些机制将直接与本地文件系统交互。然而，其他 Windows 文件系统特定的内容（如不区分大小写）并未复制。
- en: ^([[12](#CHP-2-FN-3)]) This particular @-based trick was quickly embraced to
    facilitate all sorts of online fraud targeted at casual users. Attempts to mitigate
    its impact ranged from the heavy-handed and oddly specific (e.g., disabling URL-based
    authentication in Internet Explorer or crippling it with warnings in Firefox)
    to the fairly sensible (e.g., hostname highlighting in the address bar of several
    browsers).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#CHP-2-FN-3)]) 这种基于 @ 的技巧很快就被接受，以方便各种针对普通用户的在线欺诈。减轻其影响的尝试从重手和奇怪的具体措施（例如，在
    Internet Explorer 中禁用基于 URL 的身份验证或在 Firefox 中通过警告来削弱它）到相当合理的措施（例如，在几个浏览器的地址栏中突出显示主机名）。
- en: Reserved Characters and Percent Encoding
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留字符和百分号编码
- en: 'The URL-parsing algorithm outlined in the previous section relies on the assumption
    that certain reserved, syntax-delimiting characters will not appear literally
    in the URL in any other capacity (that is, they won’t be a part of the username,
    request path, and so on). These generic, syntax-disrupting delimiters are:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节中概述的 URL 解析算法依赖于这样一个假设，即某些保留的、用于语法分隔的字符不会以任何其他形式出现在 URL 中（也就是说，它们不会是用户名、请求路径的一部分等）。这些通用的、破坏语法的分隔符是：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The RFC also names a couple of lower-tier delimiters without giving them any
    specific purpose, presumably to allow scheme- or application-specific features
    to be implemented within any of the top-level sections:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 还提到了一些低级别的分隔符，但没有为它们指定任何特定用途，这可能是为了允许在顶级部分的任何部分实现方案或应用特定的功能：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All of the above characters are in principle off-limits, but there are legitimate
    cases where one would want to include them in the URL (for example, to accommodate
    arbitrary search terms entered by the user and passed to the server in the query
    string). Therefore, rather than ban them, the standard provides a method to encode
    all spurious occurrences of these values. The method, simply called *percent encoding*
    or *URL encoding*, substitutes characters with a percent sign (`%`) followed by
    two hexadecimal digits representing a matching ASCII value. For example, “`/`”
    will be encoded as *%2F* (uppercase is customary but not enforced). It follows
    that to avoid ambiguity, the naked percent sign itself must be encoded as *%25*.
    Any intermediaries that handle existing URLs (browsers and web applications included)
    are further compelled never to attempt to decode or encode reserved characters
    in relayed URLs, because the meaning of such a URL may suddenly change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述字符原则上都是禁止使用的，但在某些合法情况下，人们可能希望将它们包含在URL中（例如，为了适应用户输入的任意搜索词，并通过查询字符串传递给服务器）。因此，而不是禁止它们，标准提供了一种方法来编码所有这些值的虚假出现。这种方法简单地称为*百分编码*或*URL编码*，用百分号（%）后跟表示匹配ASCII值的两个十六进制数字来替换字符。例如，“/”将被编码为*%2F*（大写是惯例但不是强制性的）。因此，为了避免歧义，裸百分号本身必须编码为*%25*。任何处理现有URL的中介（包括浏览器和Web应用程序）都进一步被迫不得尝试解码或编码传递的URL中的保留字符，因为这样的URL的含义可能会突然改变。
- en: Regrettably, the immutability of reserved characters in existing URLs is at
    odds with the need to respond to any URLs that are technically illegal because
    they misuse these characters and that are encountered by the browser in the wild.
    This topic is not covered by the specifications at all, which forces browser vendors
    to improvise and causes cross-implementation inconsistencies. For example, should
    the URL *http://a@b@c/* be translated to *http://a@b%40c/* or perhaps to *http://a%40b@c/*?
    Internet Explorer and Safari think the former makes more sense; other browsers
    side with the latter view.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 殊为遗憾，现有URL中保留字符的不可变性与其需要响应任何技术上非法的URL的需求相矛盾，因为这些URL错误地使用了这些字符，并且在浏览器中遇到。这个主题在规范中完全没有涉及，这迫使浏览器供应商进行临时改进，并导致跨实现不一致。例如，URL
    *http://a@b@c/* 应该被转换为 *http://a@b%40c/* 还是可能转换为 *http://a%40b@c/*？Internet Explorer和Safari认为前者更有意义；其他浏览器则支持后者观点。
- en: The remaining characters not in the reserved set are not supposed to have any
    particular significance within the URL syntax itself. However, some (such as nonprintable
    ASCII control characters) are clearly incompatible with the idea that URLs should
    be human readable and transport-safe. Therefore, the RFC outlines a confusingly
    named subset of *unreserved* characters (consisting of alphanumerics, “`-`”, “`.`”,
    “`_`”, and “`˜`”) and says that only this subset and the reserved characters in
    their intended capacity are formally allowed to appear in the URL as is.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在保留集合之外的字符在URL语法本身中不应有任何特定的意义。然而，其中一些（如不可打印的ASCII控制字符）显然与URL应该是人类可读和传输安全的理念不相符。因此，RFC概述了一个名为*未保留*字符的子集（包括字母数字，“-”，“.”，“_”和“~”），并表示只有这个子集以及它们在预期用途中的保留字符正式允许出现在URL中。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Curiously, these unreserved characters are only *allowed* to appear in an unescaped
    form; they are not *required* to do so. User agents may encode or decode them
    at whim, and doing so does not change the meaning of the URL at all. This property
    brings up yet another way to confuse users: the use of noncanonical representations
    of unreserved characters. Specifically, all of the following are equivalent:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，这些未保留字符仅*允许*以未转义的形式出现；它们不是*必须*这样做。用户代理可以随意编码或解码它们，这样做并不会改变URL的含义。这种属性提出了另一种混淆用户的方法：使用未规范化的未保留字符表示。具体来说，以下所有表示都是等效的：
- en: '[http://example.com/](http://example.com/)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://example.com/](http://example.com/)'
- en: '*http://%65xample.%63om/*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*http://example.com/*'
- en: '*http://%65%78%61%6d%70%6c%65%2e%63%6f%6d/*^([[13](#ftn.CHP-2-FN-4)])'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*http://example.com/*^([[13](#ftn.CHP-2-FN-4)])'
- en: A number of otherwise nonreserved, printable characters are excluded from the
    so-called unreserved set. Because of this, strictly speaking, the RFCs require
    them to be unconditionally percent encoded. However, since browsers are not explicitly
    tasked with the enforcement of this rule, it is not taken very seriously. In particular,
    all browsers allow “`^`”, “`{`”, “`|`”, and “`}`” to appear in URLs without escaping
    and will send these characters to the server as is. Internet Explorer further
    permits “`<`”, “`>`”, and “`` ` ``” to go through; Internet Explorer, Firefox,
    and Chrome all accept “`\`”; Chrome and Internet Explorer will permit a double
    quote; and Opera and Internet Explorer both pass the nonprintable character 0x7F
    (DEL) as is.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些本应非保留的可打印字符被排除在所谓的非保留集之外。因此，严格来说，RFC要求它们无条件地进行百分编码。然而，由于浏览器没有明确负责执行这项规则，所以它并没有被认真对待。特别是，所有浏览器都允许“`^`”、“`{`”、“`|`”和“`}`”出现在URL中而不进行转义，并将这些字符原样发送到服务器。Internet
    Explorer进一步允许“`<`”、“`>`”和“`` ` ``”通过；Internet Explorer、Firefox和Chrome都接受“`\`”；Chrome和Internet
    Explorer将允许双引号；而Opera和Internet Explorer都允许非打印字符0x7F（DEL）原样通过。
- en: Lastly, contrary to the requirements spelled out in the RFC, most browsers also
    do not encode fragment identifiers at all. This poses an unexpected challenge
    to client-side scripts that rely on this string and expect certain potentially
    unsafe characters never to appear literally. We will revisit this topic in [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与RFC中明确要求的内容相反，大多数浏览器甚至根本不对片段标识符进行编码。这对依赖于这个字符串并期望某些潜在不安全的字符永远不会以字面形式出现的客户端脚本构成了一个意想不到的挑战。我们将在[第6章](ch06.html
    "第6章。浏览器端脚本")中重新探讨这个话题。
- en: Handling of Non-US-ASCII Text
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非US-ASCII文本的处理
- en: Many languages used around the globe rely on characters outside the basic, 7-bit
    ASCII character set or the default 8-bit code page traditionally used by all PC-compatible
    systems (CP437). Heck, some languages depend on alphabets that are not based on
    Latin at all.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 全球许多语言依赖于基本7位ASCII字符集之外的字符，或者依赖于所有PC兼容系统传统上使用的默认8位代码页（CP437）。实际上，一些语言依赖于根本不是基于拉丁字母的字母表。
- en: 'In order to accommodate the needs of an often-ignored but formidable non-English
    user base, various 8-bit code pages with an alternative set of high-bit characters
    were devised long before the emergence of the Web: ISO 8859-1, CP850, and Windows
    1252 for Western European languages; ISO 8859-2, CP852, and Windows 1250 for Eastern
    and Central Europe; and KOI8-R and Windows 1251 for Russia. And, because several
    alphabets could not be accommodated in the 256-character space, we saw the rise
    of complex variable-width encodings, such as Shift JIS for katakana.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足一个经常被忽视但强大的非英语用户群体的需求，在Web出现之前就设计了各种带有替代高比特字符集的8位代码页：ISO 8859-1、CP850和Windows
    1252用于西欧语言；ISO 8859-2、CP852和Windows 1250用于东欧和中欧；KOI8-R和Windows 1251用于俄罗斯。而且，由于几个字母表无法适应256字符的空间，我们看到了复杂变宽编码的兴起，例如Shift
    JIS用于片假名。
- en: The incompatibility of these character maps made it difficult to exchange documents
    between computers configured for different code pages. By the early 1990s, this
    growing problem led to the creation of *Unicode*—a sort of universal character
    set, too large to fit within 8 bits but meant to encompass practically all regional
    scripts and specialty pictographs known to man. Unicode was followed by UTF-8,
    a relatively simple, variable-width representation of these characters, which
    was theoretically safe for all applications capable of handling traditional 8-bit
    formats. Unfortunately, UTF-8 required more bytes to encode high-bit characters
    than did most of its competitors, and to many users, this seemed wasteful and
    unnecessary. Because of this criticism, it took well over a decade for UTF-8 to
    gain traction on the Web, and it only did so long after all the relevant protocols
    had solidified.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符映射的不兼容性使得在不同代码页配置的计算机之间交换文档变得困难。到20世纪90年代初，这个日益增长的问题导致了*Unicode*的创建——一种几乎可以包含人类已知所有区域脚本和专业象形文字的通用字符集。Unicode之后是UTF-8，这是一种相对简单、变宽的字符表示形式，理论上对能够处理传统8位格式的所有应用程序都是安全的。不幸的是，UTF-8编码高比特字符所需的字节数比大多数竞争对手都要多，对许多用户来说，这似乎是浪费且不必要的。由于这种批评，UTF-8在Web上获得认可花了十多年时间，而且是在所有相关协议都巩固之后才实现的。
- en: 'This unfortunate delay had some bearing on the handling of URLs that contain
    user input. Browsers needed to accommodate such use very early on, but when the
    developers turned to the relevant standards, they found no meaningful advice.
    Even years later, in 2005, the RFC 3986 had just this to say:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个不幸的延迟对处理包含用户输入的URL的处理产生了一定的影响。浏览器需要很早就适应这种使用，但当开发者转向相关标准时，他们发现没有有意义的建议。甚至多年以后，在2005年，RFC
    3986也只有以下内容：
- en: In local or regional contexts and with improving technology, users might benefit
    from being able to use a wider range of characters; such use is not defined by
    this specification.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本地或区域环境中，以及随着技术的改进，用户可能会从能够使用更广泛的字符中受益；这种使用并未由本规范定义。
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Percent-encoded octets . . . may be used within a URI to represent characters
    outside the range of the US-ASCII coded character set if this representation is
    allowed by the scheme or by the protocol element in which the URI is referenced.
    Such a definition should specify the character encoding used to map those characters
    to octets prior to being percent-encoded for the URI.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 百分比编码的八位字节……可以在URI中使用，以表示超出US-ASCII编码字符集范围的字符，如果这种表示由方案或URI引用中的协议元素允许。这样的定义应指定用于将那些字符映射到八位字节并在进行URI百分比编码之前进行编码的字符编码。
- en: Alas, despite this wishful thinking, none of the remaining standards addressed
    this topic. It was always possible to put raw high-bit characters in a URL, but
    without knowing the code page they should be interpreted in, the server would
    not be able to tell if that *%B1* was supposed to mean “±”, “ą”, or some other
    squiggly character specific to the user’s native script.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 悲哉，尽管有这种美好的愿望，但剩余的标准都没有解决这个问题。始终可以将原始高位字符放入URL中，但如果没有知道它们应该解释的代码页，服务器将无法判断那个*%B1*是否应该表示“±”、“ą”或用户母语脚本中的一些其他波浪形字符。
- en: Sadly, browser vendors have not taken the initiative and come up with a consistent
    solution to this problem. Most browsers internally transcode URL path segments
    to UTF-8 (or ISO 8859-1, if sufficient), but then they generate the query string
    in the code page of the referring page instead. In certain cases, when URLs are
    entered manually or passed to certain specialized APIs, high-bit characters may
    be also downgraded to their 7-bit US-ASCII look-alikes, replaced with question
    marks, or even completely mangled due to implementation flaws.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，浏览器供应商没有采取主动行动，提出一个一致的解决方案来解决这个问题。大多数浏览器在内部将URL路径段转码为UTF-8（或者在足够的情况下，为ISO
    8859-1），但随后它们在引用页面的代码页中生成查询字符串。在某些情况下，当URL是手动输入或传递给某些专用API时，高位字符也可能被降级为其7位US-ASCII相似字符，用问号替换，或者由于实现缺陷而完全损坏。
- en: 'Poorly implemented or not, the ability to pass non-English characters in query
    strings and paths scratched an evident itch. The traditional percent-encoding
    approach left just one URL segment completely out in the cold: High-bit input
    could not be allowed as is when specifying the name of the destination server,
    because at least in principle, the well-established DNS standard permitted only
    period-delimited alphanumerics and dashes to appear in domain names—and while
    nobody adhered to the rules, the set of exceptions varied from one name server
    to another.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实现得多么糟糕，将非英语字符传递到查询字符串和路径中的能力都满足了明显的需求。传统的百分比编码方法只让一个URL段完全处于不利地位：在指定目标服务器名称时，不允许直接使用高位输入，因为至少在原则上，已经建立的标准DNS仅允许点分隔的字母数字和破折号出现在域名中——尽管没有人遵守规则，但例外情况因名称服务器而异。
- en: An astute reader might wonder why this limitation would matter; that is, why
    was it important to have localized domain names in non-Latin alphabets, too? That
    question may be difficult to answer now. Quite simply, several folks thought a
    lack of these encodings would prevent businesses and individuals around the world
    from fully embracing and enjoying the Web—and, rightly or not, they were determined
    to make it happen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的读者可能会想知道为什么这种限制很重要；也就是说，为什么在非拉丁字母表中也要有本地化域名？这个问题现在可能很难回答。简单地说，有几个人认为缺乏这些编码将阻止全球的企业和个人完全拥抱和享受互联网——而且，无论对错，他们都决心让它成为现实。
- en: 'This pursuit led to the formation of the Internationalized Domain Names in
    Applications (IDNA). First, RFC 3490,^([[102](pr03.html#ftn.CHP-2-FT-9)]) which
    outlined a rather contrived scheme to encode arbitrary Unicode strings using alphanumerics
    and dashes, and then RFC 3492,^([[103](pr03.html#ftn.CHP-2-FT-10)]) which described
    a way to apply this encoding to DNS labels using a format known as *Punycode*.
    Punycode looked roughly like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种追求导致了应用程序中国际化域名（IDNA）的形成。首先，RFC 3490，^([[102](pr03.html#ftn.CHP-2-FT-9)])概述了一个相当复杂的方案，用于使用字母数字和破折号对任意Unicode字符串进行编码，然后是RFC
    3492，^([[103](pr03.html#ftn.CHP-2-FT-10)])，它描述了使用称为*Punycode*的格式将此编码应用于DNS标签的方法。Punycode看起来大致如下：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A compliant browser presented with a technically illegal URL that contained
    a literal non-US-ASCII character anywhere in the hostname was supposed to transform
    the name to Punycode before performing a DNS lookup. Consequently, when presented
    with Punycode in an existing URL, it should put a decoded, human-readable form
    of the string in the address bar.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合规的浏览器在遇到一个技术上非法的URL，其中在任何位置包含一个非US-ASCII字符时，应该将名称转换为Punycode，然后再执行DNS查找。因此，当在现有URL中遇到Punycode时，它应该在地址栏中显示该字符串的解码、可读形式。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Combining all these incompatible encoding strategies can make for an amusing
    mix. Consider this example URL of a made-up Polish-language towel shop:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些不兼容的编码策略结合起来，可能会产生有趣的混合。考虑以下一个虚构的波兰语毛巾店的示例URL：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages949993.png.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages949993.png.jpg)'
- en: Of all the URL-based encoding approaches, IDNA soon proved to be the most problematic.
    In essence, the domain name in the URL shown in the browser’s address bar is one
    of the most important security indicators on the Web, as it allows users to quickly
    differentiate sites they trust and have done business with from the rest of the
    Internet. When the hostname shown by the browser consists of 38 familiar and distinctive
    characters, only fairly careless victims will be tricked into thinking that their
    favorite *examp*l*e.com* domain and an impostor *examp*1*e.com* site are the same
    thing. But IDNA casually and indiscriminately extended these 38 characters to
    some 100,000 glyphs supported by Unicode, many of which look exactly alike and
    are separated from each other based on functional differences alone.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有基于URL的编码方法中，IDNA很快证明是最有问题的。本质上，浏览器地址栏中显示的URL中的域名是Web上最重要的安全指示之一，因为它使用户能够快速区分他们信任并与之进行过交易的网站与互联网上的其他网站。当浏览器显示的域名由38个熟悉且独特的字符组成时，只有相当粗心的受害者才会被骗，认为他们最喜欢的*examp*l*e.com*域名和冒充的*examp*1*e.com*网站是同一件事。但IDNA随意且不加区分地将这38个字符扩展到Unicode支持的约10万个符号中，其中许多符号看起来几乎相同，并且仅基于功能差异而彼此分离。
- en: 'How bad is it? Let’s consider Cyrillic, for example. This alphabet has a number
    of homoglyphs that look practically identical to their Latin counterparts but
    that have completely different Unicode values and resolve to completely different
    Punycode DNS names:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多糟糕？以西里尔字母为例。这个字母表有几个与拉丁字母表中的字母几乎相同的同形异义词，但它们的Unicode值完全不同，并且解析为完全不同的Punycode
    DNS名称：
- en: '| Latin | a | c | e | i | j | o | p | s | x | y |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 拉丁 | a | c | e | i | j | o | p | s | x | y |'
- en: '| U+0061 | U+0063 | U+0065 | U+0069 | U+006A | U+006F | U+0070 | U+0073 | U+0078
    | U+0079 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| U+0061 | U+0063 | U+0065 | U+0069 | U+006A | U+006F | U+0070 | U+0073 | U+0078
    | U+0079 |'
- en: '| Cyrillic | a | c | e | i | j | o | p | s | x | y |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 西里尔 | a | c | e | i | j | o | p | s | x | y |'
- en: '| U+0430 | U+0441 | U+0435 | U+0456 | U+0458 | U+043E | U+0440 | U+0455 | U+0445
    | U+0443 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| U+0430 | U+0441 | U+0435 | U+0456 | U+0458 | U+043E | U+0440 | U+0455 | U+0445
    | U+0443 |'
- en: When IDNA was proposed and first implemented in browsers, nobody seriously considered
    the consequences of this issue. Browser vendors apparently assumed that DNS registrars
    would prevent people from registering look-alike names, and registrars figured
    it was the browser vendors’ problem to have unambiguous visuals in the address
    bar.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当IDNA被提出并在浏览器中首次实现时，没有人认真考虑这个问题带来的后果。浏览器供应商显然认为DNS注册商将阻止人们注册类似的名字，而注册商认为在地址栏中保持清晰的视觉是浏览器供应商的问题。
- en: 'In 2002 the significance of the problem was finally recognized by all parties
    involved. That year, Evgeniy Gabrilovich and Alex Gontmakher published “The Homograph
    Attack,”^([[104](pr03.html#ftn.CHP-2-FT-11)]) a paper exploring the vulnerability
    in great detail. They noted that any registrar-level work-arounds, even if implemented,
    would have a fatal flaw. An attacker could always purchase a wholesome top-level
    domain and then, on his own name server, set up a subdomain record that, with
    the IDNA transformation applied, would decode to a string visually identical to
    *example.com/* (the last character being merely a nonfunctional look-alike of
    the actual ASCII slash). The result would be:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在2002年，所有相关方终于认识到了这个问题的严重性。那年，叶夫根尼·加布里洛维奇和亚历克斯·冈特马克赫发表了“同音攻击”^([[104](pr03.html#ftn.CHP-2-FT-11)])，一篇详细探讨漏洞的论文。他们指出，任何注册级别的工作方案，即使实施，也会有一个致命的缺陷。攻击者总是可以购买一个健全的顶级域名，然后在自己的域名服务器上设置一个子域名记录，应用IDNA转换后，会解码成一个与*example.com/*（最后一个字符仅是一个非功能的类似ASCII斜杠的替代品）视觉上相同的字符串。结果将是：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages949995.png.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages949995.png.jpg)'
- en: There is nothing that a registrar can do to prevent this attack, and the ball
    is in the browser vendors’ court. But what options do they have, exactly?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注册商无法采取任何措施来防止这种攻击，球现在在浏览器供应商的场地上。但他们到底有什么选择呢？
- en: As it turns out, there aren’t many. We now realize that the poorly envisioned
    IDNA standard cannot be fixed in a simple and painless way. Browser developers
    have responded to this risk by reverting to incomprehensible Punycode when a user’s
    locale does not match the script seen in a particular DNS label (which causes
    problems when browsing foreign sites or when using imported or simply misconfigured
    computers); permitting IDNA only in certain country-specific, top-level domains
    (ruling out the use of internationalized domain names in *.com* and other high-profile
    TLDs); and blacklisting certain “bad” characters that resemble slashes, periods,
    white spaces, and so forth (a fool’s errand, given the number of typefaces used
    around the world).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，并不多。我们现在意识到，构思不佳的IDNA标准无法以简单和痛苦的方式修复。浏览器开发者通过在用户的区域设置与特定DNS标签中看到的脚本不匹配时回退到难以理解的Punycode来应对这种风险（这在使用外国网站或使用导入或配置错误的计算机时会导致问题）；仅在某些特定国家的顶级域名中允许使用IDNA（排除了在*.com*和其他高知名度TLD中使用国际化域名）；并列入某些类似斜杠、点、空格等“坏”字符的黑名单（鉴于全球使用的字体数量，这是一项徒劳的任务）。
- en: These measures are drastic enough to severely hinder the adoption of internationalized
    domain names, probably to a point where the standard’s lingering presence causes
    more security problems than it brings real usability benefits to non-English users.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些措施足够激进，足以严重阻碍国际化域名的采用，可能到了这种程度，标准的持续存在带来的安全问题比它为非英语用户带来的实际可用性好处还要多。
- en: '* * *'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[13](#CHP-2-FN-4)]) Similar noncanonical encodings were widely used for various
    types of social engineering attacks, and consequently, various countermeasures
    have been deployed through the years. As usual, some of these countermeasures
    are disruptive (for example, Firefox flat out rejects percent-encoded text in
    hostnames), and some are fairly good (such as the forced “canonicalization” of
    the address bar by decoding all the unnecessarily encoded text for display purposes).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#CHP-2-FN-4)]) 类似的不规范编码被广泛用于各种类型的社会工程攻击，因此，多年来部署了各种对策。像往常一样，其中一些对策是破坏性的（例如，Firefox明确拒绝在主机名中使用百分号编码的文本），而另一些则相当不错（例如，通过解码所有不必要的编码文本以用于显示目的，强制执行地址栏的“规范转换”）。
- en: Common URL Schemes and Their Function
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见URL方案及其功能
- en: Let’s leave the bizarre world of URL parsing behind us and go back to the basics.
    Earlier in this chapter, we implied that certain schemes may have unexpected security
    consequences and that because of this, any web application handling user-supplied
    URLs must be cautious. To explain this point a bit better, it is useful to review
    all the URL schemes commonly supported in a typical browser environment. These
    can be combined into four basic groups.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们抛开奇特的URL解析世界，回到基础。在本章的早期，我们暗示某些方案可能会有意外的安全后果，并且由于这个原因，任何处理用户提供的URL的Web应用程序都必须谨慎。为了更好地解释这一点，回顾在典型浏览器环境中通常支持的URL方案是有用的。这些可以组合成四个基本组。
- en: Browser-Supported, Document-Fetching Protocols
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器支持的文档获取协议
- en: These schemes, handled internally by the browser, offer a way to retrieve arbitrary
    content using a particular transport protocol and then display it using common,
    browser-level rendering logic. This is the most rudimentary and the most expected
    function of a URL.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方案由浏览器内部处理，提供了一种使用特定传输协议检索任意内容，然后使用常见的浏览器级渲染逻辑显示它的方法。这是 URL 的最基本和最预期的功能。
- en: 'The list of commonly supported schemes in this category is surprisingly short:
    *http:* (RFC 2616), the primary transport mode used on the Web and the focus of
    the next chapter of this book; *https:*, an encrypted version of HTTP (RFC 2818^([[105](pr03.html#ftn.CHP-2-FT-12)]));
    and *ftp:*, an older file transfer protocol (RFC 959^([[106](pr03.html#ftn.CHP-2-FT-13)])).
    All browsers also support *file:* (previously also known as *local:*), a system-specific
    method for accessing the local filesystem or NFS and SMB shares. (This last scheme
    is usually not directly accessible through Internet-originating pages, though.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类别中，常见支持的方案列表出奇地短：*http:*（RFC 2616），在 Web 上使用的首选传输模式，也是本书下一章的重点；*https:*，HTTP
    的加密版本（RFC 2818^([[105](pr03.html#ftn.CHP-2-FT-12)]））；以及 *ftp:*，一种较老的文件传输协议（RFC
    959^([[106](pr03.html#ftn.CHP-2-FT-13)]））。所有浏览器也支持 *file:*（以前也称为 *local:*），一种特定于系统的访问本地文件系统或
    NFS 和 SMB 共享的方法。（这个最后的方案通常不能通过源自互联网的页面直接访问。）
- en: 'Two additional, obscure cases also deserve a brief mention: built-in support
    for the *gopher:* scheme, one of the failed predecessors of the Web (RFC 1436^([[107](pr03.html#ftn.CHP-2-FT-14)])),
    which is still present in Firefox, and *shttp:*, an alternative, failed take on
    HTTPS (RFC 2660^([[108](pr03.html#ftn.CHP-2-FT-15)])), still recognized in Internet
    Explorer (but today, simply aliased to HTTP).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个额外的、不为人知的案例也值得简要提及：内置对 *gopher:* 方案的支持，这是 Web 的一个失败的先驱（RFC 1436^([[107](pr03.html#ftn.CHP-2-FT-14)]）），仍然存在于
    Firefox 中，以及 *shttp:*，一种对 HTTPS 的替代、失败的尝试（RFC 2660^([[108](pr03.html#ftn.CHP-2-FT-15)]）），仍然在
    Internet Explorer 中被认可（但今天，它简单地被别名为 HTTP）。
- en: Protocols Claimed by Third-Party Applications and Plug-ins
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方应用程序和插件声明的协议
- en: For these schemes, matching URLs are simply dispatched to external, specialized
    applications that implement functionality such as media playback, document viewing,
    or IP telephony. At this point, the involvement of the browser (mostly) ends.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些方案，匹配的 URL 简单地被发送到外部、专门的应用程序，这些应用程序实现了媒体播放、文档查看或 IP 电话等功能。到此，浏览器（主要）的参与就结束了。
- en: Scores of external protocol handlers exist today, and it would take another
    thick book to cover them all. Some of the most common examples include the *acrobat:*
    scheme, predictably routed to Adobe Acrobat Reader; *callto:* and *sip:* schemes
    claimed by all sorts of instant messengers and telephony software; *daap:*, *itpc:*,
    and *itms:* schemes used by Apple iTunes; *mailto:*, *news:*, and *nntp:* protocols
    claimed by mail and Usenet clients; *mmst:*, *mmsu:*, *msbd:*, and *rtsp:* protocols
    for streaming media players; and so on. Browsers are sometimes also included on
    the list. The previously mentioned *firefoxurl:* scheme launches Firefox from
    within another browser, while *cf:* gives access to Chrome from Internet Explorer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在大量外部协议处理器，要涵盖它们所有内容需要另一本厚厚的书。其中一些最常见例子包括 *acrobat:* 方案，可预测地路由到 Adobe Acrobat
    Reader；*callto:* 和 *sip:* 方案被各种即时通讯软件和电话软件所声称；*daap:*, *itpc:*, 和 *itms:* 方案由
    Apple iTunes 使用；*mailto:*, *news:*, 和 *nntp:* 协议由邮件和 Usenet 客户端声称；*mmst:*, *mmsu:*,
    *msbd:*, 和 *rtsp:* 协议用于流媒体播放器；等等。浏览器有时也会包含在列表中。之前提到的 *firefoxurl:* 方案可以在另一个浏览器中启动
    Firefox，而 *cf:* 则可以从 Internet Explorer 访问 Chrome。
- en: For the most part, when these schemes appear in URLs, they usually have no impact
    on the security of the web applications that allow them to go through (although
    this is not guaranteed, especially in the case of plug-in-supported content).
    It is worth noting that third-party protocol handlers tend to be notoriously buggy
    and are sometimes abused to compromise the operating system. Therefore, restricting
    the ability to navigate to mystery protocols is a common courtesy to the user
    of any reasonably trustworthy website.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些方案，当它们出现在 URL 中时，通常对允许它们通过的 Web 应用程序的安全性没有影响（尽管这并不保证，尤其是在插件支持的内容的情况下）。值得注意的是，第三方协议处理器往往臭名昭著地存在漏洞，有时被滥用以损害操作系统。因此，限制导航到神秘协议的能力是对任何合理可信网站用户的一种常见礼节。
- en: Nonencapsulating Pseudo-Protocols
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非封装伪协议
- en: An array of protocols is reserved to provide convenient access to the browser’s
    scripting engine and other internal functions, without actually retrieving any
    remote content and perhaps without establishing an isolated document context to
    display the result. Many of these pseudo-protocols are highly browser-specific
    and are either not directly accessible from the Internet or are incapable of doing
    harm. However, there are several important exceptions to this rule.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列协议被保留，以提供方便地访问浏览器的脚本引擎和其他内部功能，而无需实际检索任何远程内容，也许无需建立独立的文档上下文来显示结果。许多这些伪协议非常特定于浏览器，要么不能直接从互联网访问，要么无法造成伤害。然而，有几个重要的例外。
- en: Perhaps the best-known exception is the *javascript:* scheme (in earlier years,
    also available under aliases such as *livescript:* or *mocha:* in Netscape browsers).
    This scheme gives access to the JavaScript-programming engine in the context of
    the currently viewed website. In Internet Explorer, *vbscript:* offers similar
    capabilities through the proprietary Visual Basic interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的例外可能是 *javascript:* 方案（在早年，在Netscape浏览器中也可通过别名如 *livescript:* 或 *mocha:*
    访问）。此方案允许在当前查看的网站上下文中访问JavaScript编程引擎。在Internet Explorer中，*vbscript:* 通过专有的Visual
    Basic界面提供类似的功能。
- en: 'Another important case is the *data:* protocol (RFC 2397^([[109](pr03.html#ftn.CHP-2-FT-16)])),
    which permits short, inline documents to be created without any extra network
    requests and sometimes inherits much of their operating context from the referring
    page. An example of a *data:* URL is:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的情况是 *data:* 协议（RFC 2397^([[109](pr03.html#ftn.CHP-2-FT-16)]))，它允许创建简短的、内联的文档，而无需任何额外的网络请求，有时它们的大部分操作上下文都来自引用页面。一个
    *data:* URL 的例子是：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These externally accessible pseudo-URLs are of acute significance to site security.
    When navigated to, their payload may execute in the context of the originating
    domain, possibly stealing sensitive data or altering the appearance of the page
    for the affected user. We’ll discuss the specific capabilities of browser scripting
    languages in [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts"), but as
    you might expect, they are substantial. (URL context inheritance rules, on the
    other hand, are the focus of [Chapter 10](ch10.html "Chapter 10. Origin Inheritance").)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些外部可访问的伪URL对于站点安全至关重要。当导航到这些URL时，其有效载荷可能在原始域的上下文中执行，可能窃取敏感数据或更改受影响用户的页面外观。我们将在[第6章](ch06.html
    "第6章。浏览器端脚本")中讨论浏览器脚本语言的特定功能，但正如你所预期的那样，它们是相当重要的。（另一方面，URL上下文继承规则是[第10章](ch10.html
    "第10章。来源继承")的重点。）
- en: Encapsulating Pseudo-Protocols
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装伪协议
- en: 'This special class of pseudo-protocols may be used to prefix any other URL
    in order to force a special decoding or rendering mode for the retrieved resource.
    Perhaps the best-known example is the *view-source:* scheme supported by Firefox
    and Chrome, used to display the pretty-printed source of an HTML page. This scheme
    is used in the following way:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类特殊的伪协议可以用来作为任何其他URL的前缀，以强制对检索到的资源进行特殊的解码或渲染模式。或许最著名的例子是Firefox和Chrome支持的
    *view-source:* 方案，用于显示HTML页面的格式化源代码。此方案的使用方式如下：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other protocols that function similarly include *jar:*, which allows content
    to be extracted from ZIP files on the fly in Firefox; *wyciwyg:* and *view-cache:*,
    which give access to cached pages in Firefox and Chrome respectively; an oddball
    *feed:* scheme, which is meant to access news feeds in Safari;^([[110](pr03.html#ftn.CHP-2-FT-17)])
    and a host of poorly documented protocols associated with the Windows help subsystem
    and other components of Microsoft Windows (*hcp:*, *its:*, *mhtml:*, *mk:*, *ms-help:*,
    *ms-its:*, and *ms-itss:*).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其他功能类似的协议包括 *jar:*，它允许在Firefox中动态提取ZIP文件中的内容；*wyciwyg:* 和 *view-cache:*，分别提供Firefox和Chrome中缓存页面的访问权限；一个奇特的
    *feed:* 方案，旨在访问Safari中的新闻源；^([[110](pr03.html#ftn.CHP-2-FT-17)]) 以及与Windows帮助子系统和其他Microsoft
    Windows组件相关的一大批文档不充分的协议（*hcp:*, *its:*, *mhtml:*, *mk:*, *ms-help:*, *ms-its:*,
    和 *ms-itss:*）。
- en: 'The common property of many encapsulating protocols is that they allow the
    attacker to hide the actual URL that will be ultimately interpreted by the browser
    from naïve filters: `view-source:javascript:` (or even `view-source:view-source:javascript:`)
    followed by malicious code is a simple way to accomplish this. Some security restrictions
    may be present to limit such trickery, but they should not be relied upon. Another
    significant problem, recurring especially with Microsoft’s *mhtml:*, is that using
    the protocol may ignore some of the content directives provided by the server
    on HTTP level, possibly leading to widespread misery.^([[111](pr03.html#ftn.CHP-2-FT-18)])'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 许多封装协议的共同特性是它们允许攻击者隐藏浏览器最终将解释的实际URL，从而避开天真过滤器：`view-source:javascript:`（甚至`view-source:view-source:javascript:`）后跟恶意代码是完成这一点的简单方法。可能存在一些安全限制来限制这种诡计，但不应依赖于它们。另一个显著的问题，尤其是在微软的*mhtml:*中反复出现，是使用该协议可能会忽略服务器在HTTP级别提供的某些内容指令，这可能导致普遍的不幸.^([[111](pr03.html#ftn.CHP-2-FT-18)])
- en: Closing Note on Scheme Detection
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于方案检测的结束语
- en: The sheer number of pseudo-protocols is the primary reason why web applications
    need to carefully screen user-supplied URLs. The wonky and browser-specific URL-parsing
    patterns, coupled with the open-ended nature of the list of supported schemes,
    means that it is unsafe to simply blacklist known bad schemes; for example, a
    check for *javascript:* may be circumvented if this keyword is spliced with a
    tab or a newline, replaced with *vbscript:*, or prefixed with another encapsulating
    scheme.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 伪协议的数量众多是为什么Web应用需要仔细筛选用户提供的URL的主要原因。古怪且特定于浏览器的URL解析模式，加上支持方案列表的开放性，意味着简单地黑名单已知的坏方案是不安全的；例如，如果这个关键字与制表符或换行符拼接，替换为*vbscript:*，或者以另一个封装方案为前缀，那么对*javascript:*的检查可能会被规避。
- en: Resolution of Relative URLs
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对URL的解析
- en: Relative URLs have been mentioned on several occasions earlier in the chapter,
    and they deserve some additional attention at this point, too. The reason for
    their existence is that on almost every web page on the Internet, a considerable
    number of URLs will reference resources hosted on that same server, perhaps in
    the same directory. It would be inconvenient and wasteful to require a fully qualified
    URL to appear in the document every time such a reference is needed, so short,
    relative URLs (such as *../other_file.txt*) are used instead. The missing details
    are inferred from the URL of the referring document.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相对URL在章节的前几部分已经被提到，现在也需要给予更多的关注。它们存在的原因是，在互联网上的几乎每个网页上，都会有相当数量的URL引用同一服务器上托管的资源，可能是在同一个目录下。每次需要此类引用时都要求出现完全限定的URL将是不方便且浪费的，因此使用简短的相对URL（如*../other_file.txt*）代替。缺失的细节可以从引用文档的URL中推断出来。
- en: Because relative URLs are allowed to appear in exactly the same scenarios in
    which any absolute URL may appear, a method to distinguish between the two is
    necessary within the browser. Web applications also benefit from the ability to
    make the distinction, because most types of URL filters may want to scrutinize
    absolute URLs only and allow local references through as is.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于相对URL可以出现在任何绝对URL可能出现的完全相同的场景中，因此浏览器内部需要有一种方法来区分这两种URL。Web应用也受益于这种区分能力，因为大多数类型的URL过滤器可能只想仔细检查绝对URL，并允许本地引用按原样通过。
- en: 'The specification may make this task seem very simple: If the URL string does
    not begin with a valid scheme name followed by a semicolon and, preferably, a
    valid “//” sequence, it should be interpreted as a relative reference. And if
    no context for parsing such a relative URL exists, it should be rejected. Everything
    else is a safe relative link, right?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 规范可能使这项任务看起来非常简单：如果URL字符串不以有效的方案名称开头，后面跟一个分号和，最好是有效的“//”序列，则应将其解释为相对引用。如果没有解析此类相对URL的上下文，则应拒绝。其他一切都是安全的相对链接，对吧？
- en: Predictably, it’s not as easy as it seems. First, as outlined in previous sections,
    the accepted set of characters in a valid scheme name, and the patterns accepted
    in lieu of “//”, vary from one implementation to another. Perhaps more interestingly,
    it is a common misconception that relative links can point only to resources on
    the same server; quite a few other, less-obvious variants of relative URLs exist.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 预计这并不像看起来那么简单。首先，如前几节所述，有效方案名称中接受的字符集，以及代替“//”接受的模式，因实现而异。也许更有趣的是，一个常见的误解是相对链接只能指向同一服务器上的资源；实际上存在许多其他不那么明显的相对URL变体。
- en: Let’s have a quick peek at the known classes of relative URLs to better illustrate
    this possibility.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下已知的相对URL类别，以更好地说明这种可能性。
- en: '**Scheme, but no authority present** (http:foo.txt)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**有方案，但没有权限** (http:foo.txt)'
- en: This infamous loophole is hinted at in RFC 3986 and attributed to an oversight
    in one of the earlier specs. While said specs descriptively classified such URLs
    as (invalid) absolute references, they also provided a promiscuous reference-parsing
    algorithm keen on interpreting them incorrectly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种臭名昭著的漏洞在RFC 3986中有所暗示，并归因于早期规范中的一个疏忽。虽然这些规范描述性地将这些URL分类为（无效）绝对引用，但它们还提供了一个对它们进行错误解释的贪婪引用解析算法。
- en: In the latter interpretation, these URLs would set a new protocol and path,
    query, or fragment ID but have the authority section copied over from the referring
    location. This syntax is accepted by several browsers, but inconsistently. For
    example, in some cases, *http:foo.txt* may be treated as a relative reference,
    while *https:example.com* may be parsed as an absolute one!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种解释中，这些URL将设置新的协议和路径、查询或片段标识符，但权限部分将从引用位置复制。这种语法被几个浏览器接受，但并不一致。例如，在某些情况下，*http:foo.txt*
    可能被视为相对引用，而 *https:example.com* 可能被解析为绝对引用！
- en: '**No scheme, but authority present** (//example.com)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有方案，但有权限** (//example.com)'
- en: 'This is another notoriously confusing but at least well-documented quirk. While
    */example.com* is areference to a local resource on the current server, the standard
    compels browsers to treat *//example.com* as a very different case: a reference
    to a different authority over the current protocol. In this scenario, the scheme
    will be copied over from the referring location, and all other URL details will
    be derived from the relative URL.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种臭名昭著但至少有良好文档记录的怪癖。虽然 */example.com* 是对当前服务器上本地资源的引用，但标准强制浏览器将 *//example.com*
    视为一个非常不同的情况：对当前协议的不同权限的引用。在这种情况下，方案将从引用位置复制，所有其他URL细节都将从相对URL派生。
- en: '**No scheme, no authority, but path present** (../notes.txt)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有方案，没有权限，但有路径** (../notes.txt)'
- en: This is the most common variant of a relative link. Protocol and authority information
    is copied over from the referring URL. If the relative URL does not start with
    a slash, the path will also be copied over up to the rightmost “/”. For example,
    if the base URL is [http://www.example.com/files/](http://www.example.com/files/),
    the path is the same, but in [http://www.example.com/files/index.html](http://www.example.com/files/index.html),
    the filename is truncated. The new path is then appended, and standard path normalization
    follows on the concatenated value. The query string and fragment ID are derived
    only from the relative URL.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相对链接最常见的变体。协议和权限信息是从引用URL复制的。如果相对URL不以斜杠开头，路径也将复制到最右侧的“/”。例如，如果基本URL是 [http://www.example.com/files/](http://www.example.com/files/)，则路径相同，但在
    [http://www.example.com/files/index.html](http://www.example.com/files/index.html)
    中，文件名被截断。然后，将新路径附加到上面，并在连接值上执行标准路径规范化。查询字符串和片段标识符仅从相对URL派生。
- en: '**No scheme, no authority, no path, but query string present** (?search=bunnies)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有方案，没有权限，没有路径，但有查询字符串** (?search=bunnies)'
- en: In this scenario, protocol, authority, and path information are copied verbatim
    from the referring URL. The query string and fragment ID are derived from the
    relative URL.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，协议、权限和路径信息直接从引用URL复制。查询字符串和片段标识符是从相对URL派生出来的。
- en: '**Only fragment ID present** (#bunnies)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅存在片段标识符** (#bunnies)'
- en: All information except for the fragment ID is copied verbatim from the referring
    URL; only the fragment ID is substituted. Following this type of relative URL
    does not cause the page to be reloaded under normal circumstances, as noted earlier.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了片段标识符之外的所有信息都是直接从引用URL复制的；只有片段标识符被替换。遵循此类相对URL在正常情况下不会导致页面重新加载，如前所述。
- en: Because of the risk of potential misunderstandings between application-level
    URL filters and the browser when handling these types of relative references,
    it is a good design practice never to output user-supplied relative URLs verbatim.
    Where feasible, they should be explicitly rewritten to absolute references, and
    all security checks should be carried out against the resulting fully qualified
    address instead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在处理这些类型的相对引用时，应用级URL过滤器与浏览器之间可能存在潜在误解的风险，因此，始终直接输出用户提供的相对URL是一个良好的设计实践。在可行的情况下，它们应被明确重写为绝对引用，并且所有安全检查都应针对生成的完全合格地址进行。
- en: Security Engineering Cheat Sheet
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Constructing Brand-New URLs Based on User Input
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于用户输入构建全新的URL时
- en: '**If you allow user-supplied data in path, query, or fragment ID:** If one
    of the section delimiters manages to get through without proper escaping, the
    URL may have a different effect from what you intended (for example, linking one
    of the user-visible HTML buttons to the wrong server-side action). It is okay
    to err on the side of caution: When inserting an attacker-controlled field value,
    you can simply percent-escape everything but alphanumerics.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您允许用户在路径、查询或片段ID中提供数据：** 如果某个部分分隔符在没有适当转义的情况下成功通过，URL可能会产生与您预期不同的效果（例如，将一个用户可见的HTML按钮链接到错误的服务器端操作）。谨慎行事是正确的：当插入攻击者控制的字段值时，您只需对非字母数字字符进行百分号转义即可。'
- en: '**If you allow user-supplied scheme name or authority section:** This is a
    major code injection and phishing risk! Apply the relevant input-validation rules
    outlined below.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您允许用户提供的方案名称或授权部分：** 这是一种主要的代码注入和钓鱼风险！应用以下概述的相关输入验证规则。'
- en: When Designing URL Input Filters
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计URL输入过滤器时
- en: '**Relative URLs:** Disallow or explicitly rewrite them to absolute references
    to avoid trouble. Anything else is very likely unsafe.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对URL：** 禁止或显式重写它们为绝对引用以避免麻烦。其他任何内容都极有可能是不安全的。'
- en: '**Scheme name:** Permit only known prefixes, such as *http://*, *https://*,
    or *ftp://*. Do not use blacklisting instead; it is extremely unsafe.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方案名称：** 仅允许已知的前缀，例如 *http://*、*https://* 或 *ftp://*。不要使用黑名单；这极其不安全。'
- en: '**Authority section:** Hostname should contain only alphanumerics, “-”, and
    “.” and can only be followed by “/”, “?”, “#”, or end-of-string. Allowing anything
    else will backfire. If you need to examine the hostname, make sure to make a proper
    right-hand substring match.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权部分：** 主机名应仅包含字母数字、“-”和“.”，并且只能由“/”、“?”、“#”或字符串末尾跟随。允许任何其他内容都会适得其反。如果您需要检查主机名，请确保进行适当的右侧子字符串匹配。'
- en: In rare cases, you might need to account for IDNA, IPv6 bracket notation, port
    numbers, or HTTP credentials in the URL. If so, you must fully parse the URL,
    validate all sections and reject anomalous values, and reserialize them into a
    nonambiguous, canonical, well-escaped representation.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在罕见的情况下，您可能需要考虑IDNA、IPv6括号表示法、端口号或HTTP凭证在URL中的情况。如果是这样，您必须完全解析URL，验证所有部分，拒绝异常值，并将它们重新序列化为一个非歧义、规范、正确转义的表示形式。
- en: When Decoding Parameters Received Through URLs
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当解码通过URL接收到的参数时
- en: Do not assume that any particular character will be escaped just because the
    standard says so or because your browser does it. Before echoing back any URL-derived
    values or putting them inside database queries, new URLs, and so on, scrub them
    carefully for dangerous characters.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要假设任何特定字符会因为标准如此规定或因为您的浏览器这样做而被转义。在回显任何由URL派生的值或将它们放入数据库查询、新URL等之前，仔细清除危险字符。
- en: Chapter 3. Hypertext Transfer Protocol
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 超文本传输协议
- en: 'The next essential concept we need to discuss is the Hypertext Transfer Protocol
    (HTTP): the core transfer mechanism of the Web and the preferred method for exchanging
    URL-referenced documents between servers and clients. Despite having hypertext
    in its name, HTTP and the actual hypertext content (the HTML language) often exist
    independent of each other. That said, they are intertwined in sometimes surprising
    ways.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要讨论的下一个基本概念是超文本传输协议（HTTP）：Web的核心传输机制，以及服务器和客户端之间交换URL引用文档的首选方法。尽管HTTP的名字中有超文本，但HTTP和实际的超文本内容（HTML语言）通常独立存在。话虽如此，它们有时以令人惊讶的方式交织在一起。
- en: The history of HTTP offers interesting insight into its authors’ ambitions and
    the growing relevance of the Internet. Tim Berners-Lee’s earliest 1991 draft of
    the protocol (HTTP/0.9^([[112](pr03.html#ftn.CHP-3-FT-1)])) was barely one and
    a half pages long, and it failed to account for even the most intuitive future
    needs, such as extensibility needed to transmit non-HTML data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的历史为作者们的雄心和互联网日益增长的相关性提供了有趣的见解。蒂姆·伯纳斯-李（Tim Berners-Lee）1991年最早的协议草案（HTTP/0.9^([[112](pr03.html#ftn.CHP-3-FT-1)]））仅有不到一页半长，并且未能考虑到甚至是最直观的未来需求，例如传输非HTML数据所需的扩展性。
- en: 'Five years and several iterations of the specification later, the first official
    HTTP/1.0 standard (RFC 1945^([[113](pr03.html#ftn.CHP-3-FT-2)])) tried to rectify
    many of these shortcomings in about 50 densely packed pages of text. Fast-forward
    to 1999, and in HTTP/1.1 (RFC 2616^([[114](pr03.html#ftn.CHP-3-FT-3)])), the seven
    credited authors attempted to anticipate almost every possible use of the protocol,
    creating an opus over 150 pages long. That’s not all: As of this writing, the
    current work on HTTPbis,^([[115](pr03.html#ftn.CHP-3-FT-4)]) essentially a replacement
    for the HTTP/1.1 specification, comes to 360 pages or so. While much of the gradually
    accumulated content is irrelevant to the modern Web, this progression makes it
    clear that the desire to tack on new features far outweighs the desire to prune
    failed ones.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 五年后，经过几个版本的规范迭代，第一个官方的HTTP/1.0标准（RFC 1945^([[113](pr03.html#ftn.CHP-3-FT-2)]))在约50页密集的文字中试图纠正许多这些不足。快进到1999年，在HTTP/1.1（RFC
    2616^([[114](pr03.html#ftn.CHP-3-FT-3)]))中，七位认可的作者试图预测几乎该协议的每一种可能的使用，创作了一部超过150页的杰作。不仅如此：截至本文撰写时，对HTTPbis的工作，^([[115](pr03.html#ftn.CHP-3-FT-4)]))基本上是HTTP/1.1规范的替代品，达到了大约360页。虽然其中大部分逐渐积累的内容对现代网络来说并不相关，但这种进展清楚地表明，添加新特性的愿望远远超过了修剪失败特性的愿望。
- en: Today, all clients and servers support a not-entirely-accurate superset of HTTP/1.0,
    and most can speak a reasonably complete dialect of HTTP/1.1, with a couple of
    extensions bolted on. Despite the fact that there is no practical need to do so,
    several web servers, and all common browsers, also maintain backward compatibility
    with HTTP/0.9.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有客户端和服务器都支持HTTP/1.0的一个不完全准确的超集，并且大多数都能说一口相当完整的HTTP/1.1方言，并附加了一些扩展。尽管实际上没有这样的需求，但一些Web服务器和所有常见的浏览器也保持了与HTTP/0.9的向后兼容性。
- en: Basic Syntax of HTTP Traffic
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP流量基本语法
- en: At a glance, HTTP is a fairly simple, text-based protocol built on top of TCP/IP.^([[14](#ftn.CHP-3-FN-1)])
    Every HTTP session is initiated by establishing a TCP connection to the server,
    typically to port 80, and then issuing a request that outlines the requested URL.
    In response, the server returns the requested file and, in the most rudimentary
    use case, tears down the TCP connection immediately thereafter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，HTTP是一种相当简单、基于文本的协议，它建立在TCP/IP之上.^([[14](#ftn.CHP-3-FN-1)]) 每个HTTP会话都是通过建立到服务器的TCP连接来启动的，通常是端口80，然后发出一个概述请求URL的请求。作为回应，服务器返回请求的文件，在最基本的使用案例中，随后立即终止TCP连接。
- en: 'The original HTTP/0.9 protocol provided no room for any additional metadata
    to be exchanged between the participating parties. The client request always consisted
    of a single line, starting with GET, followed by the URL path and query string,
    and ending with a single CRLF newline (ASCII characters 0x0D 0x0A; servers were
    also advised to accept a lone LF). A sample HTTP/0.9 request might have looked
    like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的HTTP/0.9协议为参与方之间交换任何额外的元数据没有提供空间。客户端请求始终由一行组成，以GET开头，后跟URL路径和查询字符串，并以单个CRLF换行符（ASCII字符0x0D
    0x0A；服务器也被建议接受单独的LF）。一个示例HTTP/0.9请求可能看起来像这样：
- en: '[PRE10]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In response to this message, the server would have immediately returned the
    appropriate HTML payload. (The specification required servers to wrap lines of
    the returned document at 80 characters, but this advice wasn’t really followed.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对此消息的回应，服务器会立即返回适当的HTML有效负载。（规范要求服务器将返回文档的行包装在80个字符处，但这些建议并没有真正得到遵循。）
- en: 'The HTTP/0.9 approach has a number of substantial deficiencies. For example,
    it offers no way for browsers to communicate users’ language preferences, supply
    a list of supported document types, and so on. It also gives servers no way to
    tell a client that the requested file could not be found, that it has moved to
    a different location, or that the returned file is not an HTML document to begin
    with. Finally, the scheme is not kind to server administrators: When the transmitted
    URL information is limited to only the path and query strings, it is impossible
    for a server to host multiple websites, distinguished by their hostnames, under
    one IP address—and unlike DNS records, IP addresses don’t come cheap.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/0.9方法存在许多实质性的缺陷。例如，它为浏览器提供不了与用户语言偏好进行通信的方式，提供支持的文档类型列表等。它也使服务器无法通知客户端请求的文件找不到，它已移动到不同的位置，或者返回的文件根本不是HTML文档。最后，该方案对服务器管理员来说并不友好：当传输的URL信息仅限于路径和查询字符串时，服务器无法在单个IP地址下托管多个网站，这些网站通过它们的域名区分开来——而且与DNS记录不同，IP地址并不便宜。
- en: 'In order to fix these shortcomings (and to make room for future tweaks), HTTP/1.0
    and HTTP/1.1 standards embrace a slightly different conversation format: The first
    line of a request is modified to include protocol version information, and it
    is followed by zero or more *name: value* pairs (also known as *headers*), each
    occupying a separate line. Common request headers included in such requests are
    *User-Agent* (browser version information), *Host* (URL hostname), *Accept* (supported
    MIME document types^([[15](#ftn.CHP-3-FN-2)])), *Accept-Language* (supported language
    codes), and *Referer* (a misspelled field indicating the originating page for
    the request, if known).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '为了解决这些不足（并为未来的调整留出空间），HTTP/1.0 和 HTTP/1.1 标准采用了略微不同的对话格式：请求的第一行被修改以包含协议版本信息，其后跟随零个或多个
    *name: value* 对（也称为 *headers*），每个对占据一行。此类请求中常见的请求头包括 *User-Agent*（浏览器版本信息）、*Host*（URL
    主机名）、*Accept*（支持的 MIME 文档类型^([[15](#ftn.CHP-3-FN-2)]))）、*Accept-Language*（支持的语言代码）和
    *Referer*（一个拼写错误的字段，表示请求的起始页面，如果已知）。'
- en: These headers are terminated with a single empty line, which may be followed
    by any payload the client wishes to pass to the server (the length of which must
    be explicitly specified with an additional *Content-Length* header). The contents
    of the payload are opaque from the perspective of the protocol itself; in HTML,
    this location is commonly used for submitting form data in one of several possible
    formats, though this is in no way a requirement.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头部以一个单独的空行结束，之后可以跟随客户端希望传递给服务器的任何有效负载（其长度必须通过额外的 *Content-Length* 头部明确指定）。从协议本身的角度来看，有效负载的内容是透明的；在
    HTML 中，这个位置通常用于以几种可能的格式提交表单数据，尽管这并不是一个要求。
- en: 'Overall, a simple HTTP/1.1 request may look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，一个简单的 HTTP/1.1 请求可能看起来像这样：
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The server is expected to respond to this query by opening with a line that
    specifies the supported protocol version, a numerical status code (used to indicate
    error conditions and other special circumstances), and an optional, human-readable
    status message. A set of self-explanatory headers comes next, ending with an empty
    line. The response continues with the contents of the requested resource:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器预计会通过一行来响应这个查询，该行指定支持的协议版本、一个数值状态码（用于指示错误条件和其他特殊情况），以及一个可选的、可读的状态消息。接下来是一组自解释的头部，以一个空行结束。响应接着是请求资源的正文：
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: RFC 2616 also permits the response to be compressed in transit using one of
    three supported methods (*gzip*, *compress*, *deflate*), unless the client explicitly
    opts out by providing a suitable *Accept-Encoding* header.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2616 也允许在传输过程中使用三种支持的方法（*gzip*、*compress*、*deflate*）压缩响应，除非客户端通过提供合适的 *Accept-Encoding*
    头部明确退出。
- en: The Consequences of Supporting HTTP/0.9
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持HTTP/0.9 的后果
- en: 'Despite the improvements made in HTTP/1.0 and HTTP/1.1, the unwelcome legacy
    of the “dumb” HTTP/0.9 protocol lives on, even if it is normally hidden from view.
    The specification for HTTP/1.0 is partly to blame for this, because it requested
    that all future HTTP clients and servers support the original, half-baked draft.
    Specifically, section 3.1 says:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HTTP/1.0 和 HTTP/1.1 做出了改进，但不受欢迎的“愚蠢”HTTP/0.9 协议的遗留问题仍然存在，即使它通常隐藏在视线之外。HTTP/1.0
    的规范部分应为此负责，因为它要求所有未来的 HTTP 客户端和服务器支持原始的、半成品草案。具体来说，第 3.1 节说：
- en: HTTP/1.0 clients must . . . understand any valid response in the format of HTTP/0.9
    or HTTP/1.0.
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HTTP/1.0 客户端必须 . . . 理解任何有效的 HTTP/0.9 或 HTTP/1.0 格式的响应。
- en: 'In later years, RFC 2616 attempted to backtrack on this requirement (section
    19.6: “It is beyond the scope of a protocol specification to mandate compliance
    with previous versions.”), but acting on the earlier advice, all modern browsers
    continue to support the legacy protocol as well.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在后来的年份里，RFC 2616 试图撤销这一要求（第 19.6 节：“协议规范的范围之外是强制遵守先前版本。”），但根据早期的建议，所有现代浏览器仍然继续支持这个遗留协议。
- en: 'To understand why this pattern is dangerous, recall that HTTP/0.9 servers reply
    with nothing but the requested file. There is no indication that the responding
    party actually understands HTTP and wishes to serve an HTML document. With this
    in mind, let’s analyze what happens if the browser sends an HTTP/1.1 request to
    an unsuspecting SMTP service running on port 25 of *example.com*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种模式为何危险，回想一下 HTTP/0.9 服务器只回复请求的文件。没有任何迹象表明响应方实际上理解 HTTP 并愿意提供 HTML 文档。考虑到这一点，让我们分析一下如果浏览器向运行在
    *example.com* 端口 25 的不知情的 SMTP 服务发送 HTTP/1.1 请求会发生什么：
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because the SMTP server doesn’t understand what is going on, it’s likely to
    respond this way:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 SMTP 服务器不理解发生了什么，它很可能会这样响应：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All browsers willing to follow the RFC are compelled to accept these messages
    as the body of a valid HTTP/0.9 response and assume that the returned document
    is, indeed, HTML. These browsers will interpret the quoted attacker-controlled
    snippet appearing in one of the error messages as if it comes from the owners
    of a legitimate website at *example.com*. This profoundly interferes with the
    browser security model discussed in [Part II](pt02.html "Part II. Browser Security
    Features") of this book and, therefore, is pretty bad.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有愿意遵循 RFC 的浏览器被迫将这些消息作为有效 HTTP/0.9 响应的正文，并假设返回的文档确实是 HTML。这些浏览器将解释出现在错误消息中的一个引用的攻击者控制的片段，就像它来自
    *example.com* 的合法网站所有者一样。这严重干扰了本书第二部分（[Part II](pt02.html "Part II. Browser Security
    Features")）中讨论的浏览器安全模型，因此，这是相当糟糕的。
- en: Newline Handling Quirks
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 换行处理怪癖
- en: Setting aside the radical changes between HTTP/0.9 and HTTP/1.0, several other
    core syntax tweaks were made later in the game. Perhaps most notably, contrary
    to the letter of earlier iterations, HTTP/1.1 asks clients not only to honor newlines
    in the CRLF and LF format but also to recognize a lone CR character. Although
    this recommendation is disregarded by the two most popular web servers (IIS and
    Apache), it is followed on the client side by all browsers except Firefox.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 HTTP/0.9 和 HTTP/1.0 之间的根本变化之外，后来还进行了一些其他核心语法的调整。最值得注意的是，与早期版本的字面意思相反，HTTP/1.1
    要求客户端不仅尊重 CRLF 和 LF 格式中的换行符，还要识别单独的 CR 字符。尽管这个建议被两个最受欢迎的 Web 服务器（IIS 和 Apache）忽视，但所有浏览器（除了
    Firefox）都在客户端遵循了这一建议。
- en: 'The resulting inconsistency makes it easier for application developers to forget
    that not only LF but also CR characters must be stripped from any attacker-controlled
    values that appear anywhere in HTTP headers. To illustrate the problem, consider
    the following server response, where a user-supplied and insufficiently sanitized
    value appears in one of the headers, as highlighted in bold:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的不一致性使得应用程序开发者更容易忘记，不仅 LF，而且 CR 字符必须从 HTTP 标题中任何攻击者控制的值中删除。为了说明这个问题，考虑以下服务器响应，其中用户提供的、未充分清理的值出现在一个标题中，如粗体所示：
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To Internet Explorer, this response may appear as:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Internet Explorer 来说，这个响应可能看起来是这样的：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In fact, the class of vulnerabilities related to HTTP header newline smuggling—be
    it due to this inconsistency or just due to a failure to filter any type of a
    newline—is common enough to have its own name: *header injection* or *response
    splitting*.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，与 HTTP 标题换行符潜入相关的漏洞类别——无论是由于这种不一致性，还是仅仅因为未能过滤任何类型的换行符——已经足够常见，以至于有了自己的名称：*标题注入*或*响应分割*。
- en: 'Another little-known and potentially security-relevant tweak is support for
    multiline headers, a change introduced in HTTP/1.1\. According to the standard,
    any header line that begins with a whitespace is treated as a continuation of
    the previous one. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个鲜为人知且可能影响安全的调整是支持多行标题，这是一个在 HTTP/1.1 中引入的变更。根据标准，任何以空格开头的标题行都被视为上一行的延续。例如：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Multiline headers are recognized in client-issued requests by IIS and Apache,
    but they are not supported by Internet Explorer, Safari, or Opera. Therefore,
    any implementation that relies on or simply permits this syntax in any attacker-influenced
    setting may be in trouble. Thankfully, this is rare.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: IIS 和 Apache 会识别客户端发出的多行标题，但 Internet Explorer、Safari 或 Opera 不支持这种语法。因此，任何依赖于或简单地允许这种语法在攻击者影响的环境中的实现可能会遇到麻烦。幸运的是，这种情况很少发生。
- en: Proxy Requests
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理请求
- en: Proxies are used by many organizations and Internet service providers to intercept,
    inspect, and forward HTTP requests on behalf of their users. This may be done
    to improve performance (by allowing certain server responses to be cached on a
    nearby system), to enforce network usage policies (for example, to prevent access
    to porn), or to offer monitored and authenticated access to otherwise separated
    network environments.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 代理被许多组织和互联网服务提供商用来代表用户拦截、检查和转发 HTTP 请求。这可能是为了提高性能（通过允许某些服务器响应在附近的系统上缓存），为了执行网络使用策略（例如，防止访问色情），或者为了提供受监控和认证的网络环境访问。
- en: 'Conventional HTTP proxies depend on explicit browser support: The application
    needs to be configured to make a modified request to the proxy system, instead
    of attempting to talk to the intended destination. To request an HTTP resource
    through such a proxy, the browser will normally send a request like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的HTTP代理依赖于显式的浏览器支持：应用程序需要配置为向代理系统发送修改后的请求，而不是尝试与目标目的地通信。要通过此类代理请求HTTP资源，浏览器通常会发送如下请求：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The key difference between the above example and the usual syntax is the presence
    of a fully qualified URL in the first line of the request ([http://www.fuzzybunnies.com/](http://www.fuzzybunnies.com/)),
    instructing the proxy where to connect to on behalf of the user. This information
    is somewhat redundant, given that the *Host* header already specifies the hostname;
    the only reason for this overlap is that the mechanisms evolved independent of
    each other. To avoid being fooled by co-conspiring clients and servers, proxies
    should either correct any mismatching *Host* headers to match the request URL
    or associate cached content with a particular URL-*Host* pair and not just one
    of these values.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述示例和常规语法之间的关键区别在于请求的第一行中存在一个完全限定的URL（[http://www.fuzzybunnies.com/](http://www.fuzzybunnies.com/)），指示代理代表用户连接到何处。鉴于*Host*头已经指定了主机名，此信息有些冗余；这种重叠的唯一原因是这些机制独立发展。为了避免被共谋的客户端和服务器欺骗，代理应纠正任何不匹配的*Host*头以匹配请求URL，或者将缓存的内容与特定的URL-*Host*对相关联，而不仅仅是这些值之一。
- en: 'Many HTTP proxies also allow browsers to request non-HTTP resources, such as
    FTP files or directories. In these cases, the proxy will wrap the response in
    HTTP, and perhaps convert it to HTML if appropriate, before returning it to the
    user.^([[16](#ftn.CHP-3-FN-3)]) That said, if the proxy does not understand the
    requested protocol, or if it is simply inappropriate for it to peek into the exchanged
    data (for example, inside encrypted sessions), a different approach must be used.
    A special type of a request, CONNECT, is reserved for this purpose but is not
    further explained in the HTTP/1.1 RFC. The relevant request syntax is instead
    outlined in a separate, draft-only specification from 1998.^([[116](pr03.html#ftn.CHP-3-FT-5)])
    It looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 许多HTTP代理还允许浏览器请求非HTTP资源，例如FTP文件或目录。在这些情况下，代理将响应包装在HTTP中，并在适当的情况下将其转换为HTML，然后再将其返回给用户。[^([[16](#ftn.CHP-3-FN-3)])]
    话虽如此，如果代理不理解请求的协议，或者它不适合窥探交换的数据（例如，在加密会话中），则必须使用不同的方法。为此目的保留了一种特殊类型的请求，即CONNECT，但在HTTP/1.1
    RFC中未进一步解释。相关的请求语法在1998年的一份单独的、仅草案的规范中概述。[^([[116](pr03.html#ftn.CHP-3-FT-5)])]
    它看起来是这样的：
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the proxy is willing and able to connect to the requested destination, it
    acknowledges this request with a specific HTTP response code, and the role of
    this protocol ends. At that point, the browser will begin sending and receiving
    raw binary data within the established TCP stream; the proxy, in turn, is expected
    to forward the traffic between the two endpoints indiscriminately.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理愿意并且能够连接到请求的目标，它将通过特定的HTTP响应代码来确认此请求，此时该协议的作用结束。在此之后，浏览器将开始在建立的TCP流中发送和接收原始二进制数据；代理则预期将无差别地转发两个端点之间的流量。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hilariously, due to a subtle omission in the draft spec, many browsers have
    incorrectly processed the nonencrypted, proxy-originating error responses returned
    during an attempt to establish an encrypted connection. The affected implementations
    interpreted such plaintext responses as though they originated from the destination
    server over a secure channel. This glitch effectively eliminated all assurances
    associated with the use of encrypted communications on the Web. It took over a
    decade to spot and correct the flaw.^([[117](pr03.html#ftn.CHP-3-FT-6)])
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 搞笑的是，由于草案规范中的一个细微遗漏，许多浏览器错误地处理了在尝试建立加密连接期间返回的非加密、代理起源的错误响应。受影响的实现将此类明文响应解释为似乎来自目标服务器通过安全通道。这个故障实际上消除了与在网络上使用加密通信相关的所有保证。这个缺陷花了十多年才被发现并纠正。[^([[117](pr03.html#ftn.CHP-3-FT-6)])]
- en: 'Several other classes of lower-level proxies do not use HTTP to communicate
    directly with the browser but nevertheless inspect the exchanged HTTP messages
    to cache content or enforce certain rules. The canonical example of this is a
    transparent proxy that silently intercepts traffic at the TCP/IP level. The approach
    taken by transparent proxies is unusually dangerous: Any such proxy can look at
    the destination IP and the *Host* header sent in the intercepted connection, but
    it has no way of immediately telling if that destination IP is genuinely associated
    with the specified server name. Unless an additional lookup and correlation is
    performed, co-conspiring clients and servers can have a field day with this behavior.
    Without these additional checks, the attacker simply needs to connect to his or
    her home server and send a misleading *Host:* [www.google.com](http://www.google.com)
    header to have the response cached for all other users as though genuinely coming
    from [www.google.com](http://www.google.com).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些低级代理类不使用HTTP直接与浏览器通信，但仍然检查交换的HTTP消息以缓存内容或强制执行某些规则。这种做法的典型例子是透明代理，它在TCP/IP级别静默拦截流量。透明代理采取的方法异常危险：任何这样的代理都可以查看被拦截连接中的目标IP和*Host*头部，但它无法立即判断该目标IP是否真正与指定的服务器名称相关联。除非进行额外的查找和关联，否则共谋的客户端和服务器可以利用这种行为。如果没有这些额外的检查，攻击者只需连接到他的或她的家用服务器，并发送一个误导性的*Host:*
    [www.google.com](http://www.google.com)头部，就可以让其他所有用户的响应被缓存，就像真正来自[www.google.com](http://www.google.com)一样。
- en: Resolution of Duplicate or Conflicting Headers
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复或冲突头部的解决
- en: Despite being relatively verbose, RFC 2616 does a poor job of explaining how
    a compliant parser should resolve potential ambiguities and conflicts in the request
    or response data. Section 19.2 of this RFC (“Tolerant Applications”) recommends
    relaxed and error-tolerant parsing of certain fields in “unambiguous” cases, but
    the meaning of the term itself is, shall we say, not particularly unambiguous.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管RFC 2616相对冗长，但它对符合规范的解析器如何解决请求或响应数据中可能存在的歧义和冲突解释得并不好。本RFC的第19.2节（“宽容的应用”）建议在“明确”情况下对某些字段进行宽松和容错解析，但这个术语本身的意义，可以说，并不特别明确。
- en: 'For example, because of a lack of specification-level advice, roughly half
    of all browsers will favor the first occurrence of a particular HTTP header, and
    the rest will favor the last one, ensuring that almost every header injection
    vulnerability, no matter how constrained, is exploitable for at least some percentage
    of targeted users. On the server side, the situation is similarly random: Apache
    will honor the first *Host* header seen, while IIS will completely reject a request
    with multiple instances of this field.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于缺乏规范级别的建议，大约一半的浏览器将优先考虑特定HTTP头部的第一次出现，而其余的将优先考虑最后一次出现，确保几乎每个头部注入漏洞，无论多么受限，都能至少被一部分目标用户利用。在服务器端，情况同样随机：Apache将尊重看到的第一个*Host*头部，而IIS将完全拒绝包含多个此字段实例的请求。
- en: On a related note, the relevant RFCs contain no explicit prohibition on mixing
    potentially conflicting HTTP/1.0 and HTTP/1.1 headers and no requirement for HTTP/1.0
    servers or clients to ignore all HTTP/1.1 syntax. Because of this design, it is
    difficult to predict the outcome of indirect conflicts between HTTP/1.0 and HTTP/1.1
    directives that are responsible for the same thing, such as *Expires* and *Cache-Control*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，相关的RFC没有明确禁止混合可能冲突的HTTP/1.0和HTTP/1.1头部，也没有要求HTTP/1.0服务器或客户端忽略所有HTTP/1.1语法。正因为这种设计，很难预测HTTP/1.0和HTTP/1.1指令之间间接冲突的结果，而这些指令负责相同的事情，例如*Expires*和*Cache-Control*。
- en: 'Finally, in some rare cases, header conflict resolution is outlined in the
    spec very clearly, but the purpose of permitting such conflicts to arise in the
    first place is much harder to understand. For example, HTTP/1.1 clients are required
    to send the *Host* header on all requests, but servers (not just proxies!) are
    also required to recognize absolute URLs in the first line of the request, as
    opposed to the traditional path- and query-only method. This rule permits a curiosity
    such as this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在某些罕见的情况下，规范中对头部冲突的解决方法描述得非常清楚，但允许这种冲突最初出现的目的很难理解。例如，HTTP/1.1客户端要求在所有请求中发送*Host*头部，但服务器（不仅仅是代理！）也要求识别请求的第一行中的绝对URL，而不是传统的路径和查询方法。这条规则允许这种好奇心：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, section 5.2 of RFC 2616 instructs clients to disregard the nonfunctional
    (but still mandatory!) *Host* header, and many implementations follow this advice.
    The problem is that underlying applications are likely to be unaware of this quirk
    and may instead make somewhat important decisions based on the inspected header
    value.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，RFC 2616的第5.2节指示客户端忽略非功能性的（但仍然是强制性的！）*Host*标题，许多实现都遵循这一建议。问题是底层应用程序可能不会意识到这个怪癖，而可能会基于检查的标题值做出一些重要的决定。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When complaining about the omissions in the HTTP RFCs, it is important to recognize
    that the alternatives can be just as problematic. In several scenarios outlined
    in that RFC, the desire to explicitly mandate the handling of certain corner cases
    led to patently absurd outcomes. One such example is the advice on parsing dates
    in certain HTTP headers, at the request of section 3.3 in RFC 1945\. The resulting
    implementation (the *prtime.c* file in the Firefox codebase^([[118](pr03.html#ftn.CHP-3-FT-7)]))
    consists of close to 2,000 lines of extremely confusing and unreadable C code
    just to decipher the specified date, time, and time zone in a sufficiently fault-tolerant
    way (for uses such as deciding cache content expiration).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当抱怨HTTP RFCs中的遗漏时，重要的是要认识到替代方案可能同样有问题。在该RFC中概述的几个场景中，明确要求处理某些边缘情况的需求导致了明显荒谬的结果。一个这样的例子是关于解析某些HTTP标题中日期的建议，这是根据RFC
    1945第3.3节的要求提出的。结果实现（Firefox代码库中的 *prtime.c* 文件^([[118](pr03.html#ftn.CHP-3-FT-7)]))包含接近2,000行极其混乱且难以阅读的C代码，只是为了以足够容错的方式解析指定的日期、时间和时区（例如，用于决定缓存内容过期）。
- en: Semicolon-Delimited Header Values
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分号分隔的标题值
- en: Several HTTP headers, such as *Cache-Control* or *Content-Disposition*, use
    a semicolon-delimited syntax to cram several separate *name=value* pairs into
    a single line. The reason for allowing this nested notation is unclear, but it
    is probably driven by the belief that it will be a more efficient or a more intuitive
    approach that using several separate headers that would always have to go hand
    in hand.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 几个HTTP标题，例如 *Cache-Control* 或 *Content-Disposition*，使用分号分隔的语法，将多个单独的 *name=value*
    对压缩到一行中。允许这种嵌套记法的原因尚不清楚，但可能是由这样的信念驱动的：它将比使用多个单独的标题更高效或更直观，而这些标题总是必须一起使用。
- en: Some use cases outlined in RFC 2616 permit *quoted-string* as the right-hand
    parameter in such pairs. *Quoted-string* is a syntax in which a sequence of arbitrary
    printable characters is surrounded by double quotes, which act as delimiters.
    Naturally, the quote mark itself cannot appear inside the string, but—importantly—a
    semicolon or a whitespace may, permitting many otherwise problematic values to
    be sent as is.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2616中概述的一些用例允许 *quoted-string* 作为此类对中的右侧参数。*quoted-string* 是一种语法，其中一系列任意可打印字符被双引号包围，这些引号充当分隔符。自然地，引号本身不能出现在字符串中，但——重要的是——分号或空白字符可以，允许许多其他情况下可能有问题值被原样发送。
- en: 'Unfortunately for developers, Internet Explorer does not cope with the *quoted-string*
    syntax particularly well, effectively rendering this encoding scheme useless.
    The browser will parse the following line (which is meant to indicate that the
    response is a downloadable file rather than an inline document) in an unexpected
    way:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于开发者来说，Internet Explorer并不擅长处理 *quoted-string* 语法，实际上使这种编码方案变得无用。浏览器将以意想不到的方式解析以下行（其目的是指示响应是可下载的文件而不是内联文档）：
- en: '[PRE21]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Microsoft’s implementation, the filename will be truncated at the semicolon
    character and will appear to be *evil_file.exe*. This behavior creates a potential
    hazard to any application that relies on examining or appending a “safe” filename
    extension to an attacker-controlled filename and otherwise correctly checks for
    the quote character and newlines in this string.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft的实现中，文件名将在分号字符处截断，并看起来像 *evil_file.exe*。这种行为对任何依赖于检查或向攻击者控制的文件名添加“安全”文件扩展名并正确检查此字符串中的引号字符和新行的应用程序构成了潜在的风险。
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An additional *quoted-pair* mechanism is provided to allow quotes (and any other
    characters) to be used safely in the string when prefixed by a backslash. This
    mechanism appears to be specified incorrectly, however, and not supported by any
    major browser except for Opera. For *quoted-pair* to work properly, stray “\”
    characters would need to be banned from the *quoted-string*, which isn’t the case
    in RFC 2616\. *Quoted-pair* also permits any *CHAR*-type token to be quoted, including
    newlines, which is incompatible with other HTTP-parsing rules.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一种额外的 *quoted-pair* 机制，允许在字符串前加上反斜杠时安全地使用引号（以及任何其他字符）。然而，这种机制似乎被错误地指定，并且除了
    Opera 以外，没有任何主流浏览器支持。为了使 *quoted-pair* 正确工作，需要禁止 *quoted-string* 中的“\”字符，但在 RFC
    2616 中并非如此。*Quoted-pair* 还允许任何 *CHAR*-type 令牌被引用，包括换行符，这与其他 HTTP 解析规则不兼容。
- en: It is also worth noting that when duplicate semicolon-delimited fields are found
    in a single HTTP header, their order of precedence is not defined by the RFC.
    In the case of *filename=* in *Content-Disposition*, all mainstream browsers use
    the first occurrence. But there is little consistency elsewhere. For example,
    when extracting the *URL=* value from the *Refresh* header (used to force reloading
    the page after a specified amount of time), Internet Explorer 6 will fall back
    to the last instance, yet all other browsers will prefer the first one. And when
    handling *Content-Type*, Internet Explorer, Safari, and Opera will use the first
    *charset=* value, while Firefox and Chrome will rely on the last.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当在单个 HTTP 标头中找到重复的分号分隔字段时，它们的优先级顺序在 RFC 中并未定义。在 *Content-Disposition*
    中的 *filename=* 的情况下，所有主流浏览器都使用第一次出现。但其他地方的一致性很少。例如，当从 *Refresh* 标头（用于在指定时间后强制重新加载页面）中提取
    *URL=* 值时，Internet Explorer 6 将回退到最后一个实例，而所有其他浏览器都会选择第一个。当处理 *Content-Type* 时，Internet
    Explorer、Safari 和 Opera 将使用第一个 *charset=* 值，而 Firefox 和 Chrome 将依赖于最后一个。
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Food for thought: A fascinating but largely non-security-related survey of
    dozens of inconsistencies associated with the handling of just a single HTTP header—*Content-Disposition*—can
    be found on a page maintained by Julian Reschke: [http://greenbytes.de/tech/tc2231/](http://greenbytes.de/tech/tc2231/).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 思考食物：Julian Reschke 维护的一页上可以找到与单个 HTTP 标头——*Content-Disposition*——处理相关的数十个不一致性的迷人但主要与安全无关的调查。[http://greenbytes.de/tech/tc2231/](http://greenbytes.de/tech/tc2231/)
- en: Header Character Set and Encoding Schemes
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题字符集和编码方案
- en: Like the documents that laid the groundwork for URL handling, all subsequent
    HTTP specs have largely avoided the topic of dealing with non-US-ASCII characters
    inside header values. There are several plausible scenarios where non-English
    text may legitimately appear in this context (for example, the filename in *Content-Disposition*),
    but when it comes to this, the expected browser behavior is essentially undefined.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与为 URL 处理奠定基础的文档一样，所有后续的 HTTP 规范在很大程度上都避免了处理标头值中非 US-ASCII 字符的话题。有几个合理的场景下，非英语文本可能合法地出现在这个上下文中（例如，*Content-Disposition*
    中的文件名），但在这方面，预期的浏览器行为基本上是未定义的。
- en: 'Originally, RFC 1945 permitted the TEXT token (a primitive broadly used to
    define the syntax of other fields) to contain 8-bit characters, providing the
    following definition:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，RFC 1945 允许 TEXT 令牌（一种广泛用于定义其他字段语法的原始令牌）包含 8 位字符，提供了以下定义：
- en: '[PRE22]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The RFC followed up with cryptic advice: When non-US-ASCII characters are encountered
    in a TEXT field, clients and servers *may* interpret them as ISO-8859-1, the standard
    Western European code page, but they don’t have to. Later, RFC 2616 copied and
    pasted the same specification of TEXT tokens but added a note that non-ISO-8859-1
    strings must be encoded using a format outlined in RFC 2047,^([[119](pr03.html#ftn.CHP-3-FT-8)])
    originally created for email communications. Fair enough; in this simple scheme,
    the encoded string opens with a “=?” prefix, followed by a character-set name,
    a “?q?” or “?b?” encoding-type indicator (*quoted-printable*^([[17](#ftn.CHP-3-FN-4)])
    or *base64*,^([[18](#ftn.CHP-3-FN-5)]) respectively), and lastly the encoded string
    itself. The sequence ends with a “?=” terminator. An example of this may be:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: RFC随后给出了神秘的建议：当在TEXT字段中遇到非US-ASCII字符时，客户端和服务器*可能*将它们解释为ISO-8859-1，即标准的西欧代码页，但不必这样做。后来，RFC
    2616复制并粘贴了相同的TEXT令牌规范，但增加了一个注释，指出非ISO-8859-1字符串必须使用RFC 2047中概述的格式进行编码，^([[119](pr03.html#ftn.CHP-3-FT-8)])该格式最初是为电子邮件通信创建的。公平地说；在这个简单的方案中，编码的字符串以“=?”前缀开始，后面跟一个字符集名称，一个“?q?”或“?b?”编码类型指示器（*quoted-printable*^([[17](#ftn.CHP-3-FN-4)])或*base64*^([[18](#ftn.CHP-3-FN-5)]))，最后是编码的字符串本身。序列以“?=”终止符结束。一个例子可能是：
- en: '[PRE23]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The RFC should also have stated that any spurious “=?...?=” patterns must never
    be allowed as is in the relevant headers, in order to avoid unintended decoding
    of values that were not really encoded to begin with.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: RFC还应指出，任何虚假的“=?...?=”模式都不应直接允许出现在相关头中，以避免对实际上并未编码的值进行意外的解码。
- en: 'Sadly, the support for this RFC 2047 encoding is spotty. It is recognized in
    some headers by Firefox and Chrome, but other browsers are less cooperative. Internet
    Explorer chooses to recognize URL-style percent encoding in the *Content-Disposition*
    field instead (a habit also picked up by Chrome) and defaults to UTF-8 in this
    case. Firefox and Opera, on the other hand, prefer supporting a peculiar percent-encoded
    syntax proposed in RFC 2231,^([[120](pr03.html#ftn.CHP-3-FT-9)]) a striking deviation
    from how HTTP syntax is supposed to look:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，对这种RFC 2047编码的支持参差不齐。Firefox和Chrome在某些头中识别它，但其他浏览器合作较少。Internet Explorer选择在*Content-Disposition*字段中识别URL风格的百分编码，这种情况也被Chrome采纳）并默认使用UTF-8。另一方面，Firefox和Opera更喜欢支持RFC
    2231中提出的独特百分编码语法，^([[120](pr03.html#ftn.CHP-3-FT-9)）这与HTTP语法应有的样子有显著差异：
- en: '[PRE24]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Astute readers may notice that there is no single encoding scheme supported
    by all browsers at once. This situation prompts some web application developers
    to resort to using raw high-bit values in the HTTP headers, typically interpreted
    as UTF-8, but doing so is somewhat unsafe. In Firefox, for example, a long-standing
    glitch causes UTF-8 text to be mangled when put in the *Cookie* header, permitting
    attacker-injected cookie delimiters to materialize in unexpected places.^([[121](pr03.html#ftn.CHP-3-FT-10)])
    In other words, there are no easy and robust solutions to this mess.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能会注意到，没有一种编码方案被所有浏览器同时支持。这种情况促使一些Web应用程序开发者求助于在HTTP头中使用原始的高位值，通常解释为UTF-8，但这样做是相当不安全的。例如，在Firefox中，一个长期存在的漏洞导致UTF-8文本在放入*Cookie*头时被破坏，允许攻击者注入的cookie分隔符出现在意想不到的地方.^([[121](pr03.html#ftn.CHP-3-FT-10)）。换句话说，没有简单且健壮的解决方案来解决这个问题。
- en: When discussing character encodings, the problem of handling of the NUL character
    (0x00) probably deserves a mention. This character, used as a string terminator
    in many programming languages, is technically prohibited from appearing in HTTP
    headers (except for the aforementioned, dysfunctional *quoted-pair* syntax), but
    as you may recall, parsers are encouraged to be tolerant. When this character
    is allowed to go through, it is likely to have unexpected side effects. For example,
    *Content-Disposition* headers are truncated at NUL by Internet Explorer, Firefox,
    and Chrome but not by Opera or Safari.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论字符编码时，处理空字符（0x00）的问题可能值得提及。这个字符在许多编程语言中用作字符串终止符，在技术上禁止出现在HTTP头中（除了上述功能不正常的*quoted-pair*语法），但正如你可能记得的，解析器被鼓励要有容忍度。当这个字符被允许通过时，它可能会产生意外的副作用。例如，*Content-Disposition*头在NUL处被Internet
    Explorer、Firefox和Chrome截断，但不是Opera或Safari。
- en: Referer Header Behavior
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用头行为
- en: As mentioned earlier in this chapter, HTTP requests may include a *Referer*
    header. This header contains the URL of a document that triggered the current
    navigation in some way. It is meant to help with certain troubleshooting tasks
    and to promote the growth of the Web by emphasizing cross-references between related
    web pages.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，HTTP请求可能包括一个*Referer*标题。此标题包含以某种方式触发当前导航的文档的URL。它的目的是帮助进行某些故障排除任务，并通过强调相关网页之间的交叉引用来促进网络的增长。
- en: Unfortunately, the header may also reveal some information about user browsing
    habits to certain unfriendly parties, and it may leak sensitive information that
    is encoded in the URL query parameters on the referring page. Due to these concerns,
    and the subsequent poor advice on how to mitigate them, the header is often misused
    for security or policy enforcement purposes, but it is not up to the task. The
    main problem is that there is no way to differentiate between a client that is
    not providing the header because of user privacy preferences, one that is not
    providing it because of the type of navigation taking place, and one that is deliberately
    tricked into hiding this information by a malicious referring site.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，此标题也可能向某些不友好方透露有关用户浏览习惯的信息，并且它可能泄露在引用页面URL查询参数中编码的敏感信息。由于这些担忧以及随后的缓解这些担忧的糟糕建议，该标题经常被误用于安全或政策执行目的，但它并不胜任这项任务。主要问题是无法区分一个客户端没有提供标题是因为用户隐私偏好，一个客户端没有提供标题是因为正在进行的导航类型，以及一个客户端被恶意引用网站故意欺骗以隐藏这些信息。
- en: 'Normally, this header is included in most HTTP requests (and preserved across
    HTTP-level redirects), except in the following scenarios:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，此标题包含在大多数HTTP请求中（并在HTTP级别重定向中保留），但在以下场景中除外：
- en: After organically entering a new URL into the address bar or opening a bookmarked
    page.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有机地将新URL输入地址栏或打开书签页面后。
- en: When the navigation originates from a pseudo-URL document, such as *data:* or
    *javascript:*.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当导航来自伪URL文档时，例如*data:*或*javascript:*。
- en: When the request is a result of redirection controlled by the *Refresh* header
    (but not a *Location*-based one).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求是由*Refresh*标题控制的重定向结果（但不是基于*Location*的重定向）。
- en: Whenever the referring site is encrypted but the requested page isn’t. According
    to RFC 2616 section 15.1.2, this is done for privacy reasons, but it does not
    make a lot of sense. The *Referer* string is still disclosed to third parties
    when one navigates from one encrypted domain to an unrelated encrypted one, and
    rest assured, the use of encryption is not synonymous with trustworthiness.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当引用网站加密但请求的页面未加密时。根据RFC 2616第15.1.2节，这是出于隐私原因，但这并没有太多意义。当从一个加密域导航到不相关的加密域时，*Referer*字符串仍然会向第三方披露，请放心，加密的使用并不等同于可信性。
- en: If the user decides to block or spoof the header by tweaking browser settings
    or installing a privacy-oriented plug-in.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户决定通过调整浏览器设置或安装以隐私为导向的插件来阻止或伪造此标题。
- en: As should be apparent, four out of five of these conditions can be purposefully
    induced by any rogue site.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如应明显，这五个条件中有四个可以通过任何恶意网站故意诱导。
- en: '* * *'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[14](#CHP-3-FN-1)]) *Transmission Control Protocol (TCP)* is one of the core
    communications protocols of the Internet, providing the transport layer to any
    application protocols built on top of it. TCP offers reasonably reliable, peer-acknowledged,
    ordered, session-based connectivity between networked hosts. In most cases, the
    protocol is also fairly resilient against blind packet spoofing attacks attempted
    by other, nonlocal hosts on the Internet.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#CHP-3-FN-1)]) 传输控制协议（TCP）是互联网的核心通信协议之一，为构建在其之上的任何应用协议提供传输层。TCP为网络主机之间提供合理可靠的、对等确认的、有序的、基于会话的连接。在大多数情况下，该协议对其他非本地主机尝试的盲目数据包伪造攻击也相当有弹性。
- en: ^([[15](#CHP-3-FN-2)]) MIME type (aka *Internet media type*) is a simple, two-component
    value identifying the class and format of any given computer file. The concept
    originated in RFC 2045 and RFC 2046, where it served as a way to describe email
    attachments. The registry of official values (such as *text/plain* or *audio/mpeg*)
    is currently maintained by IANA, but ad hoc types are fairly common.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#CHP-3-FN-2)]) MIME类型（也称为*Internet媒体类型*）是一个简单的两分量值，用于标识任何给定计算机文件的类别和格式。该概念起源于RFC
    2045和RFC 2046，当时它被用作描述电子邮件附件的方式。官方值注册表（如*text/plain*或*audio/mpeg*）目前由IANA维护，但临时类型相当常见。
- en: ^([[16](#CHP-3-FN-3)]) In this case, some HTTP headers supplied by the client
    may be used internally by the proxy, but they will not be transmitted to the non-HTTP
    endpoint, which creates some interesting, if non-security-relevant, protocol ambiguities.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#CHP-3-FN-3)]) 在这种情况下，客户端提供的某些 HTTP 头部可能被代理内部使用，但它们不会被传输到非 HTTP 终端，这创造了一些有趣但与安全无关的协议歧义。
- en: ^([[17](#CHP-3-FN-4)]) *Quoted-printable* is a simple encoding scheme that replaces
    any nonprintable or otherwise illegal characters with the equal sign (=) followed
    by a 2-digit hexadecimal representation of the 8-bit character value to be encoded.
    Any stray equal signs in the input text must be replaced with “=3D” as well.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#CHP-3-FN-4)]) *Quoted-printable* 是一种简单的编码方案，它将任何不可打印或非法字符替换为等号 (=)
    后跟要编码的 8 位字符值的 2 位十六进制表示。输入文本中的任何多余的等号都必须替换为“=3D”。
- en: ^([[18](#CHP-3-FN-5)]) *Base64* is a non-human-readable encoding that encodes
    arbitrary 8-bit input using a 6-bit alphabet of case-sensitive alphanumerics,
    “+”, and “/”. Every 3 bytes of input map to 4 bytes of output. If the input does
    not end at a 3-byte boundary, this is indicated by appending one or two equal
    signs at the end of the output string.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#CHP-3-FN-5)]) *Base64* 是一种非人类可读的编码，它使用大小写敏感的字母数字、加号（“+”）和斜杠（“/”）的 6
    位字母表来编码任意 8 位输入。每 3 个字节的输入映射到 4 个字节的输出。如果输入不以 3 个字节的边界结束，则通过在输出字符串末尾附加一个或两个等号来表示。
- en: HTTP Request Types
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 请求类型
- en: 'The original HTTP/0.9 draft provided a single method (or “verb”) for requesting
    a document: GET. The subsequent proposals experimented with an increasingly bizarre
    set of methods to permit interactions other than retrieving a document or running
    a script, including such curiosities as SHOWMETHOD, CHECKOUT, or—why not—SPACEJUMP.^([[122](pr03.html#ftn.CHP-3-FT-11)])'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 HTTP/0.9 草案提供了一个用于请求文档的单个方法（或“动词”）：GET。随后的提案尝试了一系列越来越奇怪的方法，以允许除了检索文档或运行脚本之外的其他交互，包括诸如
    SHOWMETHOD、CHECKOUT 或——为什么不呢——SPACEJUMP 这样的奇特方法.^([[122](pr03.html#ftn.CHP-3-FT-11)])
- en: Most of these thought experiments have been abandoned in HTTP/1.1, which settles
    on a more manageable set of eight methods. Only the first two request types—GET
    and POST—are of any significance to most of the modern Web.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些思想实验在 HTTP/1.1 中已被放弃，它确定了一套更易于管理的八种方法。只有前两种请求类型——GET 和 POST——对大多数现代 Web
    具有任何意义。
- en: GET
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET
- en: The GET method is meant to signify information retrieval. In practice, it is
    used for almost all client-server interactions in the course of a normal browsing
    session. Regular GET requests carry no browser-supplied payloads, although they
    are not strictly prohibited from doing so.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: GET 方法旨在表示信息检索。在实践中，它被用于正常浏览会话期间几乎所有客户端-服务器交互。常规 GET 请求不携带浏览器提供的有效负载，尽管它们并不严格禁止这样做。
- en: The expectation is that GET requests should not have, to quote the RFC, “significance
    of taking an action other than retrieval” (that is, they should make no persistent
    changes to the state of the application). This requirement is increasingly meaningless
    in modern web applications, where the application state is often not even managed
    entirely on the server side; consequently, the advice is widely ignored by application
    developers.^([[19](#ftn.CHP-3-FN-6)])
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 预期 GET 请求不应具有，引用 RFC 中的说法，“采取除检索之外行动的意义”（也就是说，它们不应对应用程序的状态造成持久性更改）。在现代网络应用中，这一要求越来越没有意义，因为应用程序的状态通常甚至不在服务器端完全管理；因此，这一建议被应用程序开发者广泛忽视.^([[19](#ftn.CHP-3-FN-6)])
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In HTTP/1.1, clients may ask the server for any set of possibly noncontiguous
    or overlapping fragments of the target document by specifying the *Range* header
    on GET (and, less commonly, on some other types of requests). The server is not
    obliged to comply, but where the mechanism is available, browsers may use it to
    resume aborted downloads.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP/1.1 中，客户端可以通过在 GET 请求（以及较少见的其他请求类型）中指定 *Range* 头部来请求目标文档的任何一组可能非连续或重叠的片段。服务器没有义务遵守，但如果机制可用，浏览器可以使用它来恢复中断的下载。
- en: POST
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST
- en: The POST method is meant for submitting information (chiefly HTML forms) to
    the server for processing. Because POST actions may have persistent side effects,
    many browsers ask the user to confirm before reloading any content retrieved with
    POST, but for the most part, GET and POST are used in a quasi-interchangeable
    manner.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: POST 方法旨在将信息（主要是 HTML 表单）提交给服务器进行处理。由于 POST 操作可能具有持久性副作用，许多浏览器在重新加载使用 POST 获取的任何内容之前都会要求用户确认，但就大部分而言，GET
    和 POST 以准可互换的方式使用。
- en: POST requests are commonly accompanied by a payload, the length of which is
    indicated by the *Content-Length* header. In the case of plain HTML, the payload
    may consist of URL-encoded or MIME-encoded form data (a format detailed in [Chapter 4](ch04.html
    "Chapter 4. Hypertext Markup Language")), although again, the syntax is not constrained
    at the HTTP level in any special way.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: POST 请求通常伴随着一个负载，其长度由 *Content-Length* 头部指示。在纯 HTML 的情况下，负载可能由 URL 编码或 MIME
    编码的表单数据组成（格式在第 4 章[第 4 章。超文本标记语言](ch04.html "第 4 章。超文本标记语言")中详细说明），尽管再次强调，在 HTTP
    层面上，其语法并没有任何特殊的限制。
- en: HEAD
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HEAD
- en: HEAD is a rarely used request type that is essentially identical to GET but
    that returns only the HTTP headers, and not the actual payload, for the requested
    content. Browsers generally do not issue HEAD requests on their own, but the method
    is sometimes employed by search engine bots and other automated tools, for example,
    to probe for the existence of a file or to check its modification time.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: HEAD 是一种很少使用的请求类型，它与 GET 实质上相同，但只返回请求内容的 HTTP 头部，而不是实际的负载。浏览器通常不会自行发出 HEAD 请求，但该方法有时会被搜索引擎爬虫和其他自动化工具使用，例如，用于探测文件的存在或检查其修改时间。
- en: OPTIONS
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OPTIONS
- en: OPTIONS is a metarequest that returns the set of supported methods for a particular
    URL (or “*”, meaning the server in general) in a response header. The OPTIONS
    method is almost never used in practice, except for server fingerprinting; because
    of its limited value, the returned information may not be very accurate.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: OPTIONS 是一个元请求，它返回特定 URL（或“*”，表示服务器本身）在响应头中支持的集合方法。在实际情况中，OPTIONS 方法几乎从不使用，除了用于服务器指纹识别；由于其价值有限，返回的信息可能并不非常准确。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of completeness, we need to note that OPTIONS requests are also
    a cornerstone of a proposed cross-domain request authorization scheme, and as
    such, they may gain some prominence soon. We will revisit this scheme, and explore
    many other upcoming browser security features, in [Chapter 16](ch16.html "Chapter 16. New
    and Upcoming Security Features").
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们需要指出，OPTIONS 请求也是一项提议的跨域请求授权方案的基础，因此它们可能会很快获得一些重视。我们将在[第 16 章](ch16.html
    "第 16 章。新和即将推出的安全功能")中重新审视这个方案，并探讨许多即将推出的浏览器安全功能。
- en: PUT
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PUT
- en: A PUT request is meant to allow files to be uploaded to the server at the specified
    target URL. Because browsers do not support PUT, intentional file-upload capabilities
    are almost always implemented through POST to a server-side script, rather than
    with this theoretically more elegant approach.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: PUT 请求的目的是允许将文件上传到指定的目标 URL 所在的服务器。由于浏览器不支持 PUT，故有意文件上传功能几乎总是通过 POST 到服务器端脚本实现，而不是使用这种理论上更优雅的方法。
- en: That said, some nonweb HTTP clients and servers may use PUT for their own purposes.
    Just as interestingly, some web servers may be misconfigured to process PUT requests
    indiscriminately, creating an obvious security risk.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，一些非 Web HTTP 客户端和服务器可能会出于自己的目的使用 PUT。同样有趣的是，一些 Web 服务器可能配置错误，会无差别地处理 PUT
    请求，从而造成明显的安全风险。
- en: DELETE
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DELETE
- en: DELETE is a self-explanatory method that complements PUT (and that is equally
    uncommon in practice).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE 是一种自解释的方法，它补充了 PUT（在实际情况中同样不常见）。
- en: TRACE
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TRACE
- en: TRACE is a form of “ping” request that returns information about all the proxy
    hops involved in processing a request and echoes the original request as well.
    TRACE requests are not issued by web browsers and are seldom used for legitimate
    purposes. TRACE’s primary use is for security testing, where it may reveal interesting
    details about the internal architecture of HTTP servers in a remote network. Precisely
    for this reason, the method is often disabled by server administrators.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: TRACE 是一种“ping”请求的形式，它返回有关处理请求所涉及的所有代理跳转的信息，并回显原始请求。TRACE 请求不是由 Web 浏览器发出的，并且很少用于合法目的。TRACE
    的主要用途是安全测试，它可能会揭示远程网络中 HTTP 服务器内部结构的有趣细节。正是出于这个原因，服务器管理员通常会禁用此方法。
- en: CONNECT
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CONNECT
- en: The CONNECT method is reserved for establishing non-HTTP connections through
    HTTP proxies. It is not meant to be issued directly to servers. If the support
    for CONNECT request is enabled accidentally on a particular server, it may pose
    a security risk by offering an attacker a way to tunnel TCP traffic into an otherwise
    protected network.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: CONNECT 方法是为通过 HTTP 代理建立非 HTTP 连接而保留的。它不是直接发送给服务器的。如果某个服务器意外启用了 CONNECT 请求的支持，它可能会通过为攻击者提供一种将
    TCP 流量隧道到本应受保护的网络中的方式，从而构成安全风险。
- en: Other HTTP Methods
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 HTTP 方法
- en: A number of other request methods may be employed by other nonbrowser applications
    or browser extensions; the most popular set of HTTP extensions may be WebDAV,
    an authoring and version-control protocol described in RFC 4918.^([[123](pr03.html#ftn.CHP-3-FT-12)])
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他请求方法可能被其他非浏览器应用程序或浏览器扩展使用；最受欢迎的一组HTTP扩展可能是WebDAV，这是一个在RFC 4918中描述的作者和版本控制协议.^([[123](pr03.html#ftn.CHP-3-FT-12)])
- en: Further, the *XMLHttpRequest* API nominally allows client-side JavaScript to
    make requests with almost arbitrary methods to the originating server—although
    this last functionality is heavily restricted in certain browsers (we will look
    into this in [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic")).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*XMLHttpRequest* API名义上允许客户端JavaScript以几乎任意的方法向原始服务器发出请求——尽管这种最后的功能在某些浏览器中受到严格限制（我们将在第9章[内容隔离逻辑](ch09.html
    "第9章。内容隔离逻辑")中探讨这一点）。
- en: '* * *'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[19](#CHP-3-FN-6)]) There is an anecdotal (and perhaps even true) tale of
    an unfortunate webmaster by the name of John Breckman. According to the story,
    John’s website has been accidentally deleted by a search engine-indexing robot.
    The robot simply unwittingly discovered an unauthenticated, GET-based administrative
    interface that John had built for his site . . . and happily followed every “delete”
    link it could find.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#CHP-3-FN-6)]) 有一个关于不幸的网站管理员约翰·布雷克曼的轶事（也许甚至是真的）。据故事所说，约翰的网站被搜索引擎索引机器人意外删除。机器人无意中发现了约翰为他的网站构建的一个未经身份验证的基于GET的行政界面……并且高兴地跟随它找到的每一个“删除”链接。
- en: Server Response Codes
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器响应代码
- en: Section 10 of RFC 2616 lists nearly 50 status codes that a server may choose
    from when constructing a response. About 15 of these are used in real life, and
    the rest are used to indicate increasingly bizarre or unlikely states, such as
    “402 Payment Required” or “415 Unsupported Media Type.” Most of the RFC-listed
    states do not map cleanly to the behavior of modern web applications; the only
    reason for their existence is that somebody hoped they eventually would.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2616的第10节列出了服务器在构建响应时可能选择的近50个状态代码。其中大约有15个在实际生活中使用，其余的用于表示越来越奇怪或不寻常的状态，例如“402需要付款”或“415不支持的媒体类型”。大多数RFC列出的状态与现代Web应用程序的行为不匹配；它们存在的唯一原因是有人希望它们最终会这样。
- en: A few codes are worth memorizing because they are common or carry special meaning,
    as discussed below.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码值得记忆，因为它们很常见或具有特殊含义，如下所述。
- en: '200-299: Success'
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 200-299：成功
- en: 'This range of status codes is used to indicate a successful completion of a
    request:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态代码范围用于表示请求的成功完成：
- en: '**200 OK**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**200 OK**'
- en: This is a normal response to a successful GET or POST. The browser will display
    the subsequently returned payload to the user or will process it in some other
    context-specific way.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对成功GET或POST的正常响应。浏览器将显示随后返回的有效载荷给用户，或以某种其他上下文特定的方式处理它。
- en: '**204 No Content**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**204无内容**'
- en: This code is sometimes used to indicate a successful request to which no verbose
    response is expected. A 204 response aborts navigation to the URL that triggered
    it and keeps the user on the originating page.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码有时用于表示一个成功的请求，不需要详细的响应。204响应会中止触发它的URL的导航，并保持用户在原始页面上。
- en: '**206 Partial Content**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**206部分内容**'
- en: This code is like 200, except that it is returned by servers in response to
    range requests. The browser must already have a portion of the document (or it
    would not have issued a range request) and will normally inspect the *Content-Range*
    response header to reassemble the document before further processing it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码类似于200，但它是服务器在响应范围请求时返回的。浏览器必须已经拥有文档的一部分（否则它不会发出范围请求），并且通常会在进一步处理之前检查*Content-Range*响应头以重新组装文档。
- en: '300-399: Redirection and Other Status Messages'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 300-399：重定向和其他状态消息
- en: 'These codes are used to communicate a variety of states that do not indicate
    an error but that require special handling on the browser end:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码用于传达各种状态，这些状态不表示错误，但需要在浏览器端进行特殊处理：
- en: '**301 Moved Permanently, 302 Found, 303 See Other**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**301永久移动，302找到，303查看其他**'
- en: This response instructs the browser to retry the request at a new location,
    specified in the *Location* response header. Despite the distinctions made in
    the RFC, when encountering any of these response codes, all modern browsers replace
    POST with GET, remove the payload, and then resubmit the request automatically.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应指示浏览器在新位置重试请求，该位置由 *Location* 响应头指定。尽管 RFC 中有明确的区分，但当遇到这些响应代码中的任何一个时，所有现代浏览器都会自动将
    POST 替换为 GET，删除有效载荷，然后重新提交请求。
- en: Note
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Redirect messages may contain a payload, but if they do, this message will not
    be shown to the user unless the redirection is not possible (for example, because
    of a missing or unsupported *Location* value). In fact, in some browsers, display
    of the message may be suppressed even in that scenario.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向消息可能包含有效载荷，但如果包含，除非重定向不可行（例如，由于缺少或不支持的 *Location* 值），否则此消息不会显示给用户。实际上，在某些浏览器中，即使在那种情况下，也可能抑制消息的显示。
- en: '**304 Not Modified**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**304 未修改**'
- en: This nonredirect response instructs the client that the requested document hasn’t
    been modified in relation to the copy the client already has. This response is
    seen after conditional requests with headers such as *If-Modified-Since*, which
    are issued to revalidate the browser document cache. The response body is not
    shown to the user. (If the server responds this way to an unconditional request,
    the result will be browser-specific and may be hilarious; for example, Opera will
    pop up a nonfunctional download prompt.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非重定向响应指示客户端，请求的文档与客户端已有的副本相比没有修改。这个响应通常出现在带有 *If-Modified-Since* 等头的条件请求之后，这些请求是为了重新验证浏览器文档缓存。响应体不会显示给用户。（如果服务器对无条件请求以这种方式响应，结果将是浏览器特定的，可能非常有趣；例如，Opera
    将弹出非功能性的下载提示。）
- en: '**307 Temporary Redirect**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**307 临时重定向**'
- en: Similar to 302, but unlike with other modes of redirection, browsers will not
    downgrade POST to GET when following a 307 redirect. This code is not commonly
    used in web applications, and some browsers do not behave very consistently when
    handling it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与 302 类似，但与其它重定向模式不同，当遵循 307 重定向时，浏览器不会将 POST 降级为 GET。这个代码在 Web 应用程序中不常用，一些浏览器在处理它时表现并不一致。
- en: '400-499: Client-Side Error'
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '400-499: 客户端错误'
- en: 'This range of codes is used to indicate error conditions caused by the behavior
    of the client:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码范围用于指示由客户端行为引起的错误条件：
- en: '**400 Bad Request (and related messages)**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**400 错误请求（及相关消息）**'
- en: The server is unable or unwilling to process the request for some unspecified
    reason. The response payload will usually explain the problem to some extent and
    will be typically handled by the browser just like a 200 response.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器无法或不愿意以某种未指定原因处理请求。响应有效载荷通常会在一定程度上解释问题，并且通常会被浏览器像 200 响应一样处理。
- en: More specific variants, such as “411 Length Required,” “405 Method Not Allowed,”
    or “414 Request-URI Too Long,” also exist. It’s anyone’s guess as to why not specifying
    *Content-Length* when required has a dedicated 411 response code but not specifying
    *Host* deserves only a generic 400 one.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 存在更多具体的变体，例如“411 长度要求”，“405 方法不允许”或“414 请求-URI 太长”，也都有。为什么在需要指定 *Content-Length*
    时有专门的 411 响应代码，而未指定 *Host* 只需要通用的 400 响应代码，这谁也说不清。
- en: '**401 Unauthorized**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**401 未授权**'
- en: This code means that the user needs to provide protocol-level HTTP authentication
    credentials in order to access the resource. The browser will usually prompt the
    user for login information next, and it will present a response body only if the
    authentication process is unsuccessful. This mechanism will be explained in more
    detail shortly, in [HTTP Authentication](ch03s08.html "HTTP Authentication") in
    [HTTP Authentication](ch03s08.html "HTTP Authentication").
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码意味着用户需要提供协议级别的 HTTP 认证凭据才能访问资源。浏览器通常会提示用户输入登录信息，并且只有在认证过程失败时才会呈现响应体。这个机制将在稍后的
    [HTTP 认证](ch03s08.html "HTTP Authentication") 中详细介绍。
- en: '**403 Forbidden**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**403 禁止访问**'
- en: The requested URL exists but can’t be accessed for reasons other than incorrect
    HTTP authentication. Reasons may involve insufficient filesystem permissions,
    a configuration rule that prevents this request from being processed, or insufficient
    credentials of some sort (e.g., invalid cookies or an unrecognized source IP address).
    The response will usually be shown to the user.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的 URL 存在，但由于除不正确的 HTTP 认证之外的其他原因无法访问。可能的原因包括文件系统权限不足、阻止此请求处理的配置规则，或某些类型的凭证不足（例如，无效的
    cookie 或未识别的源 IP 地址）。通常，响应将显示给用户。
- en: '**404 Not Found**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**404 未找到**'
- en: The requested URL does not exist. The response body is typically shown to the
    user.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的 URL 不存在。通常，响应体将显示给用户。
- en: '500-599: Server-Side Error'
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 500-599：服务器端错误
- en: 'This is a class of error messages returned in response to server-side problems:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一类响应服务器端问题的错误消息：
- en: '**500 Internal Server Error, 503 Service Unavailable, and so on**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**500 内部服务器错误，503 服务不可用，等等**'
- en: The server is experiencing a problem that prevents it from fulfilling the request.
    This may be a transient condition, a result of misconfiguration, or simply the
    effect of requesting an unexpected location. The response is normally shown to
    the user.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器遇到问题，阻止其满足请求。这可能是一种暂时状态，是配置错误的结果，或者仅仅是请求一个意外位置的效果。通常，响应会显示给用户。
- en: Consistency of HTTP Code Signaling
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 状态码信号的一致性
- en: Because there is no immediately observable difference between returning most
    2xx, 4xx, and 5xx codes, these values are not selected with any special zeal.
    In particular, web applications are notorious for returning “200 OK” even when
    an application error has occurred and is communicated on the resulting page. (This
    is one of the many factors that make automated testing of web applications much
    harder than it needs to be.)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回大多数 2xx、4xx 和 5xx 状态码之间没有立即可观察的差异，因此这些值没有用任何特殊的热情来选择。特别是，Web 应用程序因在发生应用程序错误并在结果页面上进行通信时返回“200
    OK”而臭名昭著。（这是使 Web 应用程序的自动化测试比实际需要的更困难的多因素之一。）
- en: On rare occasions, new and not necessarily appropriate HTTP codes are invented
    for specific uses. Some of these are standardized, such as a couple of messages
    introduced in the WebDAV RFC.^([[124](pr03.html#ftn.CHP-3-FT-13)]) Others, such
    as Microsoft’s Microsoft Exchange “449 Retry With” status, are not.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，会为特定用途发明新的、不一定合适的 HTTP 状态码。其中一些是标准化的，例如在 WebDAV RFC 中引入的几条消息.^([[124](pr03.html#ftn.CHP-3-FT-13)])
    其他，如微软的 Microsoft Exchange “449 重试”状态，则不是。
- en: Keepalive Sessions
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久连接
- en: 'Originally, HTTP sessions were meant to happen in one shot: Make one request
    for each TCP connection, rinse, and repeat. The overhead of repeatedly completing
    a three-step TCP handshake (and forking off a new process in the traditional Unix
    server design model) soon proved to be a bottleneck, so HTTP/1.1 standardized
    the idea of keepalive sessions instead.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，HTTP 会话旨在一次性发生：为每个 TCP 连接发送一个请求，冲洗，然后重复。反复完成三次 TCP 握手（以及在传统的 Unix 服务器设计模型中启动一个新进程）的开销很快证明是一个瓶颈，因此
    HTTP/1.1 标准化了持久连接的想法。
- en: The existing protocol already gave the server an understanding of where the
    client request ended (an empty line, optionally followed by *Content-Length* bytes
    of data), but to continue using the existing connection, the client also needed
    to know the same about the returned document; the termination of a connection
    could no longer serve as an indicator. Therefore, keepalive sessions require the
    response to include a *Content-Length* header too, always specifying the amount
    of data to follow. Once this many payload bytes are received, the client knows
    it is okay to send a second request and begin waiting for another response.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的协议已经让服务器理解客户端请求的结束位置（一个空行，可选地后跟 *Content-Length* 字节的数据），但为了继续使用现有的连接，客户端也需要了解返回的文档相同的信息；连接的终止不能再作为指示器。因此，持久连接需要响应包括一个
    *Content-Length* 标头，始终指定后续数据的数量。一旦收到这么多有效载荷字节，客户端就知道可以发送第二个请求并开始等待另一个响应。
- en: 'Although very beneficial from a performance standpoint, the way this mechanism
    is designed exacerbates the impact of HTTP request and response-splitting bugs.
    It is deceptively easy for the client and the server to get out of sync on which
    response belongs to which request. To illustrate, let’s consider a server that
    thinks it is sending a single HTTP response, structured as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从性能角度来看非常有益，但这种机制的设计加剧了HTTP请求和响应拆分错误的影响。客户端和服务器在同步哪个响应属于哪个请求时很容易出现误导。为了说明这一点，让我们考虑一个认为自己在发送单个HTTP响应的服务器，其结构如下：
- en: '[PRE25]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The client, on the other hand, may see two responses and associate the first
    one with its most current request and the second one with the yet-to-be-issued
    query^([[20](#ftn.CHP-3-FN-7)]) (which may even be addressed to a different hostname
    on the same IP):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，客户端可能会看到两个响应，并将第一个响应与其最新的请求关联起来，将第二个响应与尚未发出的查询^([[20](#ftn.CHP-3-FN-7)])（这甚至可能指向同一IP上的不同主机名）关联起来：
- en: '[PRE26]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If this response is seen by a caching HTTP proxy, the incorrect result may also
    be cached globally and returned to other users, which is really bad news. A much
    safer design for keepalive sessions would involve specifying the length of both
    the headers and the payload up front or using a randomly generated and unpredictable
    boundary to delimit every response. Regrettably, the design does neither.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓存HTTP代理看到这个响应，错误的结果也可能被全局缓存并返回给其他用户，这真的是一个坏消息。一个更安全的keepalive会话设计应该包括提前指定头和负载的长度，或者使用随机生成且不可预测的边界来界定每个响应。遗憾的是，该设计并没有做到这一点。
- en: 'Keepalive connections are the default in HTTP/1.1 unless they are explicitly
    turned off (*Connection: close*) and are supported by many HTTP/1.0 servers when
    enabled with a *Connection: keep-alive* header. Both servers and browsers can
    limit the number of concurrent requests serviced per connection and can specify
    the maximum amount of time an idle connection is kept around.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '在HTTP/1.1中，除非明确关闭（*Connection: close*），否则默认使用keepalive连接，并且当启用*Connection:
    keep-alive*头时，许多HTTP/1.0服务器也支持它。服务器和浏览器都可以限制每个连接可以服务的并发请求数量，并可以指定空闲连接保持的最大时间。'
- en: '* * *'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[20](#CHP-3-FN-7)]) In principle, clients could be designed to sink any unsolicited
    server response data before issuing any subsequent requests in a keepalive session,
    limiting the impact of the attack. This proposal is undermined by the practice
    of HTTP pipelining, however; for performance reasons, some clients are designed
    to dump multiple requests at once, without waiting for a complete response in
    between.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#CHP-3-FN-7)]) 从原则上讲，客户端可以被设计成在keepalive会话中发出任何后续请求之前，吸收任何未经请求的服务器响应数据，从而限制攻击的影响。然而，由于HTTP管道化的实践；出于性能原因，一些客户端被设计成一次丢弃多个请求，而不等待接收完整响应。
- en: Chunked Data Transfers
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分块数据传输
- en: The significant limitation of *Content-Length*-based keepalive sessions is the
    need for the server to know in advance the exact size of the returned response.
    This is a pretty simple task when dealing with static files, as the information
    is already available in the filesystem. When serving dynamically generated data,
    the problem is more complicated, as the output must be cached in its entirety
    before it is sent to the client. The challenge becomes insurmountable if the payload
    is very large or is produced gradually (think live video streaming). In these
    cases, precaching to compute payload size is simply out of the question.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 基于*Content-Length*的keepalive会话的一个重大限制是服务器需要提前知道返回响应的确切大小。当处理静态文件时，这是一个相当简单的工作，因为信息已经在文件系统中可用。当提供动态生成数据时，问题变得更加复杂，因为输出必须在发送到客户端之前完整地缓存。如果负载非常大或逐渐生成（例如，实时视频流），挑战变得无法克服。在这些情况下，预先缓存以计算负载大小根本不可行。
- en: 'In response to this challenge, RFC 2616 section 3.6.1 gives servers the ability
    to use *Transfer-Encoding: chunked*, a scheme in which the payload is sent in
    portions as it becomes available. The length of every portion of the document
    is declared up front using a hexadecimal integer occupying a separate line, but
    the total length of the document is indeterminate until a final zero-length chunk
    is seen.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '针对这一挑战，RFC 2616第3.6.1节赋予服务器使用*Transfer-Encoding: chunked*的能力，这是一种在数据可用时将其分部分发送的方案。文档每一部分的长度都通过一个单独的行上的十六进制整数提前声明，但直到看到一个长度为零的最终块，文档的总长度是不确定的。'
- en: 'A sample chunked response may look like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例分块响应可能看起来像这样：
- en: '[PRE27]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are no significant downsides to supporting chunked data transfers, other
    than the possibility of pathologically large chunks causing integer overflows
    in the browser code or needing to resolve mismatches between *Content-Length*
    and chunk length. (The specification gives precedence to chunk length, although
    any attempts to handle this situation gracefully appear to be ill-advised.) All
    the popular browsers deal with these conditions properly, but new implementations
    need to watch their backs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 支持分块数据传输没有显著的缺点，除了可能导致浏览器代码中的整数溢出或需要解决 *Content-Length* 和块长度之间的不匹配的可能性（尽管任何尝试优雅地处理这种情况似乎都是不明智的）。所有流行的浏览器都正确处理这些条件，但新的实现需要小心行事。
- en: Caching Behavior
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存行为
- en: For reasons of performance and bandwidth conservation, HTTP clients and some
    intermediaries are eager to cache HTTP responses for later reuse. This must have
    seemed like a simple task in the early days of the Web, but it is increasingly
    fraught with peril as the Web encompasses ever more sensitive, user-specific information
    and as this information is updated more and more frequently.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能和带宽节约的原因，HTTP 客户端和一些中间代理渴望缓存 HTTP 响应以供以后重用。在 Web 的早期，这似乎是一个简单的任务，但随着 Web
    包含越来越多的敏感、用户特定信息，以及这些信息更新得越来越频繁，这变得越来越充满危险。
- en: RFC 2616 section 13.4 states that GET requests responded to with a range of
    HTTP codes (most notably, “200 OK” and “301 Moved Permanently”) may be implicitly
    cached in the absence of any other server-provided directives. Such a response
    may be stored in the cache indefinitely, and may be reused for any future requests
    involving the same request method and destination URL, even if other parameters
    (such as *Cookie* headers) differ. There is a prohibition against caching requests
    that use HTTP authentication (see [HTTP Authentication](ch03s08.html "HTTP Authentication")
    in [HTTP Authentication](ch03s08.html "HTTP Authentication")), but other authentication
    methods, such as cookies, are not recognized in the spec.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2616 第 13.4 节指出，对于以一系列 HTTP 代码（最显著的是“200 OK”和“301 Moved Permanently”）响应的
    GET 请求，在没有其他服务器提供的指令的情况下，可以隐式缓存。这样的响应可以无限期地存储在缓存中，并且可以用于任何涉及相同请求方法和目标 URL 的未来请求，即使其他参数（如
    *Cookie* 头部）不同。禁止缓存使用 HTTP 认证的请求（参见 [HTTP 认证](ch03s08.html "HTTP Authentication")），但规范中未认可其他认证方法，如
    cookies。
- en: When a response is cached, the implementation may opt to revalidate it before
    reuse, but doing so is not required most of the time. Revalidation is achieved
    by request with a special conditional header, such as *If-Modified-Since* (followed
    by a date recorded on the previously cached response) or *If-None-Match* (followed
    by an opaque *ETag* header value that the server returned with an earlier copy).
    The server may respond with a “304 Not Modified” code or return a newer copy of
    the resource.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应被缓存时，实现方式可以选择在重用之前对其进行重新验证，但大多数情况下并不需要这样做。重新验证是通过带有特殊条件头部的请求来实现的，例如 *If-Modified-Since*（后面跟着之前缓存的响应中记录的日期）或
    *If-None-Match*（后面跟着服务器与较早副本一起返回的不透明 *ETag* 头部值）。服务器可能会以“304 Not Modified”代码响应，或者返回资源的较新副本。
- en: Note
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The *Date/If-Modified-Since* and *ETag/If-None-Match* header pairs, when coupled
    with *Cache-Control: private*, offer a convenient and entirely unintended way
    for websites to store long-lived, unique tokens in the browser.^([[125](pr03.html#ftn.CHP-3-FT-14)])
    The same can also be achieved by depositing a unique token inside a cacheable
    JavaScript file and returning “304 Not Modified” to all future conditional requests
    to the token-generating location. Unlike purpose-built mechanisms such as HTTP
    cookies (discussed in the next section), users have very little control over what
    information is stored in the browser cache, under what circumstances, and for
    how long.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '当 *Date/If-Modified-Since* 和 *ETag/If-None-Match* 头部对与 *Cache-Control: private*
    结合使用时，为网站提供了一个方便且完全意外的存储长期、唯一令牌的方法，在浏览器中。^([[125](pr03.html#ftn.CHP-3-FT-14)])
    同样，也可以通过在可缓存的 JavaScript 文件中存储一个唯一令牌，并对所有未来的针对生成令牌位置的带条件请求返回“304 Not Modified”，来实现这一点。与专门构建的机制，如
    HTTP cookies（在下节中讨论）不同，用户对存储在浏览器缓存中的信息、存储条件以及存储时间几乎没有任何控制权。'
- en: 'Implicit caching is highly problematic, and therefore, servers almost always
    should resort to using explicit HTTP-caching directives. To assist with this,
    HTTP/1.0 provides an *Expires* header that specifies the date by which the cached
    copy should be discarded; if this value is equal to the *Date* header provided
    by the server, the response is noncacheable. Beyond that simple rule, the connection
    between *Expires* and *Date* is unspecified: It is not clear whether *Expires*
    should be compared to the system clock on the caching system (which is problematic
    if the client and server clocks are not in sync) or evaluated based on the *Expires
    - Date* delta (which is more robust, but which may stop working if *Date* is accidentally
    omitted). Firefox and Opera use the latter interpretation, while other browsers
    prefer the former one. In most browsers, an invalid *Expires* value also inhibits
    caching, but depending on it is a risky bet.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式缓存问题很大，因此，服务器几乎总是应该求助于使用显式的 HTTP 缓存指令。为此，HTTP/1.0 提供了一个 *Expires* 头部，指定缓存副本应丢弃的日期；如果此值等于服务器提供的
    *Date* 头部，则响应不可缓存。除了这个简单的规则之外，*Expires* 和 *Date* 之间的关系是不明确的：不清楚 *Expires* 是否应该与缓存系统的系统时钟进行比较（如果客户端和服务器时钟不同步，则可能存在问题）或者基于
    *Expires - Date* 差值进行评估（这更稳健，但如果 *Date* 误被省略，则可能停止工作）。Firefox 和 Opera 使用后一种解释，而其他浏览器则更喜欢前者。在大多数浏览器中，无效的
    *Expires* 值也会阻止缓存，但依赖它是风险很大的。
- en: 'HTTP/1.0 clients can also include a *Pragma: no-cache* request header, which
    may be interpreted by the proxy as an instruction to obtain a new copy of the
    requested resource, instead of returning an existing one. Some HTTP/1.0 proxies
    also recognize a nonstandard *Pragma: no-cache* response header as an instruction
    not to make a copy of the document.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP/1.0 客户端还可以包含一个 *Pragma: no-cache* 请求头部，这可以被代理解释为获取请求资源的新的副本，而不是返回现有的副本。一些
    HTTP/1.0 代理也识别一个非标准的 *Pragma: no-cache* 响应头部作为不制作文档副本的指令。'
- en: In contrast, HTTP/1.1 embraces a far more substantial approach to caching directives,
    introducing a new *Cache-Control* header. The header takes values such as *public*
    (the document is cacheable publicly), *private* (proxies are not permitted to
    cache), *no-cache* (which is a bit confusing—the response may be cached but should
    not be reused for future requests),^([[21](#ftn.CHP-3-FN-8)]) and *no-store* (absolutely
    no caching at all). Public and private caching directives may be accompanied with
    a qualifier such as *max-age*, specifying the maximum time an old copy should
    be kept, or *must-revalidate*, requesting a conditional request to be made before
    content reuse.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，HTTP/1.1 对缓存指令采用了更为实质性的方法，引入了一个新的 *Cache-Control* 头部。该头部包含诸如 *public*（文档可以公开缓存）、*private*（代理不允许缓存）、*no-cache*（有点令人困惑——响应可以被缓存但不应用于未来的请求）^([[21](#ftn.CHP-3-FN-8)])
    和 *no-store*（绝对不缓存）等值。公共和私有缓存指令可以伴随一个限定符，例如 *max-age*，指定旧副本应保留的最大时间，或者 *must-revalidate*，请求在内容重用之前进行条件请求。
- en: 'Unfortunately, it is typically necessary for servers to return both HTTP/1.0
    and HTTP/1.1 caching directives, because certain types of legacy commercial proxies
    do not understand *Cache-Control* correctly. In order to reliably prevent caching
    over HTTP, it may be necessary to use the following set of response headers:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，服务器通常需要返回 HTTP/1.0 和 HTTP/1.1 缓存指令，因为某些类型的旧版商业代理无法正确理解 *Cache-Control*。为了可靠地防止通过
    HTTP 缓存，可能需要使用以下响应头集合：
- en: '[PRE28]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When these caching directives disagree, the behavior is difficult to predict:
    Some browsers will favor HTTP/1.1 directives and give precedence to *no-cache*,
    even if it is mistakenly followed by *public*; others don’t.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些缓存指令不一致时，行为难以预测：一些浏览器将优先考虑 HTTP/1.1 指令，并优先考虑 *no-cache*，即使它错误地跟在 *public*
    之后；而其他浏览器则不是这样。
- en: 'Another risk of HTTP caching is associated with unsafe networks, such as public
    Wi-Fi networks, which allow an attacker to intercept requests to certain URLs
    and return modified, long-cacheable contents on requests to the victim. If such
    a poisoned browser cache is then reused on a trusted network, the injected content
    will unexpectedly resurface. Perversely, the victim does not even have to visit
    the targeted application: A reference to a carefully chosen sensitive domain can
    be injected by the attacker into some other context. There are no good solutions
    to this problem yet; purging your browser cache after visiting Starbucks may be
    a very good idea.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 缓存的一个风险与不安全的网络有关，例如公共 Wi-Fi 网络，这些网络允许攻击者拦截对某些 URL 的请求，并在对受害者的请求中返回修改后的、长时间可缓存的
    内容。如果这种受污染的浏览器缓存随后在受信任的网络中使用，注入的内容将意外地再次出现。奇怪的是，受害者甚至不必访问目标应用程序：攻击者可以将对精心选择的敏感域的引用注入到其他上下文中。目前还没有好的解决方案来解决这个问题；在访问星巴克后清除浏览器缓存可能是一个非常不错的选择。
- en: '* * *'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[21](#CHP-3-FN-8)]) The RFC is a bit hazy in this regard, but it appears
    that the intent is to permit the cached document to be used for purposes such
    as operating the “back” and “forward” navigation buttons in a browser but not
    when a proper page load is requested. Firefox follows this approach, while all
    other browsers consider *no-cache* and *no-store* to be roughly equivalent.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[21](#CHP-3-FN-8)]) RFC 在这方面有些模糊，但看起来意图是允许缓存的文档用于诸如在浏览器中操作“后退”和“前进”导航按钮等目的，但不适用于请求正确页面加载的情况。Firefox
    采用这种方法，而所有其他浏览器认为 *no-cache* 和 *no-store* 大致相同。
- en: HTTP Cookie Semantics
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP Cookie 语义
- en: HTTP cookies are not a part of RFC 2616, but they are one of the more important
    protocol extensions used on the Web. The cookie mechanism allows servers to store
    short, opaque *name=value* pairs in the browser by sending a *Set-Cookie* response
    header and to receive them back on future requests via the client-supplied *Cookie*
    parameter. Cookies are by far the most popular way to maintain sessions and authenticate
    user requests; they are one of the four canonical forms of *ambient authority*^([[22](#ftn.CHP-3-FN-9)])
    on the Web (the other forms being built-in HTTP authentication, IP checking, and
    client certificates).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP cookies 并不是 RFC 2616 的一部分，但它们是 Web 上使用的重要协议扩展之一。cookie 机制允许服务器通过发送 *Set-Cookie*
    响应头来在浏览器中存储短而透明的 *name=value* 对，并在未来的请求中通过客户端提供的 *Cookie* 参数接收它们。cookie 是迄今为止维护会话和验证用户请求最受欢迎的方式；它们是
    Web 上四种规范形式的 *环境权限*^([[22](#ftn.CHP-3-FN-9)]) 之一（其他形式包括内置的 HTTP 认证、IP 检查和客户端证书）。
- en: Originally implemented in Netscape by Lou Montulli around 1994, and described
    in a brief four-page draft document,^([[126](pr03.html#ftn.CHP-3-FT-15)]) the
    mechanism has not been outlined in a proper standard in the last 17 years. In
    1997, RFC 2109^([[127](pr03.html#ftn.CHP-3-FT-16)]) attempted to document the
    status quo, but somewhat inexplicably, it also proposed a number of sweeping changes
    that, to this day, make this specification substantially incompatible with the
    actual behavior of any modern browser. Another ambitious effort—*Cookie2*—made
    an appearance in RFC 2965,^([[128](pr03.html#ftn.CHP-3-FT-17)]) but a decade later,
    it still has virtually no browser-level support, a situation that is unlikely
    to change. A new effort to write a reasonably accurate cookie specification—RFC
    6265^([[129](pr03.html#ftn.CHP-3-FT-18)])—was wrapped up shortly before the publication
    of this book, finally ending this specification-related misery.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制最初由 Lou Montulli 在 1994 年左右在 Netscape 实现，并在一份简短的四页草案文档中描述，^([[126](pr03.html#ftn.CHP-3-FT-15)])
    在过去 17 年中，该机制并未在适当的标准中进行概述。1997 年，RFC 2109^([[127](pr03.html#ftn.CHP-3-FT-16)])
    试图记录现状，但有些令人费解地，它还提出了一系列广泛的变更，这些变更至今仍使该规范与任何现代浏览器的实际行为存在实质性不兼容。另一个雄心勃勃的努力——*Cookie2*——出现在
    RFC 2965^([[128](pr03.html#ftn.CHP-3-FT-17)]) 中，但十年后，它几乎在浏览器级别上没有支持，这种情况不太可能改变。在本书出版前不久，一项新的努力——RFC
    6265^([[129](pr03.html#ftn.CHP-3-FT-18)])——完成了对合理准确的 cookie 规范的编写，最终结束了这一规范相关的痛苦。
- en: Because of the prolonged absence of any real standards, the actual implementations
    evolved in very interesting and sometimes incompatible ways. In practice, new
    cookies can be set using *Set-Cookie* headers followed by a single *name=value*
    pair and a number of optional semicolon-delimited parameters defining the scope
    and lifetime of the cookie.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 由于长期缺乏任何真正的标准，实际的实现以非常有趣且有时不兼容的方式发展。在实践中，可以使用 *Set-Cookie* 头部后跟一个单个的 *name=value*
    对和一系列可选的分号分隔的参数来设置新的 cookie，这些参数定义了 cookie 的作用域和生存期。
- en: '**Expires**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**过期时间**'
- en: Specifies the expiration date for a cookie in a format similar to that used
    for *Date* or *Expires* HTTP headers. If a cookie is served without an explicit
    expiration date, it is typically kept in memory for the duration of a browser
    session (which, especially on portable computers with suspend functionality, can
    easily span several weeks). Definite-expiry cookies may be routinely saved to
    disk and persist across sessions, unless a user’s privacy settings explicitly
    prevent this possibility.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似于 *Date* 或 *Expires* HTTP 报头使用的格式指定 cookie 的过期日期。如果 cookie 没有提供明确的过期日期，它通常会被保存在内存中，直到浏览器会话结束（特别是在具有挂起功能的便携式计算机上，这可以轻松跨越几周）。具有明确过期日期的
    cookie 可能会被常规地保存到磁盘上，并在会话之间持续存在，除非用户的隐私设置明确阻止这种可能性。
- en: '**Max-age**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**Max-age**'
- en: This alternative, RFC-suggested expiration mechanism is not supported in Internet
    Explorer and therefore is not used in practice.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代的、RFC 建议的过期机制在 Internet Explorer 中不受支持，因此在实践中没有使用。
- en: '**Domain**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**域名**'
- en: This parameter allows the cookie to be scoped to a domain broader than the hostname
    that returned the *Set-Cookie* header. The exact rules and security consequences
    of this scoping mechanism are explored in [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic").
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数允许 cookie 范围限定到比返回 *Set-Cookie* 报头的 hostname 更宽泛的域名。此范围机制的精确规则和安全后果将在 [第
    9 章](ch09.html "第 9 章。内容隔离逻辑") 中探讨。
- en: Note
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Contrary to what is implied in RFC 2109, it is not possible to scope cookies
    to a specific hostname when using this parameter. For example, *domain=example.com*
    will always match [www.example.com](http://www.example.com) as well. Omitting
    *domain* is the only way to create host-scoped cookies, but even this approach
    is not working as expected in Internet Explorer.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 与 RFC 2109 中暗示的不同，使用此参数时无法将 cookie 范围限定到特定的主机名。例如，*domain=example.com* 总是会匹配
    [www.example.com](http://www.example.com)。省略 *domain* 是创建主机范围 cookie 的唯一方法，但即使这种方法在
    Internet Explorer 中也没有按预期工作。
- en: '**Path**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径**'
- en: Allows the cookie to be scoped to a particular request path prefix. This is
    not a viable security mechanism for the reasons explained in [Chapter 9](ch09.html
    "Chapter 9. Content Isolation Logic"), but it may be used for convenience, to
    prevent identically named cookies used in various parts of the application from
    colliding with each other.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 cookie 范围限定到特定的请求路径前缀。这不是一个可行的安全机制，原因已在 [第 9 章](ch09.html "第 9 章。内容隔离逻辑")
    中解释，但它可能用于方便起见，防止应用不同部分中使用的同名 cookie 发生冲突。
- en: '**Secure attribute**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**Secure 属性**'
- en: Prevents the resulting cookie from being sent over nonencrypted connections.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 防止生成的 cookie 通过非加密连接发送。
- en: '**HttpOnly attribute**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**HttpOnly 属性**'
- en: Removes the ability to read the cookie through the *document.cookie* API in
    JavaScript. This is a Microsoft extension, although it is now supported by all
    mainstream browsers.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 移除了通过 JavaScript 中的 *document.cookie* API 读取 cookie 的能力。这是一个微软的扩展，尽管现在所有主流浏览器都支持它。
- en: When making future requests to a domain for which valid cookies are found in
    the cookie jar, browsers will combine all applicable *name=value* pairs into a
    single, semicolon-delimited *Cookie* header, without any additional metadata,
    and return them to the server. If too many cookies need to be sent on a particular
    request, server-enforced header size limits will be exceeded, and the request
    may fail; there is no method for recovering from this condition, other than manually
    purging the cookie jar.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当向在 cookie jar 中找到有效 cookie 的域名发出未来请求时，浏览器会将所有适用的 *name=value* 对组合成一个单独的分号分隔的
    *Cookie* 报头，不包含任何其他元数据，并将其返回给服务器。如果某个请求需要发送过多的 cookie，服务器强制性的报头大小限制将被超过，请求可能会失败；没有从这种状态恢复的方法，除了手动清空
    cookie jar。
- en: Curiously, there is no explicit method for HTTP servers to delete unneeded cookies.
    However, every cookie is uniquely identified by a name-domain-path tuple (the
    *secure* and *httponly* attributes are ignored), which permits an old cookie of
    a known scope to be simply overwritten. Furthermore, if the overwriting cookie
    has an *expires* date in the past, it will be immediately dropped, effectively
    giving a contrived way to purge the data.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，没有明确的方法让 HTTP 服务器删除不必要的 cookie。然而，每个 cookie 都由一个独特的名称-域名-路径三元组（忽略 *secure*
    和 *httponly* 属性）唯一标识，这允许简单地覆盖已知范围的旧 cookie。此外，如果覆盖的 cookie 有一个过去的 *expires* 日期，它将立即被丢弃，这实际上提供了一种人为清除数据的方法。
- en: Although RFC 2109 requires multiple comma-separated cookies to be accepted within
    a single *Set-Cookie* header, this approach is dangerous and is no longer supported
    by any browser. Firefox allows multiple cookies to be set in a single step via
    the *document.cookie* JavaScript API, but inexplicably, it requires newlines as
    delimiters instead. No browser uses commas as *Cookie* delimiters, and recognizing
    them on the server side should be considered unsafe.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RFC 2109要求在单个 *Set-Cookie* 头中接受多个逗号分隔的cookie，但这种做法是危险的，并且不再被任何浏览器支持。Firefox允许通过
    *document.cookie* JavaScript API在单个步骤中设置多个cookie，但不可思议的是，它要求使用换行符作为分隔符。没有浏览器使用逗号作为
    *Cookie* 分隔符，在服务器端识别它们应被视为不安全的。
- en: Another important difference between the spec and reality is that cookie values
    are supposed to use the *quoted-string* format outlined in HTTP specs (see [Semicolon-Delimited
    Header Values](ch03.html#semicolon-delimited_header_values "Semicolon-Delimited
    Header Values") in [Semicolon-Delimited Header Values](ch03.html#semicolon-delimited_header_values
    "Semicolon-Delimited Header Values")), but only Firefox and Opera recognize this
    syntax in practice. Reliance on *quoted-string* values is therefore unsafe, and
    so is allowing stray quote characters in attacker-controlled cookies.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 规范与现实之间另一个重要的区别是，cookie值应使用HTTP规范中概述的 *quoted-string* 格式（参见[Semicolon-Delimited
    Header Values](ch03.html#semicolon-delimited_header_values "Semicolon-Delimited
    Header Values")），但只有Firefox和Opera在实际中识别这种语法。因此，依赖 *quoted-string* 值是不安全的，允许攻击者控制的cookie中存在散乱的引号字符也是如此。
- en: Cookies are not guaranteed to be particularly reliable. User agents enforce
    modest settings on the number and size of cookies permitted per domain and, as
    a misguided privacy feature, may also restrict their lifetime. Because equally
    reliable user tracking may be achieved by other means, such as the *ETag/If-None-Match*
    behavior outlined in the previous section, the efforts to restrict cookie-based
    tracking probably do more harm than good.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies并不保证特别可靠。用户代理对每个域允许的cookie数量和大小执行适度设置，并且作为一种错误的隐私功能，它们还可能限制它们的生存期。由于可以通过其他方式，如前一部分中概述的
    *ETag/If-None-Match* 行为，以同样可靠的方式实现用户跟踪，因此限制基于cookie的跟踪的努力可能弊大于利。
- en: '* * *'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[22](#CHP-3-FN-9)]) *Ambient authority* is a form of access control based
    on a global and persistent property of the requesting entity, rather than any
    explicit form of authorization that would be valid only for a specific action.
    A user-identifying cookie included indiscriminately on every outgoing request
    to a remote site, without any consideration for why this request is being made,
    falls into that category.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[22](#CHP-3-FN-9)]) *环境权限* 是一种基于请求实体全局和持久属性的一种访问控制形式，而不是任何仅对特定操作有效的明确授权形式。在向远程站点发出的每个请求中不加区分地包含用于识别用户的cookie，而不考虑为什么发起这个请求，就属于这一类别。
- en: HTTP Authentication
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP认证
- en: HTTP authentication, as specified in RFC 2617,^([[130](pr03.html#ftn.CHP-3-FT-19)])
    is the original credential-handling mechanism envisioned for web applications,
    one that is now almost completely extinct. The reasons for this outcome might
    have been the inflexibility of the associated browser-level UIs, the difficulty
    of accommodating more sophisticated non-password-based authentication schemes,
    or perhaps the inability to exercise control over how long credentials are cached
    and what other domains they are shared with.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 2617指定的HTTP认证，是最初为Web应用程序设想的一种凭证处理机制，现在几乎已经完全灭绝。这种结果的原因可能包括与浏览器级别UI相关的僵化性、难以适应更复杂的非基于密码的认证方案，或者可能是因为无法控制凭据的缓存时间以及它们共享的其他域。
- en: In any case, the basic scheme is fairly simple. It begins with the browser making
    an unauthenticated request, to which the server responds with a “401 Unauthorized”
    code.^([[23](#ftn.CHP-3-FN-10)]) The server must also include a *WWW-Authenticate*
    HTTP header, specifying the requested authentication method, the *realm* string
    (an arbitrary identifier to which the entered credentials should be bound), and
    other method-specific parameters, if applicable.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，基本方案相当简单。它始于浏览器发起一个未经身份验证的请求，服务器随后响应一个“401 未授权”代码.^([[23](#ftn.CHP-3-FN-10)])
    服务器还必须包含一个 *WWW-Authenticate* HTTP头，指定请求的认证方法、*realm* 字符串（一个任意标识符，输入的凭据应与其绑定），以及适用的方法特定参数。
- en: The client is expected to obtain the credentials in one way or the other, encode
    them in the *Authorization* header, and retry the original request with this header
    included. According to the specification, for performance reasons, the same *Authorization*
    header may also be included on subsequent requests to the same server path prefix
    without the need for a second *WWW-Authenticate* challenge. It is also permissible
    to reuse the same credentials in response to any *WWW-Authenticate* challenges
    elsewhere on the server, if the *realm* string and the authentication method match.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应通过某种方式获取凭据，将它们编码在*授权*头中，并包含此头重试原始请求。根据规范，出于性能原因，相同的*授权*头也可以包含在随后的对同一服务器路径前缀的请求中，无需第二次*WWW-Authenticate*挑战。如果*realm*字符串和认证方法匹配，也可以在服务器上的其他任何*WWW-Authenticate*挑战中重用相同的凭据。
- en: 'In practice, this advice is not followed very closely: Other than Safari and
    Chrome, most browsers ignore the *realm* string or take a relaxed approach to
    path matching. On the flip side, all browsers scope cached credentials not only
    to the destination server but also to a specific protocol and port, a practice
    that offers some security benefits.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这些建议并没有被严格遵守：除了Safari和Chrome之外，大多数浏览器忽略了*realm*字符串，或者对路径匹配采取了宽松的态度。另一方面，所有浏览器都将缓存的凭据范围不仅限于目标服务器，还包括特定的协议和端口，这种做法提供了一些安全优势。
- en: 'The two credential-passing methods specified in the original RFC are known
    as *basic* and *digest*. The first one essentially sends the passwords in plaintext,
    encoded as *base64*. The other computes a one-time cryptographic hash that protects
    the password from being viewed in plaintext and prevents the *Authorization* header
    from being replayed later. Unfortunately, modern browsers support both methods
    and do not distinguish between them in any clear way. As a result, attackers can
    simply replace the word *digest* with *basic* in the initial request to obtain
    a clean, plaintext password as soon as the user completes the authentication dialog.
    Surprisingly, section 4.8 of the RFC predicted this risk and offered some helpful
    yet ultimately ignored advice:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 原始RFC中指定的两种凭据传递方法被称为*基本*和*摘要*。第一种方法本质上是以*base64*编码的明文发送密码。另一种方法计算出一个一次性加密散列，保护密码不被以明文形式查看，并防止*授权*头在之后被重放。不幸的是，现代浏览器支持这两种方法，并且没有以任何明显的方式区分它们。因此，攻击者可以简单地将在初始请求中将单词*摘要*替换为*基本*，一旦用户完成身份验证对话框，就可以立即获得一个干净的明文密码。令人惊讶的是，RFC的第4.8节预测了这种风险，并提供了一些有用的但最终被忽视的建议：
- en: User agents should consider measures such as presenting a visual indication
    at the time of the credentials request of what authentication scheme is to be
    used, or remembering the strongest authentication scheme ever requested by a server
    and produce a warning message before using a weaker one. It might also be a good
    idea for the user agent to be configured to demand Digest authentication in general,
    or from specific sites.
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户代理应考虑采取一些措施，例如在请求凭据时提供视觉指示，说明将要使用的认证方案，或者记住服务器请求过的最强认证方案，并在使用较弱的方案之前发出警告信息。也许用户代理还应配置为在一般情况下或从特定站点要求摘要认证。
- en: In addition to these two RFC-specified authentication schemes, some browsers
    also support less-common methods, such as Microsoft’s *NTLM* and *Negotiate*,
    used for seamless authentication with Windows domain credentials.^([[131](pr03.html#ftn.CHP-3-FT-20)])
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两种RFC指定的认证方案之外，一些浏览器还支持不太常见的方法，例如微软的*NTLM*和*协商*，这些方法用于与Windows域凭据无缝认证。[^[[131](pr03.html#ftn.CHP-3-FT-20])]
- en: Although HTTP authentication is seldom encountered on the Internet, it still
    casts a long shadow over certain types of web applications. For example, when
    an external, attacker-supplied image is included in a thread on a message board,
    and the server hosting that image suddenly decides to return “401 Unauthorized”
    on some requests, users viewing the thread will be presented out of the blue with
    a somewhat cryptic password prompt. After double-checking the address bar, many
    will probably confuse the prompt for a request to enter their forum credentials,
    and these will be immediately relayed to the attacker’s image-hosting server.
    Oops.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP认证在互联网上很少遇到，但它仍然对某些类型的Web应用投下了长长的阴影。例如，当外部攻击者提供的图像被包含在论坛的一个帖子中，而托管该图像的服务器突然决定在某些请求上返回“401未授权”时，查看该帖子的用户会突然看到一个有些神秘的密码提示。在仔细检查地址栏后，许多人可能会将提示误认为是输入论坛凭证的请求，并将这些凭证立即转发给攻击者的图像托管服务器。哎呀。
- en: '* * *'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[23](#CHP-3-FN-10)]) The terms *authentication* and *authorization* appear
    to be used interchangeably in this RFC, but they have a distinctive meaning elsewhere
    in information security. *Authentication* is commonly used to refer to the process
    of proving your identity, whereas *authorization* is the process of determining
    whether your previously established credentials permit you to carry out a specific
    privileged action.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-3-FN-10)]) 在这个RFC中，似乎将“认证”和“授权”这两个术语互换使用，但在信息安全的其他地方，它们有着独特的含义。“认证”通常用来指证明你的身份的过程，而“授权”则是确定你之前建立的凭证是否允许你执行特定的特权操作。
- en: Protocol-Level Encryption and Client Certificates
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议级加密和客户端证书
- en: 'As should now be evident, all information in HTTP sessions is exchanged in
    plaintext over the network. In the 1990s, this would not have been a big deal:
    Sure, plaintext exposed your browsing choices to nosy ISPs, and perhaps to another
    naughty user on your office network or an overzealous government agency, but that
    seemed no worse than the behavior of SMTP, DNS, or any other commonly used application
    protocol. Alas, the growing popularity of the Web as a commerce platform has aggravated
    the risk, and substantial network security regression caused by the emergence
    of inherently unsafe public wireless networks put another nail in that coffin.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如现在所应显而易见，HTTP会话中的所有信息都在网络上以明文形式交换。在20世纪90年代，这不会成为什么大问题：当然，明文会暴露你的浏览选择给好奇的ISP，也许还会给办公室网络中的另一个淘气的用户或一个过于热情的政府机构，但这似乎并不比SMTP、DNS或其他常用应用协议的行为更糟。然而，随着Web作为商业平台的日益流行，这种风险加剧了，而公共无线网络固有的不安全性导致的网络安全大幅倒退，又给这个棺材钉上了另一颗钉子。
- en: After several less successful hacks, a straightforward solution to this problem
    was proposed in RFC 2818:^([[132](pr03.html#ftn.CHP-3-FT-21)]) Why not encapsulate
    normal HTTP requests within an existing, multipurpose Transport Layer Security
    (TLS, aka SSL) mechanism developed several years earlier? This transport method
    leverages public key cryptography^([[24](#ftn.CHP-3-FN-11)]) to establish a confidential,
    authenticated communication channel between the two endpoints, without requiring
    any HTTP-level tweaks.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在几次不太成功的黑客攻击之后，RFC 2818提出了一个直接解决这个问题的方法：为什么不将正常的HTTP请求封装在几年前开发的现有、多用途的传输层安全性（TLS，也称为SSL）机制中？这种传输方法利用公钥密码学^([[24](#ftn.CHP-3-FN-11)])在两个端点之间建立一个保密、认证的通信通道，而不需要任何HTTP级别的调整。
- en: In order to allow web servers to prove their identity, every HTTPS-enabled web
    browser ships with a hefty set of public keys belonging to a variety of *certificate
    authorities*. Certificate authorities are organizations that are trusted by browser
    vendors to cryptographically attest that a particular public key belongs to a
    particular site, hopefully after validating the identity of the person who requests
    such attestation and after verifying his claim to the domain in question.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让网络服务器证明其身份，每个启用了HTTPS的网页浏览器都附带了一组庞大的公钥，这些公钥属于各种**证书颁发机构**。证书颁发机构是那些被浏览器供应商信任的组织，它们通过密码学方式证明特定的公钥属于特定的网站，希望是在验证请求这种证明的人的身份以及验证他对相关域的主张之后。
- en: The set of trusted organizations is diverse, arbitrary, and not particularly
    well documented, which often prompts valid criticisms. But in the end, the system
    usually does the job reasonably well. Only a handful of bloopers have been documented
    so far (including a recent high-profile compromise of a company named Comodo^([[133](pr03.html#ftn.CHP-3-FT-22)])),
    and no cases of widespread abuse of CA privileges are on the record.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 受信任的组织集合是多样化的、任意的，并且没有特别好的文档记录，这往往引发有效的批评。但最终，系统通常能合理地完成工作。到目前为止，只有少数几个错误被记录下来（包括最近一家名为Comodo的公司的高调妥协[[133](pr03.html#ftn.CHP-3-FT-22)]），并且没有记录广泛滥用CA特权的案例。
- en: As to the actual implementation, when establishing a new HTTPS connection, the
    browser receives a signed public key from the server, verifies the signature (which
    can’t be forged without having access to the CA’s private key), checks that the
    signed *cn* (common name) or *subjectAltName* fields in the certificate indicate
    that this certificate is issued for the server the browser wants to talk to, and
    confirms that the key is not listed on a public revocation list (for example,
    due to being compromised or obtained fraudulently). If everything checks out,
    the browser can proceed by encrypting messages to the server with that public
    key and be certain that only that specific party will be able to decrypt them.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实际实现，当建立新的HTTPS连接时，浏览器从服务器接收一个签名后的公钥，验证签名（如果没有访问CA的私钥，签名是无法伪造的），检查证书中签名的*cn*（通用名称）或*subjectAltName*字段表明此证书是为浏览器想要与之通信的服务器签发的，并确认该密钥不在公共撤销列表上（例如，由于被破坏或欺诈性地获得）。如果一切检查无误，浏览器就可以通过使用该公钥加密消息到服务器，并确信只有那个特定的当事人能够解密它们。
- en: 'Normally, the client remains anonymous: It generates a temporary encryption
    key, but that process does not prove the client’s identity. Such a proof can be
    arranged, though. Client certificates are embraced internally by certain organizations
    and are adopted on a national level in several countries around the world (e.g.,
    for e-government services). Since the usual purpose of a client certificate is
    to provide some information about the real-world identity of the user, browsers
    usually prompt before sending them to newly encountered sites, for privacy reasons;
    beyond that, the certificate may act as yet another form of ambient authority.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，客户端保持匿名：它生成一个临时的加密密钥，但这个过程并不能证明客户端的身份。尽管如此，这样的证明是可以安排的。某些组织内部接受客户端证书，并在世界上的几个国家达到国家层面（例如，用于电子政府服务）。由于客户端证书的通常目的是提供有关用户现实世界身份的一些信息，因此出于隐私原因，浏览器通常在将它们发送到新遇到的网站之前会提示用户；除此之外，证书还可以作为另一种环境权威的形式。
- en: It is worth noting that although HTTPS as such is a sound scheme that resists
    both passive and active attackers, it does very little to hide the evidence of
    access to a priori public information. It does not mask the rough HTTP request
    and response sizes, traffic directions, and timing patterns in a typical browsing
    session, thus making it possible for unsophisticated, passive attackers to figure
    out, for example, which embarrassing page on Wikipedia is being viewed by the
    victim over an encrypted channel. In fact, in one extreme case, Microsoft researchers
    illustrated the use of such packet profiling to reconstruct user keystrokes in
    an online application.^([[134](pr03.html#ftn.CHP-3-FT-23)])
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管HTTPS本身是一个能够抵御被动和主动攻击者的健全方案，但它对隐藏访问先前公开信息的证据几乎没有什么帮助。它不会掩盖典型浏览会话中的粗略HTTP请求和响应大小、流量方向和时间模式，这使得未受训练的、被动的攻击者能够推断出，例如，受害者通过加密通道正在查看维基百科上的哪个令人尴尬的页面。实际上，在一种极端情况下，微软研究人员展示了使用这种数据包分析来重建在线应用程序中的用户按键的方法[[134](pr03.html#ftn.CHP-3-FT-23)]）。
- en: Extended Validation Certificates
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展验证证书
- en: In the early days of HTTPS, many public certificate authorities relied on fairly
    pedantic and cumbersome user identity and domain ownership checks before they
    would sign a certificate. Unfortunately, in pursuit of convenience and in the
    interest of lowering prices, some now require little more than a valid credit
    card and the ability to put a file on the destination server in order to complete
    the verification process. This approach renders most of the certificate fields
    other than *cn* and *subjectAltName* untrustworthy.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTPS的早期阶段，许多公共证书机构在签署证书之前，会进行相当繁琐和复杂的用户身份和域名所有权检查。不幸的是，为了追求便利和降低价格，一些现在只需要一张有效的信用卡和将文件上传到目标服务器的能力，就可以完成验证过程。这种方法使得除了*cn*和*subjectAltName*之外的大多数证书字段都不可信。
- en: 'To address this problem, a new type of certificate, tagged using a special
    flag, is being marketed today at a significantly higher price: *Extended Validation
    SSL (EV SSL)*. These certificates are expected not only to prove domain ownership
    but also more reliably attest to the identity of the requesting party, following
    a manual verification process. EV SSL is recognized by all modern browsers by
    making portion of the address bar blue or green. Although having this tier of
    certificates is valuable, the idea of coupling a higher-priced certificate with
    an indicator that vaguely implies a “higher level of security” is often criticized
    as a cleverly disguised money-making scheme.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，一种新的证书类型正在以显著更高的价格进行推广，这种证书使用特殊的标志进行标记：*扩展验证SSL (EV SSL)*。这些证书不仅预期可以证明域名所有权，而且通过手动验证过程，还能更可靠地证明请求方的身份。EV
    SSL通过使地址栏的一部分变为蓝色或绿色而被所有现代浏览器所识别。尽管拥有这一级别的证书很有价值，但将更高价格的证书与一个含糊暗示“更高安全级别”的指示器相结合的想法，通常被批评为一种巧妙伪装的赚钱手段。
- en: Error-Handling Rules
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理规则
- en: In an ideal world, HTTPS connections that involve a suspicious certificate error,
    such as a grossly mismatched hostname or an unrecognized certification authority,
    should simply result in a failure to establish the connection. Less-suspicious
    errors, such as a recently expired certificate or a hostname mismatch, perhaps
    could be accompanied by just a gentle warning.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，涉及可疑证书错误（如严重不匹配的主机名或未知的证书机构）的HTTPS连接应该简单地导致连接失败。不太可疑的错误，如最近到期的证书或主机名不匹配，可能只需伴随一个温和的警告。
- en: 'Unfortunately, most browsers have indiscriminately delegated the responsibility
    for understanding the problem to the user, trying hard (and ultimately failing)
    to explain cryptography in layman’s terms and requiring the user to make a binary
    decision: Do you actually want to see this page or not? ([Figure 3-1](ch03s09.html#an_example_certificate_warning_dialog_in
    "Figure 3-1. An example certificate warning dialog in the still-popular Internet
    Explorer 6") shows one such prompt.)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数浏览器不加区分地将理解问题的责任委托给了用户，努力（但最终失败）用通俗易懂的语言解释密码学，并要求用户做出二选一的决定：你真的想看到这个页面吗？([图3-1](ch03s09.html#an_example_certificate_warning_dialog_in
    "图3-1. 在仍然流行的Internet Explorer 6中的示例证书警告对话框")显示了这样一个提示。)
- en: '![An example certificate warning dialog in the still-popular Internet Explorer
    6](httpatomoreillycomsourcenostarchimages949997.png.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![在仍然流行的Internet Explorer 6中的示例证书警告对话框](httpatomoreillycomsourcenostarchimages949997.png.jpg)'
- en: Figure 3-1. An example certificate warning dialog in the still-popular Internet
    Explorer 6
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1. 在仍然流行的Internet Explorer 6中的示例证书警告对话框
- en: 'The language and appearance of SSL warnings has evolved through the years toward
    increasingly dumbed-down (but still problematic) explanations of the problem and
    more complicated actions required to bypass the warning. This trend may be misguided:
    Studies show that over 50 percent of even the most frightening and disruptive
    warnings are clicked through.^([[135](pr03.html#ftn.CHP-3-FT-24)]) It is easy
    to blame the users, but ultimately, we may be asking them the wrong questions
    and offering exactly the wrong choices. Simply, if it is believed that clicking
    through the warning is advantageous in some cases, offering to open the page in
    a clearly labeled “sandbox” mode, where the harm is limited, would be a more sensible
    solution. And if there is no such belief, any override capabilities should be
    eliminated entirely (a goal sought by *Strict Transport Security*, an experimental
    mechanism that will be discussed in [Chapter 16](ch16.html "Chapter 16. New and
    Upcoming Security Features")).'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: SSL警告的语言和外观在多年中逐渐演变为越来越简单（但仍然有问题）的问题解释和更复杂的绕过警告所需采取的行动。这种趋势可能是错误的：研究表明，即使是令人恐惧和破坏性的警告，也有超过50%的人会点击通过。[^[[135](pr03.html#ftn.CHP-3-FT-24)]]
    虽然容易责怪用户，但最终，我们可能是在问他们错误的问题，并提供了完全错误的选择。简单来说，如果认为在某些情况下点击通过警告是有利的，提供以清晰标记的“沙盒”模式打开页面的选项，其中危害有限，将是一个更合理的解决方案。如果没有这样的信念，任何覆盖能力都应该完全消除（这是*严格传输安全*的目标，一个将在第16章中讨论的实验性机制）。
- en: Security Engineering Cheat Sheet
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Handling User-Controlled Filenames in Content-Disposition Headers
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理内容处置头中的用户控制文件名时
- en: '**If you do not need non-Latin characters:** Strip or substitute any characters
    except for alphanumerics, “.”, “-”, and “_”. To protect your users against potentially
    harmful or deceptive filenames, you may also want to confirm that at least the
    first character is alphanumeric and substitute all but the rightmost period with
    something else (e.g., an underscore).'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您不需要非拉丁字符：** 删除或替换除字母数字、“.”、“-”和“_”之外的所有字符。为了保护您的用户免受可能有害或误导性的文件名的影响，您还可能希望确认至少第一个字符是字母数字的，并将除了最右侧的点之外的所有字符替换为其他内容（例如，下划线）。'
- en: Keep in mind that allowing quotes, semicolons, backslashes, and control characters
    (0x00-0x1F) will introduce vulnerabilities.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，允许引号、分号、反斜杠和控制字符（0x00-0x1F）将引入漏洞。
- en: '**If you need non-Latin names:** You must use RFC 2047, RFC 2231, or URL-style
    percent encoding in a browser-dependent manner. Make sure to filter out control
    characters (0x00-0x1F) and escape any semicolons, backslashes, and quotes.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您需要非拉丁字母的名字：** 您必须以浏览器依赖的方式使用RFC 2047、RFC 2231或URL风格的百分号编码。确保过滤掉控制字符（0x00-0x1F），并转义任何分号、反斜杠和引号。'
- en: When Putting User Data in HTTP Cookies
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当将用户数据放入HTTP Cookie中时
- en: '**Percent-encode everything except for alphanumerics**. Better yet, use base64\.
    Stray quote characters, control characters (0x00-0x1F), high-bit characters (0x80-0xFF),
    commas, semicolons, and backslashes may allow new cookie values to be injected
    or the meaning and scope of existing cookies to be altered.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除了字母数字之外的所有内容都需要进行百分号编码**。更好的做法是使用base64。多余的引号字符、控制字符（0x00-0x1F）、高位字符（0x80-0xFF）、逗号、分号和反斜杠可能会允许注入新的cookie值，或者改变现有cookie的意义和范围。'
- en: When Sending User-Controlled Location Headers
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送用户控制的地理位置头时
- en: '**Consult the cheat sheet in [Chapter 2](ch02.html "Chapter 2. It Starts with
    a URL")**. Parse and normalize the URL, and confirm that the scheme is on a whitelist
    of permissible values and that you are comfortable redirecting to the specified
    host.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考[第2章](ch02.html "第2章。一切从URL开始")中的速查表**。解析和标准化URL，并确认方案在允许值的白名单上，并且您对重定向到指定的主机感到满意。'
- en: Make sure that any control and high-bit characters are escaped properly. Use
    Punycode for hostnames and percent-encoding for the remainder of the URL.
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保任何控制和高位字符都已被正确转义。使用Punycode进行主机名编码，并对URL的其余部分使用百分号编码。
- en: When Sending User-Controlled Redirect Headers
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送用户控制的重定向头时
- en: '**Follow the advice provided for Location**. Note that semicolons are unsafe
    in this header and cannot be escaped reliably, but they also happen to have a
    special meaning in some URLs. Your choice is to reject such URLs altogether or
    to percent-encode the “;” character, thereby violating the RFC-mandated syntax
    rules.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵循关于位置的提示**。请注意，分号在这个头中是不安全的，并且无法可靠地转义，但它们在某些URL中也有特殊含义。您的选择是完全拒绝这样的URL，或者对“;”字符进行百分号编码，从而违反RFC规定的语法规则。'
- en: When Constructing Other Types of User-Controlled Requests or Responses
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建其他类型的用户可控请求或响应时
- en: '**Examine the syntax and potential side effects of the header in question**.
    In general, be mindful of control and high-bit characters, commas, quotes, backslashes,
    and semicolons; other characters or strings may be of concern on a case-by-case
    basis. Escape or substitute these values as appropriate.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查所涉及头部的语法和潜在副作用**。一般来说，要注意控制和高位字符、逗号、引号、反斜杠和分号；其他字符或字符串可能根据具体情况引起关注。根据需要转义或替换这些值。'
- en: '**When building a new HTTP client, server, or proxy:** Do not create a new
    implementation unless you absolutely have to. If you can’t help it, read this
    chapter thoroughly and aim to mimic an existing mainstream implementation closely.
    If possible, ignore the RFC-provided advice about fault tolerance and bail out
    if you encounter any syntax ambiguities.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在构建新的HTTP客户端、服务器或代理时**：除非你绝对有必要，否则不要创建新的实现。如果你无法避免，请仔细阅读本章，并力求尽可能接近模仿现有的主流实现。如果可能，忽略RFC提供的关于容错性的建议，并在遇到任何语法歧义时退出。'
- en: '* * *'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[24](#CHP-3-FN-11)]) Public key cryptography relies on asymmetrical encryption
    algorithms to create a pair of keys: a private one, kept secret by the owner and
    required to decrypt messages, and a public one, broadcast to the world and useful
    only to encrypt traffic to that recipient, not to decrypt it.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#CHP-3-FN-11)]) 公钥密码学依赖于非对称加密算法来创建一对密钥：一个私有的，由所有者保密并用于解密消息，另一个公有的，向全世界广播，仅用于加密发送给该接收者的流量，而不是解密。
- en: Chapter 4. Hypertext Markup Language
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 超文本标记语言
- en: The Hypertext Markup Language (HTML) is the primary method of authoring online
    documents. One of the earliest written accounts of this language is a brief summary
    posted on the Internet by Tim Berners-Lee in 1991.^([[136](pr03.html#ftn.CHP-4-FT-1)])
    His proposal outlines an SGML-derived syntax that allows text documents to be
    annotated with inline hyperlinks and several types of layout aids. In the following
    years, this specification evolved gradually under the direction of Sir Berners-Lee
    and Dan Connolly, but it wasn’t until 1995, at the onset of the First Browser
    Wars, that a reasonably serious and exhaustive specification of the language (HTML
    2.0) made it to RFC 1866.^([[137](pr03.html#ftn.CHP-4-FT-2)])
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本标记语言（HTML）是编写在线文档的主要方法。关于这种语言的最早书面记录之一是蒂姆·伯纳斯-李在1991年发布在互联网上的一篇简要总结。[^([[136](pr03.html#ftn.CHP-4-FT-1)])
    他的提案概述了一种基于SGML的语法，允许文本文档通过内联超链接和几种类型的布局辅助工具进行标注。在接下来的几年里，在伯纳斯-李爵士和丹·康诺利的指导下，该规范逐渐演变，但直到1995年，在第一次浏览器大战开始时，该语言的合理全面规范（HTML
    2.0）才出现在RFC 1866中。[^([[137](pr03.html#ftn.CHP-4-FT-2)])]
- en: 'From that point on, all hell broke loose: For the next few years, competing
    browser vendors kept introducing all sorts of flashy, presentation-oriented features
    and tweaked the language to their liking. Several attempts to amend the original
    RFC have been undertaken, but ultimately the IETF-managed standardization approach
    proved to be too inflexible. The newly formed World Wide Web Consortium took over
    the maintenance of the language and eventually published the HTML 3.2 specification
    in 1997.^([[138](pr03.html#ftn.CHP-4-FT-3)])'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，一切变得混乱不堪：接下来的几年里，竞争的浏览器供应商不断推出各种花哨的、以展示为导向的功能，并根据自己的喜好调整了语言。已经尝试对原始RFC进行多次修订，但最终，由IETF管理的标准化方法证明过于僵化。新成立的万维网联盟接管了该语言的维护工作，并于1997年最终发布了HTML
    3.2规范。[^([[138](pr03.html#ftn.CHP-4-FT-3)])]
- en: The new specification tried to reconcile the differences in browser implementations
    while embracing many of the bells and whistles that appealed to the public, such
    as customizable text colors and variable typefaces. Ultimately, though, HTML 3.2
    proved to be a step back for the clarity of the language and had only limited
    success in catching up with the facts.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 新规范试图弥合浏览器实现之间的差异，同时采纳了许多吸引公众的铃声和哨声，如可定制的文本颜色和可变字体。然而，最终，HTML 3.2在语言的清晰度上退步了，并且在追赶事实方面只取得了有限的成效。
- en: In the following years, the work on HTML 4 and 4.01^([[139](pr03.html#ftn.CHP-4-FT-4)])
    focused on pruning HTML of all accumulated excess and on better explaining how
    document elements should be interpreted and rendered. It also defined an alternative,
    strict XHTML syntax derived from XML, which was much easier to consistently parse
    but more punishing to write. Despite all this work, however, only a small fraction
    of all websites on the Internet could genuinely claim compliance with any of these
    standards, and little or no consistency in parsing modes and error recovery could
    be seen on the client end. Consequently, some of the work on improving the core
    language fizzled out, and the W3C turned its attention to stylesheets, the Document
    Object Model, and other more abstract or forward-looking challenges.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年里，对HTML 4和4.01的工作主要集中在修剪HTML中所有累积的冗余，以及更好地解释文档元素应该如何被解释和渲染。它还定义了一种基于XML的替代，严格的XHTML语法，这更容易一致地解析，但编写起来更具惩罚性。然而，尽管所有这些工作，然而，互联网上所有网站中只有一小部分真正声称符合这些标准，客户端在解析模式和错误恢复方面几乎看不到任何一致性。因此，一些改进核心语言的工作变得毫无成效，W3C将注意力转向了样式表、文档对象模型以及其他更抽象或前瞻性的挑战。
- en: In the late 2000s, some of the low-level work has been revived under the banner
    of HTML5,^([[140](pr03.html#ftn.CHP-4-FT-5)]) an ambitious project to normalize
    almost every aspect of the language syntax and parsing, define all the related
    APIs, and more closely police browser behavior in general. Time will tell if it
    will be successful; until then, the language itself, and each of the four leading
    parsing engines,^([[25](#ftn.CHP-4-FN-1)]) come with their own set of frustrating
    quirks.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代后期，一些底层工作在HTML5的旗帜下得到复兴，HTML5是一个雄心勃勃的项目，旨在规范语言语法的几乎每个方面，定义所有相关API，并更严格地监控浏览器的一般行为。时间将证明它是否成功；在此之前，语言本身以及四个主要的解析引擎，^([[25](#ftn.CHP-4-FN-1)])都带有它们自己的一套令人沮丧的怪癖。
- en: Basic Concepts Behind HTML Documents
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML文档的基本概念
- en: 'From a purely theoretical standpoint, HTML relies on a fairly simple syntax:
    a hierarchical structure of tags, *name=value* tag parameters, and text nodes
    (forming the actual document body) in between. For example, a simple document
    with a title, a heading, and a hyperlink may look like this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹理论的角度来看，HTML依赖于相当简单的语法：标签的分层结构、*name=value* 标签参数，以及介于其中的文本节点（构成实际文档主体）。例如，一个简单的文档，包含标题、标题和超链接，可能看起来像这样：
- en: '[PRE29]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This syntax puts some constraints on what may appear inside a parameter value
    or inside the document body. Five characters—angle brackets, single and double
    quotes, and an ampersand—are reserved as the building blocks of the HTML markup,
    and these need to be avoided or escaped in some way when used outside of their
    intended function. The most important rules are:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法对参数值或文档主体内部可能出现的元素施加了一些限制。五个字符——尖括号、单引号、双引号和和号——被保留为HTML标记的构建块，当它们用于其预期功能之外时，需要避免或以某种方式转义。最重要的规则是：
- en: Stray ampersands (&) should never appear in most sections of an HTML document.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML文档的大部分部分中，不应出现多余的和号（&）。
- en: Both types of angle brackets are obviously problematic inside a tag, unless
    properly quoted.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种类型的尖括号在标签内显然是问题性的，除非它们被正确引用。
- en: The left angle bracket (<) is a hazard inside a text node.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左尖括号（<）在文本节点内是一个危险因素。
- en: Quote characters appearing inside a tag can have undesirable effects, depending
    on their exact location, but are harmless in text nodes.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出现在标签内的引号字符可能会根据它们的确切位置产生不良影响，但在文本节点中是无害的。
- en: To allow these characters to appear in problematic locations without causing
    side effects, an ampersand-based encoding scheme, discussed in [Entity Encoding](ch04s03.html
    "Entity Encoding") in [HTML Parsing Survival Tips](ch04s02.html#html_parsing_survival_tips
    "HTML Parsing Survival Tips"), is provided.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许这些字符在不引起副作用的情况下出现在问题位置，提供了一个基于和号（&）的编码方案，这在[实体编码](ch04s03.html "实体编码")中有所讨论，该内容位于[HTML解析生存技巧](ch04s02.html#html_parsing_survival_tips
    "HTML Parsing Survival Tips")。
- en: Note
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, the availability of such an encoding scheme is not a guarantee of
    its use. The failure to properly filter out or escape reserved characters when
    displaying user-controlled data is the cause of a range of extremely common and
    deadly web application security flaws. A particularly well-known example of this
    is *cross-site scripting (XSS)*, an attack in which malicious, attacker-provided
    JavaScript code is unintentionally echoed back somewhere in the HTML markup, effectively
    giving the attacker full control over the appearance and operation of the targeted
    site.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种编码方案的可用性并不能保证其被使用。在显示用户控制的数据时未能正确过滤或转义保留字符，是导致一系列极其常见且致命的Web应用程序安全漏洞的原因。一个特别著名的例子是*跨站脚本（XSS）*，这是一种攻击，恶意攻击者提供的JavaScript代码在HTML标记中无意中被回显，从而有效地使攻击者完全控制目标网站的外观和操作。
- en: Document Parsing Modes
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档解析模式
- en: 'For any HTML document, a top-level *<!DOCTYPE>* directive may be used to instruct
    the browser to parse the file in a manner that at least superficially conforms
    to one of the officially defined standards; to a more limited extent, the same
    signal can be conveyed by the *Content-Type* header, too. Of all the available
    parsing modes, the most striking difference exists between XHTML and traditional
    HTML. In the traditional mode, parsers will attempt to recover from most types
    of syntax errors, including unmatched opening and closing tags. In addition, tag
    and parameter names will be considered case insensitive, parameter values will
    not always need to be quoted, and certain types of tags, such as *<img>*, will
    be closed implicitly. In other words, the following input will be grudgingly tolerated:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何HTML文档，可以使用顶层*<!DOCTYPE>*指令来指示浏览器以至少表面上符合官方定义标准的方式解析文件；在更有限的程度上，相同的信号也可以通过*Content-Type*头传递。在所有可用的解析模式中，XHTML和传统HTML之间的差异最为显著。在传统模式下，解析器将尝试从大多数类型的语法错误中恢复，包括不匹配的开启和关闭标签。此外，标签和参数名称将被视为不区分大小写，参数值不一定需要引用，并且某些类型的标签，如*<img>*，将被隐式关闭。换句话说，以下输入将被勉强接受：
- en: '[PRE30]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The XML mode, on the other hand, is strict: All tags need to be balanced carefully,
    named using the proper case, and closed explicitly. (The XML-specific self-closing
    tag syntax, such as *<img />*, is permitted.) In addition, most syntax mistakes,
    even trivial ones, will result in an error and prevent the document from being
    displayed at all.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，XML模式是严格的：所有标签都需要仔细平衡，使用正确的命名大小写，并且必须显式关闭。（允许使用XML特定的自闭合标签语法，例如*<img />*。）此外，大多数语法错误，即使是微不足道的错误，也会导致错误，并阻止文档显示。
- en: Unlike the regular flavor of HTML, XML-based documents may also elegantly incorporate
    sections using other XML-compliant markup formats, such as MathML, a mathematical
    formula markup language. This is done by specifying a different *xmlns* namespace
    setting for a particular tag, with no need for one-off, language-level hacks.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的HTML版本不同，基于XML的文档可以优雅地结合使用其他XML兼容的标记格式，例如MathML，这是一种数学公式标记语言。这是通过为特定标签指定不同的*xmlns*命名空间设置来实现的，无需进行一次性的语言级别黑客攻击。
- en: The last important difference worth mentioning here is that traditional HTML
    parsing strategies feature a selection of special modes, entered into after certain
    tags are encountered and exited only when a specific terminator string is seen;
    everything in between is interpreted as non-HTML text. Some examples of such special
    tags include *<style>*, *<script>*, *<textarea>*, or *<xmp>*. In practical implementations,
    these modes are exited only when a literal, case-insensitive match on *</style*,
    *</script*, or a similar matching value, is made; any other markup inside such
    a block will not be interpreted as HTML. (Interestingly, there is one officially
    obsolete tag, *<plaintext>*, that cannot be exited at all; it stays in effect
    for the remainder of the document.)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 值得在此提及的最后一个重要区别是，传统的HTML解析策略具有一组特殊的模式，这些模式在遇到某些标签后进入，并在看到特定的终止字符串时退出；介于两者之间的所有内容都被解释为非HTML文本。这类特殊标签的例子包括*<style>*,
    *<script>*, *<textarea>*, 或 *<xmp>*。在实际实现中，这些模式只有在进行字面、不区分大小写的匹配时才会退出，例如匹配*</style>*,
    *</script>*, 或类似的匹配值；任何此类块内的其他标记都不会被解释为HTML。（有趣的是，有一个官方上已经废弃的标签*<plaintext>*,
    完全无法退出；它将一直有效到文档的末尾。）
- en: 'In comparison, the XML mode is more predictable. It generally forbids stray
    “<” and “&” characters inside the document, but it provides a special syntax,
    starting with “<![CDATA[” and ending with “]]>”, as a way to encapsulate any raw
    text inside an arbitrary tag. For example:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，XML模式更可预测。它通常禁止在文档内部出现散乱的“<”和“&”字符，但它提供了一种特殊的语法，以“<![CDATA[”开始，以“]]>”结束，作为在任意标签内封装任何原始文本的方法。例如：
- en: '[PRE31]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The other notable special parsing mode available in both XHTML and normal HTML
    is a comment block. In XML, it quite simply begins with “<!--” and ends with “-->”.
    In the traditional HTML parser in Firefox versions prior to 4, any occurrence
    of “--”, later followed by “>”, is also considered good enough.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在XHTML和普通HTML中都可用的一种值得注意的特殊解析模式是注释块。在XML中，它非常简单，以“<!--”开始，以“-->”结束。在Firefox版本4之前的传统HTML解析器中，任何出现“--”，随后是“>”的情况也被认为足够好。
- en: The Battle over Semantics
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义之战
- en: 'The low-level syntax of the language aside, HTML is also the subject of a fascinating
    conceptual struggle: a clash between the ideology and the reality of the online
    world. Tim Berners-Lee always championed the vision of a *semantic web*, an interconnected
    system of documents in which every functional block, such as a citation, a snippet
    of code, a mailing address, or a heading, has its meaning explained by an appropriate
    machine-readable tag (say, *<cite>*, *<code>*, *<address>*, or *<h1>* to *<h6>*).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语言的底层语法之外，HTML也是一场迷人的概念斗争的主题：在线世界的意识形态与现实之间的冲突。蒂姆·伯纳斯-李一直倡导*语义网*的愿景，这是一个相互连接的文档系统，其中每个功能块，如引用、代码片段、邮寄地址或标题，都由适当的机器可读标签（例如，*<cite>*,
    *<code>*, *<address>*, 或 *<h1>到<h6>*）解释其含义。
- en: This approach, he and other proponents argued, would make it easier for machines
    to crawl, analyze, and index the content in a meaningful way, and in the near
    future, it would enable computers to reason using the sum of human knowledge.
    According to this philosophy, the markup language should provide a way to stylize
    the appearance of a document, but only as an afterthought.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 他和其他支持者认为，这种方法将使机器更容易以有意义的方式爬取、分析和索引内容，并且在未来不久，它将使计算机能够利用人类知识的总和进行推理。根据这种哲学，标记语言应该提供一种方式来美化文档的外观，但只能作为次要考虑。
- en: Sir Berners-Lee has never given up on this dream, but in this one regard, the
    actual usage of HTML proved to be very different from what he wished for. Web
    developers were quick to pragmatically distill the essence of HTML 3.2 into a
    handful of presentation-altering but semantically neutral tags, such as *<font>*,
    *<b>*, and *<pre>*, and saw no reason to explain further the structure of their
    documents to the browser. W3C attempted to combat this trend but with limited
    success. Although tags such as *<font>* have been successfully obsoleted and largely
    abandoned in favor of CSS, this is only because stylesheets offered more powerful
    and consistent visual controls. With the help of CSS, the developers simply started
    relying on a soup of semantically agnostic *<span>* and *<div>* tags to build
    everything from headings to user-clickable buttons, all in a manner completely
    opaque to any automated content extraction tools.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 伯纳斯-李爵士从未放弃过这个梦想，但在这一方面，HTML的实际使用证明与他所期望的非常不同。网络开发者迅速地将HTML 3.2的精髓提炼成几个改变呈现但语义中性的标签，如*<font>*,
    *<b>*, 和 *<pre>*, 并没有看到进一步解释他们文档结构的理由。W3C试图对抗这种趋势，但效果有限。尽管*<font>*这样的标签已经被成功废弃，并大量被CSS所取代，但这仅仅是因为样式表提供了更强大和一致的视觉控制。借助CSS，开发者开始依赖一大堆语义无关的*<span>*和*<div>*标签来构建从标题到用户可点击按钮的一切，所有这些对任何自动内容提取工具来说都是完全透明的。
- en: 'Despite having had a lasting impact on the design of the language, in some
    ways, the idea of a semantic web may be becoming obsolete: Online content less
    frequently maps to the concept of a single, viewable document, and HTML is often
    reduced to providing a convenient drawing surface and graphic primitives for JavaScript
    applications to build their interfaces with.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对语言的设计产生了持久的影响，但在某些方面，语义网的观念可能正在变得过时：在线内容越来越不映射到单一可查看文档的概念，HTML通常被简化为提供方便的绘图表面和图形原语，供JavaScript应用程序构建界面。
- en: '* * *'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[25](#CHP-4-FN-1)]) To process HTML documents, Internet Explorer uses the
    Trident engine (aka MSHTML); Firefox and some derived products use Gecko; Safari,
    Chrome, and several other browsers use WebKit; and Opera relies on Presto. With
    the exception of WebKit, a collaborative open source effort maintained by several
    vendors, these engines are developed largely in-house by their respective browser
    teams.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-4-FN-1)]) 为了处理 HTML 文档，Internet Explorer 使用 Trident 引擎（也称为 MSHTML）；Firefox
    和一些派生产品使用 Gecko；Safari、Chrome 以及其他几个浏览器使用 WebKit；而 Opera 则依赖于 Presto。除了 WebKit，这是一个由几家供应商维护的协作开源努力，其他引擎主要是由各自的浏览器团队内部开发的。
- en: Understanding HTML Parser Behavior
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 HTML 解析器行为
- en: 'The fundamentals of HTML syntax outlined in the previous sections are usually
    enough to understand the meaning of well-formed HTML and XHTML documents. When
    the XHTML dialect is used, there is little more to the story: The minimal fault-tolerance
    of the parser means that anomalous syntax almost always leads simply to a parsing
    error. Alas, the picture is very different with traditional, laid-back HTML parsers,
    which aggressively second-guess the intent of the page developer even in very
    ambiguous or potentially harmful situations.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中概述的 HTML 语法基础通常足以理解良好形成的 HTML 和 XHTML 文档的意义。当使用 XHTML 词汇时，故事也就到此为止了：解析器的最小容错性意味着异常语法几乎总是导致解析错误。然而，情况与传统的、放松的
    HTML 解析器截然不同，即使在非常模糊或可能有害的情况下，这些解析器也会积极猜测页面开发者的意图。
- en: 'Since an accurate understanding of user-supplied markup is essential to designing
    many types of security filters, let’s have a quick look at some of these behaviors
    and quirks. To begin, consider the following reference snippet:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 由于准确理解用户提供的标记对于设计许多类型的网络安全过滤器至关重要，让我们快速了解一下这些行为和特性。首先，考虑以下参考片段：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages949999.png.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages949999.png.jpg)'
- en: 'Web developers are usually surprised to learn that this syntax can be drastically
    altered without changing its significance to the browser. For example, Internet
    Explorer will allow an NUL character (0x00) to be inserted in the location marked
    at ![](httpatomoreillycomsourcenostarchimages950001.png), a change that is likely
    to throw all naïve HTML filters off the trail. It is also not widely known that
    the whitespaces at ![](httpatomoreillycomsourcenostarchimages950003.png) and ![](httpatomoreillycomsourcenostarchimages950005.png)
    can be substituted with uncommon vertical tab (0x0B) or form feed (0x0C) characters
    in all browsers and with a nonbreaking UTF-8 space (0xA0) in Opera.^([[26](#ftn.CHP-4-FN-2)])
    Oh, and here''s a really surprising bit: In Firefox, the whitespace at ![](httpatomoreillycomsourcenostarchimages950003.png)
    can also be replaced with a single, regular slash—yet the one at ![](httpatomoreillycomsourcenostarchimages950005.png)
    can’t.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 网页开发者通常会对这种语法可以在不改变其对浏览器意义的情况下被大幅修改感到惊讶。例如，Internet Explorer 允许在标记为 ![](httpatomoreillycomsourcenostarchimages950001.png)
    的位置插入 NUL 字符（0x00），这种变化可能会让所有天真的 HTML 过滤器迷失方向。而且，很少有人知道在 ![](httpatomoreillycomsourcenostarchimages950003.png)
    和 ![](httpatomoreillycomsourcenostarchimages950005.png) 的空白字符可以用不常见的垂直制表符（0x0B）或换页符（0x0C）字符在所有浏览器中替换，在
    Opera 中则可以用非断行 UTF-8 空格（0xA0）替换.^([[26](#ftn.CHP-4-FN-2)]) 哦，还有一件真正令人惊讶的事情：在 Firefox
    中，![](httpatomoreillycomsourcenostarchimages950003.png) 的空白字符也可以被替换为一个普通的单个斜杠——然而在
    ![](httpatomoreillycomsourcenostarchimages950005.png) 的位置则不能。
- en: Moving on, the location marked ![](httpatomoreillycomsourcenostarchimages950007.png)
    is also of note. In this spot, NUL characters are ignored by most parsers, as
    are many types of whitespaces. Not long ago, WebKit browsers accepted a slash
    in this location, but recent parser improvements have eliminated this quirk.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，标记为 ![](httpatomoreillycomsourcenostarchimages950007.png) 的位置也值得关注。在这个位置，大多数解析器会忽略
    NUL 字符，以及许多类型的空白字符。不久前，WebKit 浏览器接受在这个位置使用斜杠，但最近的解析器改进已经消除了这个特性。
- en: Quote characters are a yet another topic of interest. Website developers know
    that single and double quotes can be used to put a string containing whitespaces
    or angle brackets in an HTML parameter, but it usually comes as a surprise that
    Internet Explorer also honors backticks (`) instead of real quotes in the location
    marked ![](httpatomoreillycomsourcenostarchimages950009.png). Similarly, few people
    realize that in any browser, an implicit whitespace is inserted after a quoted
    parameter, and that the explicit whitespace at ![](httpatomoreillycomsourcenostarchimages950011.png)
    can therefore be skipped without changing the meaning of the tag.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 引号字符又是另一个引人入胜的话题。网站开发者知道可以使用单引号和双引号将包含空格或尖括号的字符串放入HTML参数中，但通常会让人们感到惊讶的是，在标记为![图片链接](http://atomoreilly.com/source/nostarch/images/950009.png)的位置，Internet
    Explorer也尊重反引号（`）而不是真正的引号。同样，很少有人意识到在任何浏览器中，在引号参数之后都会插入一个隐式的空格，因此在![图片链接](http://atomoreilly.com/source/nostarch/images/950011.png)处的显式空格可以省略，而不会改变标签的意义。
- en: 'The security impact of these patterns is not always easy to appreciate, but
    consider an HTML filter tasked with scrubbing an *<img>* tag with an attacker-controlled
    *title* parameter. Let’s say that in the input markup, this parameter is not quoted
    if it contains no whitespaces and angle brackets—a design that can be seen on
    a popular blogging site. This practice may appear safe at first, but in the following
    two cases, a malicious, injected *onerror* parameter will materialize inside a
    tag:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式对安全性的影响并不总是容易理解，但考虑一个HTML过滤器，其任务是清除带有攻击者控制的*title*参数的*<img>*标签。假设在输入标记中，如果该参数不包含空格和尖括号，则不会对其进行引号处理——这种设计可以在一个流行的博客网站上看到。这种做法可能一开始看起来很安全，但在以下两种情况下，恶意注入的*onerror*参数将出现在标签内部：
- en: '[PRE32]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: and
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE33]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Yet another wonderful quote-related quirk in Internet Explorer makes this job
    even more complicated. While most browsers recognize quoting only when it is used
    at the beginning of a parameter value, Internet Explorer simply checks for any
    occurrence of an equal sign (=) followed by a quote and will parse this syntax
    in a rather unexpected way:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在Internet Explorer中非常有趣的与引号相关的怪癖使得这项工作变得更加复杂。虽然大多数浏览器仅在参数值的开头使用引号时才识别引号，但Internet
    Explorer只是检查任何等于号（=）后跟引号的出现，并以一种相当意想不到的方式解析这种语法：
- en: '[PRE34]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Interactions Between Multiple Tags
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个标签之间的交互
- en: 'Parsing a single tag can be a daunting task, but as you might imagine, anomalous
    arrangements of multiple HTML tags will be even less predictable. Consider the
    following trivial example:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 解析单个标签可能是一项艰巨的任务，但正如你可能想象的那样，多个HTML标签的非正常排列将更加不可预测。考虑以下简单的例子：
- en: '[PRE35]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When presented with such syntax, most browsers only interpret *<i>* and treat
    the “<b” string as an invalid tag parameter. Firefox versions before 4, however,
    would automatically close the *<i>* tag first when encountering an angle bracket
    and, in the end, will interpret both *<i>* and *<b>*. In the spirit of fault tolerance,
    until recently WebKit followed that model, too.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到这样的语法时，大多数浏览器只会解释*<i>*，并将“<b”字符串视为无效的标签参数。然而，Firefox版本在4之前，在遇到尖括号时会自动先关闭*<i>*标签，最终会解释*<i>*和*<b>*。本着容错的精神，直到最近WebKit也遵循了这一模式。
- en: 'A similar behavior can be observed in previous versions of Firefox when dealing
    with tag names that contain invalid characters (in this case, the equal sign).
    Instead of doing its best to ignore the entire block, the parser would simply
    reset and interpret the quoted tag:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理包含无效字符（在这种情况下，是等于号）的标签名时，可以在Firefox的早期版本中观察到类似的行为。解析器不会尽力忽略整个块，而是简单地重置并解释引号内的标签：
- en: '[PRE36]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The handling of tags that are not closed before the end of the file is equally
    fascinating. For example, the following snippet will prompt most browsers to interpret
    the *<i>* tag or ignore the entire string, but Internet Explorer and Opera use
    a different backtracking approach and will see *<b>* instead:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾之前未关闭的标签的处理同样引人入胜。例如，以下片段将导致大多数浏览器解释*<i>*标签或忽略整个字符串，但Internet Explorer和Opera使用不同的回溯方法，并将看到*<b>*：
- en: '[PRE37]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In fact, Firefox versions prior to version 4 engaged in far-fetched reparsing
    whenever particular special tags, such as *<title>*, were not closed before the
    end of the document:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Firefox版本在4之前，如果特定的特殊标签（如*<title>*）在文档末尾之前没有关闭，就会进行牵强的重新解析：
- en: '[PRE38]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last two parsing quirks have interesting security consequences in any scenario
    where the attacker may be able to interrupt page load prematurely. Even if the
    markup is otherwise fairly well sanitized, the meaning of the document may change
    in a very unexpected way.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个解析怪癖在任何攻击者可能能够提前中断页面加载的场景中都有有趣的后果。即使标记本身相当干净，文档的意义可能会以非常意想不到的方式改变。
- en: Explicit and Implicit Conditionals
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式和隐式条件
- en: 'To further complicate the job of HTML parsing, some browsers exhibit behaviors
    that can be used to conditionally skip some of the markup in a document. For example,
    in an attempt to help novice users of Microsoft’s Active Server Pages development
    platform, Internet Explorer treats *<% ... %>* blocks as a completely nonstandard
    comment, hiding any markup between these two character sequences. Another Internet
    Explorer-specific feature is explicit conditional expressions interpreted by the
    parser and smuggled inside standard HTML comment blocks:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步复杂化 HTML 解析的工作，一些浏览器表现出一些行为，可以用来有条件地跳过文档中的一些标记。例如，为了帮助微软 Active Server
    Pages 开发平台的初级用户，Internet Explorer 将 `<% ... %>` 块视为一个完全非标准的注释，隐藏这两个字符序列之间的任何标记。另一个
    Internet Explorer 特有的功能是解析器解释的显式条件表达式，并偷偷地放在标准的 HTML 注释块中：
- en: '[PRE39]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Many other quirks of this type are related to the idiosyncrasies of SGML and
    XML. For example, due to the comment-handling behavior mentioned earlier in an
    aside, browsers disagree on how to parse !- and ?-directives (such as *<!DOCTYPE>*
    or *<?xml>*), whether to allow XML-style CDATA blocks in non-XHTML modes, and
    on what precedence to give to overlapping special parsing mode tags (such as “*<style><!--
    </style> -->*”).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他这类怪癖都与 SGML 和 XML 的特性有关。例如，由于前面提到的旁注中的注释处理行为，浏览器在解析 !- 和 ?-指令（如 `<!DOCTYPE>`
    或 `<?xml>`）方面存在分歧，是否允许在非 XHTML 模式下使用 XML 风格的 CDATA 块，以及如何确定重叠的特殊解析模式标签（如 `<style><!--
    </style> -->`）的优先级。
- en: HTML Parsing Survival Tips
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 解析生存技巧
- en: 'The set of parsing behaviors discussed in the previous sections is by no means
    exhaustive. In fact, an entire book has been written on this topic: Inquisitive
    readers are advised to grab *Web Application Obfuscation* (Syngress, 2011) by
    Mario Heiderich, Eduardo Alberto Vela Nava, Gareth Heyes, and David Lindsay—and
    then weep about the fate of humanity. The bottom line is that building HTML filters
    that try to block known dangerous patterns, and allow the remaining markup as
    is, is simply not feasible.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 前面几节讨论的解析行为远非详尽无遗。实际上，已经有整本书是关于这个主题的：建议好奇的读者获取 Mario Heiderich、Eduardo Alberto
    Vela Nava、Gareth Heyes 和 David Lindsay 所著的《Web 应用混淆》（Syngress，2011）——然后为人类的命运感到悲伤。底线是，构建试图阻止已知危险模式的
    HTML 过滤器，并允许剩余的标记保持原样，这根本不可行。
- en: The only reasonable approach to tag sanitization is to employ a realistic parser
    to translate the input document into a hierarchical in-memory document tree, and
    then scrub this representation for all unrecognized tags and parameters, as well
    as any undesirable tag/parameter/value configurations. At that point, the tree
    can be carefully reserialized into a well-formed, well-escaped HTML that will
    not flex any of the error correction muscles in the browser itself. Many developers
    think that a simpler design should be possible, but eventually they discover the
    reality the hard way.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 标签清理的唯一合理方法是使用一个现实的解析器将输入文档转换为层次结构的内存文档树，然后清理这个表示形式中所有未识别的标签和参数，以及任何不希望的标签/参数/值配置。到那时，这个树可以被仔细地重新序列化为格式良好、转义良好的
    HTML，不会在浏览器本身中激活任何错误纠正功能。许多开发者认为应该有一个更简单的设计方案，但最终他们以艰难的方式发现了现实。
- en: '* * *'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[26](#CHP-4-FN-2)]) The behavior exhibited by Opera is particularly sneaky:
    The Unicode whitespace is not recognized by many standard library functions used
    in server-side HTML sanitizers, such as *isspace(...)* in libc. This increases
    the risk of implementation glitches.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#CHP-4-FN-2)]) Opera 表现出的行为尤其狡猾：Unicode 空白字符不被许多用于服务器端 HTML 清理器的标准库函数识别，例如
    libc 中的 `isspace(...)`。这增加了实现故障的风险。
- en: Entity Encoding
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体编码
- en: Let’s talk about character encoding again. As noted on the first pages of this
    chapter, certain reserved characters are generally unsafe inside text nodes and
    tag parameter values, and they will often lead to outright syntax errors in XHTML.
    In order to allow such characters to be used safely (and to allow a convenient
    way to embed high-bit text), a simple ampersand-prefixed, semicolon-terminated
    encoding scheme, known as entity encoding, is available to developers.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次谈谈字符编码。正如本章第一页所注明的，某些保留字符在文本节点和标签参数值内通常是危险的，并且它们往往会直接导致XHTML中的语法错误。为了允许安全地使用这些字符（并允许方便地嵌入高位文本），开发人员可以使用一个简单的以&符号开头、以分号结尾的编码方案，称为实体编码。
- en: The most familiar use of this encoding method is the inclusion of certain predefined,
    named entities. Only a handful of these are specified for XML, but several hundred
    more are scattered in HTML specifications and supported by all modern browsers.
    In this approach, *&lt;* is used to insert a left angle bracket; *&gt;* substitutes
    a right angle bracket; *&amp;* replaces the ampersand itself; while, say, *&rarr;*
    is a nice Unicode arrow.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码方法最熟悉的使用是包含某些预定义的命名实体。在XML中，只有少数这些实体被指定，但在HTML规范中有数百个更多，并且所有现代浏览器都支持。在这种情况下，*&lt;*用于插入左尖括号；*&gt;*替换为右尖括号；*&amp;*替换为自身；而例如*&rarr;*是一个很好的Unicode箭头。
- en: Note
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In XHTML documents, additional named entities can be defined using the *<!ENTITY>*
    directive and made to resolve to internally defined strings or to the contents
    of an external file URL. (This last option is obviously unsafe if allowed when
    processing untrusted content; the resulting attack is sometimes called *External
    XML Entity*, or XXE for short.)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在XHTML文档中，可以使用*<!ENTITY>*指令定义额外的命名实体，并将其解析为内部定义的字符串或外部文件URL的内容。（如果允许处理不受信任的内容时使用此选项，则显然是不安全的；这种攻击有时被称为*外部XML实体*，或简称XXE。）
- en: In addition to the named entities, it is also possible to insert an arbitrary
    ASCII or Unicode character using a decimal *&#number;* notation. In this case,
    *&#60;* maps to a left angle bracket; *&#62;* substitutes a right one; and *&#128569;*
    is, I kid you not, a Unicode 6.0 character named “smiling cat face with tears
    of joy.” Hexadecimal notation can also be used if the number is prefixed with
    “x”. In this variant, the left angle bracket becomes *&#x3c;*, etc.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命名实体之外，还可以使用十进制*&#number;*表示法插入任意ASCII或Unicode字符。在这种情况下，*&#60;*映射到左尖括号；*&#62;*替换为右尖括号；而*&#128569;*实际上是一个名为“笑脸猫脸带泪”的Unicode
    6.0字符。如果数字前缀为“x”，则也可以使用十六进制表示法。在这种情况下，左尖括号变为*&#x3c;*等。
- en: 'The HTML parser recognizes entity encoding inside text nodes and parameter
    values and decodes it transparently when building an in-memory representation
    of the document tree. Therefore, the following two cases are functionally identical:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: HTML解析器识别文本节点和参数值内的实体编码，并在构建文档树内存表示时透明地解码它。因此，以下两种情况在功能上是相同的：
- en: '[PRE40]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: and
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE41]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following two examples, on the other hand, will not work as expected, as
    the encoding interferes with the structure of the tag itself:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下两个示例将不会按预期工作，因为编码会干扰标签本身的结构：
- en: '[PRE42]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: and
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE43]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The largely transparent behavior of entity encoding makes it important to correctly
    resolve it prior to making any security decisions about the contents of a document
    and, if applicable, to properly restore it in the sanitized output later on. To
    illustrate, the following syntax must be recognized as an absolute reference to
    a *javascript:* pseudo-URL and not to a cryptic fragment ID inside a relative
    resource named “./javascript&”:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 实体编码的这种很大程度上透明的行为使得在做出关于文档内容的任何安全决策之前正确解析它变得很重要，如果适用，在稍后对清洗后的输出进行正确恢复。为了说明，以下语法必须被识别为对*javascript:*伪URL的绝对引用，而不是对名为“./javascript&”的相对资源内的神秘片段ID的引用：
- en: '[PRE44]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unfortunately, even the simple task of recognizing and parsing HTML entities
    can be tricky. In traditional parsing, for example, entities may often be accepted
    even if the trailing semicolon is omitted, as long as the next character is not
    an alphanumeric. (In Firefox, dashes and periods are also accepted in entity names.)
    Numeric entities are even more problematic, as they may have an overlong notation
    with an arbitrary number of trailing zeros. Moreover, if the numerical value is
    higher than 232, the standard size of an integer on many computer architectures,
    the corresponding character may be computed incorrectly.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使是识别和解析 HTML 实体的简单任务也可能很棘手。例如，在传统的解析中，即使尾随的分号被省略，只要下一个字符不是字母数字，实体通常也会被接受。（在
    Firefox 中，连字符和点也接受在实体名称中。）数字实体甚至更成问题，因为它们可能有任意数量的尾随零的过长表示法。此外，如果数值大于许多计算机架构中整数的标准大小
    232，相应的字符可能被错误计算。
- en: 'Developers working with XHTML should be aware of a potential pitfall in that
    dialect, too. Although HTML entities are not recognized in most of the special
    parsing modes, XHTML differs from traditional HTML in that tags such as *<script>*
    and *<style>* do not automatically toggle a special parsing mode on their own.
    Instead, an explicit *<![CDATA[...]]>* block around any scripts or stylesheets
    is required to achieve a comparable effect. Therefore, the following snippet with
    an attacker-controlled string (otherwise scrubbed for angle brackets, quotes,
    backslashes, and newlines) is perfectly safe in HTML, but not in XHTML:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XHTML 的工作开发者也应该意识到该方言中存在的一个潜在陷阱。尽管在大多数特殊解析模式中不识别 HTML 实体，但 XHTML 与传统 HTML
    的不同之处在于，如 *<script>* 和 *<style>* 这样的标签不会自动切换到特殊的解析模式。相反，需要任何脚本或样式的 *<![CDATA[...]]>*
    块来实现类似的效果。因此，以下带有攻击者控制的字符串（否则会清除尖括号、引号、反斜杠和新行）的片段在 HTML 中是安全的，但在 XHTML 中则不是：
- en: '[PRE45]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: HTTP/HTML Integration Semantics
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/HTML 集成语义
- en: From [Chapter 3](ch03.html "Chapter 3. Hypertext Transfer Protocol"), we recall
    that HTTP headers may give new meaning to the entire response (*Location*, *Transfer-Encoding*,
    and so on), change the way the payload is presented (*Content-Type*, *Content-Disposition*),
    or affect the client-side environment in other, auxiliary ways (*Refresh*, *Set-Cookie*,
    *Cache-Control*, *Expires*, etc.).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第 3 章](ch03.html "第 3 章。超文本传输协议")中，我们回忆起 HTTP 头部可能给整个响应赋予新的意义（如 *Location*、*Transfer-Encoding*
    等），改变有效载荷的呈现方式（如 *Content-Type*、*Content-Disposition*），或者以其他辅助方式影响客户端环境（如 *Refresh*、*Set-Cookie*、*Cache-Control*、*Expires*
    等）。
- en: But what if an HTML document is delivered through a non-HTTP protocol or loaded
    from a local file? Clearly, in this case, there is no simple way to express or
    preserve this information. We can part with some of it easily, but parameters
    such as the MIME type or the character set are essential, and losing them forces
    browsers to improvise later on. (Consider, for example, that charsets such as
    UTF-7, UTF-16, and UTF-32 are not ASCII-compatible and, therefore, HTML documents
    can’t even be parsed without determining which of these transformations needs
    to be used.)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果 HTML 文档是通过非 HTTP 协议发送或从本地文件加载的，会怎样呢？显然，在这种情况下，没有简单的方法来表示或保留这些信息。我们可以轻松地放弃其中的一些，但
    MIME 类型或字符集等参数是必不可少的，失去它们迫使浏览器在以后进行即兴创作。（例如，考虑 UTF-7、UTF-16 和 UTF-32 这样的字符集与 ASCII
    不兼容，因此，HTML 文档甚至在没有确定需要使用哪种转换的情况下都无法解析。）
- en: The security consequences of the browser-level heuristics used to detect character
    sets and document types will be explored in detail in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms"). Meanwhile, the problem of preserving protocol-level
    information within a document is somewhat awkwardly addressed by a special HTML
    directive, *<meta http-equiv=...>*. By the time the browser examines the markup,
    many content-handling decisions must have already been made, but some tweaks are
    still on the table; for example, it may be possible to adjust the charset to a
    generally compatible value or to specify *Refresh*, *Set-Cookie*, and caching
    directives.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 13 章](ch13.html "第 13 章。内容识别机制")中，将详细探讨用于检测字符集和文档类型的浏览器级启发式方法的安全后果。同时，通过特殊的
    HTML 指令 *<meta http-equiv=...>*，以一种多少有些尴尬的方式解决了在文档中保留协议级信息的问题。当浏览器检查标记时，许多内容处理决策可能已经做出，但仍有一些调整可以做出；例如，可能调整字符集到一个普遍兼容的值，或者指定
    *Refresh*、*Set-Cookie* 和缓存指令。
- en: 'As an illustration of permissible syntax, consider the following directive
    that, when appearing in an 8-bit ASCII document, will clarify for the browser
    that the charset of the document is UTF-8 and not, say, ISO-8859-1:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 作为允许的语法的示例，考虑以下指令，当出现在8位ASCII文档中时，将向浏览器阐明文档的字符集是UTF-8，而不是，比如说，ISO-8859-1：
- en: '[PRE46]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On the flip side, all of the following directives will fail, because at this
    point it is too late to switch to an incompatible UTF-32 encoding, change the
    document type to a video format, or execute a redirect instead of parsing the
    file:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，以下所有指令都将失败，因为此时切换到不兼容的UTF-32编码、更改文档类型为视频格式或执行重定向而不是解析文件都太晚了：
- en: '[PRE47]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Be mindful that when *http-equiv* values conflict with each other, or contradict
    the HTTP headers received from the server earlier on, their behavior is not consistent
    and should not be relied upon. For example, the first supported *charset=* value
    usually prevails (and HTTP headers have precedence over *<meta>* in this case),
    but with several conflicting *Refresh* values, the behavior is highly browser-specific.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当 *http-equiv* 值相互冲突或与之前从服务器接收到的HTTP头信息相矛盾时，它们的行为并不一致，不应依赖。例如，第一个支持的 *charset=*
    值通常占主导地位（在这种情况下，HTTP头信息优先于 *<meta>*），但有几个冲突的 *Refresh* 值时，行为高度依赖于浏览器。
- en: Note
  id: totrans-549
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some browsers will attempt to speculatively extract <meta http-equiv> information
    before actually parsing the document, which may lead to embarrassing mistakes.
    For example, a security bug recently fixed in Firefox 4 caused the browser to
    interpret the following statement as a character set declaration: *<meta http-equiv="Refresh"
    content="10;http://www.example.com/charset=utf-7">*.^([[141](pr03.html#ftn.CHP-4-FT-6)])'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器会在实际解析文档之前尝试推测性地提取 <meta http-equiv> 信息，这可能会导致尴尬的错误。例如，Firefox 4最近修复的一个安全漏洞导致浏览器将以下声明解释为字符集声明：*<meta
    http-equiv="Refresh" content="10;http://www.example.com/charset=utf-7">*。^([[141](pr03.html#ftn.CHP-4-FT-6)])
- en: Hyperlinking and Content Inclusion
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超链接和内容包含
- en: One of the most important and security-relevant features of HTML is, predictably,
    the ability to link to and embed external content. HTTP-level features such as
    *Location* and *Refresh* aside, this can be accomplished in a couple of straightforward
    ways.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: HTML最重要的和与安全相关的特性之一，不出所料，是链接到和嵌入外部内容的能力。除了HTTP级别的功能（如 *Location* 和 *Refresh*）之外，这可以通过几种简单的方式实现。
- en: Plain Links
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平常链接
- en: 'The following markup demonstrates the most familiar and most basic method for
    referencing external content from within a document:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记示例展示了在文档内引用外部内容最熟悉和最基本的方法：
- en: '[PRE48]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This hyperlink may point to any of the browser-recognized schemes, including
    pseudo-URLs (*data:*, *javascript:*, and so on) and protocols handled by external
    applications (such as *mailto:*). Clicking on the text (or any HTML elements)
    nested inside such a *<a href=...>* block will typically prompt the browser to
    navigate away from the linking document and go to the specified location, if meaningfully
    possible for the protocol used.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 此超链接可能指向浏览器识别的任何方案，包括伪URL（如 *data:*、*javascript:* 等）以及由外部应用程序（如 *mailto:*）处理的协议。点击嵌套在
    *<a href=...>* 块内的文本（或任何HTML元素）通常会导致浏览器从链接文档导航离开，并前往指定的位置，如果该协议有意义的话。
- en: An optional *target* parameter may be used to target other windows or document
    views for navigation. The parameter must specify the name of the target view.
    If the name cannot be found, or if access is denied, the default behavior is typically
    to open a new window instead. The conditions in which access may be denied are
    the topic of [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules").
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用可选的 *target* 参数来针对其他窗口或文档视图进行导航。该参数必须指定目标视图的名称。如果找不到该名称，或者访问被拒绝，通常的默认行为是打开一个新窗口。可能被拒绝访问的条件是[第11章](ch11.html
    "第11章。同源规则之外的生活")的主题。
- en: 'Four special target names can be used, too (as shown on the left of [Figure 4-1](ch04s05.html#predefined_targets_for_hyperlinks
    "Figure 4-1. Predefined targets for hyperlinks")): *_blank* always opens a brand-new
    window, *_parent* navigates a higher-level view that embeds the link-bearing document
    (if any), and *_top* always navigates the top-level browser window, no matter
    how many document embedding levels are in between. Oh, right, the fourth special
    target, *_self*, is identical to not specifying a value at all and exists for
    no reason whatsoever.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用四个特殊的目标名称（如图4-1左侧所示）：*_blank* 总是打开一个全新的窗口，*_parent* 导航到一个包含链接文档的更高层级视图（如果有的话），而
    *_top* 总是导航到顶级浏览器窗口，无论中间有多少文档嵌入层级。对了，第四个特殊目标，*_self*，与不指定任何值相同，且没有任何原因存在。
- en: '![Predefined targets for hyperlinks](httpatomoreillycomsourcenostarchimages950013.png.jpg)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
  zh: '![预定义的超链接目标](httpatomoreillycomsourcenostarchimages950013.png.jpg)'
- en: Figure 4-1. Predefined targets for hyperlinks
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 预定义的超链接目标
- en: Forms and Form-Triggered Requests
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单和表单触发的请求
- en: 'An HTML form can be thought of as an information-gathering hyperlink: When
    the “submit” button is clicked, a dynamic request is constructed on the fly from
    the data collected via any number of input fields. Forms allow user input and
    files to be uploaded to the server, but in almost every other way, the result
    of submitting a form is similar to following a normal link.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将HTML表单视为一个信息收集的超链接：当点击“提交”按钮时，会动态地从任何数量的输入字段收集数据，即时构建一个动态请求。表单允许用户输入和文件上传到服务器，但在几乎所有其他方面，提交表单的结果与跟随正常链接相似。
- en: 'A simple form markup may look like this:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的表单标记可能看起来像这样：
- en: '[PRE49]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The *action* parameter works like the *href* value used for normal links, with
    one minor difference: If the value is absent, the form will be submitted to the
    location of the current document, whereas any destination-free *<a>* links will
    simply not work at all. An optional *target* parameter may also be specified and
    will behave as outlined in the previous section.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '*action* 参数的工作方式与用于正常链接的 *href* 值类似，只有一个细微的差别：如果值不存在，表单将被提交到当前文档的位置，而任何无目标
    *<a>* 链接将根本无法工作。还可以指定一个可选的 *target* 参数，其行为将在上一节中概述。'
- en: Note
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unusually, unlike *<a>* tags, forms cannot be nested inside each other, and
    only the top-level *<form>* tag will remain operational in such a case.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 不寻常的是，与 *<a>* 标签不同，表单不能嵌套在彼此内部，在这种情况下，只有顶级 *<form>* 标签将保持可用。
- en: When the *method* value is set to GET or is simply not present at all, all the
    nested field names and their current values will be escaped using the familiar
    percent-encoding scheme outlined in [Chapter 2](ch02.html "Chapter 2. It Starts
    with a URL"), but with two rather arbitrary differences. First, the space character
    (0x20) will be substituted with the plus sign, rather than encoded as “%20”. Second,
    following from this, any existing plus signs need to be encoded as “%2B”, or else
    they will be misinterpreted as spaces.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *method* 值设置为 GET 或根本不存在时，所有嵌套的字段名称及其当前值都将使用在[第2章](ch02.html "第2章。从URL开始")中概述的熟悉百分编码方案进行转义，但有两大相当任意的差异。首先，空格字符（0x20）将被加号替换，而不是编码为“%20”。其次，由此产生的任何现有加号都需要编码为“%2B”，否则它们将被错误地解释为空格。
- en: 'Encoded *name=value* pairs are then delimited with ampersands and combined
    into a single string, such as this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的 *name=value* 对然后用 ampersands 分隔，并合并成一个字符串，例如：
- en: '[PRE50]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The resulting value is inserted into the query part of the destination URL (replacing
    any existing contents of that section) and submitted to the server. The received
    response is then shown to the user in the targeted viewport.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 结果值被插入到目标URL的查询部分（替换该部分的任何现有内容）并提交给服务器。然后，接收到的响应将在目标视口中显示给用户。
- en: The situation is a bit more complicated if the *method* parameter is set to
    POST. For that type of HTTP request, three data submission formats are available.
    In the default mode (referred to as *application/x-www-form-urlencoded*), the
    message is constructed the same way as for GET but is transmitted in the request
    payload instead, leaving the query string and all other parts of the destination
    URL intact.^([[27](#ftn.CHP-4-FN-3)])
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 *method* 参数设置为 POST，情况会稍微复杂一些。对于这种类型的HTTP请求，有三种数据提交格式可用。在默认模式（称为 *application/x-www-form-urlencoded*）下，消息的构建方式与GET相同，但它在请求有效载荷中传输，从而保留查询字符串和目标URL的所有其他部分.^([[27](#ftn.CHP-4-FN-3)])
- en: 'The existence of the second POST submission mode, triggered by specifying *enctype="text/plain"*
    on the *<form>* tag, is difficult to justify. In this mode, field names and values
    will not be percent encoded at all (but, depending on the browser, plus signs
    may be used to substitute for spaces), and a newline delimiter will be used in
    place of an ampersand. The resulting format is essentially useless, as it can’t
    be parsed unambiguously: Form-originating newlines and equal signs are indistinguishable
    from browser inserted ones.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种 POST 提交模式的存在，由在 *<form>* 标签上指定 *enctype="text/plain"* 触发，很难证明其合理性。在此模式下，字段名称和值将根本不进行百分编码（但，取决于浏览器，可能使用加号来代替空格），并且将使用换行符代替和号。生成的格式基本上是无用的，因为它无法被明确解析：来自表单的新行和等号与浏览器插入的无法区分。
- en: 'The last mode is triggered with *enctype="multipart/form-data"* and must be
    used whenever submitting user-selected files through a form (which is possible
    with a special *<input type="file">* tag). The resulting request body consists
    of a series of short MIME messages corresponding to every submitted field.^([[28](#ftn.CHP-4-FN-4)])
    These messages are delimited with a client-selected random, unique boundary token
    that should otherwise not appear in the encapsulated data:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种模式由 *enctype="multipart/form-data"* 触发，并且必须在通过表单提交用户选择的文件时使用（这可以通过特殊的 *<input
    type="file">* 标签实现）。生成的请求体由一系列短 MIME 消息组成，对应于每个提交的字段.^([[28](#ftn.CHP-4-FN-4)])
    这些消息由客户端选择的随机、唯一的边界标记分隔，该标记在其他情况下不应出现在封装的数据中：
- en: '[PRE51]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Despite the seemingly open-ended syntax of the tag, other request methods and
    submission formats are not supported by any browser, and this is unlikely to change.
    For a short while, the HTML5 standard tried to introduce PUT and DELETE methods
    in forms, but this proposal was quickly shot down.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该标签的语法看似开放，但任何浏览器都不支持其他请求方法或提交格式，并且这种情况不太可能改变。HTML5 标准曾试图在表单中引入 PUT 和 DELETE
    方法，但这个提议很快就被否决了。
- en: Frames
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: 'Frames are a form of markup that allows the contents of one HTML document to
    be displayed in a rectangular region of another, embedding page. Several framing
    tags are supported by modern browsers, but the most common way of achieving this
    goal is with a hassle-free and flexible inline frame:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 框架是一种标记形式，允许一个 HTML 文档的内容在另一个嵌入页面的矩形区域内显示。现代浏览器支持几种框架标签，但实现这一目标最常见的方式是使用无需麻烦且灵活的内联框架：
- en: '[PRE52]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In traditional HTML documents, this tag puts the parser in one of the special
    parsing modes, and all text between the opening and the closing tag will simply
    be ignored in frame-aware browsers. In legacy browsers that do not understand
    *<iframe>*, the markup between the opening and closing tags is processed normally,
    however, offering a decidedly low-budget, conditional rendering directive. This
    conditional behavior is commonly used to provide insightful advice such as “This
    page must be viewed in a browser that supports frames.”
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 HTML 文档中，此标签将解析器置于一种特殊的解析模式，并且所有在开始和结束标签之间的文本在框架感知浏览器中都将被简单地忽略。在不支持 *<iframe>*
    的旧浏览器中，开始和结束标签之间的标记将被正常处理，然而，提供了一种明确低成本的条件渲染指令。这种条件行为通常用于提供有洞察力的建议，例如“此页面必须在支持框架的浏览器中查看。”
- en: The frame is a completely separate document view that in many aspects is identical
    to a new browser window. (It even enjoys its own JavaScript execution context.)
    Like browser windows, frames can be equipped with a *name* parameter and then
    targeted from *<a>* and *<form>* tags.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 框架是一个完全独立的文档视图，在许多方面与新的浏览器窗口相同。（它甚至拥有自己的 JavaScript 执行上下文。）像浏览器窗口一样，框架可以配备一个
    *name* 参数，然后可以从 *<a>* 和 *<form>* 标签中定位。
- en: 'The constraints on the *src* URL for framed content are roughly similar to
    the rules enforced on regular links. This includes the ability to point frames
    to javascript: or to load externally handled protocols that leave the frame empty
    and open the target application in a new process.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 对于框架内容的 *src* URL 的限制大致类似于对常规链接实施的规则。这包括将框架指向 `javascript:` 或加载外部处理的协议，这些协议会留空框架并在新进程中打开目标应用程序。
- en: Frames are of special interest to web security, as they allow almost unconstrained
    types of content originating from unrelated websites to be combined onto a single
    page. We will have a second look at the problems associated with this behavior
    in [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules").
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 框架对网络安全性特别感兴趣，因为它们允许几乎不受限制的类型的内容从无关网站组合到单个页面上。我们将在[第11章](ch11.html "第11章。同源规则之外的生活")中再次审视与此行为相关的问题。
- en: Type-Specific Content Inclusion
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型特定的内容包含
- en: In addition to content-agnostic link navigation and document framing, HTML also
    provides multiple ways for a more lightweight inclusion of several predefined
    types of external content.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内容无关的链接导航和文档框架之外，HTML还提供了多种方法以更轻量级的方式包含几种预定义类型的外部内容。
- en: '**Images**'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像**'
- en: Image files can be retrieved and displayed on a page using *<img>* tags, via
    stylesheets, and through a legacy *background=* parameter on markup such as *<body>*
    or *<table>*.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`<img>`标签、通过样式表以及通过诸如`<body>`或`<table>`等标记的遗留`background=`参数来检索和显示页面上的图像文件。
- en: The most popular image type on the Internet is a lossy but very efficient JPEG
    file, followed by lossless and more featured (but slower) PNG. An increasingly
    obsolete lossless GIF format is also supported by every browser, and so is the
    rarely encountered and usually uncompressed Windows bitmap file (BMP). An increasing
    number of rendering engines support SVG, an XML-based vector graphics and animation
    format, too, but the inclusion of such images through the *<img>* tag is subject
    to additional restrictions.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上最受欢迎的图像类型是损失但非常高效的JPEG文件，其次是无损且功能更丰富（但速度较慢）的PNG。一个日益过时的无损GIF格式也受到每个浏览器的支持，同样，很少遇到的通常未压缩的Windows位图文件（BMP）也得到支持。越来越多的渲染引擎支持SVG，这是一个基于XML的矢量图形和动画格式，但通过`<img>`标签包含此类图像受到额外的限制。
- en: The list of recognized image types can be wrapped up with odds and ends such
    as Windows metafiles (WMF and EMF), Windows Media Photo (WDP and HDP), Windows
    icons (ICO), animated PNG (APNG), TIFF images, and—more recently—WebP. Browser
    support for these is far from universal, however.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将已识别的图像类型列表总结为一些零散的项目，如Windows元文件（WMF和EMF）、Windows媒体照片（WDP和HDP）、Windows图标（ICO）、动画PNG（APNG）、TIFF图像，以及最近出现的WebP。然而，浏览器对这些格式的支持远非普遍。
- en: '**Cascading stylesheets**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**层叠样式表**'
- en: These text-based files can be loaded with a *<link rel=stylesheet href=...>*
    tag—even though *<style src=...>* would be a more intuitive choice—and may redefine
    the visual aspects of almost any other HTML tag within their parent document (and
    in some cases, even include embedded JavaScript). The syntax and function of CSS
    are the subject of [Chapter 5](ch05.html "Chapter 5. Cascading Style Sheets").
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基于文本的文件可以用`<link rel=stylesheet href=...>`标签加载——尽管`<style src=...>`可能是一个更直观的选择——并且可以重新定义其父文档中几乎所有其他HTML标签的视觉方面（在某些情况下，甚至可以包含嵌入的JavaScript）。CSS的语法和功能是[第5章](ch05.html
    "第5章。层叠样式表")的主题。
- en: In the absence of the appropriate *charset* value in the *Content-Type* header
    for the downloaded stylesheet, the encoding according to which this subresource
    will be interpreted can be specified by the including party through the *charset*
    parameter of the *<link>* tag.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下载的样式表的`Content-Type`头中没有适当的`charset`值，包含方可以通过`<link>`标签的`charset`参数指定此子资源的解释编码。
- en: '**Scripts**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本**'
- en: Scripts are text-based programs included with *<script>* tags and are executed
    in a manner that gives them full control over the host document. The primary scripting
    language for the Web is JavaScript, although an embedded version of Visual Basic
    is also supported in Internet Explorer and can be used at will. [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts") takes an in-depth look at client-side scripts
    and their capabilities.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是包含在`<script>`标签中的基于文本的程序，并以一种赋予它们对宿主文档完全控制的方式执行。网络的主要脚本语言是JavaScript，尽管在Internet
    Explorer中也支持嵌入的Visual Basic版本，并且可以随意使用。[第6章](ch06.html "第6章。浏览器端脚本")深入探讨了客户端脚本及其功能。
- en: As with CSS, in the absence of valid *Content-Type* data, the charset according
    to which the script is interpreted may be controlled by the including party.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS一样，在没有有效的`Content-Type`数据的情况下，脚本解释所依据的字符集可能由包含方控制。
- en: '**Plug-in content**'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**插件内容**'
- en: This category spans miscellaneous binary files included with *<embed>* or *<object>*
    tags or via an obsolete, Java-specific *<applet>* tag. Browser plug-in content
    follows its own security rules, which are explored to some extent in [Chapter 8](ch08.html
    "Chapter 8. Content Rendering with Browser Plug-ins") and [Chapter 9](ch09.html
    "Chapter 9. Content Isolation Logic"). In many cases, it is safe to consider plug-in-supported
    content as equivalent to or more powerful than JavaScript.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别涵盖了与 *<embed>* 或 *<object>* 标签一起包含的或通过过时的、Java 特定的 *<applet>* 标签包含的各类二进制文件。浏览器插件内容遵循其自身的安全规则，这在
    [第 8 章](ch08.html "第 8 章。使用浏览器插件进行内容渲染") 和 [第 9 章](ch09.html "第 9 章。内容隔离逻辑") 中有所探讨。在许多情况下，可以将插件支持的内容视为等同于或比
    JavaScript 更强大。
- en: Note
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The standard permits certain types of browser-supported documents, such as *text/html*
    or *text/plain*, to be loaded through *<object>* tags, in which case they form
    a close equivalent of *<iframe>*. This functionality is not used in practice,
    and the rationale behind it is difficult to grasp.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 标准允许某些类型的浏览器支持的文档，如 *text/html* 或 *text/plain*，通过 *<object>* 标签加载，在这种情况下，它们与
    *<iframe>* 形成紧密的等价物。这种功能在实际中并未使用，其背后的理由也难以理解。
- en: '**Other supplementary content**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他补充内容**'
- en: This category includes various rendering cues that may or may not be honored
    by the browser; they are most commonly provided through *<link>* directives. Examples
    include website icons (known as “favicons”), alternative versions of a page, and
    chapter navigation links.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别包括各种可能或可能不被浏览器尊重的渲染提示；它们最常见的是通过 *<link>* 指令提供的。例如包括网站图标（称为“favicons”）、页面的替代版本和章节导航链接。
- en: Several other once-supported content inclusion methods, such as the *<bgsound>*
    tag for background music, were commonplace in the past but have fallen out of
    grace. On the other hand, as a part of HTML5, new tags such as *<video>* and *<audio>*
    are expected to gain popularity soon.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 一些曾经支持的内容包含方法，如用于背景音乐的 *<bgsound>* 标签，在过去很常见，但现在已经不再受欢迎。另一方面，作为 HTML5 的一部分，新的标签如
    *<video>* 和 *<audio>* 预计很快会流行起来。
- en: There is relatively little consistency in what URL schemes are accepted for
    type-specific content retrieval. It should be expected that protocols routed to
    external applications will be rejected, as they do not have a sensible meaning
    in this context, but beyond this, not many assumptions should be made. As a security
    precaution, most browsers will also reject scripting-related schemes when loading
    images and stylesheets, although Internet Explorer 6 and Opera do not follow this
    practice. As of this writing, *javascript:* URLs are also permitted on *<embed>*
    and *<applet>* tags in Firefox but not, for example, on *<img>*.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在接受类型特定的内容检索的 URL 方案方面，相对一致性较少。应该预期，路由到外部应用程序的协议将被拒绝，因为在这个上下文中它们没有合理的意义，但除此之外，不应做出太多假设。作为安全预防措施，大多数浏览器在加载图像和样式表时也会拒绝与脚本相关的方案，尽管
    Internet Explorer 6 和 Opera 不遵循这一做法。截至本文撰写时，*javascript:* URL 在 Firefox 中的 *<embed>*
    和 *<applet>* 标签上也是允许的，但例如在 *<img>* 标签上则不允许。
- en: For almost all of the type-specific content inclusion methods, *Content-Type*
    and *Content-Disposition* headers provided by the server will typically be ignored
    (perhaps except for the *charset=* value), as may be the HTTP response code itself.
    It is best to assume that whenever the body of any server-provided resource is
    even vaguely recognizable as one of the data formats enumerated in this section,
    it may be interpreted as such.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有类型特定的内容包含方法，服务器提供的 *Content-Type* 和 *Content-Disposition* 头部信息通常会被忽略（或许除了
    *charset=* 值之外），HTTP 响应码本身也可能如此。最好假设，当任何服务器提供的资源内容被模糊地识别为该节中列举的数据格式之一时，它可能被解释为该格式。
- en: A Note on Cross-Site Request Forgery
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于跨站请求伪造的说明
- en: On all types of cross-domain navigation, the browser will transparently include
    any ambient credentials; consequently, to the server, a request legitimately originating
    from its own client-side code will appear roughly the same as a request originating
    from a rogue third-party site, and it may be granted the same privileges.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有类型的跨域导航中，浏览器将透明地包含任何环境凭证；因此，对于服务器来说，一个合法源自其客户端代码的请求将大致与源自恶意第三方网站的请求相同，并且可能会被赋予相同的权限。
- en: Applications that fail to account for this possibility when processing any sensitive,
    state-changing requests are said to be vulnerable to *cross-site request forgery*
    (*XSRF* or *CSRF*). This vulnerability can be mitigated in a number of ways, the
    most common of which is to include a secret user- and session-specific value on
    such requests (as an additional query parameter or a hidden form field). The attacker
    will not be able to obtain this value, as read access to cross-domain documents
    is restricted by the same-origin policy (see [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic")).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何敏感的、状态改变请求时未能考虑到这种可能性的应用程序被认为容易受到*跨站请求伪造*（*XSRF*或*CSRF*）的攻击。这种漏洞可以通过多种方式缓解，其中最常见的是在请求中包含一个秘密的用户和会话特定值（作为一个额外的查询参数或隐藏表单字段）。攻击者将无法获取此值，因为跨域文档的读取访问受到同源策略的限制（参见[第9章](ch09.html
    "第9章。内容隔离逻辑")）。
- en: Security Engineering Cheat Sheet
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程备忘单
- en: Good Engineering Hygiene for All HTML Documents
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 所有HTML文档的良好工程卫生
- en: Always output consistent, valid, and browser-supported *Content-Type* and *charset*
    information to prevent the document from being interpreted contrary to your original
    intent.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是输出一致、有效且浏览器支持的*内容类型*和*字符集*信息，以防止文档被解释为与您的原始意图相反。
- en: When Generating HTML Documents with Attacker-Controlled Bits
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成带有攻击者控制部分的HTML文档时
- en: This task is difficult to perform consistently across the entire web application,
    and it is one of the most significant sources of web application security flaws.
    Consider using context-sensitive auto-escaping frameworks, such as *JSilver* or
    *CTemplate*, to automate it. If that is not possible, read on.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个Web应用程序中一致地执行此任务很困难，这是Web应用程序安全漏洞的最重要来源之一。考虑使用上下文敏感的自动转义框架，如*JSilver*或*CTemplate*来自动化它。如果这不可能，请继续阅读。
- en: '**User-supplied content in text body:** Always entity-encode “<”, “>”, and
    “&”. Note that certain other patterns may be dangerous in certain non-ASCII-compatible
    output encodings. If applicable, consult [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms").'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本主体中的用户提供的内联内容：**始终对“<”，“>”，和“&”进行实体编码。请注意，某些其他模式在非ASCII兼容的输出编码中可能是危险的。如果适用，请参阅[第13章](ch13.html
    "第13章。内容识别机制")。'
- en: Keep in mind that some Unicode metacharacters (e.g., U+202E) alter the direction
    or flow of the subsequent text. It may be desirable to remove them in particularly
    sensitive uses.
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，某些Unicode元字符（例如，U+202E）会改变后续文本的方向或流程。在特别敏感的使用中，可能需要删除它们。
- en: '**Tag-specific** style **and** on* **parameters:** Multiple levels of escaping
    are required. This practice is extremely error prone, meaning not really something
    to attempt. If it is absolutely unavoidable, review the cheat sheets in [Chapter 5](ch05.html
    "Chapter 5. Cascading Style Sheets") and [Chapter 6](ch06.html "Chapter 6. Browser-Side
    Scripts").'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定标签的样式**和**参数：**需要多级转义。这种做法极其容易出错，意味着这不是一个真正值得尝试的事情。如果绝对不可避免，请查阅[第5章](ch05.html
    "第5章。层叠样式表")和[第6章](ch06.html "第6章。浏览器端脚本")中的备忘单。'
- en: '**All other HTML parameter values:** Always use quotes around attacker-controlled
    input. Entity-encode “<”, “>”, “&”, and any stray quotes. Remember that some parameters
    require additional validation. For URLs, see the cheat sheet in [Chapter 2](ch02.html
    "Chapter 2. It Starts with a URL").'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有其他HTML参数值：**始终在攻击者控制的输入周围使用引号。对“<”，“>”，“&”和任何多余的引号进行实体编码。请记住，某些参数需要额外的验证。对于URL，请参阅[第2章](ch02.html
    "第2章。从URL开始")中的备忘单。'
- en: Never attempt to blacklist known bad values in URLs or any other parameters;
    doing so will backfire and may lead to script execution flaws.
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 永远不要尝试在URL或任何其他参数中黑名单已知的不良值；这样做会适得其反，可能导致脚本执行漏洞。
- en: '**Special parsing modes (e.g.**, <script> **and** <style> **blocks):** For
    values appearing inside quoted strings, replace quote characters, backslash, “<”,
    “>”, and all nonprintable characters with language-appropriate escape codes. For
    values appearing outside strings, exercise extreme caution and allow only carefully
    validated, known, alphanumeric values.'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊解析模式（例如**，<script> **和** <style> **块）：**对于出现在引号字符串内的值，将引号字符、反斜杠、“<”，“>”和所有非打印字符替换为语言适当的转义代码。对于出现在字符串外的值，请采取极端谨慎的态度，并仅允许经过仔细验证的已知字母数字值。'
- en: In XHTML mode, remember to wrap the entire script section in a CDATA block.
    Avoid cases that require multiple levels of encoding, such as building parameters
    to the JavaScript *eval(...)* function using attacker-supplied strings. Never
    place user-controlled data inside HTML comments, !-type or ?-type tags, and other
    nonessential or unusually parsed blocks.
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在XHTML模式下，请记住将整个脚本部分包裹在CDATA块中。避免需要多级编码的情况，例如使用攻击者提供的字符串构建传递给JavaScript *eval(...)*
    函数的参数。永远不要将用户控制的数据放在HTML注释、!-type或?-type标签以及其他非必要或异常解析的块中。
- en: When Converting HTML to Plaintext
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当将HTML转换为纯文本时
- en: A common mistake is to strip only well-formed tags. Remember that all left-angle
    brackets must be removed, even if no matching right-angle bracket is found. To
    minimize the risk of errors, always entity-escape angle brackets and ampersands
    in the generated output, too.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个常见的错误是仅删除格式良好的标签。请记住，所有左尖括号都必须删除，即使找不到匹配的右尖括号。为了最大限度地减少错误的风险，在生成的输出中也总是对尖括号和和符号进行实体转义。
- en: When Writing a Markup Filter for User Content
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写用于用户内容的标记过滤器时
- en: Read this chapter carefully. Use a reasonably robust HTML parser to build an
    in-memory document tree. Walk the tree, removing any unrecognized or unnecessary
    tags and parameters and scrubbing any undesirable tags/parameters/value combinations.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细阅读本章。使用一个合理健壮的HTML解析器来构建内存中的文档树。遍历树，删除任何未识别或不必要的标签和参数，并清除任何不希望出现的标签/参数/值组合。
- en: When done, reserialize the document, making sure to apply proper escaping rules
    to parameter values and text content. (See the first tip on this cheat sheet.)
    Be aware of the impact of special parsing modes.
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，重新序列化文档，确保对参数值和文本内容应用适当的转义规则。（参见本备忘单上的第一个提示。）注意特殊解析模式的影响。
- en: Because of the somewhat counterintuitive namespace interactions with JavaScript,
    do not allow *name* and *id* parameters on user-supplied markup—at least not without
    reading [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts") first.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于与JavaScript的命名空间交互有些反直觉，不允许在用户提供的标记中使用 *name* 和 *id* 参数——至少在未首先阅读[第6章](ch06.html
    "第6章。浏览器端脚本")之前不要这样做。
- en: Do not attempt to sanitize an existing, serialized document in place. Doing
    so inevitably leads to security problems.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要尝试就地清理现有的、序列化的文档。这样做不可避免地会导致安全问题。
- en: '* * *'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[27](#CHP-4-FN-3)]) This has the potential for confusion, as the same parameter
    may appear both in the query string and in the POST payload. There is no consistency
    in how various server-side web applications frameworks resolve this conflict.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#CHP-4-FN-3)]) 这可能导致混淆，因为相同的参数可能同时出现在查询字符串和POST有效负载中。各种服务器端Web应用程序框架解决这种冲突的方式并不一致。
- en: ^([[28](#CHP-4-FN-4)]) MIME (Multipurpose Internet Mail Extensions) is a data
    format intended for encapsulating and safely transmitting various types of documents
    in email messages. The format makes several unexpected appearances in the browser
    world. For example, *Content-Type* file format identifiers also have unambiguous
    MIME roots.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#CHP-4-FN-4)]) MIME（多用途互联网邮件扩展）是一种数据格式，旨在封装和通过电子邮件消息安全地传输各种类型的文档。该格式在浏览器世界中出现了几次意想不到的情况。例如，*Content-Type*
    文件格式标识符也有明确的MIME根。
- en: Chapter 5. Cascading Style Sheets
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。层叠样式表
- en: As the Web matured through the 1990s, website developers increasingly needed
    a consistent and flexible way to control the appearance of HTML documents; the
    collection of random, vendor-specific tag parameters available at the time simply
    would not do. After reviewing several competing proposals, W3C eventually settled
    on *Cascading Style Sheets (CSS)*, a fairly simple text-based page appearance
    description language proposed by Håkon Wium Lie.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web在20世纪90年代的发展，网站开发者越来越需要一个一致且灵活的方式来控制HTML文档的外观；当时可用的随机、供应商特定的标签参数集合根本无法满足需求。在审查了几个竞争性提案后，W3C最终决定采用*层叠样式表（CSS）*，这是一种由Håkon
    Wium Lie提出的相当简单的基于文本的页面外观描述语言。
- en: The initial CSS level 1 specification saw the light of day by the end of 1996,^([[142](pr03.html#ftn.CHP-5-FT-1)])
    but further revisions of this document continued until 2008\. The initial draft
    of CSS level 2 followed in December 1998 and has yet to be finalized as of 2011\.
    The work on the most recent iteration, level 3, started in 2005 and also continues
    to this day. Although most of the individual features envisioned for CSS2 and
    CSS3 have been adopted by all modern browsers after years of trial and error,
    many subtle details vary significantly from one implementation to another, and
    the absence of a finalized standard likely contributes to this.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 1.0 的初始规范于 1996 年底问世，^([[142](pr03.html#ftn.CHP-5-FT-1)]) 但对该文档的进一步修订一直持续到
    2008 年。CSS 2.0 的初始草案于 1998 年 12 月发布，截至 2011 年仍未最终确定。对最新版本，即 3.0 版本的研发始于 2005 年，并且至今仍在继续。尽管经过多年的试验和错误，CSS2
    和 CSS3 所设想的大部分单个功能都已由所有现代浏览器采用，但许多细微的细节在不同实现之间差异很大，而缺乏一个最终标准可能正是导致这种情况的原因。
- en: Despite the differences from one browser to another, CSS is a very powerful
    tool. With only a couple of constraints, stylesheets permit almost every HTML
    tag to be scaled, positioned, and decorated nearly arbitrarily, thereby overcoming
    the constraints originally placed on it by the underlying markup language; in
    some implementations, JavaScript programs can be embedded in the CSS presentation
    directives as well. The job of placing user-controlled values inside stylesheets,
    or recoding any externally provided CSS, is therefore of great interest to web
    application security.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不同浏览器之间存在差异，CSS 仍然是一个非常强大的工具。仅通过几个限制，样式表允许几乎任意地缩放、定位和装饰几乎每一个 HTML 标签，从而克服了底层标记语言最初对其施加的限制；在某些实现中，JavaScript
    程序还可以嵌入到 CSS 展示指令中。因此，将用户控制的值放置在样式表中，或重新编码任何外部提供的 CSS，对网络应用安全来说具有极大的兴趣。
- en: Basic CSS Syntax
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本CSS语法
- en: 'Stylesheets can be placed in an HTML document in three ways: inlined globally
    for the entire document with a *<style>* block, retrieved from an external URL
    via the *<link rel=stylesheet>* directive, or attached to a specific tag using
    the *style* parameter. In addition, XML-based documents (including XHTML) may
    also leverage a little-known *<?xml-stylesheet href=... ?>* directive to achieve
    the same goal.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表可以通过三种方式放置在 HTML 文档中：通过 *<style>* 块内联全局应用于整个文档，通过 *<link rel=stylesheet>*
    指令从外部 URL 获取，或者使用 *style* 参数附加到特定的标签。此外，基于 XML 的文档（包括 XHTML）还可以利用一个鲜为人知的 *<?xml-stylesheet
    href=... ?>* 指令来实现相同的目标。
- en: 'The first two methods of inclusion require a fully qualified stylesheet consisting
    of any number of selectors (directives describing which HTML tags the following
    ruleset will apply to) followed by semicolon-delimited *name: value* rules between
    curly brackets. Here is a simple example of such syntax, defining the appearance
    of *<img>*, *<span>*, and *<div>* tags:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '包含的前两种方法需要包含任何数量的选择器（描述以下规则集将应用于哪些 HTML 标签的指令）的完全合格的样式表，后跟花括号内分号分隔的 *name:
    value* 规则。以下是一个此类语法的简单示例，定义了 *<img>*、*<span>* 和 *<div>* 标签的外观：'
- en: '[PRE53]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Selectors can reference a particular type of a tag (such as *img*), a period-prefixed
    name of a class of tags (for example, *.photos*, which will apply to all tags
    with an inline *class=photos* parameter), or a combination of both (*img.company_logo*).
    Selector suffixes such as *:hover* or *:visited* may also be used to make the
    selector match only under certain circumstances, such as when the mouse hovers
    over the content or when a particular displayed hyperlink has already been visited
    before.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器可以引用特定类型的标签（如 *img*），以点前缀命名的标签类名（例如，*.photos*，它将应用于所有具有内联 *class=photos*
    参数的标签），或者两者的组合（*img.company_logo*）。类似于 *:hover* 或 *:visited* 的选择器后缀也可以用来使选择器仅在特定情况下匹配，例如当鼠标悬停在内容上，或者当特定的显示超链接已经被访问过之前。
- en: 'So-called *complex selectors*^([[143](pr03.html#ftn.CHP-5-FT-2)]) are an interesting
    feature introduced in CSS2 and extended in CSS3\. They allow any given ruleset
    to apply only to tags with particular strings appearing in parameter values or
    that are positioned in a particular relation to other markup. One example of such
    a selector is this:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 所说的 *复杂选择器*^([[143](pr03.html#ftn.CHP-5-FT-2)]) 是 CSS2 中引入的一个有趣特性，并在 CSS3 中得到扩展。它们允许给定的规则集仅应用于参数值中包含特定字符串的标签，或者位于其他标记的特定关系中的标签。这样一个选择器的例子如下：
- en: '[PRE54]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Oh, while we are at it: As evident in this example, C-style *`/*...*/`* comment
    blocks are permitted in CSS syntax anywhere outside a quoted string. On the flip
    side, *`//`*-style comments are not recognized at all.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，顺便说一下：正如这个例子所示，C 样式的 *`/*...*/`* 注释块可以在 CSS 语法中任何非引号字符串之外的地方使用。另一方面，*`//`*-样式的注释则完全不识别。
- en: Property Definitions
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性定义
- en: 'Inside the *{ ... }* block that follows a selector, as well as inside the *style*
    parameter attached to a specific tag, any number of *name: value* rules can be
    used to redefine almost every aspect of how the affected markup is displayed.
    Visibility, shape, color, screen position, rendering order, local or remote typeface,
    and even any additional text (*content* property supported on certain pseudo-classes)
    and mouse cursor shape are all up for grabs.^([[29](#ftn.CHP-5-FN-1)]) Simple
    types of automation, such as counters for numbered lists, are available through
    CSS rules as well.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '在跟随选择器的 *{ ... }* 块内部，以及附加到特定标签的 *style* 参数内部，可以使用任意数量的 *name: value* 规则来重新定义受影响标记的显示的几乎所有方面。可见性、形状、颜色、屏幕位置、渲染顺序、本地或远程字体，甚至任何附加文本（某些伪类支持的内容属性）和鼠标光标形状都可以重新定义。此外，通过
    CSS 规则还可以提供简单的自动化类型，例如编号列表的计数器。^([[29](#ftn.CHP-5-FN-1)])'
- en: 'Property values can be formatted as the following:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值可以格式化为以下形式：
- en: '**Raw text** This method is used chiefly to specify numerical values (with
    optional units), RGB vectors and named colors, and other predefined keywords (“absolute,”
    “left,” “center,” etc.).'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始文本** 此方法主要用于指定数值（可选单位）、RGB 向量和命名颜色，以及其他预定义的关键字（“绝对”、“左”、“中心”等）。'
- en: '**Quoted strings** Single or double quotes should be placed around any nonkeyword
    values, but there is little consistency in how this rule is enforced. For example,
    quoting is not required around typeface names or certain uses of URLs, but it
    is necessary for the aforementioned *content* property.'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引号字符串** 应该将任何非关键字值放在单引号或双引号内，但如何执行此规则并不一致。例如，字体名称或某些 URL 的使用不需要引号，但对于前面提到的
    *content* 属性则是必需的。'
- en: '**Functional notation** Two parameter-related pseudo-functions are mentioned
    in the original CSS specification: *rgb(...)*, for converting individual RGB color
    values into a single color code, and *url(...)*, required for URLs in most but
    not all contexts. On top of this, several more pseudo-functions have been rolled
    out in recent years, including *scale(...)*, *rotate(...)*, or *skew(...)*.'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数表示法** 原始 CSS 规范中提到了两个与参数相关的伪函数：*rgb(...)*，用于将单个 RGB 颜色值转换为单个颜色代码，以及 *url(...)*，在大多数但不是所有上下文中都是必需的。除此之外，近年来还推出了几个更多的伪函数，包括
    *scale(...)*、*rotate(...)* 或 *skew(...)*。'
- en: A proprietary *expression(...)* function is also available in Internet Explorer;
    it permits JavaScript statements to be inserted within CSS. This function is one
    of the most important reasons why attacker-controlled stylesheets can be a grave
    security risk.
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Internet Explorer 中也提供了一个专有的 *expression(...)* 函数；它允许在 CSS 中插入 JavaScript
    语句。这个函数是攻击者控制的样式表可能构成严重安全风险的最重要原因之一。
- en: '@ Directives and XBL Bindings'
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@ 指令和 XBL 绑定'
- en: In addition to selectors and properties, several @-prefixed directives are recognized
    in stand-alone stylesheets. All of them modify the meaning of the stylesheet;
    for example, by specifying the namespace or the display media that the stylesheet
    should be applied to. But two special directives also affect the behavior of the
    parsing process. The first of these is *@charset*, which sets the charset of the
    current CSS block; the other is *@import*, which inserts an external file into
    the stylesheet.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择器和属性之外，在独立样式表中还识别了几个以 @- 前缀的指令。所有这些指令都会修改样式表的意义；例如，通过指定样式表应该应用到的命名空间或显示媒体。但有两个特殊的指令也会影响解析过程的行为。第一个是
    *@charset*，它设置当前 CSS 块的字符集；另一个是 *@import*，它将外部文件插入到样式表中。
- en: 'The *@import* directive itself serves as a good example of the idiosyncrasies
    of CSS parsing; the parser views all of the following examples as equivalent:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '*@import* 指令本身是 CSS 解析特性的一个很好的例子；解析器认为以下所有示例都是等效的：'
- en: '[PRE55]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In Firefox, external content directives, including JavaScript code, may be also
    loaded from an external source using the *-moz-binding* property, a vendor-specific
    way to weave XML Binding Language^([[144](pr03.html#ftn.CHP-5-FT-3)]) files (an
    obscure method of providing automation to XML content) into the document. There
    is some talk of supporting XBL in other browsers, too, at which point the name
    of the property would change and the XSS risk may or may not be addressed in some
    way.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中，外部内容指令，包括JavaScript代码，也可以通过使用*-moz-binding*属性从外部源加载，这是一种特定于供应商的方法，用于将XML绑定语言^([[144](pr03.html#ftn.CHP-5-FT-3)])文件（一种提供XML内容自动化的晦涩方法）编织到文档中。关于在其他浏览器中也支持XBL的讨论，此时属性的名称将改变，XSS风险可能以某种方式得到解决，也可能没有得到解决。
- en: Note
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As can be expected, the handling of pseudo-URLs in *@import, url(...)* and other
    CSS-based content inclusion schemes is a potential security risk. While most current
    browsers do not accept scripting-related schemes in these contexts, Internet Explorer
    6 allows them without reservations, thereby creating a code injection vector if
    the URL is not validated carefully enough.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，处理伪URLs在@import、url(...)*和其他基于CSS的内容包含方案中是一个潜在的安全风险。虽然大多数当前浏览器在这些上下文中不接受与脚本相关的方案，但Internet
    Explorer 6允许它们而不加限制，如果URL没有经过足够的验证，就会创建一个代码注入向量。
- en: Interactions with HTML
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与HTML的交互
- en: 'It follows from the discussion in the previous chapter that for any stylesheets
    inlined in HTML documents, HTML parsing is performed first and is completely independent
    of CSS syntax rules. Therefore, it is unsafe to place certain HTML syntax characters
    inside CSS properties, as in the following example, even when quoted properly.
    A common mistake is permitting this:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章的讨论可以得出，对于任何内联在HTML文档中的样式表，HTML解析首先执行，并且完全独立于CSS语法规则。因此，在CSS属性中放置某些HTML语法字符是不安全的，如下例所示，即使正确地引用了它们。一个常见的错误是允许这样做：
- en: '[PRE56]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We’ll discuss a way to encode problematic characters in stylesheets shortly,
    but first, let’s have a quick look at another very distinctive property of CSS.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论在样式表中编码问题字符的方法，但首先，让我们快速看一下CSS的另一个非常独特的属性。
- en: '* * *'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[29](#CHP-5-FN-1)]) The ability to redefine mouse cursors using an arbitrary
    bitmap has predictably resulted in some security bugs. An oversized cursor combined
    with script-based mouse position tracking could be used to obscure or replace
    important elements of the browser UI and trick the user into doing something dangerous.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#CHP-5-FN-1)]) 使用任意位图重新定义鼠标光标的做法，如预期的那样，导致了一些安全漏洞。一个过大的光标结合基于脚本的鼠标位置跟踪，可能被用来隐藏或替换浏览器UI中的重要元素，并诱使用户执行危险的操作。
- en: Parser Resynchronization Risks
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器重新同步风险
- en: 'An undoubtedly HTML-inspired behavior that sets CSS apart from most other languages
    is that compliant parsers are expected to continue after encountering a syntax
    error and restart at the next matching curly bracket (some superficial nesting-level
    tracking is mandated by the spec). In particular, the following stylesheet snippet,
    despite being obviously malformed, will still apply the specified border style
    to all *<img>* tags:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 一种无疑受到HTML启发的行为，使CSS与大多数其他语言区分开来，是符合规范的解析器在遇到语法错误后应继续执行，并在下一个匹配的大括号处重新启动（规范要求进行一些表面上的嵌套级别跟踪）。特别是，以下样式表片段，尽管显然格式不正确，但仍将指定的边框样式应用于所有*<img>*标签：
- en: '[PRE57]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This unusual behavior creates an opportunity to exploit parser incompatibilities
    in an interesting way: If there is any way to derail a particular CSS implementation
    with inputs that seem valid to other parsers, the resynchronization logic may
    cause the attacked browser to resume parsing at an incorrect location, such as
    in the middle of an attacker-supplied string.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不寻常的行为为以有趣的方式利用解析器不兼容性提供了机会：如果存在任何方法可以通过对其他解析器看似有效但特定CSS实现无效的输入来使CSS实现脱轨，那么重新同步逻辑可能会导致被攻击的浏览器在错误的位置恢复解析，例如在攻击者提供的字符串中间。
- en: 'A naïve illustration of this issue may be Internet Explorer’s support for multiline
    string literals. In this browser, it is seemingly safe not to scrub CR and LF
    characters in user-supplied CSS strings, so some webmasters may allow it. Unfortunately,
    the same pattern will cause any other browser to resume at an unexpected offset
    and interpret the *evil_rule* ruleset:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 对此问题的简单说明可能是Internet Explorer对多行字符串字面量的支持。在这个浏览器中，似乎在用户提供的CSS字符串中不删除CR和LF字符是安全的，因此一些网站管理员可能会允许这样做。不幸的是，相同的模式会导致任何其他浏览器在意外的偏移处恢复，并解释*evil_rule*规则集：
- en: '[PRE58]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The support for multiline strings is a Microsoft-specific extension, and the
    aforementioned problem is easily fixed by avoiding such noncompliant syntax to
    begin with. Unfortunately, other desynchronization risks are introduced by the
    standard itself. For example, recall complex selectors: This CSS3 syntax makes
    no sense to pre-CSS3 parsers. In the following example, an older implementation
    may bail out after encountering an unexpected angle bracket and resume parsing
    from the attacker-supplied *evil_rule* instead:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 多行字符串的支持是微软特有的扩展，上述问题可以通过从一开始就避免这种不合规的语法来轻松解决。不幸的是，标准本身引入了其他不同步的风险。例如，回想一下复杂的选择器：这种CSS3语法对预CSS3解析器来说没有意义。在以下示例中，较旧的实现可能会在遇到意外的尖括号后退出，并从攻击者提供的
    *evil_rule* 重新开始解析：
- en: '[PRE59]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The still-popular browser Internet Explorer 6 would be vulnerable to this trick.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然流行的浏览器Internet Explorer 6会容易受到这种技巧的影响。
- en: Character Encoding
  id: totrans-672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符编码
- en: 'To make it possible to quote reserved or otherwise problematic characters inside
    strings, CSS offers an unorthodox escaping scheme: a backslash (\) followed by
    one to six hexadecimal digits. For example, according to this scheme, the letter
    *e* may be encoded as “\65”, “\065”, or “\000065”. Alas, only the last syntax,
    “\000065”, will be unambiguous if the next character happens to be a valid hexadecimal
    digit; encoding “teak” as “t\65ak” would not work as expected, because the escape
    sequence would be interpreted as “\65A”, an Arabic sign in the Unicode character
    map.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在字符串内部引用保留字符或其他问题字符，CSS提供了一种非常规的转义方案：一个反斜杠（\）后跟一到六个十六进制数字。例如，根据此方案，字母 *e*
    可以编码为“\65”、“\065”或“\000065”。然而，只有最后的语法“\000065”在下一个字符恰好是有效的十六进制数字时才会是明确的；将“teak”编码为“t\65ak”不会按预期工作，因为转义序列会被解释为“\65A”，这是Unicode字符集中的阿拉伯符号。
- en: 'To avoid this problem, the specification embraces an awkward compromise: A
    whitespace can follow an escape sequence and will be interpreted as a terminator,
    and then removed from the string (e.g., “t\65 ak”). Regrettably, more familiar
    and predictable fixed-length C-style escape sequences such as *\ x65* cannot be
    used instead.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，规范采取了一个尴尬的折衷方案：反斜杠序列之后可以跟一个空格，它将被解释为终止符，然后从字符串中移除（例如，“t\65 ak”）。遗憾的是，更熟悉且可预测的固定长度C风格转义序列，如*\
    x65*，不能被用来代替。
- en: In addition to the numerical escaping scheme, it is also possible to place a
    backslash in front of a character that is not a valid hexadecimal digit. In this
    case, the subsequent character will be treated as a literal. This mechanism is
    useful for encoding quote characters and the backslash itself, but it should not
    be used to escape HTML control characters such as angle brackets. The aforementioned
    precedence of HTML parsing over CSS parsing renders this approach inadequate.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数值转义方案之外，还可以在非十六进制有效数字字符之前放置一个反斜杠。在这种情况下，后续的字符将被视为字面量。这种机制对于编码引号字符和反斜杠本身很有用，但不应用于转义HTML控制字符，如尖括号。上述HTML解析优先于CSS解析的优先级使得这种方法不适用。
- en: 'In a bizarre twist, due to somewhat ambiguous guidance in the W3C drafts, many
    CSS parsers recognize arbitrary escape sequences in locations other than quote-enclosed
    strings. To add insult to injury, in Internet Explorer, the substitution of these
    sequences apparently takes place before the pseudo-function syntax is parsed,
    effectively making the following two examples equivalent:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个奇怪的转折中，由于W3C草案中的指导有些含糊不清，许多CSS解析器在其他位置也识别任意转义序列。更糟糕的是，在Internet Explorer中，这些序列的替换似乎在解析伪函数语法之前发生，实际上使得以下两个示例等效：
- en: '[PRE60]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Even more confusingly, in a misguided bid to maintain fault tolerance, Microsoft’s
    implementation does not recognize backslash escape codes inside *url(...)* values;
    this is, once more, to avoid hurting the feelings of users who type the wrong
    type of a slash when specifying a URL.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人困惑的是，为了维护容错性，微软的实现不识别 *url(...)* 值内的反斜杠转义代码；这又一次是为了避免伤害那些在指定URL时输入错误类型斜杠的用户感情。
- en: These and similar quirks make the detection of known dangerous CSS syntax extremely
    error prone.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及类似的怪癖使得检测已知的危险CSS语法极其容易出错。
- en: Security Engineering Cheat Sheet
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Loading Remote Stylesheets
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载远程样式表时
- en: You are linking the security of your site to the originating domain of the stylesheet.
    Even in browsers that do not support JavaScript expressions inside stylesheets,
    features such as conditional selectors and *url(...)* references can be used to
    exfiltrate portions of your site.^([[145](pr03.html#ftn.CHP-5-FT-4)])
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您正在将您站点的安全性链接到样式表的原始域名。即使在不支持在样式表中使用JavaScript表达式的浏览器中，也可以使用条件选择器和*url(...)*引用等特性来泄露您站点的部分内容.^([[145](pr03.html#ftn.CHP-5-FT-4)])
- en: When in doubt, make a local copy of the data instead.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不确定时，最好创建数据的一个本地副本。
- en: On HTTPS sites, require stylesheets to be served over HTTPS as well.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTTPS站点上，要求样式表也通过HTTPS提供。
- en: When Putting Attacker-Controlled Values into CSS
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 当将攻击者控制的值放入CSS
- en: '**Strings and URLs inside stand-alone blocks**. Always use quotes. Backslash-escape
    all control characters (0x00-0x1F), “\”, “<”, “>”, “{“, “}”, and quotes using
    numerical codes. It is also preferable to escape high-bit characters. For URLs,
    consult the cheat sheet in [Chapter 2](ch02.html "Chapter 2. It Starts with a
    URL") to avoid code injection vulnerabilities.'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立块内的字符串和URL**。始终使用引号。使用数字代码转义所有控制字符（0x00-0x1F）、“\”、“<”、“>”、“{”、“}”和引号。还最好转义高位字符。对于URL，请参考[第2章](ch02.html
    "第2章。从URL开始")中的速查表，以避免代码注入漏洞。'
- en: '**Strings in** style **parameters**. Multiple levels of escaping are involved.
    The process is error prone, so do not attempt it unless absolutely necessary.
    If it is unavoidable, apply the above CSS escaping rules first and then apply
    HTML parameter encoding to the resulting string.'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式参数中的字符串**。涉及多级转义。这个过程容易出错，所以除非绝对必要，否则不要尝试。如果不可避免，首先应用上述CSS转义规则，然后对结果字符串应用HTML参数编码。'
- en: '**Nonstring attributes**. Allow only whitelisted alphanumeric keywords and
    carefully validated numerical values. Do not attempt to reject known bad patterns
    instead.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非字符串属性**。只允许白名单字母数字关键字和经过仔细验证的数值。不要尝试拒绝已知的坏模式。'
- en: When Filtering User-Supplied CSS
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当过滤用户提供的CSS
- en: Remove all content outside of functional rulesets. Do not preserve or generate
    user-controlled comment blocks, @-directives, and so on.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除所有功能规则集之外的内容。不要保留或生成用户控制的注释块、@-指令等。
- en: Carefully validate selector syntax, permitting only alphanumerics; underscores;
    whitespaces; and correctly positioned colons, periods, and commas before “{”.
    Do not permit complex text-matching selectors; they are unsafe.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细验证选择器语法，只允许字母数字；下划线；空格；以及在“{”之前正确位置的分号、句号和逗号。不允许复杂的文本匹配选择器；它们是不安全的。
- en: Parse and validate every rule in the { ... } block. Permit only whitelisted
    properties with well-understood consequences and confirm that they take expected,
    known safe values. Note that strings passed to certain properties may sometimes
    be interpreted as URLs even in the absence of a *url(...)* wrapper.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析并验证{ ... }块中的每一条规则。只允许具有良好理解后果的白名单属性，并确认它们采用预期的、已知的、安全的值。请注意，传递给某些属性的字符串有时即使没有*url(...)*包装器也可能被解释为URL。
- en: Encode every parameter value using the rules outlined earlier in this section.
    Bail out on any syntax abnormalities.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本节前面概述的规则对每个参数值进行编码。在出现任何语法异常时退出。
- en: Keep in mind that unless specifically prevented from doing so, CSS may position
    user content outside the intended drawing area or redefine the appearance of any
    part of the UI of your application. The safest way to avoid this problem is to
    display the untrusted content inside a separate frame.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，除非明确阻止，否则CSS可能会将用户内容定位在预期的绘制区域之外或重新定义应用程序UI的任何部分的显示。避免此问题的最安全方法是，在单独的框架内显示不受信任的内容。
- en: When Allowing User-Specified Class Values on HTML Markup
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 当允许在HTML标记上指定用户定义的类值
- en: Ensure that user-supplied content can’t reuse class names that are used for
    any part of the application UI. If a separate frame is not being used, it’s advisable
    to maintain separate namespace prefixes.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保用户提供的内联内容不能重用用于应用程序UI任何部分的类名。如果没有使用单独的框架，建议维护单独的命名空间前缀。
- en: Chapter 6. Browser-Side Scripts
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。浏览器端脚本
- en: The first browser scripting engine debuted in Netscape Navigator around 1995,
    thanks to the work of Brendan Eich. The integrated Mocha language, as it was originally
    called, gave web developers the ability to manipulate HTML documents, display
    simple, system-level dialogs, open and reposition browser windows, and use other
    basic types of client-side automation in a hassle-free way.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个浏览器脚本引擎在 1995 年左右首次出现在 Netscape Navigator 中，归功于布伦丹·艾奇的工作。最初被称为集成 Mocha 语言，它赋予了网络开发者操作
    HTML 文档、显示简单的系统级对话框、打开和重新定位浏览器窗口以及以无烦恼的方式使用其他基本类型的客户端自动化的能力。
- en: While iterating through beta releases, Netscape eventually renamed Mocha LiveScript,
    and after an awkward branding deal was struck with Sun Microsystems, JavaScript
    was chosen as the final name. The similarities between Brendan’s Mocha and Sun’s
    Java were few, but the Netscape Corporation bet that this odd marketing-driven
    marriage would secure JavaScript’s dominance in the more lucrative server world.
    It made this sentiment clear in a famously confusing 1995 press release that introduced
    the language to the world and immediately tried to tie it to an impressive range
    of random commercial products:^([[146](pr03.html#ftn.CHP-6-FT-1)])
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代测试 beta 版本的过程中，Netscape 最终将 Mocha LiveScript 改名为 JavaScript，并在与 Sun Microsystems
    达成一项尴尬的品牌合作后，选择了 JavaScript 作为最终名称。布伦丹的 Mocha 与 Sun 的 Java 之间的相似之处寥寥无几，但 Netscape
    公司押注这种由市场营销驱动的奇特联姻将确保 JavaScript 在更具利润空间的网络服务器领域占据主导地位。它在一份著名的、令人困惑的 1995 年新闻稿中表达了这种观点，该新闻稿向世界介绍了这种语言，并立即试图将其与一系列令人印象深刻的随机商业产品联系起来：^([[146](pr03.html#ftn.CHP-6-FT-1)])
- en: '**Netscape and Sun Announce JavaScript, the Open, Cross-Platform Object Scripting
    Language for Enterprise Networks and the Internet**'
  id: totrans-701
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Netscape 和 Sun 宣布 JavaScript，面向企业网络和互联网的开放、跨平台对象脚本语言**'
- en: ''
  id: totrans-702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[ . . . ]'
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[ . . . ]'
- en: ''
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Netscape Navigator Gold 2.0 enables developers to create and edit JavaScript
    scripts, while Netscape LiveWire enables JavaScript programs to be installed,
    run and managed on Netscape servers, both within the enterprise and across the
    Internet. Netscape LiveWire Pro adds support for JavaScript connectivity to high-performance
    relational databases from Illustra, Informix, Microsoft, Oracle and Sybase. Java
    and JavaScript support are being built into all Netscape products to provide a
    unified, front-to-back, client/server/tool environment for building and deploying
    live online applications.
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Netscape Navigator Gold 2.0 允许开发者创建和编辑 JavaScript 脚本，而 Netscape LiveWire 允许
    JavaScript 程序在 Netscape 服务器上安装、运行和管理，无论是在企业内部还是在互联网上。Netscape LiveWire Pro 增加了连接到
    Illustra、Informix、Microsoft、Oracle 和 Sybase 的高性能关系数据库的支持。Java 和 JavaScript 的支持正在集成到所有
    Netscape 产品中，以提供统一的前后端、客户端/服务器/工具环境，用于构建和部署实时在线应用程序。
- en: 'Despite Netscape’s misplaced affection for Java, the value of JavaScript for
    client-side programming seemed clear, including to the competition. In 1996 Microsoft
    responded by shipping a near-verbatim copy of JavaScript in Internet Explorer
    3.0 along with a counterproposal of its own: a Visual Basic-derived language dubbed
    VBScript. Perhaps because it was late to the party, and perhaps because of VBScript’s
    clunkier syntax, Microsoft’s alternative failed to gain prominence or even any
    cross-browser support. In the end, JavaScript secured its position in the market,
    and in part due to Microsoft’s failure, no new scripting languages have been attempted
    in mainstream browsers since.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管 Netscape 对 Java 的喜爱有些过度，但 JavaScript 在客户端编程中的价值似乎很明确，包括对竞争对手来说也是如此。1996
    年，微软通过在 Internet Explorer 3.0 中发布 JavaScript 的几乎完全相同的副本，并提出了自己的反提案：一种名为 VBScript
    的 Visual Basic 衍生语言。可能是因为它来得太晚，也可能是因为 VBScript 的语法更笨拙，微软的替代品未能获得显著的关注或任何跨浏览器的支持。最终，JavaScript
    在市场上确立了其地位，部分原因是微软的失败，自那时起，主流浏览器中就没有尝试过新的脚本语言。 '
- en: Encouraged by the popularity of the JavaScript language, Netscape handed over
    some of the responsibility for maintaining it to an independent body, the European
    Computer Manufacturers Association (ECMA). The new overseers successfully released
    ECMAScript, 3rd edition in 1999^([[147](pr03.html#ftn.CHP-6-FT-2)]) but had substantially
    more difficulty moving forward from there. The 4th edition, an ambitious overhaul
    of the language, was eventually abandoned after several years of bickering between
    the vendors, and a scaled-down 5th edition,^([[148](pr03.html#ftn.CHP-6-FT-3)])
    published in 2009, still enjoys only limited (albeit steadily improving) browser
    support. The work on a new iteration, called “Harmony,” begun in 2008, still has
    not been finalized. Absent an evolving and widely embraced standard, vendor-specific
    extensions of the language are common, but they usually cause only pain.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript语言的流行推动下，Netscape将维护它的一部分责任交给了独立机构，即欧洲计算机制造商协会（ECMA）。新的监管机构成功地在1999年发布了ECMAScript的第三版^([[147](pr03.html#ftn.CHP-6-FT-2)])，但在继续前进方面遇到了相当大的困难。第四版，对语言的全面改革，在供应商之间经过几年的争吵后最终被放弃，并于2009年发布了一个规模较小的第五版^([[148](pr03.html#ftn.CHP-6-FT-3)))，但仍然只得到了有限的（尽管持续改善的）浏览器支持。从2008年开始的“和谐”新版本的研发工作至今尚未完成。在没有演变和广泛接受的标准的情况下，语言的供应商特定扩展很常见，但它们通常只会带来痛苦。
- en: Basic Characteristics of JavaScript
  id: totrans-708
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的基本特征
- en: JavaScript is a fairly simple language meant to be interpreted at runtime. It
    has vaguely C-influenced syntax (save for pointer arithmetic); a straightforward
    classless object model, said to be inspired by a little-known programming language
    named Self; automatic garbage collection; and weak, dynamic typing.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种相当简单的语言，旨在在运行时进行解释。它具有受C语言影响的语法（除了指针运算）；一个简单的无类对象模型，据说受到了一个名为Self的鲜为人知的编程语言的启发；自动垃圾回收；以及弱动态类型。
- en: JavaScript as such has no built-in I/O mechanisms. In the browser, limited abilities
    to interact with the host environment are offered through a set of predefined
    methods and properties that map to native code inside the browser, but unlike
    what can be seen in many other programming languages, these interfaces are fairly
    limited and purpose built.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种语言，JavaScript没有内置的I/O机制。在浏览器中，通过一组预定义的方法和属性提供有限的与宿主环境交互的能力，这些方法和属性映射到浏览器内部的本地代码，但与许多其他编程语言中看到的情况不同，这些接口相当有限且专为特定目的而设计。
- en: 'Most of the core features of JavaScript are fairly unremarkable and should
    be familiar to developers already experience with C, C++, or, to a lesser extent,
    Java. A simple JavaScript program might look like this:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的大部分核心功能相当普通，应该对已经熟悉C、C++或在一定程度上熟悉Java的开发者来说很熟悉。一个简单的JavaScript程序可能看起来像这样：
- en: '[PRE62]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Because it is beyond the scope of this book to provide a more detailed overview
    of the semantics of JavaScript, we’ll summarize only some of its more unique and
    security-relevant properties later in this chapter. For readers looking for a
    more systematic introduction to the language, Marijn Haverbeke’s *Eloquent JavaScript*
    (No Starch Press, 2011) is a good choice.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的范围不涉及对JavaScript语法的更详细概述，我们将在本章后面简要总结其一些更独特和安全相关的属性。对于寻求对语言有更系统介绍的人来说，Marijn
    Haverbeke的《优雅的JavaScript》（No Starch Press，2011年）是一个不错的选择。
- en: Script Processing Model
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本处理模型
- en: Every HTML document displayed in a browser—be it in a separate window or in
    a frame—is given a separate instance of the JavaScript execution environment,
    complete with an individual namespace for all global variables and functions created
    by the loaded scripts. All scripts executing in the context of a particular document
    share this common sandbox and can also interact with other contexts through browser-supplied
    APIs. Such cross-document interactions must be done in a very explicit way; accidental
    interference is unlikely. Superficially, script-isolation rules are reminiscent
    of the process-compartmentalization model in modern multitasking operating systems
    but a lot less inclusive.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中显示的每个HTML文档——无论是单独的窗口还是框架中——都会有一个独立的JavaScript执行环境实例，包括由加载的脚本创建的所有全局变量和函数的独立命名空间。在特定文档上下文中执行的脚本共享这个公共沙盒，并且也可以通过浏览器提供的API与其他上下文进行交互。这种跨文档交互必须以非常明确的方式进行；意外干扰的可能性很小。表面上，脚本隔离规则让人联想到现代多任务操作系统的进程隔离模型，但包容性要小得多。
- en: 'Within a particular execution context, all encountered JavaScript blocks are
    processed individually and almost always in a well-defined order. Each code block
    must consist of any number of self-contained, well-formed syntax units and will
    be processed in three distinct, consequent steps: parsing, function resolution,
    and code execution.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的执行上下文中，所有遇到的 JavaScript 块都是单独处理的，并且几乎总是按照一个明确的顺序进行。每个代码块必须由任意数量的自包含、格式良好的语法单元组成，并且将按照三个不同的、连续的步骤进行处理：解析、函数解析和代码执行。
- en: Parsing
  id: totrans-717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析
- en: The parsing stage validates the syntax of the script block and, usually, converts
    it to an intermediate binary representation, which can be subsequently executed
    at a more reasonable speed. The code has no global effects until this step completes
    successfully. In case of syntax errors, the entire problematic block is abandoned,
    and the parser proceeds to the next available chunk of code.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 解析阶段验证脚本块的语法，并且通常将其转换为中间的二进制表示形式，这可以在随后的执行中以更合理的速度执行。代码在完成此步骤之前没有全局效果。在出现语法错误的情况下，整个有问题的块将被放弃，解析器继续处理下一个可用的代码块。
- en: 'To illustrate the behavior of a compliant JavaScript parser, consider the following
    HTML snippet:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明符合规范的 JavaScript 解析器的行为，考虑以下 HTML 片段：
- en: '[PRE63]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Contrary to what developers schooled in C may be accustomed to, the above sequence
    is not equivalent to the following snippet:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 C 中受过教育的开发者可能习惯的做法相反，上述顺序与以下代码片段并不等价：
- en: '[PRE64]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is because *<script>* blocks are not concatenated before parsing. Instead,
    the first script segment will simply cause a syntax error (an assignment with
    a missing right-hand value), resulting in the entire block being ignored and not
    reaching execution stage. The fact that the whole segment is abandoned before
    it can have any global side effects also means that the original example is not
    equivalent to this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 *<script>* 块在解析之前并没有被连接。相反，第一个脚本段将简单地导致语法错误（一个缺少右侧值的赋值），导致整个块被忽略，并且不会达到执行阶段。整个段落在能够产生任何全局副作用之前就被放弃的事实也意味着原始示例与这个示例并不等价：
- en: '[PRE65]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This sets JavaScript apart from many other scripting languages such as Bash,
    where the parsing stage is not separated from execution in such a strong way.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 JavaScript 与许多其他脚本语言（如 Bash）不同，在 Bash 中，解析阶段并没有如此强烈地与执行阶段分离。
- en: What will happen in the original example provided earlier in this section is
    that the first block will be ignored but the second one (*<script>2;</script>*)
    will be parsed properly. That second block will amount to a no-op when executed,
    however, because it uses a pure, numerical expression as a code statement.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节前面提供的原始示例中，将会发生的情况是第一个块将被忽略，但第二个块 (*<script>2;</script>*) 将被正确解析。然而，当执行时，第二个块将相当于一个无操作（no-op），因为它使用了一个纯数值表达式作为代码语句。
- en: Function Resolution
  id: totrans-727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数解析
- en: 'Once the parsing stage is completed successfully, the next step involves registering
    every named, global function that the parser found within the currently processed
    block. Past this point, each function found will be reachable from the subsequently
    executed code. Because of this extra pre-execution step, the following syntax
    will work flawlessly (contrary to what programmers may be accustomed to in C or
    C++, *hello_world()* will be registered before the first code statement—a call
    to said function—is executed):'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解析阶段成功完成，下一步涉及注册解析器在当前处理的块中找到的每个命名全局函数。在此之后，每个找到的函数都将可以从随后执行的代码中访问。由于这个额外的预执行步骤，以下语法将完美工作（与程序员在
    C 或 C++ 中可能习惯的做法相反，*hello_world()* 将在执行第一个代码语句（即对该函数的调用）之前被注册）：
- en: '[PRE66]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'On the other hand, the modified example below will not have the desired effect:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，下面修改后的示例将不会产生预期的效果：
- en: '[PRE67]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This modified case will fail with a runtime error because individual blocks
    of code are not processed simultaneously but, rather, are looked at based on the
    order in which they are made available to the JavaScript engine. The block that
    defines *hello_world()* will not yet be parsed when the first block is already
    executing.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改后的案例将因运行时错误而失败，因为代码块不是同时处理的，而是根据它们提供给 JavaScript 引擎的顺序来处理的。当第一个块已经开始执行时，定义
    *hello_world()* 的块尚未被解析。
- en: 'To further complicate the picture, the mildly awkward global name resolution
    model outlined here applies only to functions, not to variable declarations. Variables
    are registered sequentially at execution time, in a way similar to other interpreted
    scripting languages. Consequently, the following code sample, which merely replaces
    our global *hello_world()* with an unnamed function assigned to a global variable,
    will not work as planned:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步复杂化这幅图景，这里概述的略显尴尬的全局名称解析模型仅适用于函数，而不适用于变量声明。变量在执行时按顺序注册，方式类似于其他解释型脚本语言。因此，以下代码示例，它只是将我们的全局
    *hello_world()* 替换为一个分配给全局变量的未命名函数，将不会按预期工作：
- en: '[PRE68]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this case, the assignment to the *hello_world* variable will not be done
    by the time the *hello_world()* call is attempted.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对 *hello_world* 变量的赋值将不会在尝试调用 *hello_world()* 时完成。
- en: Code Execution
  id: totrans-736
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码执行
- en: Once function resolution is completed, the JavaScript engine normally proceeds
    with the ordered execution of all statements outside of function blocks. The execution
    of a script may fail at this point due to an unhandled exception or for a couple
    of other, more esoteric reasons. If such an error is encountered, however, any
    resolved functions within the offending code block will remain callable, and any
    effects of the already executed code will persist in the current scripting context.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数解析完成，JavaScript 引擎通常会继续按顺序执行函数块之外的所有语句。脚本在此处可能由于未处理的异常或其他一些更神秘的原因而失败。然而，如果遇到此类错误，则受影响代码块中的任何已解析函数仍然可以调用，并且已执行代码的任何效果将保留在当前脚本上下文中。
- en: 'Exception recovery and several other JavaScript execution characteristics are
    illustrated by the following lengthy but interesting code snippet:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 以下长篇但有趣的代码片段展示了异常恢复和其他几个 JavaScript 执行特性：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages950015.png.jpg)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages950015.png.jpg)'
- en: Try to follow this example on your own and see if you agree with the annotations
    provided on the right.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己跟随这个例子，看看你是否同意右侧提供的注释。
- en: 'As should be evident from this exercise, any unexpected and unhandled exceptions
    have an unusual consequence: They may leave the application in an inconsistent
    but still potentially executable state. Because exceptions are meant to prevent
    error propagation caused by unanticipated errors, this design is odd—especially
    given that on many other fronts (such as the ban on *goto* statements), JavaScript
    exhibits a more fundamentalist stance.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如此练习所示，任何意外且未处理的异常都有不寻常的后果：它们可能会使应用程序处于不一致但仍然可能可执行的状态。由于异常旨在防止由未预料到的错误引起的错误传播，这种设计显得很奇怪——尤其是在许多其他方面（如禁止
    *goto* 语句），JavaScript 表现出更基要主义的立场。
- en: Execution Ordering Control
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行顺序控制
- en: In order to properly analyze the security properties of certain common web application
    design patterns, it is important to understand the JavaScript engine’s execution
    ordering and timing model. Thankfully, this model is remarkably sane.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确分析某些常见网络应用程序设计模式的安全属性，了解 JavaScript 引擎的执行顺序和计时模型非常重要。幸运的是，这个模型非常合理。
- en: Virtually all JavaScript living within a particular execution context is executed
    synchronously. The code can’t be reentered due to an external event while it is
    still executing, and there is no support for threads that would be able to simultaneously
    modify any shared memory. While the execution engine is busy, the processing of
    events, timers, page navigation requests, and so on, is postponed; in most cases,
    the entire browser, or at least the HTML renderer, will also remain largely unresponsive.
    Only once the execution stops and the scripting engine enters an idle state will
    the processing of queued events resume. At this point, the JavaScript code may
    be entered again.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有存在于特定执行上下文中的 JavaScript 都是以同步方式执行的。由于外部事件，代码在执行过程中无法重新进入，并且没有支持能够同时修改任何共享内存的线程。当执行引擎忙碌时，事件处理、计时器、页面导航请求等处理将被推迟；在大多数情况下，整个浏览器，或者至少是
    HTML 渲染器，也将保持大部分无响应。只有当执行停止并且脚本引擎进入空闲状态时，排队事件的处理才会继续。此时，JavaScript 代码可以再次进入。
- en: Further, JavaScript offers no *sleep(...)* or *pause(...)* function to temporarily
    release the CPU and later resume execution from the same location. Instead, if
    a programmer desires to postpone the execution of a script, it is necessary to
    register a timer to initiate a new execution flow later on. This flow will need
    to start at the beginning of a specified handler function (or at the beginning
    of an ad hoc, self-contained snippet of code provided when setting up a timer).
    Although these design decisions can be annoying, they substantially reduce the
    risk of race conditions in the resulting code.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JavaScript 没有提供 *sleep(...)* 或 *pause(...)* 函数来暂时释放 CPU 并稍后从相同位置恢复执行。相反，如果程序员希望推迟脚本的执行，则必须注册一个定时器，稍后启动新的执行流程。这个流程需要从指定的处理函数的开始（或设置定时器时提供的自包含代码片段的开始）开始。尽管这些设计决策可能令人烦恼，但它们在很大程度上减少了代码中发生竞争条件的风险。
- en: Note
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several probably unintentional loopholes in this synchronous execution
    model. One of them is the possibility of code execution while the execution of
    another piece of JavaScript is temporarily suspended after calling *alert(...)*
    or *showModalDialog(...)*. Such corner cases do not come into play very often,
    though.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个同步执行模型中存在几个可能并非故意的漏洞。其中之一是在调用 *alert(...)* 或 *showModalDialog(...)* 后，暂时挂起另一段
    JavaScript 执行时可能发生代码执行的可能性。尽管这些边缘情况并不经常出现。
- en: 'The disruptive, browser-blocking behavior of busy JavaScript loops requires
    the implementation of some mitigation on the browser level. We will explore these
    mitigations in detail in [Chapter 14](ch14.html "Chapter 14. Dealing with Rogue
    Scripts"). For now, suffice it to say that they have another highly unusual consequence:
    Any endless loop may, in fact, terminate, in a fashion similar to throwing an
    unhandled exception. The engine will then return to the idle state but will remain
    operational, the offending code will remain callable, and all timers and event
    handlers will stay in place.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 忙碌的 JavaScript 循环的破坏性、阻止浏览器行为需要浏览器级别的缓解措施。我们将在 [第 14 章](ch14.html "第 14 章。处理恶意脚本")
    中详细探讨这些缓解措施。目前，只需说它们还有一个非常不寻常的后果：任何无限循环实际上都可能终止，类似于抛出一个未处理的异常。然后，引擎将返回空闲状态，但仍然处于运行状态，有问题的代码仍然可以调用，所有定时器和事件处理程序都将保持原位。
- en: 'When triggered on purpose by the attacker, the ability to unexpectedly terminate
    the execution of CPU-intensive code may put the application in an inconsistent
    state by aborting an operation that the author expects to always complete successfully.
    And that’s not all: Another, closely related consequence of these semantics should
    become evident in [JavaScript Object Notation and Other Data Serializations](ch06.html#javascript_object_notation_and_other_dat
    "JavaScript Object Notation and Other Data Serializations") in [JavaScript Object
    Notation and Other Data Serializations](ch06.html#javascript_object_notation_and_other_dat
    "JavaScript Object Notation and Other Data Serializations").'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者故意触发时，意外终止 CPU 密集型代码的执行可能会通过中断作者预期总是成功完成的操作，使应用程序处于不一致的状态。而且，这还不是全部：这些语义的另一个密切相关的后果将在
    [JavaScript 对象表示法和其他数据序列化](ch06.html#javascript_object_notation_and_other_dat
    "JavaScript Object Notation and Other Data Serializations") 中变得明显。[JavaScript
    对象表示法和其他数据序列化](ch06.html#javascript_object_notation_and_other_dat "JavaScript
    Object Notation and Other Data Serializations")。
- en: Code and Object Inspection Capabilities
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码和对象检查功能
- en: The JavaScript language has a rudimentary provision for inspecting the decompiled
    source code of any nonnative functions, simply by invoking the *toString()* or
    *toSource()* method on any function that the developer wishes to examine. Beyond
    that capability, opportunities to inspect the flow of programs are limited. Applications
    may leverage access to the in-memory representation of their host document and
    look up all inlined *<script>* blocks, but there is no direct visibility into
    any remotely loaded or dynamically generated code. Some insight into the call
    stack may also be gained through a nonstandard *caller* property, but there is
    also no way to tell which line of code is being currently executed or which one
    is coming up next.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言为检查任何非本地函数的反编译源代码提供了一个基本的规定，只需在开发者希望检查的任何函数上调用 *toString()* 或 *toSource()*
    方法即可。除了这个能力之外，检查程序流程的机会是有限的。应用程序可以利用对其宿主文档内存表示的访问来查找所有内联的 *<script>* 块，但无法直接看到任何远程加载或动态生成的代码。也可以通过非标准的
    *caller* 属性获得对调用栈的一些了解，但也没有办法知道当前正在执行哪一行代码或下一行将执行哪一行。
- en: 'The ability to dynamically create new JavaScript code is a more prominent part
    of the language. It is possible to instruct the engine to synchronously interpret
    strings passed to the built-in *eval(...)* function. For example, this will display
    an alert dialog:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建新JavaScript代码的能力是语言中更突出的一部分。可以指示引擎同步解释传递给内置的 *eval(...)* 函数的字符串。例如，这将显示一个警告对话框：
- en: '[PRE69]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Syntax errors in any input text provided to *eval(...)* will cause this function
    to throw an exception. Similarly, if parsing succeeds, any unhandled exceptions
    thrown by the interpreted code will be passed down to the caller. Finally, in
    the absence of syntax errors or runtime problems, the value of the last statement
    evaluated by the engine while executing the supplied code will be used as the
    return value of *eval(...)* itself.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 任何提供给 *eval(...)* 的输入文本中的语法错误都会导致此函数抛出异常。同样，如果解析成功，由解释的代码抛出的任何未处理的异常将被传递给调用者。最后，在没有语法错误或运行时问题的情况下，执行器在执行提供的代码时评估的最后一条语句的值将被用作
    *eval(...)* 本身的返回值。
- en: In addition to this function, other browser-level mechanisms can be leveraged
    to schedule deferred parsing and execution of new JavaScript blocks once the execution
    engine returns to the idle state. Examples of such mechanisms include timers (*setTimeout*,
    *setInterval*), event handlers (*onclick*, *onload*, and so on), and interfaces
    to the HTML parser itself (*innerHTML*, *document.write(...)*, and such).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个功能之外，还可以利用其他浏览器级别的机制来安排在执行器返回空闲状态后延迟解析和执行新的JavaScript块。这类机制的例子包括计时器（*setTimeout*、*setInterval*）、事件处理器（*onclick*、*onload*
    等）以及HTML解析器的接口（*innerHTML*、*document.write(...)* 等）。
- en: Whereas the ability to inspect the code is somewhat underhanded, runtime object
    introspection capabilities are well developed in JavaScript. Applications are
    permitted to enumerate almost any object method or property using simple *for
    ... in* or *for each ... in* iterators and can leverage operators such as *typeof*,
    *instanceof*, or “strictly equals” (===) and properties such as *length* to gain
    additional insight into the identity of every discovered item.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然检查代码的能力有些隐蔽，但JavaScript中的运行时对象自省能力已经相当成熟。应用程序被允许使用简单的 *for ... in* 或 *for
    each ... in* 迭代器枚举几乎任何对象的方法或属性，并且可以利用诸如 *typeof*、*instanceof* 或“严格等于”（===）这样的运算符以及诸如
    *length* 这样的属性来深入了解每个发现项的身份。
- en: All of the foregoing features make it largely impossible for scripts running
    in the same context to keep secrets from each other. The functionality also makes
    it more difficult to keep secrets across document contexts, a problem that browser
    vendors had to combat for a very long time—and that, as you’ll learn in [Chapter 11](ch11.html
    "Chapter 11. Life Outside Same-Origin Rules"), is still not completely a thing
    of the past.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述功能使得在同一上下文中运行的脚本之间很难保守秘密。该功能还使得在文档上下文中保守秘密变得更加困难，这是一个浏览器厂商长期以来必须应对的问题——正如你将在[第11章](ch11.html
    "第11章。同源规则之外的生活")中了解到的那样，这仍然不是完全过去的事情。
- en: Modifying the Runtime Environment
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改运行时环境
- en: Despite the relative simplicity of the JavaScript language, executed scripts
    have many unusual ways of profoundly manipulating the behavior of their own JavaScript
    sandbox. In some rare cases, these behaviors can impact other documents, as well.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript语言相对简单，但执行脚本有许多不寻常的方式来深刻地操纵其自身的JavaScript沙盒的行为。在某些罕见的情况下，这些行为可能会影响其他文档。
- en: Overriding Built-Ins
  id: totrans-760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖内置函数
- en: 'One of the more unusual tools at the disposal of a rogue script is the ability
    to delete, overwrite, or shadow most of the built-in JavaScript functions and
    virtually all browser-supplied I/O methods. For example, consider the behavior
    of the following code:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 一个恶意脚本可用的更不寻常的工具是删除、覆盖或隐藏大多数内置JavaScript函数和几乎所有浏览器提供的I/O方法的能力。例如，考虑以下代码的行为：
- en: '[PRE70]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And this is just where the fun begins. In Chrome, Safari, and Opera, it is possible
    to subsequently remove the *eval(...)* function altogether, using the *delete*
    operator. Confusingly, attempting the same in Firefox will restore the original
    built-in function, undoing the effect of the original override. Finally, in Internet
    Explorer, the deletion attempt will generate a belated exception that seems to
    serve no meaningful purpose at that point.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是乐趣的开始。在Chrome、Safari和Opera中，可以使用 *delete* 运算符完全删除 *eval(...)* 函数。令人困惑的是，在Firefox中尝试同样的操作将恢复原始的内置函数，从而撤销了原始覆盖的效果。最后，在Internet
    Explorer中，删除尝试将生成一个似乎在那个点上没有实际意义的延迟异常。
- en: 'Further along these lines, almost every object, including built-ins such as
    *String* or *Array*, has a freely modifiable prototype. This prototype is a master
    object from which all existing and future object instances derive their methods
    and properties (forming a crude equivalent of class inheritance present in more
    fully featured programming languages). The ability to tamper with object prototypes
    can cause rather counterintuitive behavior of newly created objects, as illustrated
    here:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这些思路进一步，几乎每个对象，包括如 *String* 或 *Array* 这样的内置对象，都有一个可以自由修改的原型。这个原型是一个主对象，所有现有和未来的对象实例都从中继承其方法和属性（形成了一种在功能更全面的编程语言中存在的类继承的粗略等效）。修改对象原型的能力可能导致新创建的对象产生相当反直觉的行为，如下所示：
- en: '[PRE71]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Setters and Getters
  id: totrans-766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置器和获取器
- en: 'More interesting features of the object model available in contemporary dialects
    of JavaScript are *setters* and *getters*: ways to supply custom code that handles
    reading or setting properties of the host object. Although not as powerful as
    operator overloading in C++, these can be used to make existing objects or object
    prototypes behave in even more confusing ways. In the following snippet, the acts
    of setting the object property and reading it back later on are both subverted
    easily:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在当代JavaScript方言中，对象模型的一些更有趣的特性是 *设置器* 和 *获取器*：提供自定义代码以处理宿主对象的属性读取或设置的方式。尽管它们不如C++中的运算符重载强大，但它们可以用来使现有对象或对象原型以更令人困惑的方式表现。在下面的代码片段中，设置对象属性和稍后读取它的行为都很容易被颠覆：
- en: '[PRE72]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setters and getters were initially developed as a vendor extension but are now
    standardized under ECMAScript edition 5\. The feature is available in all modern
    browsers but not in Internet Explorer 6 or 7.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器和获取器最初是作为供应商扩展开发的，但现在在ECMAScript第5版中得到了标准化。该功能在所有现代浏览器中都是可用的，但在Internet Explorer
    6或7中不可用。
- en: Impact on Potential Uses of the Language
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对语言潜在用途的影响
- en: As a result of the techniques discussed in the previous two sections, a script
    executing inside a context once tainted by any other untrusted content has no
    reliable way to examine its operating environment or take corrective action; even
    the behavior of simple conditional expressions or loops can’t necessarily be relied
    upon. The proposed enhancements to the language are likely to make the picture
    even more complicated. For example, the failed proposal for ECMAScript edition
    4 featured full-fledged operator overloading, and this idea may return.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两节中讨论的技术，在某个环境中执行脚本，该环境曾经被任何其他不受信任的内容污染，脚本将没有可靠的方式来检查其操作环境或采取纠正措施；即使是简单的条件表达式或循环的行为也不一定能依赖。语言提出的增强功能可能会使情况变得更加复杂。例如，ECMAScript第4版的失败提案包括完整的运算符重载，这个想法可能会回归。
- en: Even more interestingly, these design decisions also make it difficult to inspect
    any execution context from outside the per-page sandbox. For example, blind reliance
    on the reliability of the *location* object of a potentially hostile document
    has led to a fair number of security vulnerabilities in browser plug-ins, JavaScript-based
    extensions, and several classes of client-side web application security features.
    These vulnerabilities eventually resulted in the development of browser-level
    workarounds designed to partially protect this specific object against sabotage,
    but most of the remaining object hierarchy is up for grabs.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，这些设计决策还使得从页面沙盒外部检查任何执行上下文变得困难。例如，盲目依赖潜在敌对文档的 *location* 对象的可靠性，导致了浏览器插件、基于
    JavaScript 的扩展和几类客户端网络应用安全特性中相当数量的安全漏洞。这些漏洞最终导致了浏览器级别的解决方案的开发，旨在部分保护这个特定的对象免受破坏，但大多数剩余的对象层次结构仍然处于争夺之中。
- en: Note
  id: totrans-774
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ability to tamper with one’s own execution context is limited in the “strict”
    mode of ECMAScript edition 5\. This mode is not fully supported in any browser
    as of this writing, however, and is meant to be an opt-in, discretionary mechanism.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 第 5 版的“严格”模式下，对自身执行上下文的篡改能力受到限制。然而，截至本文撰写时，任何浏览器都不完全支持这种模式，它旨在是一个可选的、任意的机制。
- en: JavaScript Object Notation and Other Data Serializations
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 对象表示法和其他数据序列化
- en: 'A very important syntax structure in JavaScript is its very compact and convenient
    in-place object serialization, known as JavaScript Object Notation, or JSON (RFC
    4627^([[149](pr03.html#ftn.CHP-6-FT-4)])). This data format relies on overloading
    the meaning of the curly bracket symbol ({). When such a brace is used to open
    a fully qualified statement, it is treated in a familiar way, as the start of
    a nested code block. In an expression, however, it is assumed to be the beginning
    of a serialized object. The following example illustrates a correct use of this
    syntax and will display a simple prompt:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，一个非常重要的语法结构是其非常紧凑且方便的现场对象序列化，称为 JavaScript 对象表示法，或 JSON（RFC 4627^([[149](pr03.html#ftn.CHP-6-FT-4)])）。这种数据格式依赖于对花括号符号
    ({) 的重载。当这样的花括号用于打开一个完全限定的语句时，它以熟悉的方式处理，作为嵌套代码块的开始。然而，在表达式的情况下，它被假定为序列化对象的开始。以下示例说明了这种语法的正确使用，并将显示一个简单的提示：
- en: '[PRE73]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In contrast to the unambiguous serializations of numbers, strings, or arrays,
    the overloading of the curly bracket means that JSON blocks will not be recognized
    properly when used as a standalone statement. This may seem insignificant, but
    it is an advantage: It prevents any server-supplied responses that comply with
    this syntax from being meaningfully included across domains via *<script src=...>*.^([[30](#ftn.CHP-6-FN-1)])
    The listing that follows will cause a syntax error, ostensibly due to an illegal
    quote (![](httpatomoreillycomsourcenostarchimages950001.png)) in what the interpreter
    attempts to treat as a code label,^([[31](#ftn.CHP-6-FN-2)]) and will have no
    measurable side effects:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字、字符串或数组的不明确序列化相比，花括号的重载意味着当作为独立语句使用时，JSON 块将无法正确识别。这看起来可能微不足道，但这是一个优点：它防止了任何符合这种语法的服务器提供的响应通过
    *<script src=...>* 在域之间有意义地包含。^([[30](#ftn.CHP-6-FN-1)]) 下面的列表将导致语法错误，表面上是因为在解释器试图将其视为代码标签的地方存在非法引号
    (![](httpatomoreillycomsourcenostarchimages950001.png)))，并且将没有可测量的副作用：
- en: '[PRE74]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The inability to include JSON via *<script src=...>* is an interesting property,
    but it is also a fragile one. In particular, wrapping the response in parentheses
    or square brackets, or removing quotes around the labels, will render the syntax
    readily executable in a standalone block, which may have observable side effects.
    Given the rapidly evolving syntax of JavaScript, it is not wise to bank on this
    particular code layout always causing a parsing error in the years to come. That
    said, in many noncritical uses, this level of assurance will be good enough to
    rely on as a simple security mechanism.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 无法通过 *<script src=...>* 包含 JSON 是一个有趣的特性，但同时也非常脆弱。特别是，将响应包裹在括号或方括号中，或者移除标签周围的引号，将使语法在独立块中易于执行，这可能会产生可观察的副作用。鉴于
    JavaScript 语法的快速演变，依赖这种特定的代码布局在未来的几年里始终导致解析错误是不明智的。尽管如此，在许多非关键用途中，这种程度的保证已经足够作为简单的安全机制来依赖。
- en: 'Once retrieved through a channel such as *XMLHttpRequest*, the JSON serialization
    can be quickly and effortlessly converted to an in-memory object using the *JSON.parse(...)*
    function in all common browsers, other than Internet Explorer. Unfortunately,
    for purposes of compatibility with Internet Explorer, and sometimes just out of
    custom, many developers resort to an equally fast yet far more dangerous hack:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过如 *XMLHttpRequest* 这样的通道检索到 JSON 序列化，就可以使用所有常见浏览器中的 *JSON.parse(...)* 函数快速且轻松地将它转换为内存中的对象，除了
    Internet Explorer。不幸的是，为了与 Internet Explorer 兼容，有时仅仅是出于习惯，许多开发者求助于一个同样快速但危险得多的黑客手段：
- en: '[PRE75]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The problem with this syntax is that the *eval(...)* function used to compute
    the “value” of a JSON expression permits not only pure JSON inputs but any other
    well-formed JavaScript syntax to appear in the string. This can have undesirable,
    global side effects. For example, the function call embedded in this faux JSON
    response will execute:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法的问题是，用于计算 JSON 表达式“值”的 *eval(...)* 函数不仅允许纯 JSON 输入，还允许任何其他有效的 JavaScript
    语法出现在字符串中。这可能导致不希望看到的全局副作用。例如，这个伪造 JSON 响应中嵌入的函数调用将会执行：
- en: '[PRE76]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This behavior creates an additional burden on web developers to accept JSON
    payloads only from trusted sources and always to correctly escape feeds produced
    by their own server-side code. Predictably, failure to do so has contributed a
    fair number of application-level security bugs.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为给网络开发者带来了额外的负担，他们必须只接受来自可信来源的 JSON 有效载荷，并且始终正确转义他们自己的服务器端代码生成的数据流。可以预见的是，未能这样做已经导致了许多应用程序级别的安全漏洞。
- en: Note
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The difficulty of getting *eval(...)* right is embodied by the JSON specification
    (RFC 4627) itself: The allegedly secure parser implementation included in that
    document unintentionally permits rogue JSON responses to freely increment or decrement
    any program variables that happen to consist solely of the letters “a”, “e”, “f”,
    “l”, “n”, “r”, “s”, “t”, “u”, plus digits; that’s enough to spell “unsafe” and
    about 1,000 other common English words. The faulty regular expression legitimized
    in this RFC appears all over the Internet and will continue to do so.'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 *eval(...)* 正确性的难度体现在 JSON 规范（RFC 4627）本身：该文档中包含的声称安全的解析器实现无意中允许恶意的 JSON
    响应自由增加或减少任何仅由字母“a”、“e”、“f”、“l”、“n”、“r”、“s”、“t”、“u”以及数字组成的程序变量；这足以构成“不安全”以及大约 1,000
    个其他常见的英语单词。在这个 RFC 中合法化的有缺陷的正则表达式遍布整个互联网，并将继续这样做。
- en: Thanks to their ease of use, JSON serializations are ubiquitous in server-to-client
    communications across all modern web applications. The format is rivaled only
    by other, less secure string or array serializations and by JSONP.^([[32](#ftn.CHP-6-FN-3)])
    All of these schemes are incompatible with *JSON.parse(...)*, however, and must
    rely on unsafe *eval(...)* to be converted to in-memory data. The other property
    of these formats is that, unlike proper JSON, they will parse properly when loaded
    with *<script src=...>* on a third-party page. This property is advantageous in
    some rare cases, but mostly it just constitutes an unobvious risk. For example,
    consider that even though loading an array serialization via a *<script>* tag
    normally has no measurable side effects, an attacker could, at least until recent
    improvements, modify the setters on an *Array* prototype to retrieve the supplied
    data. A common but often insufficient practice of prefixing a response with a
    *while(1);* loop to prevent this attack can backfire in interesting ways if you
    recall the possibility of endless loops terminating in JavaScript.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们易于使用，JSON 序列化在现代所有网络应用中的服务器到客户端通信中无处不在。这种格式仅被其他更不安全的字符串或数组序列化以及 JSONP 所匹敌.^([[32](#ftn.CHP-6-FN-3)])
    然而，所有这些方案都与 *JSON.parse(...)* 不兼容，并且必须依赖不安全的 *eval(...)* 来转换为内存中的数据。这些格式的另一个特性是，与正确的
    JSON 不同，当在第三方页面上使用 *<script src=...>* 加载时，它们可以正确解析。这种特性在某些罕见情况下是有利的，但大多数情况下它仅仅构成了一种不明显风险。例如，考虑即使通过
    *<script>* 标签加载数组序列化通常没有可测量的副作用，攻击者至少直到最近，可以修改 *Array* 原型的设置器来检索提供的数据。一种常见的但通常不够充分的预防措施是在响应前加上一个
    *while(1);* 循环来防止这种攻击，但如果记住无限循环可能在 JavaScript 中终止，这种做法可能会以有趣的方式产生反效果。
- en: E4X and Other Syntax Extensions
  id: totrans-791
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E4X 和其他语法扩展
- en: Like HTML, JavaScript is quickly evolving. Some of the changes made to it over
    the years have been fairly radical and may end up turning text formats that were
    previously rejected by the parser into a valid JavaScript code. This, in turn,
    may lead to unexpected data disclosure, especially in conjunction with the extensive
    code and object inspection and modification capabilities discussed earlier in
    this chapter—and the ability to use *<script src=...>* to load cross-domain code.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML一样，JavaScript正在迅速发展。多年来对其所做的某些更改相当激进，最终可能将以前被解析器拒绝的文本格式转换为有效的JavaScript代码。这反过来可能导致意外的数据泄露，尤其是在本章前面讨论的广泛代码和对象检查以及修改能力，以及使用
    *<script src=...>* 加载跨域代码的能力。
- en: 'One of the more notable examples of this trend is *ECMAScript for XML* (E4X),^([[150](pr03.html#ftn.CHP-6-FT-5)])
    a completely unnecessary but elegant plan to incorporate XML syntax directly into
    JavaScript as an alternative to JSON-style serializations. In any E4X-compatible
    engine, such as Firefox, the following two snippets of code would be roughly equivalent:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这种趋势的一个更显著的例子是 *ECMAScript for XML* (E4X)，^([[150](pr03.html#ftn.CHP-6-FT-5)])
    这是一个完全不必要的但优雅的计划，将XML语法直接纳入JavaScript，作为JSON样式序列化的替代方案。在任何E4X兼容的引擎中，例如Firefox，以下两个代码片段大致等价：
- en: '[PRE77]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The unexpected consequence of E4X is that, under this regime, any well-formed
    XML document suddenly becomes a valid *<script src=...>* target that will parse
    as an expression-as-statement block. Moreover, if an attacker can strategically
    place “{” and “}” characters on an included page, or alter the setters for the
    right object prototype, the attacker may be able to extract user-specific text
    displayed in an unrelated document. The following example illustrates the risk:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: E4X的意外后果是，在这种机制下，任何格式良好的XML文档突然变成了一个有效的 *<script src=...>* 目标，它将被解析为一个表达式-语句块。此外，如果攻击者能够在包含的页面上战略性地放置“{”和“}”字符，或者更改正确对象原型的设置器，攻击者可能能够提取在无关文档中显示的用户特定文本。以下示例说明了风险：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages950017.png.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages950017.png.jpg)'
- en: To their credit, after several years of living with the flaw, Firefox developers
    decided to disallow any E4X statements that span the entirety of any parsed script,
    partly closing this loophole. Nevertheless, the fluidity of the language is evident,
    and it casts some doubt on the robustness of using of JSON responses as a defense
    against cross-domain script inclusion. The moment a third meaning is given to
    the “{” symbol or quotes-as-labels start having a purpose, the security of this
    server-to-client data exchange format will be substantially degraded. Be sure
    to plan ahead.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 值得赞扬的是，在忍受了几年这个缺陷之后，Firefox开发者决定禁止任何跨越整个解析脚本的E4X语句，这在一定程度上关闭了这个漏洞。尽管如此，语言的灵活性是显而易见的，这让人对使用JSON响应作为防御跨域脚本包含的手段的稳健性产生了一些怀疑。一旦“{”符号被赋予第三个含义，或者引号作为标签开始发挥作用，这种服务器到客户端数据交换格式的安全性将大大降低。务必提前做好规划。
- en: '* * *'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[30](#CHP-6-FN-1)]) Unlike most other content inclusion schemes available
    to scripts (such as *XMLHttpRequest*), *<script src=...>* is not subject to the
    cross-domain security restrictions outlined in [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic"). Therefore, the mechanism is a security risk whenever ambient
    authority credentials, such as cookies, are used by the server to dynamically
    generate user-specific JavaScript code. This class of vulnerabilities is unimaginatively
    referred to as *cross-site script inclusion*, or *XSSI*.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#CHP-6-FN-1)]) 与大多数其他提供给脚本的（如 *XMLHttpRequest*）内容包含方案不同，*<script src=...>*
    不受第9章中概述的跨域安全限制的影响。因此，当服务器使用环境权限凭据（如cookies）动态生成用户特定JavaScript代码时，这种机制就是一个安全风险。这类漏洞被毫无想象力地称为
    *跨站脚本包含*，或 *XSSI*。
- en: '^([[31](#CHP-6-FN-2)]) Somewhat unexpectedly, JavaScript supports C-style labeled
    statements, such as *my_label: alert(“Hi mom!”)*. This is interesting because
    for philosophical reasons, the language has no support for *goto* and, therefore,
    such a label can’t be meaningfully referenced in most cases.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[31](#CHP-6-FN-2)]) 比较意外的是，JavaScript支持C样式的标签语句，例如 *my_label: alert(“Hi
    mom!”)*。这很有趣，因为出于哲学原因，该语言不支持 *goto*，因此在这种情况下，这样的标签通常无法有意义地引用。'
- en: ^([[32](#CHP-6-FN-3)]) JSONP literally means “JSON with padding” and stands
    for JSON serialization wrapped in some supplementary code that turns it into a
    valid, standalone JavaScript statement for convenience. Common examples may include
    a function call (e.g., *callback_function({ ...JSON data... })*) or a variable
    assignment (*var return_value = { ...JSON data... }*).
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#CHP-6-FN-3)]) JSONP 实际上意味着“带有填充的 JSON”，它代表被一些补充代码包裹的 JSON 序列化，这些代码将其转换为一个有效的、独立的
    JavaScript 语句，以便于使用。常见的例子可能包括函数调用（例如，*callback_function({ ...JSON 数据... })*）或变量赋值（*var
    return_value = { ...JSON 数据... }*）。
- en: Standard Object Hierarchy
  id: totrans-802
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准对象层次结构
- en: The JavaScript execution environment is structured around an implicit root object,
    which is used as the default namespace for all global variables and functions
    created by the program. In addition to a handful of language-mandated built-ins,
    this namespace is prepopulated with a hierarchy of functions that implement input
    and output capabilities in the browser environment. These capabilities include
    manipulating browser windows (*open(...)*, *close()*, *moveTo(...)*, *resizeTo(...)*,
    *focus()*, *blur()*, and such); configuring JavaScript timers (*setTimeout(...)*,
    *setInterval(...)*, and so on); displaying various UI prompts (*alert(...)*, *prompt(...)*,
    *print(...)*); and performing a variety of other vendor-specific and frequently
    risky functions, such as accessing the system clipboard, creating bookmarks, or
    changing the home page.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 执行环境是围绕一个隐式根对象构建的，该对象用作程序创建的所有全局变量和函数的默认命名空间。除了几个语言强制性的内置函数外，此命名空间还预先填充了一个函数层次结构，这些函数在浏览器环境中实现输入和输出功能。这些功能包括操作浏览器窗口（*open(...)*、*close()*、*moveTo(...)*、*resizeTo(...)*、*focus()*、*blur()*
    等）；配置 JavaScript 定时器（*setTimeout(...)*、*setInterval(...)* 等）；显示各种 UI 提示（*alert(...)*、*prompt(...)*、*print(...)*）；以及执行各种供应商特定的和经常有风险的功能，例如访问系统剪贴板、创建书签或更改主页。
- en: 'The top-level object also provides JavaScript references to root objects belonging
    to related contexts, including the parent frame (*parent*), the top-level document
    in the current browser window (*top*), the window that created the current one
    (*opener*), and all subframes of the current document (*frames[]*). Several circular
    references to the current root object itself are also included—say, *window* and
    *self*. In browsers other than Firefox, elements with specified *id* or *name*
    parameters will be automatically registered in this namespace, too, permitting
    syntax such as this:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级对象还提供了对属于相关上下文的根对象的 JavaScript 引用，包括父框架（*parent*）、当前浏览器窗口中的顶级文档（*top*）、创建当前窗口的窗口（*opener*）以及当前文档的所有子框架（*frames[]*）。还包括对当前根对象本身的几个循环引用——例如，*window*
    和 *self*。在非 Firefox 浏览器中，具有指定 *id* 或 *name* 参数的元素也将自动注册在此命名空间中，允许使用如下语法：
- en: '[PRE78]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Thankfully, in case of any name conflicts with JavaScript variables or built-ins,
    *id* data will not be given precedence, largely avoiding any possible interference
    between otherwise sanitized, user-supplied markup and in-document scripts.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 JavaScript 变量或内置函数发生名称冲突的情况下，*id* 数据不会优先考虑，这很大程度上避免了清洁的用户提供的标记和文档内脚本之间可能发生的任何干扰。
- en: 'The remainder of the top-level hierarchy consists primarily of a couple of
    distinguished children objects that group browser API features by theme:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级层次结构的其余部分主要由几个具有特色的子对象组成，这些对象按主题分组浏览器 API 功能：
- en: location **object**
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 位置 **对象**
- en: 'This is a collection of properties and methods that allow the program to read
    the URL of the current document or initiate navigation to a new one. This last
    action, in most cases, is lethal to the caller: The current scripting context
    will be destroyed and replaced with a new one shortly thereafter. Updating just
    the fragment identifier (*location.hash*) is an exception to this rule, as explained
    in [Chapter 2](ch02.html "Chapter 2. It Starts with a URL").'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个属性和方法集合，允许程序读取当前文档的 URL 或启动对新文档的导航。在大多数情况下，此操作对调用者来说是致命的：当前的脚本上下文将在不久之后被销毁并替换为一个新的上下文。更新仅片段标识符（*location.hash*）是此规则的例外，如第
    2 章所述。
- en: Note that when using *location.** data to construct new strings (HTML and JavaScript
    code in particular), it is unsafe to assume that it is escaped in any specific
    way. Internet Explorer will keep angle brackets as is in the *location.search*
    property (which corresponds to the URL query string). Chrome, on the other hand,
    will escape them, but it will glance over double quotes (`"`) or backslashes.
    Most browsers also do not apply any escaping to the fragment ID.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用 *location.** 数据构建新的字符串（特别是HTML和JavaScript代码）时，假设它以任何特定方式转义是不安全的。Internet
    Explorer将保持 *location.search* 属性（对应于URL查询字符串）中的角度括号不变。另一方面，Chrome会转义它们，但会忽略双引号（`"`）或反斜杠。大多数浏览器也不会对片段ID应用任何转义。
- en: history **object**
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: history **对象**
- en: This hierarchy provides several infrequently used methods for moving through
    the per-window browsing history, in a manner similar to clicking the “back” and
    “forward” buttons in the browser UI. It is not possible to directly examine any
    of the previously visited URLs; the only option is to navigate to the history
    blindly by providing numerical offsets, such as *history.go(-2)*. (Some recent
    additions to this hierarchy will be discussed in [Chapter 17](ch17.html "Chapter 17. Other
    Browser Mechanisms of Note").)
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层次结构提供了几个不常使用的方法，用于在窗口浏览历史中移动，其方式类似于在浏览器UI中点击“后退”和“前进”按钮。无法直接检查任何之前访问的URL；唯一的选择是通过提供数值偏移量，如
    *history.go(-2)*，盲目地导航到历史记录。（关于这个层次结构的一些最近添加的内容将在第17章[Chapter 17](ch17.html "Chapter 17. Other
    Browser Mechanisms of Note")中讨论。）
- en: screen **object**
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: screen **对象**
- en: A basic API for examining the dimensions of the screen and the browser window,
    monitor DPI, color depth, and so on. This is offered to help websites optimize
    the presentation of a page for a particular display device.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的API用于检查屏幕和浏览器窗口的尺寸，监视DPI、颜色深度等。这有助于网站优化特定显示设备的页面展示。
- en: navigator **object**
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: navigator **对象**
- en: An interface for querying the browser version, the underlying operating system,
    and the list of installed plug-ins.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于查询浏览器版本、底层操作系统和已安装插件列表的接口。
- en: document **object**
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: document **对象**
- en: By far the most complex of the hierarchies, this is a doorway to the Document
    Object Model^([[151](pr03.html#ftn.CHP-6-FT-6)]) of the current page; we will
    have a look at this model in the following section. A couple of functions not
    related to document structure also appear under the *document* hierarchy, usually
    due to arbitrary design decisions. Examples include *document.cookie* for manipulating
    cookies, *document.write(...)* for appending HTML to the current page, and *document.execCommand(...)*
    for performing certain WYSIWYG editing tasks.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最复杂的层次结构之一，是进入当前页面文档对象模型（Document Object Model）的入口；我们将在下一节中查看这个模型。在 *document*
    层次结构下还出现了一些与文档结构无关的函数，通常是由于任意的设计决策。例如，*document.cookie* 用于操作cookie，*document.write(...)*
    用于将HTML附加到当前页面，以及 *document.execCommand(...)* 用于执行某些所见即所得（WYSIWYG）编辑任务。
- en: Note
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Interestingly, the information available through the *navigator* and *screen*
    objects is sufficient to uniquely fingerprint many users with a high degree of
    confidence. This long-known property is emphatically demonstrated by *Panopticlick*,
    a project of the Electronic Frontier Foundation: [https://panopticlick.eff.org/](https://panopticlick.eff.org/).'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，通过 *navigator* 和 *screen* 对象可获得的信息足以以高置信度唯一标识许多用户。这个早已为人所知的属性通过电子前沿基金会（Electronic
    Frontier Foundation）的项目 *Panopticlick* 得到强调：[https://panopticlick.eff.org/](https://panopticlick.eff.org/)。
- en: Several other language-mandated objects offer simple string-processing or arithmetic
    capabilities. For example, *Math.random()* implements an unsafe, predictable pseudo-random
    number generator (a safe PRNG alternative is unfortunately not available at this
    time in most browsers^([[33](#ftn.CHP-6-FN-4)])), while *String.fromCharCode()*
    can be used to convert numerical values into Unicode strings. In privileged execution
    contexts, which are not reachable by normal web applications, a fair number of
    other task-specific objects will also appear.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 几种其他由语言强制规定的对象提供了简单的字符串处理或算术功能。例如，*Math.random()* 实现了一个不安全、可预测的伪随机数生成器（遗憾的是，在大多数浏览器中目前还没有安全的PRNG替代方案^([[33](#ftn.CHP-6-FN-4)]))，而
    *String.fromCharCode()* 可以用来将数值转换为Unicode字符串。在特权执行上下文中，这些上下文无法被普通网络应用程序访问，还将出现许多其他特定任务的对象。
- en: Note
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When accessing any of the browser-supplied objects, it is important to remember
    that while JavaScript does not use NUL-terminated ASCIZ strings, the underlying
    browser (written in C or C++) sometimes will. Therefore, the outcomes of assigning
    NUL-containing strings to various DOM properties, or supplying them to native
    functions, may be unpredictable and inconsistent. Almost all browsers truncate
    assignments to *location.** at NUL, but only some engines will do the same when
    dealing with DOM **.innerHTML*.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问任何浏览器提供的对象时，重要的是要记住，虽然 JavaScript 不使用以 NUL 结尾的 ASCIZ 字符串，但底层浏览器（用 C 或 C++
    编写）有时会这样做。因此，将包含 NUL 的字符串分配给各种 DOM 属性，或提供给原生函数的结果可能是不可预测和不一致的。几乎所有浏览器都会在 *location.*
    的分配处截断，但只有一些引擎在处理 DOM **.innerHTML** 时会这样做。
- en: The Document Object Model
  id: totrans-824
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档对象模型
- en: The Document Object Model, accessible through the *document* hierarchy, provides
    a structured, in-memory representation of the current document as mapped out by
    the HTML parser. The resulting object tree exposes all HTML elements on the page,
    their tag-specific methods and properties, and the associated CSS data. This representation,
    not the original HTML source, is used by the browser to render and update the
    currently displayed document.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对象模型（Document Object Model），通过 *document* 层级结构可访问，提供了当前文档的结构化、内存表示，该表示由 HTML
    解析器映射。生成的对象树公开了页面上的所有 HTML 元素、它们的特定于标签的方法和属性以及相关的 CSS 数据。这种表示，而不是原始的 HTML 源代码，被浏览器用于渲染和更新当前显示的文档。
- en: 'JavaScript can access the DOM in a very straightforward way, similarly to any
    normal objects. For example, the following snippet will go to the fifth tag within
    the document’s *<body>* block, look up the first nested subtag, and set that element’s
    CSS color to red:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可以以非常直接的方式访问 DOM，类似于任何普通对象。例如，以下代码片段将访问文档的 *<body>* 块内的第五个标签，查找第一个嵌套子标签，并将该元素的
    CSS 颜色设置为红色：
- en: '[PRE79]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To avoid having to waddle through the DOM tree in order to get to a particular
    deeply nested element, the browser provides several documentwide lookup functions,
    such as *getElementById(...)* and *getElementsByTagName(...)*, as well as partly
    redundant grouping mechanisms such as *frames[]*, *images[]*, or *forms[]*. These
    features permit syntax such as the following two lines of code, both of which
    directly reference an element no matter where in the document hierarchy it happens
    to appear:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在 DOM 树中跋涉以到达特定的深层嵌套元素，浏览器提供了几个全局查找函数，例如 *getElementById(...)* 和 *getElementsByTagName(...)*，以及部分冗余的分组机制，如
    *frames[]*, *images[]*, 或 *forms[]*。这些功能允许以下两行代码的语法，这两行代码都直接引用一个元素，无论它在文档层次结构中的位置如何：
- en: '[PRE80]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For legacy reasons, the names of certain HTML elements (*<img>*, *<form>*,
    *<embed>*, *<object>*, and *<applet>*) are also directly mapped to the *document*
    namespace, as illustrated in the following snippet:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，某些 HTML 元素（如 *<img>*, *<form>*, *<embed>*, *<object>*, 和 *<applet>*)
    的名称也直接映射到 *document* 命名空间，如下面的代码片段所示：
- en: '[PRE81]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Unlike in the more reasonable case of *name* and *id* mapping in the global
    namespace (see previous section), such *document* entries may clobber built-in
    functions and objects such as *getElementById* or *body*. Therefore, permitting
    user-specified tag names, for example for the purpose of constructing forms, can
    be unsafe.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局命名空间中更合理的 *name* 和 *id* 映射的情况不同（见上一节），这样的 *document* 条目可能会覆盖内置函数和对象，如 *getElementById*
    或 *body*。因此，允许用户指定的标签名称，例如用于构建表单，可能是不安全的。
- en: 'In addition to providing access to an abstract representation of the document,
    many DOM nodes may expose properties such as *innerHTML* and *outerHTML*, which
    permit a portion of the document tree to be read back as a well-formed, serialized
    HTML string. Interestingly, the same property can be written to in order to replace
    any portion of the DOM tree with the result of parsing a script-supplied snippet
    of HTML. One example of that last use is this:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供对文档的抽象表示的访问外，许多 DOM 节点还可能公开 *innerHTML* 和 *outerHTML* 等属性，这些属性允许将文档树的一部分读取为格式良好的、序列化的
    HTML 字符串。有趣的是，相同的属性可以写入以替换 DOM 树的任何部分，并用解析脚本提供的 HTML 片段的结果来替换。以下是一个该用途的例子：
- en: '[PRE82]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Every assignment to *innerHTML* must involve a well-formed and self-contained
    block of HTML that does not alter the document hierarchy outside the substituted
    fragment. If this condition is not met, the input will be coerced to a well-formed
    syntax before the substitution takes place. Therefore, the following example will
    not work as expected; that is, it will not display “Hi mom!” in bold and will
    not put the remainder of the document in italics:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对 *innerHTML* 的赋值都必须涉及一个格式良好且自包含的 HTML 块，该块不会改变替换片段之外的文档层次结构。如果不符合此条件，输入将在替换之前被强制转换为格式良好的语法。因此，以下示例将不会按预期工作；也就是说，它不会以粗体显示“Hi
    mom!”，也不会将文档的其余部分以斜体显示：
- en: '[PRE83]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Instead, each of these two assignments will be processed and corrected individually,
    resulting in a behavior equivalent to this:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这两个赋值将分别处理和纠正，从而产生相当于以下的行为：
- en: '[PRE84]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'It is important to note that the *innerHTML* mechanism should be used with
    extreme caution. In addition to being inherently prone to markup injection if
    proper HTML escaping is not observed, browser implementations of the DOM-to-HTML
    serialization algorithms are often imperfect. A recent (now fixed) example of
    such a problem in WebKit^([[152](pr03.html#ftn.CHP-6-FT-7)]) is illustrated here:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，*innerHTML* 机制应谨慎使用。除了如果未观察到适当的 HTML 转义，其本身容易受到标记注入的影响外，浏览器对 DOM 到 HTML
    序列化算法的实现通常也不完美。以下是一个近期（现已修复）的 WebKit 中的此类问题示例：
- en: '[PRE85]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Because of the confusion over the semantics of *<textarea>*, this seemingly
    unambiguous input markup, when parsed to a DOM tree and then accessed through
    *innerHTML*, would be incorrectly read back as:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对 *<textarea>* 语义的混淆，这个看似明确的输入标记，在解析为 DOM 树并通过 *innerHTML* 访问时，会被错误地读取为：
- en: '[PRE86]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In such a situation, even performing a no-op assignment of this serialization
    (such as *some_element.innerHTML += ""*) would lead to unexpected script injection.
    Similar problems tend to plague other browsers, too. For example, Internet Explorer
    developers working on the *innerHTML* code were unaware that MSHTML recognizes
    backticks (`) as quote characters and so ended up handling them incorrectly. In
    their implementation, the following markup:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使执行此序列化的无操作赋值（如 *some_element.innerHTML += ""*），也可能导致意外的脚本注入。类似的问题也常常困扰其他浏览器。例如，正在处理
    *innerHTML* 代码的 Internet Explorer 开发者没有意识到 MSHTML 将反引号（`）识别为引号字符，因此最终处理错误。在他们的实现中，以下标记：
- en: '[PRE87]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'would be reserialized as this:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 将被重新序列化为以下形式：
- en: '[PRE88]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Individual bugs aside, the situation with *innerHTML* is pretty dire: Section
    10.3 of the current draft of HTML5 simply acknowledges that certain script-created
    DOM structures are completely impossible to serialize to HTML and does not require
    browsers to behave sensibly in such a case. *Caveat emptor!*'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 除去个别错误，关于 *innerHTML* 的情况相当严峻：HTML5 当前草案的 10.3 节只是承认某些由脚本创建的 DOM 结构完全无法序列化为
    HTML，并且不要求浏览器在这种情况下做出合理的反应。*买者自慎！*
- en: Access to Other Documents
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问其他文档
- en: 'Scripts may come into possession of object handles that point to the root hierarchy
    of another scripting context. For example, by default, every context can readily
    reference *parent*, *top*, *opener*, and *frames[]*, all supplied to it in the
    top-level object. Calling the *window.open(...)* function to create a new window
    will also return a reference, and so will an attempt to look up an existing named
    window using this syntax:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可能会获得指向另一个脚本上下文根层次结构的对象句柄。例如，默认情况下，每个上下文都可以轻松地引用 *parent*、*top*、*opener* 和
    *frames[]*，这些都在顶层对象中提供给它。调用 *window.open(...)* 函数创建新窗口也会返回一个引用，同样，尝试使用此语法查找现有命名窗口也会返回引用：
- en: '[PRE89]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Once the program holds a handle pointing to another scripting context, it may
    attempt to interact with that context, subject to security checks discussed in
    [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic"). An example of a simple
    interaction might be as follows:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序持有指向另一个脚本上下文的句柄，它可能会尝试与该上下文交互，但需遵守第 9 章中讨论的安全检查。[第 9 章](ch09.html "第 9 章。内容隔离逻辑")。一个简单的交互示例可能如下：
- en: '[PRE90]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: or
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE91]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the absence of a valid handle, JavaScript-level interaction with an unrelated
    document should not be possible. In particular, there is no way to look up unnamed
    windows opened in completely separate navigation flows, at least until their name
    is explicitly set by one of the visited pages (the *window.name* property permits
    this).
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有有效句柄的情况下，与无关文档的JavaScript级别交互不应可能。特别是，无法查找在完全不同的导航流程中打开的无名窗口，至少直到其中一个访问的页面明确设置了它们的名称（*window.name*
    属性允许这样做）。
- en: '* * *'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[33](#CHP-6-FN-4)]) There are a recently added *window.crypto.getRandomValues(...)*
    API in Chrome and a currently nonoperational *window.crypto.random(...)* API in
    Firefox.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[33](#CHP-6-FN-4)]) Chrome中最近添加了 *window.crypto.getRandomValues(...)* API，而Firefox中目前不可用的
    *window.crypto.random(...)* API。 '
- en: Script Character Encoding
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本字符编码
- en: 'JavaScript engines support several familiar, backslash-based string-encoding
    methods that can be employed to escape quote characters, HTML markup, and other
    problematic bits in the embedded text. These methods are as follows:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎支持几种熟悉的基于反斜杠的字符串编码方法，可以用来转义引号字符、HTML标记和其他嵌入文本中的问题部分。这些方法如下：
- en: 'C-style shorthand notation for certain control characters: *\b* for backspace,
    *\t* for horizontal tab, *\v* for vertical tab, *\f* for form feed, *\r* for CR,
    and *\n* for LF. This exact set of escape codes is recognized by both ECMAScript
    and the JSON RFC.'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些控制字符的C风格简写表示法：*\b* 表示退格，*\t* 表示水平制表符，*\v* 表示垂直制表符，*\f* 表示换页，*\r* 表示回车，*\n*
    表示换行。这个精确的转义码集合被ECMAScript和JSON RFC都识别。
- en: Three-digit, zero-padded, 8-bit octal character codes with no prefix (such as
    “\145” instead of “e”). This C-inspired syntax is not a part of ECMAScript but
    is in practice supported by all scripting engines, both in normal code and in
    *JSON.parse(...)*.
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无前缀的三位、零填充的8位八进制字符码（例如，“\145”而不是“e”）。这种受C语言启发的语法不是ECMAScript的一部分，但在实践中所有脚本引擎都支持它，无论是在普通代码中还是在
    *JSON.parse(...)* 中。
- en: Two-digit, zero-padded, 8-bit hexadecimal character codes, prefixed with “x”
    (“e” becomes “\x65”). Again, this scheme is not endorsed by ECMAScript or RFC
    4627, but having its roots in the C language, it is widely supported in practice.
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀为“x”的两位、零填充的8位十六进制字符码（“e”变为“\x65”）。同样，这个方案既不被ECMAScript也不被RFC 4627所支持，但它起源于C语言，在实践中被广泛支持。
- en: Four-digit, zero-padded, 16-bit hexadecimal Unicode values, prefixed with “u”
    (“e” turns into “\u0065”). This format is sanctioned by ECMAScript and RFC 4627
    and is supported by all modern browsers.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀为“u”的两位、零填充的16位十六进制Unicode值（“e”变为“\u0065”）。这种格式被ECMAScript和RFC 4627所认可，并且所有现代浏览器都支持。
- en: A backslash followed by any character other than an octal digit; “b”, “t”, “v”,
    “f”, “r,” or “n” characters used for other predefined escape sequences; and “x”
    or “u”. In this scheme, the subsequent character will be treated as a literal.
    ECMAScript permits this scheme to be used to escape only quotes and the backslash
    character itself, but in practice, any other value is accepted as well.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后跟非八进制数字的任何字符；用于其他预定义转义序列的“b”、“t”、“v”、“f”、“r”或“n”字符；以及“x”或“u”。在这个方案中，后续字符将被视为字面量。ECMAScript允许使用此方案来转义引号和反斜杠字符本身，但在实践中，任何其他值也被接受。
- en: This approach is somewhat error prone, and as in the case of CSS, it should
    not be used to escape angle brackets and other HTML syntax delimiters. This is
    because JavaScript parsing takes place after HTML parsing, and the backslash prefix
    will be not treated in any special way by the HTML parser itself.
  id: totrans-865
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法有一定的错误倾向，并且与CSS的情况类似，不应用来转义尖括号和其他HTML语法分隔符。这是因为JavaScript解析发生在HTML解析之后，反斜杠前缀本身不会被HTML解析器以任何特殊方式处理。
- en: Note
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Somewhat inexplicably, Internet Explorer does not recognize the vertical tab
    (“\v”) shorthand, thereby creating one of the more convenient (but very naughty!)
    ways to test for that particular browser:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 令人费解的是，Internet Explorer 不识别垂直制表符（“\v”）简写，从而创造了一种更方便（但非常淘气！）的测试该特定浏览器的方法：
- en: '[PRE92]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Surprisingly, the Unicode-based escaping method (but not the other ones) is
    also recognized outside strings. Although the idea seems arbitrary, the behavior
    is a bit more sensible than with CSS: Escape codes can be used only in identifiers,
    and they will not work as a substitute for any syntax-sensitive symbols. Therefore,
    the following is possible:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 意外地，基于Unicode的转义方法（但不包括其他方法）也在字符串之外被识别。尽管这个想法似乎很随意，但与CSS相比，行为要合理一些：转义码只能在标识符中使用，并且不能作为任何语法敏感符号的替代。因此，以下是可以的：
- en: '[PRE93]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: On the other hand, any attempt to substitute the parentheses or quotes in a
    similar fashion would fail.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，任何以类似方式替换括号或引号的行为都会失败。
- en: 'Unlike in some C or C++ implementations, stray multiline string literals are
    not tolerated by any JavaScript engine. That said, despite a strongly worded prohibition
    in ECMAScript specs, there is one exception: A lone backslash at the end of a
    line may be used to join multiline literals seamlessly. This behavior is illustrated
    below:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些 C 或 C++ 实现 不同，JavaScript 引擎不容忍多余的多行字符串字面量。话虽如此，尽管 ECMAScript 规范中有明确的禁止，但有一个例外：行尾的单个反斜杠可以用来无缝连接多行字面量。以下是一个示例：
- en: '[PRE94]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Code Inclusion Modes and Nesting Risks
  id: totrans-874
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码包含模式及嵌套风险
- en: 'As should be evident from the earlier discussions in this chapter, there are
    several ways to execute scripts in the context of the current page. It is probably
    useful to enumerate some of the most common ones:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面的讨论所示，有几种方法可以在当前页面的上下文中执行脚本。可能有用的是列举一些最常见的方法：
- en: Inline *<script>* blocks
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联 *<script>* 块
- en: Remote scripts loaded with *<script src=...>*^([[34](#ftn.CHP-6-FN-5)])
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *<script src=...>* 加载的远程脚本^([[34](#ftn.CHP-6-FN-5)])
- en: '*javascript:* URLs in various HTML parameters and in CSS'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*javascript:* 在各种 HTML 参数和 CSS 中的 URL'
- en: CSS *expression(...)* syntax and XBL bindings in certain browsers
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些浏览器的 CSS *expression(...)* 语法和 XBL 绑定
- en: Event handlers (*onload*, *onerror*, *onclick*, etc.)
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器 (*onload*, *onerror*, *onclick*, 等)
- en: Timers (*setTimeout*, *setInterval)*
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器 (*setTimeout*, *setInterval)*
- en: '*eval(...)* calls'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*eval(...)* 调用'
- en: 'Combining these methods often seems natural, but doing so can create very unexpected
    and dangerous parsing chains. For example, consider the transformation that would
    need to be applied to the value inserted by the server in place of *user_string*
    in this code:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些方法结合起来通常看起来很自然，但这样做可能会创建非常意外且危险的分析链。例如，考虑需要对服务器插入的值应用于此代码中 *user_string*
    的转换：
- en: '[PRE95]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: It is often difficult to notice that the value will go through no fewer than
    three rounds of parsing! First, the HTML parser will extract the *onclick* parameter
    and put it into DOM; next, when the button is clicked, the first round of JavaScript
    parsing will extract the *setTimeout(...)* syntax; and finally, one second after
    the initial click, the actual *do_stuff(...)* sequence will be parsed and executed.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 很难注意到值将经过不少于三轮的解析！首先，HTML 解析器将提取 *onclick* 参数并将其放入 DOM；接下来，当按钮被点击时，第一轮 JavaScript
    解析将提取 *setTimeout(...)* 语法；最后，在初始点击后一秒钟，实际的 *do_stuff(...)* 序列将被解析并执行。
- en: Therefore, in the example above, in order to survive the process, *user_string*
    needs to be double-encoded using JavaScript backslash sequences, and then encoded
    again using HTML entities, in that exact order. Any different approach will likely
    lead to code injection.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上面的例子中，为了在过程中幸存下来，*user_string* 需要使用 JavaScript 反斜杠序列进行双重编码，然后使用 HTML 实体再次编码，顺序必须完全一致。任何不同的方法都可能引发代码注入。
- en: 'Another tricky escaping situation is illustrated here:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个展示复杂转义情况的示例：
- en: '[PRE96]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Even though the initial assignment of *some_value* requires *user_string* to
    be escaped just once, the subsequent ad hoc construction of a second-order script
    in the *setTimeout(...)* parameter introduces a vulnerability if no additional
    escaping is applied beforehand.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 *some_value* 的初始赋值只需要对 *user_string* 进行一次转义，但在 *setTimeout(...)* 参数中构建的二级脚本在事先没有进行额外转义的情况下会引入漏洞。
- en: Such coding patterns happen frequently in JavaScript programs, and they are
    very easy to miss. It is much better to consistently discourage them than to audit
    the resulting code.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的编码模式在 JavaScript 程序中经常出现，而且很容易被忽略。一致地禁止它们比审计产生的代码要好得多。
- en: '* * *'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[34](#CHP-6-FN-5)]) On both types of *<script>* blocks, Microsoft supports
    a pseudo-dialect called *JScript.Encode*. This mode can be selected by specifying
    a *language* parameter on the *<script>* tag and simply permits the actual script
    to be encoded using a trivial alphabet substitution cipher to make it unreadable
    to casual users. The mechanism is completely worthless from the security standpoint,
    as the “encryption” can be reverted easily.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#CHP-6-FN-5)]) 在两种类型的 *<script>* 块中，Microsoft 支持一种称为 *JScript.Encode*
    的伪方言。可以通过在 *<script>* 标签上指定 *language* 参数来选择此模式，它简单地允许使用简单的字母替换密码对实际脚本进行编码，使其对普通用户不可读。从安全角度来看，这种机制完全无价值，因为“加密”可以很容易地恢复。
- en: 'The Living Dead: Visual Basic'
  id: totrans-893
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活着的死者：Visual Basic
- en: Having covered most of the needed ground related to JavaScript, it’s time for
    an honorable mention of the long-forgotten contender for the scripting throne.
    Despite 15 years of lingering in almost complete obscurity, browser-side VBScript
    is still supported in Internet Explorer. In most aspects, Microsoft’s language
    is supposed to be functionally equivalent to JavaScript, and it has access to
    exactly the same Document Object Model APIs and other built-in functions as JavaScript.
    But, as one might expect, some tweaks and extensions are present—for example,
    a couple of VB-specific functions in place of the JavaScript built-ins.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了与JavaScript相关的绝大部分内容后，现在是时候对那个长期被遗忘的脚本王位竞争者表示敬意了。尽管在几乎完全被遗忘的状态中徘徊了15年，但浏览器端的VBScript在Internet
    Explorer中仍然得到支持。在大多数方面，Microsoft的语言应该与JavaScript功能上等效，并且它能够访问与JavaScript完全相同的Document
    Object Model API和其他内置函数。但是，正如人们所预期的，一些调整和扩展是存在的——例如，用几个VB特定的函数替换JavaScript的内置函数。
- en: There is virtually no research into the security properties of VBScript, the
    robustness of the parser, or its potential incompatibilities with the modern DOM.
    Anecdotal evidence suggests that the language receives no consistent scrutiny
    on Microsoft’s end, either. For example, the built-in *MsgBox*^([[153](pr03.html#ftn.CHP-6-FT-8)])
    can be used to display modal, always-on-top prompts with a degree of flexibility
    completely unheard of in the JavaScript world, leaving *alert(...)* in the dust.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有研究VBScript的安全属性、解析器的健壮性或其与现代DOM的潜在不兼容性。轶事证据表明，该语言在Microsoft端也没有得到一致的审查。例如，内置的*MsgBox*^([[153](pr03.html#ftn.CHP-6-FT-8)])可以用来显示具有一定程度灵活性的模态、始终在顶部的提示，这在JavaScript世界中是完全闻所未闻的，让*alert(...)*相形见绌。
- en: It is difficult to predict how long VBScript will continue to be supported in
    this browser and what unexpected consequences for user and web application security
    it is yet to have. Only time will tell.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 预测VBScript在这个浏览器中还将支持多久以及它对用户和Web应用安全可能产生的意外后果是困难的。只有时间才能告诉我们。
- en: Security Engineering Cheat Sheet
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Loading Remote Scripts
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载远程脚本时
- en: As with CSS, you are linking the security of your site to the originating domain
    of the script. When in doubt, make a local copy of the data instead. On HTTPS
    sites, require all scripts to be served over HTTPS.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS一样，你将你站点的安全性链接到脚本的原始域名。如有疑问，请制作数据的本地副本。在HTTPS站点上，要求所有脚本通过HTTPS提供服务。
- en: When Parsing JSON Received from the Server
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析从服务器接收到的JSON时
- en: Rely on *JSON.parse(...)* where supported. Do not use *eval(...)* or the *eval*-based
    implementation provided in RFC 4627\. Both are unsafe, especially when processing
    data from third parties. A later implementation from the author of RFC 4627, *json2.js*,^([[154](pr03.html#ftn.CHP-6-FT-9)])
    is probably okay.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的地方依赖*JSON.parse(...)*。不要使用*eval(...)*或RFC 4627中提供的基于*eval*的实现。两者都不安全，尤其是在处理第三方数据时。RFC
    4627的作者的一个后续实现，*json2.js*^([[154](pr03.html#ftn.CHP-6-FT-9)])可能没问题。
- en: When Putting User-Supplied Data Inside JavaScript Blocks
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 当在JavaScript块中放置用户提供的数据时
- en: '**Stand-alone strings in** <script> **blocks:** Backslash-escape all control
    characters (0x00 - 0x1F), “\”, “<”, “>”, and quotes using numerical codes. It
    is also preferable to escape high-bit characters.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<script>块中的独立字符串：**使用数字代码转义所有控制字符（0x00 - 0x1F）、“\”， “<”， “>”和引号。还最好转义高位字符。'
- en: Do not rely on user-supplied strings to construct dynamic HTML. Always use safe
    DOM features such as *innerText* or *createTextNode(...)* instead. Do not use
    user-supplied strings to construct second-order scripts; avoid *eval(...)*, *setTimeout(...)*,
    and so on.
  id: totrans-904
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要依赖于用户提供的字符串来构建动态HTML。始终使用安全的DOM功能，如*innerText*或*createTextNode(...)*，而不是使用用户提供的字符串来构建二阶脚本；避免使用*eval(...)*、*setTimeout(...)*等。
- en: '**Stand-alone strings in separately served scripts:** Follow the same rules
    as for *<script>* blocks. If your scripts contain any sensitive, user-specific
    information, be sure to account for cross-site script inclusion risks; use reliable
    parser-busting prefixes, such as “)}]'' \n”, near the beginning of a file or,
    at the very minimum, use a proper JSON serialization with no padding or other
    tweaks. Additionally, consult [Chapter 13](ch13.html "Chapter 13. Content Recognition
    Mechanisms") for tips on how to prevent cross-site scripting in non-HTML content.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立于单独提供的脚本中的字符串：**遵循与*<script>*块相同的规则。如果您的脚本包含任何敏感的、用户特定的信息，请确保考虑到跨站脚本包含的风险；在文件开头附近使用可靠的解析器破坏前缀，例如“)}]''
    \n”，或者在最低限度内，使用没有填充或其他调整的正确JSON序列化。此外，请参阅[第13章](ch13.html "第13章。内容识别机制")以获取有关如何防止非HTML内容中的跨站脚本的建议。'
- en: '**Strings in inlined event handlers**, javascript: **URLs, and so on:** Multiple
    levels of escaping are involved. Do not attempt this because it is error prone.
    If unavoidable, apply the above JS escaping rules first and then apply HTML or
    URL parameter encoding, as applicable, to the resulting string. Never use in conjunction
    with *eval(...)*, *setTimeout(...)*, *innerHTML*, and such.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联事件处理器中的字符串**、javascript: **URLs**和如此等等：涉及多级转义。不要尝试这样做，因为它容易出错。如果不可避免，首先应用上述JS转义规则，然后根据适用情况对结果字符串应用HTML或URL参数编码。永远不要与*eval(...)*、*setTimeout(...)*、*innerHTML*等一起使用。'
- en: '**Nonstring content:** Allow only whitelisted alphanumeric keywords and carefully
    validated numerical values. Do not attempt to reject known bad patterns instead.'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非字符串内容：**仅允许白名单中的字母数字关键字和经过仔细验证的数值。不要尝试拒绝已知的坏模式。'
- en: When Interacting with Browser Objects on the Client Side
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 当与客户端上的浏览器对象交互时
- en: '**Generating HTML content on the client side:** Do not resort to *innerHTML*,
    *document.write(...)*, and similar tools because they are prone to introducing
    cross-site scripting flaws, often in unexpected ways. Use safe methods such as
    *createElement(...)* and *appendChild(...)* and properties such as *innerText*
    or *textContent* to construct the document instead.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在客户端生成HTML内容：**不要求助于*innerHTML*、*document.write(...)*和类似的工具，因为它们容易引入跨站脚本漏洞，通常以意想不到的方式。使用安全的方法，如*createElement(...)*和*appendChild(...)*以及*innerText*或*textContent*属性来构建文档。'
- en: '**Relying on user-controlled data:** Make no assumptions about the escaping
    rules applied to any values read back from the browser and, in particular, to
    *location* properties and other external sources of URLs, which are inconsistent
    and vary from one implementation to another. Always do your own escaping.'
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖于用户控制的数据：**对从浏览器读取的任何值应用的转义规则不要做任何假设，特别是对*location*属性和其他外部URL来源，这些属性不一致，并且因实现而异。始终自行转义。'
- en: If You Want to Allow User-Controlled Scripts on Your Page
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在您的页面上允许用户控制的脚本
- en: It is virtually impossible to do this safely. Experimental JavaScript rewriting
    frameworks, such as Caja ([http://code.google.com/p/google-caja/](http://code.google.com/p/google-caja/)),
    are the only portable option. Also see [Chapter 16](ch16.html "Chapter 16. New
    and Upcoming Security Features") for information on sandboxed frames, an upcoming
    alternative for embedding untrusted gadgets on web pages.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上几乎不可能安全地做到这一点。像Caja（[http://code.google.com/p/google-caja/](http://code.google.com/p/google-caja/））这样的实验性JavaScript重写框架是唯一的便携式选择。有关沙箱框架的信息，请参阅[第16章](ch16.html
    "第16章。新和即将推出的安全功能")，这是在网页上嵌入不受信任的小工具的即将推出的替代方案。
- en: Chapter 7. Non-HTML Document Types
  id: totrans-913
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。非HTML文档类型
- en: In addition to HTML documents, about a dozen other file formats are recognized
    and displayed by the rendering engines of modern web browsers; a list that is
    likely to grow over time.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 除了HTML文档之外，现代网络浏览器的渲染引擎还识别并显示大约十几种其他文件格式；这个列表可能会随着时间的推移而增长。
- en: Because of the powerful scripting capabilities available in some of these formats,
    and because of the antics of browser-content handling, the set of natively supported
    non-HTML inputs deserves a closer examination at this point, even if a detailed
    discussion of some of their less-obvious security consequences—such as *content
    sniffing*—will have to wait until [Part II](pt02.html "Part II. Browser Security
    Features") of this book.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些格式中一些格式强大的脚本功能，以及浏览器内容处理的怪异行为，原生支持的非HTML输入集值得在此进行更仔细的检查，即使对它们一些不太明显的安全后果的详细讨论——例如*内容嗅探*——将不得不等到本书的[第二部分](pt02.html
    "第二部分。浏览器安全功能")。
- en: Plaintext Files
  id: totrans-916
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯文本文件
- en: Perhaps the most prosaic type of non-HTML document recognized by every single
    browser is a plaintext file. In this rendering mode, the input is simply displayed
    as is, typically using a nonproportional typeface, and save for optional character
    set transcoding, the data is not altered in any way.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器都能识别的最常见的非HTML文档类型是纯文本文件。在这种渲染模式下，输入内容会原样显示，通常使用非等宽字体，除非进行可选的字符集转换，否则数据不会以任何方式改变。
- en: 'All browsers recognize plaintext files served with *Content-Type: text/plain*
    in the HTTP headers. In all implementations but Internet Explorer, plaintext is
    also the fallback display method for headerless HTTP/0.9 responses and HTTP/1.*x*
    data with *Content-Type* missing; in both these cases, plaintext is used when
    all other content detection heuristics fail. (Internet Explorer unconditionally
    falls back to HTML rendering, true to the letter of Tim Berners-Lee’s original
    protocol drafts.)'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '所有浏览器都识别HTTP头中带有`Content-Type: text/plain`的纯文本文件。在所有实现中，除了Internet Explorer之外，纯文本也是无头HTTP/0.9响应和缺少`Content-Type`的HTTP/1.*x*数据的回退显示方法；在这两种情况下，当所有其他内容检测启发式方法失败时，都会使用纯文本。
    (Internet Explorer无条件地回退到HTML渲染，这符合蒂姆·伯纳斯-李原始协议草案的字面意思。)'
- en: For the convenience of developers, most browsers also automatically map several
    other MIME types, including *application/javascript* and friends^([[35](#ftn.CHP-7-FN-1)])
    or *text/css*, to plaintext. Interestingly, *application/json*, the value mandated
    for JSON responses in RFC 4627, is not on the list (perhaps because it is seldom
    used in practice).
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便开发者，大多数浏览器还自动将几个其他MIME类型映射到纯文本，包括`application/javascript`及其相关类型^([[35](#ftn.CHP-7-FN-1)])或`text/css`。有趣的是，RFC
    4627中规定的JSON响应的值`application/json`并不在列表中（可能是因为在实践中很少使用）。
- en: Plaintext rendering has no specific security consequences. That said, due to
    a range of poor design decisions in other browser components and in third-party
    code, even seemingly harmless non-HTML formats are at a risk of being misidentified
    as, for example, HTML. Attacker-controlled plaintext documents are of special
    concern because their layout is often fairly unconstrained and therefore particularly
    conducive to being misidentified. [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms") dissects these threats and provides advice on how to
    mitigate the risk.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本渲染没有特定的安全后果。尽管如此，由于其他浏览器组件和第三方代码中存在一系列设计不当的决定，即使是看似无害的非HTML格式也有被错误识别为HTML的风险。攻击者控制的纯文本文档尤其值得关注，因为它们的布局通常相当不受限制，因此特别容易发生误识别。[第13章](ch13.html
    "第13章。内容识别机制")分析了这些威胁，并提供了减轻风险的建议。
- en: '* * *'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[35](#CHP-7-FN-1)]) The official MIME type for JavaScript is *application/javascript*,
    as per RFC 4329, but about a dozen other values have been used in the past (e.g.,
    *text/javascript, application/x-javascript, application/ecmascript*).
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#CHP-7-FN-1)]) 根据RFC 4329，JavaScript的官方MIME类型是`application/javascript`，但过去曾使用过大约十种其他值（例如，`text/javascript,
    application/x-javascript, application/ecmascript`）。
- en: Bitmap Images
  id: totrans-923
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位图图像
- en: Browser-rendering engines recognize direct navigation to the same set of bitmap
    image formats that are normally supported in HTML documents when loaded via the
    *<img>* tag, including JPEG, PNG, GIF, BMP, and a couple more. When the user navigates
    directly to such a resource, the decoded bitmap is shown in the document window,
    allowing the user little more than the ability to scroll, zoom in and out, and
    save the file to disk.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器渲染引擎在通过`<img>`标签加载HTML文档时，会识别直接导航到一组通常支持的位图图像格式，包括JPEG、PNG、GIF、BMP以及一些其他格式。当用户直接导航到这样的资源时，解码后的位图会在文档窗口中显示，用户只能进行滚动、缩放和将文件保存到磁盘等有限操作。
- en: In the absence of *Content-Type* information, images are detected based on file
    header checks. When a *Content-Type* value is present, it is compared with about
    a dozen predefined image types, and the user is routed accordingly. But if an
    attempt to decode the image fails, file headers are used to make a second guess.
    It is therefore possible (but, for the reasons explored in [Chapter 13](ch13.html
    "Chapter 13. Content Recognition Mechanisms"), often unwise) to serve a GIF file
    as *image/jpeg*.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有`Content-Type`信息的情况下，图像的检测基于文件头检查。当存在`Content-Type`值时，它会与大约十种预定义的图像类型进行比较，并根据结果将用户路由到相应的类型。但如果解码图像失败，则会使用文件头进行第二次猜测。因此，尽管如[第13章](ch13.html
    "第13章。内容识别机制")中探讨的原因，这样做通常是不明智的，但可以将GIF文件作为`image/jpeg`提供服务。
- en: As with text files, bitmap images are a passive resource and carry no unusual
    security risks.^([[36](#ftn.CHP-7-FN-2)]) However, whenever serving user-supplied
    images, remember that attackers will have a degree of control over the data, even
    if the format is carefully validated and scaled or recompressed. Therefore, the
    concerns about such a document format being misinterpreted by a browser or a plug-in
    still remain.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 与文本文件一样，位图图像是一种被动资源，不携带任何异常的安全风险.^([[36](#ftn.CHP-7-FN-2)]) 然而，每当提供用户提交的图像时，请记住攻击者将对数据进行一定程度的控制，即使格式经过仔细验证并进行了缩放或重新压缩。因此，关于这种文档格式可能被浏览器或插件错误解释的担忧仍然存在。
- en: '* * *'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[36](#CHP-7-FN-2)]) Naturally, exploitable coding errors occasionally happen
    in all programs that deal with complex data formats, and image parsers are no
    exception.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#CHP-7-FN-2)]) 自然，处理复杂数据格式的所有程序中偶尔都会发生可利用的编码错误，图像解析器也不例外。
- en: Audio and Video
  id: totrans-929
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频和视频
- en: For a very long time, browsers had no built-in support for playing audio and
    video content, save for an obscure and oft-ridiculed *<bgsound>* tag in Internet
    Explorer, which to this day can be used to play simple MID or WAV files. In the
    absence of real, cross-browser multimedia playback functionality, audio and video
    were almost exclusively the domain of browser plug-ins, whether purpose-built
    (such as Windows Media Player or Apple QuickTime) or generic (Adobe Flash, Microsoft
    Silverlight, and so on).
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间内，浏览器没有内置支持播放音频和视频内容的功能，除了在 Internet Explorer 中一个晦涩且常被嘲讽的 *<bgsound>*
    标签，它至今仍可用于播放简单的 MID 或 WAV 文件。在没有真正的跨浏览器多媒体播放功能的情况下，音频和视频几乎完全由浏览器插件掌控，无论是专门构建的（如
    Windows Media Player 或 Apple QuickTime）还是通用的（如 Adobe Flash、Microsoft Silverlight
    等）。
- en: 'The ongoing work on HTML5 seeks to change this through support for *<audio>*
    and *<video>* tags: convenient, scriptable methods to interface with built-in
    media decoders. Unfortunately, there is substantial vendor-level disagreement
    as to which video formats to support and what patent consequences this decision
    may have. For example, while many browsers already support Ogg Theora (a free,
    open source, but somewhat niche codec), spirited arguments surrounding the merits
    of supporting the very popular but patent- and royalty-encumbered H.264 format
    and the prospects of a new, Google-backed WebM alternative will probably continue
    for the foreseeable future.'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 的工作正在寻求通过支持 *<audio>* 和 *<video>* 标签来改变这一点：方便的、可脚本化的方法来与内置媒体解码器接口。不幸的是，在支持哪些视频格式以及这一决定可能带来的专利后果方面，存在大量的供应商级别分歧。例如，尽管许多浏览器已经支持
    Ogg Theora（一个免费、开源但有些小众的编解码器），但围绕支持非常受欢迎但受专利和版税限制的 H.264 格式以及新的、谷歌支持的 WebM 替代方案的激烈争论可能会在可预见的未来继续下去。
- en: As with other passive media formats (and unlike some types of plug-in-rendered
    content!), neither *<bgsound>* nor HTML5 multimedia are expected to have any unusual
    implications for web application security, as long as the possibility of content
    misidentification is mitigated appropriately.^([[37](#ftn.CHP-7-FN-3)])
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他被动媒体格式（以及一些插件渲染的内容不同！）一样，只要适当缓解了内容误识别的可能性，*<bgsound>* 和 HTML5 多媒体都不太可能对 Web
    应用程序安全产生任何异常影响.^([[37](#ftn.CHP-7-FN-3)])
- en: '* * *'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[37](#CHP-7-FN-3)]) But some far-fetched interactions between various technologies
    are a distinct possibility. For example, what if the *<audio>* tag supports raw,
    uncompressed audio and is pointed to a sensitive nonaudio document, and then the
    proposed HTML5 microphone API is used by another website to capture the resulting
    waveform and reconstruct the contents of the file?
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[37](#CHP-7-FN-3)]) 但各种技术之间的一些牵强附会的交互是明确可能的。例如，如果 *<audio>* 标签支持原始、未压缩的音频，并且指向一个敏感的非音频文档，然后另一个网站使用提出的
    HTML5 麦克风 API 来捕获生成的波形并重建文件内容呢？
- en: XML-Based Documents
  id: totrans-935
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于XML的文档
- en: Readers who found the handling of the formats discussed so far to be too sane
    for their tastes are in for a well-deserved treat. The largest and definitely
    most interesting family of browser-supported non-HTML document types relies on
    the common XML syntax and provides more than a fair share of interesting surprises.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些认为迄今为止讨论的格式处理过于理智的读者来说，他们将得到一份应得的享受。浏览器支持的最大的、无疑也是最有意思的非 HTML 文档类型家族依赖于常见的
    XML 语法，并提供了超过公平份额的有趣惊喜。
- en: Several of the formats belonging to this category are forwarded to specialized,
    single-purpose XML analyzers, usually based on the received *Content-Type* value
    or other simple heuristics. But more commonly, the payload is routed to the same
    parser that is relied upon to render XHTML documents and then displayed using
    this common pipeline.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 属于这一类别的几种格式被转发到专门的、单一用途的XML分析器，通常基于接收到的*Content-Type*值或其他简单的启发式方法。但更常见的是，有效载荷被路由到依赖于渲染XHTML文档的相同解析器，然后使用此通用管道显示。
- en: In the latter case, the actual meaning of the document is determined by the
    URL-like *xmlns* namespace directives present in the markup itself, and the namespace
    parameter may have nothing to do with the value originally supplied in *Content-Type*.
    Quite simply, there is no mechanism that would prevent a document served as *application/mathml+xml*
    from containing nothing but XHTML markup and beginning with *<html >*.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下，文档的实际含义由标记本身中存在的类似URL的*xmlns*命名空间指令决定，命名空间参数可能与最初在*Content-Type*中提供的值无关。简单来说，没有任何机制可以阻止一个作为*application/mathml+xml*提供的文档只包含XHTML标记并以*<html
    >*开始。
- en: 'In the most common scenario, the namespace for the entire XML file is defined
    only once and is attached to the top-level tag. In principle, however, any number
    of different *xmlns* directives may appear in a single file, giving different
    meanings to each section of the document. For example:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 在最常见的情况下，整个XML文件的命名空间只定义一次，并附加到顶级标签上。然而，原则上，单个文件中可以出现任意数量的不同*xmlns*指令，为文档的每个部分赋予不同的含义。例如：
- en: '[PRE97]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Faced with such input, the general-purpose renderer will usually do its best
    to make sense of all the recognized namespaces and assemble the markup into a
    single, consistent document with a normal Document Object Model representation.
    And, if any one of the recognized namespaces happens to support scripting, any
    embedded scripts will execute, too.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这样的输入，通用渲染器通常会尽力理解所有被识别的命名空间，并将标记组装成一个具有正常文档对象模型表示的单个、一致的文档。而且，如果任何被识别的命名空间恰好支持脚本，任何嵌入的脚本也将执行。
- en: Because of the somewhat counterintuitive *xmlns* handling behavior, *Content-Type*
    is not a suitable way to control how a particular XML document will be parsed;
    the presence of a particular top-level *xmlns* directive is also not a guarantee
    that no other data formats will be honored later on. Any attacker-controlled XML-based
    formats must therefore be handled with care and sanitized very thoroughly.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*xmlns*处理行为的某种反直觉性，*Content-Type*不是控制特定XML文档如何解析的合适方式；特定顶级*xmlns*指令的存在也不能保证以后不会尊重其他数据格式。因此，任何由攻击者控制的基于XML的格式都必须谨慎处理并彻底清理。
- en: Generic XML View
  id: totrans-943
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用XML视图
- en: In most browsers, a valid XML document with no renderer-recognized namespaces
    present anywhere in the markup will be shown as an interactive, pretty-printed
    representation of the document tree, as shown in [Figure 7-1](ch07s04.html#firefox_displaying_an_xml_document_with
    "Figure 7-1. Firefox displaying an XML document with no recognized namespaces").
    This mode is not particularly useful to end users, but it can aid debugging.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数浏览器中，一个有效的XML文档，其标记中任何地方都没有解析器识别的命名空间，将显示为文档树的交互式、格式化的表示，如图[图7-1](ch07s04.html#firefox_displaying_an_xml_document_with
    "图7-1. Firefox显示没有识别命名空间的XML文档")所示。这种模式对最终用户来说并不特别有用，但它可以帮助调试。
- en: 'That said, when any of the namespaces in the document is known to the browser
    (even when the top-level one is not recognized at all!), the document will be
    rendered differently: All recognized markup will work as intended, all unsupported
    tags will simply have no effect, and any text between them will be shown as is.'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，当文档中的任何命名空间为浏览器所知（即使顶级命名空间根本不被识别！）时，文档的渲染方式将不同：所有被识别的标记将按预期工作，所有不受支持的标记将简单地没有效果，并且任何位于它们之间的文本将按原样显示。
- en: 'To illustrate this rendering strategy, consider the following input:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种渲染策略，考虑以下输入：
- en: '[PRE98]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The above example will be rendered as “Hello world!” The first *<u>* tag, with
    no semantics-defining namespace associated with it, will have no visible effect.
    The second one will be understood as an XHTML tag that triggers underlining.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将被渲染为“Hello world！”第一个没有与它关联语义定义命名空间的*<u>*标签将没有可见效果。第二个将被理解为触发下划线的XHTML标签。
- en: '![Firefox displaying an XML document with no recognized namespaces](httpatomoreillycomsourcenostarchimages950019.png.jpg)'
  id: totrans-949
  prefs: []
  type: TYPE_IMG
  zh: '![Firefox 显示没有识别命名空间的 XML 文档](httpatomoreillycomsourcenostarchimages950019.png.jpg)'
- en: Figure 7-1. Firefox displaying an XML document with no recognized namespaces
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1. Firefox 显示没有识别命名空间的 XML 文档
- en: The consequences of this fault-tolerant approach to the rendering of unknown
    XML documents and unrecognized namespaces are subtle but fairly important. For
    example, it will not be safe to proxy an unsanitized RSS feed, even though this
    format is typically routed to a specialized renderer and thus not subject to XSS
    risks. Any browser with no built-in RSS reader may fall back to generic rendering
    and then find HTML buried deep inside the feed.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 这种容错方法对未知 XML 文档和未识别命名空间的渲染后果微妙但相当重要。例如，即使这种格式通常被路由到专门的渲染器，不受到 XSS 风险的影响，也不应该代理未清理的
    RSS 源。任何没有内置 RSS 阅读器的浏览器都可能回退到通用渲染，然后发现 HTML 深深地隐藏在源中。
- en: Scalable Vector Graphics
  id: totrans-952
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可缩放矢量图形
- en: 'Scalable Vector Graphics (SVG)^([[155](pr03.html#ftn.CHP-7-FT-1)]) is a quickly
    evolving, XML-based vector graphics format. First published in 2001 by W3C, it
    is noteworthy for its integrated animation capabilities and direct JavaScript
    scripting features. The following example of a vector image draws a circle and
    displays a message when this circle is clicked:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 可缩放矢量图形 (SVG)^([[155](pr03.html#ftn.CHP-7-FT-1)]) 是一种快速发展的、基于 XML 的矢量图形格式。它由
    W3C 于 2001 年首次发布，以其集成的动画功能和直接的 JavaScript 脚本功能而著称。以下矢量图像示例绘制了一个圆，并在点击该圆时显示一条消息：
- en: '[PRE99]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The SVG file format is recognized all modern browsers except for Internet Explorer
    prior to 9, and it is handled by the general-purpose XML renderer. SVG images
    can be embedded into XHTML with an appropriate *xmlns* directive or inlined in
    non-XML HTML5 documents using a predefined *<svg>* tag.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 文件格式被所有现代浏览器所识别，除了 9 版本之前的 Internet Explorer，它由通用 XML 渲染器处理。SVG 图像可以通过适当的
    *xmlns* 指令嵌入到 XHTML 中，或者使用预定义的 *<svg>* 标签内联在非 XML HTML5 文档中。
- en: Interestingly, in several browsers the format can also be placed in a stand-alone
    XML document and then viewed directly, or it can be loaded on third-party pages
    via the *<img>* markup. While it is safe to load SVG images via *<img>* (scripting
    should be disabled in this scenario), it is fairly dangerous to host user-supplied
    SVG data because in cases of direct navigation, all embedded scripts will execute
    in the context of the hosting domain. This unexpected problem means that serving
    any externally originating SVG images will require very careful syntax sanitization
    to eliminate non-SVG *xmlns* content from the XML container and to permit only
    certain types of markup in the remainder of the document.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在几个浏览器中，该格式也可以放置在独立的 XML 文档中，然后直接查看，或者可以通过 *<img>* 标记在第三方页面上加载。虽然通过 *<img>*
    加载 SVG 图像是安全的（在这种情况下应禁用脚本），但托管用户提供的 SVG 数据相当危险，因为在直接导航的情况下，所有嵌入的脚本都将执行在托管域的上下文中。这个意外的问题意味着，提供任何外部来源的
    SVG 图像都需要非常仔细的语法清理，以从 XML 容器中消除非 SVG *xmlns* 内容，并允许在文档的其余部分中仅使用某些类型的标记。
- en: Note
  id: totrans-957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *Content-Disposition* header on the relevant HTTP responses is a potential
    workaround that permits SVG to be included via *<img>* but not accessed directly.
    This approach is not perfect, but it limits the risk. Using a throwaway domain
    to host such images is another possibility.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 相关 HTTP 响应的 *Content-Disposition* 标头是一个潜在的解决方案，允许通过 *<img>* 包含 SVG，但不能直接访问。这种方法并不完美，但它限制了风险。使用一次性域名托管此类图像是另一种可能性。
- en: Mathematical Markup Language
  id: totrans-959
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学标记语言
- en: Mathematical Markup Language (MathML)^([[156](pr03.html#ftn.CHP-7-FT-2)]) is
    a fairly straightforward means to facilitate the semantic, if a bit verbose, representation
    of mathematical equations. The standard was originally proposed by the W3C in
    1998, and it has been substantially refined through the years. Because of its
    somewhat niche application, MathML needed over a decade to gain partial support
    in Opera and Firefox browsers, but it is slowly gaining acceptance today. In the
    browsers that support the language, it may be placed in a standalone file or inline
    in XHTML and HTML5 documents.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 数学标记语言（MathML）^([[156](pr03.html#ftn.CHP-7-FT-2)]) 是一种相当直接的方法，用于促进数学方程式的语义表示，尽管有些冗长。该标准最初由
    W3C 在 1998 年提出，并且多年来得到了大幅改进。由于其相对狭窄的应用范围，MathML 需要超过十年时间才在 Opera 和 Firefox 浏览器中获得部分支持，但如今它正在逐渐被接受。在支持该语言的浏览器中，它可以被放置在独立的文件中，或者在
    XHTML 和 HTML5 文档中内联。
- en: Unlike SVG, MathML has no additional security considerations beyond those associated
    with generically handled XML.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 与SVG不同，MathML没有超出通用处理XML之外的其他安全考虑。
- en: XML User Interface Language
  id: totrans-962
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML用户界面语言
- en: The XML User Interface Language (XUL)^([[157](pr03.html#ftn.CHP-7-FT-3)]) is
    a presentation markup language created by Mozilla specifically for building browser-based
    applications, rather than documents. XUL exists because although modern HTML is
    often powerful enough to build basic graphical user interfaces, it is not particularly
    convenient for certain specialized tasks that desktop applications excel in, such
    as implementing common dialog windows or system menus.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: XML用户界面语言（XUL）^([[157](pr03.html#ftn.CHP-7-FT-3)]) 是Mozilla专门为构建基于浏览器的应用程序而不是文档而创建的表示标记语言。XUL之所以存在，是因为尽管现代HTML通常足够强大以构建基本的图形用户界面，但它并不特别方便用于桌面应用程序擅长的某些特定任务，例如实现常见的对话框窗口或系统菜单。
- en: XUL is not currently supported by any browser other than Firefox and appears
    to be disabled in the recent release, Firefox 6\. In Firefox, it is handled by
    the general-purpose renderer, based on the appropriate *xmlns* namespace. Firefox
    uses XUL for much of its internal UI, but otherwise the language is seldom encountered
    on the Internet.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: XUL目前除了Firefox以外的任何浏览器都不支持，并且似乎在最近的Firefox 6版本中被禁用。在Firefox中，它由基于适当*xmlns*命名空间的通用渲染器处理。Firefox使用XUL来处理其大部分内部用户界面，但除此之外，这种语言在互联网上很少遇到。
- en: From the standpoint of web application security, Internet-originating XUL documents
    can be considered roughly equivalent to HTML documents. Essentially, the language
    has JavaScript scripting capabilities and allows broad control over the appearance
    of the rendered page. Other than that property, it has no unusual quirks.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络应用安全的角度来看，源自互联网的XUL文档可以大致等同于HTML文档。本质上，这种语言具有JavaScript脚本功能，并允许对渲染页面的外观进行广泛控制。除了这个特性外，它没有其他不寻常的怪癖。
- en: Wireless Markup Language
  id: totrans-966
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无线标记语言
- en: 'Wireless Markup Language (WML)^([[158](pr03.html#ftn.CHP-7-FT-4)]) is a largely
    obsolete “optimized” HTML syntax developed in the 1990s by a consortium of mobile
    handset manufacturers and cellular network operators. This XML-based language,
    a part of the Wireless Application Protocol suite (WAP), offered a simplified
    weblike browsing experience for pre-smartphone devices with limited bandwidth
    and CPU resources.^([[38](#ftn.CHP-7-FN-4)]) A simple WML page might have looked
    like this:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 无线标记语言（WML）^([[158](pr03.html#ftn.CHP-7-FT-4)]) 是一种在20世纪90年代由一群移动手机制造商和蜂窝网络运营商联合开发的“优化”HTML语法，它已经很大程度上过时了。这种基于XML的语言是无线应用协议套件（WAP）的一部分，为带宽和CPU资源有限的预智能手机设备提供了简化的类似网页的浏览体验。^([[38](#ftn.CHP-7-FN-4)])
    一个简单的WML页面可能看起来像这样：
- en: '[PRE100]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Because WAP services needed to be engineered independently of normal HTML content
    and had to deal with closed and underspecified client architectures and other
    carrier-imposed restrictions, WML never became as popular as its proponents hoped.
    In almost all developed markets, WML has been displaced by fast, Internet-enabled
    smartphones with fully featured HTML browsers. Nevertheless, the legacy of the
    language lives on, and it is still routed to specialized renderers in Opera and
    in Internet Explorer Mobile.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WAP服务需要独立于正常的HTML内容进行设计，并且必须处理封闭和不明确的客户端架构以及其他运营商强加的限制，因此WML从未像其支持者所希望的那样流行。在几乎所有发达市场，WML已经被快速、互联网连接的智能手机和功能齐全的HTML浏览器所取代。尽管如此，该语言的遗产仍然存在，并且它仍然在Opera和Internet
    Explorer Mobile中的专用渲染器中被路由。
- en: 'In the browsers that support the format, it is often possible to use WML-based
    scripts. There are two methods to achieve this. The canonical way is to use WMLScript
    (WMLS), a JavaScript-derived execution environment that depends on stand-alone
    script files, coupled with an extremely inconsiderate abuse of fragment IDs for
    an equivalent of possibly attacker-controlled *eval(...)* statements:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持该格式的浏览器中，通常可以使用基于WML的脚本。有两种方法可以实现这一点。标准的方法是使用WMLScript（WMLS），这是一个基于JavaScript的执行环境，依赖于独立的脚本文件，并且对片段ID进行了极端的不当使用，以实现可能由攻击者控制的*eval(...)*语句：
- en: '[PRE101]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The other method of executing scripts, available in more featured browsers,
    is to simply embed normal *javascript:* URLs or insert *<script>* blocks into
    the WML file.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能更强大的浏览器中，执行脚本的另一种方法是简单地嵌入正常的*javascript:* URL或将*<script>*块插入到WML文件中。
- en: RSS and Atom Feeds
  id: totrans-973
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSS和Atom源
- en: '*Feeds* are a standardized way for clients to periodically poll sites of interest
    to users (such as their favorite blogs) for machine-readable updates to said sites’
    content. Really Simple Syndication (RSS)^([[159](pr03.html#ftn.CHP-7-FT-5)]) and
    Atom^([[160](pr03.html#ftn.CHP-7-FT-6)]) are two superficially similar but fiercely
    competing XML-based feed formats. The first (RSS) is popular; the second (Atom)
    is said to be good.'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '*源*是客户端定期轮询用户感兴趣站点（如他们最喜欢的博客）以获取机器可读更新的一种标准化方式。真正简单的聚合（RSS）^([[159](pr03.html#ftn.CHP-7-FT-5)])和Atom^([[160](pr03.html#ftn.CHP-7-FT-6)])是两种表面上相似但激烈竞争的基于XML的源格式。第一个（RSS）很受欢迎；第二个（Atom）据说很好。'
- en: Built-in, specialized RSS and Atom renderers are available in Firefox, Safari,
    and Opera. The determination to route an XML document to these modules is based
    on simple, browser-specific heuristics, such as the top-level tag being named
    *<rss>* or *<feed>* (and not having any conflicting *xmlns* directives). In Firefox,
    RSS parsing may kick in even if *Content-Type* is *image/svg+xml* or *text/html*.
    Safari will happily recognize feeds in even more unrelated MIME types.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox、Safari和Opera都提供了内置的专门RSS和Atom渲染器。将XML文档路由到这些模块的决定基于简单的、浏览器特定的启发式方法，例如顶级标签被命名为**<rss>**或**<feed>**（并且没有任何冲突的**xmlns**指令）。在Firefox中，即使**Content-Type**是**image/svg+xml**或**text/html**，RSS解析也可能启动。Safari会高兴地识别更多不相关的MIME类型。
- en: 'One interesting feature of both feed formats is that they permit a subset of
    HTML, including CSS, to be embedded in a document in a rather peculiar, indirect
    way: as an entity-escaped text. Here is an example of this syntax:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种源格式的一个有趣特点是它们允许HTML的一个子集，包括CSS，以一种相当奇特、间接的方式嵌入到文档中：作为实体转义文本。以下是一个这种语法的示例：
- en: '[PRE102]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The subset of HTML permitted in RSS and Atom feeds is not well defined, and
    some feed renderers have previously permitted direct scripting or navigation to
    potentially dangerous pseudo-URLs. Perhaps more importantly, however, any browser
    that does not have built-in feed previews may render the file using the generic
    XML parsing approach; if such feeds are not sanitized carefully, script execution
    will ensue.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: RSS和Atom源中允许的HTML子集定义得并不好，一些源渲染器以前允许直接脚本或导航到可能危险的伪URL。然而，更重要的是，任何没有内置源预览功能的浏览器可能会使用通用的XML解析方法来渲染文件；如果这些源没有经过仔细的清理，就会导致脚本执行。
- en: '* * *'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[38](#CHP-7-FN-4)]) Astute readers will note that XML is not a particularly
    good way to conserve bandwidth or CPU resources. To that effect, the WAP suite
    provides an alternative, binary-only serialization of XML, known as WBXML.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[38](#CHP-7-FN-4)]) 精明的读者会注意到XML并不是特别好的节省带宽或CPU资源的方式。为了这个目的，WAP套件提供了一个XML的二进制仅序列化版本，称为WBXML。
- en: A Note on Nonrenderable File Types
  id: totrans-981
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于不可渲染文件类型的一个说明
- en: For the sake of completeness, it should be noted that all modern browsers support
    a number of specialized file formats that remain completely opaque to the renderer
    or to the web application layer but that are nevertheless recognized by a variety
    of in-browser subsystems.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，应该指出，所有现代浏览器都支持一些专门的文件格式，这些格式对渲染器或Web应用程序层来说是完全透明的，但仍然被浏览器中的各种子系统所识别。
- en: A detailed investigation of these formats is beyond the scope of this book,
    but some notable examples include plug-in and extension installation manifests,
    automatic HTTP proxy autoconfiguration files (PAC), installable visual skins,
    Certificate Revocation Lists (CRLs), antimalware site blacklists, and downloadable
    TrueType and OpenType fonts.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些格式的详细调查超出了本书的范围，但一些值得注意的例子包括插件和扩展安装清单、自动HTTP代理自动配置文件（PAC）、可安装的视觉皮肤、证书吊销列表（CRL）、反恶意软件网站黑名单以及可下载的TrueType和OpenType字体。
- en: The security properties of these mechanisms should be studied individually before
    deciding to allow any of these formats to be served to the user. Save for the
    generic content-hosting considerations outlined in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms"), they are unlikely to harm the hosting web application
    directly, but they may cause problems for users.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定允许任何这些格式被提供给用户之前，应该单独研究这些机制的安全性属性。除了在[第13章](ch13.html "第13章。内容识别机制")中概述的通用内容托管考虑因素外，它们不太可能直接损害托管Web应用程序，但它们可能会给用户带来问题。
- en: Security Engineering Cheat Sheet
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Hosting XML-Based Document Formats
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 当托管基于XML的文档格式时
- en: 'Assume that the payload may be interpreted as XHTML or some other script-enabled
    document type, regardless of the *Content-Type* and the top-level *xmlns* directive.
    Do not allow unconstrained attacker-controlled markup anywhere inside the file.
    Use the *Content-Disposition: attachment* if data is not meant to be viewed directly;
    *<img>* and feeds will still work.'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '假设负载可能被解释为XHTML或其他启用了脚本功能的文档类型，无论`Content-Type`和顶级`xmlns`指令如何。不要允许在文件内部任何地方使用不受约束的攻击者控制的标记。如果数据不是直接查看的，请使用`Content-Disposition:
    attachment`；`<img>`和feed仍然可以工作。'
- en: On All Non-HTML Document Types
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有非HTML文档类型上
- en: 'Use correct, browser-recognized *Content-Type* and *charset* values. Specify
    the *Content-Disposition: attachment* where possible. Verify and constrain output
    syntax. Consult the cheat sheet in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms") to avoid security problems related to content-sniffing
    flaws.'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '使用正确的、浏览器认可的`Content-Type`和`charset`值。尽可能指定`Content-Disposition: attachment`。验证和约束输出语法。参考[第13章](ch13.html
    "第13章. 内容识别机制")中的cheat sheet，以避免与内容嗅探漏洞相关的安全问题。'
- en: Chapter 8. Content Rendering with Browser Plug-ins
  id: totrans-990
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 使用浏览器插件进行内容渲染
- en: Browser plug-ins come in many forms and shapes, but the most common variety
    give the ability to display new file formats in the browser, as if they were HTML.
    The browser simply hands over the retrieved file, provides the helper application
    with a rectangular drawing surface in the document window, and essentially backs
    away from the scene. Such content-rendering plug-ins are clearly distinguished
    from browser extensions, a far more numerous bunch that commonly relies on JavaScript
    code to tweak how the already-supported, in-browser content is presented to the
    user.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器插件形式多样，但最常见的类型是能够在浏览器中显示新的文件格式，就像它们是HTML一样。浏览器只是将检索到的文件交给插件，在文档窗口中为辅助应用程序提供一个矩形绘图表面，并基本上从场景中退去。这种内容渲染插件与浏览器扩展明显不同，后者是一大批数量众多的插件，通常依赖于JavaScript代码来调整已支持的、在浏览器中呈现给用户的内容。
- en: Browser plug-ins have a long and colorful history of security flaws. In fact,
    according to some analysts, 12 out of the 15 most frequently exploited client-side
    vulnerabilities in 2010 could be attributed to the quality of plug-in software.^([[161](pr03.html#ftn.CHP-8-FT-1)])
    Many of these problems are because the underlying parsers were originally not
    meant to handle malicious inputs gracefully and have not benefited from the intense
    scrutiny that the remainder of the Web has been subject to. Other problems stem
    from the unusual security models devised by plug-in developers and the interference
    between these permissions, the traditional design of web browsers, and the commonsense
    expectations of application developers.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器插件有着漫长且复杂的安全漏洞历史。实际上，根据一些分析人士的说法，2010年最常见的15个客户端漏洞中有12个可以归因于插件软件的质量。[^([161](pr03.html#ftn.CHP-8-FT-1))]
    许多这些问题是因为底层解析器最初并未设计为优雅地处理恶意输入，并且没有从整个网络所经历的严格审查中受益。其他问题则源于插件开发者设计的非传统安全模型，以及这些权限、传统浏览器设计以及应用程序开发者常识性期望之间的干扰。
- en: We will review some of the security mechanisms used by popular plug-ins in the
    next chapter of this book. Before taking this dive, it makes sense to look at
    the ways plug-ins integrate with other online content and the common functionality
    they offer.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章中，我们将回顾一些流行插件使用的安全机制。在深入探讨之前，了解插件如何与其他在线内容集成以及它们提供的常见功能是有意义的。
- en: Invoking a Plug-in
  id: totrans-994
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用插件
- en: Content-rendering plug-ins can be activated in a couple of ways. The most popular
    explicit method is to use *<embed src=...>* or `<`*object data=...>* markup in
    a “host” HTML document, with the *src* or *data* parameter pointing to the URL
    from which the actual plug-in-recognized document is to be retrieved. The dimensions
    and position of the drawable area allocated for the plug-in can be controlled
    with CSS (or with legacy HTML parameters).
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 内容渲染插件可以通过几种方式激活。最流行的一种显式方法是使用“宿主”HTML文档中的`<embed src=...>`或`<object data=...>`标记，其中`src`或`data`参数指向要检索的实际插件识别文档的URL。可以通过CSS（或使用传统的HTML参数）来控制分配给插件的绘制区域的尺寸和位置。
- en: In this scenario, every *<embed>* or *<object>* tag should be accompanied by
    an additional *type* parameter. The MIME type specified there will be compared
    to the list of MIME types registered by all the active plug-ins, and the retrieved
    file will be routed to the appropriate handler. If no match is found, a warning
    asking the user to download a plug-in should be theoretically displayed instead,
    although most browsers look at other signals before resorting to this unthinkable
    possibility; examining *Content-Type* or the apparent file extension spotted in
    the URL are two common choices.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个 `<embed>` 或 `<object>` 标签都应该伴随一个额外的 `type` 参数。那里指定的 MIME 类型将与所有活动插件注册的
    MIME 类型列表进行比较，检索到的文件将被路由到适当的处理程序。如果没有找到匹配项，理论上应该显示一个警告，提示用户下载插件，尽管大多数浏览器在求助于这种不可想象的可能性之前会查看其他信号；检查
    `Content-Type` 或在 URL 中发现的明显文件扩展名是两种常见的选择。
- en: Note
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An obsolete *<applet>* tag, used to load Java programs (roughly equivalent to
    *<object type="application/x-java-applet">*), works in a comparable way but unconditionally
    disregards these auxiliary signals.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过时的 `<applet>` 标签，用于加载 Java 程序（大致相当于 `<object type="application/x-java-applet">`），以类似的方式工作，但无条件地忽略这些辅助信号。
- en: 'Additional input to the plug-in is commonly passed using *<param>* tags nested
    inside the *<object>* block or through nonstandard additional parameters attached
    to the *<embed>* markup itself. The former, more modern approach may look like
    this:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 向插件提供的额外输入通常使用嵌套在 `<object>` 块内的 `<param>` 标签或通过附加到 `<embed>` 标记的非标准额外参数来传递。前者，更现代的方法可能看起来像这样：
- en: '[PRE103]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In this content-inclusion mode, the *Content-Type* header returned by the server
    when retrieving the subresource is typically ignored, unless the *type* parameter
    is unknown to the browser. This is an unfortunate design, for reasons that will
    be explained shortly.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种内容包含模式下，当检索子资源时，服务器返回的 `Content-Type` 头通常会被忽略，除非浏览器不知道 `type` 参数。这是一个不幸的设计，原因将在稍后解释。
- en: The other method for displaying plug-in content involves navigating directly
    to a suitable file. In this case, and in the case of *<embed>* or *<object>* with
    a missing *type* parameter, the *Content-Type* value obtained from the server
    is honored, and it will be compared with the list of plug-in-recognized MIME types.
    If a match is found, the content is routed to the appropriate component. If the
    *Content-Type* lookup fails or the header is missing, some browsers will examine
    the response body for known content signatures; others just give up.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 显示插件内容的另一种方法是通过直接导航到合适的文件。在这种情况下，以及当 `<embed>` 或 `<object>` 缺少 `type` 参数时，将从服务器获得的
    `Content-Type` 值将被尊重，并将其与插件识别的 MIME 类型列表进行比较。如果找到匹配项，内容将被路由到适当的组件。如果 `Content-Type`
    查找失败或缺少头信息，一些浏览器将检查响应体中的已知内容签名；其他浏览器则放弃。
- en: Note
  id: totrans-1003
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The aforementioned content-focused methods aside, several types of plug-ins
    can be loaded directly from within JavaScript or VBScript programs without the
    need to explicitly create any HTML markup or retrieve any external data. Such
    is the case for ActiveX, an infamous script-to-system integration bridge available
    in Internet Explorer. (We will devote some time to ActiveX later in this chapter,
    but first things first.)
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述内容聚焦的方法之外，一些类型的插件可以直接从 JavaScript 或 VBScript 程序中加载，而无需显式创建任何 HTML 标记或检索任何外部数据。ActiveX
    就是这种情况，这是一个臭名昭著的脚本到系统集成的桥梁，可在 Internet Explorer 中使用。（我们将在本章稍后讨论 ActiveX，但首先应该先了解一些基本概念。）
- en: The Perils of Plug-in Content-Type Handling
  id: totrans-1005
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件内容类型处理的危险
- en: As noted in the previous section, in certain scenarios the *Content-Type* parameter
    on a retrieved plug-in-handled file is ignored, and the *type* parameter in the
    corresponding markup on the embedding page is used instead. While this decision
    is somewhat similar to the behavior of other type-specific content-inclusion tags
    (say, *<img>*), as discussed in [Type-Specific Content Inclusion](ch04s05.html#type-specific_content_inclusion
    "Type-Specific Content Inclusion") in [Frames](ch04s05.html#frames "Frames"),
    it has some unique and ultimately disastrous consequences in the plug-in world.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在某些场景中，检索的插件处理的文件上的 `Content-Type` 参数会被忽略，而嵌入页面上的相应标记中的 `type` 参数将被使用。虽然这个决定与其他类型特定的内容包含标签（例如，`<img>`）的行为有些相似，正如在
    [类型特定的内容包含](ch04s05.html#type-specific_content_inclusion "类型特定的内容包含") 中所讨论的，但在插件世界中，它有一些独特且最终灾难性的后果。
- en: The big problem is that several types of plug-ins are essentially full-fledged
    code execution environments and give the executed applications (*applets*) a range
    of special privileges to interact with the originating domain. For example, a
    Flash file retrieved from [fuzzybunnies.com](http://fuzzybunnies.com) would be
    granted access to its originating domain (complete with a user’s cookies) when
    embedded on the decidedly rogue [bunnyoutlet.com](http://bunnyoutlet.com).
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 大问题是，几种类型的插件本质上是完全的代码执行环境，并赋予执行的应用程序（*applets*）一系列特殊权限与原始域名交互。例如，从[fuzzybunnies.com](http://fuzzybunnies.com)检索到的Flash文件，在嵌入到明显可疑的[bunnyoutlet.com](http://bunnyoutlet.com)时，将获得对其原始域的访问权限（包括用户的cookies）。
- en: 'In such a scenario, it would seem to be important for [fuzzybunnies.com](http://fuzzybunnies.com)
    to be able to clearly communicate that a particular type of a document is indeed
    meant to be interpreted by a plug-in—and, consequently, that some documents aren’t
    meant to be used this way. Unfortunately, there is no way for this to happen:
    The handling of a retrieved file is fully controlled by the embedding site (in
    our example, by the mean-spirited bullies who own [bunnyoutlet.com](http://bunnyoutlet.com)).
    Therefore, if the originating domain hosts any type of user-controlled content,
    even in a nominally harmless format (such as *text/plain* or *image/jpeg*), the
    owners of [bunnyoutlet.com](http://bunnyoutlet.com) may instruct the browser to
    disregard the existing metadata and route that document to a plug-in of their
    choice. A simple markup to achieve this sinister goal may be'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于[fuzzybunnies.com](http://fuzzybunnies.com)来说，能够清楚地传达特定类型的文档确实是为了由插件来解释的——并且因此，某些文档并不适合以这种方式使用——这似乎很重要。不幸的是，这种情况根本无法实现：检索到的文件的处理完全由嵌入网站控制（在我们的例子中，由拥有[bunnyoutlet.com](http://bunnyoutlet.com)的刻薄恶霸控制）。因此，如果原始域名托管任何类型的用户可控内容，即使是在名义上无害的格式（如*text/plain*或*image/jpeg*），[bunnyoutlet.com](http://bunnyoutlet.com)的拥有者可以指示浏览器忽略现有的元数据，并将该文档路由到他们选择的插件。为了实现这个险恶的目标，可能需要一个简单的标记来做到这一点。
- en: '[PRE104]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If this turn of events seems wrong, that’s because it is. Security researchers
    have repeatedly demonstrated that it is quite easy to construct documents that
    are, for example, simultaneously a valid image and a valid plug-in-recognized
    executable. The well-known “GIFAR” vulnerability, discovered in 2008 by Billy
    Rios,^([[162](pr03.html#ftn.CHP-8-FT-2)]) exploited that very trick: It smuggled
    a Java applet inside a perfectly kosher GIF image. In response, Sun Microsystems
    reportedly tightened down the Java JAR file parser to mitigate the risk, but the
    general threat of such mistakes is still very real and will likely rear its ugly
    head once more.'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种事件的发展看起来是错误的，那是因为它确实是。安全研究人员反复证明，构建同时是有效图像和有效插件识别的可执行文档是非常容易的。2008年由Billy
    Rios发现的著名的“GIFAR”漏洞，就利用了这种技巧：它将Java applet隐藏在一个完全合法的GIF图像中。作为回应，Sun Microsystems据报道加强了Java
    JAR文件解析器的控制以减轻风险，但此类错误的普遍威胁仍然非常真实，并且可能会再次露出其丑陋的真相。
- en: Interestingly, the decision by some developers to rely on *Content-Type* and
    other signals if the *type* parameter is unrecognized is almost as bad. This decision
    makes it impossible for the well-intentioned [fuzzybunnies.com](http://fuzzybunnies.com)
    to safely embed a harmless video from the rogues at [bunnyoutlet.com](http://bunnyoutlet.com)
    by simply specifying *type="video/x-ms-wmv"*, because if any of the visitors do
    not have a plug-in for that specific media type, [bunnyoutlet.com](http://bunnyoutlet.com)
    will suddenly have a say in what type of plug-in should be loaded on the embedding
    site instead. Some browsers, such as Internet Explorer, Chrome, or Opera, may
    also resort to looking for apparent file extensions present in the URL, which
    can lead to an interesting situation where neither the embedding nor the hosting
    party has real control over how a document is displayed—and quite often only the
    attacker is in charge.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，一些开发者决定在未识别*type*参数时依赖于*Content-Type*和其他信号，这个决定几乎和前者一样糟糕。这个决定使得[well-intentioned
    fuzzybunnies.com](http://fuzzybunnies.com)无法通过简单地指定*type="video/x-ms-wmv"*来安全地嵌入来自[bunnyoutlet.com](http://bunnyoutlet.com)的无害视频，因为如果访问者中任何一个人没有该特定媒体类型的插件，[bunnyoutlet.com](http://bunnyoutlet.com)将突然有权决定在嵌入网站上加载哪种类型的插件。一些浏览器，如Internet
    Explorer、Chrome或Opera，也可能求助于在URL中寻找明显的文件扩展名，这可能导致一个有趣的情况，即嵌入方和托管方都没有真正控制文档的显示方式——而且通常只有攻击者才是真正掌权的人。
- en: 'A much safer design would require the embedder-controlled *type* parameter
    and the host-controlled *Content-Type* header to match (at least superficially).
    Unfortunately, there is currently no way to make this happen. Several individual
    plug-ins try to play nice (for example, following a 2008 overhaul, Adobe Flash
    rejects applets served with *Content-Disposition: attachment*, as does the built-in
    PDF reader in Chrome), but these improvements are few and far between.'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '一个更安全的设计将需要嵌入器控制的**类型**参数和主机控制的**Content-Type**头来匹配（至少表面上）。不幸的是，目前还没有办法实现这一点。一些单独的插件试图表现得很好（例如，在2008年全面改版后，Adobe
    Flash拒绝使用**Content-Disposition: attachment**提供的applet，Chrome内置的PDF阅读器也是如此），但这些改进是少之又少。'
- en: Document Rendering Helpers
  id: totrans-1013
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档渲染助手
- en: 'A significant portion of the plug-in landscape belongs to programs that allow
    certain very traditional, “nonweb” document formats to be shown directly in the
    browser. Some of these programs are genuinely useful: Windows Media Player, RealNetworks
    RealPlayer, and Apple QuickTime have been the backbone of online multimedia playback
    for about a decade, at least until their displacement by Adobe Flash. The merits
    of others are more questionable, however. For example, Adobe Reader and Microsoft
    Office both install in-browser document viewers, increasing the user’s attack
    surface appreciably, though it is unclear whether these viewers offer a real benefit
    over opening the same document in a separate application with one extra click.'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 插件领域的一个显著部分属于允许某些非常传统、非Web文档格式直接在浏览器中显示的程序。其中一些程序确实很有用：Windows Media Player、RealNetworks
    RealPlayer和Apple QuickTime一直是大约十年在线多媒体播放的支柱，至少直到Adobe Flash取代它们。然而，其他一些程序的优点则更加可疑。例如，Adobe
    Reader和Microsoft Office都安装了浏览器文档查看器，大大增加了用户的攻击面，尽管不清楚这些查看器是否比在单独的应用程序中打开同一文档多点击一次真正有益。
- en: 'Of course, in a perfect world, hosting or embedding a PDF or a Word document
    should have no direct consequences for the security of the participating websites.
    Yet, predictably, the reality begs to differ. In 2009, a researcher noted that
    PDF-based forms that submit to *javascript:* URLs can apparently lead to client-side
    code execution on the embedding site.^([[163](pr03.html#ftn.CHP-8-FT-3)]) Perhaps
    even more troubling than this report alone, according to that researcher’s account,
    Adobe initially dismissed the report with the following note: “Our position is
    that, like an HTML page, a PDF file is active content.”'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在一个完美的世界里，托管或嵌入PDF或Word文档应该不会对参与网站的安全性产生直接影响。然而，不出所料，现实情况却大相径庭。2009年，一位研究人员指出，基于PDF的表单提交到*javascript:*
    URL可能会导致嵌入站点上的客户端代码执行.^([[163](pr03.html#ftn.CHP-8-FT-3)]) 根据那位研究人员的描述，Adobe最初以以下注释驳回了这份报告：“我们的立场是，就像一个HTML页面一样，PDF文件是活动内容。”
- en: It is regrettable that the hosting party does not have full control of when
    this active content is detected and executed and that otherwise reasonable webmasters
    may think of PDFs or Word documents as just a fancy way to present text. In reality,
    despite their harmless appearance, in a bid to look cool, many such document formats
    come equipped with their own hyperlinking capabilities or even scripting languages.
    For example, JavaScript code can be embedded in PDF documents, and Visual Basic
    macros are possible in Microsoft Office files. When a script-bearing document
    is displayed on an HTML page, some form of a programmatic plug-in-to-browser bridge
    usually permits a degree of interaction with the embedding site, and the design
    of such bridges can vary from vaguely questionable to outright preposterous.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，托管方无法完全控制何时检测和执行这种活动内容，而且其他合理的网站管理员可能会将PDF或Word文档仅仅视为一种展示文本的华丽方式。实际上，尽管它们看起来无害，但为了看起来酷，许多这样的文档格式都配备了他们自己的超链接功能或甚至脚本语言。例如，JavaScript代码可以嵌入到PDF文档中，在Microsoft
    Office文件中也可以使用Visual Basic宏。当一个包含脚本的文档在HTML页面上显示时，通常需要某种形式的插件到浏览器的桥梁，允许与嵌入站点进行一定程度的交互，而这些桥梁的设计可以从模糊可疑到明显荒谬不等。
- en: In one 2007 case, Petko D. Petkov noticed that a site that hosts any PDF documents
    can be attacked simply by providing completely arbitrary JavaScript code in the
    fragment identifier. This string will be executed on the hosting page through
    the plug-in bridge:^([[164](pr03.html#ftn.CHP-8-FT-4)])
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 在2007年的一起案例中，Petko D. Petkov注意到，任何托管PDF文档的网站都可以通过在片段标识符中提供完全任意的JavaScript代码来被攻击。这个字符串将通过插件桥梁在托管页面上执行:^([[164](pr03.html#ftn.CHP-8-FT-4)])
- en: '[PRE105]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The two vulnerabilities outlined here are now fixed, but the lesson is that
    special care should be exercised when hosting or embedding any user-supplied documents
    in sensitive domains. The consequences of doing so are not well documented and
    can be difficult to predict.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 这里概述的两个漏洞现在已经修复，但教训是，在敏感域中托管或嵌入任何用户提供的文档时，应格外小心。这样做可能带来的后果没有很好地记录，并且难以预测。
- en: Plug-in-Based Application Frameworks
  id: totrans-1020
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于插件的 应用程序框架
- en: 'The boring job of rendering documents is a well-established role for browser
    plug-ins, but several ambitious vendors go well beyond this paradigm. The aim
    of some plug-ins is simply to displace HTML and JavaScript by providing alternative,
    more featured platforms for building interactive web applications. That reasoning
    is not completely without merit: Browsers have long lacked in performance, in
    graphics capabilities, and in multimedia codecs, stifling some potential uses
    of the Web. Reliance on plug-ins is a reasonable short-term way to make a difference.
    On the flip side, when proprietary, patent- and copyright-encumbered plug-ins
    are promoted as the ultimate way to build an online ecosystem, without any intent
    to improve the browsers themselves, the openness of the Web inevitably suffers.
    Some critics, notably Steve Jobs, think that creating a tightly controlled ecosystem
    is exactly what several plug-in vendors, most notably Adobe, aspire to.^([[165](pr03.html#ftn.CHP-8-FT-5)])'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 将文档渲染的枯燥工作作为浏览器插件的一个既定角色已经是很常见的了，但一些雄心勃勃的供应商已经远远超出了这个模式。一些插件的目标仅仅是通过提供替代的、功能更强大的平台来构建交互式网络应用，从而取代HTML和JavaScript。这种推理并非完全没有道理：浏览器长期以来在性能、图形能力和多媒体编解码器方面存在不足，这限制了Web的一些潜在用途。依赖插件是短期内改变现状的合理方式。然而，当专有、受专利和版权保护的插件被宣传为构建在线生态系统的终极方式，而没有意图去改进浏览器本身时，Web的开放性不可避免地会受到影响。一些批评者，尤其是史蒂夫·乔布斯，认为创建一个严格控制的环境正是几个插件供应商，尤其是Adobe所追求的。[^([[165](pr03.html#ftn.CHP-8-FT-5)])]
- en: In response to this perceived threat of a hostile takeover of the Web, many
    of the shortcomings that led to the proliferation of alternative application frameworks
    are now being hastily addressed under the vaguely defined umbrella of HTML5; *<video>*
    tags and WebGL^([[39](#ftn.CHP-8-FN-1)]) are the prime examples of this work.
    That said, some of the features available in plug-ins will probably not be captured
    as a part of any browser standard in the immediate future. For example, there
    is currently no serious plan to add inherently dangerous elevated privilege programs
    supported by Java or security-by-obscurity content protection schemes (euphemistically
    called Digital Rights Management, or DRM).
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这种被认为是对Web进行敌意接管威胁的回应，许多导致替代应用程序框架泛滥的不足之处现在正匆忙地在HTML5这个模糊定义的大旗下得到解决；*<video>*标签和WebGL[^([[39](#ftn.CHP-8-FN-1)])]是这一工作的主要例子。尽管如此，一些插件中可用的功能可能在未来的一段时间内不会被纳入任何浏览器标准。例如，目前没有计划添加Java支持的危险提升权限程序或隐蔽性内容保护方案（委婉地称为数字版权管理，或DRM）。
- en: Therefore, while the landscape will change dramatically in the coming years,
    we can expect that in one form or another, proprietary web application frameworks
    are here to stay.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管未来几年情况将发生巨大变化，我们可以预期，以某种形式，专有的网络应用程序框架将在这里继续存在。
- en: Adobe Flash
  id: totrans-1024
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Adobe Flash
- en: Adobe Flash is a web application framework introduced in 1996, in the heat of
    the First Browser Wars. Before its acquisition by Adobe in 2005, the Flash platform
    was known as Macromedia Flash or Shockwave Flash (hence the *.swf* file extension
    used for Flash files), and it is still sometimes referred to as such.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe Flash是一个在1996年首次浏览器大战期间推出的网络应用程序框架。在2005年被Adobe收购之前，Flash平台被称为Macromedia
    Flash或Shockwave Flash（因此Flash文件使用的*.swf*文件扩展名），有时仍然这样称呼。
- en: Flash is a fairly down-to-earth platform built on top of a JavaScript-based
    language dubbed ActionScript.^([[166](pr03.html#ftn.CHP-8-FT-6)]) It includes
    a 2-D vector and bitmap graphics-rendering engine and built-in support for several
    image, video, and audio formats, such as the popular and efficient H.264 codec
    (which is used for much of today’s online multimedia).
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: Flash是一个相当接地气的平台，建立在基于JavaScript的语言ActionScript之上。[^([[166](pr03.html#ftn.CHP-8-FT-6)])]
    它包括一个2D矢量图形和位图图形渲染引擎，以及内置对多种图像、视频和音频格式的支持，例如流行的、高效的H.264编解码器（它被用于今天大部分在线多媒体）。
- en: 'By most estimates, Flash is installed on around 95 to 99 percent of all desktop
    systems.^([[167](pr03.html#ftn.CHP-8-FT-7)]), ^([[168](pr03.html#ftn.CHP-8-FT-8)])
    This user base is substantially higher than that of any other media player plug-in.
    (Support for the Windows Media Player and QuickTime plug-ins is available on only
    about 60 percent of PCs, despite aggressive bundling strategies, while the increasingly
    unpopular RealPlayer is still clinging to 25 percent.) The market position contributes
    to the product’s most significant and unexpected use: the replacement of all multimedia
    playback plug-ins previously relied upon for streaming video on the Web. Although
    the plug-in is also used for a variety of other jobs (including implementing online
    games, interactive advertisements, and so on), simple multimedia constitutes a
    disproportionately large slice of the pie.'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 根据大多数估计，Flash大约安装在所有桌面系统的95%到99%之间.^([[167](pr03.html#ftn.CHP-8-FT-7)]), ^([[168](pr03.html#ftn.CHP-8-FT-8)])
    这个用户基础比任何其他媒体播放器插件都要高得多。尽管采取了积极的捆绑策略，Windows Media Player和QuickTime插件的支持仅限于大约60%的PC，而越来越不受欢迎的RealPlayer仍然占据25%。这种市场地位促成了该产品最显著且出乎意料的使用：取代了之前用于在网络上流式传输视频的所有多媒体播放插件。尽管该插件也被用于各种其他任务（包括实现在线游戏、交互式广告等），但简单的多媒体占据了相当大的市场份额。
- en: Note
  id: totrans-1028
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Confusingly, a separate plug-in called Adobe Shockwave Player (without the word
    “Flash”) is also available, which can be used to play back content created with
    Adobe Director. This plug-in is sometimes mistakenly installed in place of or
    alongside Adobe Flash, contributing to an approximately 20 percent install base,^([[169](pr03.html#ftn.CHP-8-FT-9)])
    but it is almost always unnecessary. The security properties of this plug-in are
    not particularly well studied.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，还有一个名为Adobe Shockwave Player（不包含“Flash”一词）的独立插件也可供使用，它可以用来播放使用Adobe Director创建的内容。这个插件有时会被错误地安装，取代或与Adobe
    Flash一起安装，导致大约20%的安装基础，^([[169](pr03.html#ftn.CHP-8-FT-9)])但它几乎总是不必要的。这个插件的安全特性并没有得到特别深入的研究。
- en: Properties of ActionScript
  id: totrans-1030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ActionScript属性
- en: The capabilities of ActionScript in SWF files are generally analogous to those
    of JavaScript code embedded on HTML pages with some minor, yet interesting, differences.
    For example, Flash programs are free to enumerate all fonts installed on a system
    and collect other useful system fingerprinting signals not available to normal
    scripts. Flash programs can also use full screen rendering, facilitating UI spoofing
    attacks, and they can request access to input devices such as a camera or a microphone
    (this requires the user’s consent). Flash also tends to ignore browser security
    and privacy settings and uses its own configuration for mechanisms such as in-plug-in
    persistent data storage (although some improvements in this area were announced
    in May 2011).
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: SWF文件中ActionScript的功能通常与嵌入HTML页面中的JavaScript代码的功能类似，有一些细微但有趣的差异。例如，Flash程序可以自由地列出系统上安装的所有字体，并收集其他有用的系统指纹信号，这些信号对于普通脚本不可用。Flash程序还可以使用全屏渲染，便于UI欺骗攻击，并且可以请求访问输入设备，如摄像头或麦克风（这需要用户的同意）。Flash还倾向于忽略浏览器的安全性和隐私设置，并使用自己的配置来处理机制，如插件内持久数据存储（尽管在2011年5月宣布了该领域的某些改进）。
- en: The remaining features are less surprising. We’ll discuss the network and DOM
    access permissions of Flash applications in more detail in the next chapter, but
    in short, by default, every Flash applet can use the browser HTTP stack (and any
    ambient credentials managed therein) to talk back to its originating server, request
    a limited range of subresources from other sites, and navigate the current browser
    window or open a new one. ActionScript programs may also negotiate browser-level
    access to other currently running Flash applications and, in some cases, access
    the DOM of the embedding page. This last functionality is implemented by injecting
    *eval(...)*-like statements into the target JavaScript context.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的功能并不令人惊讶。我们将在下一章更详细地讨论Flash应用程序的网络和DOM访问权限，但简而言之，默认情况下，每个Flash小程序都可以使用浏览器HTTP堆栈（以及其中管理的任何环境凭证）与其原始服务器进行通信，从其他站点请求有限范围的子资源，并导航当前浏览器窗口或打开一个新窗口。ActionScript程序还可以协商对其他当前运行的Flash应用程序的浏览器级别访问，并在某些情况下访问嵌入页面的DOM。这种最后的功能是通过向目标JavaScript上下文中注入类似*eval(...)*的语句来实现的。
- en: ActionScript offers fertile ground for web application vulnerabilities. For
    example, the *getURL(...)* and *navigateToURL(...)* functions, used to navigate
    the browser or open new windows, are sometimes invoked with attacker-controlled
    inputs. Such a use is dangerous. Even though *javascript:* URLs do not have a
    special meaning to Flash, the function will pass such strings to the browser,
    in some cases resulting in script injection on the embedding site.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: ActionScript为Web应用程序漏洞提供了肥沃的土壤。例如，用于导航浏览器或打开新窗口的*getURL(...)*和*navigateToURL(...)*函数有时会使用攻击者控制的输入来调用。这种用法是危险的。尽管*javascript:*
    URL对Flash没有特殊含义，但该函数会将此类字符串传递给浏览器，在某些情况下导致嵌入网站上的脚本注入。
- en: 'Until recently, a related problem was present with other URL-handling APIs,
    such as *loadMovie(...)*. Even though the function did not rely on the browser
    to load the document, it would recognize an internal *asfunction:* scheme, which
    works similarly to *eval(...)* and could be trivially leveraged to perform a call
    to *getURL(...)*:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，其他URL处理API，如*loadMovie(...)*，也存在相关的问题。尽管该函数不依赖于浏览器来加载文档，但它会识别内部*asfunction:*方案，该方案与*eval(...)*类似，可以轻易地被利用来执行对*getURL(...)*的调用：
- en: '[PRE106]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The issue with loading scripts from untrusted sources, discussed in [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts"), also has an equivalent in the plug-in word.
    In Flash, it is very unsafe to invoke certain functions that affect the state
    of the ActionScript execution environment (such as the *LoadVars.load(...)*) with
    attacker-controlled URLs, even if the scheme from which the resource is loaded
    is *http:* or *https:*.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。浏览器端脚本")中讨论的从不受信任的源加载脚本的问题，在插件中也有一个等效问题。在Flash中，使用攻击者控制的URL调用影响ActionScript执行环境状态的某些函数（如*LoadVars.load(*)）是非常不安全的，即使加载资源的方案是*http:*或*https:*。
- en: 'Another commonly overlooked attack surface is the internal, simplified HTML
    parser offered by the Flash plug-in: Basic HTML markup can be assigned to properties
    such as *TextField.htmlText* and *TextArea.htmlText*. It is easy to forget that
    user-supplied content must be escaped correctly in this setting. Failure to do
    so may permit attackers to modify the appearance of the application UI or to inject
    potentially problematic scripting-oriented links.'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常被忽视的攻击面是Flash插件提供的内部简化HTML解析器：基本HTML标记可以分配给诸如*TextField.htmlText*和*TextArea.htmlText*这样的属性。很容易忘记在这个设置中用户提供的内
    容必须正确转义。未能这样做可能会允许攻击者修改应用程序UI的外观或注入可能存在问题的以脚本为导向的链接。
- en: 'Yet another class of Flash-related security bugs may arise due to design or
    implementation problems in the plug-in itself. For example, take the *ExternalInterface.call(...)*
    API. It is meant to allow ActionScript to call existing JavaScript functions on
    the embedding page and takes two parameters: the name of the JavaScript function
    to call and an optional string to be passed to this routine. While it is understood
    that the first parameter should not be attacker controlled, it appears to be safe
    to put user data in the second one. In fact, the documentation provides the following
    code snippet outlining this specific use case:^([[170](pr03.html#ftn.CHP-8-FT-10)])'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类与Flash相关的安全漏洞可能源于插件本身的设计或实现问题。例如，考虑*ExternalInterface.call(...)* API。它的目的是允许ActionScript调用嵌入页面上现有的JavaScript函数，并接受两个参数：要调用的JavaScript函数的名称和一个可选的字符串，该字符串将被传递给此例程。虽然人们理解第一个参数不应该由攻击者控制，但似乎将用户数据放在第二个参数中是安全的。实际上，文档提供了以下代码片段来概述此特定用例^([[170](pr03.html#ftn.CHP-8-FT-10)]).
- en: '[PRE107]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This call will result in the following *eval(...)* statement being injected
    on the embedding page:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用将在嵌入页面上注入以下*eval(...)*语句：
- en: '[PRE108]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'When writing the code behind this call, the authors of the plug-in remembered
    to use backslash escaping when outputting the second parameter: *hello"world*
    becomes *hello\"world*. Unfortunately, they overlooked the need to escape any
    stray backslash characters, too. Because of this, if the value of *input.text*
    is set to the following string, the embedded script will unexpectedly execute:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此调用背后的代码时，插件的作者记得在输出第二个参数时使用反斜杠转义：*hello"world*变为*hello\"world*。不幸的是，他们忽略了需要转义任何多余的转义字符。因此，如果*input.text*的值设置为以下字符串，嵌入的脚本将意外执行：
- en: '[PRE109]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'I contacted Adobe about this particular problem in March 2010\. Over a year
    later, its response was this: “We have not made any change to this behavior for
    backwards compatibility reasons.”'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 我于2010年3月联系了Adobe关于这个特定问题。一年多后，它的回应是这样的：“出于向后兼容性的原因，我们没有对此行为做出任何更改。”
- en: That seems unfortunate.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很不幸。
- en: Microsoft Silverlight
  id: totrans-1046
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微软Silverlight
- en: Microsoft Silverlight is a versatile development platform built on the Windows
    Presentation Foundation, a GUI framework that is a part of Microsoft’s .NET stack.
    It debuted in 2007 and combines an Extensible Application Markup Language (XAML)^([[171](pr03.html#ftn.CHP-8-FT-11)])
    (Microsoft’s alternative to Mozilla’s XUL) with code written in one of several
    managed .NET languages,^([[40](#ftn.CHP-8-FN-2)]) such as C# or Visual Basic.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Silverlight是一个基于Windows Presentation Foundation（一个微软.NET堆栈中的GUI框架）的多功能开发平台。它于2007年首次亮相，结合了可扩展应用程序标记语言（XAML）^([[171](pr03.html#ftn.CHP-8-FT-11)])（微软对Mozilla的XUL的替代品）以及用几种托管.NET语言之一编写的代码，例如C#或Visual
    Basic。
- en: Despite substantial design differences and a more ambitious (and confusing)
    architecture, this plug-in is primarily meant to compete with Adobe Flash. Many
    of the features available to Silverlight applications mirror those implemented
    in its competitor, including a nearly identical security model and a similar *eval(...)*-based
    bridge to the embedding page. To Microsoft’s credit, Silverlight does not come
    with an equivalent of the *asfunction:* scheme or with a built-in HTML renderer,
    however.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在设计上存在显著差异，并且架构更加雄心勃勃（但也更加复杂），这个插件的主要目的是与Adobe Flash竞争。许多Silverlight应用程序的功能与其竞争对手实现的功能相似，包括几乎相同的网络安全模型和基于*eval(...)*的嵌入页面桥接。然而，值得微软称道的是，Silverlight没有提供*asfunction:*方案，也没有内置的HTML渲染器。
- en: Silverlight is marketed by Microsoft fairly aggressively, and it is bundled
    with some editions of Internet Explorer. As a result, depending on the source,
    it is believed to have about a 60 to 75 percent desktop penetration.^([[172](pr03.html#ftn.CHP-8-FT-12)])
    Despite its prevalence, Silverlight is used fairly infrequently to develop actual
    web applications, perhaps because it usually offers no compelling advantages over
    its more established counterpart or because its architecture is seen as more contrived
    and platform-specific. (Netflix, a popular video streaming and rental service,
    is one of the very few high-profile websites that actually relies on Silverlight
    for playback on some devices.)
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 微软对Silverlight进行了相当积极的推广，并将其捆绑在一些版本的Internet Explorer中。因此，根据来源不同，它被认为大约有60%到75%的桌面渗透率.^([[172](pr03.html#ftn.CHP-8-FT-12)])
    尽管其普及，但Silverlight在开发实际Web应用程序时使用得相当少，可能是因为它通常没有提供比其更成熟的替代品更有吸引力的优势，或者因为其架构被视为更牵强和特定于平台。（Netflix，一个流行的视频流媒体和租赁服务，是极少数真正依赖Silverlight在某些设备上进行播放的高知名度网站之一。）
- en: Sun Java
  id: totrans-1050
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sun Java
- en: Java is a programming language coupled with a platform-independent, managed-code
    execution platform. Developed in the early to mid-1990s by James Gosling for Sun
    Microsystems, Java has a well-established role as a server-side programming language
    and a very robust presence in many other niches, including mobile devices. Yet,
    from the beginning, Sun hoped that Java would also occupy a prominent place on
    the browser end.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种与平台无关的、托管代码执行平台相结合的编程语言。由詹姆斯·高斯林在20世纪90年代初为Sun Microsystems开发，Java在服务器端编程语言中有着稳固的地位，并在许多其他领域，包括移动设备中有着非常强大的存在。然而，从一开始，Sun就希望Java也能在浏览器端占据一个突出的位置。
- en: Java in the browser predated Flash and most similar plug-ins, and the now-obsolete
    *<applet>* tag is a testament to how important and unique and novel this addition
    must have seemed back in its day. Yet, despite this head start, the Java language
    is nearly extinct as an in-browser development platform, and even in its heyday
    it never enjoyed real prominence. It retains a remarkable 80 percent installed
    base, but this high percentage is attributed largely to the fact that the Java
    plug-in is bundled with Java Runtime Environment (JRE), a more practically useful
    and commonly preinstalled component that is required to run normal, desktop Java
    applications on the system without any involvement on the browser end.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的Java在Flash和大多数类似插件之前，现在已废弃的*<applet>*标签证明了在当时这个添加是多么的重要、独特和新颖。尽管如此，Java语言作为浏览器开发平台几乎已经灭绝，即使在它的鼎盛时期，它也从未真正享有真正的突出地位。它保持了惊人的80%的安装基数，但这个高比例主要归因于Java插件与Java运行时环境（JRE）捆绑在一起，这是一个更实用且通常预先安装的组件，它使得在系统上运行正常的桌面Java应用程序成为可能，而无需浏览器端的任何参与。
- en: The reasons for the failure of Java as a browser technology are difficult to
    pinpoint. Perhaps it’s due to the plug-in’s poor startup performance, the clunky
    UI libraries that made it difficult to develop snappy and user-friendly web applications,
    or the history of vicious litigation between Sun and Microsoft that cast a long
    shadow over the future of the language on Microsoft’s operating systems.^([[41](#ftn.CHP-8-FN-3)])
    Whatever the reasons may be, the high install base of Java coupled with its marginal
    use means that the risks it creates far outweigh any potential benefits to the
    users. (The plug-in had close to 80 security vulnerabilities in 2010,^([[173](pr03.html#ftn.CHP-8-FT-13)])
    and the vendor is commonly criticized for patching such bugs very slowly.)
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: Java作为浏览器技术的失败原因难以确定。可能是因为插件的启动性能不佳，或者是因为笨拙的UI库使得开发快速且用户友好的Web应用程序变得困难，亦或是由于Sun和Microsoft之间长期的恶意诉讼，这对微软操作系统上语言的未来造成了长期的影响.^([[41](#ftn.CHP-8-FN-3)])
    无论原因是什么，Java的高安装基数加上其边缘化的使用意味着它带来的风险远远超过了对用户潜在的好处。（该插件在2010年几乎有80个安全漏洞，^([[173](pr03.html#ftn.CHP-8-FT-13)])
    而供应商通常因修补这些漏洞缓慢而受到批评。）
- en: Java’s security policies are somewhat similar to those of other plug-ins, but
    in some aspects, such as its understanding of the same-origin policy or its ability
    to restrict access to the embedding page, it compares unfavorably. (The next chapter
    provides an overview of this.) It is also worth noting that unlike with Flash
    or Silverlight, certain types of cryptographically signed applets may request
    access to potentially dangerous OS features, such as unconstrained networking
    or file access, and only a user’s easily coaxed consent stands in the way.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: Java的安全策略与其他插件有些相似，但在某些方面，例如对同源策略的理解或限制对嵌入页面的访问的能力，它并不占优势。（下一章将概述这一点。）值得注意的是，与Flash或Silverlight不同，某些类型的加密签名小程序可能请求访问潜在的操作系统功能，如不受限制的网络访问或文件访问，而只有用户的容易诱导的同意才能阻止。
- en: XML Browser Applications (XBAP)
  id: totrans-1055
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML浏览器应用程序（XBAP）
- en: XML Browser Applications (XBAP)^([[174](pr03.html#ftn.CHP-8-FT-14)]) is Microsoft’s
    heavy-handed foray into the world of web application frameworks, attempted in
    the years during which the battle over Java started going sour and before the
    company released Silverlight.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: XML浏览器应用程序（XBAP)^([[174](pr03.html#ftn.CHP-8-FT-14)]) 是微软在Web应用程序框架领域的强势介入，这一尝试发生在Java之战开始变得糟糕的年份，以及公司在发布Silverlight之前。
- en: XBAP is reminiscent of Silverlight in that it leverages the same Windows Presentation
    Foundation and .NET architecture. However, instead of being a self-contained and
    snappy browser plug-in, it depends on the large and unwieldy .NET runtime, in
    a manner similar to the Java plug-in’s dependence on JRE. It executes the managed
    code in a separate process called *PresentationHost.exe*, often loading extensive
    dependencies at initialization time. By Microsoft’s own admission, the load time
    of a medium-size previously uncached application could easily reach 10 seconds
    or more. When the technology premiered in 2002, most users were already expecting
    Internet applications to be far more responsive than that.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: XBAP与Silverlight相似，因为它利用了相同的Windows Presentation Foundation和.NET架构。然而，它并非是一个独立且快速的浏览器插件，而是依赖于庞大且难以驾驭的.NET运行时，这与Java插件的JRE依赖方式类似。它在一个名为*PresentationHost.exe*的独立进程中执行托管代码，通常在初始化时加载大量的依赖项。根据微软自己的说法，一个中等大小的先前未缓存的程序加载时间可能轻易达到10秒或更多。当这项技术在2002年首次推出时，大多数用户已经期待互联网应用程序的响应速度要远高于此。
- en: The security model of XBAP applications is poorly documented and has not been
    researched to date, perhaps due to XBAP’s negligible real-world use and obtuse,
    multilayer architecture. One would reasonably expect that XBAP’s security properties
    would parallel the model eventually embraced for Silverlight, but with broader
    access to certain .NET libraries and UI widgets. And, apparently as a result of
    copying from Sun, XBAP programs can also be given elevated privileges when loaded
    from the local filesystem or signed with a cryptographic certificate.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: XBAP应用程序的安全模型文档不完善，迄今为止尚未进行研究，可能是因为XBAP在现实世界中的使用微乎其微，并且其架构复杂、层次繁多。人们合理地预期，XBAP的安全特性最终将与Silverlight所采用的模型相平行，但将拥有对某些.NET库和UI小部件的更广泛访问权限。显然，由于从Sun那里借鉴，XBAP程序在从本地文件系统加载或使用加密证书签名时也可以获得提升的权限。
- en: Microsoft bundled XBAP plug-ins with its .NET framework to the point of silently
    installing nonremovable Windows Presentation Foundation plug-ins—not only in Internet
    Explorer but also in the competing Firefox and Chrome. This move stirred some
    well-deserved controversy, especially once the first vulnerability reports started
    pouring in. (Mozilla even temporarily disabled the plug-in through an automated
    update to protect its users.) Still, despite such bold and questionable moves
    to popularize it, nobody actually wanted to write XBAP applets, and inch by inch,
    the technology followed Java into the dustbin of history.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 微软将XBAP插件捆绑到其.NET框架中，以至于悄无声息地安装了不可删除的Windows Presentation Foundation插件——不仅限于Internet
    Explorer，还包括竞争的Firefox和Chrome。这一举动引起了一些应得的争议，尤其是当第一个漏洞报告开始涌现时。（Mozilla甚至通过自动更新暂时禁用了插件以保护其用户。）尽管如此，尽管有这些大胆且可疑的举措来推广它，实际上没有人想要编写XBAP小程序，并且这项技术一步一步地跟随Java进入了历史的垃圾堆。
- en: Eventually, Microsoft appeared to acknowledge this failure and chose to focus
    on Silverlight instead. Beginning with Internet Explorer 9, XBAP is disabled by
    default for Internet-originating content, and the dubious Firefox and Chrome plug-ins
    are no longer automatically pushed to users. Nevertheless, it seems reasonable
    to assume that at least 10 percent of all Internet users may be still browsing
    with a complex, partly abandoned, and largely unnecessary plug-in installed on
    their machines and will continue to do so for the next couple of years.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，微软似乎承认了这一失败，并选择专注于Silverlight。从Internet Explorer 9开始，XBAP默认禁用对互联网来源内容的支持，可疑的Firefox和Chrome插件也不再自动推送给用户。尽管如此，合理地假设至少有10%的所有互联网用户可能仍在使用安装在他们的机器上的复杂、部分废弃且很大程度上不必要的插件进行浏览，并且在未来几年内将继续这样做。
- en: '* * *'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[39](#CHP-8-FN-1)]) WebGL is a fairly recent attempt to bring OpenGL-based
    3D graphics to JavaScript applications. The first specification of the standard
    appeared in March 2011, and wide browser-level support is expected to follow.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[39](#CHP-8-FN-1)]) WebGL是相对较近的一次尝试，旨在将基于OpenGL的3D图形引入JavaScript应用程序。该标准的第一个规范于2011年3月出现，预计将得到广泛的浏览器级支持。
- en: ^([[40](#CHP-8-FN-2)]) Managed code is not executed directly by the CPU (which
    would be inherently unsafe, because CPUs are not designed to enforce web security
    rules). Rather, it is compiled to an intermediate binary form and then interpreted
    at runtime by a specialized virtual machine. This approach is faster than interpreting
    scripts at runtime and permits custom security policy enforcement as the program
    is being executed.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[40](#CHP-8-FN-2)]) 管理代码不是直接由 CPU 执行的（这本质上是不可取的，因为 CPU 并未设计用来强制执行网络安全规则）。相反，它被编译成中间二进制形式，然后在运行时由一个专门的虚拟机进行解释。这种方法比在运行时解释脚本要快，并且允许在程序执行过程中实施自定义的安全策略。
- en: ^([[41](#CHP-8-FN-3)]) The legal battles started in 1997, when Microsoft decided
    to roll out its own (and in some ways, superior) version of the Java virtual machine.
    Sun Microsystems sued, hoping to win an injunction that would force Microsoft
    to bundle Sun’s version instead. The two companies initially settled in 2001,
    but shortly thereafter they headed back to court. In the final settlement in 2004,
    Sun walked away with $1.6 billion in cash, but Windows users were not getting
    any Java runtime at all.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[41](#CHP-8-FN-3)]) 法律斗争始于 1997 年，当时微软决定推出自己的（在某些方面，更优越的）Java 虚拟机版本。太阳微系统公司提起诉讼，希望赢得一项禁令，迫使微软捆绑其版本。两家公司最初在
    2001 年达成和解，但不久之后，他们又回到了法庭。在 2004 年的最终和解中，太阳微系统公司获得了 16 亿美元现金，但 Windows 用户根本无法获得任何
    Java 运行时。
- en: ActiveX Controls
  id: totrans-1065
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActiveX 控件
- en: At its core, ActiveX is the successor to Object Linking and Embedding (OLE),
    a 1990 technology that made it possible for programs to reuse components of other
    applications in a standardized, language-independent way. A simple use case for
    ActiveX would be a spreadsheet application wishing to embed an editable vector
    image from a graphics-editing program or a simple game that wants to embed a video
    player.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，ActiveX 是对象链接和嵌入 (OLE) 的继承者，OLE 是一种 1990 年的技术，它使得程序能够以标准化的、语言无关的方式重用其他应用程序的组件。ActiveX
    的一个简单用例是一个电子表格应用程序希望嵌入来自图形编辑程序的可编辑矢量图像，或者一个简单的游戏希望嵌入视频播放器。
- en: 'The idea is not controversial, but by the mid-1990s Microsoft had decided that
    ActiveX made sense in the browser, too. After all, wouldn’t websites want to benefit
    from the same Windows components that desktop applications could rely on? The
    approach violates the idea of nurturing an open, OS-independent web, but it’s
    otherwise impressive, as illustrated by the following JavaScript example that
    casually creates, edits, and saves an Excel spreadsheet:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法并不具有争议性，但到了 1990 年代中期，微软已经决定 ActiveX 在浏览器中也是有意义的。毕竟，网站不会希望从桌面应用程序可以依赖的相同
    Windows 组件中受益吗？这种方法违反了培育一个开放、操作系统无关的网络的观念，但就以下 JavaScript 示例所示，它仍然令人印象深刻，该示例随意创建、编辑和保存了一个
    Excel 电子表格：
- en: '[PRE110]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Standards compliance aside, Microsoft’s move to ActiveX proved disastrous from
    a security standpoint. Many of the exposed ActiveX components were completely
    unprepared to behave properly when interacting with untrusted environments, and
    over the next 15 years, researchers discovered several hundred significant security
    vulnerabilities in web-accessible ActiveX controls. Heck, the simple observation
    that Firefox does not support this technology helped bolster its security image
    at the onset of the Second Browser Wars.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准兼容性之外，微软转向 ActiveX 的举措从安全角度来看是灾难性的。许多暴露的 ActiveX 组件在与不受信任的环境交互时完全未准备好正确行为，在接下来的
    15 年里，研究人员发现了数百个重要的安全漏洞，这些漏洞存在于可从网络访问的 ActiveX 控件中。事实上，Firefox 不支持这项技术的事实在第二次浏览器大战初期就帮助提升了其安全形象。
- en: 'Despite this fiasco, Microsoft stood by ActiveX defiantly, investing in gradually
    limiting the number of controls that could be accessed from the Internet and fixing
    the bugs in those it considered essential. Not until Internet Explorer 9 did Microsoft
    finally decide to let go: Internet Explorer 9 disables all ActiveX access by default,
    requiring several extra clicks to use it when needed.'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管发生了这次灾难，微软仍然坚定地支持 ActiveX，逐渐限制可以从互联网访问的控件数量，并修复了那些它认为至关重要的控件的漏洞。直到 Internet
    Explorer 9，微软才最终决定放手：默认情况下，Internet Explorer 9 禁用了所有 ActiveX 访问，需要点击几次才能在需要时使用它。
- en: Note
  id: totrans-1071
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The wisdom of delegating the choice to the user is unclear, especially since
    the permission granted to a site extends not only to legitimate content on that
    website but also to any payloads injected due to application bugs such as XSS.
    Still, Internet Explorer 9 is some improvement.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 将选择权委托给用户的智慧尚不明确，特别是考虑到授予网站的权限不仅限于该网站上的合法内容，而且还包括由于应用程序漏洞（如XSS）注入的任何有效载荷。尽管如此，Internet
    Explorer 9还是有一些改进。
- en: Living with Other Plug-ins
  id: totrans-1073
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他插件共存
- en: So far, we have covered almost all general-purpose browser plug-ins in use today.
    Although there is a long tail of specialized or experimental plug-ins, their use
    is fairly insignificant and not something that we need to take into account when
    surveying the overall health of the online ecosystem.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了今天使用的几乎所有通用浏览器插件。尽管存在大量专用或实验性插件，但它们的使用相对不显著，而且在评估整个在线生态系统的健康状况时，我们不需要考虑它们。
- en: Well, with one exception. An unspecified but probably significant percentage
    of online users can be expected to have an assortment of web-exposed browser plug-ins
    or ActiveX controls that they never knowingly installed, or that they were forced
    to install even though it’s doubtful that they would ever benefit from the introduced
    functionality.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，有一个例外。可以预期，一定比例的在线用户可能拥有各种暴露在网页上的浏览器插件或ActiveX控件，他们可能从未有意安装，或者尽管他们可能永远不会从引入的功能中受益，但他们被迫安装。
- en: This inexcusable practice is sometimes embraced by otherwise reputable and trusted
    companies. For example, Adobe forces users who wish to download Adobe Flash to
    also install GetRight, a completely unnecessary third-party download utility.
    Microsoft does the same with Akamai Download Manager on its developer-oriented
    website, complete with a hilarious justification (emphasis mine):^([[175](pr03.html#ftn.CHP-8-FT-15)])
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不可原谅的做法有时会被其他信誉良好且受信任的公司所接受。例如，Adobe强制希望下载Adobe Flash的用户也安装GetRight，这是一个完全不必要的第三方下载工具。微软在其面向开发者的网站上对阿卡迈下载管理器做了同样的事情，并附有令人捧腹的辩解（强调如下）:^([[175](pr03.html#ftn.CHP-8-FT-15)])
- en: What is the Akamai Download Manager and why do I *have* to use it?
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 阿卡迈下载管理器是什么，为什么我 *必须* 使用它？
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To help you download large files with reduced chance of interruption, some downloads
    require the use of the Akamai Download Manager.
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了帮助您以减少中断的机会下载大文件，一些下载需要使用阿卡迈下载管理器。
- en: The primary concern with software installed this way and exposed directly to
    malicious input from anywhere on the Internet is that unless it is designed with
    extreme care, it is likely to have vulnerabilities (and sure enough, both GetRight
    and Akamai Download Manager had some). Therefore, the risks of browsing with a
    completely unnecessary plug-in that only served a particular purpose once or twice
    far outweigh the purported (and usually unwanted) benefits.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式安装并直接暴露于来自互联网任何地方的恶意输入的软件的主要担忧是，除非它被极端小心地设计，否则它很可能存在漏洞（确实，GetRight和阿卡迈下载管理器都有一些）。因此，使用一次或两次就只服务于特定目的的完全不必要的插件所带来的风险，远远超过了其声称的（通常是不受欢迎的）好处。
- en: Security Engineering Cheat Sheet
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程备忘单
- en: When Serving Plug-in-Handled Files
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供插件处理的文件时
- en: '**Data from trusted sources:** Data from trusted sources is generally safe
    to host, but remember that security vulnerabilities in Flash, Java, or Silverlight
    applets, or in the Adobe Reader JavaScript engine, may impact the security of
    your domain. Avoid processing user-supplied URLs and generating or modifying user-controlled
    HTML from within plug-in-executed applets. Exercise caution when using the JavaScript
    bridge.'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自可信来源的数据：** 来自可信来源的数据通常可以安全托管，但请记住，Flash、Java或Silverlight小程序或Adobe Reader
    JavaScript引擎中的安全漏洞可能会影响您域的安全性。避免处理用户提供的URL，并在插件执行的applet中生成或修改用户控制HTML。在使用JavaScript桥接时保持谨慎。'
- en: '**User-controlled simple multimedia:** User-controlled multimedia is relatively
    safe to host, but be sure to validate and constrain the format, use the correct
    *Content-Type*, and consult the cheat sheet in [Chapter 13](ch13.html "Chapter 13. Content
    Recognition Mechanisms") to avoid security problems caused by content-sniffing
    flaws.'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户控制的简单多媒体：** 用户控制的多媒体相对安全，但务必验证和限制格式，使用正确的 *Content-Type*，并参考[第13章](ch13.html
    "第13章。内容识别机制")中的备忘单，以避免由内容嗅探漏洞引起的安全问题。'
- en: '**User-controlled document formats:** These are not inherently unsafe, but
    they have an increased risk of contributing security problems due to plug-in design
    flaws. Consider hosting from a dedicated domain when possible. If you need to
    authenticate the request to an isolated domain, do so with a single-use request
    token instead of by relying on cookies.'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户控制的文档格式**：这些格式本身并不具有固有的不安全性，但由于插件设计缺陷，它们可能导致更高的安全风险。在可能的情况下，考虑从专用域名托管。如果你需要验证对隔离域的请求，请使用一次性请求令牌而不是依赖cookie。'
- en: '**User-controlled active applications:** These are unsafe to host in sensitive
    domains.'
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户控制的活动应用程序**：这些在敏感域中托管是不安全的。'
- en: When Embedding Plug-in-Handled Files
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌入由插件处理的文件时
- en: Always make sure that plug-in content on HTTPS sites is also loaded over HTTPS,^([[42](#ftn.CHP-8-FN-4)])
    and always explicitly specify the *type* parameter on *<object>* or *<embed>*.
    Note that because of the non-authoritative handling of *type* parameters, restraint
    must be exercised when embedding plug-in content from untrusted sources, especially
    on highly sensitive sites.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要确保HTTPS站点上的插件内容也通过HTTPS加载，^([[42](#ftn.CHP-8-FN-4)]) 并且始终在`<object>`或`<embed>`上显式指定`*type*`参数。请注意，由于对`*type*`参数的非权威处理，在从不受信任的来源嵌入插件内容时，必须谨慎行事，尤其是在高度敏感的网站上。
- en: '**Simple multimedia:** It is generally safe to load simple multimedia from
    third-party sources, with the caveats outlined above.'
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单多媒体**：通常可以从第三方来源安全地加载简单多媒体，前提是上述警告得到遵守。'
- en: '**Document formats:** These are usually safe, but they carry a greater potential
    for plug-in and browser content-handling issues than simple multimedia. Exercise
    caution.'
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档格式**：这些通常比较安全，但与简单的多媒体相比，它们在插件和浏览器内容处理方面具有更大的潜在问题。请谨慎行事。'
- en: '**Flash and Silverlight:** In principle, Flash and Silverlight apps can be
    embedded safely from external sources if the appropriate security flags are present
    in the markup. If the flags are not specified correctly, you may end up tying
    the security of your site to that of the provider of the content. Consult the
    cheat sheet in [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic") for
    advice.'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flash和Silverlight**：原则上，如果标记中存在适当的安全标志，Flash和Silverlight应用程序可以从外部来源安全地嵌入。如果标志未正确指定，你可能会将你站点的安全性绑定到内容提供者的安全性。参见[第9章](ch09.html
    "第9章。内容隔离逻辑")中的cheat sheet以获取建议。'
- en: '**Java:** Java always ties the security of your service to that of the provider
    of the content, because DOM access to the embedding page can’t be reliably restricted.
    See [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic"). Do not load Java
    apps from untrusted sites.'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**：Java总是将你的服务安全性与内容提供者的安全性绑定在一起，因为无法可靠地限制对嵌入页面的DOM访问。参见[第9章](ch09.html
    "第9章。内容隔离逻辑")。不要从不受信任的站点加载Java应用程序。'
- en: If You Want to Write a New Browser Plug-in or ActiveX Component
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要编写一个新的浏览器插件或ActiveX组件
- en: Unless you are addressing an important, common-use case that will benefit a
    significant fraction of the Internet, please reconsider. If you are scratching
    an important itch, consider doing it in a peer-reviewed, standardized manner as
    a part of HTML5.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在解决一个重要且广泛使用的用例，这将使互联网的很大一部分受益，否则请重新考虑。如果你正在解决一个重要的需求，考虑以同行评审和标准化的方式作为HTML5的一部分来实现。
- en: '* * *'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[42](#CHP-8-FN-4)]) If loading an HTTP-delivered applet on an HTTPS page
    is absolutely unavoidable, it is safer to place it inside an intermediate HTTP
    frame rather than directly inside the HTTPS document, as this prevents the applet-to-JavaScript
    bridge from being leveraged for attacks.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[42](#CHP-8-FN-4)]) 如果在HTTPS页面上加载HTTP分发的applet是绝对不可避免的，将其放置在中间HTTP框架内而不是直接放置在HTTPS文档中会更安全，因为这可以防止利用applet到JavaScript的桥梁进行攻击。
