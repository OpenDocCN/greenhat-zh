<html><head></head><body>
  <h1><span class="chapter">Chapter 7 -</span><br/>
  A Brief Primer on Security</h1>

  <p>Hacking the Xbox requires security hacking in addition to hardware and <span style="font-size: 1em;">firmware hacking, as you discovered in the last chapter. We will go over</span> <span style="font-size: 1em;">some of the possible motivations behind adding sophisticated security to</span> <span style="font-size: 1em;">something as mundane as a gaming machine, and then we will dive into</span> <span style="font-size: 1em;">the basic principals and algorithms necessary to understand and appreci</span><span style="font-size: 1em;">ate the Xbox’s security mechanisms.</span></p>

  <h2 id="sigil_toc_id_52"><b class="calibre3">Who Needs Security, Anyways?</b></h2>

  <p>The video game console is a toy for most people: it’s low cost, consumer <span style="font-size: 1em;">electronics. Why did Microsoft go through such pains to secure their</span> <span style="font-size: 1em;">system? In the game of security hacking, quite frequently understanding the motive of the securer is helpful in finding weaknesses that you can</span> <span style="font-size: 1em;">exploit.</span></p>

  <p>Cryptography is not security. Cryptography is a means to an end for <span style="font-size: 1em;">security, but real security involves the entire system architecture, including the end users. As Kevin Mitnick said in a recent Slashdot interview,</span> <span style="font-size: 1em;">“. . . security is not a product that can be purchased off the shelf, but</span> <span style="font-size: 1em;">consists of policies, people, processes, and technology.”<sup>1</sup> I believe that</span> <span style="font-size: 1em;">security is</span> <i class="calibre4" style="font-size: 1em;">fundamentally</i> <span style="font-size: 1em;">a social concept. In practice, you can open your windows and leave the front door locked and people won’t just walk in through your window or pick your doorlock, even though both are</span> <span style="font-size: 1em;">relatively easy tasks. Locked doors and open windows work because a</span> <span style="font-size: 1em;">locked door is mostly a symbolic measure; it forces an intruder to make a</span> <span style="font-size: 1em;">conscious act of violation in order to enter a house, and that alone is</span> <span style="font-size: 1em;">enough to separate criminals from well-doers. Sony’s Playstation console</span> <span style="font-size: 1em;">has a good example of front-door lock security. The mechanism used to</span> <span style="font-size: 1em;">copy-protect their games is simple, involves no cryptography, and is</span> <span style="font-size: 1em;">easily overridden with easily installed, inexpensive hardware modifica</span><span style="font-size: 1em;">tions. Despite this, sales numbers indicate that purchasing Playstation</span> <span style="font-size: 1em;">games has not gone out of style; the front-door lock is working.</span></p>

  <p><span style="font-size: 1em;">Microsoft employs a variation of front-door lock style security. Video</span> <span style="font-size: 1em;">games for the Xbox are distributed using the (so far) uncopyable DVD-9</span> <span style="font-size: 1em;">format, a single-sided, dual layer media format. User-writeable DVDs,</span> <span style="font-size: 1em;">on the other hand, are always in DVD-5 format, a single-sided, single</span> <span style="font-size: 1em;">layer media format. DVD-9 capable burners are not likely to be avail</span><span style="font-size: 1em;">able soon due to the difficulty in making a writing system capable of</span> <span style="font-size: 1em;">burning one layer without affecting the integrity of the other layer. Thus, by distributing security data between the two layers of a DVD-9 disk and</span> <span style="font-size: 1em;">requiring a game executable to come from DVD-9 media, Microsoft has</span> <span style="font-size: 1em;">a fairly effective front-door lock on its video games. By judiciously</span> <span style="font-size: 1em;">requiring the DVD-9 format, Microsoft has pretty much forced any</span> <span style="font-size: 1em;">potential game copier into a realm where some kind of hardware</span> <span style="font-size: 1em;">modification is necessary.</span></p>

  <p>Why then would Microsoft risk investing in such a complex security scheme <span style="font-size: 1em;">on the Xbox? Is Microsoft’s main motivation really to quell piracy? It is</span> <span style="font-size: 1em;">quite possible that in fact the primary reason for the rest of the Xbox</span> <span style="font-size: 1em;">security system—the secure boot sectors, signed executables, trust relationships and encrypted/authenticated network protocols — lies not in anti</span><span style="font-size: 1em;">piracy measures.</span></p>

  <p>One possible motivation for all the security is to prevent the use of the <span style="font-size: 1em;">Xbox console for any purpose other than gaming. The Xbox console is in</span> <span style="font-size: 1em;">the unique position of being an almost 100 percent stock PC. Unlike the</span> <span style="font-size: 1em;">Gamecube and the Playstation2, there is an enormous body of software t</span><span style="font-size: 1em;">hat seems like it should just run on the Xbox, given the right BIOS</span> <span style="font-size: 1em;">programming. To make matters worse, Microsoft loses much more money</span> <span style="font-size: 1em;">on its console hardware than its competitors. Some estimate that its losses may be as high as $200 per console, assuming the most recent retail price of $199. Hence, it is in Microsoft’s interest to try and ensure that it is not selling subsidized GNU/Linux boxes. However, even this is probably not Microsoft’s main goal. The Xbox’s 64 MB of main memory, lack of a</span> <span style="font-size: 1em;">keyboard or mouse out of the box, and a fairly slow processor by today’s</span> <span style="font-size: 1em;">standards makes it less appealing than, for example, the $200 Microtel PC</span> <span style="font-size: 1em;">available at Walmart as of late 2002. In addition, Microsoft has deep</span> <span style="font-size: 1em;">pockets; if the Xbox gained market traction and outsold Sony’s</span> <span style="font-size: 1em;">Playstation2, Microsoft would only have to stomach a few billion dollars</span> <span style="font-size: 1em;">of upfront loss — relatively small in comparison to the roughly $40</span> <span style="font-size: 1em;">billion cash-pile on which it sits. Thus, it is quite possible that the critical mission of Xbox security is not to prevent alternative console uses or to deter piracy.</span></p>

  <p><span style="font-size: 1em;">Perhaps the real reason for the complex security of the Xbox is to ensure the success of Xbox Live, Microsoft’s on-line gaming service. Microsoft’s</span> <span style="font-size: 1em;">marketing hype and PR statements indicate that it is betting on the success</span> <span style="font-size: 1em;">of Xbox Live to drive hardware sales. Furthermore, Xbox Live is a</span> <span style="font-size: 1em;">subscription service, and one year from its launch users will have to pay a monthly fee. If Microsoft can get its subscribers hooked on Xbox Live,</span> <span style="font-size: 1em;">then all of a sudden the Xbox business looks quite profitable, even if a</span> <span style="font-size: 1em;">substantial amount of money is lost up-front on the hardware. The trick</span> <span style="font-size: 1em;">is, of course, hook Xbox users on Xbox Live. Billed as the “Disneyland</span> <span style="font-size: 1em;">of on-line gaming,” the goal of Xbox Live is to provide a well-executed</span> <span style="font-size: 1em;">and fair gaming experience. Central to the value proposition of Xbox</span> <span style="font-size: 1em;">Live that there are no cheaters. In order to ensure that nobody is cheat</span><span style="font-size: 1em;">ing, users must be forced to authenticate themselves against a registry</span> <span style="font-size: 1em;">maintained by Xbox Live, and their game state must be kept secure and</span> <span style="font-size: 1em;">unmodifiable. In addition, game software must be unpatched. Even more</span> <span style="font-size: 1em;">crucial is the fact that you only need a few cheaters to ruin the gaming</span> <span style="font-size: 1em;">experience of an entire user base. All of a sudden, the front-door security protections offered by the DVD-9 format seem inadequate. The odds are</span> <span style="font-size: 1em;">against you if you betting the success of a business on the morality and</span> <span style="font-size: 1em;">honor of a user base of millions of twenty-something hardcore male</span> <span style="font-size: 1em;">gamers with a reasonable amount of computer savvy distributed</span> <span style="font-size: 1em;">throughout. The hardware must be trustable, network connections</span> <span style="font-size: 1em;">secure, and executables signed and sealed.</span></p>

  <p>The statement that the hardware must be trustable bears repeating. Given an untrustable user base, the only way to establish a trust relationship with <span style="font-size: 1em;">clients is if a seed of trust exists in every piece of hardware. Hence,</span> <span style="font-size: 1em;">Microsoft must include in every client a piece of tamper-proof hardware that enables some kind of attestation. Attestation is the ability to prove that</span> <span style="font-size: 1em;">some piece of data, such as a player’s identity or game state, is in fact</span> <span style="font-size: 1em;">generated by untainted software and hardware. The tamper-proof</span> <span style="font-size: 1em;">hardware does not have to implement the attestation function directly,</span> <span style="font-size: 1em;">but it must at least ensure that the system is in a trustable state before</span> <span style="font-size: 1em;">attestation.</span></p>

  <p>There are many ways to ensure that hardware is trustable. The brute-<span style="font-size: 1em;">force method is to make the entire piece of hardware physically secure.</span> <span style="font-size: 1em;">Automated Teller Machines are prime examples of hardware that is</span> <span style="font-size: 1em;">physically secure. Sealed in thick sheet metal and covered with intrusion</span> <span style="font-size: 1em;">sensors, it is difficult to physically penetrate and modify the hardware of an ATM. Stil , hile effective, this is an impractical and expensive solution for a video game console.</span> <span style="font-size: 1em;">A more economical solution is to use a small piece of trusted tamper-proof</span> <span style="font-size: 1em;">hardware that can make “measurements” on the rest of the system. These</span> <span style="font-size: 1em;">sorts of measurements are typically accomplished through the use of a</span> <span style="font-size: 1em;">cryptographic hash function. If all of these trust measurements conform</span> <span style="font-size: 1em;">with the expected values, then one might be able to conclude that the entire system is trustable.</span></p>

  <p><span style="font-size: 1em;">I say might because this scheme is still vulnerable to man-in-the-middle</span> <span style="font-size: 1em;">attacks where a hacker sends spoofed valid data in response to a mea</span><span style="font-size: 1em;">surement query. Man-in-the-middle attacks refer to a general class of</span> <span style="font-size: 1em;">attacks where an adversary can freely modify and control the information</span> <span style="font-size: 1em;">being passed between two parties. Because of the man-in-the-middle</span> <span style="font-size: 1em;">weakness, it does not make sense to use an extremely sophisticated tamper</span><span style="font-size: 1em;">proof module to make the system measurements. A single packaged</span> <span style="font-size: 1em;">silicon chip is probably good enough, as it is typically easier to intercept and spoof the measurement data going past on a printed circuit board</span> <span style="font-size: 1em;">than it is to penetrate the epoxy package of a chip and modify the chip’s</span> <span style="font-size: 1em;">circuitry.</span></p>

  <p>The trust measurement system can be implemented using a measure-once <span style="font-size: 1em;">approach. Starting with the processor cold-boot sequence, every piece of</span> <span style="font-size: 1em;">code is measured for trust before execution. If the processor never executes untrusted code, then what is there not to trust? This scheme requires a very simple tamper-proof hardware module — a tamper-proof ROM that stores the cold-boot code, a “seed” of trust. The type of cryptography</span> <span style="font-size: 1em;">used for the measurement and verification process is typically a combina</span><span style="font-size: 1em;">tion of hashes and public-key cryptography. Public-key cryptography is</span> <span style="font-size: 1em;">preferred for this application because the private key required to generate a valid code segment is a secret kept by only the hardware vendor. Again,</span> <span style="font-size: 1em;">this scheme is vulnerable to many kinds of man-in-the-middle attacks, as</span> <span style="font-size: 1em;">well as pure cryptographic attacks and attacks on the implementation of</span> <span style="font-size: 1em;">the system.</span></p>

  <h2 id="sigil_toc_id_53"><b class="calibre3">A Brief Primer on Cryptography</b></h2>

  <blockquote>
    <b class="calibre3">ci·pher</b> ( <i class="calibre4">n</i>): <b class="calibre3">1 a</b>: ZERO <b class="calibre3">b</b>: one that has no weight, worth, or influence : NONENTITY. <b class="calibre3">2 a</b>: a method of transforming text in order to conceal its meaning — compare to CODE <sup>2</sup>
  </blockquote>

  <p>Ciphers provide no security on their own. More specifically, ciphers only <span style="font-size: 1em;">provide security if the key is secure, if the algorithm is strong, and if there are no back doors into the system. If someone hands you a CD-ROM</span> <span style="font-size: 1em;">encrypted with a strong cipher and locks you in a padded room with a</span> <span style="font-size: 1em;">supercomputer, the sun will probably go supernova before you can decrypt</span> <span style="font-size: 1em;">the CD-ROM. On the other hand, if you could observe and probe the</span> <span style="font-size: 1em;">machine as it was working to encrypt the CD-ROM, the encryption is moot.</span> <span style="font-size: 1em;">You could get the enciphering key by eavesdropping the keyboard. Or, you</span> <span style="font-size: 1em;">could dump the contents of the computer’s memory and obtain the</span> <span style="font-size: 1em;">plaintext without knowing the key.</span></p>

  <p>The situation with the Xbox is similar to the latter. Ultimately, the Xbox <span style="font-size: 1em;">must access and run the programs presented to it on valid disks. Further</span><span style="font-size: 1em;">more, the Pentium CPU used in the Xbox cannot tell the difference</span> <span style="font-size: 1em;">between an authorized instruction and an unauthorized instruction.</span> <span style="font-size: 1em;">Finally, the user has full access to probe and modify the Xbox hardware.</span> <span style="font-size: 1em;">Thus, even if the Xbox uses strong ciphers, the security of keys is</span> <span style="font-size: 1em;">questionable, and there may be back doors into the system.</span></p>

  <p><span style="font-size: 1em;">This section will briefly describe the kinds of cryptographic algorithms</span> <span style="font-size: 1em;">used in the Xbox. We will focus on the practical implications and</span> <span style="font-size: 1em;">implementation issues of these algorithms. You will need to understand</span> <span style="font-size: 1em;">these algorithms in order to appreciate the available attacks on the Xbox</span> <span style="font-size: 1em;">security system.</span></p>

  <div class="note">
    <h3 class="sigil_not_in_toc">Note</h3><img alt="" class="calibre2 note" src="../Images/index-123_1.png"/>

    <p><b class="calibre3">I make no pretense of addressing the theoretical aspects</b> <b class="calibre3" style="font-size: 1em;">of cryptography; those are beyond me and beyond the</b> <b class="calibre3" style="font-size: 1em;">scope of the book. Instead, I refer interested readers to</b> <b class="calibre3" style="font-size: 1em;">Bruce Schneier’s excellent book, <i class="calibre4">Applied Cryptography</i></b> <b class="calibre3" style="font-size: 1em;">(John Wiley &amp; Sons); most of my knowledge in cryptogra</b><b class="calibre3" style="font-size: 1em;">phy comes from that book. Readers who are already famil</b><b class="calibre3" style="font-size: 1em;">iar with cryptography should be able to skim or skip the</b> <b class="calibre3" style="font-size: 1em;">remainder of this chapter.</b></p>
  </div>

  <h3 id="sigil_toc_id_54"><b class="calibre3" style="font-size: 1em;">Classes of Cryptographic Algorithms</b><br/></h3>

  <p>There are a few important classes of cryptographic algorithms used in the <span style="font-size: 1em;">Xbox. These are:</span></p>

  <p>• Hashes</p>

  <p>• Symmetric ciphers</p>

  <p>• Public key ciphers</p>

  <p><i class="calibre4">Hashes</i> come in several varieties. Hashes of the cryptographic variety are used to summarize or “digest” a large amount of data. The summary is a number of fixed length, typically around 100 to 200 bits long, while the <span style="font-size: 1em;">source data can be of almost any size. The most important property of a</span> <span style="font-size: 1em;">hash is that it is a one-way computation. In other words, it is easy to</span> <span style="font-size: 1em;">compute the hash, but it is very difficult (see the sidebar “Very Difficult Problems” to understand exactly what this means) to derive sequences of</span> <span style="font-size: 1em;">data whose hash digest are identical or to determine anything about the</span> <span style="font-size: 1em;">original data from the hash.</span></p>

  <p>The strength of a hash against finding two sequences of data that hash to <span style="font-size: 1em;">the same value is referred to as its</span> <i class="calibre4" style="font-size: 1em;">collision resistance</i><span style="font-size: 1em;">, and in general, a good n-bit hash requires about 2n/2 random data sequences to be hashed and</span> <span style="font-size: 1em;">compared in order to cause a collision. Since hashes are designed to be</span> <span style="font-size: 1em;">very easy to compute and very collision-resistant, they are often used to</span> <span style="font-size: 1em;">detect whether a bit has been changed in large regions of secure data. For many applications, it is sufficient to include just an encrypted hash of a</span> <span style="font-size: 1em;">message in lieu of expending the computational effort to encrypt the</span> <span style="font-size: 1em;">whole message.</span></p>

  <p><i class="calibre4">Symmetric ciphers</i> are algorithms that have encryption and decryption keys that can be easily derived from one another. Most of the time, the <span style="font-size: 1em;">encryption and decryption keys are the same. Symmetric ciphers use a</span> <i class="calibre4" style="font-size: 1em;">mixing function</i> <span style="font-size: 1em;">to combine a</span> <i class="calibre4" style="font-size: 1em;">key schedule</i> <span style="font-size: 1em;">with data that has been processed by some</span><i class="calibre4" style="font-size: 1em;">cryptographic function</i><span style="font-size: 1em;">. This mixing may be repeated several times</span> <span style="font-size: 1em;">over a single block of data as in a block cipher, or it may occur once as in a stream cipher. All of the basic functions in a symmetric cipher are</span> <span style="font-size: 1em;">computationally simple, so symmetric ciphers are the preferred method</span> <span style="font-size: 1em;">for encrypting bulk data.</span></p>

  <p>Typical examples of mixing functions are XORs, modular additions and <span style="font-size: 1em;">modular multiplications. The simplest function, XOR, has the property</span> <span style="font-size: 1em;">that any number XOR itself is zero. The XOR operation is often denoted</span> <span style="font-size: 1em;">with a ⊕ symbol. The XOR operation also has all the usual properties of</span> <span style="font-size: 1em;">arithmetic (commutative, associative, distributive, etc.), so</span></p>

  <p><span style="font-size: 1em;">(A ⊕ B) ⊕ B = A ⊕ (B ⊕ B) = A ⊕ 0 = A</span></p>

  <p>Thus, if A were a message and B were a key, (A ⊕ B) would be the <span style="font-size: 1em;">ciphertext, and the plaintext can be recovered by simply performing an XOR</span> <span style="font-size: 1em;">with B again.</span></p>

  <p>A <i class="calibre4">key schedule</i> is an algorithm that takes a relatively short key and expands its information over a long series of bits. Key schedules are used to help diffuse the key data over a larger block of data so the relationship <span style="font-size: 1em;">between the ciphertext and the key is obscured.</span></p>

  <div class="infobox">
    <h2 class="sigil_not_in_toc"><b class="calibre3">Very Difficult Problems</b></h2>

    <p>Cryptographic functions are all based on mathematical al<span style="font-size: 1em;">gorithms whose results are easy to compute given all the op</span><span style="font-size: 1em;">erands, but whose operands are very difficult to compute given</span> <span style="font-size: 1em;">just the result. The security of a cryptographic function is pre</span><span style="font-size: 1em;">cisely the difficulty of computing these operands given just</span> <span style="font-size: 1em;">the results. Let us take a moment and explore what it means to</span> <span style="font-size: 1em;">be very difficult.</span></p>

    <p><span style="font-size: 1em;">Consider the symmetric cipher AES. It uses a 128-bit key, and</span> <span style="font-size: 1em;">so far, it is strong against all known analytical cryptographic</span> <span style="font-size: 1em;">attacks, such as differential and linear cryptanalysis. When I</span> <span style="font-size: 1em;">say it is strong against analysis X, I mean that it will require at</span> <span style="font-size: 1em;">least as many operations to recover the key or plaintext using</span> <span style="font-size: 1em;">a brute-force search as it would using analysis X. A brute-force</span> <span style="font-size: 1em;">search is when I take a very fast computer and try every one</span> <span style="font-size: 1em;">of the 2<sup>128</sup> possible keys in order to recover the original data.</span> <span style="font-size: 1em;">Most cryptographic algorithms in common use today are</span> <span style="font-size: 1em;">strong against all known cryptanalysis techniques, so the im</span><span style="font-size: 1em;">portant number to understand is the strength of a brute-force</span> <span style="font-size: 1em;">attack.</span></p>

    <p>As it turns out, older algorithms such as DES, a 56-bit cipher is <span style="font-size: 1em;">not a very difficult problem. It is fairly easy to build a machine</span> <span style="font-size: 1em;">using FPGAs (Field Programmable Gate Arrays) that can crack</span> <span style="font-size: 1em;">keys at an economy of about 2<sup>22</sup> keys/second/dollar (2</span><span style="font-size: 1em;"><sup>22</sup> is</span> <span style="font-size: 1em;">about four million). Note that this number increases with time</span> <span style="font-size: 1em;">at a rate equivalent to Moore’s Law. Today, if you are willing</span> <span style="font-size: 1em;">to wait about a week for each key, you can recover them for</span> <span style="font-size: 1em;">about the price of a nice car. Let’s hope that banks do not</span> <span style="font-size: 1em;">use DES to encrypt their account data!</span></p>

    <p style="font-size: medium;">The successor to DES, AES, is a cipher that can use 128, 192, or <span style="font-size: 1em;">56-bit keys. These keys are large enough to be considered</span> <span style="font-size: 1em;">impervious to brute-force attacks (i.e., a very difficult prob</span><span style="font-size: 1em;">lem). According to the AES Q&amp;A published by NIST (http://</span><span style="font-size: 1em;">csrc.nist.gov/encryption/aes/aesfact.html), a machine</span> <span style="font-size: 1em;">powerful enough to recover one DES key per second through</span> <span style="font-size: 1em;">brute force (trying on average 255 keys per second) would still</span> <span style="font-size: 1em;">require 149 trillion years to recover a 128-bit AES key. My favor</span><span style="font-size: 1em;">ite analysis of the strength of 256-bit keys against brute force</span> <span style="font-size: 1em;">attacks comes from Bruce Schneier’s Applied Cryptography.</span> <span style="font-size: 1em;">In his book, he uses an argument based on the amount of</span> <span style="font-size: 1em;">energy required to crack a 256-bit key. It turns out that even</span> <span style="font-size: 1em;">with a thermodynamically ideal computer, it would require</span> <span style="font-size: 1em;">over 32 times the annual energy output of our sun to just count</span> <span style="font-size: 1em;">to 2<sup>192</sup>, much less do anything useful with that count. (I must</span> <span style="font-size: 1em;">stress that all of this assumes that the most efficient attack is</span> <span style="font-size: 1em;">brute force. Who knows, maybe someone will discover a weak</span><span style="font-size: 1em;">ness in the algorithm that can be used to mount a much more</span> <span style="font-size: 1em;">efficient attack. New analysis techniques are constantly being</span> <span style="font-size: 1em;">invented that slowly chips away at the strength of a cipher.)</span></p>

    <p style="font-size: medium;">Public key ciphers, on the other hand, are based on a wide <span style="font-size: 1em;">variety of difficult to reverse mathematical operations, such as</span> <span style="font-size: 1em;">prime number multiplication and modular exponentiation. As</span> <span style="font-size: 1em;">a result, the key space for many public key ciphers is sparse,</span> <span style="font-size: 1em;">so more key bits are required for equivalent symmetric cipher</span> <span style="font-size: 1em;">security. As an example, key lengths in the RSA public-key ci</span><span style="font-size: 1em;">pher are typically several thousands of bits long.</span></p>

    <p style="font-size: medium;">The exact correlation between the security of RSA public key <span style="font-size: 1em;">lengths and symmetric cipher key lengths is unknown. The se</span><span style="font-size: 1em;">curity of RSA is thought to be the difficulty of factoring the</span> <span style="font-size: 1em;">products of large prime numbers; however, there may be other</span> <span style="font-size: 1em;">attacks yet to be discovered on the algorithm. Even so, the</span> <span style="font-size: 1em;">effective difficulty of factoring the product of large primes is</span> <span style="font-size: 1em;">reduced not only by advances in computing technology</span> <span style="font-size: 1em;">(Moore’s Law), but also by advances in number theory, such</span> <span style="font-size: 1em;">as the invention and refinement of the Quadratic Sieve and</span> <span style="font-size: 1em;">the General Number Field Sieve.</span> <span style="font-size: 1em;">In August 1999, a group of researches used the Number Field</span> <span style="font-size: 1em;">Sieve to factor a 512-bit prime number in 7.4 calendar months,</span> <span style="font-size: 1em;">including the time required to set up the factorizing run<sup>1</sup>. In</span> <span style="font-size: 1em;">addition, new technologies such as quantum computing</span> <span style="font-size: 1em;">promise to enable the factorization of prime numbers in poly</span><span style="font-size: 1em;">nomial time. I wouldn’t hold your breath, however; there is still</span> <span style="font-size: 1em;">debate as to whether it is possible to build a quantum com</span><span style="font-size: 1em;">puter large enough to factor an interesting prime.</span> <span style="font-size: 1em;">As of today, RSA Security, Inc. recommends key lengths of 1024</span> <span style="font-size: 1em;">bits for most corporate uses, and 2048 bits for “extremely valu</span><span style="font-size: 1em;">able keys”<sup>2</sup>. Bruce Schneier estimates in the second edition of</span> <span style="font-size: 1em;">Applied Cryptography that a 2304 bit public key length gives</span> <span style="font-size: 1em;">the equivalent security of a 128 bit symmetric key, and that a</span> <span style="font-size: 1em;">1792 bit public key length corresponds to about a 112 bit sym</span><span style="font-size: 1em;">metric key.</span></p>

    <p style="font-size: medium;">As you read about the Xbox security scheme, keep in mind <span style="font-size: 1em;">these basic guidelines about how difficult it can be to crack</span> <span style="font-size: 1em;">these security schemes using brute-force methods. Time after</span> <span style="font-size: 1em;">time, messages are posted on hacking forums and bulletin</span> <span style="font-size: 1em;">boards asking, “why don’t we start a distributed key search</span> <span style="font-size: 1em;">effort for these keys?” Now you know the answer.</span></p>

    <p><sup>1</sup> http://www.rsasecurity.com/rsalabs/challenges/factoring/rsa155.html</p>

    <p><sup>2</sup> http://www.rsasecurity.com/rsalabs/faq/3-1-5.html</p>
  </div>

  <p>A typical cryptographic function as used in a symmetric block cipher <span style="font-size: 1em;">consists of a set of carefully designed substitutions, permutations,</span> <span style="font-size: 1em;">compressions and expansions. These functions serve to confuse and</span> <span style="font-size: 1em;">diffuse the plaintext. Subtle changes in any piece of a cryptographic</span> <span style="font-size: 1em;">function typically have a profound effect on the security of a cipher.</span></p>

  <p><span style="font-size: 1em;">The fact that the encryption and decryption keys are closely related in a</span> <span style="font-size: 1em;">symmetric cipher makes them difficult to use in certain security applica</span><span style="font-size: 1em;">tions. For example, if I wish to distribute an encrypted document to a</span> <span style="font-size: 1em;">mailing list, everyone on the mailing list must also effectively know my</span> <span style="font-size: 1em;">encryption key if they can read the document. In addition, initiating</span> <span style="font-size: 1em;">contact with a remote party is difficult, because at some point I have to</span> <span style="font-size: 1em;">transmit a key to them. Someone observing the transmission medium</span> <span style="font-size: 1em;">could steal the key and read, forge, and modify all subsequent messages.</span></p>

  <p><i class="calibre4" style="font-size: 1em;">Public key ciphers</i> <span style="font-size: 1em;">are algorithms that use a different key for encryption and decryption. They are also referred to as asymmetric ciphers for this reason. The big advantage of public key ciphers is that one of the keys</span> <span style="font-size: 1em;">can be kept a secret. This allows data exchange with untrusted users</span> <span style="font-size: 1em;">without giving the untrusted user the ability to forge or read other</span> <span style="font-size: 1em;">protected content. The down side of public key algorithms is that they</span> <span style="font-size: 1em;">typically require more complex computations and are thus slower than</span> <span style="font-size: 1em;">symmetric ciphers. Public key ciphers also tend to require longer keys for</span> <span style="font-size: 1em;">equivalent security. As a result, if a large amount of data is to be ex</span><span style="font-size: 1em;">changed, public key ciphers are often used to encrypt a key for a symmet</span><span style="font-size: 1em;">ric cipher that is used to encrypt the bulk of the data. This symmetric</span> <span style="font-size: 1em;">cipher key can be unique to each transaction and hence it is often referred to as a “session key.”</span></p>

  <h4 id="sigil_toc_id_55"><b class="calibre3">SHA-1 Hash</b></h4>

  <p>SHA-1 is the Secure Hash Algorithm recommended by the Federal <span style="font-size: 1em;">government in FIPS publication 180-1 (http://www.itl.nist.gov/</span><span style="font-size: 1em;">fipspubs/fip180-1.htm). Devised by the NSA and based on Ronald L.</span> <span style="font-size: 1em;">Rivest’s MD4 message digest algorithm, SHA-1 works on messages of</span> <span style="font-size: 1em;">any length less than 264 bits in length, and it produces a 160 bit output.</span> <span style="font-size: 1em;">The SHA-1 hash algorithm starts with a deterministic 160-bit seed state;</span> <span style="font-size: 1em;">this state is blended with a block of 512 bits of message data over four</span> <span style="font-size: 1em;">rounds. Each round consists of a series of non-linear functions, rotations, shifts and XORs. The result of a round is used to seed the next round’s</span> <span style="font-size: 1em;">computation. In general, 280 random messages need to be generated,</span> <span style="font-size: 1em;">hashed and “simultaneously” compared in order to find two messages</span> <span style="font-size: 1em;">that have the same hash value (i.e., a hash collision). Finding two random</span> <span style="font-size: 1em;">messages that have the same hash is known as the “birthday attack,”</span> <span style="font-size: 1em;">named after the probabilistic phenomenon called the “birthday para</span><span style="font-size: 1em;">dox”: the probability that two people share the same birthday in a room</span> <span style="font-size: 1em;">of 23 people is better than 50%. On the other hand, 2160 random</span> <span style="font-size: 1em;">messages need to be generated, hashed and compared in order to find a</span> <span style="font-size: 1em;">message that hashes to the same value as a specific message. Thus, the</span> <span style="font-size: 1em;">strength of a hash function depends heavily upon the manner in which it</span> <span style="font-size: 1em;">is used.</span></p>
  <pre>

void encipher(unsigned long *const v,unsigned long *const w,
               const unsigned long *const k)
{
  register unsigned long
           y=v[0], z=v[1], sum=0, delta=0x9E3779B9,
           a=k[0], b=k[1], c=k[2], d=k[3], n=32;

  while(n—&gt;0) {
     sum += delta;
     y += (z &lt;&lt; 4)+a ^ z+sum ^ (z &gt;&gt; 5)+b;
     z += (y &lt;&lt; 4)+c ^ y+sum ^ (y &gt;&gt; 5)+d;
  }

   w[0]=y; w[1]=z;
}

</pre>

  <p class="caption"><b class="calibre3">Listing 7-1</b>: TEA Algorithm in ANSI C<sup>3</sup></p>

  <h4 id="sigil_toc_id_56"><b class="calibre3" style="font-size: 1em;">TEA</b><br/></h4>

  <p>TEA, or tiny encryption algorithm, was developed by David Wheeler <span style="font-size: 1em;">and Roger Needham at the Computer Laboratory of Cambridge</span> <span style="font-size: 1em;">University. (The developers have a web page for TEA at http://</span><span style="font-size: 1em;">vader.brad.ac.uk/tea/tea.shtml; much of the material pre</span><span style="font-size: 1em;">sented here is gleaned from that page.)</span></p>

  <p><span style="font-size: 1em;">As its name implies, TEA is a compact, fast encryption algorithm suitable</span> <span style="font-size: 1em;">for encrypting real-time data streams and embedded applications where</span> <span style="font-size: 1em;">processor performance and storage space is tight. TEA has a 128-bit key</span> <span style="font-size: 1em;">and it operates on 64-bits of data at a time, and each of its 32 rounds</span> <span style="font-size: 1em;">uses only shifts, XORs and additions. (The algorithm, given in Listing 7-1</span> <span style="font-size: 1em;">and Figure 7-2, is optimized for implementation on 32-bit general-</span><span style="font-size: 1em;">purpose processors.)</span></p>

  <p><img alt="figure_7-1" src="../Images/figure_7-1.png" style="font-size: 1em; width: 100%;"/><br/></p>

  <p class="caption"><b class="calibre3">Figure 7-1</b>: Tea cipher usage scenarios.</p>

  <p><img alt="figure_7-2" src="../Images/figure_7-2.png" style="font-size: 1em; width: 100%;"/><br/></p>

  <p class="caption"><b class="calibre3">Figure 7-2</b>: Inner structure of TEA. This diagram depicts a single round of TEA, which is repeated 32 times for the full cipher. The key schedule is described in the boxes on the right for use as both a cipher and as a hashing function.</p>

  <p><span style="font-size: 1em;">The bantam TEA algorithm is believed to be quite secure when used to</span> <span style="font-size: 1em;">encrypt and decrypt data. However, TEA is not used for encryption in</span> <span style="font-size: 1em;">the Xbox; it is actually used as a hash function by operating the cipher in a modified Davies-Meyer mode. The region to be hashed is divided into</span> <span style="font-size: 1em;">64-bit blocks. These source data blocks are used as half of the key input to TEA. The other half of the key input comes from the result of the</span> <span style="font-size: 1em;">previous TEA operation, and the first TEA operation uses a magic</span> <span style="font-size: 1em;">number as its input.</span></p>

  <p>The result is a 64-bit hash function, as depicted in Figure 7-1. This hash is weak against birthday attacks, especially given the computational efficiency of TEA, as only 2<sup>32</sup> message pairs need to be tested on average to find a collision. Even though a birthday attack does not apply in the <span style="font-size: 1em;">Xbox’s usage scenario, the Xbox runs the hash twice, each time with a</span> <span style="font-size: 1em;">different magic number seed, and concatenates the results to generate a</span> <span style="font-size: 1em;">single 128-bit hash value — probably in an attempt to foil brute-force</span> <span style="font-size: 1em;">attacks.</span></p>

  <p>Unfortunately, TEA has a weakness in its key schedule: every TEA key <span style="font-size: 1em;">has four related keys. In other words, for every key, you can generate</span> <span style="font-size: 1em;">three other keys that produce the same ciphertext result with the same</span> <span style="font-size: 1em;">input data. Related-key generation is as simple as complementing pairs of</span> <span style="font-size: 1em;">key bits (bits 31 and 63 is one pair, bits 95 and 127 are the other pair).</span> <span style="font-size: 1em;">This makes TEA unsuitable for use as a hash function, and this weakness</span> <span style="font-size: 1em;">is well documented in the paper “Key-schedule cryptanalysis of IDEA,</span> <span style="font-size: 1em;">G-DES, GOST, SAFER, and triple-DES,” by John Kelsey, Bruce</span> <span style="font-size: 1em;">Schneier, and David Wagner, presented many years ago at CRYPTO</span> <span style="font-size: 1em;">1996. This weakness was later leveraged by a team headed by Andy</span> <span style="font-size: 1em;">Green to break the second version of the Xbox security scheme.</span></p>

  <h4 id="sigil_toc_id_57"><b class="calibre3">RC-4</b></h4>

  <p>RC-4 (Ron’s Code or Rivest Cipher 4) is a variable key-length stream <span style="font-size: 1em;">cipher by Ron Rivest. The heart of RC-4 is the keystream generator. It</span> <span style="font-size: 1em;">can be thought of as a cryptographic pseudo-random number generator</span> <span style="font-size: 1em;">(CPRNG). The output of the CPRNG is XOR’d one byte at a time with a</span> <span style="font-size: 1em;">plaintext stream to generate the ciphertext. Decryption is accomplished in a similar fashion. Loosely speaking, the generator is “seeded” with a value</span> <span style="font-size: 1em;">(the key) of up to 256 bytes (2048 bits) long. If the key is shorter than 256</span> <span style="font-size: 1em;">bytes, it is repeated to fill out the 256 bytes before use as a seed; this enables variable-length keys. In the Xbox, the key is 16 bytes (128 bits) in length, and thus the cipher is dubbed RC-4/128.</span></p>
  <pre>
typedef struct rc4_key {
  unsigned char state[256];
  unsigned char x;
  unsigned char y;
} rc4_key;

void prepare_key(unsigned char *key_data_ptr, int key_data_len,
                rc4_key *key) {
  unsigned char swapByte, index1, index2;
  unsigned char* state;
  short counter;
  
  state = &amp;key-&gt;state[0];
  for(counter = 0; counter &amp;lt; 256; counter++)
    state[counter] = counter;
    key-&gt;x = 0;     key-&gt;y = 0;
    index1 = 0;     index2 = 0;
  for(counter = 0; counter &amp;lt; 256; counter++) {
    index2 = (key_data_ptr[index1] + state[counter] +
              index2) % 256;
    swap_byte(&amp;state[counter], &amp;state[index2]);
    index1 = (index1 + 1) % key_data_len;
  }
}

void rc4(unsigned char *buffer_ptr, int buffer_len, rc4_key
        *key) {
  unsigned char x, y, xorIndex;
  unsigned char* state;
  short counter;
  
  x = key-&gt;x;     y = key-&gt;y;
  
  state = &amp;key-&gt;state[0];
  for(counter = 0; counter &amp;lt; buffer_len; counter ++) {
    x = (x + 1) % 256;
    y = (state[x] + y) % 256;
    swap_byte(&amp;state[x], &amp;state[y]);
    xorIndex = state[x] + (state[y]) % 256;
    buffer_ptr[counter] ^= state[xorIndex];
  }
  key-&gt;x = x;     key-&gt;y = y;
}
</pre>

  <p class="caption"><b class="calibre3">Listing 7-2</b>: RC-4 code in C, from original Usenet posting.<sup>4</sup></p>

  <p><span style="font-size: 1em;">RC-4 is thought to be a strong cipher, although there are a few known</span> <span style="font-size: 1em;">weaknesses in the key scheduling algorithm that can be leveraged in poorly</span> <span style="font-size: 1em;">designed cryptosystems, such as WEP. Scott Fluhrer, Itsik Mantin, and Adi</span> <span style="font-size: 1em;">Shamir document these weaknesses in a paper titled “Weaknesses in the Key</span> <span style="font-size: 1em;">Scheduling Algorithm of RC4,” presented at the Eighth Annual Workshop</span> <span style="font-size: 1em;">on Selected Areas in Cryptography (August 2001). None of these weak</span><span style="font-size: 1em;">nesses can be applied against the Xbox’s implementation of RC-4.</span></p>

  <p><span style="font-size: 1em;">There is, however, a potential problem in the way that RC-4 is used in the</span> <span style="font-size: 1em;">first version of the Xbox security. RC-4 is used on the Xbox to encipher a stream of x86 code, and no significant check is performed on the deciphered code to ensure the integrity of the plaintext. This means that changes in the ciphertext wil lead to changes in the code that the Xbox executes. The trick is to figure out a change in the ciphertext that leads to a meaningful code modification. Since RC-4 encrypts one byte at a time and x86 opcodes can be as short as a single byte, it requires no more than 2<sup>8</sup> = 256</span> <span style="font-size: 1em;">iterations to “brute force” an instruction into a single known location by</span> <span style="font-size: 1em;">mutating the ciphertext.</span></p>

  <p>Determing which location to brute force can be tricky, but I suspect a lot <span style="font-size: 1em;">of information could be derived by mutating ciphertext bits and</span> <span style="font-size: 1em;">observing what happens to the pattern of instruction fetches, even with</span> <span style="font-size: 1em;">the caches turned on. The goal would be to try and identify the location</span> <span style="font-size: 1em;">of a jump opcode’s operands and to modify the jump destination such</span> <span style="font-size: 1em;">that the secured program jumps into an unsecured region of memory.</span> <span style="font-size: 1em;">The process would be similar to playing the classic board game “Battle</span><span style="font-size: 1em;">ship.” Keep in mind that the attack is so easy that guessing through a</span> <span style="font-size: 1em;">kilobyte of code only requires a maximum of 218 iterations. The guessing</span> <span style="font-size: 1em;">process could be automated by integrating a logic analyzer with a ROM</span> <span style="font-size: 1em;">emulator via a control script running on a host computer.</span></p>

  <p>The history behind RC-4 is actually quite interesting. RC-4 was invented <span style="font-size: 1em;">in 1987 by Ron Rivest, and was kept as a trade secret by RSA Security,</span> <span style="font-size: 1em;">Inc. until it was released in 1994 by an anonymous post to a cypherpunks</span> <span style="font-size: 1em;">mailing list (see Listing 7-2). As a result of RC-4’s virtues of simplicity and robustness, it has found its way into numerous applications, including WEP, SSL, SQL, and CDPD. While the source code for RC-4 is widely</span> <span style="font-size: 1em;">distributed and well known, the cipher is still the intellectual property of RSA Security. I wouldn’t recommend integrating it into a commercial</span> <span style="font-size: 1em;">product without first obtaining a license from RSA Security.</span></p>

  <div>
    <img alt="figure_7-3" src="../Images/figure_7-3.png" style="width: 100%;"/><br/>
  </div>

  <p><b class="calibre3">Figure 7-3</b>: Use of RSA with session keys.</p>

  <p><img alt="figure_7-4" src="../Images/figure_7-4.png" style="width: 100%;"/><br/></p>

  <p><b class="calibre3">Figure 7-4</b>: RSA used to implement digital signatures.</p>

  <h4 id="sigil_toc_id_58"><b class="calibre3" style="font-size: 1em;">RSA</b><br/></h4>

  <p>RSA is a public-key algorithm devised by Ron Rivest, Adi Shamir and <span style="font-size: 1em;">Leonard Adleman in 1977. In a public-key algorithm, two distinct keys are</span> <span style="font-size: 1em;">used, a public key and a private key. As their names imply, the private key must be kept secret, while the public key can be freely distributed. The</span> <span style="font-size: 1em;">math behind RSA is briefly described in the sidebar titled “The RSA</span> <span style="font-size: 1em;">Algorithm.” You need not understand the details of the math behind</span> <span style="font-size: 1em;">RSA to grasp how RSA is used in the context of the Xbox.</span></p>

  <p>Brute-force attacks are currently thought to be infeasible on RSA with <span style="font-size: 1em;">keylengths in excess of about a thousand bits. Also note that one cannot</span> <span style="font-size: 1em;">be too cavalier about how RSA is integrated into a cryptosystem. There</span> <span style="font-size: 1em;">are some attacks against protocols that use RSA, such as tricking the</span> <span style="font-size: 1em;">private key holder into signing carefully crafted messages that can then be used to derive the signer’s private key.</span></p>

  <p>Encrypting a message using RSA is as simple as invoking RSA on a <span style="font-size: 1em;">message. However, RSA encryption works on message blocks that are too</span> <span style="font-size: 1em;">short and the encryption process is too slow to be practical for most</span> <span style="font-size: 1em;">messages. Thus, RSA is typically used to encrypt a single-use random key,</span> <span style="font-size: 1em;">called a session key, for a fast symmetric cipher such as AES that is then used to encrypt the bulk message. This process is illustrated in Figure 7-3.</span></p>

  <p>In addition to encryption, RSA enables digital signatures. A digital signature allows parties exchanging messages over an insecure medium to guarantee <span style="font-size: 1em;">that messages are not forged and are not modified. The message does not</span> <span style="font-size: 1em;">have to be encrypted. A typical digital signature protocol works as</span> <span style="font-size: 1em;">follows: The sender computes a hash of the message to be sent. This hash</span> <span style="font-size: 1em;">is then encrypted with the sender’s private key and included with the</span> <span style="font-size: 1em;">message plaintext. The receiver decrypts the encrypted message hash</span> <span style="font-size: 1em;">using the sender’s public key, and compares this hash against a locally</span> <span style="font-size: 1em;">computed hash of the received message. If the decrypted hash sent with</span> <span style="font-size: 1em;">the message and the locally computed hash agree, then the receiver could</span> <span style="font-size: 1em;">conclude that the message is authentic and unaltered. This process is</span> <span style="font-size: 1em;">outlined in Figure 7-4.</span></p>

  <div class="infobox">
    <h2 class="sigil_not_in_toc"><b class="calibre3" style="font-size: 1em;">The RSA Algorithm</b><br/></h2>

    <p>The RSA algorithm was patented by the Massachusetts <span style="font-size: 1em;">Institute of Technology and exclusively licensed to RSA Data</span> <span style="font-size: 1em;">Security, Inc in 1983. The patent on the RSA algorithm has</span> <span style="font-size: 1em;">since expired in September 2000. Thus, today RSA is free to</span> <span style="font-size: 1em;">use in any application. Many excellent tutorials and edu</span><span style="font-size: 1em;">cational examples using RSA can now be found on the</span> <span style="font-size: 1em;">Internet. Perform a Google search using the keywords “RSA</span> <span style="font-size: 1em;">algorithm” to find some of these examples.</span></p>

    <p>The RSA algorithm is as follows (adapted from http://<span style="font-size: 1em;">world.std.com/~franl/crypto/rsa-guts.html):</span></p>

    <p>1. Find two large (thousands of bits long) prime numbers, “P” <span style="font-size: 1em;">and “Q”.</span></p>

    <p>2. Choose “E” such that E &gt; 1, E &lt; PQ, and E is relatively prime <span style="font-size: 1em;">to (P-1)(Q-1). E does not have to be prime, but it must be</span> <span style="font-size: 1em;">odd. <b>The pair of E and PQ are the public key.</b></span></p>

    <p>3. Compute “D” such that (DE - 1) is evenly divisible by <span style="font-size: 1em;">(P-1)(Q-1). This can be accomplished by finding an integer</span> <span style="font-size: 1em;">X which causes D = (X(P-1)(Q-1) + 1)/E to be an integer. <b>D is</b></span> <span style="font-size: 1em;"><b>the private key.</b></span></p>

    <p>4. Plaintext “T” is encrypted using the function</p>

    <p>C = (T<sup>E</sup>) mod PQ</p>

    <p>5. Ciphertext “C” is decrypted using the function</p>

    <p>T = (C<sup>D</sup>) mod PQ</p>

    <p>Note that T &lt; PQ. Messages larger than PQ must be broken <span style="font-size: 1em;">down into a sequence of smaller messages, and very short</span> <span style="font-size: 1em;">messages must be padded with carefully selected values</span> <span style="font-size: 1em;">to foil dictionary attacks, among other things.</span></p>
  </div>

  <p>If this protocol sounds complex to you, it is. There are a lot of places <span style="font-size: 1em;">where things can go wrong. The receiver could have a false copy of the</span> <span style="font-size: 1em;">sender’s public key. The sender could have had his private key compro</span><span style="font-size: 1em;">mised. The hash could have weaknesses. Employing digital signatures in</span> <span style="font-size: 1em;">an adversarial environment requires attention to detail at all levels of the system design.</span></p>

  <p>In the Xbox, digital signatures are used to control the distribution and sale of programs for the console. Microsoft is effectively in control of both the sender and the receiver of messages. The receivers — Xbox consoles — are programmed to only run programs that are digitally signed by <span style="font-size: 1em;">Microsoft. In an ideal world, this guarantees that Microsoft has the final</span> <span style="font-size: 1em;">word on who can or cannot run programs on the console, and hackers</span> <span style="font-size: 1em;">cannot modify games to insert viruses, Trojan horses, or back doors.</span> <span style="font-size: 1em;">Saved games are also sealed using encryption, and as a result, it is</span> <span style="font-size: 1em;">nominally impossible to hack a game and cheat by patching the execut</span><span style="font-size: 1em;">able or by jacking up your character stats.</span></p>

  <p><span style="font-size: 1em;">Clearly, a pivotal issue in hacking the Xbox console is their implementation of the digital signature system. The Xbox uses a SHA-1 hash with 2048-bit</span> <span style="font-size: 1em;">RSA keys, making the chance of a successful brute force attack very, very slim.</span> <span style="font-size: 1em;">Of course, the probability is zero if you never try, but the odds are stacked against you (see the sidebar “Very Difficult Problems”). You’ll have better luck trying to win the lottery. This is by no mistake; the discovery of the private key would make game copying trivial and developers would not have to pay royalties to Microsoft (legally, they may be obligated but there is no technical reason preventing them). Given that this key is probably worth a few billion dollars to Microsoft, it is quite likely that no single human</span> <span style="font-size: 1em;">knows the full key, as rubber-hose (beatings) and green-paper (bribery)</span> <span style="font-size: 1em;">cryptanalysis techniques tend to be quite effective on humans. (Do</span> <i class="calibre4" style="font-size: 1em;">not</i> <span style="font-size: 1em;">discount real “brute force” as a possibility if you are trying to protect an extremely valuable secret!) Products such as BBN’s SignAssure™ certificate</span> <span style="font-size: 1em;">authority management system ensure the physical security of high-value</span> <span style="font-size: 1em;">keys and implement secret-sharing schemes that require multiple trusted</span> <span style="font-size: 1em;">users to activate the machine.</span></p>

  <p>As mentioned previously, there are a few known viable attacks against RSA, <span style="font-size: 1em;">but not all of them apply in the Xbox scenario, as they rely on groups of</span> <span style="font-size: 1em;">users or require chosen-ciphertext. In addition, the list of weaknesses is</span> <span style="font-size: 1em;">widely known and most implementations of digital signatures implement</span> <span style="font-size: 1em;">the proper countermeasures to protect against such attacks.</span></p>

  <h4 id="sigil_toc_id_59"><b class="calibre3">The Rest of the Picture</b></h4>

  <p>An effective security system needs good key management, strong <span style="font-size: 1em;">protocols, and in the case of the Xbox, physical security in addition to</span> <span style="font-size: 1em;">strong ciphers and hashes.</span></p>

  <p>Key management is perhaps one of the most difficult system implementa<span style="font-size: 1em;">tion tasks that face any security architect. Ultimately, the decryption keys need to go into the hands of a user. The user interface must be designed so that the average user with minimum training does not accidentally leak</span> <span style="font-size: 1em;">key information. As ciphers become stronger, the easiest path of attack is increasingly through the user. Eavesdropping through surveillance videos,</span> <span style="font-size: 1em;">social engineering, or even analyzing the pattern of sounds made by the</span> <span style="font-size: 1em;">keyboard as a password is typed will probably yield more information per</span> <span style="font-size: 1em;">unit effort about a passphrase than cryptanalysis. Public key cryptography</span> <span style="font-size: 1em;">partially helps solve the problem of key distribution, but public key</span> <span style="font-size: 1em;">fingerprints should be compared in person to rule out the possibility of</span> <span style="font-size: 1em;">man-in-the-middle attacks. Public key cryptography also does not</span> <span style="font-size: 1em;">prevent someone with physical access to the client machine from eaves</span> <span style="font-size: 1em;">dropping on the decrypted output.</span></p>

  <p>In addition, protocol attacks find weaknesses in the way keys and data are <span style="font-size: 1em;">manipulated, or in the way strong ciphers are used. The WEP attack on</span> <span style="font-size: 1em;">RC-4 and Mike Bond and Ross Anderson’s attack on the IBM 4758</span> <span style="font-size: 1em;">Cryptoprocessor are both examples of protocol attacks. The red flags</span> <span style="font-size: 1em;">for potential protocol attacks are systems that implement backward-</span><span style="font-size: 1em;">compatibility measures, and systems that are implemented by engineers</span> <span style="font-size: 1em;">whose primary job is not crypto-security.</span></p>

  <p>Finally, in a system like the Xbox where one of the goals is to establish a trustable client, back doors and buffer-overrun attacks are also viable attacks on the trust state of a machine. No widely used commercial processors embed execution privileges within instruction streams or data tags. Proces<span style="font-size: 1em;">sors blindly execute any piece of code that it is instructed to jump to,</span> <span style="font-size: 1em;">whether or not the jump was induced through a transient hardware failure</span> <span style="font-size: 1em;">or through maliciously placed code. Periodic hashes on the machine state can be used to counter this deficiency, but even then the state checks can be</span> <span style="font-size: 1em;">spoofed.</span></p>

  <p>As discussed in the beginning of this chapter, establishing the trust state of a client also requires a piece of tamper-resistant hardware to carry the seed of trust. The amount of physical security must be enough to make it uneconomical to defeat the security once, and robust enough such that <span style="font-size: 1em;">one instance of broken security does not enable trivial attacks on the</span> <span style="font-size: 1em;">remainder of the consoles. Some of the trade-offs when designing</span> <span style="font-size: 1em;">physical security as well as the decisions made by Microsoft to this end</span> <span style="font-size: 1em;">are discussed in the next chapter.</span></p>

  <p>The moral of this chapter is that security requires a well-designed <i class="calibre4">system</i>. <span style="font-size: 1em;">Although ciphers have become strong enough to make brute-force attacks</span> <span style="font-size: 1em;">moot, systems have grown in complexity. This complexity increases the</span> <span style="font-size: 1em;">likelihood of a viable protocol or back door attack, yet does little to save users from the more traditional eavesdropping, rubber-hose and user-error</span> <span style="font-size: 1em;">attacks.</span></p>
  <hr class="sigil_split_marker"/>

  <p><sup>1</sup> http://interviews.slashdot.org/article.pl?sid=03/02/04/2233250&amp;mode=nocomment&amp;tid=103&amp;tid=123&amp;tid=172<br/></p>

  <p><sup>2</sup> Merriam-Webster OnLine Dictionary (www.webster.com).<br/></p>

  <p><sup>3</sup> Code is from http://vader.brad.ac.uk/tea/source.shtml#ansi</p>

  <p><sup>4</sup> Code from http://www.cc.jyu.fi/~paasivir/crypt/rciv/rc4article.txt. Minor white-space modifications to make it all fit on one page. The swap byte function definition is also not included, but you can guess what it does by its name.</p>
</body></html>