<html><head></head><body><section class="chapter" epub:type="chapter" id="kernel_configuration" title="Chapter&#xA0;18.&#xA0;Kernel Configuration"><div class="titlepage"><div><div><h2 class="title">Chapter 18. Kernel Configuration</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Kernel, not colonel!</em></span><br/>
<span class="emphasis"><em>This is blowfish, not chicken.</em></span><br/>
<span class="emphasis"><em>Less grease, more function.</em></span></p></div></div><p><span class="inlinemediaobject"><a id="inline_id00019"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> Depending on your systems administration experience and background, the kernel is a subject of great mystery and speculation. It might be something you reconfigure when the whim strikes you, or something you know to leave alone.</p><p>Most commercial operating systems provide only a few basic hooks for configuring the kernel. Many open source operating systems tell you to rebuild the kernel from source code whenever you change anything.</p><p>OpenBSD falls somewhere in the middle.</p><p>The standard OpenBSD kernel is intended to be perfectly usable without modifications, but you have the tools to perform any tweaks or adjustments necessary for your environment. Additionally, you have the complete source code and kernel-building tools in case you decide to perform wholesale kernel surgery.</p><p><a class="indexterm" id="idx0430"/><a class="indexterm" id="idx0502"/><a class="indexterm" id="idx1139"/><a class="indexterm" id="idx1155"/><a class="indexterm" id="idx1157"/><a class="indexterm" id="idx1358"/><a class="indexterm" id="idx1359"/><a class="indexterm" id="idx2298"/><a class="indexterm" id="idx2352"/><a class="indexterm" id="idx2538"/><a class="indexterm" id="idx2588"/>OpenBSD lets you adjust kernel behavior even as the system is running, via <code class="literal">sysctl(8)</code>. Some hardware or protocols require special OpenBSD kernel tweaks to run in specific environments. This chapter will cover both kinds of changes, but first, let’s talk about the kernel in general.</p><div class="sect1" title="What Is the Kernel?"><div class="titlepage"><div><div><h2 class="title" id="what_is_the_kernel" style="clear: both">What Is the Kernel?</h2></div></div></div><p>“The file <span class="emphasis"><em>/bsd</em></span> is OpenBSD’s kernel. Next question?”</p><p>That’s technically correct, but not exactly useful. A more general description is that “The kernel is the interface that links applications and the hardware.” That’s not a complete definition, but it’s good enough.</p><p>The kernel allows programs to write data to disk drives and to the network, and it gives instructions to the CPU and shuffles bits into memory. When you open a web page, the browser application asks the kernel to fetch the data it displays.</p><p>Some kernel responsibilities exceed this definition. For example, the kernel handles network connectivity, including forwarding packets from one interface to another if needed. The packet-filtering rules run in the kernel (although the rules are managed by applications). The kernel handles disk redundancy. And the kernel also handles all sorts of things that don’t impact applications but are integral to a functioning system.</p><p>A simplified view is to think of the kernel as the program that handles all the low-level functions, which is close enough to give you an idea of what the kernel does.</p><p>Along with <span class="emphasis"><em>kernel</em></span>, you’ll also hear the term <span class="emphasis"><em>userland</em></span>. Userland is everything in the system that isn’t the kernel. Your shells, libraries, and applications are all part of userland.</p><div class="sect2" title="Kernel Messages"><div class="titlepage"><div><div><h3 class="title" id="kernel_messages">Kernel Messages</h3></div></div></div><p>The kernel issues messages to userland. These include hardware attaching and detaching alerts, warnings from device drivers, and system boot messages. If you’re logged on to the system console in text mode, you might notice these messages.</p><p>To review kernel messages, you can watch the console, check the system logs (as discussed in <a class="xref" href="ch15.html" title="Chapter 15. System Maintenance">Chapter 15</a>), or use <code class="literal">dmesg(8)</code>.</p><p>OpenBSD has a system message buffer, where it sends messages from the kernel. These messages are usually copied to the system logger, but they’re also accessible via <code class="literal">dmesg</code>.</p><p>The system message buffer is circular. As it fills up, the oldest messages are deleted to make room for new ones. Run <code class="literal">dmesg</code> to view it.</p></div><div class="sect2" title="Startup Messages"><div class="titlepage"><div><div><h3 class="title" id="startup_messages">Startup Messages</h3></div></div></div><p>One common question is “What hardware did your kernel find?” If the kernel handles all the device drivers and other hardware support, the list of devices found should include all the supported hardware in the system.</p><p><a class="indexterm" id="idx0021"/><a class="indexterm" id="idx0022"/><a class="indexterm" id="idx0035"/><a class="indexterm" id="idx0142"/><a class="indexterm" id="idx0423"/><a class="indexterm" id="idx0948"/><a class="indexterm" id="idx1275"/>While the system message buffer is circular, OpenBSD copies the boot-time system messages into <span class="emphasis"><em>/var/run/dmesg.boot</em></span>. Here are the boot messages from one of my test systems.</p><a id="I_programlisting18_id487753"/><pre class="programlisting">OpenBSD 5.2-current (GENERIC) #287: Tue Aug 21 18:15:00 MDT 2013
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
cpu0: AMD Opteron(tm) Processor 4184 ("AuthenticAMD" 686-class, 512KB L2 cache) 2.80 GHz
cpu0:FPU,V86,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,CMOV,PAT,
PSE36,CFLUSH,MMX,FXSR,SSE,SSE2,NXE,MMXX,FFXSR,LONG,3DNOW2,3DNOW,SSE3,CX16,
POPCNT,LAHF,ABM,SSE4A
real mem  = 267907072 (255MB)
avail mem = 252616704 (240MB)
…</pre><p>The first line lists the version of OpenBSD, the kernel name and version, the date the kernel was built, as well as the machine and directory where the kernel was built and who built it. This machine runs an official OpenBSD i386 snapshot, built by Theo de Raadt.</p><p>We then see some specifics on the processor. Those familiar with AMD will note that this is a 64-bit amd64 processor. I chose to run the 32-bit i386 version of OpenBSD, because that’s the installation disk I had handy.</p><p>This system came with 256MB of RAM, but 1MB is lost due to hardware-level weirdness. OpenBSD sees 255MB, and 240MB are available to programs other than the kernel at this moment. The kernel might use some of that memory later.</p></div><div class="sect2" title="Device Attachments"><div class="titlepage"><div><div><h3 class="title" id="device_attachments">Device Attachments</h3></div></div></div><p>The kernel then explores the hardware. When it finds hardware that matches a device driver, it attaches the device driver to the hardware.</p><a id="I_programlisting18_id487792"/><pre class="programlisting">mainbus0 at root
bios0 at mainbus0: AT/286+ BIOS, date 10/13/09, BIOS32 rev. 0 @ 0xfd780, SMBIOS rev. 2.4 @ 0xe0010 (98 entries)
bios0: vendor Phoenix Technologies LTD version "6.00" date 10/13/2009
bios0: VMware, Inc. VMware Virtual Platform
acpi0 at bios0: rev 2</pre><p>OpenBSD found the main system bus, <code class="literal">mainbus0</code>, which is a bit odd because it’s not actually a piece of hardware. The kernel creates this logical device as a point for all other devices to attach to. It’s not the only logical device driver, but it’s present on every machine.</p><p>The <code class="literal">bios0</code> device, for the hardware BIOS, isn’t terribly interesting either. You know the hardware has some kind of BIOS. We covered configuring your system BIOS back in <a class="xref" href="ch03.html" title="Chapter 3. Installation Walk-Through">Chapter 3</a>, and you haven’t needed to look at it since. Similarly, the <code class="literal">acpi0</code> device represents the Advanced Configuration and Power Interface (ACPI). If it needed any configuration, you took care of that after unpacking the system from the shipping box.</p></div><div class="sect2" title="Connections and Numbering"><div class="titlepage"><div><div><h3 class="title" id="connections_and_numbering">Connections and Numbering</h3></div></div></div><p><a class="indexterm" id="idx0947"/>Now we get into real hardware.</p><a id="I_programlisting18_id487850"/><pre class="programlisting">pci0 at mainbus0 bus 0: configuration mode 1 (bios)
pchb0 at pci0 dev 0 function 0 "Intel 82443BX AGP" rev 0x01
ppb0 at pci0 dev 1 function 0 "Intel 82443BX AGP" rev 0x01
pci1 at ppb0 bus 1
piixpcib0 at pci0 dev 7 function 0 "Intel 82371AB PIIX4 ISA" rev 0x08
pciide0 at pci0 dev 7 function 1 "Intel 82371AB IDE" rev 0x01: DMA, channel 0 configured to compatibility, channel 1 configured to compatibility</pre><p>The first PCI bus, device <code class="literal">pci0</code>, is attached to <code class="literal">mainbus0</code> in the slot bus 0. The kernel then finds a device it identifies as <code class="literal">pchb0</code>, and attaches it to the PCI bus as device 0. Don’t know what <code class="literal">pchb0</code> is? Use <code class="literal">man pchb</code> to identify this as a PCI host bridge. <code class="literal">dmesg</code> gives you the part number.</p><p>Next is the device <code class="literal">ppb0</code> (a PCI/PCI bridge, per <code class="literal">ppb(4)</code>), attached to PCI bus 0 as device 1. This is followed by another PCI bus, <code class="literal">pci1</code>, attached to the <code class="literal">ppb</code> device. Each instance of a device is assigned a number, starting with zero. Our tenth PCI bus would be device <code class="literal">pci9</code>. (There’s no technical requirement for sequential numbering, but the kernel follows this rule unless you tell it otherwise.)</p><p>If you dig through <span class="emphasis"><em>dmesg.boot</em></span>, you’ll see that every device is plugged into another device somewhere. For example, here’s my keyboard.</p><a id="I_programlisting18_id487917"/><pre class="programlisting">wskbd0 at pckbd0: console keyboard, using wsdisplay0</pre><p>The keyboard <code class="literal">wskbd0</code> is attached to device <code class="literal">pckbd0</code>.</p><a id="I_programlisting18_id487932"/><pre class="programlisting">pckbc0 at isa0 port 0x60/5
pckbd0 at pckbc0 (kbd slot)</pre><p>Device <code class="literal">pckbd0</code> is attached to device <code class="literal">pckbc0</code>, which, in turn, is plugged into the <code class="literal">isa0</code> device, which is the ISA bus.</p><a id="I_programlisting18_id487950"/><pre class="programlisting">isa0 at piixpcib0</pre><p>The ISA bus is connected to the Intel PIIX4 ISA bridge.</p><a id="I_programlisting18_id487958"/><pre class="programlisting">piixpcib0 at pci0 dev 7 function 0 "Intel 82371AB PIIX4 ISA" rev 0x08</pre><p>And this bridge is then hooked to PCI bus 0.</p><p>OpenBSD finds devices from the root outward, which means that everything is listed in the reverse order from what you’ve just seen. You get a list of which devices are attached to a device, and then the devices attached to those devices. You can backtrack starting with the end device, but that’s kind of annoying.</p></div><div class="sect2" title="Using dmassage to View Installed Devices"><div class="titlepage"><div><div><h3 class="title" id="using_dmassage_to_view_installed_devices">Using dmassage to View Installed Devices</h3></div></div></div><p><a class="indexterm" id="idx0501"/><a class="indexterm" id="idx0950"/><a class="indexterm" id="idx1367"/><a class="indexterm" id="idx2296"/><a class="indexterm" id="idx2297"/><a class="indexterm" id="idx2300"/><a class="indexterm" id="idx2303"/>I find the <code class="literal">dmassage</code> package most useful for identifying exactly what’s attached to what devices, although that’s not its only function. Install <code class="literal">dmassage</code> like any other package, and then run it with <code class="literal">-t</code> to display installed devices as a tree, like this:</p><a id="I_programlisting18_id488052"/><pre class="programlisting">root
 |-mainbus0
 |  |-bios0
 |  |-cpu0
 |  |-ioapic0
 |  |-pci0
 |  |  |-mpi0
 |  |  |  \-scsibus1
 |  |  |     \-sd0
 |  |  |-pchb0
 |  |  |-pciide0
 |  |  |  \-atapiscsi0
 |  |  |     \-scsibus0
 |  |  |        \-cd0
…</pre><p>While this information may not be immediately useful, <code class="literal">dmassage</code> illustrates how devices are interconnected on your system, which may become important later.</p></div></div><div class="sect1" title="Viewing and Adjusting Sysctls"><div class="titlepage"><div><div><h2 class="title" id="viewing_and_adjusting_sysctls" style="clear: both">Viewing and Adjusting Sysctls</h2></div></div></div><p>As noted in earlier chapters, the OpenBSD kernel includes a variety of parameters known as <span class="emphasis"><em>system controls</em></span>, or <span class="emphasis"><em>sysctls</em></span>. Some sysctls are static and can be viewed but not changed. The root account can change others, either at runtime or at boot.</p><p>Sysctls allow an application to retrieve information from the kernel. They also let a sysadmin change system behavior without reconfiguring applications, recompiling the kernel, or rebooting. You can view sysctl values and adjust those that can be changed with <code class="literal">sysctl(8)</code>.</p><p>That said, just because you <span class="emphasis"><em>can</em></span> change sysctls doesn’t mean you <span class="emphasis"><em>should</em></span> change them. The OpenBSD developers set the sysctls to default values that work well for most environments. You might need to change one or two for your system, but if you find yourself changing sysctls all over the place, you’re probably sending yourself down the sysadmin rabbit hole.</p><div class="sect2" title="Sysctl MIBs"><div class="titlepage"><div><div><h3 class="title" id="sysctl_mibs">Sysctl MIBs</h3></div></div></div><p>The kernel presents sysctls in a MIB tree. As you learned in <a class="xref" href="ch16.html" title="Chapter 16. Network Servers">Chapter 16</a>, MIB trees organize information into hierarchical categories. The top-level categories include <code class="literal">kern</code> (kernel), <code class="literal">vm</code> (virtual memory), <code class="literal">net</code> (networking), <code class="literal">hw</code> (hardware), <code class="literal">machdep</code> (machine-dependent values), and so on. Each of these categories has additional subcategories. For example, <code class="literal">net</code> has the categories <code class="literal">inet</code> (IPv4) and <code class="literal">inet6</code> (IPv6). The <code class="literal">inet6</code> MIBs have subcategories <code class="literal">ip6</code> (general IPv6 characteristics) and <code class="literal">icmp6</code> (ICMP for IPv6). When you reach the end of categories, you’ll find individual MIBs like these:</p><a id="I_programlisting18_id488126"/><pre class="programlisting">net.inet6.ip6.forwarding=0</pre><p><a class="indexterm" id="idx0766"/><a class="indexterm" id="idx1161"/><a class="indexterm" id="idx1163"/><a class="indexterm" id="idx1164"/><a class="indexterm" id="idx2305"/>This MIB configures forwarding IPv6 packets between interfaces, turning the host into the router. How do I know? I’ve read it in the documentation, and it’s a commented example in <span class="emphasis"><em>/etc/sysctl.conf</em></span>. OpenBSD doesn’t maintain a central list of sysctl values, but the man pages refer to any related sysctls.</p><p>If you want to explore sysctls, get a list from your system, as described next.</p></div><div class="sect2" title="Viewing Sysctls"><div class="titlepage"><div><div><h3 class="title" id="viewing_sysctls">Viewing Sysctls</h3></div></div></div><p>Use <code class="literal">sysctl(8)</code> to view the sysctls available on a system.</p><a id="I_programlisting18_id488250"/><pre class="programlisting">$ <span class="strong"><strong>sysctl</strong></span>
kern.ostype=OpenBSD
kern.osrelease=5.2
kern.osrevision=201211
kern.version=OpenBSD 5.2-current (GENERIC) #287: Tue Aug 21 18:15:00 MDT 2013
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
…</pre><p>This particular system has more than 400 sysctls. Interpreting the <code class="literal">kern.ostype</code> and <code class="literal">kern.osrelease</code> sysctls is fairly straightforward, but why would an OpenBSD system have a sysctl to report the operating system?</p><p>The <code class="literal">sysctl(3)</code> interface appears in all BSD-derived operating systems and even in Linux, so checking the <code class="literal">kern.ostype</code> sysctl, or checking for its existence, is a good way for third-party software to identify the operating system. <code class="literal">kern.osrevision</code> is just the year and month this particular snapshot was built. <code class="literal">kern.version</code> is the kernel compilation information displayed at boot. That’s not hard, is it? Let’s look at the next few sysctls:</p><a id="I_programlisting18_id488296"/><pre class="programlisting">kern.maxvnodes=5926
kern.maxproc=1310
kern.maxfiles=7030
kern.argmax=262144</pre><p>Figuring out what these do is a little harder than interpreting the previous sysctl names. An experienced sysadmin could make really good guesses about these, but guessing isn’t system administration. Always research sysctls before changing them.</p><p>When you know the name of a sysctl and you want to view its current value, give the sysctl name as an argument to <code class="literal">sysctl</code>. For example, to view the current securelevel (discussed in <a class="xref" href="ch10.html" title="Chapter 10. Securing Your System">Chapter 10</a>), check the <code class="literal">kern.securelevel</code> sysctl.</p><a id="I_programlisting18_id488322"/><pre class="programlisting">$ <span class="strong"><strong>sysctl kern.securelevel</strong></span>
kern.securelevel=1</pre><p><a class="indexterm" id="idx0996"/><a class="indexterm" id="idx1464"/><a class="indexterm" id="idx2301"/><a class="indexterm" id="idx2304"/>The current value of <code class="literal">kern.securelevel</code> is 1.</p><p>You can view subsets of the sysctl tree by giving just the part of the tree you’re interested in. For example, to view only the sysctls related to ICMP, check the <code class="literal">sysctl net.inet.icmp</code> subcategory.</p><a id="I_programlisting18_id488382"/><pre class="programlisting">$ <span class="strong"><strong>sysctl net.inet.icmp</strong></span>
net.inet.icmp.maskrepl=0
net.inet.icmp.bmcastecho=0
net.inet.icmp.errppslimit=100
net.inet.icmp.rediraccept=0
net.inet.icmp.redirtimeout=600
net.inet.icmp.tstamprepl=1</pre><p>OpenBSD has six sysctls for IPv4 ICMP networking. You can view any portion of the sysctl tree this way, going as deep or as shallow as you like.</p></div><div class="sect2" title="Changing Sysctl Values"><div class="titlepage"><div><div><h3 class="title" id="changing_sysctl_values">Changing Sysctl Values</h3></div></div></div><p>Some sysctls are read-only. For example, the <code class="literal">hw.ncpufound</code> sysctl shows how many processors the system has.</p><a id="I_programlisting18_id488416"/><pre class="programlisting">$ <span class="strong"><strong>sysctl hw.ncpufound</strong></span>
hw.ncpufound=1</pre><p>This system has one processor. You cannot change the number of hardware processors through software (duh).</p><p>On the other hand, a system decides whether or not to forward packets in software. OpenBSD performs packet forwarding entirely in the kernel, like embedded firewalls and routers. The sysctl <code class="literal">net.inet.ip.forwarding</code> controls this feature. If this is set to <code class="literal">0</code>, packets are not forwarded. If it’s set to 1, the system routes packets.</p><a id="I_programlisting18_id488443"/><pre class="programlisting">$ <span class="strong"><strong>sysctl net.inet.ip.forwarding</strong></span>
net.inet.ip.forwarding=0</pre><p>To change this, use the equal sign to assign a new value.</p><a id="I_programlisting18_id488456"/><pre class="programlisting"># <span class="strong"><strong>sysctl net.inet.ip.forwarding=1</strong></span>
net.inet.ip.forwarding: 0 -&gt; 1</pre><p>If you need to stop forwarding packets, set this sysctl to <code class="literal">0</code>.</p><p>Changes take effect immediately. Remember that only root can change sysctl values.</p></div><div class="sect2" title="Types of Sysctl Values"><div class="titlepage"><div><div><h3 class="title" id="types_of_sysctl_values">Types of Sysctl Values</h3></div></div></div><p>Most sysctls have a numerical value, but the interpretation of that number depends on the sysctl. A few sysctls are words, and some generate tables.</p><div class="sect3" title="Numerical Sysctls"><div class="titlepage"><div><div><h4 class="title" id="numerical_sysctls">Numerical Sysctls</h4></div></div></div><p><a class="indexterm" id="idx0155"/><a class="indexterm" id="idx0180"/><a class="indexterm" id="idx0767"/><a class="indexterm" id="idx1159"/><a class="indexterm" id="idx1160"/><a class="indexterm" id="idx1162"/><a class="indexterm" id="idx1562"/><a class="indexterm" id="idx2302"/><a class="indexterm" id="idx2358"/><a class="indexterm" id="idx2660"/>Some sysctls are Boolean—either on or off. For example, IP forwarding is either on or off. You can’t have 50 percent packet forwarding on a properly functioning system.</p><p>Other numerical sysctls have a range of valid numbers. For example the <code class="literal">kern.securelevel</code> sysctl can range from <code class="literal">-1</code> to <code class="literal">2</code>, as discussed in <a class="xref" href="ch10.html" title="Chapter 10. Securing Your System">Chapter 10</a>. While you could assign a value outside this range, it wouldn’t have any effect beyond the closest valid value.</p><p>Some sysctls have numerical values that map directly to some kernel value. For example, the <code class="literal">kern.maxproc</code> sysctl gives the maximum number of processes that the system can run. You can adjust this value as needed to support your applications. While there’s no maximum value, increasing <code class="literal">kern.maxproc</code> increases the memory used by various in-kernel tables. By the same token, there’s no minimum size, but if you reduce this setting too far, the system won’t run correctly.</p></div><div class="sect3" title="Word Sysctls"><div class="titlepage"><div><div><h4 class="title" id="word_sysctls">Word Sysctls</h4></div></div></div><p>A few sysctls are words, such as the <code class="literal">kern.ostype</code> sysctl examined earlier. Most of these sysctls cannot be changed with <code class="literal">sysctl</code>, but some can be changed with other programs. For example, the sysctl <code class="literal">kern.hostname</code> gives the system’s hostname. You cannot change <code class="literal">kern.hostname</code> with <code class="literal">sysctl</code>, but you can change it with <code class="literal">hostname(8)</code>.</p></div><div class="sect3" title="Table Sysctls"><div class="titlepage"><div><div><h4 class="title" id="table_sysctls">Table Sysctls</h4></div></div></div><p>In addition to words and numbers, some sysctls generate output in the form of tables. These sysctls are not intended for direct human consumption, but are meant for processing by dedicated userland programs. For example, <code class="literal">netstat(1)</code> reads table sysctls to create its output.</p><p>To view all sysctls, including tables, pass the <code class="literal">-A</code> option to <code class="literal">sysctl</code>.</p><a id="I_programlisting18_id488683"/><pre class="programlisting">$ <span class="strong"><strong>sysctl -A</strong></span></pre><p>Many table sysctls still won’t print (they will generate warnings that you should use program such-and-such to view that data), but you’ll get a few tables amid the regular output.</p><p>And by the way, tabular sysctls are read-only.</p></div></div><div class="sect2" title="Setting Sysctls at Boot"><div class="titlepage"><div><div><h3 class="title" id="setting_sysctls_at_boot">Setting Sysctls at Boot</h3></div></div></div><p>Sysctl changes are not permanent; they revert when you reboot. To make sysctl changes permanent, set them in <span class="emphasis"><em>/etc/sysctl.conf</em></span>.</p><p>Changes specified in <span class="emphasis"><em>sysctl.conf</em></span> take place early in the booting process, before any server software starts. For example, if you need to customize the network stack, those changes should take place before the system opens any network connections. List the sysctls you need to change, an equal sign, and the desired value in <span class="emphasis"><em>sysctl.conf</em></span>.</p><p><a class="indexterm" id="idx0536"/><a class="indexterm" id="idx0802"/><a class="indexterm" id="idx1004"/><a class="indexterm" id="idx1077"/><a class="indexterm" id="idx1113"/><a class="indexterm" id="idx1124"/><a class="indexterm" id="idx1460"/><a class="indexterm" id="idx1461"/><a class="indexterm" id="idx1462"/><a class="indexterm" id="idx1463"/><a class="indexterm" id="idx1465"/><a class="indexterm" id="idx1467"/><a class="indexterm" id="idx2001"/><a class="indexterm" id="idx2372"/>The default <span class="emphasis"><em>sysctl.conf</em></span> contains commonly changed sysctls (those that the OpenBSD team expects you might reasonably want to change). Each is commented out with a pound sign (<code class="literal">#</code>) and set to the most common nondefault setting. If you want to change the sysctl, uncomment the entry.</p><p>The following are some commonly changed entries from <span class="emphasis"><em>sysctl.conf</em></span>. (You might have different entries in your system, depending on your OpenBSD version.)</p><div class="blockquote" title="net.inet.ip.forwarding"><blockquote class="blockquote" title="net.inet.ip.forwarding"><div class="blockquote-title"><span class="strong"><strong><code class="literal">net.inet.ip.forwarding</code></strong></span></div><p>This controls forwarding of IPv4 packets between interfaces. When set to <code class="literal">1</code>, the system forwards packets received on any interface according to the internal routing table. When set to <code class="literal">0</code> (the default), packets are not forwarded.</p></blockquote></div><div class="blockquote" title="net.inet.icmp.rediraccept"><blockquote class="blockquote" title="net.inet.icmp.rediraccept"><div class="blockquote-title"><span class="strong"><strong><code class="literal">net.inet.icmp.rediraccept</code></strong></span></div><p>This determines whether the host will accept ICMP redirects. Routers send ICMP redirects to direct hosts to use different local gateways for more specific routes. While the router can forward the packets for the clients, using redirects reduces network load. Accepting ICMP redirects means the host could be redirected to an invalid gateway, however, so they can be a security issue. Set this to <code class="literal">1</code> to accept ICMP redirects. The default of <code class="literal">0</code> ignores ICMP redirects.</p></blockquote></div><div class="blockquote" title="net.inet6.ip6.forwarding"><blockquote class="blockquote" title="net.inet6.ip6.forwarding"><div class="blockquote-title"><span class="strong"><strong><code class="literal">net.inet6.ip6.forwarding</code></strong></span></div><p>This controls the forwarding of IPv6 packets, much like <code class="literal">net.inet.ip.forwarding</code> does for IPv4 packets. You can control IPv4 and IPv6 forwarding separately. Set this to <code class="literal">1</code> to forward IPv6 packets.</p></blockquote></div><div class="blockquote" title="net.inet6.icmp6.rediraccept"><blockquote class="blockquote" title="net.inet6.icmp6.rediraccept"><div class="blockquote-title"><span class="strong"><strong><code class="literal">net.inet6.icmp6.rediraccept</code></strong></span></div><p>By default, OpenBSD ICMPv6 ignores redirects, just as it ignores IPv4 ICMP redirects. Set this to <code class="literal">1</code> to accept ICMPv6 redirects.</p></blockquote></div><div class="blockquote" title="net.inet6.ip6.accept_rtadv"><blockquote class="blockquote" title="net.inet6.ip6.accept_rtadv"><div class="blockquote-title"><span class="strong"><strong><code class="literal">net.inet6.ip6.accept_rtadv</code></strong></span></div><p>IPv6 autoconfiguration listens for router advertisements, much as IPv4 autoconfiguration listens for configurations from DHCP servers. To autoconfigure IPv6, a host must accept router advertisements. Set this to <code class="literal">0</code> to disable accepting router advertisements.</p></blockquote></div><div class="blockquote" title="net.inet.tcp.always_keepalive"><blockquote class="blockquote" title="net.inet.tcp.always_keepalive"><div class="blockquote-title"><span class="strong"><strong><code class="literal">net.inet.tcp.always_keepalive</code></strong></span></div><p>The TCP keep-alive feature sends packets over otherwise idle connections so that intermediate devices will recognize that a connection is still in use. Proper firewalls recognize live but idle TCP connections even without keep-alives. If you have a broken firewall or NAT device, TCP keep-alives can help hold a connection alive. Set this to <code class="literal">1</code> to enable keep-alives.</p></blockquote></div><div class="blockquote" title="net.inet.tcp.ecn"><blockquote class="blockquote" title="net.inet.tcp.ecn"><div class="blockquote-title"><span class="strong"><strong><code class="literal">net.inet.tcp.ecn</code></strong></span></div><p>By default, OpenBSD’s TCP stack does not use Explicit Congestion Notification (ECN). Set this to <code class="literal">1</code> to enable ECN.</p></blockquote></div><div class="blockquote" title="ddb.panic"><blockquote class="blockquote" title="ddb.panic"><div class="blockquote-title"><span class="strong"><strong><code class="literal">ddb.panic</code></strong></span></div><p><a class="indexterm" id="idx0281"/><a class="indexterm" id="idx0315"/><a class="indexterm" id="idx0375"/><a class="indexterm" id="idx0376"/><a class="indexterm" id="idx1144"/><a class="indexterm" id="idx1257"/><a class="indexterm" id="idx1259"/><a class="indexterm" id="idx2282"/><a class="indexterm" id="idx2627"/>OpenBSD uses the <code class="literal">ddb(4)</code> kernel debugger. If you want the system to drop into the debugger in the unlikely event of a kernel panic, leave this at <code class="literal">1</code>. If you want the system to reboot as soon as possible, set this to <code class="literal">0</code>.</p></blockquote></div><div class="blockquote" title="ddb.console"><blockquote class="blockquote" title="ddb.console"><div class="blockquote-title"><span class="strong"><strong><code class="literal">ddb.console</code></strong></span></div><p>When set to <code class="literal">1</code>, this enables entering the <code class="literal">ddb(4)</code> debugger from the console when someone presses <span class="smallcaps">CTRL-ALT-ESC</span>. This option is primarily of interest to developers.</p></blockquote></div><div class="blockquote" title="vm.swapencrypt.enable"><blockquote class="blockquote" title="vm.swapencrypt.enable"><div class="blockquote-title"><span class="strong"><strong><code class="literal">vm.swapencrypt.enable</code></strong></span></div><p>By default, OpenBSD encrypts all data written to swap. To disable encrypting swap, set this to <code class="literal">0</code>. There’s really no reason to disable swap encryption, because encrypting swap space induces minimal system load.</p></blockquote></div><div class="blockquote" title="machdep.allowaperture"><blockquote class="blockquote" title="machdep.allowaperture"><div class="blockquote-title"><span class="strong"><strong><code class="literal">machdep.allowaperture</code></strong></span></div><p>This controls userland program access to the memory that userland really shouldn’t be able to access. The X Windows System needs access to this memory to display a graphical console. (<a class="xref" href="ch17.html" title="Chapter 17. Desktop OpenBSD">Chapter 17</a> covers this sysctl and X.)</p></blockquote></div><div class="blockquote" title="machdep.kbdreset"><blockquote class="blockquote" title="machdep.kbdreset"><div class="blockquote-title"><span class="strong"><strong><code class="literal">machdep.kbdreset</code></strong></span></div><p>On amd64 and i386 systems, setting this to <code class="literal">1</code> allows you to press <span class="smallcaps">CTRL-ALT-DEL</span> on the console to do a clean shutdown and reboot. When set to <code class="literal">0</code> (the default), pressing <span class="smallcaps">CTRL-ALT-DEL</span> has no effect.</p></blockquote></div><p>As a rule, if you don’t understand the thing that a sysctl affects, don’t change it. You won’t learn about RFC 3390 by playing with a sysctl related to it; you’ll learn about RFC 3390 by actually <span class="emphasis"><em>reading</em></span> RFC 3390 and spending quality time with a packet sniffer watching traffic with RFC 3390 disabled and enabled.</p><p>And if you want to change a sysctl that’s not listed here, think twice. If the OpenBSD guys wanted you to change it, they would list it in <span class="emphasis"><em>sysctl.conf</em></span>.</p></div></div><div class="sect1" title="Altering the Kernel with config(8)"><div class="titlepage"><div><div><h2 class="title" id="altering_the_kernel_with_config8" style="clear: both">Altering the Kernel with config(8)</h2></div></div></div><p>While <code class="literal">sysctl</code> lets you tweak the kernel, it won’t let you change values that are hard-coded into the kernel binary. Some of these values are used to initialize kernel data structures, and they can’t be changed once the kernel is running. Others relate to device drivers. Once the kernel has finished probing devices, it won’t go back and reprobe just because you change where a device driver checks for its hardware. To change hard-coded values like these, you must edit the existing kernel file and reboot, allowing the system to set things as you like from initialization. That’s where <code class="literal">config(8)</code> comes in.</p><p>The <code class="literal">config</code> command has two completely separate functions. The first creates a kernel compilation directory from a text configuration file, as discussed in <a class="xref" href="ch19.html" title="Chapter 19. Building Custom Kernels">Chapter 19</a>. The function we’re most interested in now is editing an existing kernel binary, which lets you tweak a kernel to better suit your needs.</p><div class="note" title="Note"><h3 class="title"><a id="ch18note01"/>Note</h3><p><a class="indexterm" id="idx0105"/><a class="indexterm" id="idx0203"/><a class="indexterm" id="idx0282"/><a class="indexterm" id="idx0431"/><a class="indexterm" id="idx1083"/><a class="indexterm" id="idx1102"/><a class="indexterm" id="idx1125"/><a class="indexterm" id="idx1127"/><a class="indexterm" id="idx1145"/><a class="indexterm" id="idx1148"/><a class="indexterm" id="idx1429"/>The modern OpenBSD kernel is largely dynamic. If you call for additional virtual interfaces, the kernel creates them. If you need to change the amount of memory for the buffer cache, use a sysctl. Editing the kernel is rarely necessary.</p></div><div class="sect2" title="Making a Backup of the Default Kernel"><div class="titlepage"><div><div><h3 class="title" id="making_a_backup_of_the_default_kernel">Making a Backup of the Default Kernel</h3></div></div></div><p>Before making any changes to a working kernel, no matter how minor, back up the original kernel! If your minor changes make your machine unbootable, you want to be able to easily fall back to a working kernel.</p><p>The kernel is just a file, <span class="emphasis"><em>/bsd</em></span>. To back it up, copy it to another file. I recommend naming your backup of the default kernel <span class="emphasis"><em>/bsd.GENERIC</em></span>, for reasons that will become apparent in <a class="xref" href="ch19.html" title="Chapter 19. Building Custom Kernels">Chapter 19</a>.</p><p>Always keep a known-good kernel on your system. A bad kernel can prevent a computer from booting, and if you don’t have a reliable kernel that’s easily bootable, you will need to boot from installation media. (Boot your backup kernel using the instructions in <a class="xref" href="ch05.html" title="Chapter 5. The Boot Process">Chapter 5</a>.) And remember that subtle kernel bugs can take weeks or months to show up, so plan to keep your backup kernel forever.</p></div><div class="sect2" title="Device Drivers and the Kernel"><div class="titlepage"><div><div><h3 class="title" id="device_drivers_and_the_kernel">Device Drivers and the Kernel</h3></div></div></div><p>Much of the hard-coded information in the kernel relates to device drivers, especially drivers for ancient ISA cards.</p><p>Some of you may remember manually configuring the interrupt request (IRQ) and memory port addresses on a network or SCSI card. The kernel uses the IRQ to identify cards. Essentially, it consults an internal list of IRQs and port numbers, compares it to what it finds on the hardware probe, and assigns the drivers appropriately. “This card answers at IRQ 10 and memory port 0x300? It must be a NE2000-compatible network card. I will assign that driver to it.” The process is more complicated than this, of course, but this probe is a vital part of the process. If you want OpenBSD to recognize such a card, and the card is set to an IRQ and memory port other than what OpenBSD expects, you must tell the kernel the IRQ and memory port the card is using.</p><p>Realistically, the best way to deal with ISA cards is to feed them to the recycling plant. Running OpenBSD on a 25-year-old VAX is interesting and educational. Running OpenBSD on 15-year-old Sparc hardware is realistic for very specific applications, and can also be educational and interesting. Running OpenBSD on 10-year-old consumer-grade i386 hardware is either a waste of time or an exercise in masochism—probably both.</p><div class="note" title="Note"><h3 class="title"><a id="ch18note02"/>Note</h3><p>Modern PCI-descended hardware includes hooks for the kernel to identify the hardware and assign the proper device driver. You shouldn’t need to edit the kernel to support hardware.</p></div></div><div class="sect2" title="Enabling Drivers"><div class="titlepage"><div><div><h3 class="title" id="enabling_drivers">Enabling Drivers</h3></div></div></div><p><a class="indexterm" id="idx0284"/><a class="indexterm" id="idx0426"/><a class="indexterm" id="idx0963"/><a class="indexterm" id="idx1147"/><a class="indexterm" id="idx1149"/><a class="indexterm" id="idx1197"/>Rather than changing driver IRQs, more realistically, you might need to enable a device driver that’s disabled by default or disable a device that’s on by default.</p><p>The kernel includes some device drivers that are disabled because they react badly with certain hardware, such as the IPMI driver. The <code class="literal">ipmi(4)</code> driver is known to be buggy, and as I write this, it is badly broken in some use cases. It’s included in the default kernel, but disabled by default.</p><p>You can choose to enable <code class="literal">ipmi(4)</code>. If it works for you, great. If it doesn’t, feel free to submit bug reports, preferably with patches, or at least proper <code class="literal">dmesg</code> output and crash dumps.</p></div><div class="sect2" title="Editing the Kernel with config"><div class="titlepage"><div><div><h3 class="title" id="editing_the_kernel_with_config">Editing the Kernel with config</h3></div></div></div><p>When using <code class="literal">config</code> as a kernel editor, use the command-line options <code class="literal">-e</code> and <code class="literal">-o</code>. The <code class="literal">-e</code> flag tells <code class="literal">config</code> you’re editing a kernel binary. The <code class="literal">-o</code> flag lets you specify a new file for the edited version of the kernel.</p><p>Give the original kernel file path as an argument. For example, here’s how to edit <span class="emphasis"><em>/bsd</em></span> and write the result to the file <span class="emphasis"><em>/bsd.test</em></span>:</p><a id="I_programlisting18_id489646"/><pre class="programlisting"># <span class="strong"><strong>config -e -o /bsd.test /bsd</strong></span></pre><p>You could use the <code class="literal">-f</code> flag instead of <code class="literal">-o</code> and a filename. The <code class="literal">-f</code> flag tells <code class="literal">config</code> to edit the kernel file in place, not to create a new file.</p><div class="note" title="Note"><h3 class="title"><a id="ch18note03"/>Note</h3><p>If you’re editing <span class="emphasis"><em>/bsd</em></span> and you specified the <code class="literal">-f</code> option, your changes are written directly to <span class="emphasis"><em>/bsd</em></span>. I recommend <span class="emphasis"><em>not</em></span> doing this. (Unless, of course, you’re absolutely certain you know what you’re doing. You get to keep all the parts.)</p></div><p>Running <code class="literal">config</code> will open the kernel editor, which should look much like this:</p><a id="I_programlisting18_id489707"/><pre class="programlisting">OpenBSD 5.2-current (GENERIC) #287: Tue Aug 21 18:15:00 MDT 2013
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
Enter 'help' for information
ukc&gt;</pre><p>At this point, you need to use kernel editor commands to make changes.</p><div class="sect3" title="Using the help and list Commands"><div class="titlepage"><div><div><h4 class="title" id="using_the_help_and_list_commands">Using the help and list Commands</h4></div></div></div><p>Start with the two editor commands <code class="literal">help</code> and <code class="literal">list</code>. The <code class="literal">help</code> command shows all the commands available within <code class="literal">config</code> and comes in particularly handy at stupid-o’clock <span class="smallcaps">AM</span> to remind you of the necessary syntax.</p><p>The <code class="literal">list</code> command displays a complete list of all the devices the kernel supports, one screen at a time.</p><a id="I_programlisting18_id489763"/><pre class="programlisting">ukc&gt; <span class="strong"><strong>list</strong></span>
  0 video* at uvideo* flags 0x0
  1 audio* at uaudio*|sb0|sb*|gus0|gus*|pas0|ess*|wss0|wss*|ym*|eap*|envy*|
eso*|sv*|neo*|cmpci*|clcs*|clct*|auacer*|auglx*|auich*|auixp*|autri*|auvia*|
azalia*|fms*|maestro*|esa*|yds*|emu* flags 0x0
  2 midi* at umidi*|sb0|sb*|ym*|mpu*|mpu*|autri*|eap*|envy* flags 0x0
…</pre><p><a class="indexterm" id="idx0083"/><a class="indexterm" id="idx0207"/><a class="indexterm" id="idx0886"/><a class="indexterm" id="idx1540"/><a class="indexterm" id="idx1792"/><a class="indexterm" id="idx1891"/><a class="indexterm" id="idx2581"/><a class="indexterm" id="idx2607"/>On an OpenBSD 5.2 system, the default kernel has 538 entries, most for hardware that isn’t on any particular system but that OpenBSD supports out of the box. Let’s take a closer look at the devices shown.</p><p>Line 0 says that this kernel supports the <code class="literal">video</code> device. The kernel will look for a video device attached to the <code class="literal">uvideo</code> device. The <code class="literal">uvideo(4)</code> man page tells us that <code class="literal">uvideo</code> is USB video, mainly for webcams and the like, and <code class="literal">video(4)</code> says that the <code class="literal">video</code> driver is a device-independent video driver. The <code class="literal">flags</code> statement gives settings to feed to this device driver. (This kernel supports webcams.)</p><p>Line 1 says that this kernel supports an <code class="literal">audio</code> device, and it can be attached to any of a long list of device drivers. The online manual says that <code class="literal">uaudio</code>, <code class="literal">sb0</code>, <code class="literal">gus0</code>, and so on are sound cards. We get sound with our video? Truly we live in an age of wonders.</p><p>Entries for older ISA gear are more complex.</p><a id="I_programlisting18_id489895"/><pre class="programlisting">278 ne0 at isa0 port 0x240 size 0 iomem -1 iosiz 0 irq 9 drq -1 drq2 -1 flags 0x0</pre><p>This entry for supporting the old-fashioned NE2000 ISA network card includes an IRQ, DRQ, memory port, and a few other settings that I’ve (thankfully) forgotten about. The kernel will check ISA bus number 0 at the stated port and IRQ, in the hope of finding such a device.</p><a id="I_programlisting18_id489905"/><pre class="programlisting">504 pflog count 1 (pseudo device)</pre><p>This is a <span class="emphasis"><em>pseudo-device</em></span>—a software creation that acts much like an actual device but has no underlying hardware. The <code class="literal">pflog(4)</code> pseudo-device is where the packet filter dumps its logs. This kernel creates one instance of the <code class="literal">pflog</code> device at boot, but thanks to OpenBSD’s cloneable interfaces, the kernel can create more <code class="literal">pflog</code> interfaces as needed.</p><p>Finally, notice that several lines declare themselves “free.” You can copy an existing device and add it to the kernel. For example, if you wanted a kernel that supported 10 NE2000 cards, and needed 10 instances of the device driver in the kernel, you could copy and add the devices here. The kernel will autoconfigure any number of device driver instances for modern hardware; it will find 10 PCI Express network cards and give them their own instances of the device without any prodding from you.</p></div><div class="sect3" title="Finding and Enabling Devices"><div class="titlepage"><div><div><h4 class="title" id="finding_and_enabling_devices">Finding and Enabling Devices</h4></div></div></div><p><a class="indexterm" id="idx0283"/><a class="indexterm" id="idx0427"/><a class="indexterm" id="idx0428"/><a class="indexterm" id="idx0798"/><a class="indexterm" id="idx1146"/><a class="indexterm" id="idx1150"/><a class="indexterm" id="idx1151"/>One of the disadvantages to the <code class="literal">list</code> command is that it shows everything in the kernel. You can’t interrupt it; you must scroll through to the end. It’s also difficult to search through several hundred devices by eye. If you know the device you want, use <code class="literal">find</code> to search for it. Here, we’ll use <code class="literal">ipmi</code> as an example.</p><a id="I_programlisting18_id490036"/><pre class="programlisting">ukc&gt; <span class="strong"><strong>find ipmi</strong></span>
493 ipmi0 at mainbus0 disable bus -1 flags 0x0</pre><p>The IPMI device is device number 493, and it is attached to the device <code class="literal">mainbus0</code>. But note the word <code class="literal">disable</code> in the device entry. The <code class="literal">ipmi</code> device is disabled. Let’s turn it on.</p><a id="I_programlisting18_id490062"/><pre class="programlisting">ukc&gt; <span class="strong"><strong>enable ipmi</strong></span>
493 ipmi0 enabled</pre><p>The kernel now has an active IPMI driver. Yippee!</p></div><div class="sect3" title="Changing Kernel Constants"><div class="titlepage"><div><div><h4 class="title" id="changing_kernel_constants">Changing Kernel Constants</h4></div></div></div><p>In addition to the device drivers, the kernel has a few hard-coded values for internal data structures. If you run <code class="literal">help</code> in the kernel editor, you’ll see these values as options.</p><a id="I_programlisting18_id490095"/><pre class="programlisting">ukc&gt; <span class="strong"><strong>help</strong></span>
…
        bufcachepercent [number]            Show/change BUFCACHEPERCENT
        nkmempg         [number]            Show/change NKMEMPAGES</pre><p>As you can see there are only two values: <code class="literal">BUFCACHEPERCENT</code> and <code class="literal">NKMEMPAGES</code>. Unless you have a compelling reason to touch these values, leave them alone.</p><p><code class="literal">NKMEMPAGES</code> is the number of pages of memory dedicated to the kernel.If your machine starts panicking with error messages of <code class="literal">out of space in kmem_map</code>, you can increase this value. If the system boots successfully, however, you’re better off setting the <code class="literal">vm.nkmempages</code> sysctl rather than editing the kernel.</p><p><code class="literal">BUFCACHEPERCENT</code> is the percentage of physical memory dedicated to the buffer cache. In some fairly rare circumstances, increasing the size of the buffer cache can improve filesystem performance. You could set the sysctl <code class="literal">kern.bufcachepercent</code> instead of editing this kernel value, however.</p><p>To view a current value, enter its name.</p><a id="I_programlisting18_id490149"/><pre class="programlisting">ukc&gt; <span class="strong"><strong>bufcachepercent</strong></span>
bufcachepercent = 20</pre><p>To change the value, enter its name and the desired value.</p><a id="I_programlisting18_id490162"/><pre class="programlisting">ukc&gt; <span class="strong"><strong>bufcachepercent 50</strong></span>
bufcachepercent = 50</pre><p><a class="indexterm" id="idx0176"/><a class="indexterm" id="idx1140"/><a class="indexterm" id="idx1886"/><a class="indexterm" id="idx1909"/><a class="indexterm" id="idx2479"/>Again, don’t muck with these numbers arbitrarily. The OpenBSD developers set them to the default values for very good reasons.</p></div><div class="sect3" title="Completing Configuration"><div class="titlepage"><div><div><h4 class="title" id="completing_configuration">Completing Configuration</h4></div></div></div><p>Once you’ve made all of your changes, enter <span class="strong"><strong><code class="literal">quit</code></strong></span> to save your changes and write them to a kernel file. The <code class="literal">exit</code> command discards all changes and leaves the editor, making it easy to start over. Do not mix <code class="literal">quit</code> and <code class="literal">exit</code> unless you like being annoyed and confused.</p></div><div class="sect3" title="Installing Your Edited Kernel"><div class="titlepage"><div><div><h4 class="title" id="installing_your_edited_kernel">Installing Your Edited Kernel</h4></div></div></div><p>Your edited kernel is just a file. Verify that you have a backup of your working kernel, copy your new kernel to <span class="emphasis"><em>/bsd</em></span>, and reboot.</p></div></div></div><div class="sect1" title="Boot-Time Kernel Configuration"><div class="titlepage"><div><div><h2 class="title" id="boot-time_kernel_configuration" style="clear: both">Boot-Time Kernel Configuration</h2></div></div></div><p>The <code class="literal">config</code> kernel editor is great when you know what you’re doing, but many of us aren’t that lucky or educated. When I’m trying to figure out how to fix a problem, I’ll frequently make a change, reboot to test the change, and see if things work.</p><p>OpenBSD lets you edit the kernel at boot time. You can try one boot with a kernel change, see if it works, and write your changes to the kernel. At the boot loader prompt, run <span class="strong"><strong><code class="literal">boot -c</code></strong></span>.</p><a id="I_programlisting18_id490308"/><pre class="programlisting">boot &gt; <span class="strong"><strong>boot -c</strong></span></pre><p>You’ll get a couple lines of boot output, and then the kernel editor prompt.</p><a id="I_programlisting18_id490320"/><pre class="programlisting">ukc&gt;</pre><p>This works just like the <code class="literal">config</code> kernel configuration editor. Make any changes you want here, exactly as you would with <code class="literal">config</code>. When you <code class="literal">quit</code> the editor, the kernel should boot with the changes you’ve chosen.</p><p>The nice thing about boot-time edits is that they’re not permanent unless you later declare them so. If your changes don’t result in the desired behavior, reboot and try again. If your changes do solve your issue, however, you can write them to a kernel file.</p><p>The kernel remembers the changes you made in it. You can “replay” those changes in <code class="literal">config</code> by using the <code class="literal">-u</code> flag. Run <code class="literal">config</code> as if you were editing the kernel, but add the <code class="literal">-u</code> flag to replicate your boot-time changes.</p><a id="I_programlisting18_id490364"/><pre class="programlisting"># <span class="strong"><strong>config -u -e -o /bsd.test /bsd</strong></span></pre><p>When you get your command prompt, enter <span class="strong"><strong><code class="literal">quit</code></strong></span> to save your changes to your new kernel file.</p><p>Between <code class="literal">sysctl</code> and <code class="literal">config</code>, you should be able to make any OpenBSD-supported changes to the kernel. In the next chapter, we’ll cover how to make wildly unsupported kernel changes by rebuilding the kernel from source.</p></div></section></body></html>