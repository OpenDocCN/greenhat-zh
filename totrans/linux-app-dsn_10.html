<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page147"/><img src="../images/171-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="chapter10"/><a href="toc.html#chapter10"><b>BUILDING A FRONT PANEL INTERFACE</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">Buttons, light-emitting diodes (LEDs), and small alphanumeric displays are so common that we hardly notice them anymore. Printers, microwave ovens, phones, and DVD and CD players all use buttons, LEDs, and LCDs as part of their user interfaces—and it is likely that you will want to have buttons and LEDs on the front panel of your appliance, as well.</p>&#13;
<p class="indent">In this chapter, we will describe how to build a front panel UI. First, we will discuss the hardware used on front panels, and we will then show you how to design a UI and menu system for a front panel by reviewing the requirements and design of Laddie’s front panel UI.</p>&#13;
<p class="indent">We divided our coverage of the front panel interface into these sections:</p>&#13;
<ul>&#13;
<li>Buttons, LEDs, and LCDs</li>&#13;
<li>Designing a front panel UI</li>&#13;
<li><a id="page148"/>The Laddie front panel</li>&#13;
<li>Improving our design</li>&#13;
</ul>&#13;
<p class="indent">We’ll start by looking at the details of front panel hardware. (If you’re uncomfortable with hardware or wiring diagrams, feel free to just skim this chapter.)</p>&#13;
<p class="secl"><a id="chapter10.1"/><a href="toc.html#chapter10.1"><b>Buttons, LEDs, and LCDs</b></a></p>&#13;
<p class="noindent">This section introduces the kinds of hardware that you’ll find on an appliance’s front panel, including buttons, LEDs, and LCDs.</p>&#13;
<p class="secs"><a id="chapter10.2"/><a href="toc.html#chapter10.2"><i><b>Buttons</b></i></a></p>&#13;
<p class="noindent">The size of your production run may determine the type of hardware you use in your design, especially where buttons are concerned. When your appliance is produced as part of a large production run, buttons will usually be built directly onto the printed circuit board. Small production runs or prototypes, on the other hand, often use either a pre-built assembly or individual switches.</p>&#13;
<p class="indent">Electrically speaking, buttons are simply switches that are, most often, normally open. Each button usually requires one digital input line that can be read by your processor. (Chapter 5 explains how you can use an input line to read the state of a single switch.)</p>&#13;
<p class="secls"><b>Keypads</b></p>&#13;
<p class="noindent">A <i>keypad</i> is an array of buttons that is scanned for a closure. Scanning for a closure can reduce the total number of input and output lines needed in your hardware. The idea behind scanning a keypad is dividing the switches into an array of rows and columns and then examining the switches one row at a time. Keypads are described as <i>n-by-m</i>, indicating a array of switches with <i>n</i> rows and <i>m</i> columns. Each row is assigned an output line and each column is assigned an input line. Sixteen switches arranged as a 4-by-4 keypad would use eight I/O lines from the CPU, not 16.</p>&#13;
<p class="indent">Using a keypad becomes a viable option when you have more than five or six buttons. You can use a microprocessor to help with keyboard scanning and other hardware-based I/O, but in a cost-sensitive appliance, your Linux-based code may need to do all of the scanning and low-level I/O. Some system-on-chip processors, such as the PXA270 from Marvell, have dedicated hardware on board to do keypad scanning.</p>&#13;
<p class="indent">Consider the 2-by-2 keypad circuit shown in Figure 10-1. The pull-up resistors bias the column lines to V+, or a logic one, so the two inputs will read a logic one when no switches are closed. The two diodes on the output lines isolate one row from the other row. To scan the keypad, the processor puts zero volts (a logic zero) on row 0 and a logic one on row 1. The processor reads the input port, and if input 0 is a logic zero, then it knows button A (at row 0, column 0) is being pressed. If the input 1 is a zero, then it knows button B (at row 0, column 1) is being pressed. The processor then sets output 0 to a logic one and output 1 to a logic zero. Now if input 0 is a zero, it knows button C (at row 1, column 0) is being pressed, and if input 1 is a zero, then it knows button D (at row 1, column 1) is being pressed.</p>&#13;
<p class="imgc"><a id="page149"/><img src="../images/173-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-1: A 2-by-2 keypad</i></p>&#13;
<p class="indent">Here is some simple code to scan the above keypad.</p>&#13;
<p class="imgl"><img src="../images/173-2.jpg" alt=""/></p>&#13;
<p class="indent">This code illustrates the sequence of events fairly well, but you’ll probably want to use a loop if you are scanning more than a few rows.</p>&#13;
<p class="secls"><b>Switch Bounce</b></p>&#13;
<p class="noindent">If you drop a ball bearing onto a steel plate, it will bounce. Switch closures can also be thought of as two metal pieces colliding with each other. Switch contacts bounce when they are closed and when they are opened. If you scan the keypad too quickly, you can erroneously detect a bounce as a new switch closure. The duration of switch bounces depends on the physical properties of the switch, so they can vary widely. The manufacturer of your switch can give you specifications, but you should be sure to measure the bounce time yourself. One way to avoid switch bounce is to scan the keypad more slowly, but slowing the scan too much can make the keypad seem sluggish. You can make the keypad more responsive and still avoid switch bounce by keeping a history of the last few scan values and reporting a new closure only when the saved values are the same but are different from the current value. This is the technique we use in the following subroutine that waits for a new keypress and returns the ASCII value of the key.</p>&#13;
<p class="imgl"><a id="page150"/><img src="../images/174-1.jpg" alt=""/></p>&#13;
<p class="indent">It is important that the scan rate for a keypad be constant. It is possible to do keypad scanning in a user-space program, but you may find that the scan rate varies widely and that the program uses much more of the CPU than necessary. It is best to use a real-time Linux kernel to get accurate scan timing if you want to scan from user space, or do what we did for Laddie: Put the keypad scanning into a simple character device driver so that accurate scan timing is provided by the Linux kernel.</p>&#13;
<p class="secs"><a id="chapter10.3"/><a href="toc.html#chapter10.3"><i><b>LEDs</b></i></a></p>&#13;
<p class="noindent">Using <i>light-emitting diodes (LEDs)</i> is one of the most intuitive, easiest, and cheapest ways to present status information from your application or appliance to the user or developer. LEDs come in round or rectangular plastic packages as well as in the form of surface mount chips. They also come in a wide variety of colors, with red, yellow, and green being the most popular. Some LED packages have two LED chips in them and can light with more than one color; these bi-color LEDs are great for a go-or-no-go status indication. Consider using a bezel or a diffuser if your application requires that the LED be easily visible. In our alarm application, we use a bright LED with a bezel so that it is easy to see when the system is in alarm.</p>&#13;
<p class="indent"><a id="page151"/>Usually, each LED uses one digital output line from your hardware. If you have a lot of LEDs (such as the 28 segments in a four-digit, seven-segment display on a digital clock, for example), you can scan the LEDs similarly to how you would scan a keypad, as described above. If you need to scan your LEDs, especially if they are seven-segment displays, you should use a device driver to make the scan timing precise.</p>&#13;
<p class="indent">The human eye is drawn toward movement, and you can use this to your advantage in your front panel design. A flashing LED attracts much more attention than a static one. Color can also give meaning to an LED, but color blindness and the various cultural associations of colors make it a good idea to not rely too heavily on color to convey meaning.</p>&#13;
<p class="indent">Some popular vendors for LEDs and LED hardware include:</p>&#13;
<ul>&#13;
<li>Digi-Key, Inc. (<a href="http://www.digi-key.com/">http://www.digi-key.com</a>)</li>&#13;
<li>Jameco Electronics, Inc. (<a href="http://www.jameco.com/">http://www.jameco.com</a>)</li>&#13;
<li>Super Bright LEDs, Inc. (<a href="http://www.superbrightleds.com/">http://www.superbrightleds.com</a>)</li>&#13;
</ul>&#13;
<p class="secs"><a id="chapter10.4"/><a href="toc.html#chapter10.4"><i><b>LCDs</b></i></a></p>&#13;
<p class="noindent">Small <i>liquid crystal displays (LCDs)</i> are standard interfaces for consumer appliances. Your use of an LCD will depend on the nature of your appliance and your customer’s expectations, but there are several reasons to include an LCD in your design:</p>&#13;
<p class="bl"><b>Primary UI</b> A text-based LCD display can be the primary UI for your appliance. This is often the case for audio equipment, such as satellite receivers and network-attached audio players.</p>&#13;
<p class="bl"><b>Reliability</b> Network equipment often needs fail-safe access to configuration and status information. While using a serial port and a CLI is common, high-end network appliances often provide a keypad and LCD on the front panel for configuration.</p>&#13;
<p class="bl"><b>Perceived value</b> There is nothing like an LCD (or even better, a vacuum florescent display) to distinguish one beige box from its competitors and to convince customers that they’re buying a high-end piece of equipment.</p>&#13;
<p class="indent1">There are two common architectures used to interface an LCD to an appliance. The first is to have the Linux processor drive the LCD directly. This architecture is appropriate for low-cost, low-power, and high-volume appliances that require a graphic display. Common uses of this architecture include PDAs and cell phones. Several members of the ARM processor family have on-chip support for LCD displays. Examples include the EP9307 from Cirrus Logic and the AT91SAM926 from Atmel. Chapter 11 describes how to build a UI for memory-mapped graphics displays.</p>&#13;
<p class="indent"><a id="page152"/>The second common architecture is to have the Linux processor deal with the LCD through a controller chip that is attached to a serial, parallel, or USB port. This architecture is appropriate for small production runs and appliances based on personal computer motherboards.</p>&#13;
<p class="indent">LCDs for this architecture usually have one to four lines of text with between 10 and 40 characters per line. The most common controller chip for these displays is the ubiquitous HD44780, originally from Hitachi, but now available from several vendors. Displays based on the HD44780 usually have parallel input, but many have a daughter card that offers a serial or USB input, keyboard scanning, and LED outputs. Some displays with a daughter card give you the ability to program flash memory with text to display when the unit is first powered up. Programmable power-up text is particularly important for an appliance since responsiveness is critical to a successful UI. Displays with a daughter card and flash memory usually also have a programmable character set, which is useful if you want to display a logo or other simple graphic. We’ll have much more to say about the HD44780 later in this chapter when we review Laddie’s front panel hardware.</p>&#13;
<p class="indent">There are several web pages and packages that support alphanumeric LCD displays under Linux. Two websites that you may find of particular value are <a href="http://lcd4linux.sourceforge.net/">http://lcd4linux.sourceforge.net</a> and <a href="http://lcdproc.org/">http://lcdproc.org</a>. Alphanumeric LCD displays with serial, parallel, or USB inputs are available from several vendors. Here are a few that you might want to consider:</p>&#13;
<ul>&#13;
<li>Scott Edwards Electronics, Inc. (<a href="http://www.seetron.com/">http://www.seetron.com</a>)</li>&#13;
<li>Crystalfontz America, Inc. (<a href="http://www.crystalfontz.com/">http://www.crystalfontz.com</a>)</li>&#13;
<li>Matrix Orbital, Inc. (<a href="http://www.matrixorbital.com/">http://www.matrixorbital.com</a>)</li>&#13;
<li>Cwlinux Limited (<a href="http://www.cwlinux.com/">http://www.cwlinux.com</a>)</li>&#13;
<li>Decade Engineering (<a href="http://www.decadenet.com/">http://www.decadenet.com</a>)</li>&#13;
<li>EarthLCD (<a href="http://store.earthlcd.com/">http://store.earthlcd.com</a>)</li>&#13;
</ul>&#13;
<p class="indent1">Using a standard I/O port does not preclude having a graphic display. For example, Decade Engineering’s BOB-4 takes commands and characters from a serial port and outputs to composite sync video, and the ezLCD from EarthLCD is a color graphic LCD with a 240-by-160-pixel resolution.</p>&#13;
<p class="secl"><a id="chapter10.5"/><a href="toc.html#chapter10.5"><b>Designing a Front Panel UI</b></a></p>&#13;
<p class="noindent">This section gives some tips on how to build a front panel UI. We’ll discuss various approaches to building a menu system for LCD displays, and we’ll offer some ideas on how to make your front panel responsive as soon as possible after your user powers on the appliance.</p>&#13;
<p class="secs"><a id="chapter10.6"/><a href="toc.html#chapter10.6"><i><b>Be Simple</b></i></a></p>&#13;
<p class="noindent">The primary goal of an appliance is for it to do one thing well. To call your product an appliance is to promise that you will not overwhelm users with functions and options that they do not need. Your goal is to keep the appliance simple enough that a new or non-technical user can install the appliance in a few minutes without reading the manual. You can accomplish this by having reasonable defaults and by designing the UIs so they are easy to navigate. You can still give technical and sophisticated users access to all configuration options, but you should hide this complexity from novice users by putting it in an “Advanced Options” sub-menu.</p>&#13;
<p class="indent"><a id="page153"/>The simplest UI on your appliance should be the buttons, LEDs, and LCDs on the front panel. When you design your front panel, consider assigning one button or LED to one function or status. A one-button interface is especially useful for the most common functions.</p>&#13;
<p class="secs"><a id="chapter10.7"/><a href="toc.html#chapter10.7"><i><b>Try, Fail, Try Again</b></i></a></p>&#13;
<p class="noindent">Don’t expect to get your front panel right on the first try. It is very difficult to accurately anticipate what kind of menu flow and button labeling will be the most intuitive for users. Don’t be afraid to wear out the good will of your friends and neighbors by giving them a mock-up of your appliance and asking them to navigate the menu system. You may need to build and try several front panels before choosing the right one for your appliance.</p>&#13;
<p class="indent">We’ve found several tricks that help in this area. The first is to build a prototype display with interchangeable paper faceplates. Install the paper faceplate, and ask new users to perform specific tasks. How quickly and easily the new users can navigate the menu system is the major criteria we used to select the best menu layout for Laddie. Figure 10-2 shows the paper faceplates we used for prototyping the Laddie front panel.</p>&#13;
<p class="imgc"><img src="../images/177-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-2: A front panel with paper faceplates</i></p>&#13;
<p class="indent">Another technique is to recognize that a menu system is a state machine and can be stored as a table. Instead of hard coding the states and transitions in a program, build a table that contains the state, event, next state, and processing to perform. Then store the state transition table in a separate file and load it when the LCD UI program initializes.</p>&#13;
<p class="indent"><a id="page154"/>While nothing beats the user feedback from using real front panel hardware, you may find that you want to start by building a working prototype of the front panel using a web page, Tcl/Tk, or a character interface built with the curses library. You’ll appreciate being able to test various front panel designs before specifying your front panel hardware. An advantage of a web or Tcl/Tk version of the front panel is that you can use it as another type of UI on the finished appliance. For instance, we’ve found that the curses version of the Laddie front panel is sometimes easier to use and more capable than the Laddie CLI, though both run in an xterm session.</p>&#13;
<p class="indent">Laddie has front panel emulators written using curses, Tcl/Tk, and JavaScript combined with PHP. The web-based front panel uses an image map on top of a photograph of the front panel hardware. The Tcl/Tk version is shown in Figure 10-3.</p>&#13;
<p class="imgc"><img src="../images/178-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-3: A Laddie front panel implemented in Tcl/Tk</i></p>&#13;
<p class="secs"><a id="chapter10.8"/><a href="toc.html#chapter10.8"><i><b>Use LCD Menus and Modes</b></i></a></p>&#13;
<p class="noindent">If your appliance has an LCD display, you can add menus and status to your front panel UI. A <i>menu</i>, in this context, is a linear list of items to select. These items might be commands, configuration settings, or pathways into sub-menus. The interface will need to have buttons that allow users to navigate the list and to select desired items. Common navigation buttons include next item, previous item, select this item, and previous menu. The best way to avoid building a menu system that is <i>a maze of twisty passages, all alike</i> is to map out the menu system with a state transition diagram. Try to keep your transition diagram orthogonal so that directions like up, down, left, and right have meaning. Many LCD menu systems treat the LCD display as a window that sees part of the state transition diagram. An LCD assembly from Matrix Orbital that is made for this kind of menu structure is shown in Figure 10-4.</p>&#13;
<p class="imgc"><img src="../images/178-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-4: A typical front panel with menu navigation buttons</i></p>&#13;
<p class="indent"><a id="page155"/>You can save on cost and front panel space by eliminating the Up and Left buttons and having the Down and Right buttons wrap from the last menu option back to the first. Of course, some type of Enter button would still be required.</p>&#13;
<p class="indent">Most LCD-based UIs operate in one of two modes: They display status if no buttons are pressed, and they display a menu when a button is pressed. For example, some printers have a one-line LCD display that reports <i>Ready</i> if there is no activity, shows <i>Printing</i> if it is receiving or printing, and enters a configuration menu if any button is pressed. Laddie has three modes: one to display status, one to display log messages, and one to display a menu for configurations changes and clearing alarms.</p>&#13;
<p class="secs"><a id="chapter10.9"/><a href="toc.html#chapter10.9"><i><b>Be Quick!</b></i></a></p>&#13;
<p class="noindent">The rule of thumb is that the front panel UI should be functional within two seconds of turning on the appliance. This section discusses some common techniques that can help you meet this goal.</p>&#13;
<p class="secls"><b>Boot Linux Faster</b></p>&#13;
<p class="noindent">There is quite a bit that can be done to improve the boot time for Linux. One technique avoids a boot entirely by doing a suspend and resume, instead. A <i>suspend</i> copies the memory and state of the computer to a file or disk partition. A <i>resume</i> reloads the previously saved memory. To set up a suspend and resume on your system, build your kernel with software suspend enabled, and get your appliance into the state that you want your users to see after power on. Issue the suspend command (this may be hibernate, swsusp, or a write into /proc, depending on your system) to save the system state to the swap partition. Properly handled, the suspend image on the swap partition can actually be the software that ships on your appliance. There are configurable scripts that can run on suspend and resume, and you can modify these scripts to restart network connections and to reset the clock. See <a href="http://www.suspend2.net/">http://www.suspend2.net</a> for more details. Be sure to read the HOWTO section on <i>Keep image mode</i>.</p>&#13;
<p class="indent">Software suspend does not improve the load time for the kernel itself, but there are several techniques that do. For example, you can build your kernel with module support disabled and with only the minimum number of device drivers that you need. This reduces the time needed to load modules and should remove the need for an initial RAM disk (initrd). You might be able to avoid loading the kernel entirely if you can execute it directly from ROM or flash memory. This technique is called <i>execute in place (XIP)</i>. Using the kernel option quiet to disable printk messages during boot can save several hundred milliseconds. These and many other techniques are explained on the Consumer Electronics Linux Forum website at <a href="http://www.celinuxforum.org/">www.celinuxforum.org</a>.</p>&#13;
<p class="indent">After the kernel starts, the first program to run is usually /sbin/init, which executes the script /etc/rc.d/rc.sysinit. The rc.sysinit file sets up vital services and starts the other init scripts. On a consumer appliance you should probably replace the entire set of init scripts with one or two custom scripts. This can be a lot of work, but the time savings can be tremendous. A good way to start is to boot your system with the kernel option init=/bin/sh and manually bring up your appliance one command at a time. Try to get the button and LED UIs running as quickly as possible, deferring the non–front panel programs until the end of the initialization. Start programs in the background if you can, but be careful not to background a program if it must complete before another program you need can start. The InitNG package by Jimmy Wennlund is a popular init script alternative that is optimized for a faster boot.</p>&#13;
<p class="indent"><a id="page156"/>If the above techniques are not sufficient to get your front panel working quickly, you may want to add a microcontroller to your design.</p>&#13;
<p class="secls"><b>Use a Microcontroller</b></p>&#13;
<p class="noindent">You can use a microcontroller to handle the buttons, LEDs, and LCD in your UI. Microcontrollers are single-chip computers with on-board RAM, ROM, CPU, and I/O. Common microcontrollers include the Microchip PIC and the Atmel AVR.<sup>1</sup> These controllers are a great way to display messages on an LCD immediately after boot and to make the buttons and keypad responsive immediately. Let’s consider a DVD player as an example. After power-on, the user will usually open the disc drawer, insert a disc, close the drawer, and press Play. If the drawer mechanism is tied directly to your Linux system, the user must wait for Linux to boot before starting the above process. If, on the other hand, you have a microcontroller handling the drawer mechanism and Open button, you can immediately display <i>Ready</i> on the LCD and make the button usable. By the time the user has opened the drawer, loaded the disc, and pressed Play, the Linux part of the DVD player will probably be done booting. Of course, once Linux is running, it will want to control the drawer mechanism directly by treating the microcontroller as one of its peripherals.</p>&#13;
<p class="secls"><b>Use the Main CPU as a Microcontroller</b></p>&#13;
<p class="noindent">Adding a microcontroller increases the cost, power requirement, and printed circuit board space of an appliance. An alternative is to carve out a piece of the main CPU to use as a microcontroller while Linux is starting. You can modify the bootloader to set up a timer interrupt and use the interrupt handler to provide a front panel UI. You’ll need to modify Linux so that it does not touch the timer or interrupt handler while booting. Once Linux is running, it can take over the timer and interrupt, making the front panel hardware just another device that it manages. This technique describes a form of virtual machine (VM); as they become more popular, you may find that a VM provides all the hooks necessary to be used as an I/O controller.</p>&#13;
<p class="secls"><b>Don’t Shut Down</b></p>&#13;
<p class="noindent">A common technique to make an appliance more responsive is to never shut it down. Instead, you can build your appliance to enter a low power state when the user presses the Off button. A low power state might include having a slower CPU clock and removing power to as many peripherals as possible. However, you should be aware that this approach has fallen into disfavor as more and more consumers demand that <i>Off</i> means zero power consumption.</p>&#13;
<p class="secls"><a id="page157"/><b>Give Feedback</b></p>&#13;
<p class="noindent">If you can’t be quick, at least try to give the user an idea of what the system is doing. Don’t be afraid to modify the Linux kernel to send simplified boot status messages to the LCD. Telling the user what is happening can help him or her tolerate the 10- to 20-second boot time of Linux.</p>&#13;
<p class="indent">Giving feedback should not be limited to just the boot process. Give the user constant feedback by bringing the Ethernet activity LED to the front panel or having the LCD display rotate through various appliance statistics. Be sure to indicate error conditions clearly and unambiguously.</p>&#13;
<p class="secl"><a id="chapter10.10"/><a href="toc.html#chapter10.10"><b>The Laddie Front Panel</b></a></p>&#13;
<p class="noindent">Our requirements for the Laddie front panel UI were that we be able to view either system status or log messages, and that we have the minimal set of commands necessary to manage the system. We gave Laddie’s LCD UI three modes: Status, Logs, and Menu. The <i>Status</i> display reports whether there are any alarms, the <i>Logs</i> mode shows the last two log messages, and the <i>Menu</i> mode lets a user clear, test, enable, and disable an alarm zone. There are four buttons for navigating the menu system, and a flashing LED indicates an alarm in the system.</p>&#13;
<p class="indent">The Laddie LCD UI listens for log messages from logmuxd and opens a PostgreSQL/RTA connection to the alarm daemon (ladd). The DB connection to ladd is used for configuration changes and to request the current status. The diagram in Figure 10-5 illustrates how these daemons connect.</p>&#13;
<p class="imgc"><img src="../images/181-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-5: Architecture of the Laddie front panel UI</i></p>&#13;
<p class="indent">Our front panel uses a parallel port to control a HD44780-based LCD (with two lines of 16 characters each) and to scan a 4-button, 2-by-2 keypad. The frame is made of wood, and a paper faceplate made it easy to try different front panel labeling. Figure 10-6 shows a picture of the front panel showing alarms in zones 2 and 5.</p>&#13;
<p class="imgc"><a id="page158"/><img src="../images/182-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-6: A picture of the Laddie front panel</i></p>&#13;
<p class="secs"><a id="chapter10.11"/><a href="toc.html#chapter10.11"><i><b>Laddie LCD Menu System</b></i></a></p>&#13;
<p class="noindent">The menu system we chose for Laddie’s front panel is always in one of three modes: Status, Logs, or Menu. This description of Laddie’s menu system might make more sense if you can see one in action as you read. If you have a PC running the Laddie CD, you can use the web-based front panel emulator at <a href="http://192.168.1.11/front_panel">http://192.168.1.11/front_panel</a>. We’ll show just the text of the display and you can picture what it would look like on a real display. Status mode shows which, if any, zones are in alarm.</p>&#13;
<p class="imgl"><img src="../images/182-2.jpg" alt=""/></p>&#13;
<p class="indent">Logs mode shows the last two log messages that were received. Alarm system log messages are rewritten and forwarded by logmuxd. They include the time that the event occurred, as well as a description of the event. For example:</p>&#13;
<p class="imgl"><img src="../images/182-3.jpg" alt=""/></p>&#13;
<p class="indent">The user can toggle between Status and Logs modes by pressing the Display button. The default mode at program start is Status.</p>&#13;
<p class="indent">If the user presses the Command, Zone, or Enter button, the display switches to Menu mode. When going into Menu mode, the system saves the previous mode (Status or Logs). This lets the user revert to the previous mode when he or she exits Menu mode.</p>&#13;
<p class="indent"><a id="page159"/>The first screen displayed in Menu mode lets the user clear all the alarms with one more button press. The display is:</p>&#13;
<p class="imgl"><img src="../images/183-1.jpg" alt=""/></p>&#13;
<p class="indent">Subsequent presses of the Command button rotate through the available commands. The top line of the display does not change; only the second line rotates through:</p>&#13;
<p class="imgl"><img src="../images/183-2.jpg" alt=""/></p>&#13;
<p class="indent">The Zone button increments the zone from one to five and then back to one.</p>&#13;
<p class="indent">After the user has selected a command and a zone, a press of the Enter button sends the SQL command to the LAD daemon to make the requested change. After sending the command, the menu system displays:</p>&#13;
<p class="imgl"><img src="../images/183-3.jpg" alt=""/></p>&#13;
<p class="indent">The <i>Command Sent</i> message is displayed for about two seconds, and then the display reverts to the mode (Status or Logs) it saved before it went into Menu mode. The user can exit Menu mode at any time by pressing the Display button, which recalls the previous mode (Status or Logs) and reverts to that mode. In addition, if the user abandons a Menu session by not pressing any button for about 10 seconds, the system times out and reverts to the previous display (Status or Logs).</p>&#13;
<p class="indent">We hope our simple menu system for Laddie gives you some ideas for what to include in your front panel menu.</p>&#13;
<p class="secs"><a id="chapter10.12"/><a href="toc.html#chapter10.12"><i><b>Laddie Front Panel Hardware</b></i></a></p>&#13;
<p class="noindent">The Laddie front panel uses a parallel port to scan a 2-by-2 keypad, to control an alarm LED, and to control an HD44780-based, two-line, 16-character LCD display. We provide a Linux 2.6 character device driver for the keypad, LED, and alphanumeric display.</p>&#13;
<p class="secls"><b>Schematics</b></p>&#13;
<p class="noindent">The wiring diagram for the hardware of our prototype front panel is shown in Figure 10-7. Signal frequencies in this circuit are fairly low, so either wire wrap or point-to-point wiring should be fine. None of the component values are critical, and the values shown should be taken as guides, not as requirements.</p>&#13;
<p class="imgc"><a id="page160"/><img src="../images/184-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-7: Schematic of the Laddie front panel</i></p>&#13;
<p class="indent">Our prototype uses a second parallel port for the front panel. (The first parallel port was used, you may recall, for the alarm system zone sensors.) We use the data lines of the parallel port for the character input to the display. Two of the parallel port’s control lines are used for the register select and write strobe. A third control line from the parallel port controls the alarm LED. Two data lines and two status lines are used for scanning the four-button keypad. From your understanding of how a scanned keypad works, you may be able to add the five zone switches to this schematic, putting all the Laddie hardware on one parallel port.</p>&#13;
<p class="secls"><b>The HD44780 Display Controller</b></p>&#13;
<p class="noindent">An HD44780-based alphanumeric display can be thought of as a mini-terminal. Like any terminal, you write ASCII characters to it and it displays them. This terminal’s eight-bit character set includes the printable ASCII characters, a subset of the Katakana character set, and 16 user-defined characters. The actual character set depends on which version of HD4478 you have, but the character set for the Samsung KS0066U shown in Figure 10-8 is fairly typical. Note that the character code corresponds mostly to the ASCII code. For example, the code for <i>A</i> is 0x41, which is also the ASCII code for <i>A</i>.</p>&#13;
<p class="imgc"><a id="page161"/><img src="../images/185-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-8: A typical HD44780 character set</i></p>&#13;
<p class="secls"><b>The HD44780 Command Set</b></p>&#13;
<p class="noindent">An HD44780 display accepts both commands and characters. Figure 10-9 shows a typical command set for the HD44780. Initialization commands can clear the display, turn it on or off, and specify whether the interface uses four or eight bits. Cursor commands control the cursor type (block or underline), whether or not the cursor is visible, whether the cursor or the display moves after displaying a character, and whether the movement is to the left or the right. Other commands let you move the cursor to a specific location and to read and write to the user-defined character generator.</p>&#13;
<p class="imgc"><img src="../images/185-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-9: The HD44780 command set</i></p>&#13;
<p class="indent"><a id="page162"/>Our initialization of the HD44780 consists of the following command sequence:</p>&#13;
<p class="imgl"><img src="../images/186-1.jpg" alt=""/></p>&#13;
<p class="indent">We’ve found that after initialization, the only command we use is the move cursor command—and we only use it to move the cursor to the first column of either the top or bottom row.</p>&#13;
<p class="secls"><b>Sending Commands and Characters to the Laddie Front Panel</b></p>&#13;
<p class="noindent">You can read status and configuration information from the HD44780 if you want, but many designs, including ours, connects the read/write pin to ground, making the part write only. This saves a pin (since it is not controlling the R/W line), and it is just as easy to maintain any necessary state information—cursor location, for example—in the controlling software.</p>&#13;
<p class="indent">Our HD44780 design has 10 pins that tie to the microprocessor: eight data lines, a pin to specify either command or character data (RS), and a strobe pin to tell to tell the HD44780 that new data is available (E). The eight output lines on the parallel port connect directly to the eight data pins on the HD44780. If your hardware design has fewer pins, you can configure the part to use a four-bit bus instead of an eight-bit bus. Of course, this doubles the number of steps needed to write a byte to the part.</p>&#13;
<p class="indent">Since both characters and commands are eight bits in length, we need another way to differentiate commands and data. Consider, for example, the byte 0x20. Is this a space or a configuration command? Since both commands and characters are eight bits, the HD44780 uses another pin, the RS pin, to distinguish between the two. You can set the RS pin to a zero for commands and to a one for character data. One of the issues to decide in designing the device driver is how to control this pin.</p>&#13;
<p class="indent">Data is transferred to the HD44780 on the high-to-low transition of the E pin. The data must be valid for at least half a microsecond before the E line goes low. The actual setup time is a function of the brand of HD44780 and its oscillator frequency. In our device driver we use usleep() to delay two microseconds before setting E low.</p>&#13;
<p class="indent">Relative to the schematic given above, the sequence for writing to the HD44780 is:</p>&#13;
<ul>&#13;
<li>Output the character or command to the data register.</li>&#13;
<li>Set the RS line high or low.</li>&#13;
<li>Set the E line high.</li>&#13;
<li>Wait two microseconds.</li>&#13;
<li>Set the E line low.</li>&#13;
<li>Wait at least five milliseconds before writing the next byte.</li>&#13;
</ul>&#13;
<p class="indent"><a id="page163"/>The HD44780 can take several milliseconds to execute some commands. You can read the status of the display to tell you when to write the next byte, or you can do what we did, which is just wait at least five milliseconds between writes. The exact time is dependent on the version of HD44780 that you use. For this book we used a display we bought on the surplus market, so we had to experiment a little to find the right delay.</p>&#13;
<p class="secls"><b>Design Notes</b></p>&#13;
<p class="noindent">While the HD44780-based display can be thought of as a simple ASCII terminal, there were a couple of decisions we needed to make when we designed our API and device driver. The first was how to handle the RS pin. Since both commands and display characters are eight bits in length, we could not mix display characters and commands in the same byte stream. We saw three ways to get around this problem: We could send commands using an ioctl, we could use an escape sequence to bury the commands in the character stream, or we could have two different devices for the display, one for characters and one for commands. We chose to use an escape sequence. The HD44780 we used had no display characters in the range of 0x10 to 0x1F, so we used 0x10 as the escape code for HD44780 commands and 0x11 as the escape code for commands to control the front panel LED.</p>&#13;
<p class="indent">The other consideration in our design was how to handle the five-millisecond delay between writes. We could have put a usleep(5000) between writes, but this would have been a problem when updating all 32 characters on our display. (You may recall that the whole reason for writing a device driver was to have a guaranteed scan rate for the keypad.) We handled the five-millisecond delay by writing all output bytes into a circular buffer and reading one byte from the buffer each time we scanned the keypad. This slowed the maximum rate that we can output characters but was simple and effective.</p>&#13;
<p class="indent">The Linux device driver that we wrote to drive our display is available on the CD. Look in the source files under front_panel.</p>&#13;
<p class="secls"><b>Further Reading</b></p>&#13;
<p class="noindent">The HD44780 came out quite some time ago and is in fact no longer available. Nonetheless, it set the standard for alphanumeric LCD displays, and HD44780-compatible parts are still available from several vendors. A web search will locate data sheets for several HD44780-compatible parts, including the Samsung KS0066U that we used.</p>&#13;
<p class="indent">Our review of the HD44780 is very far from complete. If you are considering using any alphanumeric displays on your appliance, you might want to make use of some of the online references that we used:</p>&#13;
<p class="bl"><a href="http://www.epemag.wimborne.co.uk/resources.htm"><b>http://www.epemag.wimborne.co.uk/resources.htm</b></a> A simple but complete introduction to the HD44780</p>&#13;
<p class="bl"><a href="http://home.iae.nl/users/pouweha/lcd/lcd.shtml"><b>http://home.iae.nl/users/pouweha/lcd/lcd.shtml</b></a> Offers details on HD44780 interfacing</p>&#13;
<p class="bl"><a href="http://www.eio.com/datashet.htm"><b>http://www.eio.com/datashet.htm</b></a> Data sheets on HD44780-compatible parts</p>&#13;
<p class="secs"><a id="chapter10.13"/><a href="toc.html#chapter10.13"><i><b>Laddie Front Panel UI</b></i></a></p>&#13;
<p class="noindent"><a id="page164"/>In earlier sections of this chapter we reviewed the requirements, operations, and hardware for the Laddie front panel. In this section we’ll look at the software that implements the front panel UI. We’ll break our discussion into three areas: the software for the front panel, the various front panel emulators, and the software architecture common to both. Let’s start with the common architecture.</p>&#13;
<p class="secls"><b>UI Software Architecture</b></p>&#13;
<p class="noindent">The front panel software uses an event-driven state machine. Events include button presses, the expiration of a timer, and arriving log messages that indicate a possible change of state in the alarm system. Output from the program includes SQL commands sent to the Laddie daemon, a flag to flash (or not flash) the LED, and the text displayed on the LCD.</p>&#13;
<p class="imgc"><img src="../images/188-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-10: Laddie front panel architecture</i></p>&#13;
<p class="indent">Several state variables are used. The primary state variable, unimaginatively called State, indicates the type of information displayed on the LCD: status, log, or menu. There are also states for the brief <i>Command Sent</i> message and for an indication that the program could not open an SQL connection to the ladd daemon. Another state variable, Curcmd, contains an integer that indicates which command to show when the user is in the menu. The <i>Command</i> button cycles Curcmd through the five possible front panel commands. The Zone state variable holds the zone number to use for the current command. The Zone button cycles Zone through the five possible zone numbers.</p>&#13;
<p class="imgl"><img src="../images/188-2.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure 10-11: Events and states in the front panel menu system</i></p>&#13;
<p class="indent">The code to handle the state and event processing is fairly easy to read once you’ve reviewed the operation of the front panel. The state machine code is implemented twice—once in C for the hardware and several emulators, including a web-based emulator written in JavaScript and PHP.</p>&#13;
<p class="secls"><b>lad216</b></p>&#13;
<p class="noindent"><a id="page165"/>The C code to generate the proper escape sequences is in the lad216 program. The program uses standard in and out, so if you build the hardware described above and install our /dev/lad_pad driver, you could tie the lad216 program to the hardware with the command:</p>&#13;
<p class="ex">lad216 &lt;/dev/lad_pad &gt;/dev/lad_pad</p>&#13;
<p class="indent">The code is in three files: main.c which has the select loop, menu.c which has the state machine, and lad216.c which encodes the output for display on the lad_pad hardware. Using standard input and output makes it easy to connect lad216 to the various front panel emulators described below.</p>&#13;
<p class="secls"><b>Front Panel Emulators</b></p>&#13;
<p class="noindent">A front panel emulator is a great way to test a front panel design without actually building it. Front panel emulators that ship with the finished product are particularly nice for end users who do not want to be burdened with learning different UIs.</p>&#13;
<p class="indent">We went a little overboard building front panel emulators for Laddie, building one that uses C and curses, one that uses Tcl/Tk and the X Window system, and one that uses JavaScript and HTML. You can choose which emulator to examine based on your preferred programming language.</p>&#13;
<p class="indent">The curses version replaces lad216.c with cur216.c, but still uses the main.c and menu.c files. You can try the curses front panel emulator by booting the Laddie CD and telnetting into the appliance. The cur216 executable is in the default path.</p>&#13;
<p class="indent">The Tcl/Tk version, x216.tcl, is based on the lad216 executable, using Tcl/Tk to replace the lad_pad hardware with a Tcl equivalent. The Laddie CD does not include the X Window system so you can not run x216.tcl on a booted Laddie appliance.</p>&#13;
<p class="indent">You can try the web-based front panel emulator by booting Laddie and pointing your browser to <a href="http://192.168.1.11/front_panel">http://192.168.1.11/front_panel</a>. The index.html file should open a window with a photograph of our actual front panel hardware. The buttons are tied to an image map and operate the same way the buttons do on the real system. The LED is either a static image of the LED in the off state, or is an animated GIF image of the flashing LED. The HTML of the LCD uses CSS to specify a fairly large monospaced font.</p>&#13;
<p class="indent">The techniques used in the web emulator are simple, and you may find them of use if you ever build a web emulator of your own front panel. To illustrate these techniques, let’s look at how the LED image is controlled. In the HTML we specify the exact location of the image and give it a name, <i>led.</i></p>&#13;
<p class="ex">&lt;div id="led" style="position:absolute; left:27; top:20;"&gt;&lt;/div&gt;</p>&#13;
<p class="indent"><a id="page166"/>The JavaScript code uses XMLHttpRequest() to request the alarm status from a PHP script tied to the webserver running on the appliance. The value returned is zero if there are no alarms. The JavaScript to control the LED image is straightforward.</p>&#13;
<p class="imgl"><img src="../images/190-1.jpg" alt=""/></p>&#13;
<p class="indent">The JavaScript program uses the exact same architecture and state machine as described above, and it uses XMLHttpRequest() instead of select() to asynchronously wait for log messages. After the arrival of any log message, the code queries ladd for the latest status and redraws the web page based on the new status information.</p>&#13;
<p class="secl"><a id="chapter10.14"/><a href="toc.html#chapter10.14"><b>Improving Our Design</b></a></p>&#13;
<p class="noindent">The Laddie front panel could be improved in several ways. The lad_pad driver could have been simplified had we separated the LCD data lines from the two output lines used for keypad scanning. Separating them would have allowed the convenient use of a second timer just for LCD output characters, which would have made the LCD more responsive to output. Another improvement in the driver would have been to pull more than one character from the queue if the characters were not sent to the LCD. For example, there is no reason to wait 20 milliseconds between characters if the character is an escape code or an LED command.</p>&#13;
<p class="indent">The photograph in the web front panel is of the hardware we built. This is a little backward. Normally, you would build and test the emulated web-based version before building the actual hardware.</p>&#13;
<p class="indent">The web-based front panel has a more subtle problem. It uses XMLHttpRequest() to wait for arriving log messages, and after receiving one, it sets a timer to make the next request.</p>&#13;
<p class="ex">setTimeout("GetLogMsg()", 100);</p>&#13;
<p class="indent">This arrangement, no matter how short the timer, will miss log messages that arrive close together. You can see this in action by setting three alarms and clearing them all at once. The log display will capture the log of the first alarm being cleared, but it will miss one or both of the logs for the next two. The main web interface has the same problem, but solves it by numbering the log messages. After updating the web page, the JavaScript code in the main web UI reads the ID of the last message received from logmuxd. If the ID of the log in the web page does not include the most recent log message, the page is redrawn using the most recent log messages.</p>&#13;
<p class="secl"><a id="chapter10.15"/><a href="toc.html#chapter10.15"><b>Summary</b></a></p>&#13;
<p class="noindent"><a id="page167"/>In this chapter we’ve looked at how you can build an effective front panel using buttons, LEDs, and small, text-only LCDs. We saw that scanning a keypad or LED array can reduce the number of I/O lines you need, and that movement, such as a blinking LED, can draw the eye and let the user know that the appliance is running. We also noted that how well your appliance is accepted may depend on how quickly you make user interaction possible and how easily users can navigate your menu system.</p>&#13;
<p class="indent">We reviewed Laddie’s front panel design, including its menu system, hardware, UI software, and various front panel emulators. Our hardware design includes an HD44780 display and a 2-by-2 keypad. The source for our 2.6 character device driver, lad_pad, is on the CD and might be a nice introduction to kernel modules.</p>&#13;
<p class="indent">The UI menu system is implemented as a state machine, and is implemented twice. The first implementation, using C, uses standard in and out so that it can be tied to either a Tcl/Tk emulator or to the real front panel. The second implementation uses JavaScript and image maps for the front panel buttons and uses XMLHttpRequest() to receive the asynchronous log messages.</p>&#13;
<p class="imgc"><a id="page168"/><img src="../images/192-1.jpg" alt=""/></p>&#13;
<p class="noindent1">__________________</p>&#13;
<p class="foot"><sup>1</sup> You can program the Atmel AVR using C on a Linux workstation. See <a href="http://www.avrfreaks.org/">www.avrfreaks.org</a> for more information.</p>&#13;
<p class="foot"><sup>2</sup> You may need to set the terminal type, since telnet does not set it for you. I use xterm on my desktop, so when I telnet to the Laddie appliance, I set the terminal type with the command export TERM=xterm.</p>&#13;
</div>&#13;
</body></html>