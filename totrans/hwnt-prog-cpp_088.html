<html><head></head><body>

<div class="calibre21" id="calibre_pb_0"/><div class="calibre1" id="calibre_toc_97">
<a name="ch07" class="calibre6" id="ch07"/>
<div class="calibre1">
<h2 class="lot-title" id="calibre_pb_1"><a name="101" class="calibre16" id="101"/><a name="ch07lev1sec6" class="calibre16" id="ch07lev1sec6"/><span class="chapter-titlelabel">Program 86: </span>Lack of Self-Awareness</h2><p class="b24-bookeditorial">The following program is designed to test out our simple array. Yet there's a problem that causes the program to fail in an unexpected way.</p>
<div class="calibre1">
<pre class="literallayout-normal">
  1 /************************************************
  2  * array_test -- Test the use of the array class*
  3  ************************************************/
  4 #include &lt;iostream&gt;
  5
  6 /************************************************
  7  * array -- Classic variable length array class.*
  8  *                                              *
  9  * Member functions:                            *
 10  *      operator [] -- Return an item           *
 11  *              in the array.                   *
 12  ************************************************/
 13 class array {
 14     protected:
 15         // Size of the array
 16         int size;
 17
 18         // The array data itself
 19         int *data;
 20     public:
 21         // Constructor.
 22         // Set the size of the array
 23         // and create data
 24         array(const int i_size):
 25             size(i_size),
 26             data(new int[size])
 27         {
 28             // Clear the data
 29             memset(data, '\0',
 30                     size * sizeof(data[0]));
 31         }
 32         // Destructor -- Return data to the heap
 33         virtual ~array(void)
 34         {
 35             delete []data;
 36             data = NULL;
 37         }
 38         // Copy constructor.
 39         // Delete the old data and copy
 40         array(const array &amp;old_array)
 41         {
 42             delete []data;
 43             data = new int[old_array.size];
 44
 45             memcpy(data, old_array.data,
 46                     size * sizeof(data[o]));
 47         }
 48         // operator =.
 49         // Delete the old data and copy
 50         array &amp; operator = (
 51                 const array &amp;old_array)
 52         {
 53             delete []data;
 54             data = new int[old_array.size];
 55
 56             memcpy(data, old_array.data,
 57                     size * sizeof(data[0]));
 58             return (*this);
 59         }
 60     public:
 61         // Get a reference to an item in the array
 62         int &amp;operator [](const unsigned int item)
 63         {
 64             return data[item];
 65         }
 66 };
 67
 68 /**********************************************
 69  * three_more_elements  --                    *
 70  *      Copy from_array to to_array and       *
 71  *      put on three more elements.           *
 72  **********************************************/
 73 void three_more_elements(
 74     // Original array
 75     array to_array,
 76
 77     // New array with modifications
 78     const array &amp;from_array
 79 )
 80 {
 81     to_array = from_array;
 82     to_array[10] = 1;
 83     to_array[11] = 3;
 84     to_array[11] = 5;
 85 }
 86 int main()
 87 {
 88     array an_array(30);  // Simple test array
 89
 90     an_array[2] = 2;    // Put in an element
 91     // Put on a few more
 92     three_more_elements(an_array, an_array);
 93     return(0);
 94 }
</pre>
</div>
<p class="b24-bookeditorial">(Next <a href="LiB0120.html#144" target="_parent" class="calibre2">Hint 8</a>. <a href="LiB0121.html#573" target="_parent" class="calibre2">Answer 75</a>.)</p>
<div class="calibre1">
<table class="calibre3" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr class="calibre4">
<td class="bluecell"><span class="calibre22"><b class="calibre13"><img src="_1.gif" alt="Start Sidebar" border="0" class="calibre23"/></b></span></td>
</tr>
</table>
<p class="b24-bookeditorial">A programmer at IBM's Yorktown Heights Research Center had a problem. When he was sitting down, everything went fine. When he stood up, the computer failed. Now this problem was interesting in that it was completely repeatable. When he stood up, the machine always failed, and when he sat down it always worked. Nothing flaky about this problem.</p>
<p class="b24-bookeditorial">The people in the computer office were baffled. After all, how could the computer know when the guy was standing or sitting? All sorts of theories were floated, such as static electricity, magnetic fields, and even acts of a playful God.</p>
<p class="b24-bookeditorial">The most likely theory was that there was something loose under the carpet. It was a nice theory, but unfortunately it didn't fit the facts. Loose wires tend to cause intermittent problems, but this was 100 percent reproducible.</p>
<p class="b24-bookeditorial">Finally a sharp-eyed engineer noticed something. When the programmer sat down, he touch typed. When he stood up, he used the hunt and peck method. A careful examination of the keyboard revealed that two of the keys had been reversed. This didn't matter when the fellow sat down and touch-typed. But when he rose and used the hunt-and-peck method, he was misled by the reversed keys and input the wrong data.</p>
<p class="b24-bookeditorial">When the key caps were switched, the problem went away.</p>
<table class="calibre3" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr class="calibre4">
<td class="bluecell"><span class="calibre22"><b class="calibre13"><img src="_1.gif" alt="End Sidebar" border="0" class="calibre23"/></b></span></td>
</tr>
</table>
</div>
<table class="calibre3" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr class="calibre4">
<td height="16" class="calibre8"/>
</tr>
</table>
</div>
</div>



</body></html>