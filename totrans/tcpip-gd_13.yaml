- en: Part III-2. NETWORK FILE AND RESOURCE SHARING PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 58](ch58.html "Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE
    TCP/IP NETWORK FILE SYSTEM (NFS)")'
  prefs: []
  type: TYPE_NORMAL
- en: 'To the typical end user, networks were created for one main reason: to permit
    the sharing of information. Most information on computers exists in the form of
    files that reside on storage devices such as hard disks; thus, one primary purpose
    of networks is to let users share files. File transfer and message transfer protocols
    allow users to manually move files from one place to the next, but a more automated
    method is preferable in many cases. Internetworking protocols provide such capabilities
    in the form of *network file and resource sharing protocols*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this brief part, I describe network file and resource sharing protocols
    from the standpoint of TCP/IP networks. The one chapter here provides an overview
    of the concepts and operation of this class of protocols, discussing some of the
    elements common to the different types. It then describes the most common one
    defined specifically for TCP/IP: the Network File System (NFS).'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, network file and resource sharing protocols and services are closely
    related to the file and message transfer protocols I mentioned earlier. For example,
    NFS can be used to accomplish tasks similar to those performed by TCP/IP file
    and message transfer applications such as the File Transfer Protocol (FTP) and
    the Hypertext Transfer Protocol (HTTP). I consider those protocols more like specific
    end-user applications unto themselves, and therefore describe them in later parts
    on application protocols (FTP in [Part III-6](pt17.html "Part III-6. TCP/IP GENERAL
    FILE TRANSFER PROTOCOLS") and HTTP in [Part III-8](pt19.html "Part III-8. TCP/IP
    WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)")). I realize that this
    distinction between manual and automatic file transfer is somewhat arbitrary,
    but then, so are a lot of other things in the great world of networking.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM
    (NFS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: File and resource sharing protocols are important because they let users seamlessly
    share files over a network. Due to the dominance of Microsoft operating systems
    in the industry, many people are familiar with the way Microsoft networking can
    be used in this way. However, Microsoft is somewhat of a "Johnny come lately"
    to file sharing protocols. Long before Microsoft Windows even existed, the *Network
    File System (NFS)* was letting users share files over a network using the UNIX
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide a brief look at network file and resource sharing
    in TCP/IP, with a focus on the operation of NFS. I begin with a general look at
    file and resource sharing protocol concepts. Then I provide an overview and history
    of NFS, and discuss its common versions and standards. I describe the architecture
    of NFS and the three components that compose it. I then describe the NFS file
    system model and how data is encoded using the *External Data Representation (XDR)*
    standard. I explain the client/server operation of NFS using *Remote Procedure
    Calls (RPCs)*. I then list the procedures and operations used in NFS, and conclude
    with a description of the separate NFS Mount protocol, used to attach network
    resources to a device.
  prefs: []
  type: TYPE_NORMAL
- en: File and Resource Sharing Concepts and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A primary reason why networks and internetworks are created is to allow files
    and other resources to be shared among computers. Thus, in any internetworking
    protocol stack, we need some mechanism by which users can easily move files across
    a network in a simple way. Application layer file and message transfer protocols
    like the File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP) were
    created for just this purpose: to let users access resources across a network
    while hiding the details of how the network operates at the layers below them.'
  prefs: []
  type: TYPE_NORMAL
- en: However, even though these protocols hide the lower layers, they are somewhat
    *manual* in nature. They require a user to invoke an application protocol and
    use specific commands that accomplish network-based resource access. In fact,
    the problem with such protocols isn't so much that they require manual intervention,
    but that they make sharing more difficult because they don't allow a file to be
    used directly on another resource.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a protocol like FTP. It does lets you share files between machines,
    but it draws a clear distinction between a file that is yours and a file that
    is someone else's. If you want to use a file on Joe's machine, you must transfer
    it to your machine, use it, and then transfer it back. Also, if you don't transfer
    the file back, Joe might never even see the updated version.
  prefs: []
  type: TYPE_NORMAL
- en: The Power of File and Resource Sharing Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ultimate in file and resource sharing is achieved when we can hide even
    the details of where the files are located and the commands required to move them
    around. Such a system would use an *automatic* sharing protocol that lets files
    and resources be used over a network seamlessly. Once set up, a network resource
    in such a scheme can be used in much the same way that one on a local computer
    is. Such protocols are sometimes called *network file and resource sharing protocols*.
  prefs: []
  type: TYPE_NORMAL
- en: It is this blurring of the line between a local file and a remote one that makes
    file and resource sharing protocols so powerful. Once the system is set up, users
    can access resources on another host as readily as on their own host. This is
    an extremely useful capability, especially in the modern era of client/server
    computing. For example, it allows a company to store information that is used
    by many individuals in a common place, such as in a directory on a server, where
    each of those individuals can access it. In essence, there is a virtual file system
    that spans network devices, instead of being simply on one storage device on a
    single computer.
  prefs: []
  type: TYPE_NORMAL
- en: Components of a File and Resource Sharing Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'File and transfer protocols allow users to share files effortlessly, but that
    doesn''t mean no work is involved. The work is still there, but it''s shouldered
    by those who write the protocol and those who administer its operation. Generally
    speaking, these protocols require at least the following general components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File System Model and Architecture** A mechanism for defining resources and
    files to be shared, and for describing how the virtual file system works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Access Method** Procedures that describe how users can attach or
    detach a distant resource from their local host.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation Set** A set of operations for accomplishing various tasks that
    the users need to perform on files on other hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messaging Protocol** Message formats that carry operations to be performed,
    status information, and more, and a protocol for exchanging these messages between
    devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Administrative Tools** Miscellaneous functionality needed to support the
    operation of the protocol and tie the other elements together.'
  prefs: []
  type: TYPE_NORMAL
- en: NFS Design Goals, Versions, and Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The histories of TCP/IP and the Internet are inextricably linked, as I discussed
    in [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE").
    However, there is a third partner that is less often mentioned but very much part
    of the development history of these technologies. That is the operating system
    that ran on the machines in the early Internet and is still used on a large percentage
    of Internet servers today: the *UNIX* operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: Sun Microsystems was one of the early pioneers in the development of UNIX and
    in TCP/IP networking. Early in the evolution of TCP/IP, certain tools were created
    to allow a user to access another machine over the network—after all, this is
    arguably the entire point of networking. Remote-access protocols such as Telnet
    allowed a user to log in to another host computer and use resources there. FTP
    allowed people to copy a file from a distant machine to their own and edit it.
    However, neither of these solutions really fit the bill of allowing a user to
    access a file on a remote machine in a way similar to how a local file is used.
    To fill this need, Sun created the *Network File System (NFS)*.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Design Goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NFS was specifically designed with the goal of eliminating the distinction between
    a local and a remote file. To a user, after the appropriate setup is performed,
    a file on a remote computer can be used as if it were on a hard disk on the user's
    local machine. Sun also crafted NFS specifically to be vendor-independent, to
    ensure that both hardware made by Sun and that made by other companies could interoperate.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important design goals of NFS was performance. Obviously, even
    if you set up a file on a distant machine as if it were local, the actual read
    and write operations must travel across a network. Usually, this takes more time
    than simply sending data within a computer, so the protocol itself needed to be
    as lean and mean as possible. This decision led to some interesting choices, such
    as the use of the unreliable User Datagram Protocol (UDP) for transport in TCP/IP,
    instead of the reliable Transmission Control Protocol (TCP), as with most file
    transfer protocols. This, in turn, has interesting implications on how the protocol
    works as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Another key design goal for NFS was simplicity (which of course is related to
    performance). NFS servers are said to be *stateless*, which means that the protocol
    is designed so that servers do not need to keep track of which files have been
    opened by which clients. This allows requests to be made independently of each
    other, and allows a server to gracefully deal with events such as crashes without
    the need for complex recovery procedures.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol is also designed so that if requests are lost or duplicated, file
    corruption will not occur.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *Network File System (NFS)* was created to allow client
    hosts to access files on remote servers as if they were local. It was designed
    primarily with the goals of performance, simplicity, and cross-vendor compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: NFS Versions and Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since it was initially designed and marketed by Sun, NFS began as a de facto
    standard. The first widespread version of NFS was version 2 (NFSv2), and this
    is still the most common version of the protocol. NFSv2 was eventually codified
    as an official TCP/IP standard when RFC 1094, "NFS: Network File System Protocol
    Specification," was published in 1989.'
  prefs: []
  type: TYPE_NORMAL
- en: NFS version 3 (NFSv3) was subsequently developed, and it was published in 1995
    as RFC 1813, "NFS Version 3 Protocol Specification." It is similar to NFSv2, but
    makes a few changes and adds some new capabilities. These include support for
    larger files and file transfers, better support for setting file attributes, and
    several new file access and manipulation procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'NFS version 4 (NFSv4) was published in 2000 as RFC 3010, "NFS Version 4 Protocol."
    Where NFSv3 contained only relatively small changes to the previous version, NFSv4
    is virtually a rewrite of NFS. It includes numerous changes, most notably the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting the needs of modern internetworking, NFSv4 puts greater emphasis
    on security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFSv4 introduces the concept of a *compound* procedure, which allows several
    simpler procedures to be sent from a client to a server as a group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFSv4 almost doubles the number of individual procedures that a client can use
    in accessing a file on an NFS server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFSv4 makes a significant change in messaging, with the specification of TCP
    as the transport protocol for NFS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFSv4 integrates the functions of the Mount protocol into the basic NFS protocol,
    eliminating it as a separate protocol as it is in previous versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NFSv4 standard also has a lot more details about implementation and optional
    features than the earlier standards—it's 275 pages long. So much for simplicity!
    RFC 3010 was later updated by RFC 3530, "Network File System (NFS) Version 4 Protocol,"
    in April 2003\. This standard makes several further revisions and clarifications
    to the operation of NFSv4.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Architecture and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NFS follows the classic TCP/IP client/server model of operation. A hard disk
    or a directory on a storage device of a particular computer can be set up by an
    administrator as a shared resource. This resource can then be accessed by client
    computers, which *mount* the shared drive or directory, causing it to appear as
    if it were a local directory on the client machine. Some computers may act as
    only servers or only clients; others may be both, sharing some of their own resources
    and accessing resources provided by others.
  prefs: []
  type: TYPE_NORMAL
- en: Considered from the perspective of the TCP/IP protocol suite as a whole, NFS
    is a single protocol that resides at the application layer of the TCP/IP (DOD)
    model (described in [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND
    ARCHITECTURE")). This TCP/IP layer encompasses the session, presentation, and
    application layers of the OSI Reference Model (described in [Chapter 6](ch06.html
    "Chapter 6. OSI REFERENCE MODEL LAYERS")). As I have said before in this book,
    I don't see much value in trying to differentiate between layers 5 through 7 most
    of the time. In some situations, however, these layers can be helpful in understanding
    the architecture of a protocol, and that's the case with NFS.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Main Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operation of NFS is defined in the form of three main components that can
    be viewed as logically residing at each of the three OSI model layers corresponding
    to the TCP/IP application layer, as illustrated in [Figure 58-1](ch58s03.html#nfs_architectural_components
    "Figure 58-1. NFS architectural components"):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Procedure Call (RPC)** RPC is a generic session layer service used
    to implement client/server internetworking functionality. It extends the notion
    of a program calling a local procedure on a particular host computer to the calling
    of a procedure on a remote device across a network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**External Data Representation (XDR)** XDR is a descriptive language that allows
    data types to be defined in a consistent manner. XDR conceptually resides at the
    presentation layer. Its universal representations allow data to be exchanged using
    NFS between computers that may use very different internal methods of storing
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NFS Procedures and Operations** The actual functionality of NFS is implemented
    in the form of procedures and operations that conceptually function at layer 7
    of the OSI model. These procedures specify particular tasks to be carried out
    on files over the network, using XDR to represent data and RPC to carry the commands
    across an internetwork.'
  prefs: []
  type: TYPE_NORMAL
- en: These three key "subprotocols," if you will, compose the bulk of the NFS protocol.
    Each is described in more detail in a separate section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![NFS architectural components](httpatomoreillycomsourcenostarchimages288191.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 58-1. NFS architectural components
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** NFS resides architecturally at the TCP/IP application layer.
    Even though in the TCP/IP model no clear distinction is made generally between
    the functions of layers 5 through 7 of the OSI Reference Model, NFS''s three subprotocols
    correspond well to those three layers as shown.NFS resides architecturally at
    the application layer of the TCP/IP model. Its functions are implemented primarily
    through three distinct functional components that implement the functions of layers
    5 through 7 of the OSI Reference Model: the *Remote Procedure Call (RPC)*, which
    provide session-layer services; the *External Data Representation (XDR)* standard,
    which manages data representation and conversion; and *NFS procedures and operations*,
    which allow application layer tasks to be performed using the other two components.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Important NFS Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aside from it three main components, the NFS protocol as a whole involves a
    number of other functions, most notably the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mount Protocol** A specific decision was made by the creators of NFS to not
    have NFS deal with the particulars of file opening and closing. Instead, a separate
    protocol called the *Mount* protocol is used for this purpose. Accessing a file
    or other resource over the network involves first *mounting* it using this protocol.
    The Mount protocol is architecturally distinct, but obviously closely related
    to NFS, and is even defined in an appendix of the NFS standard. I describe it
    in the last section in this chapter. (Note that in NFSv4, the functions of the
    Mount protocol have been incorporated into NFS proper.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NFS File System Model** NFS uses a particular model to implement the directory
    and file structure of the systems that use it. This model is closely based on
    the file system model of UNIX, but is not specific to only that operating system.
    It is discussed in conjunction with the explanation of the Mount protocol at the
    end of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security** Versions 2 and 3 of NFS include only limited security provisions.
    They use UNIX-style authentication to check permissions for various operations.
    NFSv4 greatly increases the security options available for NFS implementations.
    These include provisions for multiple authentication and encryption algorithms,
    and many changes to the protocol as a whole to make it more secure.'
  prefs: []
  type: TYPE_NORMAL
- en: NFS Data Definition with the External Data Representation (XDR) Standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The overall idea behind NFS is to allow you to read from or write to a file
    on another computer as readily as you do on your local machine. Of course, the
    files on your local machine are all stored in the same file system, using the
    same file structure and the same means of representing different types of data.
    You can't be sure that this will be the case when accessing a remote device, and
    this creates a bit of a Tower of Babel problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach would be to simply restrict access only to remote files on machines
    that use the same operating system. However, this would remove much of the effectiveness
    of NFS. It would also be highly impractical to require every computer to understand
    the internal representation of every other one. A more general method is needed
    to allow even very dissimilar machines to share data. To this end, the creators
    of NFS defined NFS so that it deals with data using a universal data description
    language. This language is called the *External Data Representation (XDR)* standard
    and was originally described in RFC 1014\. It was updated in RFC 1832, "XDR: External
    Data Representation Standard," in 1995.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Method of Universal Data Exchange: XDR'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind XDR is simple, and it can be easily understood in the form
    of an analogy. If you had delegates speaking 50 different languages at a convention,
    they would have a hard time communicating. You could hire translators to facilitate,
    but you would never find translators to handle all the different possible combinations
    of languages. A more practical solution is to declare one language, such as English,
    to be a common language. You then need only 49 translators: one to translate from
    English to each of the non-English languages and back again. To translate from
    Swedish to Portuguese, you translate from Swedish to English and then from English
    to Portuguese. The common language could be French, Spanish, or something else,
    as long as a translator could be found from all the other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: XDR works in the same manner. When information about how to access a file is
    to be transferred from Device A to Device B, Device A first converts it from Device
    A's internal representation to the XDR representation of those data types. The
    information is transmitted across the network using XDR encoding. Then Device
    B translates from XDR back to its own internal representation, so it can be presented
    to the user as if it were on the local file system. Each device needs to know
    only how to convert from its own language to XDR and back again; Device A doesn't
    need to know Device B's internal details and vice versa. This sort of translation
    is a classic job of the presentation layer, which is where XDR resides in the
    OSI Reference Model. XDR is itself based on an International Organization for
    Standardization (ISO) standard called "Abstract Syntax Notation."
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The idea behind XDR is also used in other protocols to allow the exchange
    of data independent of the nature of the underlying systems. For example, a similar
    idea is behind the way management information is exchanged using the Simple Network
    Management Protocol (SNMP), which is described in [Chapter 66](ch66.html "Chapter 66. TCP/IP
    STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)").
    The same basic idea underlies the important Network Virtual Terminal (NVT) paradigm
    used in the Telnet protocol, which is described in [Chapter 87](ch87.html "Chapter 87. TCP/IP
    INTERACTIVE AND REMOTE APPLICATION PROTOCOLS")*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The purpose of the *External Data Representation (XDR)* standard
    is to define a common method for representing common data types. Using this universal
    representation, data can be exchanged between devices, regardless of what internal
    file system each uses. This enables NFS to exchange file data between clients
    and servers that may be implemented using very different hardware and software
    platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: XDR Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For XDR to be universal, it must allow the description of all the common types
    of data that are used in computers. For example, it must allow integers, floating-point
    numbers, strings, and other data constructs to be exchanged. The XDR standard
    describes the structure of many data types using a notation somewhat similar to
    the C programming language. As you may know, this is one of the most popular languages
    in computing history, and it is closely associated with UNIX (and thus, certain
    TCP/IP technologies as well).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 58-1](ch58s04.html#nfs_external_data_representation_xdr_dat "Table 58-1. NFS
    External Data Representation (XDR) Data Types") shows the data types defined by
    XDR, which can be used by NFS in exchanging data between the client and server.
    For each, I have included the data type code, its size in bytes, and a brief description.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 58-1. NFS External Data Representation (XDR) Data Types
  prefs: []
  type: TYPE_NORMAL
- en: '| Data Type Code | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| int | 4 | Signed integer: A 32-bit signed integer in two''s complement notation,
    capable of holding a value from -2,147,483,648 to +2,147,483,647. |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned int | 4 | Unsigned integer: A 32-bit unsigned integer, from 0 to
    4,294,967,295. |'
  prefs: []
  type: TYPE_TB
- en: '| enum | 4 | Enumeration: An alternate way of expressing a signed integer where
    some of the integer values are used to stand for particular constant values. For
    example, you could represent the colors of the rainbow, by defining the value
    1 to stand for PURPLE, 2 to stand for BLUE, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| bool | 4 | Boolean: A logical representation of an integer, analogous to
    a two-level enumeration where a value of 0 is defined as FALSE and 1 is TRUE.
    |'
  prefs: []
  type: TYPE_TB
- en: '| hyper | 8 | Signed hyper integer: Same as a regular signed integer, but 8
    bytes wide to allow much larger numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| unsigned hyper | 8 | Unsigned hyper integer: Same as a regular unsigned integer
    but 8 bytes wide to allow much larger numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| float | 4 | Floating-point number: A 32-bit signed floating-point number.
    1 bit holds the sign (positive or negative), 8 bits hold the exponent (power),
    in base 2, and 23 bits hold the mantissa (fractional part of the number). |'
  prefs: []
  type: TYPE_TB
- en: '| double | 8 | Double-precision floating-point number: The same as float but
    with more bits to allow greater precision. 1 bit is for the sign, 11 bits for
    the exponent, and 52 bits for the mantissa. |'
  prefs: []
  type: TYPE_TB
- en: '| quadruple | 16 | Quadruple-precision floating-point number: The same as float
    and double but with still more bits to allow greater precision. 1 bit is for the
    sign, 15 bits for the exponent, and 112 bits for the mantissa. |'
  prefs: []
  type: TYPE_TB
- en: '| opaque | Variable | Opaque data: Data that is to be passed between devices
    without being given a specific representation using XDR. The term *opaque* means
    that the data is treated like a "black box" whose insides cannot be seen. Obviously,
    any machines using this data type must themselves know how to deal with it, since
    NFS does not. |'
  prefs: []
  type: TYPE_TB
- en: '| string | Variable | String: A variable-length string of ASCII characters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| (array) | Variable | Arrays: A group of any single type of the elements above,
    such as integers, floating-point numbers, and so on, may be specified in an array
    to allow many to be referenced as a single unit. They are not indicated using
    a separate data type code. |'
  prefs: []
  type: TYPE_TB
- en: '| struct | Variable | Structure: An arbitrary structure containing other data
    elements from this table. This allows the definition of complex data types. |'
  prefs: []
  type: TYPE_TB
- en: '| union | Variable | Discriminated union: A complex data type where a code
    value called a "discriminant" is used to determine the nature of the rest of the
    structure. See section 3.14 of RFC 1014 for details. |'
  prefs: []
  type: TYPE_TB
- en: '| void | 0 | Void: A null data type that contains nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| const | 0 | Constant: A constant value used in other representations. |'
  prefs: []
  type: TYPE_TB
- en: As you can see, XDR provides considerable data description capabilities. If
    you know the C language, much of what is in [Table 58-1](ch58s04.html#nfs_external_data_representation_xdr_dat
    "Table 58-1. NFS External Data Representation (XDR) Data Types") is probably familiar
    to you. Unfortunately, I can't really describe many of the more complex data types
    without turning this into a guide to C programming.
  prefs: []
  type: TYPE_NORMAL
- en: XDR also provides a means of defining new data types and a method for specifying
    optional data. This offers even more flexibility beyond the large number of specific
    types already specifically described. Each version of NFS has a slightly different
    list of data types it supports.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Client/Server Operation Using Remote Procedure Calls (RPCs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all applications deal with files and other resources. When a software
    program on a particular computer wants to read a file, write a file, or perform
    related tasks, it needs to use the correct software instructions for this purpose.
    It would be inefficient to require each software program to contain a copy of
    these instructions, so instead, they are encoded as standardized software modules,
    sometimes called *procedures*. To perform an action, a piece of software *calls*
    the procedure. The procedure temporarily takes over for the main program and performs
    a task such as reading or writing data. The procedure then returns control of
    the program back to the software that called it, and optionally, returns data
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Since the key concept of NFS was to make remote file access look like local
    file access, it was designed around the use of a network-based version of this
    procedure calling method. A software application that wants to do something with
    a file still makes a procedure call, but it makes the call to a procedure on a
    different computer instead of the local one. A special set of routines is used
    to handle the transmission of the call across the network, in a way largely invisible
    to software performing the call.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality could have been implemented directly in NFS, but instead
    Sun created a separate session-layer protocol component called the *Remote Procedure
    Call (RPC)* specification, which defines how this works. RPC was originally created
    as a subcomponent of NFS, but it is generic enough and useful enough that it has
    been used for other client/server applications in TCP/IP. For this reason, it
    is really considered in many respects a distinct protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Because RPC is the actual process of communicating in NFS, NFS itself is different
    from many other TCP/IP protocols. Its operation can't be described in terms of
    specific message exchanges and state diagrams the way a protocol like HTTP or
    the Dynamic Host Configuration Protocol (DHCP), or even TCP can, because RPC does
    all of that. NFS is defined in terms of a set of RPC server procedures and operations
    that an NFS server makes available to NFS clients. These procedures and operations
    each allow a particular type of action to be taken on a file, such as reading
    from it, writing to it, or deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: RPC Operation and Transport Protocol Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a client wants to perform some type of action on a file on a particular
    machine, it uses RPC to make a call to the NFS server on that machine. The server
    accepts the request and performs the action required, then returns a result code
    and possibly data back to the client, depending on the request. The result code
    indicates if the action was successful. If it was, the client can assume that
    whatever it asked to be done was completed. For example, in the case of writing
    data, the client can assume the data has been successfully written to long-term
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** NFS does not use a dedicated message format, like most other
    protocols do. Instead, clients and servers use the *Remote Procedure Call (RPC)*
    protocol to exchange file operation requests and data.'
  prefs: []
  type: TYPE_NORMAL
- en: NFS can operate over any transport mechanism that has a valid RPC implementation
    at the session layer. NFS has seen an evolution of sorts in its use of transport
    protocol. The NFSv2 standard says that it operates normally using UDP, and this
    is still a common way that NFS information is carried. NFSv3 says that either
    UDP or TCP may be used, but NFSv4 specifies TCP to carry data. The nominal registered
    port number for use by NFS is 2049, but other port numbers are sometimes used
    for NFS, through the use of RPC's *port mapper* capability.
  prefs: []
  type: TYPE_NORMAL
- en: Client and Server Responsibilities in NFS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since UDP is unreliable, the use of that protocol to transport important information
    may seem strange. For example, we obviously don't want data that we are trying
    to write to a file to be lost in transit. Remember, however, that UDP doesn't
    preclude the use of measures to ensure reliable communications; it simply doesn't
    provide those capabilities itself. UDP can be used by NFS because the protocol
    itself is designed to tolerate loss of transmitted data and to recover from it.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent with this concept, the general design of NFS puts most of the responsibility
    for implementing the protocol on the client, not the server. As the NFSv3 standard
    says, "NFS servers are dumb, and NFS clients are smart." What this means is that
    the servers focus only on responding to requests, while clients must take care
    of most of the nitty-gritty details of the protocol, including recovery from failed
    communications. This is a common requirement when UDP is used, because if a client
    request is lost in transit, the server has no way of knowing that it was ever
    sent.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the NFS overview earlier in this chapter, NFS servers are designed
    to be stateless. In simplified terms, this means that the NFS server does not
    keep track of the state of the clients using it from one request to another. Each
    request is independent of the previous one, and the server in essence has no memory
    of what it did before when it gets a new command from a client. This again requires
    more intelligence to be put into the clients, but has the important advantage
    of simplifying recovery in the case that the server crashes. Since there is nothing
    that the server was keeping track of for the client, there's nothing that can
    be lost. This is an important part of ensuring that files are not damaged as a
    result of network problems or congestion.
  prefs: []
  type: TYPE_NORMAL
- en: Client and Server Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both NFS clients and servers can make use of caching to improve performance.
    Servers may use caching to store recently requested information in case it is
    needed again. They may also use *predictive* caching, sometimes called *prefetching*.
    In this technique, a server that receives a request to read a block of data from
    a file may load into memory the next block after it, on the theory that it will
    likely be requested next.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side caching is used to satisfy repeat NFS requests from applications
    while avoiding additional RPC calls. Like almost everything else about NFS, caching
    is implemented much more thoroughly in NFSv4 than in the previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** NFS is designed to be a stateless protocol, with intelligent
    clients and relatively dumb servers that respond to requests and do not maintain
    status information about what files are in use. NFS was originally designed to
    use UDP for transport, for efficiency purposes. This requires that NFS clients
    take care of detecting lost requests and retransmitting them. NFSv4 uses TCP to
    take advantage of TCP''s reliability and other features.'
  prefs: []
  type: TYPE_NORMAL
- en: NFS Server Procedures and Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual exchange of information between an NFS client and server is performed
    by the underlying RPC protocol. NFS functionality is therefore described not in
    terms of specific protocol operations, but by delineating the different actions
    that a client may take on files residing on a server. In the original version
    of NFS, NFSv2, these are called NFS *server procedures*.
  prefs: []
  type: TYPE_NORMAL
- en: Each procedure represents a particular action that a client may perform, such
    as reading from a file, writing to a file, or creating or removing a directory.
    The operations performed on the file require that the file be referenced using
    a data structure called a *file handle*. As the name suggests, the file handle,
    like the handle of a real object, lets the client and server "grasp" the file.
    The Mount protocol, described later in this chapter, is used to mount a file system,
    to enable a file handle to be accessed for use by NFS procedures.
  prefs: []
  type: TYPE_NORMAL
- en: NFSv3 uses the same basic model for server procedures, but makes certain changes.
    Two of the NFSv2 procedures were removed, and several new ones added to support
    new functionality. The numbers assigned to identify each procedure were also changed.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Version 2 and Version 3 Server Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 58-2](ch58s06.html#nfs_version__and_version__server_procedu "Table 58-2. NFS
    Version 2 and Version 3 Server Procedures") shows the server procedures defined
    in versions 2 and 3 of NFS. The table shows the procedure numbers for both NFSv2
    and NFSv3, as well as the name of each procedure and a description of what it
    does. I have kept the descriptions short so the table can serve as a useful summary
    of what NFS can do. They are listed in order of the procedure number used in NFSv2.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 58-2. NFS Version 2 and Version 3 Server Procedures
  prefs: []
  type: TYPE_NORMAL
- en: '| Procedure No. (v2) | Procedure No. (v3) | Procedure Name | Procedure Summary
    | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | null | Do nothing | Dummy procedure provided for testing purposes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | getattr | Get file attributes | Retrieves the attributes of a file
    on a remote server. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | setattr | Set file attributes | Sets (changes) the attributes of
    a file on a remote server. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | — | root | Get file system root (obsolete) | This procedure was originally
    defined to allow a client to find the root of a remote file system, but is now
    obsolete. This function is instead now implemented as part of the Mount protocol.
    It was removed in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3 | lookup | Look up filename | Returns the file handle of a file for
    the client to use. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | readlink | Read from symbolic link | Reads the name of a file specified
    using a symbolic link. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | read | Read from rile | Reads data from a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | — | writecache | Write to cache | Proposed for future use in NFSv2 but
    abandoned and removed from NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 7 | write | Write to file | Writes data to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 8 | create | Create file | Creates a file on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 12 | remove | Remove file | Deletes a file from the server. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 14 | rename | Rename file | Changes the name of a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 15 | link | Create link to file | Creates a hard (nonsymbolic) link
    to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 10 | symlink | Create symbolic link | Creates a symbolic link to a file.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 9 | mkdir | Create directory | Creates a directory on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 13 | rmdir | Remove directory | Deletes a directory. |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 16 | readdir | Read from directory | Reads the contents of a directory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | — | statfs | Get file system attributes | Provides to the client general
    information about the remote file system, including the size of the file system
    and the amount of free space remaining. In NFSv3, this was replaced by fsstat
    and fsinfo. |'
  prefs: []
  type: TYPE_TB
- en: '| — | 4 | access | Check access permission | Determines the access rights that
    a user has for a particular file system object. This is new in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| — | 11 | mknod | Create a special device | Creates a special file such as
    a named pipe or device file. This is new in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| — | 17 | readdirplus | Extended read from directory | Retrieves additional
    information from a directory. This is new in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| — | 18 | fsstat | Get dynamic file system information | Returns volatile
    (dynamic) file system status information such as the current amount of file system
    free space and the number of free file slots. This is new in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| — | 19 | fsinfo | Get static file system information | Returns static information
    about the file system, such as general data about how the file system is used
    and parameters for how requests to the server should be structured. This is new
    in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| — | 20 | pathconf | Retrieve POSIX information | Retrieves additional information
    for a file or directory. This is new in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: '| — | 21 | commit | Commit cached data on a server to stable storage | Flushes
    any data that the server is holding in a write cache to storage. This is used
    to ensure that any data that the client has sent to the server but that the server
    has held pending write to storage is written out. This is new in NFSv3. |'
  prefs: []
  type: TYPE_TB
- en: It is common that a client may want to perform multiple actions on a file, such
    as several consecutive reads. One of the problems with the server procedure system
    in NFSv2 and NFSv3 is that each client action required a separate procedure call.
    This was somewhat inefficient, especially when NFS was used over a high-latency
    link.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Version 4 Server Procedures and Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve the efficiency of server procedures, NFSv4 makes a significant change
    to the way that server procedures are implemented. Instead of each client action
    being a separate procedure, a single procedure, called a *compound procedure*,
    is defined. Within this compound procedure, a large number of *server operations*
    are encapsulated. These are all sent as a single unit, and the server interprets
    and follows the instructions in each operation in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This change means there are actually only two RPC procedures in NFSv4, as shown
    in [Table 58-3](ch58s06.html#nfs_version__server_procedures "Table 58-3. NFS Version
    4 Server Procedures").
  prefs: []
  type: TYPE_NORMAL
- en: Table 58-3. NFS Version 4 Server Procedures
  prefs: []
  type: TYPE_NORMAL
- en: '| Procedure Number | Procedure Name | Procedure Summary | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | null | Do nothing | Dummy procedure provided for testing purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | compound | Compound operations | Combines a number of NFS operations
    into a single request. |'
  prefs: []
  type: TYPE_TB
- en: All the real client actions are defined as operations within the compound procedure,
    as shown in [Table 58-4](ch58s06.html#nfs_version__server_operations "Table 58-4. NFS
    Version 4 Server Operations"). You'll notice that the number of NFSv4 operations
    is much larger than the number of procedures in NFSv2 and NFSv3\. This is due
    both to the added features in NSFv4 and the fact that it incorporates functions
    formerly performed by the separate Mount protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Table 58-4. NFS Version 4 Server Operations
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation Number | Operation Name | Operation Summary | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | access | Check access rights | Determines the access rights a user has
    for an object. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | close | Close file | Closes a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | commit | Commit cached data | Flushes any data that the server is holding
    in a write cache to storage, to ensure that any pending data is permanently recorded.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | create | Create a nonregular file object | This is similar to the mknod
    procedure in NFSv3; it creates a "nonregular" (special) object file. (Regular
    files are created using the open operation.) |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | delepurge | Purge delegations awaiting recovery | NFSv4 has a feature
    where a server may delegate to a client responsibility for certain files. This
    operation removes delegations awaiting recovery from a client. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | delegreturn | Return delegation | Returns a delegation from a client
    to the server that granted it. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | getattr | Get attributes | Obtains the attributes for a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | getfh | Get current file handle | Returns a file handle, which is a
    logical object used to allow access to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | link | Create link to a file | Creates a hard (nonsymbolic) link to
    a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | lock | Create lock | Creates a lock on a file. Locks are used to manage
    access to a file—for example, to prevent two clients from trying to write to a
    file simultaneously and thus corrupting it. |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | lockt | Test for lock | Tests for the existence of a lock on an object
    and returns information about it. |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | locku | Unlock lile | Removes a lock previously created on a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | lookup | Look up filename | Looks up or finds a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | lookupp | Look up parent directory | Returns the file handle of an object''s
    parent directory. |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | nverify | Verify difference in attributes | Checks to see if attributes
    have changed on a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | open | Open a regular file | Opens a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | openattr | Open named attribute directory | Opens an attribute directory
    associated with a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | open_confirm | Confirm open | Confirms information related to an opened
    file. |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | open_ downgrade | Reduce open file access | Adjusts the access rights
    for a file that is already open. |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | putfh | Set current file handle | Replaces one file handle with another.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | putpubfh | Set public file handle | Sets the current file handle to
    be the public file handle of the server. This may or may not be the same as the
    root file handle. |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | putrootfh | Set root file handle | Sets the current file handle to be
    the root of the server''s file system. |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | read | Read from file | Reads data from a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 26 | readdir | Read directory | Reads the contents of a directory. |'
  prefs: []
  type: TYPE_TB
- en: '| 27 | readlink | Read symbolic link | Reads the name of a file specified using
    a symbolic link. |'
  prefs: []
  type: TYPE_TB
- en: '| 28 | remove | Remove file system object | Removes (deletes) an object. |'
  prefs: []
  type: TYPE_TB
- en: '| 29 | rename | Rename directory entry | Changes the name of an object. |'
  prefs: []
  type: TYPE_TB
- en: '| 30 | renew | Renew a lease | Renews an NFS delegation made by a server. (Note
    that these leases have nothing to do with DHCP leases, which are discussed in
    [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS").)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 31 | restorefh | Restore saved file handle | Allows a file handle previously
    saved to be made the current file handle. |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | savefh | Save current file handle | Allows a file handle to be saved
    so it can later be restored when needed. |'
  prefs: []
  type: TYPE_TB
- en: '| 33 | secinfo | Obtain available security | Retrieves NFS security information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 34 | setattr | Set attributes | Changes one or more attributes of a file.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 35 | setclientid | Negotiate client ID | Allows a client to communicate information
    to the server regarding how the client wants to use NFS. |'
  prefs: []
  type: TYPE_TB
- en: '| 36 | setclientid_confirm | Confirm client ID | Used to confirm the results
    of a previous negotiation using setclientid. |'
  prefs: []
  type: TYPE_TB
- en: '| 37 | verify | Verify same attributes | Allows a client to verify certain
    attributes before proceeding with a particular action. |'
  prefs: []
  type: TYPE_TB
- en: '| 38 | write | Write to file | Writes data to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| 39 | release_lockowner | Release lock owner state | Used by a client to tell
    a server to release certain information related to file locks. |'
  prefs: []
  type: TYPE_TB
- en: '| 10044 | illegal | Illegal operation | A placeholder (dummy) operation used
    to support error reporting when an invalid operation is used in a request from
    a client. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** File operations in NFS are carried out using NFS *server procedures*.
    In versions 2 and 3 of NFS, each procedure performs one action, such as reading
    data from a file. In NFSv4, a special *compound* action is defined that allows
    many individual *operations* to be sent in a single request to a server.'
  prefs: []
  type: TYPE_NORMAL
- en: NFS File System Model and the Mount Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since NFS is used by a client to simulate access to remote directories of files
    as if they were local, the protocol must present the files from the remote system
    to the local user. Just as files on a local storage device are arranged using
    a particular file system, NFS uses a *file system model* to represent how files
    are shown to a user.
  prefs: []
  type: TYPE_NORMAL
- en: The NFS File System Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file system model used by NFS is the same one that most of us are familiar
    with: a hierarchical arrangement of directories that contain files and subdirectories.
    The top of the hierarchy is the *root*, which contains any number of files and
    first-level directories. Each directory may contain more files or other directories,
    allowing an arbitrary tree structure to be created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A file can be uniquely specified by using its *filename* and a *path name*
    that shows the sequence of directories one must traverse from the root to find
    the file. Since NFS is associated with UNIX, files in NFS discussions are usually
    shown in UNIX notation; for example, */etc/hosts*. The same basic tree idea can
    also be expressed using the method followed by Windows operating systems: *C:\WINDOWS\HOSTS*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Mount Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before NFS can be used to allow a client to access a file on a remote server,
    the client must be given a way of accessing the file. This means that a portion
    of the remote file system must be made available to the client, and the file opened
    for access. A specific decision was made when NFS was created to not put file
    access, opening, and closing functions into NFS proper. Instead, a separate protocol
    was created to work with NFS, so that if the method of providing file access needed
    to be changed later, it wouldn't require changes to NFS itself. This separate
    mechanism is called the *Mount protocol* and is described in Appendix A of RFC
    1094 (NFSv2). Note that while its functionally distinct, Mount is considered part
    of the overall NFS package.
  prefs: []
  type: TYPE_NORMAL
- en: When NFS was revised to version 3, the Mount protocol was similarly modified.
    The NFSv3 version of the Mount protocol is defined in Appendix I of RFC 1813 (NFSv3).
    It contains some changes to how the protocol works, but the overall operation
    of the two versions of Mount is pretty much the same.
  prefs: []
  type: TYPE_NORMAL
- en: The term *mount* is actually an analog to a hardware term that refers to making
    a physical storage volume available. In the past, storage devices were usually
    removable disk packs, and to use one, you mounted it onto a drive unit. In a similar
    manner, NFS resources are logically mounted using the Mount protocol, which makes
    the shared file system available to the client. A file can then be opened and
    a file handle returned to the NFS client, so it can reference the file for operations
    such as reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Versions 2 and 3 of NFS do not include procedures for opening
    or closing resources on a remote server. Before NFS tasks can be accomplished
    on these versions, the special *Mount* protocol must be employed to mount a file
    system and create a file handle to access a file on it. The protocol is also used
    to unmount the file system when no longer required. The Mount protocol is implemented
    in a manner similar to NFS itself, defining a sequence of procedures that use
    RPC and XDR. In NFSv4, the Mount protocol is no longer needed, because the tasks
    it performs have been implemented as NFSv4 operations.'
  prefs: []
  type: TYPE_NORMAL
- en: The actual implementation of the Mount protocol is very similar to that of NFS
    itself. Like NFS, the Mount protocol uses XDR to define data types to be exchanged
    between the client and server and RPC to define a set of server procedures that
    clients may use to perform different operations. The main difference between Mount
    and NFS is simply that Mount defines procedures related to opening and closing
    file systems, rather than file access operations. [Table 58-5](ch58s07.html#nfs_mount_protocol_server_procedures
    "Table 58-5. NFS Mount Protocol Server Procedures") shows the server procedures
    used in the Mount protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Table 58-5. NFS Mount Protocol Server Procedures
  prefs: []
  type: TYPE_NORMAL
- en: '| Procedure Number | Procedure Name | Procedure Summary | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | null | Do nothing | Dummy procedure provided for testing purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | mnt | Add mount entry | Performs a mount operation by mapping a path
    on a server to a file handle for the client to use. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | dump | Return mount entries | Returns a list of remotely mounted file
    systems. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | umnt | Remove mount entry | Performs an unmount operation by removing
    a mount entry. (Yes, it should be *dismount*; techies usually aren''t English
    majors.) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | umntall | Remove all mount entries | Removes all mount entries, thus
    eliminating all mounted file systems between server and client. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | export | Return export list | Returns a list of exported file systems
    and indicates which clients are allowed to mount them. This is used to let the
    client see which served file systems are available for use. |'
  prefs: []
  type: TYPE_TB
- en: Again, NFSv4 does away with the notion of a separate Mount protocol, incorporating
    file mounting operations into NFS directly.
  prefs: []
  type: TYPE_NORMAL
