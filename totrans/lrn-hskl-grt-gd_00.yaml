- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haskell is fun, and that’s what it’s all about!
  prefs: []
  type: TYPE_NORMAL
- en: This book is aimed at people who have experience programming in imperative languages—such
    as C++, Java, and Python—and now want to try out Haskell. But even if you don’t
    have any significant programming experience, I’ll bet a smart person like you
    will be able to follow along and learn Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: My first reaction to Haskell was that the language was just too weird. But after
    getting over that initial hurdle, it was smooth sailing. Even if Haskell seems
    strange to you at first, don’t give up. Learning Haskell is almost like learning
    to program for the first time all over again. It’s fun, and it forces you to think
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you ever get really stuck, the IRC channel *#haskell* on the freenode network
    is a great place to ask questions. The people there tend to be nice, patient,
    and understanding. They’re a great resource for Haskell newbies.
  prefs: []
  type: TYPE_NORMAL
- en: So, What's Haskell?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haskell is a *purely functional* programming language.
  prefs: []
  type: TYPE_NORMAL
- en: In *imperative* programming languages, you give the computer a sequence of tasks,
    which it then executes. While executing them, the computer can change state. For
    instance, you can set the variable `a` to 5 and then do some stuff that might
    change the value of `a`. There are also flow-control structures for executing
    instructions several times, such as `for` and `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Purely functional programming is different. You don’t tell the computer what
    to do—you tell it *what stuff is*. For instance, you can tell the computer that
    the factorial of a number is the product of every integer from 1 to that number
    or that the sum of a list of numbers is the first number plus the sum of the remaining
    numbers. You can express both of these operations as *functions*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802500.png)'
  prefs: []
  type: TYPE_IMG
- en: In functional programming, you *can’t* set a variable to one value and then
    set it to something else later on. If you say `a` is 5, you can’t just change
    your mind and say it’s something else. After all, you said it was 5\. (What are
    you, some kind of liar?)
  prefs: []
  type: TYPE_NORMAL
- en: In purely functional languages, a function has no *side effects*. The only thing
    a function can do is calculate something and return the result. At first, this
    seems limiting, but it actually has some very nice consequences. If a function
    is called twice with the same parameters, it’s guaranteed to return the same result
    both times. This property is called *referential transparency*. It lets the programmer
    easily deduce (and even prove) that a function is correct. You can then build
    more complex functions by gluing these simple functions together.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell is *lazy*. This means that unless specifically told otherwise, Haskell
    won’t execute functions until it needs to show you a result. This is made possible
    by referential transparency. If you know that the result of a function depends
    only on the parameters that function is given, it doesn’t matter when you actually
    calculate the result of the function. Haskell, being a lazy language, takes advantage
    of this fact and defers actually computing results for as long as possible. Once
    you want your results to be displayed, Haskell will do just the bare minimum computation
    required to display them. Laziness also allows you to make seemingly infinite
    data structures, because only the parts of the data structures that you choose
    to display will actually be computed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802502.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s look at an example of Haskell’s laziness. Say you have a list of numbers,
    `xs = [1,2,3,4,5,6,7,8]`, and a function called `doubleMe` that doubles every
    element and returns the result as a new list. If you want to multiply your list
    by 8, your code might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An imperative language would probably pass through the list once, make a copy,
    and then return it. It would then pass through the list another two times, making
    copies each time, and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: In a lazy language, calling `doubleMe` on a list without forcing it to show
    you the result just makes the program tell you, “Yeah yeah, I’ll do it later!”
    Once you want to see the result, the first `doubleMe` calls the second one and
    says it wants the result immediately. Then the second one says the same thing
    to the third one, and the third one reluctantly gives back a doubled 1, which
    is 2\. The second `doubleMe` receives that and returns 4 to the first one. The
    first `doubleMe` then doubles this result and tells you that the first element
    in the final resulting list is 8\. Because of Haskell’s laziness, the `doubleMe`
    calls pass through the list just once, and only when you really need that to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell is *statically typed*. This means that when you compile your program,
    the compiler knows which piece of code is a number, which is a string, and so
    on. Static typing means that a lot of possible errors can be caught at compile
    time. If you try to add together a number and a string, for example, the compiler
    will whine at you.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802504.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Haskell uses a very good type system that has *type inference*. This means that
    you don’t need to explicitly label every piece of code with a type, because Haskell’s
    type system can intelligently figure it out. For example, if you say `a = 5 +
    4`, you don’t need to tell Haskell that `a` is a number—it can figure that out
    by itself. Type inference makes it easier for you to write code that’s more general.
    If you write a function that takes two parameters and adds them together, but
    you don’t explicitly state their type, the function will work on any two parameters
    that act like numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell is *elegant and concise*. Because it uses a lot of high-level concepts,
    Haskell programs are usually shorter than their imperative equivalents. Shorter
    programs are easier to maintain and have fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell was made by some really smart guys (with PhDs). Work on Haskell began
    in 1987 when a committee of researchers got together to design a kick-ass language.
    The Haskell Report, which defines a stable version of the language, was published
    in 1999.
  prefs: []
  type: TYPE_NORMAL
- en: What You Need to Dive In
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In short, to get started with Haskell, you need a text editor and a Haskell
    compiler. You probably already have your favorite text editor installed, so we
    won’t waste time on that. The most popular Haskell compiler is the Glasgow Haskell
    Compiler (GHC), which we will be using throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to get what you need is to download the *Haskell Platform*. The
    Haskell Platform includes not only the GHC compiler but also a bunch of useful
    Haskell libraries! To get the Haskell Platform for your system, go to [http://hackage.haskell.org/platform/](http://hackage.haskell.org/platform/)
    and follow the instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: GHC can compile Haskell scripts (usually with an *.hs* extension), and it also
    has an interactive mode. From there, you can load functions from scripts and then
    call them directly to see immediate results. Especially when you’re learning,
    it’s much easier to use the interactive mode than it is to compile and run your
    code every time you make a change.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed the Haskell Platform, open a new terminal window, assuming
    you’re on a Linux or Mac OS X system. If your operating system of choice is Windows,
    go to the command prompt. Once there, type **`ghci`** and press enter to start
    the interactive mode. (If your system fails to find the GHCi program, you can
    try rebooting your computer.)
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve defined some functions in a script—for example, *myfunctions.hs*—you
    can load these functions into GHCi by typing `:l myfunctions`. (Make sure that
    *myfunctions.hs* is in the same folder from which you started GHCi.)
  prefs: []
  type: TYPE_NORMAL
- en: If you change the *.hs* script, run `:l myfunctions` to load the file again
    or run `:r`, which reloads the current script. My usual workflow is to define
    some functions in an *.hs* file, load it into GHCi, mess around with it, change
    the file, and repeat. This is what we’ll be doing in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to everyone who sent in corrections, suggestions, and words of encouragement.
    Also thanks to Keith, Sam, and Marilyn for making me look like a real writer.
  prefs: []
  type: TYPE_NORMAL
