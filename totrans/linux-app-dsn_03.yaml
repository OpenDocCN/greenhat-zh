- en: '![](../images/43-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[USING RUN-TIME ACCESS](toc.html#chapter3)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter gives you a practical introduction to developing Linux appliances
    with the RTA library. Consider this your “Hello, world!” example. In this chapter,
    we’ll discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • RTA appliance architecture
  prefs: []
  type: TYPE_NORMAL
- en: • RTA daemon architecture
  prefs: []
  type: TYPE_NORMAL
- en: • Telling RTA about your columns and tables
  prefs: []
  type: TYPE_NORMAL
- en: • Building your first RTA program
  prefs: []
  type: TYPE_NORMAL
- en: • A little SQL
  prefs: []
  type: TYPE_NORMAL
- en: • An introduction to RTA’s built-in tables
  prefs: []
  type: TYPE_NORMAL
- en: • The RTA table editor
  prefs: []
  type: TYPE_NORMAL
- en: '[**RTA Appliance Architecture**](toc.html#chapter3.1)'
  prefs: []
  type: TYPE_NORMAL
- en: You may recall from the last chapter that there were several reasons to put
    a well-defined protocol between the UI programs and the daemon. A protocol offers
    reduced complexity in both the UI and the daemon, gives access to the daemon while
    it is running, lets you work on and test the UIs and daemon independently, and
    helps improve security. The important requirements for the protocol are that the
    protocol’s data model matches your view of the data, that you don’t have to define
    or write the protocol yourself, and that the protocol will be available for most
    UI programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: The data model we use in this book is that of a database. Because we view our
    arrays of structures as tables of data, the UI programs (or *clients*) see the
    data in the daemon as data in a database. While the UI programs think they are
    dealing with a PostgreSQL database, they are, in fact, talking to the daemon.
    This arrangement results in an appliance architecture similar to that shown in
    Figure 3-1, in which a framebuffer UI uses the PostgreSQL C language binding in
    libpq.so; the web UI uses the PostgreSQL PHP binding in pgsql.so; and the test
    and debug UI uses the command line program psql.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/44-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A sample appliance using RTA*'
  prefs: []
  type: TYPE_NORMAL
- en: After connecting to the daemon over a Unix or TCP socket, the UIs shown in Figure
    3-1 can display the configuration, status, and statistics available in the daemon.
    The librtadb.so library presents the daemon’s data as if it were coming from a
    PostgreSQL database. This figure shows the PostgreSQL client-side binding that
    we use in this book, but many more language bindings are available including Java,
    Python, Tcl, Perl, and Microsoft C++.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3-1 offers a global view of the appliance. Now let’s look at how RTA
    works inside the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: '[**RTA Daemon Architecture**](toc.html#chapter3.2)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding RTA to your daemon is fairly straightforward, since it usually involves
    using only two routines from the library. The first routine, rta_add_table(),
    makes one of your daemon’s tables visible to the clients. The second routine,
    dbcommand(), handles the protocol and SQL commands from the clients. Figure 3-2
    illustrates a daemon offering RTA access to two UI-visible tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/45-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: A daemon using RTA*'
  prefs: []
  type: TYPE_NORMAL
- en: The dbcommand() routine does not communicate directly with the client. Your
    program must create a listening TCP or Unix socket and must be able to accept
    and manage connections from the UI or other clients. Once a connection is established,
    all data from the connection should be passed to RTA with a call to dbcommand().
    The dbcommand() routine parses the SQL command in the request from the client;
    if the request is valid, it executes the SQL command and returns a buffer with
    any data to be sent back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: RTA would be of limited usefulness if all it could do was read and write values
    in your tables. Its real power lies in its ability to call a routine when ever
    a UI reads or writes a value into one of your tables. These read and write *callbacks*
    are similar to traditional database triggers. Callbacks are tied to the column
    definition and are specified separately for reads and writes. (We describe callbacks
    in the more detail in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: '[**Telling RTA About Your Columns and Tables**](toc.html#chapter3.3)'
  prefs: []
  type: TYPE_NORMAL
- en: A table is an array or linked list of data structures. Each member of your data
    structure is considered to be a column in a table, and each instance of the data
    structure is considered to be a row. From this point on, when you see the term
    *column*, think *member of my data structure*. In order to make a table visible
    to clients, you need to describe the table in a way that RTA can understand. This
    means describing the table as a whole and then describing each column in the table.
  prefs: []
  type: TYPE_NORMAL
- en: A TBLDEF structure describes the table as a whole; it contains a pointer to
    an array of column definitions with a COLDEF structure to define each column in
    your data table. At first you may find the process of creating COLDEFs and TBLDEFs
    painstaking and tedious, but once you have a little experience, you’ll find it
    simple and mechanical.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Columns***](toc.html#chapter3.4)'
  prefs: []
  type: TYPE_NORMAL
- en: One big advantage of RTA is that you don’t need to marshal the data into and
    out of the protocol. RTA uses your data as it already exists in your program.
    Of course, you have to describe your data so that RTA can access it intelligently.
    A table is made up of columns, and we need to describe each column in the table.
    This is the purpose of RTA’s COLDEF data structure.
  prefs: []
  type: TYPE_NORMAL
- en: You can also have members in your data structure that are not defined by a COLDEF.
    Such hidden columns might include information that you do not want to be visible
    to the UIs, or binary data that would have no meaning if it was displayed to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: A COLDEF contains nine pieces of information about each of your structure’s
    members.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/46-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**table**'
  prefs: []
  type: TYPE_NORMAL
- en: The table field specifies the name of the table as seen from the UI programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**name**'
  prefs: []
  type: TYPE_NORMAL
- en: The name field specifies the name of the column. Use this name when selecting
    or updating this column.
  prefs: []
  type: TYPE_NORMAL
- en: '**type**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the column is used for syntax checking and for SQL SELECT output
    formatting. The currently defined types include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/46-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**length**'
  prefs: []
  type: TYPE_NORMAL
- en: RTA uses the native compiler data types in order to match the data types you
    use in your structures. The length member is ignored for integers, longs, floats,
    and their associated pointer types, but it has meaning for strings and pointers
    to strings, both of which should report the number of bytes in the string (including
    the terminating null).
  prefs: []
  type: TYPE_NORMAL
- en: '**offset**'
  prefs: []
  type: TYPE_NORMAL
- en: The offset is the number of bytes from the start of the data structure to the
    structure member being described. For example, a table using a data structure
    with an int, a 20-character string, and a long would have the offset to the long
    set to 24 (assuming it was a 4-byte int).
  prefs: []
  type: TYPE_NORMAL
- en: Computing the offset of a structure member is painstaking and error prone. The
    gcc compiler suite provides the offsetof() macro to automatically compute the
    offset of the structure member.
  prefs: []
  type: TYPE_NORMAL
- en: '**flags**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A column has two binary attributes that are specified by the flags member.
    The first attribute specifies whether the column can be overwritten or if it is
    read-only. Statistics are often marked as read-only. An error is generated if
    a column marked as read-only is the subject in an UPDATE statement. The #define
    for this attribute is RTA_READONLY.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second attribute specifies whether or not values written to this column
    should be saved in a configuration file associated with the table. Values that
    should persist from one invocation of the program to the next should be marked
    with the #define RTA_DISKSAVE attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The flags field is the bitwise OR of RTA_DISKSAVE and RTA_READONLY.
  prefs: []
  type: TYPE_NORMAL
- en: '**readcb()**'
  prefs: []
  type: TYPE_NORMAL
- en: If defined, the *read callback* routine, readcb(), is called every time the
    column’s value is used. This is handy for values that take lots of CPU cycles
    to compute but that are used infrequently. A read callback is invoked each time
    the column is referenced—if your SQL statement uses the column name twice, the
    read callback is called twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The read callback is passed five parameters: the table name, the column name,
    the text of the SQL request, a pointer to the row affected, and the zero-indexed
    row number. A function prototype for a read callback is shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: int readcb(char *tbl, char *col, char *sql, void *pr, int rowid);
  prefs: []
  type: TYPE_NORMAL
- en: A read callback returns zero on success and an error code if an error occurred
    in the callback. (See Appendix A for a list of the error codes and more details
    on callbacks.) Check the return value in your clients in order to enhance reliability
    and security.
  prefs: []
  type: TYPE_NORMAL
- en: '**writecb()**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write callbacks* can be the real engine driving your application. If defined,
    the write callback, writecb(), is called after all columns in an UPDATE have been
    changed. Consider the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ifcfg SET addr="192.168.1.1", mask = "255.255.255.0";
  prefs: []
  type: TYPE_NORMAL
- en: If there is a write callback on addr, it will be called after both addr and
    mask have been updated. RTA does the write callback after all the fields have
    updated in order to help maintain consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write callbacks are passed six parameters: the table name, the column name,
    the text of the UPDATE statement, a pointer to the row affected, the zero-indexed
    row number, and a pointer to a copy of the row before any changes were made. (This
    last parameter is useful when you want to know both the old and new values for
    the row.) The copy of the old row is in dynamically allocated memory, which is
    freed after the write callback returns. A function prototype for a write callback
    is shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: int writecb(char *tbl, char *col, char *sql, void *pr, int rowid, void *poldrow);
  prefs: []
  type: TYPE_NORMAL
- en: The write callback returns zero on success and nonzero on failure. On failure,
    the row is restored to its initial value and an SQL error, TRIGGERED ACTION EXCEPTION,
    is returned to the client. Write callbacks allow you to enforce consistency and
    can provide security checks for your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**help**'
  prefs: []
  type: TYPE_NORMAL
- en: Your help text for the column should include a description of how the column
    is used, any limits or constraints on the column, and the side effects caused
    by any read or write callbacks. (Give yourself and your fellow developers meaningful
    help text for your columns to make it easier to maintain and troubleshoot your
    code.)
  prefs: []
  type: TYPE_NORMAL
- en: '[***Tables***](toc.html#chapter3.5)'
  prefs: []
  type: TYPE_NORMAL
- en: You tell RTA about each of your tables with a call to the RTA routine rta_add_table().
    The single parameter to rta_add_table() is a pointer to a TBLDEF structure that
    describes the table.
  prefs: []
  type: TYPE_NORMAL
- en: The TBLDEF structure uses 10 pieces of information to describe your table. The
    most critical of these are the name of the table, the start address of the array
    of structures, the width of each structure (that is, the width of each row), the
    number of rows, and a pointer to an array of COLDEF structures that describe the
    columns in the table. Most of the fields in the TBLDEF structure should be self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/48-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/49-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**savefile**'
  prefs: []
  type: TYPE_NORMAL
- en: The need to save configuration data from one boot of the appliance to the next
    is so common that the authors of RTA included the ability to automatically save
    table data in a file when the data is updated. There is one file per table, and
    the name of the file is specified in the TBLDEF structure as the savefile string.
    You can mark the columns to save by adding the RTA_DISKSAVE flag to the column
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: The save file contains a list of UPDATE statements, one for each row in the
    table. The save file is read from the disk and applied to the table when you initialize
    the table with the rta_add_table() call. The combination of RTA_DISKSAVE on a
    column and a savefile for the table eliminates the need to parse XML or INI files
    to get initial or saved configuration values. Of course, you can use XML or INI
    if you prefer to—just set the savefile pointer to a null.
  prefs: []
  type: TYPE_NORMAL
- en: '**iterator**'
  prefs: []
  type: TYPE_NORMAL
- en: An *iterator* is a subroutine in your code that steps through a linked list
    or other arrangement of the rows in your table. The iterator lets you treat a
    linked list, a B-tree, or just about any other scheme for organizing data as if
    the data was in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iterator function is called with three parameters: a pointer to the current
    row, the void pointer it_info from the TBLDEF, and the zero-indexed row number.
    The function returns a pointer to the next row. When RTA asks for the first row,
    the current row pointer is NULL, and the desired row index is zero. The function
    should return a NULL when RTA asks for the row after the last row in the list.
    If an iterator is defined, the address and nrows members in the TBLDEF are ignored.
    Here is its function prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: void iterator(void *cur_row, void *it_info, int rowid);
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one caveat when using iterator functions: Loading a save file may
    fail if you have not already allocated all the links in the linked list. (Remember,
    the save file is a list of UPDATE statements and expects the rows to already exist.)
    Fortunately, there is a simple way around this problem. Always keep one unused
    row available, and when that row is written by an UPDATE statement, have a write
    callback allocate another row so that you can stay one step ahead of the UPDATEs.
    The logmuxd program presented in Chapter 7 uses this technique.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Building Your First RTA Program**](toc.html#chapter3.6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll look at how to use RTA to expose a table inside a running program.
    The five basic steps for doing so are:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reviewing the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing RTA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and linking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[***Defining the Problem***](toc.html#chapter3.7)'
  prefs: []
  type: TYPE_NORMAL
- en: We want to expose the UI program to an array of structures that contain a user-editable
    string and two integers. One of the integers, *zalarm*, is set by the user. The
    other, *zcount*, is incremented on each transition of zalarm from one to zero
    or from zero to one. We print a message to the console each time a transition
    occurs. The string, *zname*, is considered a configuration value and is saved
    in a disk file whenever it is updated. Since zcount is a statistic, we mark it
    as read-only. This sample problem is a precursor to the actual Laddie appliance
    application presented in Chapter 5\. The code presented below is also available
    in the file myapp.c on this book’s companion CD.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Reviewing the Code***](toc.html#chapter3.8)'
  prefs: []
  type: TYPE_NORMAL
- en: This code walk-through should give you an idea of what to expect in RTA-enabled
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Includes, Defines, and Memory Allocation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/50-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/51-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The transitions of zalarm are detected in a write callback. Here, ![](../images/1.jpg)
    is the forward reference for it.
  prefs: []
  type: TYPE_NORMAL
- en: We need to allocate buffers for the text of the SQL command from the client
    and for the response returned to the client. At ![](../images/2.jpg) we are using
    500 and 5,000 bytes, respectively. These values are chosen to hold the largest
    possible SQL statement we expect to use and the largest possible result we expect
    to get back.
  prefs: []
  type: TYPE_NORMAL
- en: The structure definition at ![](../images/3.jpg) is the heart of the application’s
    data. Each instance of this data structure looks like a row in a database to the
    various UIs and clients.
  prefs: []
  type: TYPE_NORMAL
- en: We see at ![](../images/4.jpg) that our table has five rows in it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Column Definitions**'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the array of COLDEFs that define the columns in our table. The information
    in the COLDEFs is derived from the data structure we want to make visible and
    from our problem statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/51-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note ![](../images/1.jpg) the definition of the zedgedetect write callback in
    the COLDEF above. We do the transition detection of zalarm in this callback.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/52-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table Defin it ion**'
  prefs: []
  type: TYPE_NORMAL
- en: In the TBLDEF we give the name of the table, its start address, the size of
    each row, the number of rows, a pointer to the table of COLDEFs for this table,
    and the number of columns in the table. The save file, /tmp/zsave.sql, will be
    used to save the RTA_DISKSAVE columns, which, in this case, is only the name column.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/52-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**main() Routine**'
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty standard code. We allocate our socket structures and other local
    variables, then we initialize the table values and use rta_add_table() to tell
    RTA about our table.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/52-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/53-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Setting Up a Listening Socket**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that each UI program treats our application as if it were a PostgreSQL
    database, and we have to accept either Unix or TCP connections from these clients.
    Therefore, as the final piece of initialization, we set up the socket to listen
    for incoming client connections. Our program is listening on TCP port 8888, so
    we need to tell our PostgreSQL clients to use this port.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The following code has some serious shortcomings (i.e., blocking I/O, ignoring
    error conditions, and making optimistic assumptions about socket I/O). Our goal,
    however, is to make the code understandable by keeping it as short as possible.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/53-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/54-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ![](../images/1.jpg) read() call above uses blocking I/O. In a real application
    we would want to accept the connection and use a select() or poll() to multiplex
    for us. However, in this example we are trying keep the line count low.
  prefs: []
  type: TYPE_NORMAL
- en: '**dbcommand() Call**'
  prefs: []
  type: TYPE_NORMAL
- en: The following call is where the real work of RTA occurs. We pass the SQL command
    read from the client into the RTA library which parses it, verifies it, executes
    it, and fills outbuf with the result. We switch on the result of the dbcommand()
    call to see if we should send the result back to the client or close the connections.
    Under normal circumstances, the PostgreSQL client will do an orderly close and
    the dbcommand() call will return RTA_CLOSE.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/54-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Write Callback**'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the subroutine that is called after a UI/client program has set the
    zalarm column. A typical SQL command for this update would be UPDATE ztable SET
    zalarm = 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When first learning to use callbacks, you might want to add a print statement
    to the callback to display the table, column, input SQL, and row number.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/54-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/55-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A transition is detected by comparing the old value of zalarm with the new value.
    Both old and new values of the row are passed into the routine as parameters.
    We always return success in this example.
  prefs: []
  type: TYPE_NORMAL
- en: return(0); /* always succeeds */ }
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a reminder, if the write callback returns a nonzero value, the row affected
    is restored to its old value and the client program receives an error result from
    the SQL command that it sent.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Installing RTA***](toc.html#chapter3.9)'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a copy of the RTA package on this book’s companion CD and on the
    RTA project website ([http://librta.org](http://librta.org)). Check the website
    for the latest version. The SQL parser in RTA is written using yacc and lex, so
    your development system will need to have both installed if you build RTA from
    its source code.
  prefs: []
  type: TYPE_NORMAL
- en: The default installation of RTA puts the .a and .so libraries into the /usr/local/lib
    directory. If you do not want to use /usr/local/lib, you can edit the makefile
    before performing the install.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded the RTA package, extract the files and build the library.
    The sample code below shows you how.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/55-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***Building and Linking***](toc.html#chapter3.10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a test directory under rta-X.Y.Z and copy myapp.c to it. Next, build
    the application with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: gcc myapp.c -o myapp -L/usr/local/lib -lrtadb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the application, we tell the system where to find the RTA
    libraries at runtime. You can edit /etc/ld.so.conf and run ldconf ig or export
    the LD_LIBRARY_PATH environment variable. If the compile succeeded, you should
    be able to run the application with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: export LD_LIBRARY_PATH=/usr/local/lib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ./myapp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s it! Your sample application should be up and running and ready to respond
    to PostgreSQL requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Testing***](toc.html#chapter3.11)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section we assume you have installed PostgreSQL from your Linux distribution
    or from the version included on this book’s companion CD, and that the psql command
    is somewhere on your path. If all has gone well, you should now have an application
    running which pretends to be a PostgreSQL database server. Instead of a database,
    however, our sample application is offering up its internal table for use by various
    PostgreSQL clients. The client we will be using first is the command line tool,
    psql.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming everything is in order, open another terminal window and start psql,
    specifying the host and port of the database server as follows. (Remember that
    we told our application to listen on port 8888.)
  prefs: []
  type: TYPE_NORMAL
- en: psql -h localhost -p 8888
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PostgreSQL should respond with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/56-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/57-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If your SQL command did not display the above table, you need to debug the RTA
    installation. The most common problem is a version mismatch in the PostgreSQL
    protocol between the client and RTA. The psql client may give a warning, but it
    is fairly forgiving of using a newer client with an older server. This may be
    the case if you are using the very latest psql client.
  prefs: []
  type: TYPE_NORMAL
- en: Check the RTA website to see if your version of RTA is compatible with your
    version of PostgreSQL. If there is a mismatch, update either RTA or PostgreSQL.
    This book’s companion CD contains versions of the RTA and PostgreSQL libraries
    that are known to be compatible. You can also do a netstat -natp to verify that
    the application is really listening on port 8888.
  prefs: []
  type: TYPE_NORMAL
- en: Before dropping into the tutorial on SQL, let’s try a couple of commands just
    to see how the application responds.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zalarm = 1;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UPDATE 5
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: This should cause a *transition* message to be printed on the console where
    you started myapp. (Note that psql responds with the number of rows changed, and
    because we did not specify which row to change, all five rows were updated.)
  prefs: []
  type: TYPE_NORMAL
- en: Now issue the same command a second time.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zalarm = 1;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UPDATE 5
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: There should be no message printed to the console, since this time there was
    no transition.
  prefs: []
  type: TYPE_NORMAL
- en: Setting zalarm back to zero should cause a transition, and the count of transitions
    should now be 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/58-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you first started ./myapp, the saved table configuration file, /tmp/zsave.sql,
    did not exist. Create it by doing an update on a column that is marked as RTA_DISKSAVE.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "row name";
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UPDATE 5
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the above by doing a cat on /tmp/zsave.sql. You should see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 0
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 1
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 2
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 3
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "row name" LIMIT 1 OFFSET 4
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this section on RTA, let’s generate some errors and look at the
    corresponding error messages.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zcount = 0;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ERROR: Can not update read-only column ''zcount'''
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "abcdefghijklmnopqrstuvwxyz";
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ERROR: String too long for ''zname'''
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: '[**A Little SQL**](toc.html#chapter3.12)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Structured Query Language is a standard way to manipulate data in a database.
    RTA uses only two SQL commands: SELECT, to get data from a table, and UPDATE,
    to write data to a table. The RTA syntax for SELECT and UPDATE is a limited subset
    of the standard SQL syntax, with one minor extension.'
  prefs: []
  type: TYPE_NORMAL
- en: '[***SELECT***](toc.html#chapter3.13)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SELECT statement reads values out of a table. The syntax for the RTA SELECT
    statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT column_list FROM table [where_clause] [limit_clause]
  prefs: []
  type: TYPE_NORMAL
- en: The column_list is a comma-separated list of column names or a single asterisk
    (*) to retrieve all columns. The variable table is the name of the table you wish
    to examine. The where_clause specifies which rows to return, and the limit_clause
    tells how many rows to return. Here are some simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM ztable
  prefs: []
  type: TYPE_NORMAL
- en: select * from ztable
  prefs: []
  type: TYPE_NORMAL
- en: SELECT zcount, zname FROM ztable
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the columns in any order, and you can ask for the same column
    more than once.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The SQL parser recognizes the SQL reserved words in both upper- and lowercase
    letters. We use uppercase in our examples to make the reserved words more visible.*'
  prefs: []
  type: TYPE_NORMAL
- en: Also, SQL does not require a semicolon at the end of the line, but the psql
    command line tool does.
  prefs: []
  type: TYPE_NORMAL
- en: '[***UPDATE***](toc.html#chapter3.14)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UPDATE statement writes values into a table. The syntax for the RTA UPDATE
    statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE table SET update_list [where_clause] [limit_clause]
  prefs: []
  type: TYPE_NORMAL
- en: 'The update_list is a comma-separated list of value assignments in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: column_name = value[, column_name = value...]
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, value is a literal value. Let’s look at some more examples.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zalarm = 44
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zalarm = 0, zname = Terminator
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zalarm = *1,* zname = "Mr. Terminator"
  prefs: []
  type: TYPE_NORMAL
- en: Strings with spaces must be enclosed in either single or double quotes. One
    kind of quote can be enclosed in the other kind of quote.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Baker's Pride"
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = 'Just say "no"'
  prefs: []
  type: TYPE_NORMAL
- en: '[***WHERE***](toc.html#chapter3.15)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A WHERE clause specifies which rows to select or update, based on the data
    in the rows. WHERE might be the single biggest reason to use SQL. The form of
    the WHERE clause is:'
  prefs: []
  type: TYPE_NORMAL
- en: col_name rel_op value [AND col_name rel_op value ...]
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported comparison operators are equality, inequality, greater than,
    less than, greater than or equal to, and less than or equal to. Only logical AND
    is available to link column comparisons, and value must refer to a literal value.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM ztable WHERE zalarm != 0
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zalarm = 1 WHERE zname = "Front Door"
  prefs: []
  type: TYPE_NORMAL
- en: '[***LIMIT***](toc.html#chapter3.16)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LIMIT clause can limit the number of rows selected to limit rows, and can
    specify that the first OFFSET rows be ignored. The form of the LIMIT clause is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[LIMIT limit [OFFSET offset]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal SQL does not support the idea of “give me only the third row,” but this
    functionality is important if you’re trying to manage an embedded application.
    The LIMIT and OFFSET clauses let you specify exactly how many rows should be returned
    and how many candidate rows to ignore before starting the read or write. If there
    is a WHERE clause, the offset and limit apply only to the rows that match the
    WHERE conditions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Front Door" LIMIT 2
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Back Door" LIMIT 3 OFFSET 2
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zalarm = 1 LIMIT 2 OFFSET 1
  prefs: []
  type: TYPE_NORMAL
- en: SELECT zname FROM ztable LIMIT 4
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM ztable WHERE zalarm = 1 LIMIT 1
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A great way to step through a table one row at a time is to set LIMIT to 1
    and increment OFFSET from 0 up to one less than the number of rows.*'
  prefs: []
  type: TYPE_NORMAL
- en: You may remember that we said that we stored RTA_DISKSAVE columns in the save
    file given in the table definition, and that we wanted to store the configuration
    as SQL commands so that we could run it through the SQL parser. You can see a
    good example of the LIMIT clause and of save files by looking at /tmp/zsave.sql.
  prefs: []
  type: TYPE_NORMAL
- en: cat /tmp/zsave.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 0
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Front Door" LIMIT 1 OFFSET 1
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Garage" LIMIT 1 OFFSET 2
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 3
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE ztable SET zname = "Back Door" LIMIT 1 OFFSET 4
  prefs: []
  type: TYPE_NORMAL
- en: Real SQL purists reading this are probably pounding the table with their shoe
    and shouting, “Where’s ORDER_BY and INSERT and DELETE . . . and . . . and . .
    . ?” They are not there. Remember, RTA is *not* a database—it is an interface.
    We only need SELECT and UPDATE.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Introduction to RTA’s Built-in Tables**](toc.html#chapter3.17)'
  prefs: []
  type: TYPE_NORMAL
- en: The RTA library has several built-in tables. Appendix A has the full details,
    so we will introduce them here. The first table has only one row.
  prefs: []
  type: TYPE_NORMAL
- en: '[***rta_dbg***](toc.html#chapter3.18)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rta_dbg table lets you control how and what is logged. You can turn on
    tracing of all SQL by setting trace to 1, and you can direct log messages to neither,
    syslog, stderr, or both by setting target to 0, 1, 2, or 3, respectively. You
    can also specify the priority, facility, and ident values for syslog(). From psql
    we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/61-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***rta_stat***](toc.html#chapter3.19)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_stat table holds statistics related to the calls into RTA. It contains
    counts of the different types of errors, how many connections have been opened
    into RTA, and the number of SELECTs and UPDATEs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/61-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***rta_tables***](toc.html#chapter3.20)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta _tables metatable is a collection of table definition structures. In
    order to add a table into RTA, you had to fill in a data structure with a description
    of your table. The collection of table definition structures is itself a table
    in RTA. This is one of the RTA metatables.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/62-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The two RTA metatables have zero in the address field because they are actually
    an array of pointers, so they use an iterator function. All of the columns in
    the metatables are marked read-only, since all of the values are set from the
    rta_add_table() call.
  prefs: []
  type: TYPE_NORMAL
- en: '[***rta_columns***](toc.html#chapter3.21)'
  prefs: []
  type: TYPE_NORMAL
- en: The rta_columns metatable is a collection of column definitions. All of the
    column definitions from all of the tables are collected into the rta_columns table.
    (The table actually holds pointers to the COLDEF structures.) We can see what
    columns are in a table using the metatables and a WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/62-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What do you suppose we would get if we combined the RTA metatables with PHP?
    Read on.
  prefs: []
  type: TYPE_NORMAL
- en: '[**The RTA Table Editor**](toc.html#chapter3.22)'
  prefs: []
  type: TYPE_NORMAL
- en: The RTA package has a web/PHP-based utility called a *table editor* that reads
    the RTA metatables and lets you view and edit any table in the system. Figure
    3-3 shows the screen that lets you choose which table to view or edit. The screenshots
    in Figures 3-3, 3-4, and 3-5 were taken from our development system while we were
    working on the myapp.c application. You can see a similar screen by booting this
    book’s companion CD and using the browser on another PC to view [http://192.168.1.11/rta/rta_tables.php?port=8885](http://192.168.1.11/rta/rta_tables.php?port=8885).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/63-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: The RTA Table Editor*'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a table from the top screen opens a web page with the contents of
    the selected table. Figure 3-4 shows a display of the example program’s ztable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/63-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: A sample table display*'
  prefs: []
  type: TYPE_NORMAL
- en: You can select a row to edit from the table display. Figure 3-5 shows the view
    after selecting row number 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/64-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: A sample row edit screen*'
  prefs: []
  type: TYPE_NORMAL
- en: The RTA table editor has one HTML file and four PHP files that can be put on
    any PHP-enabled webserver. In fact, the webserver does not even need to run on
    the same machine as the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML file contains a list of the RTA port numbers in use. You will have
    a different port number for each RTA-enabled application that you run. On our
    development machine, we have an HTML table with port numbers and RTA application
    names that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/64-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**Summary**](toc.html#chapter3.23)'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has presented the details of how to build your application using
    RTA so that several different types of UI programs can manage it. You’ve seen
    that you need to tell RTA about the data structures you want to make visible by
    describing them with TBLDEFs and COLDEFs.
  prefs: []
  type: TYPE_NORMAL
- en: While all this may seem a little overwhelming at first, stick with it. After
    just a little practice, you’ll find that writing TBLDEFs and COLDEFs is straightforward
    and mostly mechanical. The extra effort to add RTA to your daemon is more than
    compensated by having run-time access to configuration, status, and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/66-1.jpg)'
  prefs: []
  type: TYPE_IMG
