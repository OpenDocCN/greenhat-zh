- en: Part II. Safe Harbor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*On the threats that lurk in between the computer and the Internet*'
  prefs: []
  type: TYPE_NORMAL
- en: —
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Blinkenlights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where we conclude that pretty can also be deadly, and we learn to read from
    LEDs*'
  prefs: []
  type: TYPE_NORMAL
- en: —
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this book focused on various problems related to the design
    of the data entry point system. Those problems were limited to deducing input
    by observing seemingly unrelated behavioral patterns by a user with local access
    to a system. But as information moves farther down its path to the addressee and
    leaves this system, its exposure broadens, and problems become more tangible.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this book focuses on some of the problems that occur while
    the data remains within reach, but just after it leaves the originating system-—moments
    before it enters the Internet. The exposure discussed here is limited to roughly
    the physical footprint of a local area network with its direct surroundings. An
    attack at this level requires an observation point that is local to the origin,
    but it does not require system-level access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific problem discussed in this chapter is somewhat different from those
    discussed previously: the exposure now manifests at the hardware level, much like
    in TEMPEST, but is different. The beauty of this phenomenon, and the ease of observing
    it with no specialized equipment, more than justify giving it a closer look.'
  prefs: []
  type: TYPE_NORMAL
- en: The Art of Transmitting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The need for computers to communicate with other electronic devices has been
    apparent since the beginning of practical computing, as has the difficulty of
    achieving this task reliably and on a budget. We can control the machine’s internal
    communication by providing generous and custom-fit interfaces among all major
    components with a desired capacity, maintaining precise signal characteristics,
    and using a common reference clock for all operations, so that the recipient always
    knows when to listen, and the sender always knows when to transmit data. But communication
    over longer distances or to devices equipped with nonspecialized, cheap interfaces
    is a different challenge: the computer is forced to communicate over a medium
    that usually does not allow for the degree of freedom we have grown accustomed
    to working with on the insides of a single machine.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the situation is quite the opposite. The customer expects simple, convenient,
    practical, and cheap solutions, and requiring computers to be connected through
    a $100, 3-inch, 100-wire cable didn’t seem like a winning solution. Simplicity
    is a necessity. The core of any external communication channel almost always relies
    on the serial transmission of subsequent bits that only when reassembled and grouped
    together produce numeric values, text strings, or other pieces of data native
    to the machine environment of the sender or recipient. In the most seemingly trivial
    and obvious scenario, when two machines or devices connected only by a pair of
    wires need to exchange information, they do so by setting one of the wires to
    high or low voltage in relation to the other (reference) line—or by using any
    other differing signals or states, for that matter. They do so in order to send
    subsequent bits of data at a given frequency—a frequency that must be kept reasonably
    close and in sync on both devices.
  prefs: []
  type: TYPE_NORMAL
- en: Even in such a trivial design, a number of problems immediately arise. First,
    the devices do not share a reference clock. Although both have internal quartz-based
    clocks, no two affordable clocks are ever accurate enough to maintain reliable
    and fast communications over an extended period of time due to slight manufacturing
    imperfections, interference, and other physical conditions. And serial communications
    demand precise synchronization. The straightforward bit-encoding scheme, usually
    referred to as Non-Return to Zero (NRZ), simply outputs one signal (voltage) for
    0 and another signal for 1\. In such a system, it is easy to keep both endpoints
    synchronized when values change on a regular basis—the system simply needs to
    detect a falling or rising edge, use it as a rough reference, and adjust its own
    clock accordingly. But given a longer sequence of 1s or 0s, it becomes difficult
    for the receiving side to accurately determine how many bits are being sent. In
    fact, even a small clock drift can cause problems, and there is no way to compensate
    for this during the exchange of a constant sequence of bits.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious solution, to simply interleave the data with a separate, distinguishable
    timing signal, is not always the most convenient and efficient method; increased
    complexity and reduced throughput is often perceived as a nuisance.
  prefs: []
  type: TYPE_NORMAL
- en: To effectively address this problem, many systems use a scheme called *Manchester
    encoding*, also known as *biphase code*. The algorithm for Manchester coding,
    shown along with NRZ in [Figure 5-1](ch05.html#serial_line_transmission_encodingsmnrz_a
    "Figure 5-1. Serial line transmission encodings—NRZ and biphase (Manchester)"),
    encodes data using signal edges, as opposed to signal levels. The original, aforementioned
    NRZ encoding uses an internal clock to measure voltage levels at a constant pace,
    interpreting low voltage as binary 0 and high voltage as 1\. Manchester encoding,
    on the other hand, carries data in transitions from low to high voltage or vice
    versa. In such a design, the signal is switched to high to denote binary 1 and
    to low to indicate 0.^([[11](#ftn.CHP-5-FN-1)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Although such encoding does not require the clocks to be kept synchronized,
    it is also not quite enough as it is: there is no way to encode two binary 0s
    or 1s, because it is not possible to go from low to high voltage twice without
    returning to low halfway down the road (and vice versa). To allow this type of
    information to be encoded, transitions that occur shortly after a falling or rising
    signal edge are ignored, thus allowing the system to encode multiple occurrences
    of 0 and 1 by returning to the same voltage midcycle. To manage the “blackout”
    period after a transition, a simple one-shot interval clock is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serial line transmission encodings—NRZ and biphase (Manchester)](httpatomoreillycomsourcenostarchimages1138020.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1. Serial line transmission encodings—NRZ and biphase (Manchester)
  prefs: []
  type: TYPE_NORMAL
- en: The design of a serial line based on the self-synchronizing scheme discussed
    above is often extended to provide full-duplex communications in which both parties
    can talk at once, either by using two separate lines (transmit and receive, Tx
    and Rx for short) or by using advanced echo detection and cancellation tricks
    to differentiate between its own signal and the data sent from the other side.
    Some mediums require or allow for more sophisticated signaling schemes, for example
    sending more than just one bit in every cycle; yet the principle of communications
    remains essentially the same, and Manchester encoding over the lowest possible
    number of wires—often two—is prevalent across the entire domain.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with a knowledge of the basics of “wire pair” serial communications,
    let’s take a peak at two prominent examples of serial communications in the world
    of networking, see how they exchange data internally, and look at how this information
    can leak to third parties without the user noticing.
  prefs: []
  type: TYPE_NORMAL
- en: From Your Email to Loud Noises . . . Back and Forth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most popular long-distance computer communications device is, hands down,
    a modem. Initially introduced in the 1950s for the maintenance and control of
    certain types of military equipment at remote locations, the modem brought the
    Internet to the masses. Although today often considered some-what obsolete, the
    modem has given birth to many advanced technologies, such as affordable high-speed
    DSL (Digital Subscriber Line) systems or cable modems. These devices all use clever
    variations of the same set of techniques to communicate over phone lines or other
    nondedicated analog media using either audible or inaudible signals. The research
    invested in improving modems also contributed to our understanding of numerous
    large-scale design problems in electronics in general and computer and network
    design in particular. Thus, an understanding of how modems work is key to exploring
    other, perhaps more up-to-date, methods of long-distance data transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The universality of the telephone line makes it a natural medium for computers
    to use for communication. Phone lines can be found almost anywhere, and phone
    systems provide excellent call-routing capabilities, making it possible to reach
    just about any location with little if any effort. There is a tiny caveat, though:
    phone lines were meant to carry the human voice, transmitted as a waveform, within
    narrow-frequency response range (usually not exceeding several kHz). Because these
    frequencies were recorded as voltage changes over a pair of wires and relayed
    through a number of analog repeaters and amplifiers, the standard of quality for
    the transmission wasn’t particularly high. It had to be just good enough for people
    to hear and understand each other, and because the human brain is a superb signal
    filtering and processing system, occasional noise or sound-level fluctuations
    were not much of a concern—not until much later on, when customers grew a bit
    picky.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computers, on the other hand, are generally engineered to exchange binary information,
    which is encoded using fairly precise voltage levels over well-designed, short
    lines with good signal characteristics and low capacitance—an exact opposite of
    long-distance, poorly shielded telephone lines with inadequate signal characteristics.
    Computers also need to talk much faster and much more than humans usually do.
    As such, modem designers had (huge understatement here) a difficult challenge
    to solve: They had to determine a way to encode bits of data not only in a manner
    that could be efficiently transmitted to a remote system over the wire (something
    that Manchester encoding made a bit easier), but also as audible signals that
    could be accurately distinguished at the other end of the line regardless of often
    entirely unpredictable voltage changes and other transmission artifacts. They
    had to employ robust error-correction algorithms and variable transmission speeds
    to compensate for poor line quality, occasional cross talk, trucks going over
    a buried phone line, birds building a nest on a pole, and so forth. The designers
    nodded, scratched their heads, and after perhaps just 40 years brought us an affordable
    and fairly fast method for computer-to-computer communication. Let’s take an abbreviated
    look at how this developed and how the technology matured—yet essentially stayed
    the same—over the decades that followed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The history of commercial modem development and standardization began in the
    1960s when two standards, Bell 103/113 and V.21, were conceived. Both standards
    provided an amazing (for the time) 300-baud (bits per second) full-duplex connectivity
    using a technique called *frequency shift keying* (FSK). FSK is a mysterious-sounding
    term that happens to stand for a rather trivial signal-encoding scheme: it uses
    two different tones to denote different values, one frequency for “low,” and another
    frequency for “high.” The advantage of using audible frequencies over other types
    of signaling is rather significant: this is the only type of signal that can be
    relayed through the phone system fairly well—after all, this is what the system
    was designed for. All other signals are more or less destined to be trashed beyond
    recognition before reaching the other end of the wire, in the best-case scenario,
    or being immediately filtered out by bandpass filters somewhere down the line
    in the worst case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to FSK encoding, the aforementioned Bell 103/113 and V.21 standards
    split the frequency range that could be transmitted over phone lines in two: one
    of the modems, the caller, used a frequency of 980 Hz to encode low and 1,180
    Hz to encode high. The other end, the answerer, used the higher part of the spectrum:
    1,650 Hz and 1,850 Hz, respectively. Why split the frequency in this way? Because
    a phone line is essentially just a pair of wires, which can be used for transmission
    by two devices simultaneously (full duplex), but only if they are capable of dealing
    with the fact that their respective transmissions would superimpose on each other.
    In full-duplex communication, each device must be able to distinguish its own
    signal from the data it’s receiving and filter it out. If it cannot do so successfully,
    each device would have to pause while the other end is talking (simplex mode),
    severely impairing the already sort of unimpressive throughput. By splitting the
    frequency, the phone line is essentially made to carry what it sees as two different
    “voices,” thus ensuring that simultaneous communication can occur with no collisions.'
  prefs: []
  type: TYPE_NORMAL
- en: It took 25 more years for modems to take another step in the right direction.
    The next major set of standards, Bell 212A and V.22, took a big leap forward and
    dropped frequency shift keying in favor of *differential phase shift keying* (DPSK).
    Rather than change the frequency of a wave, DPSK shifts its phase to signal different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The phase shift technique essentially introduces a minimal time shift, or delay,
    that causes the output audio signal to be slightly out of sync with the original
    reference wave, while maintaining exactly the same shape (see [Figure 5-2](ch05.html#frequency_shift_versus_phase_shift
    "Figure 5-2. Frequency shift versus phase shift")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Frequency shift versus phase shift](httpatomoreillycomsourcenostarchimages1138022.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. Frequency shift versus phase shift
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the phase shift, also called the *shift value*, is expressed in
    degrees (a reference to its effect on trigonometric functions: y = sin(x) shifted
    by 90° is exactly the same as y = sin(90° + x). A shift value of 360° denotes
    a shift by the entire wavelength, which simply puts the waves right back in sync
    and has no effect on the waveform. The correspondence of various phase shifts
    is shown in [Figure 5-3](ch05.html#phase_shifted_signals_open_parenthesis_l "Figure 5-3. Phase
    shifted signals (left) and a result of subtracting a reference waveform to more
    easily distinguish between phases (right)"), on the left.'
  prefs: []
  type: TYPE_NORMAL
- en: Once both parties are synchronized and have a way to compare the signal received
    over the cable with the expected waveform, the actual encoded data can be easily
    retrieved. A differential circuit can compare two signals, subtract them, and
    easily determine the exact phase shift of the signal, by comparing it to a reference
    signal, as shown in [Figure 5-3](ch05.html#phase_shifted_signals_open_parenthesis_l
    "Figure 5-3. Phase shifted signals (left) and a result of subtracting a reference
    waveform to more easily distinguish between phases (right)"), on the right.
  prefs: []
  type: TYPE_NORMAL
- en: The new standard also took advantage of a more advanced data-encoding method.
    Instead of simply using two alternating signals to transmit 0s and 1s, as was
    the case previously, V.22 encodes whole *dibits*—slang for pairs of bits. Encoding
    two bits at once can be achieved using four phase shift values, with the amount
    of shift used to denote each of the possible values chosen so that values are
    uniformly and possibly farthest spaced through the entire 360° spectrum—and thus
    easily distinguishable from each other (see [Table 5-1](ch05.html#using_phase_shifts_to_encode_two_bits_of
    "Table 5-1. Using phase shifts to encode two bits of data (dibit)")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Phase shifted signals (left) and a result of subtracting a reference waveform
    to more easily distinguish between phases (right)](httpatomoreillycomsourcenostarchimages1138024.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3. Phase shifted signals (left) and a result of subtracting a reference
    waveform to more easily distinguish between phases (right)
  prefs: []
  type: TYPE_NORMAL
- en: The use of dibits allowed for significantly faster transfer speed (1,200 baud)
    without the need to increase the physical rate with which the actual signal was
    modulated. Twice as much information—twice as many bits—was carried within every
    single beep.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1. Using phase shifts to encode two bits of data (dibit)
  prefs: []
  type: TYPE_NORMAL
- en: '| Dibit | Phase Shift |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `00` | 90° |'
  prefs: []
  type: TYPE_TB
- en: '| `01` | 0° |'
  prefs: []
  type: TYPE_TB
- en: '| `10` | 180° |'
  prefs: []
  type: TYPE_TB
- en: '| `11` | 270° |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is theoretically possible to use such an extended alphabet—that
    is, composite signal units similar to dibits (that have more than two states and
    thus encode more than one bit at once)—with FSK encoding as well, it is a bit
    more problematic to do so. FSK signals must avoid subharmonics and other frequencies
    that are particularly prone to distortion when sent through phone systems, thus
    severely limiting the set of possible states. The advantage of DPSK over FSK is
    that it uses a fixed frequency that is known to cause the fewest transmission
    problems and, hence, can be used more reliably at higher transmission rates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few years, the pace of research accelerated a bit, and a number
    of new standards surfaced. The V.22bis standard took the concept of wide alphabet
    signaling a bit further, combining DPSK with signal amplitude (loudness) modulation
    to build a two-dimensional set of 16 possible values. The transition from a measured
    signal to binary values was expressed using a two-dimensional table. The value
    to which a signal corresponds is obtained by first looking up the column, based
    on the measured phase-shift value, and then the row is looked up based on the
    amplitude measurement. A simplified but analogous two-by-four example is shown
    in [Table 5-2](ch05.html#two-dimensional_encoding_of_three_bits "Table 5-2. Two-dimensional
    encoding of three bits using two distinct signal parameters").
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2. Two-dimensional encoding of three bits using two distinct signal
    parameters
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Phase 0° | Phase 90° | Phase 180° | Phase 270° |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Low amplitude** | 000 (0) | 001 (1) | 010 (2) | 011 (3) |'
  prefs: []
  type: TYPE_TB
- en: '| **High amplitude** | 100 (4) | 101 (5) | 110 (6) | 111 (7) |'
  prefs: []
  type: TYPE_TB
- en: To add to the confusion, this new approach was called *quadrature amplitude
    modulation* (QAM). QAM once again made it possible to go from 1,200 to 2,400 bps
    without actually improving signal modulation speed, but by extending the number
    of meanings a single atom of signal can have.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next major evolutionary step was V.32\. V.32 was the first design to introduce
    a novel concept: instead of splitting frequencies, it used advanced echo cancellation
    circuitry^([[12](#ftn.CHP-5-FN-2)]) to detect and subtract the signal transmitted
    by the device itself from the data received over the wire. This technique allowed
    both devices (sender and receiver) to use the entire frequency spectrum, instead
    of just half of it, while still doing full-duplex.'
  prefs: []
  type: TYPE_NORMAL
- en: Development continued, and the V.34 protocol soon appeared. Although the rate
    at which the signal could safely alternate before introducing excessive distortion
    did not noticeably change over the years, the standard was considerably faster
    than its predecessors. V.34 achieves a throughput of 28,800 baud, sometimes pushed
    a bit further by manufacturers to a unofficial speed of 33,600 baud (33.6 Kbps)
    by sending only about 2,500 to 3,500 signal samples (alphabet symbols) per second;
    however, it combines four different encoding schemes to build a four-dimensional
    structure with 1,664 possible states, making it possible to send as many as 41
    bits at once. As it turns out, it’s not about raw speed but how you use what you’ve
    got.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is widely believed that the V.34 standard and its derivatives approach the
    theoretical limit for transmission of data via the voice-oriented telephone system.
    Although this may seem an odd statement given the prevalence of 56 Kbps modems,
    there is a catch: 56 Kbps devices achieve this transmission rate in a wholly different
    way than in analog solutions. Given that most phone systems have migrated from
    analog to digital since modems were first developed, and because most dial-up
    providers can now interface their systems directly with digital telecommunication
    systems, service providers can return to the most obvious but, until recently,
    impossible solution: changing line voltages instead of shifting frequencies when
    sending data to a subscriber. Because the signal is carried as digital data from
    the beginning—and can travel over buried copper lines only till the nearest telco
    facility—there are virtually no signal quality problems, and the only limit is
    the voice-carrying capacity designed into the phone system hardware. Working at
    8,000 symbols per second, but operating with a considerably smaller alphabet (usually
    about 128 symbols, or voltage levels), it is possible to send data to a subscriber
    who is connected to a digital phone system with high-quality wire using a 56 Kbps
    modem at a higher speed than usual. The upstream transfer is still implemented
    the old-fashioned way, though, and is considerably slower; as such, the modem
    is only partly 56 Kbps, and only when conditions permit.'
  prefs: []
  type: TYPE_NORMAL
- en: The Day Today
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not much has changed since the conception of modem technology. As transmission
    protocols advanced, so did the error-correction and fallback mechanisms needed
    to ensure reliable transmission when your favorite quadruped decides to chew the
    phone cable. A jungle of standards were spawned: V.42 provided a basic CRC (cyclic
    redundancy check) implementation, MNP-1 to MNP-4 provided proprietary error-correction
    algorithms, V.42bis and MNP-5 provided integrity checking combined with compression,
    and so on. But the real revolution is yet to come.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or is it? You might argue that DSL and cable modems are a revolutionary technology
    that has changed the world. I am willing to argue: in fact, they are quite similar
    to their older cousins, modems. The only significant difference between the two
    is that the other endpoint—the server that handles all connections—has moved from
    a distant city where the service provider is located to the nearest local telco
    facility, and the connection to it can be made directly using the copper wire
    coming from the customer’s residence or business. Because that direct connection
    again does not go through any other equipment, these devices can use high, inaudible
    frequencies and subtler signals that would otherwise be distorted or not relayed
    at all over the telephone network. In contrast, the good old modem was strictly
    limited to a narrow range of audible frequencies and signals that the phone system
    was intended to carry and that it could carry well. In many ways, DSL devices
    have it much easier than the old modem.'
  prefs: []
  type: TYPE_NORMAL
- en: As we see, designing a modem is actually quite a complex and difficult task;
    that’s why it took us decades to advance from bulky and expensive 300-baud devices
    to where we are now.^([[60](apb.html#ftn.CHP-5-BIB-1)]) Surprisingly, all these
    devices can talk to one another, even to devices ten years older, even at the
    lowest speeds we long forgot about. Too, all are usually aware of the standards
    known to date, including the dozens of alternatives and forks of each. Doesn’t
    that make modems even more a marvel of computer engineering?
  prefs: []
  type: TYPE_NORMAL
- en: But who pulls the strings?
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a Modem Is Just a Modem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modem-to-modem communications is, of course, not where the story starts or
    ends. The modem is just a piece of fairly inert middleware that’s hardly even
    a good paperweight. For a modem to be of any use, it must be able to communicate
    with a computer to receive commands and exchange data, even when it’s only being
    used for something as feeble as random web browsing. Internal modems have it easy:
    ISA (Integrated Systems Architecture), PCI (Peripheral Component Interconnect),
    PCMCIA (PC Memory Card International Association), and some other dedicated buses
    provide high-speed and fairly generous parallel interfaces that make the communication
    process almost trivial.'
  prefs: []
  type: TYPE_NORMAL
- en: External modems (of the analog or DSL kind), however, have to do things the
    hard way, with a serial link. Most analog modems use the well-known serial protocol
    RS-232 (renamed in the ’90s to the much more descriptive EIA/TIA-232-E^([[61](apb.html#ftn.CHP-5-BIB-2)]));
    many newer ones use USB (Universal Serial Bus). As we get close to the information
    disclosure scenarios in those devices, we want to get a glimpse of what happens
    to the data on its way between the modem and the computer, too, because that plays
    a crucial role in the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Although external modems have to use inhumane means of communicating not only
    with a remote system, but also with the local machine itself, thanks to the proximity
    to the computer and the fact that interfaces such as RS-232 are digital and were
    designed for use by computers to start with, this stage is still much simpler
    than the phone line modulation and demodulation for which bit modems became famous.
  prefs: []
  type: TYPE_NORMAL
- en: 'RS-232 uses a fairly straightforward implementation of bipolar encoding for
    the data exchanged over two separate lines and backs this with a set of NRZ control
    lines. To make life a bit more interesting, RS-232 comes with a multitude of link
    or protocol features that make it fairly difficult to implement from scratch:
    its asynchronous nature, a wide array of possible settings and speeds, and unusual
    voltage levels. But with all this, RS-232 still does not even come close to a
    real challenge for an implementator who had dealt with signal modulation over
    phone lines.'
  prefs: []
  type: TYPE_NORMAL
- en: USB, on the other hand, attempts to standardize and unify the serial interface.
    Although USB requires higher-end circuitry than RS-232 in order to interface a
    computer with a device (because of, among other things, a higher level of abstraction
    and higher supported transmission speeds), the USB is universal (hence its name)
    and has fewer oddities and legacy features.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, a common method of communicating with local devices is the
    use of Ethernet, a mechanism somewhat similar to, but predating, USB. Let us look
    at Ethernet for a while now, and I am sure all those communication protocols will
    eventually meet in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Collisions Under Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ethernet networks are, in essence, an advanced type of a multiparty serial link.^([[62](apb.html#ftn.CHP-5-BIB-3)])
    An Ethernet network is composed of a number of computers connected by a shared
    medium—nothing particularly complex, in its most basic form, just a pair of fairly
    regular wires. When a device on the network uses the medium, it applies a specific
    voltage to the wire, and all other connected systems can interpret the data by
    measuring the voltages. A set of checks ensures that devices do not try to use
    the link at the same time and that recovery is smooth if an accident happens.
    Still, even considering this possibility, the basic design is unbelievably trivial,
    compared with modems.
  prefs: []
  type: TYPE_NORMAL
- en: To work around the problem of two parties talking at once, a standard named
    Carrier Sense Multiple Access with Collision Detection (CSMA/CD) is used as the
    core mechanism controlling all communication via Ethernet. Before sending any
    data, every device connected to Ethernet follows a CSMA procedure to see if another
    device is using the cable by checking the modem’s electrical properties. If no
    other transmission is occurring, the device enters the transmission phase and
    beams its data out to the masses.
  prefs: []
  type: TYPE_NORMAL
- en: In this phase, the data is sent on the wire as a sequence of bits using *bipolar
    encoding*; the traffic contains a header with all the necessary sender and recipient
    information and a proper checksum intended to protect the integrity of the data
    in case of external or internal interference, quadruped or not. A network interface
    that considers itself to be acting on behalf of a recipient, presumably by comparing
    the observed destination address provided in the packet with its unique MAC (hardware)
    address stored on the card, should accept this traffic and verify the checksum.
    At the same time, all other parties should ignore this frame; naturally, if they
    do not (and almost every card can be instructed not to), the user can view or
    react to traffic addressed to others. (You can see how Ethernet was designed in
    the spirit of far-fetched trust and altruism—a noble but risky approach.)
  prefs: []
  type: TYPE_NORMAL
- en: It is possible (and not very unlikely) for two devices on an Ethernet network
    to start sending at exactly the same moment, even though both checked just microseconds
    or nanoseconds ago for another party transmitting. And, if they do transmit at
    exactly the same moment, a disaster is bound to happen. Two transmissions are
    mixed up and mangled, and the sent data should fail the checksum test at the destination
    . . . or should it?
  prefs: []
  type: TYPE_NORMAL
- en: Although the use of a checksum implemented within the Ethernet frame specification
    is typically sufficient to verify data transmission accuracy, it may not be particularly
    effective if the link is saturated and hundreds or thousands of collisions occur
    in a short period of time; it is just small enough to accidentally come out correct
    from time to time. The law of probabilities tells us that some damaged packets
    will—just by chance—have the same check-sum as an original packet. Furthermore,
    even if we ignore the problem of checksum deficiencies, we still want to stop
    collisions as soon as possible—by just letting collisions run rampant, you might
    find that you are no longer able to ensure the timely retransmissions of mangled
    and dropped frames in your network. After all, the sender sent it with no indication
    of a problem, and the recipient did not receive anything even remotely resembling
    a useful packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution comes with the latter part of the standard: collision detection
    (CD). The specification calls for the sender to monitor the network link while
    explaining their business to others. If another party is caught trying to talk
    at the same time, that should be detected (again, with a simple measurement of
    the electrical properties of the line), and the transmission should be immediately
    aborted. The device should also send a special jam code to ensure that both frames
    (the one being sent and the one that interfered with it) will be unconditionally
    dropped, without even getting to the checksum verification; the recipient should
    be able to spot the jam code and stop the reception of data being processed. The
    device then idles for a gradually increasing and preferably (initially) random
    period of time after every attempt (called retransmission backoff), to minimize
    the likelihood of a subsequent collision.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A fun fact: The jam code mechanism imposes an unusual requirement on the protocol.
    All frames must have a minimum (!) length, with the value calculated such that
    it allows the jam code to be generated and propagated to all machines before the
    transmission is completed. With very short frames, there may not be enough time
    to achieve this. Hence, the sender is required to artificially pad all their outgoing
    transmissions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](ch05.html#the_stages_of_a_typical_ethernet_convers "Figure 5-4. The
    stages of a typical Ethernet conversation") shows the exact sequence of events
    in a typical collision scenario. As you can see, Sender A hopes to send data to
    the recipient but notices another transmission occurring, at which point they
    decide to wait until that transmission stops. Sender A then prepares to send the
    data but, unfortunately, Sender B does the same, and both conclude that it is
    safe to send data at nearly the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: Both attempt to transmit, data gets mangled, and at that point both detect the
    other transmission and quickly send a jam code to instruct the recipient to disregard
    this frame. Finally, both senders back off for a random amount of time and hopefully
    manage not to start simultaneously the next time around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the Scenes: Wiring Soup and How We Dealt with It'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although not an example of a particularly scalable or elegant design, the Ethernet
    protocol is amazingly powerful and easy to deploy; it enabled the building of
    cheap peer-structure networks using coaxial cables just about anywhere. As such,
    it has become a de facto standard, replacing many other (and sometimes superior,
    but more expensive or proprietary) networking architectures.
  prefs: []
  type: TYPE_NORMAL
- en: '![The stages of a typical Ethernet conversation](httpatomoreillycomsourcenostarchimages1138026.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4. The stages of a typical Ethernet conversation
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, simple Ethernet over coaxial cable had its limits and disadvantages;
    it was essentially based on a long piece of wire with devices hooked up to it
    at various locations, and with resistors on both ends, not something you'd want
    to be responsible for maintaining in a large office. A simple and difficult-to-debug
    mishap, such as a shorted terminal, could bring the entire infrastructure down.
    A more advanced—but only marginally more expensive—replacement was warmly welcomed.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic multiport repeaters (hubs) made it possible to run wiring without
    much effort using twisted pair wiring (Cat-3 and Cat-5 cables with RJ-45 connectors).
    To use them, you simply plugged a piece of wire from your machine into a black
    box, and all other devices connected to this black box could communicate with
    it without much consideration of electrical problems or the risk that a single
    cable failure would bring down the entire network.
  prefs: []
  type: TYPE_NORMAL
- en: '*Hubs* are, in essence, simple repeaters that broadcast all traffic received
    on one port to all other ports. They make it possible to build easily reconfigurable
    and more reliable star-type networks, but they do little else. As the network
    grows, the cost of broadcasting every bit of information to all locations, and
    the fact that only one party can talk at once across the entire network, makes
    it all too evident that the simplicity of this design is its major weakness.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Switches* turned out to be the solution. Switches are the next generation
    of hubs. Equipped with a decent processor and some memory, they’re a more expensive
    alternative to hubs that provide, under normal circumstances, additional high-level
    analysis of Ethernet frames. This analysis associates hardware addresses with
    specific ports and optimizes frame routing by delivering certain packets directly
    to the appropriate port (in unicast mode), instead of broadcasting them to all
    parties (see [Figure 5-5](ch05.html#hubs_versus_switches_in_local_networks "Figure 5-5. Hubs
    versus switches in local networks")). This greatly improves performance in more
    extensive networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another fun fact: Real hubs are almost extinct nowadays. Almost all 10/100
    Mb devices marketed as hubs actually use basic switch chipsets; it is simply cheaper
    to repackage the chip than to develop and maintain several variants.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hubs versus switches in local networks](httpatomoreillycomsourcenostarchimages1138028.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5. Hubs versus switches in local networks
  prefs: []
  type: TYPE_NORMAL
- en: I’m guessing that at this point you’re asking yourself, Where the heck are you
    going with all this? What do modems have to do with information disclosure? What
    significance do serial links have in this context? How do Ethernet networks fit
    in? And what the heck are blinkenlights?
  prefs: []
  type: TYPE_NORMAL
- en: Glad you asked. I am about to get there—to the last question, that is.
  prefs: []
  type: TYPE_NORMAL
- en: Blinkenlights in Communications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, almost all refrigerator-sized computers were equipped with numerous
    prominently exposed diagnostic interfaces. These included arrays of tiny lights
    that displayed, among other things, certain arcane properties of the internal
    state of a machine, such as internal registers or flags of the core processing
    unit or an indication of whether the cat living underneath had been fed today.
    As computers became more reliable and compact, and an average user no longer had
    to understand the machine’s internals in order to use it efficiently, the lights
    started to disappear from many devices. Ever-increasing clock speeds also contributed
    to the decline—most of the time it was no longer possible for humans to get any
    meaningful information from such a visual signal that would change thousands or
    millions of times every second.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, the lights prevailed in some applications; for example, almost all networking
    devices feature light-emitting diodes (LEDs) on their front or back panel. These
    provide link diagnostics, such as an indication of whether a particular module
    or socket is functioning properly, a party is connected, data is being transferred,
    and so on. The lights are not merely a diagnostic tool either; their hypnotic
    patterns have strange appeal, and their mystery plants seeds of uncertainty, fear,
    and respect in the hearts of lay people who enter the realm of the server room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *blinkenlights* or *blinkenlichten* has been used to describe the
    much-adored institution of diagnostic LEDs on computer equipment ever since the
    dark ages of computing, bathing the computer geek in the soothing green light
    during those long, lonely nights spent at the terminal. It came from an amusing
    prank note in mock German (itself a spoof of another, noncomputer joke from WWII),
    displayed some time in the 1950s at IBM laboratories. The note later propagated
    into a majority of server rooms and computer science laboratories across the world
    and went like this (as quoted from Eric S. Raymond’s *Hacker’s Dictionary*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1138030.png)'
  prefs: []
  type: TYPE_IMG
- en: Communications equipment is one of the last domains in which blinken-lights
    prevail and prosper. But that’s not all. Almost all these devices use serial lines
    for communications. And, for the sake of simplicity and aesthetics, “activity”
    LEDs are sometimes wired almost directly, through a simple driver circuit, to
    the transmit or receive line of the device. Curtain falls.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#CHP-5-FN-1)]) Or the other way around, depending on the transmitter
    design.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[12](#CHP-5-FN-2)]) Echo cancellation circuits attempt to distinguish signals
    being sent by the device itself from those coming from the other party, and to
    eliminate or significantly reduce the former. Various types of such devices are
    commonly used not only in digital data transfer, but also to improve phone call
    quality, eliminate microphone feedback during public events, and solve many other
    everyday problems.
  prefs: []
  type: TYPE_NORMAL
- en: The Implications of Aesthetics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It took decades for the problem to be discovered, and once it happened (in 2002),
    it struck us all as so obvious and trivial we wanted to bang our heads on the
    keyboard a couple of times.
  prefs: []
  type: TYPE_NORMAL
- en: Joe Lughry and David A. Umphress, in a research paper titled “Information Leakage
    from Optical Emanations,”^([[63](apb.html#ftn.CHP-5-BIB-4)]) discovered a new
    type of signal-disclosure scenario in certain types of network equipment, most
    often modems. They concluded that someone observing these lights could go beyond
    simply watching the magic lights with the naked eye.
  prefs: []
  type: TYPE_NORMAL
- en: LEDs, unlike incandescent bulbs, usually have short rise and fall times, meaning
    that they turn on and off almost instantly. That’s not surprising; after all,
    high-end LEDs are used to control fiber-optic links and some other optoelectronic
    communication channels. As such, the blinking of an LED hooked up to a serial
    data transmission line can actually often mirror single bits of the transmission
    as it occurs on the wire. Given a way to record this activity at a sufficient
    speed, it should be possible to retrieve this information, from at least as far
    as you can see the tiny blinking light on a device with the naked eye (or with
    a telephoto lens).
  prefs: []
  type: TYPE_NORMAL
- en: 'This research caused some stir in the industry; it was eventually also both
    downplayed and overhyped, and hence a great deal of confusion ensued, and very
    little has changed. The paper resulted in many conflicting reports, but its basic
    premise is simple and truly beautiful. The beauty of this technique is that it
    is trivial to devise such a device to receive the signal: the equally cheap and
    popular counterparts of LEDs—photodiodes and phototransistors—are easy to acquire
    and equally easy to interface with the computer. And the exposure zone, unlike
    most of the TEMPEST activity we discussed in [Chapter 3](ch03.html "Chapter 3. Ten
    Heads of the Hydra"), is not merely the subject of urban legends and pure laboratory
    results, but can be directly observed and measured.'
  prefs: []
  type: TYPE_NORMAL
- en: In the course of their research, the authors performed a set of experiments
    to verify that the signal could be successfully acquired from as far away as 20
    meters (just under 100 feet) without the need for additional digital signal conditioning.
    And common sense suggests that this might actually be an understatement, especially
    when good optics are used. (The authors used a 100 mm focal length, f/2.0 lens
    for the test, but a much better telephoto lens is commonly available to many midrange
    SLR (single lens reflex) photography amateurs. Those who are willing to part with
    their money can buy a superb-quality lens with a focal length of as much as 1,200
    mm.)
  prefs: []
  type: TYPE_NORMAL
- en: The paper takes a defensive stance in several cases, and a careful reader might
    be tempted to conclude that some of the devices classified are not vulnerable
    to the problem. In particular, some of the Ethernet devices may exhibit a more
    subtle variant of the vulnerability, as you’ll see in the prevention section later
    in this chapter. But first let’s peek at the problem with our own (computerized)
    eyes, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Building Your Own Spy Gear . . .
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplicity of building a snooping device makes it quite tempting to do so.
    This section contains several suggestions and rough schematics on how to build
    and connect such a device to an ordinary computer. Although the circuit is not
    particularly complex and does not require a master’s degree in soldering and a
    printed board circuit design software, a minimum level of proficiency in electronics
    is desirable, as is a dose of common sense. Although external interfaces of today’s
    computers are fairly robust and foolproof, there is always the risk of damaging
    equipment when attaching home-brew devices in a really innovative way, in a brief
    moment of insanity. It’s happened to the best of us.
  prefs: []
  type: TYPE_NORMAL
- en: The baseline design is extremely trivial. It calls for a single phototransistor
    (a component consisting of a transistor driven by a built-in photodiode), a regular
    low-power NPN (Negative-Positive-Negative) transistor to amplify the signal a
    bit further (not always necessary), and a set of potentiometers (perhaps in the
    range of 10 kΩ just to have enough flexibility) to experimentally pull down the
    voltage and control the circuit’s sensitivity and threshold points. There are
    no particular requirements for the components, although your mileage will vary
    depending on which ones you use. Be sure to select a phototransistor that has
    a decent response in the visible light range, though all cheap ones should work.
    (For reference, a green LED emits a wavelength of approximately 520 nm.)
  prefs: []
  type: TYPE_NORMAL
- en: A sample circuit design is shown in [Figure 5-6](ch05s03.html#a_simple_receiver_circuit
    "Figure 5-6. A simple receiver circuit").
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple receiver circuit](httpatomoreillycomsourcenostarchimages1138032.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6. A simple receiver circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit has an optimal running voltage of approximately 5V and a low maximum
    current: a power supply capable of delivering perhaps 10 to 50 mA is more than
    enough. A word of warning: If you use a supply capable of delivering a higher
    voltage, you will risk damaging the port or the computer; likewise, if you use
    a more powerful supply and do not prevent higher current from flowing through
    the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting Rvar1 or Rvar2 to a very low resistance may short the circuit. If you
    want to fiddle with the knobs mindlessly, it might be a good idea to add a fixed
    resistor to limit the current drain.
  prefs: []
  type: TYPE_NORMAL
- en: You must shield the phototransistor from external light sources—for example,
    by enclosing it in an opaque tube. Because the phototransistor has no focusing
    mechanism, it is not likely to pick up more distant signals (other than ambient
    light). Thus, for initial tests, it is a good idea to cover it entirely to simulate
    darkness and then put it by an LED to excite the circuit. You can also connect
    another LED temporarily between the GND and the output line to test the circuit.
    The test LED should light up when the sensor is directed at a light source, but
    otherwise be fairly dark.
  prefs: []
  type: TYPE_NORMAL
- en: . . . And Using It with a Computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the circuit with a test LED hookup works so far, well done; you have built
    a fancy TV remote tester. Because generic, cheap phototransistors are eager to
    pick up infrared light, your creation should “translate” IR (infrared) into visible
    light, but that’s about all the fun stuff it will do. To make it a bit more useful,
    you need to interface the circuit with the computer. A good way to do so is through
    a line printer interface, LPT, if your computer has one. Unfortunately, this wonderful
    hardware hacker’s tool is being dropped from some of the more compact and fancy
    designs.
  prefs: []
  type: TYPE_NORMAL
- en: Although initially designed to be unidirectional (for output only), the LPT
    interface provides a number of status feedback lines, such as “paper out,” “busy,”
    and “acknowledgment,” that were intended to provide a means for the printer to
    complain about problems. You can easily read the data that issues through this
    interface by accessing port 0x379 (the LPT1 status register) on a PC-compatible
    system. By hooking the circuit to a parallel port, you can easily transmit information
    back to the computer. Although you might want to connect the circuit to a different
    interface, LPT is much faster than, say, RS-232, and you won’t have to cope with
    any mundane protocols, signaling schemes, or unusual voltage levels. Too, unlike
    USB and some other current solutions, you do not need special controllers to implement
    a fairly complex protocol to even be able to talk to your PC.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although LPT also offers bi-directional operation modes (ECP or EPP), it is
    usually pointless to attempt to use this functionality for such a simple task.
    In the unidirectional mode, four bits are available for input, more than enough
    for this application; switching to bi-directional modes such as EPP or ESP provides
    an extra four bits.
  prefs: []
  type: TYPE_NORMAL
- en: It is up to you to choose the status line to use. [Table 5-3](ch05s04.html#lpt_pinout
    "Table 5-3. LPT pinout") shows a pin layout of the DB25 connector used for a printer
    port. The rows shaded gray can be used for input.
  prefs: []
  type: TYPE_NORMAL
- en: To interface the circuit with this port, you can simply connect the ground reference
    point on the connector with the one used in your circuit and then hook up the
    output line to any of the five pins. (Remember to disconnect the LED used for
    diagnostics first.) Next, monitor the status port as you first expose it to light
    and then cover the sensor. In either case, the value read depends on how you hooked
    up the circuit; the exact value does not matter, as long as the two values are
    different.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-3. LPT pinout
  prefs: []
  type: TYPE_NORMAL
- en: '| LPT Port: DB25 Pinout (Standard Mode) |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pin | Name | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Strobe | Control output bit 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | D0 | Data output bit 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | D1 | Data output bit 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | D2 | Data output bit 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | D3 | Data output bit 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | D4 | Data output bit 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | D5 | Data output bit 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | D6 | Data output bit 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | D7 | Data output bit 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | ACK | Status input bit 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Busy | Status input bit 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Paper Out | Status input bit 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Select In | Status input bit 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | Autofeed | Control output bit 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | Error | Status input (unused) |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | Init | Control output bit 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | Select | Control output bit 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | GND | Ground (0V) |'
  prefs: []
  type: TYPE_TB
- en: Because chip logic requires somewhat different input levels than your test LED
    diode, you might have to tweak the `Rvar2` until you get distinct readings from
    the port when you cover the sensor, and when you expose it to light. To accomplish
    this, it is best to be able to monitor the port in real time on the computer itself.
  prefs: []
  type: TYPE_NORMAL
- en: The way you can monitor the state of the port will depend on the operating system
    and the programming language you are using. If you’re using C, the function used
    to read the value off a port is `inb(port)`, so in this particular case you would
    issue `inb(0x379)` and check the return value. In other languages, it is likely
    to have a similar name. (Try looking for `in`, `inport`, `readport`, and so forth.)
    Also, Windows users may find the built-in “debug” utility and its “i” (port read)
    function quite handy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On some systems, such as Linux, you might need to request that the system give
    you permission to access a specific port first. Consult the documentation for
    `iopl(3)` or a similar call for more information.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you are ready to go. You can choose to point your probe at any
    LED on a device, adjust the sensor based on its brightness, and start reading
    alternating patterns of light and dark signals, as you discover how they correspond
    to the exchanged information, if at all.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re curious, you might try to examine the brightness of the indicator
    diode, not only a binary representation of its state. It might turn out that even
    though a specific LED is not intended to directly map a signal on the serial line
    to its blink patterns, there is some analog cross talk between circuits, and the
    serial line signal will have some influence on the brightness. A cheap analog-to-digital
    converter such as TLV571 from Texas Instruments is just asking to be used this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this approach to sample the frequency of less than 1 million bits
    per second, which should suffice for capturing transmission on many interfaces,
    but not necessarily on Ethernet ports (which transmit at least 10 million bits
    per second). Past this capture capacity, your LPT port will likely reach its physical
    throughput limits, but do not despair: as long as the sensor (phototransistor)
    can switch at the rate sufficient to capture communications in question, you still
    have an option. Remember that LPT is a parallel port. To reach faster capture
    speeds, such as the one needed for Ethernet, combine a trivial clock, a counter
    circuit, and a set of sample-and-hold latches (such as 74LS377) to sequentially
    store data between the port read attempts on the computer side. You can accumulate
    this information for a short period of time and then, by using more than just
    one status pin (or by switching the port to bi-directional mode), easily send
    several bits—samples—to the computer, in a single burst, in one read cycle, thus
    improving the read rate four- or eightfold.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll spare you a further, perhaps needless, excursion into the world of electronics.
    If you want to toy with the idea of high-speed or analog sampling, or perhaps
    just get your kicks from soldiering stuff together and hooking it to a computer,
    you might want to take a look at my fairly comprehensive introductory tutorial
    under the thin disguise of a computer-controlled robot design project. You should
    be able to find it at [http://lcamtuf.coredump.cx/robot.txt](http://lcamtuf.coredump.cx/robot.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, for those with interests that lean more toward practical security:
    a brief discussion of how to address the issue, short of covering all LEDs in
    the office with duct tape.'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Blinkenlights Data Disclosure—and Why It Will Fail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest solution to the problem, and one suggested by the original research,
    is *pulse stretching*—a practice intended to distort the blinks on an indicator
    by prolonging some of them, thus making any practical data recovery seemingly
    not feasible. *Pulse stretching circuits* are a group of fairly trivial devices
    that extend the duration of an encountered “high” input signal for an additional
    period of time. Most basic pulse stretcher design relies on a capacitor that charges
    in the presence of an input signal and then discharges slowly. This capacitor
    is connected to a *binary discriminator*, which is not a nickname for a vicious
    wrestling champion, but rather a device that converts analog data into binary
    output by applying a particular threshold (outputting a voltage for logical 1
    for all input voltages above *n*, and 0 for all input voltages below). In this
    case, it uses a certain capacitor charge level as the discrimination point.
  prefs: []
  type: TYPE_NORMAL
- en: 'More advanced and reliable designs, including purely digital circuitry, are
    also common, and all can be used in hubs and switches to make LEDs nice to look
    at. Without them, the high-speed blinking at way more than 50 cycles per second
    (considered the limit on our ability to perceive flicker), would usually result
    in our seeing the lights as dim but seemingly constant. A discriminator causes
    the LED to be driven by 1 more often than by 0 by extending the duration of each
    1 pulse. This makes the LED light brighter and blink less often. [Figure 5-7](ch05s05.html#pulse_stretcher_behavior_comma_3x
    "Figure 5-7. Pulse stretcher behavior, 3x") shows the behavior of such a pulse
    stretcher: a single spike (single 1) is stretched to last three times as long,
    whereas all 0s are left as they are.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pulse stretcher behavior, 3x](httpatomoreillycomsourcenostarchimages1138034.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7. Pulse stretcher behavior, 3x
  prefs: []
  type: TYPE_NORMAL
- en: While their primary purpose is aesthetic, as I have mentioned, this also seems
    to be a good way to solve the problem of light emissions information disclosure,
    by letting the attacker deduce only certain general properties of the traffic.
    Thus, at best, the attacker can figure out only general properties of the traffic,
    such as when something is being sent and when it is not.^([[13](#ftn.CHP-5-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: 'What seems to be a good solution, however, is not always. Consider the following
    sample data and the corresponding serial line signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1138036.png)'
  prefs: []
  type: TYPE_IMG
- en: Assume the signal is processed using a 5x pulse stretcher that makes every 1
    last for five additional cycles. (The original paper suggests a safe limit of
    2x, but we’ll exaggerate to make a point.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1138038.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although it might appear that almost all important information has been lost
    when compared with the input signal we want to intercept, it is possible to recover
    much of it by making four important observations:'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, all areas where the stretcher output is zero must have been zero
    in the original signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each stretched run of 1s must have been triggered by 1 at the starting location
    in the original stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each run of L 1s must have originally contained at least one 1 for every *N*
    cycles, where *N* is the stretch factor for this circuit; otherwise, there would
    be gaps in the run. The count of 1s in a block of data represented under a single
    stretch of 1s in output is greater than or equal to L/*N* rounded up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every run ends after exactly *N*−1 zeros in the original stream. We know that
    these zeros must have been preceded with 1; otherwise the run would have ended
    sooner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By applying this knowledge to the previous example, we can reconstruct most
    of the original data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1138040.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous fairly realistic example, fewer than 9 out of 32 bits of data
    were lost due to pulse stretching and cannot be conclusively reconstructed (marked
    with question marks in the graphic). Thus, we recovered 99.999988% of the potential
    search space. We must guess at the remaining data, which (especially if the data
    snooped is regular English text, such as email) is rather trivial to reconstruct
    compared to the starting point. The authors of the research suggest that even
    N = 1.5 or N = 2 “on” time pulse stretching is sufficient to obfuscate the data,
    but this is not necessarily so.
  prefs: []
  type: TYPE_NORMAL
- en: The previous reconstruction scheme works with stretches of 0s or 1s. Some links
    use return-to-zero (RZ) encodings (such as the Manchester scheme mentioned earlier),
    and because the signal is constantly alternating there, the 2x stretching might
    indeed be sufficient to obfuscate all data. However, this is only true if the
    LED is driven by a signal prior to initial internal decoding to NRZ—which, in
    most situations, is not the case. In fact, applying pulse stretching to RZ-encoded
    signal is often a silly idea in that the LED would be on all the time; hence there
    seems to be no point in doing that in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted previously, an additional problem stems from the quality of the pulse
    stretcher and its susceptibility to interference from other internal circuits:
    LED voltage fluctuations that result in slight brightness changes during a “stretch”
    period might disclose some information. Capacitor-based solutions, in particular,
    can fall into this category.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, some systems, particularly Ethernet devices known to deploy pulse stretching,
    can be partly vulnerable to attack, even though the original paper discussed earlier
    concluded that there is no direct correlation between the transmitted data and
    the behavior of an LED, based on the observation of a recorded blinking pattern
    using an oscilloscope.
  prefs: []
  type: TYPE_NORMAL
- en: The optimal solution, particularly with other types of encoding, or when pulse
    stretching is not desirable for some other reason (for example, if the designer
    wants to avoid making the LED light appear constantly for the time of a transmission)
    is to sample the line at a fairly low frequency (for example, 20 Hz) and latch
    it to a register that holds it until the next sample and that also controls the
    LED.
  prefs: []
  type: TYPE_NORMAL
- en: And, now, back to plain English.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#CHP-5-FN-3)]) This, technically speaking, is still an attack venue,
    per the discussion in [Chapter 1](ch01.html "Chapter 1. I Can Hear You Typing"),
    yet it is considerably less effective and practical, for we only get a rough idea
    of what is going on, not a copy of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Food for Thought
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than network device LEDs, plenty of other, equally interesting light emissions
    leak scenarios can be found, although the amount of information disclosed can
    be significantly lower. For example, consider disk activity LEDs. Of course, disk
    communication is not using serial signaling; instead, portions of data, ranging
    from bytes to 32-bit words, are sent simultaneously using a set of signal lines.
    And, although the LED is usually attached to indicate only a state of a specific
    control line, it is still possible to deduce many aspects of system activity by
    measuring seek times or the amount of data stored and read. (Depending on what
    the LED is actually attached to, it may be possible to measure either or both.)
    Although it’s unlikely that this information would give an attacker any immediate
    advantage, certain induced I/O activities can be combined with hard-disk drive
    LED observation to draw interesting conclusions, although I am unaware of any
    research in this area.
  prefs: []
  type: TYPE_NORMAL
- en: Other potential attack venues involve many USB devices and other proprietary
    interfaces. As mentioned earlier, USB is a serial bus, and some USB appliances
    do have activity indicators.
  prefs: []
  type: TYPE_NORMAL
- en: Various other unusual and arcane information-disclosure venues have also been
    proposed, partly researched or at least toyed with. These include measuring the
    acoustic effects of recharging capacitors as the CPU consumes various levels of
    power depending on the executed instruction^([[64](apb.html#ftn.CHP-5-BIB-5)])
    or measuring a black box device by analyzing its power consumption with the help
    of statistical analysis.^([[65](apb.html#ftn.CHP-5-BIB-6)]) Once again, no truly
    comprehensive research has been done in the area of disclosure channels other
    than classic EMF (electromagnetic field) emanations—and it appears to be a good
    idea to investigate. Best of luck. :-)
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Echoes of the Past
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where, on the example of a curious Ethernet flaw, we learn that it is good
    to speak precisely*'
  prefs: []
  type: TYPE_NORMAL
- en: —
  prefs: []
  type: TYPE_NORMAL
- en: The previous chapter tackled the basics of Ethernet communications. This seemingly
    foolproof and amazingly trivial mechanism appears to be incapable of causing serious
    security issues, except for the possible abuse of the trust relationship caused
    by the regular broadcasting of data to all parties on the network. This is a well-known
    and well-understood property of Ethernet networks, for which good remedies include
    switches, bridges, and network segmentation, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, this issue manifests itself in ways wholly unforeseen, due largely
    to an unfortunate choice of words, or lack thereof, in the official implementation
    requirements for Ethernet drivers. A widespread implementation problem is the
    result, and it has reached a scale that has earned it a place as this chapter.
    It provides an interesting case study for this class of nobody-at-fault problems.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Tower of Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Ethernet protocol provides the basic means to distribute bytes over a piece
    of wire: a low-level data-encoding scheme, and a data format to contain a portion
    of the information. The Ethernet frame contains the information about the local
    disposition of the data it carries (that is, who is sending it and who should
    be the recipient) and a brief description of the type of information encapsulated.
    Additional methods for error detection are also provided, and then the entire
    frame is pushed out to a potential recipient and all other systems. In terms of
    functionality, Ethernet is similar to data portion encapsulation schemes used
    over different mediums or in different applications, such as frame relay, Asynchronous
    Transfer Mode (ATM), Point-to-Point Protocol (PPP), and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: The question is, “What data should be carried by such an Ethernet frame?” Computers
    use hundreds of formats and application protocols and can run applications ranging
    from scientific simulations to network games and chat clients. As such, although
    it is possible to simply encapsulate the data for a remote recipient within an
    Ethernet frame as is, it is usually a bad idea because the recipient won’t know
    how to handle it. Is it incoming email? A web picture? Or perhaps configuration
    data? You can’t tell. Too, because a typical computer runs a variety of programs
    almost simultaneously, the distinction is even further blurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethernet poses yet another problem on a larger scale; specifically, how to
    reach the other end. Broadcasting data to all parties on a local network is easy;
    but what if the other system, the party one of the local users hopes to reach,
    is not local? What if it has to be reached over a wide area network (WAN) and
    uses a wholly different link-layer protocol? Even if a way can be found to route
    traffic to that remote destination, a more fundamental issue remains: how to address
    the package.'
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet uses its own unique, specialized addressing scheme. It calls hosts
    by their theoretically unique hardware card identification numbers (Media Access
    Control addresses, or MAC addresses) embedded by the manufacturer on every Ethernet
    adapter. These numbers are meaningful only to Ethernet; they are meaningless to
    any other type of network and are nearly impossible to use to track down a piece
    of hardware if you are not on the local setup. This raises a trust issue. For
    example, who bought a card with the address of 00:0D:56:E3:FB:E4, and where are
    they now? Can you trust them to really be the original purchaser and not an impostor?
  prefs: []
  type: TYPE_NORMAL
- en: Low-level host-addressing schemes, such as this one, usually are no help in
    relaying data to its destination unless the hardware with a particular MAC address
    is attached directly to the sender’s physical network. There is no way to directly
    map a physical device identifier to a particular location on the globe and determine
    which path should be used to send it information.
  prefs: []
  type: TYPE_NORMAL
- en: The OSI Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The link-level protocols were designed to support communication between local
    nodes or, in some extreme cases, between two fixed endpoints on a shared link.
    To make internetworking possible and some more practical uses of the networks
    feasible, a hierarchical structure of network protocols called Open System Interconnection
    (OSI) was devised.
  prefs: []
  type: TYPE_NORMAL
- en: The OSI model (see [Figure 6-1](ch06.html#the_physical_data_layout_in_the_osi_mode
    "Figure 6-1. The physical data layout in the OSI model, an example")) defines
    the physical connection level as the first layer and builds higher-level features
    on top of it. Link-level protocols constitute the second layer (data link layer)
    and are, as expected, defined as a way to communicate with other local nodes that
    use the same physical link. These protocols carry higher-level, link-independent
    protocol data, defined as the third layer (network layer) of the model. The Internet
    Protocol, IP for short, is the most prominent example of such a protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '![The physical data layout in the OSI model, an example](httpatomoreillycomsourcenostarchimages1138042.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. The physical data layout in the OSI model, an example
  prefs: []
  type: TYPE_NORMAL
- en: The third layer is designed to provide information about the general disposition
    of the traffic as well as universal identification of both the origin and final
    destination of data using network-specific addressing, thus making it easier to
    route the packet. Unlike the second-layer protocols, the third layer is not discarded
    or modified en route and is devoid of any link-specific features such as MAC addresses,
    CSMA/CD (Carrier Sense Multiple Access with Collision Detection) overhead, and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth layer provides the means for establishing specific communication
    channels between endpoints starting and terminating on a given machine. This provides
    a way for simultaneous communication of multiple types and channels. None of the
    fourth-level protocols needs to be understood by intermediate systems to properly
    deliver the traffic to the destination. The packets are interpreted only by the
    final recipient to determine which application should be receiving the data and
    how this piece of information relates to adjacent packets.
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent layers of the OSI model are perhaps less interesting and have
    a tendency to blend together. The fifth level is supposed to provide reliability
    features that are often incorporated either in fourth-level protocols, such as
    TCP/IP (Transmission Control Protocol/Internet Protocol), or on the application
    level. In some cases, they are not even implemented at all if there is no need
    to achieve reliable communications. The sixth level provides “library” functions,
    such as decompression and decoding of the data and, as with the fifth level, is
    usually perceived in terms of application-level functionality. Finally, the seventh
    layer is the application layer, the place where data is transferred in a specific
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the higher layers in the OSI model are independent of the lower
    layers as they apply to the carried data. When the time is right, the lower layers
    can gradually be disposed of without losing the data or the ability to further
    process it. The second layer is discarded at every intermediate system; the third
    layer can be discarded once the data is delivered to its destination system. The
    fourth layer is dropped before delivering the data to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: The third layer usually remains completely independent of the underlying link-level
    protocol by providing complete sender and addressee information, an integrity
    protection mechanism (checksumming), and information about the size of the carried
    payload. This is precisely what IP does.
  prefs: []
  type: TYPE_NORMAL
- en: One important consequence of this design is that any superfluous information
    appended to the packet on layer 2 while in transit will not affect the way the
    IP information is interpreted by the addressee.
  prefs: []
  type: TYPE_NORMAL
- en: The Missing Sentence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter’s discussion of the design of the Ethernet, I mentioned
    an interesting requirement that arises out of a need to provide reliable jam code
    propagation for the purpose of collision notification: the *minimum* size limit
    for an Ethernet frame.'
  prefs: []
  type: TYPE_NORMAL
- en: This requirement was carried over to the official IP-over-Ethernet encapsulation
    specifications, such as RFC 1042, “A Standard for the Transit of Internet Protocol
    Datagrams Over IEEE 802 Networks,”^([[66](apb.html#ftn.CHP-6-BIB-1)]) by requiring
    frames that were shorter than this minimum length to be padded. The padding can
    be carried out at will and has no effect on the carried data on the IP layer,
    as the packet length specified in the IP headers does not change. Thus, the padding
    will not be interpreted by the recipient as a part of higher-level OSI model traffic.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a slight problem. Although the RFC requires the padding to
    be initialized to zero, it does not specify who should provide and prepare the
    padding and at what software stage the padding should occur. The need for the
    padding to be of a particular value is also a requirement that in its nature is
    fairly arbitrary; hence, no attention is paid to it—setting it any other way would
    not impact how the protocol works, because the extraneous data is simply discarded
    upon receipt.
  prefs: []
  type: TYPE_NORMAL
- en: To add to the confusion, many network interface cards provide an autopadding
    feature if a packet the operating system sent to the hardware is too short—but,
    naturally, not to ensure the specific contents of a padding if frame size has
    been already taken care of in software. This led to wide-spread confusion among
    some developers who chose to obey the size requirement and extend the size of
    a packet in software by simply increasing its declared length. They often did
    not realize that the data between the end of the IP packet and the end of the
    padded frame was not prepared (initialized to zeros) by the driver, the operating
    system, or the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The problem went largely unnoticed for years, although it caused an awkward
    issue that regularly drove some network hackers insane. The packets they received
    from local systems often contained some extra garbage at the end—such as fragments
    of website contents or even chat conversations that were clearly irrelevant. They
    blamed the recipient (faulty equipment, the network traffic analysis application,
    libraries) but ultimately gave up looking for a cause because the issue was of
    marginal relevance. The issue never got the attention it deserved.
  prefs: []
  type: TYPE_NORMAL
- en: That is, not until Ofir Arkin and Josh Anderson of @Stake decided to give it
    a closer look in 2003\. Their paper “EtherLeak—Ethernet Frame Padding Information
    Leaks”^([[67](apb.html#ftn.CHP-6-BIB-2)]) examined the problem in more detail.
    The authors realized that a large number of mainstream systems, such as Linux,
    NetBSD, Microsoft Windows, and other platforms, fail to initialize the memory
    at the end of the newly prepared Ethernet frame after modifying its length. Some
    implementations even fail to change the size of a frame properly or to send a
    proper number of bytes to the hardware layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the IP packet is padded with data that happens to be stored in
    the portion of memory the system used previously for other purposes. The memory
    could contain part of a previously sent packet or some other kernel memory fragment,
    depending on the design of the driver or the operating system. This, of course,
    creates a fascinating information disclosure scenario: An attacker sends inconspicuous
    and legitimate traffic to the victim and, with some luck, obtains potentially
    sensitive information. The amount of information disclosed is typically sufficient
    to justify concern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The exposure is limited to a single Ethernet network and, as such, is fairly
    localized and noncritical in a typical LAN environment. Still, it definitely remains
    a problem of some significance, and even though any local network is partly vulnerable
    to snooping, this particular problem suggests some conclusions that extend beyond
    the most obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: On systems that use dynamic buffers for outgoing Ethernet frames (Linux, for
    example), the padding can expose not only the previous frame, but other memory
    contents, such as edited or viewed documents, URLs, passwords, or other sensitive
    resources. In this case, a careful observer might be able to gain access to information
    they could not otherwise intercept on the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On systems that use static buffers only to prepare Ethernet frames, the problem
    can be exploited to defeat systems that protect against traffic sniffing, such
    as switches, enabling the attacker to intercept data from a different connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In certain static buffer designs, information from another segment on a multihoned
    machine, with one network interface connected to a general LAN and the other interface
    hooked up to a restricted network, can be exposed, thus relaying portions of presumably
    secret data to the public infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authors of the paper extensively reviewed several open-source implementations
    and concluded that a variety of approaches and buffer layouts are commonly used
    and that there is no predominant buffer allocation and usage scheme. Their conclusion?
    A typical diverse network environment is likely to be affected by all three types
    of issues at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Food for Thought
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue discussed here is not unique to Ethernet or network design. These
    problems almost always arise when an otherwise detailed implementation guideline
    omits or only vaguely discusses a single necessary step, causing numerous developers
    to simply overlook the problem while implementing the standard. Had they been
    given more vague overall instructions, developers would probably be forced to
    think through the problem. Instead, they implement step-by-step instructions and
    are far more vulnerable to committing errors. “Foolproof” instructions that tell
    how to perform certain tasks, as opposed to what to achieve, often backfire.
  prefs: []
  type: TYPE_NORMAL
- en: We will return to the problems of protocol leak scenarios, albeit in a slightly
    different context, in [Part III](pt03.html "Part III. Out in the Wild") of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Secure in Switched Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Or, why Ethernet LANs cannot be quite fixed, no matter how hard we try*'
  prefs: []
  type: TYPE_NORMAL
- en: —
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet networks do not provide a universal and easy way to ensure the integrity
    or confidentiality of the data they transmit, nor are they engineered to with-stand
    malicious, intentionally injected traffic. Ethernet is merely a means for interfacing
    a number of local, presumably trusted systems.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming this level of trust is convenient at the design stage and is theoretically
    sufficient for peer systems on the same network and often at roughly the same
    physical location. But, as the old saying goes, only in theory is there no difference
    between theory and practice. In practice, there is a difference.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, local networks are difficult to fully control and must be protected
    from their own users as well as from external threats. Any expanding local network
    is bound to encounter a rogue user, whether from within the organization or from
    outside, exploiting a flaw in one of the systems. The occurrence of such an exploit
    is only a matter of time, as almost all network administrators learn at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Practical network security is the art of detecting incidents, minimizing exposure,
    and assessing and understanding the risk on all levels, not only an exercise in
    building perimeter defenses. The problem? A bare-bones Ethernet infrastructure
    is prone to all types of data interception, hijacking, and impersonation scenarios;
    once an intruder or a malicious but legitimate user controls a single system on
    the network—breaking through a single line of defense—this person can wreak havoc
    on the infrastructure and gain access or take over certain resources and services
    with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: Some Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethernet switches, a class of smart devices designed to route unicast traffic
    on the second OSI layer to the appropriate port instead of broadcasting it to
    all nodes (as is the case with hubs or direct connections), may appear to solve
    this problem. They are often thought to solve the security problems associated
    with the ability for one system to observe or hijack third-party traffic, but
    this is not so. The solution is not that simple, and the confusion caused by this
    presumption sometimes causes more harm than the switches could do good in the
    first place. But first things first. To understand the exposure, let’s look at
    how Ethernet switches really work.
  prefs: []
  type: TYPE_NORMAL
- en: Address Resolution and Switching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All communication within a local network is based on the addressing scheme discussed
    in [Chapter 5](ch05.html "Chapter 5. Blinkenlights"). Unique identifiers assigned
    by the hardware manufacturer to a specific endpoint device are used to address
    systems and deliver data frames. However, the Internet and most of today’s private
    networks are built around a more flexible and universal suite of protocols and
    use an addressing scheme on the third OSI layer, commonly known as Internet Protocol
    (IP) addresses. The IP address is first used to direct the traffic across the
    world to an appropriate local network using a hierarchy of routing tables on middle
    systems all over the globe; not until the packet reaches the perimeter of the
    destination network must the final recipient be located the old-fashioned way,
    by a hardware address lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a system on the local network decides to locate another local party
    with a specific IP address, it uses a special address resolution protocol (ARP)
    to determine the association between a physical card address—the basis for addressing
    systems on a local network—and the IP address, a universal internetworking system
    identifier.^([[68](apb.html#ftn.CHP-7-BIB-1)]) The sender distributes an ARP query
    to a special broadcast address on the local network. This reserved address is
    guaranteed to be received and processed by all systems on the network, regardless
    of the actual hardware address assigned to specific nodes. In this scenario, the
    system that considers itself to have the right to use the IP address specified
    in the query is expected to send a response to the sender, thus disclosing its
    hardware address in answer to the query; all other folks are supposed to silently
    ignore the broadcast ARP packet. After this exchange, both parties now know each
    other’s IP and media access control (MAC) addresses. They should cache the finding
    in a special buffer to eliminate the need to perform additional lookups every
    time a portion of data is exchanged and then proceed with the actual communications—but
    other than that, they are ready to swap some packets based on IP addressing. This
    design is a charming and delightful example of an old-time trust and courtesy.
    But what can be done to contain the exposure caused by a malicious bystander on
    the same network, who pretends to be someone else, and what can be done to prevent
    the more curious users or evil foes from reaching too far? Manufacturers of the
    Ethernet hardware most certainly did not help network administrators by making
    it possible and trivial to change MAC addresses on most of today’s devices—presumably
    allowing the user to reprogram then in order not to end up in trouble should one
    day a batch of cards turn out to have duplicate addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Again, switches appear to solve the problem. The basic design concept behind
    a smart switching device relies on duplicating the MAC address cache on the level
    of an interim network device. A switching device is equipped with numerous Ethernet
    ports, each of which connects to a single system (or, less often, a set of systems).
    But instead of serving as dumb repeaters, sending all traffic received on one
    port to all others (as Ethernet hubs do), switches attempt to memorize MAC addresses
    associated with a machine connected to each port, effectively creating MAC-to-port
    associations, as opposed to the MAC-to-IP mappings created by endpoint systems.
  prefs: []
  type: TYPE_NORMAL
- en: The data, stored in content addressable memory^([[14](#ftn.CHP-7-FN-1)]) (CAM),
    determines where to deliver incoming packets. Whenever a portion of traffic arrives,
    the switch attempts to determine which port the addressee is on. If this information
    is available, the packet is delivered directly (and only) to this particular port,
    keeping the information away from others and improving network performance.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Networks and Traffic Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some more advanced switch solutions provide additional features intended to
    make it easier to manage extensive networks and to lower deployment times and
    expenses. These features also appear to help with network security and may include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual LAN (VLAN)**'
  prefs: []
  type: TYPE_NORMAL
- en: A general name for a set of methods used to divide a pool of ports on a physical
    device into a set of separate logical networks, thus separating traffic on a group
    of ports from others and preventing any kind of traffic from crossing between
    those groups on the switch level. (This scheme is most commonly implemented using
    the IEEE 802.1Q standard, discussed in the next item in detail.) Implementing
    a VLAN is like splitting a single switch into several fully independent devices,
    except that the VLAN solution is far more flexible and cost-effective, because
    it is possible to reshape your network and reallocate physical resources at will.
    VLANs were met with a warm welcome by network staff everywhere because they promised
    to offer a simple yet powerful way to build a set of separate networks on a single
    device or, for example, separate servers from workstations, without the need to
    buy a dedicated switch for each group.
  prefs: []
  type: TYPE_NORMAL
- en: '**Trunking**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A natural extension of the baseline VLAN design. Trunks use the IEEE 802.1Q
    frame-tagging scheme to tunnel multiple VLAN traffic over a single link, instead
    of forcing the user to run separate wire for every VLAN to be populated to another
    device, as shown in [Figure 7-1](ch07.html#vlan_trunking_in_action._vlans_propagate
    "Figure 7-1. VLAN trunking in action. VLANs propagated across two devices. Devices
    on all instances of both VLAN #1 and VLAN #2 can talk with each other, but cross
    talk between VLAN #1 and VLAN #2 is not possible."). Packets from all or some
    VLANs on the source switch are tagged with enough information to determine their
    originating VLAN within the Ethernet frame header, tunneled to the other endpoint
    over a traditional link, decoded, and then pushed out into appropriate VLANs at
    the destination. Although this option usually results in lower performance than
    running a separate cable for every subnet, it is much more practical. Trunked
    systems often also feature DTP (Dynamic Trunking Protocol), a trunk autoconfiguration
    protocol that enables devices to automatically discover and exchange encapsulated
    frames other trunk-enabled devices with no special administrative actions required.'
  prefs: []
  type: TYPE_NORMAL
- en: '![VLAN trunking in action. VLANs propagated across two devices. Devices on
    all instances of both VLAN #1 and VLAN #2 can talk with each other, but cross
    talk between VLAN #1 and VLAN #2 is not possible.](httpatomoreillycomsourcenostarchimages1138044.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1. VLAN trunking in action. VLANs propagated across two devices. Devices
    on all instances of both VLAN #1 and VLAN #2 can talk with each other, but cross
    talk between VLAN #1 and VLAN #2 is not possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spanning tree protocol (STP)**'
  prefs: []
  type: TYPE_NORMAL
- en: Lets you build redundant network structures in which switches are interconnected
    in more than one location, in order to maintain fault tolerance. Traditionally,
    such a design could cause broadcast traffic and some other packets to loop forever
    while also causing network performance to deteriorate significantly, because the
    data received on one interface and forwarded to another in effect bounces back
    to the originator (see [Figure 7-2](ch07.html#packet_storm_problem_and_stp_election_sc
    "Figure 7-2. Packet storm problem and STP election scheme; left side shows a fault-tolerant
    network with no STP, where some packets are bound to loop (almost) forever between
    switches; right side is the same network where one of the devices was automatically
    elected a master node using STP, and for which the logical topology was adjusted
    to eliminate loops. When one of the links fails, the network would be reconfigured
    to ensure proper operations."), left).
  prefs: []
  type: TYPE_NORMAL
- en: When designing a network, it is often difficult to avoid accidental broadcast
    loops. It is also sometimes desirable to design architectures with potential loops
    (in which one switch connects to two or more switches), because this type of design
    is much more fault tolerant and a single device or single link can be taken out
    without dividing the entire network into two separate islands.
  prefs: []
  type: TYPE_NORMAL
- en: To make it possible to build loops and other nontrivial architectures without
    causing serious performance problems, STP implements an election mechanism to
    select a “root” node switch. Based on the result of this election, a treelike
    traffic distribution hierarchy is built from this node down, and links that could
    cause a reverse propagation of broadcast traffic are temporarily disabled (see
    [Figure 7-2](ch07.html#packet_storm_problem_and_stp_election_sc "Figure 7-2. Packet
    storm problem and STP election scheme; left side shows a fault-tolerant network
    with no STP, where some packets are bound to loop (almost) forever between switches;
    right side is the same network where one of the devices was automatically elected
    a master node using STP, and for which the logical topology was adjusted to eliminate
    loops. When one of the links fails, the network would be reconfigured to ensure
    proper operations."), right). You can quickly change this simple self-organizing
    hierarchy when one of the nodes drops off and reactivate a link previously deemed
    unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: '![Packet storm problem and STP election scheme; left side shows a fault-tolerant
    network with no STP, where some packets are bound to loop (almost) forever between
    switches; right side is the same network where one of the devices was automatically
    elected a master node using STP, and for which the logical topology was adjusted
    to eliminate loops. When one of the links fails, the network would be reconfigured
    to ensure proper operations.](httpatomoreillycomsourcenostarchimages1138046.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2. Packet storm problem and STP election scheme; left side shows a
    fault-tolerant network with no STP, where some packets are bound to loop (almost)
    forever between switches; right side is the same network where one of the devices
    was automatically elected a master node using STP, and for which the logical topology
    was adjusted to eliminate loops. When one of the links fails, the network would
    be reconfigured to ensure proper operations.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#CHP-7-FN-1)]) As its name suggests, this type of memory can be directly
    addressed by the parameter for which you are trying to determine the value, which
    saves time that would normally have to be spent on searching for the parameter.
    A library catalog is a trivial example of CAM—you do not need to go through all
    the books in the library just to find one; you determine where to look based on
    what you are looking for (a piece of information about the “content”).
  prefs: []
  type: TYPE_NORMAL
- en: Attacking the Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mechanisms discussed so far were engineered to improve the bottom line while
    providing high performance, on top of a network design that provides no security
    features whatsoever.^([[69](apb.html#ftn.CHP-7-BIB-2)]) Although certain common,
    well-understood, and easy-to-prevent attacks, such as *MAC spoofing* (the ability
    for any person to spoof an ARP message and impersonate a device with a particular
    IP) are widely recognized as a pitfall of local area networking and are easy to
    prevent with properly configured switches, some other serious design flaws are
    not so trivial and, in fact, not prevented so easily. It is not always obvious
    that solutions commonly perceived as designed to improve security in fact do nothing
    to help it.
  prefs: []
  type: TYPE_NORMAL
- en: CAM and Traffic Interception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the more spectacular reasons not to consider switches as a security feature
    is the *CAM overflow* scenario. The CAM that stores MAC-to-port associations has
    a fixed and limited size and is generally constructed in a nondiscriminatory manner.
    Whenever a system cannot be located in CAM, the switch has but one way to deliver
    the packet—it must fall back to the hub mode, broadcasting the packet to all systems,
    hoping the recipient will recognize this traffic as addressed to himself and that
    other systems will be nice enough to disregard it altogether. Thus, a careful
    attacker can employ a tactic to generate a large number of bogus ARP requests
    and responses, or some other packets, impersonating a vast number of separate
    network devices, just to fill up the switch’s CAM. Once the CAM is full, the attack
    has effectively degraded the network security by disabling smart frame routing
    on the switch and forcing it to fall back to broadcasting all data. This, in turn,
    allows the attacker to snoop on all communications, as if the network was not
    switched at all. The attacker can do all this without impersonating the recipient
    or visibly affecting the operations of the network, so the victim might well remain
    completely unaware of this problem. This is a design issue; it is not a flaw in
    the intended purpose of these devices, but a serious misconception in the popular
    understanding of how switches work. And, rest assured, it is nearly impossible
    to fully address this problem in a typical environment. Some switches do implement
    port and time limits to prevent such attacks, but these are never 100 percent
    effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other Attack Scenarios: DTP, STP, Trunks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other problems are usually easier to prevent and remain more evident (can be
    often detected by the victim), but still illustrate Ethernet-level security issues.
    For example, an attack on the aforementioned DTP mechanism is one interesting
    possibility. DTP autonegotiation is often enabled for all ports on a device in
    order to provide easier setup. The problem is that a clever attacker can hence
    pretend to be a trunk-enabled switch, rather than a mere end-user workstation
    or a humble server; once recognized by the switch it is connected to as a friendly
    device, he would start receiving 802.1Q tagged frames, including traffic in other
    virtual LANs served by the switch it is connected to, being able to intercept
    or inject malicious traffic to networks with which he is not supposed to be able
    to communicate. In many networks where the same switch handles both protected,
    “demilitarized” networks and common corporate LAN infrastructure, such an attack
    may be yield very useful data by enabling members of one of the networks to snoop
    on or interact with the other.
  prefs: []
  type: TYPE_NORMAL
- en: You can resolve this DTP problem on some devices by changing the default configuration
    and clearly defining a set of dedicated trunk-enabled ports on the switch. However,
    the problem does not end here—our other friend, STP, can be abused in a similar
    manner, allowing an attacker to choose self as the “root” switch and receive a
    cut of the network traffic. Disabling STP discovery might be even more difficult
    in a typical corporate environment.
  prefs: []
  type: TYPE_NORMAL
- en: Still another problem arises when any trunk originates or terminates at a nondedicated
    VLAN. (That is, the port used for trunking is placed in a VLAN also used by workstations.)
    By injecting already tagged frames, it is possible to inject traffic to a trunk.
    This is arguably a configuration flaw, and the problem is often overlooked, since
    many engineers assume the method for implementing trunks is far more advanced
    and magical than it really is.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention of Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These problems are often difficult to solve, particularly in a network that
    was not firmly and closely supervised through all phases of its development and
    expansion. Although certain high-end devices provide extended security features
    to counter potential attack vectors and mitigate or eliminate some of the risks,
    Ethernet networks were not designed to provide security, nor were many of the
    smart devices created to manage these networks. The attacker can easily render
    some or all of their features useless and downgrade the network security model
    to the least desirable option.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are methods and rigid practices to follow in order to secure
    a local Ethernet network, the complexity of this process and the additional financial
    cost and performance impact that doing so often carries, let alone the number
    of vectors to be addressed, all make it obvious that the technology was not engineered
    with any level of practical security in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Food for Thought
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Ethernet was developed, it seemed reasonable to disregard any security
    considerations in the design decisions and to leave the burden of securing the
    network to higher-level architecture, encryption, and so on. Over time, however,
    this initial decision has begun to contribute to the overall maintenance costs
    of Ethernet networks and the difficulty of keeping them reasonably hack proof
    without sacrificing functionality in some ways.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is hardly limited to the Ethernet, either. Many networks designed
    to be trusted based on physical-access or equipment-access criteria—including,
    for example, most of the world’s phone systems—are inherently and uncontrollably
    exposed to internal threats with little or no way to efficiently contain the exposure
    and control the collateral damage resulting from a single-system compromise within
    the grid. As the size of the network grows, and the number of interchanges increases,
    the probability of one of the systems being operated by a malicious user or insufficiently
    protected either on physical or remote access steadily approaches 1\. Although
    traditionally, access to the backbone, rather than access to an end-user station,
    would be required to compromise the system—thus making the situation somewhat
    different from Ethernet—nowadays, Voice-over-IP (VoIP) systems quickly make up
    for this inconvenience, frequently allowing easy spoofing and other trickery by
    putting too much trust on the user endpoint side.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Us versus Them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*What else can happen in the local perimeter of “our” network? Quite a bit!*'
  prefs: []
  type: TYPE_NORMAL
- en: —
  prefs: []
  type: TYPE_NORMAL
- en: Local network designs, such as the Token Ring or now predominant Ethernet, were
    engineered under the assumption that there was no need to assure security on the
    level (or layer) of the technology used to transmit the data itself. When computers
    were first developed, users sharing a network were expected to play nice.
  prefs: []
  type: TYPE_NORMAL
- en: Although for this reason alone one might assume that the designers of Ethernet
    would have seen no need to incorporate full-fledged security functionality into
    their design, they are to be blamed for the unwarranted optimism and not foreseeing
    the inevitable. Ethernet simply did not leave space to easily implement integrity,
    confidentiality, and sender-verification mechanisms at higher-order OSI layers,
    devices, and applications. Subsequent protocols and communication schemes attempted
    to implement partial privacy and a level of undeniability of communications—but
    only to reach a point where we realized it is not possible to implement adequate
    security there without going back and reworking the link layer. The only other
    possibility we were left with was building computationally expensive and complex
    cryptographic hacks on top of the system, of which the sheer complexity contributes
    to a number of security problems discovered year after year.
  prefs: []
  type: TYPE_NORMAL
- en: This unfortunate and later quite intentional trend had effectively created a
    set of networking mechanisms that, although they perform well and are affordable,
    are not suitable for handling even moderately sensitive data in the presence of
    a hostile party (and almost all user-related data flow on a local network is sensitive).
    Solutions that try to address these problems—such as virtual private network (VPN)
    applications, encrypted encapsulation for the lucky few of the most popular web
    protocols, advanced switches, and so forth—are usually far more expensive and
    sophisticated than they could have been had security been a key factor when devising
    the initial concept for an Ethernet communications scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Before we arrived there, we lived in partial denial for quite a while. When
    security became a real-world concern (with the expansion of the Internet and a
    sudden proliferation of system compromises), the first defenses to appear focused
    on the external world, while ignoring threats that could come from within the
    “trusted” network. But it wasn’t too long before a couple of corporate and institutional
    entities learned some painful lessons. With time, it became obvious that external
    defenses such as firewalls and intrusion detection systems alone were not enough,
    even when properly configured across the enterprise. The network layer was still
    vulnerable, allowing an insider to compromise data exchanges without exploiting
    the security vulnerabilities of any single system in the company.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can argue that the network could be secured by deploying appropriate
    encryption and cryptographic identity and integrity verification mechanisms on
    all interfaces, that is often impractical or impossible, particularly without
    impacting the performance and reliability of the network and incurring significant
    costs (not to mention the issues of compatibility with various operating systems
    and applications). Besides, as I have mentioned, cryptography is not always the
    answer: not only is it much easier to successfully attack when the data can be
    seen and intercepted (replay or timing attacks, for example), but certain types
    of information—such as the Ethernet frame-padding flaw discussed previously—can
    thwart all efforts to protect the user.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Part II](pt02.html "Part II. Safe Harbor") of this book, we are addressing
    some of the threats inherent in local networks that expose information without
    a traditional attack ever occurring. All these problems will remain with us as
    long as networks use the old and tested design that is rather ill-suited for networking
    today.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to move forward, but before we dive into the wild and fascinating
    world beyond the local perimeter, let’s glance at some other interesting (and
    more specific) exposure scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Blinkenlights and Their Unusual Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One such example relates to the abuse of logical indicators—that is, counters,
    flags, and other gizmos that have no physical representation but, rather, are
    maintained by a computer and made available in software, commonly implemented
    in local networks. Logical indicators are a helpful feature that, once again,
    assume that the local network is to be trusted.
  prefs: []
  type: TYPE_NORMAL
- en: The Simple Network Management Protocol^([[70](apb.html#ftn.CHP-8-BIB-1)]) (SNMP)
    is the most popular method for monitoring and sometimes administrating network
    devices. SNMP is often implemented on endpoint systems (servers and workstations)
    as well as network devices, such as switches, routers, and printers.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP provides a means for reading (or modifying) an abstract representation
    of many system and application internals, operational and configuration parameters,
    and statistics. Using SNMP, you can query a network printer about the number of
    network cards it has or its uptime and then use exactly the same method to query
    a mainframe for the same information, even though the information needs to be
    obtained internally by the device in a wholly different way on each system. Hence,
    SNMP makes it easy to monitor and manage heterogeneous environments without implementing
    a multitude of native access protocols and check procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, SNMP itself has plenty of implementation and deployment security
    issues, but that is not my point here. Even when properly implemented, this functionality
    can lead to a security information disclosure, such as providing read-only access
    to the seemingly irrelevant statistics of a network interface. (This hole is eliminated
    if the protocol is carefully restricted, but that is often impossible on certain
    types of network equipment.) A careful attacker can observe frame or packet counters
    on a system running SNMP and use that information to derive profiling information
    needed for timing attacks, which can recover interactive session information or
    other interesting characteristics, in a manner similar to the approach discussed
    in [Chapter 1](ch01.html "Chapter 1. I Can Hear You Typing").
  prefs: []
  type: TYPE_NORMAL
- en: Whoops. But really, can this much bad happen because of this?
  prefs: []
  type: TYPE_NORMAL
- en: Show Me Your Typing, and I Will Tell You Who You Are
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although I’ve mentioned this class of problems several times already, and they
    may seem abstract, their consequences are real, even when the keystroke reconstruction
    vector, on which I focused in [Chapter 1](ch01.html "Chapter 1. I Can Hear You
    Typing"), is disregarded. For example, in a fascinating development, a group of
    German researchers from Institut für Bankinnovation have created a commercial
    product, PSYLock, that provides typing-pattern-based biometrics^([[71](apb.html#ftn.CHP-8-BIB-2)]):
    Using PSYLock they have been able to uniquely identify (and hence possibly track)
    users by examining how they use the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: PSYLock relies primarily on measurements of interkeystroke timing, a trick I
    discussed previously. Given the ability to observe packet counters for a specific
    machine and calculate when, in an interactive session, a key is pressed by the
    user, you can identify a person regardless of which terminal they use. Some interesting
    applications, both malicious and supervisory in nature, can be suggested based
    on the application of this concept to the network layer. If the attacker knows
    that there is an interactive session of some remote access protocol between a
    station for which they can monitor SNMP switch port statistics, they can, by repeatedly
    polling the counter, determine when keys are pressed and, hence, draw conclusions
    as to what is being typed or who is typing.
  prefs: []
  type: TYPE_NORMAL
- en: A more lightweight variant of the attack, not requiring any of the advanced
    modeling that we had to cope with before, is also feasible. In their Bugtraq posting
    titled “Passive Analysis of SSH (Secure Shell) Traffic,”^([[72](apb.html#ftn.CHP-8-BIB-3)])
    Solar Designer and Dug Song, among other things suggest yet another possible attack,
    this time using the SSH protocol, a common method for connecting to a remote system.
    Although SSH is encrypted, in versions released prior to their research it is
    possible to measure the length of a password by carefully analyzing the size of
    an observed packet during login (the password is sent in a single chunk of data
    once entered by the user).
  prefs: []
  type: TYPE_NORMAL
- en: This technique could well be successfully applied to other cryptographic protocols
    that do not take active measures to hide the length of a password by padding it
    before sending. And, no suprise, the attack can be carried out simply by observing
    an SNMP byte counter, rather than by directly monitoring traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unexpected Bits: Personal Data All Around'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yet another reason we should not be thrilled by the prospect of a hostile party
    peeking at our network (regardless of whether we believe the data they can see
    is sensitive) is that plenty of software violates the principle of least astonishment.
    The principle of least astonishment is a fundamental rule of software design that
    basically says that a program should respond to the user in ways that surprise
    them least—in a consistent, intuitive, predictable, or otherwise expected manner.
    As it turns out, many programs from several software publishers send an amazing
    amount of valuable information, far beyond what we might expect, often putting
    users in a situation they did not bargain for. As always, Microsoft Windows leads
    the pack of these astonishing programs and does a great job of releasing information
    in intentional, but often overlooked and nonobvious ways, but the friendly software
    giant is not alone.
  prefs: []
  type: TYPE_NORMAL
- en: Although few users know it, when Windows is working in a domain and is configured
    to use roaming profiles to enable the user to log in from a different workstation
    and access their personal data, large portions of the user’s registry are sent
    to the domain controller each time they log in or out. Although the information
    contained in the profile may seem quite worthless at first, it includes various
    personal settings and history information that can be quite interesting, including
    last-executed commands, last-visited web pages, and last-opened documents.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, and perhaps even more astonishing, if a user’s home directory within
    the domain resides on a network drive, Windows looks up all commands entered by
    the user in the Run box first on the remote server and then locally. Thus, the
    information about all commands issued by the user is disclosed via the Server
    Message Block (SMB) protocol to a careful observer.
  prefs: []
  type: TYPE_NORMAL
- en: These and many other examples make it painfully obvious that almost all network
    data should be assumed to be sensitive. As such, local networks at large are not
    particularly well suited to transport any commonly occurring data, except for
    specific, limited, or additionally protected setups. And we have no good way to
    protect this information without rolling out heavy artillery, such as cryptographic
    IP tunnels or similar software or by redesigning every aspect of networking from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It would be unfair to close this chapter and ignore the problems with the wireless
    replacement to Ethernet: wi-fi.'
  prefs: []
  type: TYPE_NORMAL
- en: Wireless networks based on the IEEE 802.11 protocol are gaining momentum in
    the corporate world, as well as among ordinary home users. Unfortunately, even
    long before gaining widespread acceptance, and even though they were designed
    with the intent to maintain a level of additional security over wired hookups,
    wi-fi proved fairly difficult to deploy properly, perhaps because it attempted
    to follow in the footsteps of its older brother a bit too closely.
  prefs: []
  type: TYPE_NORMAL
- en: The 802.11 standard is, in its operating principles, not that much different
    from Ethernet. It uses a traditional “one can talk, others listen” media access
    control scheme, the only difference being that instead of a pair of wires, the
    carrier of the signal is now just a designated radio frequency. Which brings us
    to 802.11’s first problem.
  prefs: []
  type: TYPE_NORMAL
- en: In May 2004, the Queensland University of Technology’s Information Security
    Research Centre (ISRC) announced its findings that any 802.11 network in any enterprise
    could be brought to a grinding halt in a matter of seconds simply by transmitting
    a signal that inhibits other parties from trying to talk. Naturally, the same
    is true for Ethernet, except that you must be able to connect to a network plug
    first, which of course makes the attacker much easier to track and the problem
    easier to solve. You can simply check the switch then follow the cable. This attack
    is not exactly a surprise, but it’s not what business adopters expected either.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not where the problems end. Where the 802.11 standard attempted to thwart
    carrier-level attacks, it actually failed miserably. The Wired Equivalent Privacy
    (WEP) mechanism was designed for wi-fi networks to provide a level of protection
    against eavesdropping on network sessions by external parties, thus providing
    security roughly comparable to traditional LANs. However, a number of design flaws
    in the WEP scheme were found in 2001 by researchers from the University of California
    and Zero Knowledge Systems, which proved the scheme grossly inappropriate. Regrettably,
    even by that time wi-fi had been deployed widely enough to make necessary modifications
    difficult to implement.^([[73](apb.html#ftn.CHP-8-BIB-4)])
  prefs: []
  type: TYPE_NORMAL
- en: To add insult to injury, use of WEP is optional, and most wireless network devices
    have WEP turned off; they’re ready to accept and relay any traffic they receive.
    Although this is generally acceptable with wired networks, where an additional
    layer of security is provided on the physical level, wireless networks are open
    to any random person within range.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracy Reed’s warflying adventure (courtesy of Tracy Reed of Copilot Consulting
    at treed@copilotconsulting.com)](httpatomoreillycomsourcenostarchimages1138048.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. Tracy Reed’s warflying adventure (courtesy of Tracy Reed of Copilot
    Consulting at [treed@copilotconsulting.com](mailto:treed@copilotconsulting.com))
  prefs: []
  type: TYPE_NORMAL
- en: The practice of wardriving—equipping a car with a wi-fi–capable laptop and going
    on urban network-finding expeditions—became extremely popular once it was discovered
    that a majority of large businesses—particularly in large shopping malls and commercial
    districts in every city—have partly or fully open wireless networks. The abuse
    is often quite trivial, ranging from networking for free to sending spam or conducting
    remote attacks through the victim’s network, but the risk of a network being penetrated
    from inside by a skilled attacker is real.
  prefs: []
  type: TYPE_NORMAL
- en: What is the true scale of the problem? Suffice it to say that at some point
    wardriving became passé with the birth of warflying (wardriving, but with a plane
    rather than a ground vehicle). In 2002, Tracy Reed of Copilot Consulting decided
    to fly around and vicinity with a wireless scanner. Cruising at 1,500 feet, he
    managed to find nearly 400 access points with default configurations and likely
    free network access to the Internet or internal corporate networks for any person
    nearby (see [Figure 8-1](ch08s03.html#tracy_reedas_warflying_adventure_open_pa
    "Figure 8-1. Tracy Reed’s warflying adventure (courtesy of Tracy Reed of Copilot
    Consulting at treed@copilotconsulting.com)") and [Figure 8-2](ch08s03.html#silicon_valley_warflying
    "Figure 8-2. Silicon Valley warflying")). Only 23 percent of the devices scanned
    were protected by WEP (which is, in general, easy to crack anyway) or better mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Go figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Silicon Valley warflying](httpatomoreillycomsourcenostarchimages1138050.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. Silicon Valley warflying
  prefs: []
  type: TYPE_NORMAL
