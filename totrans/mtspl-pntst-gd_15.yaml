- en: Chapter 15. Porting Exploits to the Metasploit Framework
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章：将漏洞利用程序移植到Metasploit框架
- en: You can choose to convert exploits to Metasploit from a different format for
    many reasons, not the least of which is to give back to the community and the
    Framework. Not all exploits are based on the Metasploit Framework; some are programmed
    in Perl and Python or C and C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择从不同的格式将漏洞利用程序转换为Metasploit，原因有很多，其中之一是回馈社区和框架。并非所有漏洞都基于Metasploit框架；一些是用Perl和Python或C和C++编写的。
- en: When you port exploits to Metasploit, you convert an existing stand-alone exploit,
    such as a Python or Perl script, for use within Metasploit. And, of course, after
    you have imported an exploit into the Framework, you can leverage the Framework’s
    many high-end tools to handle routine tasks, so that you can concentrate on what
    is unique about your particular exploit. In addition, although stand-alone exploits
    often depend on your using a certain payload or operating system, once ported
    to the Framework, payloads can be created on the fly and the exploit can be used
    in multiple scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将漏洞利用程序移植到Metasploit时，您将现有的独立漏洞利用程序（如Python或Perl脚本）转换为在Metasploit中使用。当然，在您将漏洞利用程序导入框架后，您可以利用框架的许多高端工具来处理常规任务，这样您就可以专注于您特定漏洞的独特之处。此外，尽管独立的漏洞利用程序通常依赖于您使用特定的有效载荷或操作系统，但一旦移植到框架中，有效载荷可以即时创建，漏洞利用程序可以在多种场景中使用。
- en: This chapter will walk you through the process of porting two stand-alone exploits
    to the Framework. With your knowledge of these basic concepts and a bit of hard
    work on your part, you should be able to begin porting exploits into the Framework
    yourself by the end of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导您将两个独立的漏洞利用程序移植到框架中。通过您对这些基本概念的了解以及您的一点点努力，您应该能够在本章结束时开始自己将漏洞利用程序移植到框架中。
- en: Assembly Language Basics
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编语言基础
- en: To get the most out of this chapter, you’ll need a basic understanding of the
    assembly programming language. We use a lot of low-level assembly language instructions
    and commands in this chapter, so let’s take a look at the most common ones.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用本章内容，您需要对汇编编程语言有一个基本的了解。我们在本章中使用了大量的底层汇编语言指令和命令，所以让我们看看最常见的几个。
- en: EIP and ESP Registers
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EIP和ESP寄存器
- en: '*Registers* are placeholders that store information, perform calculations,
    or hold values that an application needs in order to run. The two most important
    registers for the purposes of this chapter are *EIP*, the extended instruction
    pointer register, and *ESP*, the extended starter pointer register.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*寄存器*是存储信息、执行计算或保留应用程序运行所需值的占位符。就本章而言，最重要的两个寄存器是*EIP*，即扩展指令指针寄存器，和*ESP*，即扩展起始指针寄存器。'
- en: The value in EIP tells the application where to go after it has executed some
    code. In this chapter, we’ll overwrite our EIP return address and tell it to point
    to our malicious shellcode. The ESP register is where, in our buffer overflow
    exploit, we would overwrite the normal application data with our malicious code
    to cause a crash. The ESP register is essentially a memory address and placeholder
    for our malicious shellcode.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: EIP中的值告诉应用程序在执行一些代码后去哪里。在本章中，我们将覆盖我们的EIP返回地址，并告诉它指向我们的恶意shellcode。ESP寄存器是我们缓冲区溢出漏洞中用来覆盖正常应用程序数据并导致崩溃的恶意代码的地方。ESP寄存器本质上是一个内存地址，也是我们恶意shellcode的占位符。
- en: The JMP Instruction Set
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JMP指令集
- en: The *JMP instruction set* is the “jump” to the ESP memory address. In the overflow
    example that we’ll explore in this chapter, we use the JMP ESP instruction set
    to tell the computer to go to the ESP memory address that happens to contain our
    shellcode.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*JMP指令集*是跳转到ESP内存地址的“跳转”。在本章将要探讨的溢出示例中，我们使用JMP ESP指令集告诉计算机跳转到ESP内存地址，该地址恰好包含我们的shellcode。'
- en: NOPs and NOP Slides
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NOP指令和NOP滑动
- en: A *NOP* is a no-operation instruction. Sometimes when you trigger an overflow,
    you won’t know exactly where you’re going to land within the space allocated.
    A NOP instruction simply says to the computer “Don’t do anything if you see me,”
    and it is represented by a \x90 in hexadecimal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*NOP*（无操作）指令。有时在触发溢出时，您可能不知道您将确切地落在分配空间中的哪个位置。NOP指令只是告诉计算机“如果你看到我，不要做任何事情”，并以十六进制的\x90表示。'
- en: A *NOP slide* is a handful of NOPs, combined to create a slide to our shellcode.
    When we go through and actually trigger the JMP ESP instructions, we will hit
    a bunch of NOPs, which will slide down until we hit our shellcode.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*NOP slide*是一系列NOP指令的组合，用来创建到我们的shellcode的滑动。当我们实际触发JMP ESP指令时，我们会遇到一些NOP指令，这些指令会滑动直到我们到达shellcode。'
- en: Porting a Buffer Overflow
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将缓冲区溢出移植到其他平台
- en: Our first example is a typical remote buffer overflow that needs only a jump
    to the extended stack pointer (JMP ESP) instruction to reach the shellcode. This
    exploit, called the “MailCarrier 2.51 SMTP EHLO / HELO Buffer Overflow Exploit,”
    uses MailCarrier 2.51 SMTP commands to cause a buffer overflow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子是一个典型的远程缓冲区溢出，只需要一个跳转到扩展堆栈指针（JMP ESP）指令来达到shellcode。这个漏洞利用被称为“MailCarrier
    2.51 SMTP EHLO / HELO 缓冲区溢出漏洞利用”，它使用MailCarrier 2.51 SMTP命令来引起缓冲区溢出。
- en: '* * *'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find the exploit and a vulnerable application at [http://www.exploit-db.com/exploits/598/](http://www.exploit-db.com/exploits/598/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://www.exploit-db.com/exploits/598/](http://www.exploit-db.com/exploits/598/)找到漏洞利用和易受攻击的应用程序。
- en: '* * *'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'But this is an older exploit, originally written for Windows 2000\. When you
    run it now, it doesn’t work quite as you’d expect. Conveniently, a Metasploit
    module is already in the Framework to implement this exploit, although it could
    use some improvement. After a little time investigating with varying buffer lengths,
    you will find that more than 1000 bytes are available for shellcode, and the buffer
    length needs to be adjusted by 4 bytes. (For more information on how this is accomplished,
    read “Exploit Writing Tutorial Part 1: Stack Based Overflows,” at [http://www.exploit-db.com/download_pdf/13535/](http://www.exploit-db.com/download_pdf/13535/).)
    The new proof of concept for this exploit follows: We have removed the shellcode
    and replaced the jump instruction with a string (*AAAA*) to overwrite the EIP
    register. (Proof of concept exploits contain the basic code necessary to demonstrate
    the exploit but do not carry an actual payload, and in many cases they require
    heavy modifications before they will work properly.)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个较老的漏洞利用程序，最初是为Windows 2000编写的。当你现在运行它时，它的工作方式并不完全符合你的预期。方便的是，Metasploit框架中已经有一个模块来实现这个漏洞利用，尽管它可能需要一些改进。经过一段时间使用不同缓冲区长度的调查，你会发现有超过1000个字节的shellcode可用，并且需要调整缓冲区长度4个字节。（关于如何实现这一点的更多信息，请阅读“漏洞编写教程第1部分：基于堆栈的溢出”，在[http://www.exploit-db.com/download_pdf/13535/](http://www.exploit-db.com/download_pdf/13535/)。）这个漏洞利用的新概念验证如下：我们移除了shellcode，并用字符串(*AAAA*)替换了跳转指令以覆盖EIP寄存器。（概念验证漏洞利用包含演示漏洞所需的基本代码，但不携带实际的有效负载，并且在许多情况下它们在正确工作之前需要大量修改。）
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you might imagine, the easiest and fastest way to port a stand-alone exploit
    to Metasploit is to modify a similar one from the Framework. And that’s what we’ll
    do next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，将独立的漏洞利用程序移植到Metasploit最快和最简单的方法是修改框架中的一个类似的漏洞利用程序。这就是我们接下来要做的。
- en: Stripping the Existing Exploit
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化现有的漏洞利用
- en: 'As our first step in porting the MailCarrier exploit, we’ll strip down the
    existing Metasploit module to a simple skeleton file, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在移植MailCarrier漏洞利用的第一步，我们将现有的Metasploit模块简化为一个简单的骨架文件，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because this exploit does not require authentication, we need only the mixin
    `Msf::Exploit::Remote::Tcp` shown at ![](../images/00002.gif). We’ve discussed
    mixins in previous chapters; you’ll recall that mixins allow you to use built-in
    protocols such as `Remote::Tcp` to perform basic remote TCP communications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个漏洞利用不需要身份验证，我们只需要如![](../images/00002.gif)所示的`Msf::Exploit::Remote::Tcp`混入。我们已经在之前的章节中讨论了混入；你会记得混入允许你使用内置协议，如`Remote::Tcp`，来执行基本的远程TCP通信。
- en: In the preceding listing, the target return address is set to the bogus value
    `Oxdeadbeef` at ![](../images/00004.gif), and the default TCP port is set to `25`
    at ![](../images/00005.gif). Upon connecting to the target, Metasploit will send
    the malicious attack using `sock.put` as shown at ![](../images/00006.gif) and
    craft our exploit for us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，目标返回地址被设置为无效值`Oxdeadbeef`在![](../images/00004.gif)，默认TCP端口被设置为`25`在![](../images/00005.gif)。连接到目标后，Metasploit将使用`sock.put`发送恶意攻击，如![](../images/00006.gif)所示，并为我们构建漏洞利用。
- en: Configuring the Exploit Definition
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置漏洞定义
- en: 'Let’s look at how we initially configure our exploit definition. We will need
    to feed the service a greeting as required by the protocol, a large buffer, a
    placeholder where we will take control of EIP, a brief NOP slide, and a placeholder
    for our shellcode. Here’s the code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们最初如何配置我们的漏洞定义。我们需要向服务提供协议要求的问候语，一个大的缓冲区，一个我们将控制 EIP 的占位符，一个简短的 NOP 滑动，以及我们的
    shellcode 的占位符。以下是代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The malicious buffer is built based on the original exploit code beginning with
    the `EHLO` command at ![](../images/00002.gif) followed by a long string of *A*s
    at ![](../images/00004.gif) (5093 of them), 4 bytes to overwrite the EIP register
    at ![](../images/00005.gif), a small NOP slide at ![](../images/00006.gif), and
    then some dummy shellcode at ![](../images/00007.gif).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意缓冲区基于原始漏洞利用代码构建，从 `EHLO` 命令开始，如 ![图 15-1](../images/00002.gif) 所示，后面跟着一长串
    *A* 字符（5093 个），4 个字节用于覆盖 EIP 寄存器，如 ![图 15-1](../images/00005.gif) 所示，然后是一个小的 NOP
    滑动，接着是一些虚拟 shellcode，如 ![图 15-1](../images/00007.gif) 所示。
- en: In this case, we’ve selected an interrupt (breakpoint) at ![](../images/00007.gif)
    so that execution will pause when it reaches our shellcode without us having to
    set a breakpoint.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在 ![图 15-1](../images/00007.gif) 处选择了一个中断（断点），这样当执行到达我们的 shellcode
    时，执行将暂停，而无需我们设置断点。
- en: Having configured the exploit section, we save the file as *mailcarrier_book.rb*
    at *modules/exploits/windows/smtp/*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 配置漏洞部分后，我们将文件保存为 *mailcarrier_book.rb* 在 *modules/exploits/windows/smtp/*。
- en: Testing Our Base Exploit
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们的基本漏洞利用
- en: 'In the next step, we load the module in *msfconsole*, set the required options,
    and configure a payload of `generic/debug_trap` (a great payload for exploit development
    that triggers a stop point when you are tracing the application in a debugger).
    Then we run the module:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们在 *msfconsole* 中加载模块，设置所需选项，并配置 `generic/debug_trap` 负载（一个用于漏洞开发的优秀负载，当你在调试器中跟踪应用程序时触发停止点）。然后我们运行模块：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We set the options as if we were running a normal exploit, except that we use
    the `generic/debug_trap` payload ![](../images/00002.gif) to test our exploit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置选项，就像我们正在运行一个正常的漏洞利用一样，除了我们使用 `generic/debug_trap` 负载（用于测试我们的漏洞利用）。
- en: After the module runs, the debugger should pause with EIP overwritten by *42424242*
    as shown in [Figure 15-1](part0019.html#mailcarrier_initial_overwrite); if you
    see a successful EIP overwrite of *42424242*, you know your exploit is working.
    Notice in [Figure 15-1](part0019.html#mailcarrier_initial_overwrite) that the
    EIP register points to 42424242 and that the NOP slide and the dummy payload have
    made it into the buffer as expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模块运行后，调试器应该暂停，EIP 被覆盖为 *42424242*，如图 [图 15-1](part0019.html#mailcarrier_initial_overwrite)
    所示；如果你看到成功的 EIP 覆盖为 *42424242*，你就知道你的漏洞利用正在工作。注意在 [图 15-1](part0019.html#mailcarrier_initial_overwrite)
    中，EIP 寄存器指向 42424242，并且 NOP 滑动和虚拟负载已按预期进入缓冲区。
- en: '![MailCarrier initial overwrite](../images/00054.jpeg)Figure 15-1. MailCarrier
    initial overwrite'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![MailCarrier 初始覆盖](../images/00054.jpeg)图 15-1. MailCarrier 初始覆盖'
- en: Implementing Features of the Framework
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现框架的功能
- en: Having proved that the basic skeleton of the module works by overwriting our
    EIP address, we can slowly start to implement the features of the Framework. We
    begin by setting the target return address (shown in bold in the following example)
    in the `'Targets'` block to a JMP ESP address. This is the same address that was
    used in the original exploit; it’s found in *SHELL32.DLL* on Windows XP SP2\.
    We need to find a legitimate return address to ensure that our code executes properly
    on the operating system we are targeting. Remember that some exploits work only
    on specific operating systems, as is the case with this exploit. We are using
    an address from *SHELL32.DLL*, which will change across different versions or
    service packs. If we were to find a standard JMP ESP in the application’s memory
    address, we would not need to use a Windows DLL and could make this exploit universal
    to all Windows platforms, because the memory addresses would never change.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过覆盖我们的 EIP 地址来证明模块的基本骨架工作后，我们可以缓慢地开始实现框架的功能。我们首先在 `'Targets'` 块中将目标返回地址（如下例中所示加粗）设置为
    JMP ESP 地址。这个地址与原始漏洞利用中使用的地址相同；它在 Windows XP SP2 的 *SHELL32.DLL* 中找到。我们需要找到一个合法的返回地址以确保我们的代码在目标操作系统中正确执行。记住，一些漏洞只在特定的操作系统上工作，就像这个漏洞一样。我们使用的是
    *SHELL32.DLL* 中的地址，这个地址会随着不同版本或服务包的变化而变化。如果我们能在应用程序的内存地址中找到一个标准的 JMP ESP，我们就不需要使用
    Windows DLL，并可以使这个漏洞利用适用于所有 Windows 平台，因为内存地址永远不会改变。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Metasploit will add the return address into the exploit at run time. You can
    replace the return address in the exploit block with `[target['Ret']].pack('V')`.
    This will insert the target return address into the exploit, reversing the bytes
    in little-endian format. (The endian-ness is determined by the target CPU’s architecture,
    and processors that are Intel-compatible use little-endian byte ordering.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit将在运行时将返回地址添加到漏洞利用中。您可以用`[target['Ret']].pack('V')`替换漏洞利用块中的返回地址。这将把目标返回地址插入到漏洞利用中，并以小端格式反转字节。（端序由目标CPU的架构决定，与Intel兼容的处理器使用小端字节序。）
- en: '* * *'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you declared more than one target, this particular line would select the
    proper return address based on the target you selected when running the exploit.
    Notice how moving the exploit to the Framework is already adding versatility.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明了多个目标，这条特定的线将根据你在运行漏洞利用时选择的目标选择正确的返回地址。注意，将漏洞利用移动到框架中已经增加了其多功能性。
- en: '* * *'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Re-executing the exploit module should result in a successful jump to the INT3
    dummy shellcode instructions, as shown in [Figure 15-2](part0019.html#a_successful_jump_to_dummy_shellcode_sem).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重新执行漏洞利用模块应该导致成功跳转到INT3虚拟shellcode指令，如图15-2所示。
- en: '![A successful jump to dummy shellcode; we are at our user control’s INT3 instructions.](../images/00055.jpeg)Figure 15-2. A
    successful jump to dummy shellcode; we are at our user control’s INT3 instructions.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![成功跳转到虚拟shellcode；我们处于用户控制的INT3指令处。](../images/00055.jpeg)图15-2. 成功跳转到虚拟shellcode；我们处于用户控制的INT3指令处。'
- en: Adding Randomization
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加随机化
- en: Most intrusion detections systems will trigger an alert when they detect a long
    string of *A*s traversing the network, because this is a common buffer pattern
    for exploits. Therefore, it’s best to introduce as much randomization as possible
    into your exploits, because doing so will break many exploit-specific signatures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数入侵检测系统在检测到跨越网络的长字符串*A*时会触发警报，因为这通常是漏洞的常见缓冲区模式。因此，最好尽可能多地对你的漏洞利用引入随机化，因为这样做将破坏许多针对特定漏洞的签名。
- en: 'To add randomness to this exploit, edit the `''Targets''` section in the super
    block to include the offset amount required prior to overwriting EIP, as shown
    here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要给这个漏洞利用添加随机性，编辑超级块中的`'Targets'`部分，包括在覆盖EIP之前所需的偏移量，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By declaring the `Offset` here ![](../images/00002.gif), you will no longer
    need to include the string of *A*s manually in the exploit itself. This is a very
    useful feature, because in some cases the buffer length will differ across different
    operating system versions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这里声明`Offset` ![](../images/00002.gif)，你将不再需要在漏洞本身中手动包含*A*字符串。这是一个非常有用的功能，因为在某些情况下，不同操作系统版本之间的缓冲区长度可能会有所不同。
- en: We can now edit the exploit section to have Metasploit generate a random string
    of uppercase alphabetic characters instead of the 5093 *A*s at runtime. From this
    point on, each run of the exploit will have a unique buffer. (We’ll use `rand_text_alpha_upper`
    to accomplish this, but we aren’t limited to this one engine. To see all available
    text formats, see the *text.rb* file located on Back|Track under */opt/metasploit/msf3/lib/rex/*.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编辑漏洞利用部分，让Metasploit在运行时生成一个随机的大写字母字符串，而不是5093个*A*。从现在开始，每次运行漏洞利用都将有一个唯一的缓冲区。（我们将使用`rand_text_alpha_upper`来完成此操作，但我们并不局限于这个引擎。要查看所有可用的文本格式，请参阅位于Back|Track下的`/opt/metasploit/msf3/lib/rex/*`目录中的`*text.rb*`文件。）
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the string of *A*s will be replaced with a random string of
    uppercase alphanumeric characters. And when we run the module again, it still
    works properly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，*A*字符串将被替换为随机的字符串，包含大写字母和数字。当我们再次运行模块时，它仍然可以正常工作。
- en: Removing the NOP Slide
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除NOP滑块
- en: 'Our next step is to remove the very obvious NOP slide, because this is another
    item that often triggers intrusion detection systems. Although `\x90` is the best-known
    no-operation instruction, it isn’t the only one available. We can use the `make_nops()`
    function to tell Metasploit to use random NOP-equivalent instructions in the module:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步要做的是移除非常明显的NOP滑块，因为这也是一个经常触发入侵检测系统的项目。尽管`\x90`是最著名的无操作指令，但它并不是唯一可用的。我们可以使用`make_nops()`函数来告诉Metasploit在模块中使用随机的NOP等效指令：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We run the module again and check our debugger, which should be paused again
    on the INT3 instructions. The familiar NOP slide has been replaced by seemingly
    random characters, as shown in [Figure 15-3](part0019.html#randomized_mailcarrier_buffer).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行模块并检查我们的调试器，它应该在INT3指令上再次暂停。熟悉的NOP滑动已被看似随机的字符所取代，如[图15-3](part0019.html#randomized_mailcarrier_buffer)所示。
- en: Removing the Dummy Shellcode
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除虚拟Shellcode
- en: With everything in the module working correctly, we can now remove the dummy
    shellcode. The encoder will exclude the bad characters declared in the module
    super block.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中的所有内容都正确工作后，我们现在可以移除虚拟Shellcode。编码器将排除模块超级块中声明的坏字符。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Randomized MailCarrier buffer](../images/00056.jpeg)Figure 15-3. Randomized
    MailCarrier buffer'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![随机化的MailCarrier缓冲区](../images/00056.jpeg)图15-3. 随机化的MailCarrier缓冲区'
- en: The `payload.encoded` function tells Metasploit to append the indicated payload
    to the end of the malicious string at run time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload.encoded` 函数告诉Metasploit在运行时将指定的有效载荷附加到恶意字符串的末尾。'
- en: 'Now, when we load our module, set a real payload, and execute it, we should
    be presented with our hard-earned shell, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们加载我们的模块，设置一个真实的有效载荷并执行它时，我们应该会看到我们辛苦获得的shell，如下所示：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our Completed Module
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们完成后的模块
- en: 'Just to wrap things up, here is the complete and final code for this Metasploit
    exploit module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 只为总结，以下是这个Metasploit漏洞利用模块的完整和最终代码：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ve just completed your first port of a buffer overflow exploit to Metasploit!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了第一个将缓冲区溢出漏洞利用程序移植到Metasploit的工作！
- en: SEH Overwrite Exploit
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SEH Overwrite Exploit
- en: In our next example, we’ll convert a Structured Exception Handler (SEH) overwrite
    exploit for Quick TFTP Pro 2.1 to Metasploit. SEH overwrites occur when you overwrite
    the pointer to the applications exception handler. In this particular exploit,
    the application triggers an exception, and when it arrives at the pointer over
    which you have control, you can direct execution flow to your shellcode. The exploit
    itself is a bit more complex than a simple buffer overflow, but it’s very elegant.
    In an SEH overwrite, we attempt to bypass the handler that tries to close an application
    gracefully when a major error or crash occurs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将Quick TFTP Pro 2.1的Structured Exception Handler (SEH)覆盖漏洞利用程序转换为Metasploit。SEH覆盖发生在你覆盖应用程序异常处理程序的指针时。在这个特定的漏洞利用程序中，应用程序触发一个异常，当它到达你控制的指针时，你可以将执行流程导向你的shellcode。这个漏洞利用程序本身比简单的缓冲区溢出复杂一些，但它非常优雅。在SEH覆盖中，我们试图绕过在发生重大错误或崩溃时尝试优雅关闭应用程序的处理程序。
- en: In the balance of this chapter, we’ll use the *POP-POP-RETN* technique to allow
    us to access our attacker-controlled memory space and gain full code execution.
    The *POP-POP-RETN* technique is commonly used to try to get around the SEH and
    execute our own code. The first *POP* in assembly pulls a memory address from
    the stack, essentially removing one memory address instruction. The second *POP*
    also pulls a memory address from the stack. The *RETN* returns us to a user-controlled
    area of the code, where we can begin executing our memory instructions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将使用*POP-POP-RETN*技术来允许我们访问攻击者控制的内存空间并获得完整的代码执行。*POP-POP-RETN*技术通常用于尝试绕过SEH并执行我们自己的代码。汇编中的第一个*POP*从堆栈中拉取一个内存地址，本质上移除了一个内存地址指令。第二个*POP*也从堆栈中拉取一个内存地址。*RETN*将我们返回到用户控制的代码区域，在那里我们可以开始执行我们的内存指令。
- en: '* * *'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about SEH overwrites, see [http://www.exploit-db.com/download_pdf/10195/](http://www.exploit-db.com/download_pdf/10195/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于SEH覆盖的信息，请参阅[http://www.exploit-db.com/download_pdf/10195/](http://www.exploit-db.com/download_pdf/10195/)。
- en: '* * *'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The Quick TFTP Pro 2.1 exploit was written by Muts. You can find the code for
    the complete exploit as well as the application at [http://www.exploit-db.com/exploits/5315/](http://www.exploit-db.com/exploits/5315/).
    We’ve stripped down the exploit here to make it simpler to port into Metasploit
    — for example, we’ve stripped out the payload. The remaining skeleton has all
    of the information we’ll need to use the exploit in Metasploit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Quick TFTP Pro 2.1 漏洞利用程序由Muts编写。您可以在[http://www.exploit-db.com/exploits/5315/](http://www.exploit-db.com/exploits/5315/)找到完整的漏洞利用程序代码以及应用程序。我们在这里简化了漏洞利用程序，使其更容易移植到Metasploit中——例如，我们移除了有效载荷。剩余的骨架包含了我们在Metasploit中使用漏洞所需的所有信息。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we did with our previous JMP ESP example, we first create a skeleton for
    our new module by using a base example of an exploit similar to the one we used
    previously:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的JMP ESP示例中所做的那样，我们首先通过使用与我们之前使用的类似漏洞的基例来为新模块创建一个骨架：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because this exploit uses the Trivial File Transfer Protocol (TFTP), we need
    to include the `Msf::Exploit::Remote::Udp` mixin shown at ![](../images/00002.gif).
    And because it manipulates the structured exception handler, we also need to include
    the `Msf::Exploit::Remote::Seh` mixin shown at ![](../images/00004.gif) to gain
    access to certain functions that deal with SEH overflows. Because TFTP servers
    typically listen on UDP port 69, we declare that port at ![](../images/00005.gif)
    as the default for the module. Lastly, once the malicious string is built, the
    code is put on the wire at ![](../images/00006.gif).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个漏洞利用使用了简单的文件传输协议（TFTP），我们需要包含![图](../images/00002.gif)中显示的 `Msf::Exploit::Remote::Udp`
    混合。由于它操作结构化异常处理程序，我们还需要包含![图](../images/00004.gif)中显示的 `Msf::Exploit::Remote::Seh`
    混合，以访问处理 SEH 溢出的一些函数。因为 TFTP 服务器通常监听 UDP 端口 69，我们在![图](../images/00005.gif)处将该端口声明为模块的默认端口。最后，一旦构建了恶意字符串，代码就被放在![图](../images/00006.gif)上。
- en: We begin by using the same skeleton from our original Python exploit earlier
    in this chapter for the TFTP exploit. We will be adding the major parts of it
    into our exploit section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始使用本章前面提到的原始 Python 漏洞的相同骨架来构建 TFTP 漏洞。我们将将其主要部分添加到我们的漏洞部分。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Following the initial string of *A*s (1019 of them, represented by `\x41` in
    hexadecimal), we add a short jump at ![](../images/00002.gif) to overwrite the
    Next SE Handler (NSEH). At the beginning of this chapter, we used a simple stack
    overflow example when we attacked MailCarrier and overwrote the instruction pointer.
    Here, we overwrite the SEH and the NSEH to break out of the structured exception
    handler. Then at ![](../images/00004.gif) we add the address of a *POP-POP-RETN*
    sequence of instructions to overwrite SEH, which puts us into an area of memory
    that we control.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始的 *A* 字符串（共 1019 个，用十六进制的 `\x41` 表示）之后，我们在![图](../images/00002.gif)处添加一个短跳转来覆盖下一个
    SE 处理程序（NSEH）。在本章开头，我们在攻击 MailCarrier 时使用了一个简单的堆栈溢出示例，覆盖了指令指针。在这里，我们覆盖 SEH 和 NSEH
    以跳出结构化异常处理程序。然后在![图](../images/00004.gif)处添加一个 *POP-POP-RETN* 指令序列的地址来覆盖 SEH，这使我们进入一个我们控制的内存区域。
- en: Next, to make sure that the packet will be recognized as a write request by
    the TFTP server, we append `\x00\x02` after the shellcode at ![](../images/00005.gif).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了确保数据包被 TFTP 服务器识别为写请求，我们在 shellcode 后面追加 `\x00\x02`，如![图](../images/00005.gif)所示。
- en: Now, when we load the module and run it against our target, our debugger should
    pause with a SEH overwrite, as shown in [Figure 15-4](part0019.html#quick_tftp_apostrophy_s_initial_seh_over).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们加载模块并针对目标运行它时，我们的调试器应该会暂停，出现 SEH 覆盖，如图[图 15-4](part0019.html#quick_tftp_apostrophy_s_initial_seh_over)所示。
- en: '![Quick TFTP’s initial SEH overwrite](../images/00057.jpeg)Figure 15-4. Quick
    TFTP’s initial SEH overwrite'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![Quick TFTP 的初始 SEH 覆盖](../images/00057.jpeg)图 15-4. Quick TFTP 的初始 SEH 覆盖'
- en: 'Because that long string of *A*s and the NOP slide sent to the application
    will set off IDS alarms, we’ll replace the *A*s (as in the previous example) with
    a random selection of uppercase alphabetic characters, and replace the `\x90`
    characters with NOP equivalents, as shown in the following boldface code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因为那串长长的 *A* 和发送到应用程序的 NOP 滑块会触发 IDS 警报，我们将用随机选择的 uppercase 字母字符替换 *A*（如前例所示），并将
    `\x90` 字符替换为 NOP 等效字符，如下所示（粗体代码）：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As always, it’s a good idea to check your new module’s functionality after every
    change. As you can see in [Figure 15-5](part0019.html#quick_tftp_buffer_with_random_characters),
    the random characters have been accepted by the application and SEH is still controlled
    as it was before.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查每次更改后新模块的功能是个好主意。正如您在[图 15-5](part0019.html#quick_tftp_buffer_with_random_characters)中看到的那样，随机字符已被应用程序接受，SEH
    仍然像之前一样受控。
- en: '![Quick TFTP buffer with random characters](../images/00058.jpeg)Figure 15-5. Quick
    TFTP buffer with random characters'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![带有随机字符的 Quick TFTP 缓冲区](../images/00058.jpeg)图 15-5. 带有随机字符的 Quick TFTP 缓冲区'
- en: Now that we know that the module is still behaving properly, we can set the
    return address in the `'Targets'` definition. The address in this example is a
    *POP-POP-RETN* from *oledlg.dll*, as in the original exploit. Remember that if
    we can find a memory instruction set in the same application that is loaded every
    time, we can create a universal exploit that is not dependent on Microsoft DLLs
    and that can target every operating system. In this case, we use *oledlg.dll*
    to make this exploit universal.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道模块仍然表现正常，我们可以在`'Targets'`定义中设置返回地址。在这个例子中，地址是从 *oledlg.dll* 的 *POP-POP-RETN*，就像原始漏洞利用一样。记住，如果我们能在同一个应用程序中找到一个每次都加载的内存指令集，我们可以创建一个通用的漏洞利用，它不依赖于Microsoft
    DLLs，并且可以针对每个操作系统。在这种情况下，我们使用 *oledlg.dll* 来使这个漏洞利用通用。
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We now have our target of Windows XP SP2 and a return address of 0x74d31458,
    as shown at ![](../images/00002.gif).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了Windows XP SP2的目标和返回地址0x74d31458，如图所示 ![此处应有图片](../images/00002.gif)。
- en: 'Next, we create a random, alphabetical, uppercase string of 1019 bytes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个由1019个字节组成的随机、字母、大写字符串：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `generate_seh_payload` function uses the declared return address and will
    automatically insert the short jump (which jumps us over the SEH handler). The
    `generate_seh_payload` function calculates the jumps for us, so it will go straight
    to the *POP-POP-RETN*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_seh_payload` 函数使用声明的返回地址，并将自动插入短跳转（跳过SEH处理程序）。`generate_seh_payload`
    函数为我们计算跳转，所以它会直接跳转到 *POP-POP-RETN*。'
- en: We run the module one last time with the dummy shellcode and see that our debugger
    contains numerous random characters, but everything is still under our direct
    control, as shown in [Figure 15-6](part0019.html#quick_tftp_fully_controlled).
    Random characters can be better than NOPs in some cases, because they serve to
    trip up many IDSs that may be monitoring the network. Many signature-based IDSs
    can trigger over large volumes of NOPs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一次使用虚拟外壳码运行模块，看到我们的调试器包含许多随机字符，但一切仍然在我们直接控制之下，如图 [图15-6](part0019.html#quick_tftp_fully_controlled)
    所示。在某些情况下，随机字符可能比NOPs更好，因为它们有助于迷惑许多可能正在监控网络的IDS。许多基于签名的IDS可能会在大量NOPs上触发。
- en: '![Quick TFTP fully controlled](../images/00059.jpeg)Figure 15-6. Quick TFTP
    fully controlled'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![完全控制的快速TFTP](../images/00059.jpeg) 图15-6. 完全控制的快速TFTP'
- en: 'Next, we remove the dummy shellcode and run the module with a real payload
    to get our shell, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们移除虚拟外壳码，并使用真实的有效载荷运行模块以获取我们的外壳，如图所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have our Meterpreter shell, we’ve successfully ported an exploit
    and used the Framework in an SEH exploit!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Meterpreter外壳，我们已经成功地将漏洞利用导入并使用框架在SEH漏洞利用中！
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Wrapping Up
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was designed to help you understand how to port different stand-alone
    exploits into the Metasploit Framework. You can import into the Framework in a
    number of ways, and different exploits will require different approaches and techniques.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在帮助你了解如何将不同的独立漏洞利用导入到Metasploit框架中。你可以以多种方式将其导入框架，不同的漏洞利用将需要不同的方法和技巧。
- en: At the beginning of this chapter, you learned how to use some basic assembly
    instructions to perform a simple stack overflow and port it into the Framework.
    We moved on to SEH overwrites, which we were able to use to maneuver around the
    handler and gain remote code execution. We used a *pop/pop/ret* technique to gain
    the ability to execute code remotely, and we used Metasploit to open a Meterpreter
    shell.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，你学习了如何使用一些基本的汇编指令来执行简单的堆栈溢出并将其导入到框架中。我们继续到SEH覆盖，我们能够用它来绕过处理程序并获取远程代码执行。我们使用
    *pop/pop/ret* 技巧来获得远程执行代码的能力，并使用Metasploit打开Meterpreter外壳。
- en: In the next chapter, we will begin to dive into the Meterpreter scripting language
    and post exploitation modules. When we compromise a system and leverage Meterpreter,
    we can perform a number of additional attacks. We’ll create our own Meterpreter
    scripts and learn how the Framework is structured and how use it to maximum effect.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始深入研究Meterpreter脚本语言和后利用模块。当我们攻陷系统并利用Meterpreter时，我们可以执行许多额外的攻击。我们将创建自己的Meterpreter脚本，并学习框架的结构以及如何最大限度地利用它。
