- en: Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP/IP APPLICATION LAYER PROTOCOLS
  prefs: []
  type: TYPE_NORMAL
- en: 'The OSI Reference Model is used to describe the architecture of networking
    protocols and technologies and to show how they relate to one another. In the
    chapter describing OSI Reference Model concepts ([Chapter 5](ch05.html "Chapter 5. GENERAL
    OSI REFERENCE MODEL ISSUES AND CONCEPTS")), I mentioned that its seven layers
    could be organized into two layer groupings: the lower layers (1 through 4) and
    the upper layers (5 through 7). While there are certainly other ways to divide
    the layers, this split best reflects the different roles that the layers play
    in a network.'
  prefs: []
  type: TYPE_NORMAL
- en: The lower layers are concerned primarily with the mechanics of formatting, encoding,
    and sending data over a network. These layers involve software elements, but they
    are often closely associated with networking hardware devices. In contrast, the
    upper layers are concerned mainly with user interaction and the implementation
    of software applications, protocols, and services that let us actually use the
    network. These elements generally don't need to worry about details, relying on
    the lower layers to ensure that data gets to where it needs to go reliably.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I describe the details of the many protocols and applications
    that occupy the upper layers in TCP/IP. The organization of this section is quite
    different from the previous section''s organization. Since the TCP/IP protocol
    suite uses an architecture that lumps all the higher layers together, even attempting
    to differentiate between these layers is not worthwhile. For these reasons, this
    section is divided by functions, rather than by layers. It contains ten parts:
    four that discuss application layer protocols that support the operation of TCP/IP,
    and six that discuss actual application protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part discusses naming systems, especially the TCP/IP Domain Name
    System (DNS). The second part overviews file and resource sharing protocols, with
    a focus on the Network File System (NFS). The third part covers TCP/IP host configuration
    and the host configuration protocols: the Boot Protocol (BOOTP) and the Dynamic
    Host Configuration Protocol (DHCP). The fourth part describes the TCP/IP network
    management framework, including the Simple Network Management Protocol (SNMP)
    and Remote Network Monitoring (RMON).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth part introduces TCP/IP applications with a look at application layer
    addressing and an overview of file and message transfer applications. The sixth
    part covers the general file transfer protocols: the File Transfer Protocol (FTP)
    and the Trivial File Transfer Protocol (TFTP). The seventh part explains the many
    related protocols that together form TCP/IP''s electronic mail application. The
    eighth part covers the Web and the important Hypertext Transfer Protocol (HTTP).
    The ninth part describes Usenet (network news) and Gopher. Finally, the tenth
    part discusses interactive and administrative protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 50](ch50.html "Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 51](ch51.html "Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST
    TABLE NAME SYSTEM")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 52](ch52.html "Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS,
    AND CHARACTERISTICS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 53](ch53.html "Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 54](ch54.html "Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION,
    ZONES, AND AUTHORITIES")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 55](ch55.html "Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 57](ch57.html "Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD,
    AND MASTER FILE FORMATS")'
  prefs: []
  type: TYPE_NORMAL
- en: Humans and computers first started dealing with each other several decades ago.
    The relationship between man (and woman!) and machine has been a pretty good one
    overall, and this is reflected in the fact that while computers were once just
    the province of techies, they are now *mainstream*. However, there are areas where
    humans and computers simply don't see eye to eye. One of these is in the way that
    we deal with information.
  prefs: []
  type: TYPE_NORMAL
- en: Computers work best with numbers, while most people prefer not to work with
    numbers. This fundamental difference represented a problem for the designers of
    networking technology. It made sense from a technical standpoint to design addressing
    schemes for networks and internetworks using simple numeric identifiers, for simplicity
    and efficiency. Unfortunately, identifying computers using numeric addresses is
    cumbersome for people and becomes more so as the number of devices on a network
    increases. To solve this problem, the techies went to work and came up with *name
    systems* for networks. These mechanisms allow computers to continue to use simple,
    efficient numeric addresses, while letting humans specify names to identify network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: This part includes eight chapters that explain both the theory and practice
    behind networking name systems. The first chapter describes the motivation for
    name systems and the important concepts and techniques behind how they work. The
    second chapter provides an introduction to name systems on TCP/IP and a brief
    description of the simple host table name system.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining chapters describe the very important Domain Name System (DNS).
    The third chapter provides an overview of DNS, including a description of its
    characteristics and components. The fourth chapter discusses the DNS name space
    and architecture, and the fifth chapter covers the DNS name registration process,
    including hierarchical authorities and administration. The sixth chapter describes
    DNS name servers and how they represent, manage, and provide data when resolution
    is invoked. The seventh chapter describes DNS clients, called *resolvers*, how
    they initiate resolution, and the steps involved in the resolution process. Finally,
    the eighth chapter ties together the information about name servers and resolvers
    by providing a look at message exchange between these units, and describing the
    formats of messages, resource records, and DNS master files. This chapter includes
    a brief look at the changes made to DNS to support the new version 6 of the Internet
    Protocol (IPv6) and its much longer addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though the abbreviation *DNS* usually stands for *Domain Name
    System*, you will also sometimes see the *S* stand for other words, especially
    *Service* or *Server*. Also, some documents refer to this name system as *the
    DNS*. Most people just say *DNS*, without the definite article, and that's the
    convention I follow here as well.
  prefs: []
  type: TYPE_NORMAL
- en: A set of related TCP/IP utilities called *nslookup, host*, and *dig* can be
    used by an administrator to query DNS name servers for information. They are useful
    for a variety of purposes, including manually determining the IP address of a
    host, checking for specific resource records maintained for a DNS name, and verifying
    the name resolution function. You can find more information about these utilities
    in [Part III-10](pt21.html "Part III-10. INTERACTIVE AND ADMINISTRATIVE UTILITIES
    AND PROTOCOLS").
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Name systems can be considered as the diplomats of the networking protocol stack.
    Just as a political diplomat is skilled at speaking multiple languages and ensuring
    good communications between those who may view the world in different ways, name
    systems bridge the gulf between the numeric addresses that computers like to use
    and the simpler names that humans prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at specific name systems, it makes sense to discuss them generally.
    This will help you to understand the reasons why these systems are important and
    the concepts that underlie all name systems, regardless of their specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'I begin this chapter with an overview of name systems and a discussion of why
    they were created. I then discuss the three main functions of a name system: the
    name space, name registration, and name resolution. I then expand on this functional
    overview, illustrating how name spaces and architectures work, the issues behind
    name registration and administration, and finally, name resolution techniques
    and the practical issues in the resolution process.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides an introduction to name systems and doesn't discuss specific
    name systems. I like to use examples to explain concepts and, for this purpose,
    do make reference to the TCP/IP Domain Name System (DNS) at times. However, you
    do not need to be familiar with DNS to follow this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Name System Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of several important differences between humans and computers is how we
    prefer to deal with information. Computers work with numbers, while very few humans
    like to do so. This distinction becomes particularly important when we look at
    how identifiers, or addresses, are assigned to network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic Names for Addressing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To a computer, there is no problem with simply giving a number to each device
    on the network and using those numbers to move information around. Your computer
    would be perfectly happy if you assigned a number like 341,481,178,295 to it and
    all the other machines on your network, and then issued commands such as, "Send
    this file to machine 56,712,489,901." However, most humans don't want to use a
    network in this manner. These long, cryptic numbers don't mean anything to them.
    They want to tell their machine, "Send this file to Joe's computer," or "Print
    this on the color laser in the Sales department," or "Check the latest headlines
    on CNN's website."
  prefs: []
  type: TYPE_NORMAL
- en: This difference led to the development of *name systems*. These technologies
    allow computers on a network to be given both a conventional numeric address and
    a more user-friendly, human-readable name, composed of letters, numbers, and other
    special symbols. Sometimes called a *symbolic name*, this can be used as an alternative
    form of addressing for devices. The name system takes care of the functions necessary
    to manage this system, including ensuring that names are unique, translating from
    names to numbers, and managing the list of names and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Paradox: Name Systems Are Both Essential and Unnecessary'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's interesting about name systems is that they are extremely important to
    networks, but at the same time, they often aren't strictly necessary for a network
    to operate. This seeming paradox is due again to the difference between humans
    and computers. Computers need only the numeric addressing scheme, not the names
    assigned to them. So, without name systems, the computers and the network can
    still work, but it will be much harder for people to use them!
  prefs: []
  type: TYPE_NORMAL
- en: An example of this can most readily be seen when a problem disables the operation
    of a part of DNS used to provide naming services on the Internet. Technically,
    DNS isn't needed to use most parts of the Internet, because all communications
    use IP addresses. This means that even though you might normally access CNN's
    website at [www.cnn.com](http://www.cnn.com), you could instead just use the IP
    address 64.236.16.20.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that prior to reading this, you probably had no idea what the
    IP address of CNN's website is, and that's true of almost everyone else who uses
    the site as well. Also, you might want to check not just CNN's website, but perhaps
    1, 2, or 20 other news sites. It would be difficult to remember the numbers for
    even a small percentage of the thousands of different websites on the Internet,
    so each time you wanted to access a resource, you would need to manually look
    up its address, as shown in [Figure 50-1](ch50.html#internetwork_access_without_a_name_syste
    "Figure 50-1. Internetwork access without a name system When there is no name
    system, a user must know the address of any device he or she wishes to access
    on the internetwork. Since most of us have limited memories for numbers, this
    means each access must be preceded by an inefficient, tedious, manual address
    lookup.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Internetwork access without a name system When there is no name system, a
    user must know the address of any device he or she wishes to access on the internetwork.
    Since most of us have limited memories for numbers, this means each access must
    be preceded by an inefficient, tedious, manual address lookup.](httpatomoreillycomsourcenostarchimages288143.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 50-1. Internetwork access without a name system When there is no name
    system, a user must know the address of any device he or she wishes to access
    on the internetwork. Since most of us have limited memories for numbers, this
    means each access must be preceded by an inefficient, tedious, manual address
    lookup.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, it's much easier to remember the names of resources. With a name
    system, you just enter the name of a device, and the name system converts it to
    an address, as shown in [Figure 50-2](ch50.html#internetwork_access_with_a_name_system
    "Figure 50-2. Internetwork access with a name system"). This is why name systems
    are so important, even if they aren't needed by the networking technologies themselves.
    In fact, the reliance on name systems like DNS is so significant that many people
    don't even realize they can enter IP addresses into their web browsers!
  prefs: []
  type: TYPE_NORMAL
- en: '![Internetwork access with a name system](httpatomoreillycomsourcenostarchimages288145.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 50-2. Internetwork access with a name system
  prefs: []
  type: TYPE_NORMAL
- en: When an internetwork is equipped with a name system, the user no longer needs
    to know the address of a device to access it. He or she enters the name, and the
    name system converts it into an address automatically, like a computerized Rolodex,
    as shown here. The name system then passes the address to the client software,
    which uses that address to access the requested resource as if the user had entered
    it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Factors That Determine the Necessity of a Name System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More generally, the importance of a name system depends greatly on the characteristics
    of the network where it is used. The following are the three main issues in determining
    the need for a name system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Size** With a really small network and only a handful of computers,
    having human users remember the numeric addresses for these machines is at least
    feasible, if not ideal. For example, a small home network with two or three machines
    doesn''t really *need* a name system, in theory. If you have thousands or millions
    of devices, however, the name system becomes essential.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Size and Complexity** The more complex the numeric addressing scheme,
    or the larger the numbers used, the more difficult it is for humans to remember
    the numbers. This makes having a name system all the more essential for the users
    of those addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Base Size and Skill** In the early days of networks, a small number
    of highly skilled and well-trained engineers used them, and these people sometimes
    just memorized the numbers of the machines they worked with every day. In modern
    networks with thousands or millions of regular users, expecting the average person
    to remember device numbers is not reasonable.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Networking name systems are important because they allow devices
    to be assigned efficient numeric addresses, while still enabling humans to access
    them using names that are easier to remember. Name systems become more important
    as you increase the size of the network, the address, or the user base. They are
    also more essential when the user base is limited in skill or experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at these issues, we can see that the trends in today's networks are
    all in the direction of increasing the importance of name systems. Our networks,
    both private and public, are growing larger, and we have more people using them,
    including more people without a technical background. We are also increasingly
    moving from small addresses to larger ones. The best example of this is the upcoming
    change to IP. While DNS is important for the 32-bit addresses used in IPv4, it's
    even *more* important for dealing with the enormous 128-bit addresses of IPv6
    (see [Part II-4](pt07.html "Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic Name System Functions: Name Space, Name Registration, and Name Resolution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the difference between numeric addresses and symbolic names is very significant
    to the users of network devices, it''s important to remember that both numbers
    and names really serve the same basic purpose: *device identification*. Even when
    we use a name system to make devices easier to access, the computers themselves
    will still normally need to use the underlying numeric identifier. In essence,
    every device will end up with (at least) two identifiers: a number *and* a name.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that devices end up with multiple identifiers is what allows both people
    and their machines to use the method of identification they prefer. However, it
    means that there must be ways of managing the assignment of names to devices and
    converting between them. A name system involves more than just slapping names
    on computers. It must be a complete *system* that allows names to be used by the
    humans while numbers continue to be used by the devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the highest level, a name system must handle three basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Space Definition** The name system defines a *name space* for the networking
    system on which it runs. The name space, also sometimes called a *name architecture*,
    describes the rules for how names are structured and used. It also defines how
    the name of one device is related to the names of other devices in the system
    and how to ensure that there are no invalid names that would cause problems with
    the system as a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Registration** To implement the name system, a name must be assigned
    to each device on the network. Like any addressing system, a name system cannot
    work properly unless every name on the system is unique. We need some way of managing
    how the names are assigned so the result is sensible. The process of linking specific
    names to particular devices is usually called *name registration*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Resolution** Even though humans like symbolic names, computers usually
    have little use for them. It is necessary to define a mechanism by which a device''s
    symbolic name can be translated into its numeric address. This process is usually
    called *name resolution*.'
  prefs: []
  type: TYPE_NORMAL
- en: The name space is more of a descriptive function, which defines how names work
    in the system. Name registration and resolution are more active functions, with
    each name system including one or more specific procedures for how these jobs
    are carried out. Name registration and resolution are in some ways complements
    of each other, so certain registration techniques are most often associated with
    particular resolution methods. In turn, the types of registration and resolution
    methods that are possible depend on the name space, and in particular, its architecture.
    These relationships are shown in simplified form in [Figure 50-3](ch50.html#name_system_functions
    "Figure 50-3. Name system functions").
  prefs: []
  type: TYPE_NORMAL
- en: '![Name system functions](httpatomoreillycomsourcenostarchimages288147.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 50-3. Name system functions
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows the relationships between the three main functions of a name
    system. The *name space* defines the structure of the name system and the rules
    for creating names. The name space is used as the basis for the *name registration*
    method, which defines the mappings between names and addresses. When a user wants
    to access a device by name, a *name resolution* method is used to consult the
    name space, determine what address is associated with a name, and then convert
    the name to an address. The processes of registration and resolution can be either
    quite plain or fairly complicated, depending on the type of name system used.
    Simple name systems are largely manual in operation, easy to understand, and best
    used in smaller networks. Larger, more complex networks and internetworks require
    more sophisticated methods of registration and resolution, which involve less
    administrator intervention and *scale* better as new machines are added to the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Although name registration and name resolution work as functions at the highest
    level, they are probably better thought of as *sets* of functions. Name registration
    is necessarily tied to issues such as name system administration and management,
    and understanding resolution requires that we look at a number of important implementation
    issues in the areas of efficiency and reliability. The rest of this chapter expands
    on this overview by considering each of these three functions in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A name system consists of three theoretical high-level functions:
    the *name space*, which describes how names are created and organized; the *name
    registration* technique, which is used to set up relationships between names and
    addresses; and the *name resolution* method, which is responsible for translating
    names to addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Name Spaces and Name Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea of a name system is to provide a way to identify devices using
    symbolic names. Like any identification mechanism, before it can be used, we must
    define the way that identification will be performed. Numeric addressing schemes
    (like IP addresses) have rules for how addresses are created and assign addresses
    to each device from their *address space*. In a similar way, devices in a name
    system are given names from the system's *name space*.
  prefs: []
  type: TYPE_NORMAL
- en: Name Space Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of the three main components of a name system, the name space is the most abstract.
    It is also the most fundamental part of the system, since it actually describes
    how the names are created. There are several aspects to what the name space defines
    in a name system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Size and Maximum Number of Names** The name space specifies the number
    of characters (symbols) that compose names. It also defines the maximum number
    of names that can appear in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Rules and Syntax** The name space specifies which characters and symbols
    are allowed in a name. This is used to allow legal names to be chosen for all
    devices, while avoiding illegal names.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Architecture and Semantics** Each name space uses a specific *architecture*
    or *structure*, which describes how names are constructed and interpreted.'
  prefs: []
  type: TYPE_NORMAL
- en: The concepts of name size and name syntax are relatively straightforward. The
    *name architecture* is probably the most important differentiating characteristic
    of name systems. For this reason, name spaces are sometimes even *called* name
    architectures. The architecture of the name space determines whether names are
    assigned and used as a simple unstructured set of symbols or have a more complex
    internal structure. In the latter case, the name space also must define how elements
    of a particular name are related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, many different name architectures are possible. In practice,
    most fall into one of two categories: flat and hierarchical.'
  prefs: []
  type: TYPE_NORMAL
- en: Flat Name Architecture (Flat Name Space)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a *flat name architecture*, names are assigned as a sequence of symbols that
    are interpreted as a single, whole label without any internal structure. There
    is no clear relationship between any name and any other name.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this sort of architecture would be a name system where computers
    are given unstructured names like Engineering Workstation 1 or Joanne's PC, as
    shown in the example in [Figure 50-4](ch50s02.html#flat_name_architecture_flat_name_s-id001
    "Figure 50-4. Flat name architecture (flat name space) This diagram shows an example
    of a flat name architecture. There is no structure that organizes the names or
    dictates how they must be constructed. Logically, each device is a peer of each
    of the others.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Flat name architecture (flat name space) This diagram shows an example of
    a flat name architecture. There is no structure that organizes the names or dictates
    how they must be constructed. Logically, each device is a peer of each of the
    others.](httpatomoreillycomsourcenostarchimages288149.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 50-4. Flat name architecture (flat name space) This diagram shows an
    example of a flat name architecture. There is no structure that organizes the
    names or dictates how they must be constructed. Logically, each device is a peer
    of each of the others.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical Name Architecture (Structured Name Space)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a *hierarchical name architecture*, or structured name space, the names are
    a sequence of symbols, but these symbols are assigned using a specific and clear
    structure. Each name consists of discrete elements that are related to each other,
    usually by using hierarchical parent/child semantics. There are many naming architectures
    in various contexts that use this type of hierarchical structure. For example,
    consider how a large company might set up an organization chart and name the executives
    and officers in the organization. One hypothetical example of a hierarchical name
    architecture is illustrated in [Figure 50-5](ch50s02.html#hierarchical_name_architecture_str-id001
    "Figure 50-5. Hierarchical name architecture (structured name space)").
  prefs: []
  type: TYPE_NORMAL
- en: The best-known real-world example of a hierarchical name space is the name space
    of DNS (see [Chapter 53](ch53.html "Chapter 53. DNS NAME SPACE, ARCHITECTURE,
    AND TERMINOLOGY")), which uses text labels separated by periods (or *dots*) to
    form an internal structure. All the names in the system are organized into a structure,
    and a particular device's place in the structure can be determined by looking
    at its name. For example, [www.tcpipguide.com](http://www.tcpipguide.com) refers
    to the World Wide Web server for *The TCP/IP Guide*, which is named under the
    umbrella of commercial (.com) companies.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchical name architecture (structured name space)](httpatomoreillycomsourcenostarchimages288151.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 50-5. Hierarchical name architecture (structured name space)
  prefs: []
  type: TYPE_NORMAL
- en: This diagram contains the same devices as [Figure 50-4](ch50s02.html#flat_name_architecture_flat_name_s-id001
    "Figure 50-4. Flat name architecture (flat name space) This diagram shows an example
    of a flat name architecture. There is no structure that organizes the names or
    dictates how they must be constructed. Logically, each device is a peer of each
    of the others."), but they have been arranged using a hierarchical, structured
    name architecture. In this case, the organization has chosen to structure its
    device names first by facility location, and then by department. Each name starts
    with something like USA-Service- or EU-Mfg-. This has immediate benefits by providing
    local control over device naming without risk of conflicts. If someone named John
    were hired into the USA sales force, his machine could be named USA-Sales-John,
    without conflicting with the machine owned by John of the European sales force
    (EU-Sales-John). The structure also makes it easier to know immediately where
    a device can be found within the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Name Architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you will see in the next two sections in this chapter, the architecture of
    the name space is intimately related to how names are registered and managed,
    and ultimately, how they are resolved. A flat name space requires a central authority
    of some sort to assign names to all devices in the system to ensure uniqueness.
    A hierarchical name architecture is ideally suited to a more distributed registration
    scheme that allows many authorities to share in the registration and administrative
    process.
  prefs: []
  type: TYPE_NORMAL
- en: All of this means that the advantages and disadvantages of each of these architectures
    are not a great mystery. Flat name spaces have the advantage of simplicity and
    the ability to create short and easily remembered names, as shown in [Figure 50-4](ch50s02.html#flat_name_architecture_flat_name_s-id001
    "Figure 50-4. Flat name architecture (flat name space) This diagram shows an example
    of a flat name architecture. There is no structure that organizes the names or
    dictates how they must be constructed. Logically, each device is a peer of each
    of the others."). However, they do not scale well to name systems containing hundreds
    or thousands of machines, due to the difficulties in ensuring each name is unique.
    For example, what happens if there are four people named John who all try to name
    their computers John's PC? Another issue is the overhead needed to centrally manage
    these names.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, hierarchical name spaces are more sophisticated and flexible, because
    they allow names to be assigned using a logical structure. We can name our machines
    using a hierarchy that reflects our organization's structure, for example, and
    give authority to different parts of the organization to manage parts of the name
    space. As long as each department is named uniquely and that unique department
    name is part of each machine name, we don't need to worry about each assigned
    name being unique across the entire organization; it just needs to be unique within
    the department. Thus, we can have four different machines named with their department
    name and John, as [Figure 50-5](ch50s02.html#hierarchical_name_architecture_str-id001
    "Figure 50-5. Hierarchical name architecture (structured name space)") demonstrates.
    The price of this flexibility is the need for longer names and more complexity
    in name registration and resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The two most common types of name architecture are the flat
    name space and the hierarchical name space. Names in a flat name space are all
    peers with no relationship. In a hierarchical architecture, a multiple-level structure
    is used to organize names in a specific way. The flat system is simpler and satisfactory
    for small networks. The hierarchical name space is more flexible and powerful,
    and better suited to larger networks and internetworks.'
  prefs: []
  type: TYPE_NORMAL
- en: Name Registration Methods, Administration, and Authorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems obvious that for our name system to be implemented, we need some method
    of assigning names to each of the devices that will use the system. Just as a
    name system has a name space that is comparable to an addressing system's address
    space, it also must implement a set of rules and procedures for assigning names,
    comparable to how an addressing system assigns addresses. This is called *name
    registration*.
  prefs: []
  type: TYPE_NORMAL
- en: Name Registration Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, name registration encompasses the following four concepts and tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Assignment and Guarantee of Uniqueness** The core task of the name registration
    process is assigning names to devices. Like all identification schemes, a key
    requirement of name registration is ensuring that each name is unique. Duplicated
    names cause ambiguity and make consistent name resolution impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central Registration Authority Designation** Ensuring uniqueness of names
    requires that there be someone in charge of the name assignment process. This
    *central registration authority* may be a single individual that maintains a file
    containing names, or it may be an organization that is responsible for the overall
    name registration process. The authority is also charged with resolving problems
    and conflicts that may arise in registrations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registration Authority Delegation** In smaller name systems, the central
    registration authority may be responsible for the actual registration process
    for all devices. In larger, hierarchical name systems, having this process centralized
    is impractical. Instead, the central registration authority will divide the name
    space and *delegate* authority for registering names in different parts of it
    to subordinate organizations. This requires a delegation policy to be developed
    and implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical Structure Definition** When a hierarchical name space is used,
    the central authority is responsible for defining how the structure will look.
    This, in turn, dictates how names can be registered in different parts of the
    hierarchy, and of course, also impacts how authority is delegated.'
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the name registration process depends to a great extent on
    the size and complexity of the name system as a whole, and, in particular, on
    the architecture of the name space. In a simple name system using a flat name
    space, registration is usually accomplished using a single authority. There is
    no structure and usually no delegation of authority, so there isn't much to registration.
    For hierarchical name systems, name registration is tied tightly to the hierarchy
    used for names.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical Name Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central authority defines the structure of the hierarchy and decides how
    the hierarchy is to be *partitioned* into subsets that can be independently administered
    by other authorities. Those authorities may, in turn, delegate subsets of their
    name spaces as well, creating a flexible and extensible system.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to delegate authority for name registration is one of the most
    powerful benefits of a hierarchical name space. For example, in DNS, a central
    authority is responsible for name registration as a whole. This central authority
    is in charge of deciding which top-level domains—such as .com, .edu, .info, and
    .uk—are allowed to exist. Authority for managing each of these subsets of the
    worldwide hierarchy is then delegated to other organizations. These organizations
    continue the process of dividing the hierarchy as they see fit. Eventually, each
    organization is able to decide how it will name its own internal systems independently;
    for example, IBM can register names in any way it sees fit within the ibm.com
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Name Registration Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several common methods by which the actual process of registration
    is carried out. These include table name registration, broadcast name registration,
    and database registration. Each of these has its strengths and weaknesses, and
    again, some are better suited to flat name spaces and some to hierarchical ones.
  prefs: []
  type: TYPE_NORMAL
- en: Table Name Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using table name registration, name assignments are maintained in a table by
    an administrator. When names need to be added, deleted, or changed, the table
    is edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is usually associated with small, flat name space name systems.
    It has the same benefits and drawbacks as flat architecture in general: It is
    simple and easy to implement, but doesn''t scale well to larger systems. With
    a dozen machines, having someone edit name registration tables is practical; with
    thousands of machines, it is not. It is also not conducive to a hierarchical system
    where there are multiple authorities, because the table needs to be kept in one
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: In larger internetworks, tables may be used as an adjunct to one of the other,
    more sophisticated, registration techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast Name Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broadcast name registration is a trial-and-error technique. A device that wants
    to use a particular name sends out a message to all other devices on the network,
    asking if anyone else is already using it. If so, it chooses a different name.
    If not, the name is considered registered and can then be used.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is more sophisticated than using tables, but it is still limited
    to use in relatively small systems. It is not practical to attempt to broadcast
    to thousands of systems, and this method could not be used over the Internet,
    since there is no way to broadcast to every device on an internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: Database Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With database registration, a database of name assignments is maintained. To
    register a name, a request must be made to have the name assignment added to the
    database. If the authority for the name system is entirely centralized, the database
    will be centralized and maintained by that authority. If authority for parts of
    the hierarchy is delegated, then a *distributed database* is used for registration,
    with each authority maintaining the part of the database describing its section
    of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most sophisticated technique and one normally associated with hierarchical
    name systems like DNS. It has several benefits, including flexibility, reliability,
    and distribution of maintenance effort. Its main drawback is complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *Name registration* is the process by which names are linked
    to addresses in a name system. It encompasses activities such as central registry
    authority designation and delegation, and name space structure management. The
    most common methods of name registration, in order of both increasing capability
    and complexity, are manual table maintenance, broadcast registration, and database
    registration.'
  prefs: []
  type: TYPE_NORMAL
- en: Name Resolution Techniques and Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier in this chapter, using a name system creates two parallel
    identification systems for computers: the numbers used by machines and the names
    used by people. The job of the name system is to integrate these two schemes.
    Name registration allows humans to specify which machines use which names. This
    is only half the process, however; we also need a way for machines to take a name
    given to them by a human and translate it into the numeric address it can actually
    use for communication. This is called *name resolution*.'
  prefs: []
  type: TYPE_NORMAL
- en: Name resolution, also sometimes called *name translation, mapping*, or *binding*,
    is the most well-known aspect of name systems, because it is where most of the
    "heavy lifting" of a name system occurs. The name space is generally set up once,
    and name registration occurs infrequently—only when names must be created or changed.
    In contrast, every user of a name system instructs the machines he or she uses
    to perform name resolution, hundreds or even thousands of times a day.
  prefs: []
  type: TYPE_NORMAL
- en: Name Resolution Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several different techniques can be used for name resolution. How this function
    is implemented depends a great deal on the other two name system functions: name
    space and name registration. As you might imagine, a simple name system with a
    simple name registration method will most often use a simple resolution method
    as well. Complex hierarchical systems with distributed databases require more
    sophistication in how names are resolved. There are three common name resolution
    methods: table name resolution, broadcast name resolution, and client/server name
    resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: Table-Based Name Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table used for table-based name registration is consulted by a device when
    resolution needs to be performed. The table tells the device how to transform
    the name of the machine it needs to contact into an address.
  prefs: []
  type: TYPE_NORMAL
- en: This technique obviously corresponds to table name registration. It is the simplest
    and least capable of the three methods. Table name resolution is suitable for
    stand-alone use only in very small name systems, but it can be a supplement to
    other methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast Name Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a device needs to resolve a name, it broadcasts a query that says something
    to this effect: "I need to send to the device named *X*. Who is that?" The device
    whose name is *X* responds, "I''m *X*, and my numeric address is *N*."'
  prefs: []
  type: TYPE_NORMAL
- en: This is the complement of broadcast name registration. It, too, can be used
    only in simple systems where every device can hear a broadcast. The use of broadcasts
    also makes it wasteful of network bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Client/Server Name Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With client/server name resolution, servers are programmed with software that
    allows them to respond to name resolution requests sent by clients. These servers
    take the name in the request, look up the associated numeric identifier in a database,
    and send it back in a response.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is generally used in conjunction with database name registration.
    It is the most complex name resolution method, but it is also the most efficient
    and the only one that can really work properly on a large, distributed hierarchical
    name system.
  prefs: []
  type: TYPE_NORMAL
- en: Client/Server Name Resolution Functional Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client/server name resolution is the method used for most large, modern name
    systems. The client/server method of request/reply resolution is similar to how
    many other protocols function. One thing that is unique about name resolution,
    however, is that name resolution isn't often invoked directly by the client. It's
    rare, for example, for a human user to say, "Please resolve the following name."
    We also certainly wouldn't want users to need to manually resolve a name to an
    address each time they wished to contact a device, as this would be cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the system is automated by having software accept machine names input
    by users. The software resolves the name by passing it to a *name resolver* software
    component. The resolver acts as the client in the name resolution process. It
    contacts a *name server*, which responds to the request. The name resolver and
    name server constitute the two main functional elements in name resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *Name resolution* is arguably the most important of the main
    functional elements of a name system, because it is the part of the system that
    actually converts names into addresses. The two main components of name resolution
    are *name resolvers*, which act as clients in the resolution process, and *name
    servers*. The three main name resolution methods—table-based, broadcast, and client/server—correspond
    closely to the table, broadcast, and database methods of name registration.'
  prefs: []
  type: TYPE_NORMAL
- en: In a distributed database for a hierarchical name system, multiple requests
    may be required, since name servers will contain only information for certain
    machines and not others. Resolvers follow a special procedure to travel the hierarchy
    until they find the server that has the information they want. Again, DNS's name
    resolution is the best example of this method.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency, Reliability, and Other Name Resolution Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described in the previous section, the primary function of name resolution
    is allowing humans to identify devices using names, then converting these names
    into numbers so that computers can use the numbers instead. This basic task is
    conceptually quite simple, but it can become quite complex in implementation.
    The reason for this is the key characteristic that makes name resolution so different
    from the other tasks performed by a name system: the frequency with which it is
    done.'
  prefs: []
  type: TYPE_NORMAL
- en: Name registration is seldom done, but name resolution is done very often. If
    you consider a large internetwork with thousands of users running various applications,
    millions of names must be resolved every day. Now, consider something like the
    Internet, which must process billions of client/server requests and replies daily!
    Ensuring that such systems work requires that we do more than just implement a
    resolution process; we must add facilities to ensure that resolution is done as
    effectively as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency Considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first major concern with name resolution is *efficiency*. Name resolution
    uses up system resources, especially with resolution techniques that require requests
    and replies to be sent. This means we want to minimize the number of times resolution
    is performed, if at all possible. Now, consider that many people will frequently
    access the same machines over and over again. For example, if you go to a website
    called [www.thisisasite.com](http://www.thisisasite.com) for the first time, your
    system will need to resolve that name. After the home page for that site loads,
    if you click a link to another page on that site, the page will also be found
    at that same name: [www.thisisasite.com](http://www.thisisasite.com). So, it would
    be wasteful to need to resolve that name a second time.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, name systems almost always include some sort of *caching* capability,
    which allows devices to remember recent name resolutions and retain the mapping
    from name to address for a period of time. Whenever a name needs to be resolved,
    the cache is first checked before going through the formal process of resolution.
    The use of caching eliminates the vast majority of actual name resolution requests
    that would otherwise be required.
  prefs: []
  type: TYPE_NORMAL
- en: The drawbacks of caching are that it requires some system resources of its own
    and that it adds complexity to the system. One issue is deciding how long to retain
    data in the cache. If we keep it too short a time, we generate extra unnecessary
    resolution requests. If we keep it too long, we risk having the mapping become
    stale if the name assignment for the machine changes. These are issues that a
    sophisticated name system must handle. A typical solution is to allow each name
    registration to specify how long information about that name-to-address link may
    be cached.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability Considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next main concern after efficiency is name resolution *reliability*. As
    I said earlier in this chapter, having a name system isn't strictly necessary
    for the computers, but it's very important for the users, especially on a large
    network like the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: While having a single central place that maintains all information about a name
    system may make administration simpler, it creates a dangerous single point of
    failure. If anything happens to the device storing the information, the entire
    name system fails. Modern name systems employ redundancies to prevent having the
    entire system rely on any particular device for resolution. A typical approach
    in a client/server system is to have multiple servers in different locations (or
    attached to different networks) that can respond to name resolution requests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Since name resolution is the part of a name system that is
    used most often, it is here that we must pay careful attention to implementation
    issues. The two most important ones are efficiency and reliability. Efficiency
    is essential due to the many thousands or millions of resolutions performed every
    day on a large system. Reliability is a consideration because users of the name
    system quickly come to rely on it, so we must make sure it is robust.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An optional feature in some name resolution systems is *load balancing*. When
    properly implemented, load balancing allows a single name to map to more than
    one underlying address. This allows requests sent to a particular virtual device
    to actually be directed to a number of different actual physical devices, spreading
    the load over multiple machines. A common use of this feature is for very popular
    websites that are visited often.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, while name resolution is obviously designed to allow names to be mapped
    to addresses, there are cases where we may wish to go in the other direction:
    given a numeric address, find the name that goes with it. This process, called
    *reverse resolution*, is analogous to having a phone number and trying to find
    the name of the person or company to which it belongs. Just as we can''t easily
    find the name matching a phone number using a conventional phone book (we would
    need to scan every page looking for the number), reverse resolution requires special
    support on the part of the name system. This is especially true if the name system
    data is distributed over many servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TCP/IP has become sufficiently popular that many people—even those who aren't
    geeks—are fairly comfortable working with its numeric identifiers (IP addresses).
    Even so, it's a lot easier to work with names than numbers, and it's certainly
    easier to remember names. We can consider also that name systems become more important
    when used on larger networks, and TCP/IP is used to implement the Internet, the
    world's largest internetwork. Having a good name system is vital to the operation
    of the Internet, and thus, has become an important element of TCP/IP as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I begin the discussion of TCP/IP's name systems with a look
    at the history of the use of host names in TCP/IP and the early development of
    its name systems. I then provide a description of the simple host table name system,
    the first one used in the protocol suite. I discuss why host tables were replaced
    by the Domain Name System (DNS) and how, even today, they can be used to complement
    DNS functions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *This chapter assumes that you are already familiar
    with the general concepts and issues of name systems explained in the preceding
    chapter*.'
  prefs: []
  type: TYPE_NORMAL
- en: A Brief History of TCP/IP Host Names and Name Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, I described an interesting paradox: Even though name
    systems aren''t strictly necessary for the functioning of a networking system,
    they make using a network so much easier for people that they are considered an
    essential part of most networks. No better evidence of this can be found than
    in the history of name system development in TCP/IP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Developing the First Name System: ARPAnet Host Name Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history of name systems in the TCP/IP protocol suite actually goes back
    well before the Transmission Control Protocol (TCP) and Internet Protocol (IP)
    were themselves even created. In the late 1960s and early 1970s, when the predecessor
    of the Internet, called the *ARPAnet*, was being developed, it used older networking
    protocols that served the same function that TCP and IP do today.
  prefs: []
  type: TYPE_NORMAL
- en: The ARPAnet was very small by today's standards, containing at first only a
    few machines, referred to as *hosts*, just as TCP/IP machines often are called
    today. The addressing scheme was also very simple, consisting of just the combination
    of a computer number and a port number for each host. With only a handful of machine
    names, it was easy to memorize addresses, but as the ARPAnet grew to several dozen
    machines, this scheme became untenable.
  prefs: []
  type: TYPE_NORMAL
- en: As early as 1971, it was apparent to the engineers designing the ARPAnet that
    symbolic names were much easier for everyone to work with than numeric addresses.
    They began to assign simple host names to each of the devices on the network.
    Each site managed its own *host table*, which listed the mappings of names to
    addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the ARPAnet engineers immediately recognized the dangers of having
    each site maintain a list of possibly inconsistent host names. Since the internetwork
    was just a small "club" at this point, they used the Request for Comment (RFC)
    process itself to document standard host-name-to-address mappings. RFC 226, "Standardization
    of Host Mnemonics," is the first RFC I could find showing how host names were
    assigned. It was published on September 20, 1971.
  prefs: []
  type: TYPE_NORMAL
- en: This initial name system was about as manual as a system could be. As additions
    and changes were made to the network, the list of host names was updated in a
    new RFC, leading to a series of RFCs being published in the 1970s. Each host administrator
    still maintained his or her own host table, which was updated when a new RFC was
    published. During this time, the structure of host names was still under discussion,
    and changes were made to just about every aspect of the name system as new ideas
    were explored and refined.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Host Names in a Host Table File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This early name system worked fine while the ARPAnet was very small, but it
    presented many problems as the internetwork grew. One problem was that it was
    extremely slow in responding to network modifications, because additions and changes
    would be entered into device tables only after a new list was published. Also,
    even with the centralized list, there were still potential consistency issues,
    because a site manager might forget to update a file or make a typographical error.
  prefs: []
  type: TYPE_NORMAL
- en: The first improvement was to make the list of host name assignments a standard
    "master" text file, which was centrally managed and could be downloaded using
    network protocols like the File Transfer Protocol (FTP). The file was maintained
    at the Network Information Center (NIC) at Stanford University. The process for
    defining and using this file was described in RFCs 606 and 608, both entitled
    "Host Names On-Line," published in December 1973 and January 1974, respectively.
    These documents also formally specified the syntax for the TCP/IP host table name
    system, described later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a centrally managed host table continued through the 1970s. When
    TCP/IP was developed, the system was maintained, and the mappings were made between
    host names and 32-bit IP addresses. RFC 810, "DoD Internet Host Table Specification,"
    shows how host tables were defined for use with IP addresses. It was published
    in March 1982.
  prefs: []
  type: TYPE_NORMAL
- en: Outgrowing the Host Table Name System and Moving to DNS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The continuing growth of the ARPAnet/Internet made it apparent that the simple
    host table name system would eventually become unmanageable. With at first dozens,
    and then hundreds and thousands of new hosts connecting to the internetwork, a
    single text file maintained in a central location just wasn't up to the task.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of moving to a hierarchical name system based on the concept of *domains*
    was first introduced in September 1981 in RFC 799, "Internet Name Domains." Considerable
    discussion and development of this concept occurred in the early 1980s. By 1983,
    a plan was put in place to migrate from the flat host table name system to the
    new Domain Name System (DNS). The detailed history of the development of this
    name system is continued in the overview of DNS in [Chapter 52](ch52.html "Chapter 52. DOMAIN
    NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS").
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP Host Table Name System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pioneers of the modern Internet made the first name system for the TCP/IP
    suite when they created simple files containing the names and addresses of the
    machines in the early ARPAnet, as explained in the preceding section. This system
    was so simple that it originally wasn't even formally specified as a name system
    per se. Since the files contained names for network hosts, the process for relating
    names to addresses was simply called the *host name* mechanism. Later, these files
    were called *host tables*, and for this reason, this technology is commonly called
    the TCP/IP *host table name system*.
  prefs: []
  type: TYPE_NORMAL
- en: As a system, it is extremely simple, since it consists of nothing more than
    a text file maintained on each machine on the network. This file is normally called
    /etc/hosts on a UNIX system and HOSTS on a Windows system (usually residing in
    the main Windows directory). The file usually begins with some comment lines and
    then lists pairs of IP addresses and host names. A very simplified example (using
    the modern table structure, which is slightly different from the original host
    table format) is shown in [Example 51-1](ch51s02.html#example_tcpip_host_table
    "Example 51-1. Example TCP/IP host table").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Example 51-1. Example TCP/IP host table
  prefs: []
  type: TYPE_NORMAL
- en: The name space and architecture for the host table name system is theoretically
    flat, with each name being able to take any form, without any real structure.
    Despite this, for consistency, certain rules were eventually put in place regarding
    how names should be created, as discussed in [Chapter 53](ch53.html "Chapter 53. DNS
    NAME SPACE, ARCHITECTURE, AND TERMINOLOGY"). As you will learn later in this chapter,
    it's also possible to use host tables to support the implementation of a hierarchical
    name space, which would mean that the names would need to be created using that
    name space's structural rules.
  prefs: []
  type: TYPE_NORMAL
- en: Host Table Name Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Name resolution in the host table name system is very simple. Each device reads
    the host table into memory when it starts up. Users of the system can refer to
    the names in that host table by using names, instead of a numeric IP addresses,
    in their invocation of various applications. When the software detects a name
    has been used in this manner, it refers the name to the internal resolver routine
    in the device, which looks up the name in the host table in memory and returns
    its address. There is no need for any transmissions or servers to be contacted;
    resolution is entirely local.
  prefs: []
  type: TYPE_NORMAL
- en: Host Table Name Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, here is the part where I am supposed to say that name registration in the
    host table name system is simple as well, right? Well, yes and no. From a purely
    technical standpoint, it certainly is simple. A name is registered on a particular
    device when the name and corresponding IP address are entered into the device's
    host table, and that's it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, name registration is much more complicated from an administrative
    standpoint, and this is where we find the major weakness of using host tables.
    Each network device maintains its own host table independent of the others, usually
    stored as a file on its local hard disk. This is in contrast to database registration
    systems (see [Chapter 50](ch50.html "Chapter 50. NAME SYSTEM ISSUES, CONCEPTS,
    AND TECHNIQUES")), where the data is centrally stored and managed. This approach
    to name registration leads to two very important concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency** Since every device has its own host table, how do we ensure
    that information is consistent throughout all the tables on the different devices?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifications** How do we ensure that information about new device mappings
    and changes to existing ones are propagated to all devices?'
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier in this chapter, the original mechanism for name registration
    was simply hand-editing, with administrators consulting updated published lists
    of device names. This was a very inefficient method that was prone to error and
    slow to acknowledge changes to the network. The revised system used a centrally
    managed master file that was downloaded by all sites on a regular basis. Name
    registration in this method required that the name/address mapping be submitted
    to the authority managing the central file, the NIC.
  prefs: []
  type: TYPE_NORMAL
- en: Weaknesses of the Host Table Name System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of a centralized master file for name registration certainly worked
    better than using the equivalent of interoffice memos to publish host name lists,
    but it was practical only in the early days of TCP/IP. As the internetwork grew,
    more weaknesses of the host table system became apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central Administration Overload** The changes to the central file became
    more frequent, increasing the administrative load on the individual managing the
    master file, to the point where changes were being made many times per day. As
    the Internet continued to grow, it would eventually have become impossible for
    human beings to enter the changes as fast as they were being submitted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Growth in the Master File Size** Every host needed a line in the master file.
    When the Internet grew to be thousands and eventually millions of devices, the
    file size would have become excessive.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excessive Bandwidth Use** Since the master file was changing so often, this
    also meant that all the devices on the network needed to keep downloading this
    master file repeatedly to stay current. At the same time, the file was also growing
    in size. Frequent downloads of a big file meant large amounts of network bandwidth
    were being consumed on something that was, in essence, an overhead activity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flat Name Space Problems** The lack of a hierarchical name space led to conflicts
    when users chose identical names for their devices, and this further increased
    the workload on the central administrator. These issues were ameliorated in part
    by using naming conventions, such as using a prefix with a location before each
    individual machine name (like the example we saw in [Chapter 50](ch50.html "Chapter 50. NAME
    SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES")), but this was not an ideal solution.'
  prefs: []
  type: TYPE_NORMAL
- en: All of these are reasons why the designers of the Internet eventually moved
    away from using host tables for the entire Internet to the more capable DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The *host table name system* was the original mechanism used
    for implementing names on the early Internet. It consists simply of a set of tables
    containing mappings between names and addresses maintained on each machine in
    the internetwork. When a name needs to be resolved, the table is consulted to
    determine the appropriate address. This system is extremely simple, but not very
    capable and not well suited to a large global Internet, which is why it was eventually
    abandoned in favor of DNS.'
  prefs: []
  type: TYPE_NORMAL
- en: Use of the Host Table Name System in Modern Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the host table name system has critical weaknesses, it has not gone
    away entirely. There are two circumstances in which this technique is still of
    value, as explained in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Small "Island" Networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are setting up a small local area network (LAN) using TCP/IP, and you
    don''t need the names of your devices to be accessible by those outside your network,
    then guess what: You have the equivalent, of sorts, of the early Internet. In
    that case, the host table system is as applicable to you as it was to the Internet
    in the 1970s. You can simply set up host tables on each device and manage them
    manually.'
  prefs: []
  type: TYPE_NORMAL
- en: As long as the LAN is small enough that editing these files periodically is
    not a hassle, this is actually a fast and effective name system, because no exchange
    of messages is needed for resolution. You can even maintain a master file on one
    machine and copy it to the others when changes are required using a script, to
    save time.
  prefs: []
  type: TYPE_NORMAL
- en: Local Name Mappings to Supplement DNS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though modern systems use DNS for most name resolution, they also usually
    still support the use of host table files. You can manually enter common name
    mappings into this file, even for devices that are on the global Internet. Your
    system can then be set up to consult this list before making use of its assigned
    DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the HOSTS file in conjunction with DNS allows you to manually specify
    mappings for commonly accessed sites, which may provide a slight performance improvement
    since there is no need to access a server. Since the HOSTS file doesn't enforce
    any particular structure to names, it is naturally quite possible to put DNS-style
    hierarchical names into the file, as I showed in [Example 51-1](ch51s02.html#example_tcpip_host_table
    "Example 51-1. Example TCP/IP host table"). The file is loaded into memory and
    used to *override* the normal DNS process for names listed in it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you then subject yourself to all the potential maintenance headaches
    of manually edited files. You must update these files as host names or addresses
    are changed in the DNS system. For this reason, this second use of the HOSTS file
    for Internet sites served by DNS is less popular than the use of the file for
    local machines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Even though the host table name system is not the primary mechanism
    used for TCP/IP naming, it is still used in two circumstances. The first is to
    implement a basic name system in a small local TCP/IP internetwork. The second
    is as an adjunct to DNS, where it allows manual mappings to be created that override
    the DNS process when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The creation of host tables to map computer names to addresses greatly improved
    the usability of the early Internet and the TCP/IP protocol suite that implemented
    it. Unfortunately, while the host table name system worked well when the internetwork
    was small, it did not scale particularly well as the Internet started to grow
    in size and complexity. The name system had to stay, but the use of host tables
    had to be dispensed with in favor of a newer, more capable system.
  prefs: []
  type: TYPE_NORMAL
- en: Over the period of several years, many engineers worked to create a system that
    would meet not just the needs of TCP/IP internetworks of the time, but also those
    of the future. The new name system was based on a hierarchical division of the
    network into groups and subgroups, with names reflecting this structure. It was
    designed to store data in a distributed fashion to facilitate decentralized control
    and efficient operation, and included flexible and extensible mechanisms for name
    registration and resolution. This new name system for TCP/IP was called the *Domain
    Name System (DNS)*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin our look at DNS in this introductory chapter. I start by providing
    an overview of DNS's development, history, and standards, continuing the history
    begun in the overall look at TCP/IP name systems. I discuss the design goals and
    objectives of the creators of DNS, to help you understand better what its designers
    were trying to do. I then talk about the main components of DNS and the functions
    it performs, relating these to the basic functions explained in the overview section
    on name systems.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Overview, History, and Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aversion that most people have to trying to remember numeric identifiers
    led to the very quick adoption of a name system for devices on the predecessors
    of what we now call the Internet. In the 1960s and early 1970s, names were given
    to machines, and these names were maintained in host tables. The TCP/IP host table
    name system (described in [Chapter 51](ch51.html "Chapter 51. TCP/IP NAME SYSTEMS
    OVERVIEW AND THE HOST TABLE NAME SYSTEM")) worked well for a number of years,
    with a centrally maintained master list used by device administrators to ensure
    a consistent view of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, such a system works well only when the number of devices is small.
    As the budding Internet grew, numerous weaknesses became apparent in the host
    table method, as I detailed in [Chapter 51](ch51.html "Chapter 51. TCP/IP NAME
    SYSTEMS OVERVIEW AND THE HOST TABLE NAME SYSTEM"). Furthermore, the problems with
    the system weren't something that could be easily patched with small changes;
    the problems were structural, part of the basic idea of host tables as a whole.
    A completely new approach was needed for how names would be used on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Early DNS Development and the Move to Hierarchical Domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important paradigm shift made by the TCP/IP engineers was the decision
    to change the name system from one that used a single, centralized list of names
    to a more decentralized system. The idea was to create a structured topology where
    names were organized into *domains*. This idea was first introduced in RFC 799,
    "Internet Name Domains," published in September 1981.
  prefs: []
  type: TYPE_NORMAL
- en: RFC 799 actually describes more the mechanics of delivering electronic mail
    messages between domains than the domains themselves. Interestingly, the standard
    assumes a flat structure of domains in its discussion, while mentioning the possibility
    of creating a hierarchical structure instead. It was the decision to go to such
    a hierarchical name space for domains that led to the creation of DNS in the form
    in which we know it today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many RFC documents describing the development of different aspects of DNS were
    published in the early 1980s. The first real milestone in DNS''s history was probably
    the publishing, in November 1983, of three initial documents discussing DNS concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: RFC 881, "Domain Names Plan and Schedule," discusses the issues involved in
    implementing the new DNS and how to migrate from the older host table system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC 882, "Domain Names: Concepts and Facilities," describes the concepts and
    functional elements of DNS in fairly extensive detail. It includes a discussion
    of the name space, resource records, and how name servers and resolvers work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC 883, "Domain Names: Implementation Specification," provides the nitty-gritty
    details on DNS messaging and operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardization of DNS and Initial Defining Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three "Domain Names" RFC documents published in November 1983 were discussed
    frequently over the months that followed, and the basic DNS mechanism was revised
    many times. Several subsequent RFCs were published, updating the DNS transition
    plan and schedule. Finally, in November 1987, agreement on the operation of the
    system was finalized, and four new RFCs were published that formalized the DNS
    system for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: RFC 1032, "Domain Administrators Guide," specifies administrative procedures
    and policies for those running a domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1033, "Domain Administrators Operations Guide," provides technical details
    on how to operate a DNS server, including how to maintain portions of the DNS
    distributed database of names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1034, "Domain Names - Concepts and Facilities," replaces RFC 882, providing
    an introduction and conceptual description of DNS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1035, "Domain Names - Implementation and Specification," is an update to
    RFC 883, specifying how DNS works in detail, including resource record definitions,
    message types, master file format, and resolver and name server implementation
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These last two documents, RFCs 1034 and 1035, are considered the definitive
    original specification for the operation of DNS. While they are now many years
    old, they still provide the essential description of how DNS works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Internet has grown to include thousands and then millions of sites,
    the importance of DNS has grown as well. Today, most people use DNS almost every
    time they use TCP/IP to access the Internet. It has gone from an alternative form
    of addressing for applications to one that is preferred by most users. It is also
    an important building block of the more complete application layer addressing
    scheme developed for TCP/IP: Uniform Resource Identifiers (URIs) (described in
    [Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM
    RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)")).'
  prefs: []
  type: TYPE_NORMAL
- en: The hierarchical nature of the DNS name space has allowed the Internet to grow
    by making the assignment and mapping of names manageable. The authority structure
    (which defines who is in charge of parts of the name space) is also hierarchical,
    giving local administrators control over the names of devices they manage, while
    ensuring name consistency across the hierarchy as a whole. The distribution of
    data using many name servers and a standardized resolution technique following
    a standard message protocol provides efficiency and reliability. These concepts
    will become clearer as we explore DNS more completely in later sections of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Evolution and Important Additional Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP/IP and the Internet have both changed a lot since 1987, of course, and
    DNS has also had to change. Many RFCs have been written since the base documents
    were published in the late 1980s, most of which further clarify the operation
    of DNS, expand on its capabilities, or define new features for it. You can find
    all of these by searching for "domain" or "DNS" in a list of RFCs. There are dozens
    of these. The following are a few of the more interesting ones:'
  prefs: []
  type: TYPE_NORMAL
- en: RFC 1183, "New DNS RR Definitions," defines several new experimental resource
    record types. Other subsequent RFCs have also defined new resource records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1794, "DNS Support for Load Balancing," discusses load balancing for greater
    performance in DNS servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1995, "Incremental Zone Transfer in DNS," specifies a new feature that allows
    only part of a zone to be transferred to a secondary name server for efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1996, "A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY),"
    adds a new message type to DNS to allow primary (authoritative) DNS servers to
    tell secondary servers that information has changed in the main database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2136, "Dynamic Updates in the Domain Name System (DNS UPDATE)," describes
    a technique for dynamically making resource record changes in the DNS database
    (also called *Dynamic DNS*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2181, "Clarifications to the DNS Specification," discusses several issues
    with the main DNS standards as defined in RFCs 1034 and 1035 and how to address
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2308, "Negative Caching of DNS Queries (DNS NCACHE)," specifies the operation
    of negative caching, a feature that allows a server to maintain information about
    names that do not exist more efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS Adaptation for Internet Protocol Version 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Version 6 of the Internet Protocol (IPv6, covered in [Part II-4](pt07.html "Part II-4. INTERNET
    PROTOCOL VERSION 6 (IPV6)")) was developed starting in the mid-1990s and brought
    with it the need to make changes and enhancements to the operation of DNS. (Even
    though DNS operates at the higher layers, it deals intimately with addresses,
    and addresses have changed in IPv6, as discussed in [Chapter 25](ch25.html "Chapter 25. IPV6
    ADDRESSING").) The modifications required to allow DNS to support IPv6 were first
    defined in RFC 1886, "IPv6 DNS Extensions," which was part of a group of RFCs
    that laid out the fundamentals of IPv6\. Several subsequent standards have been
    published since that time; these are discussed in the section on IPv6 DNS near
    the end of [Chapter 57](ch57.html "Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE
    RECORD, AND MASTER FILE FORMATS").
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter provides a more complete overview of DNS and its development,
    by discussing the design goals of its creators and the protocol's key characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Design Goals, Objectives, and Assumptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we just saw, the elapsed time from the first RFC discussing TCP/IP domain
    names to the publishing of the official standards describing the operation of
    DNS was more than six years. This is a very long time for the development of a
    system, but it isn't surprising. A lot of thought had to go into the creation
    of DNS, to be certain that it would meet all of the many demands that would be
    placed on it.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem was that the creators of DNS needed to worry about both how
    to define the new system and how to migrate from the old one. Considerable time
    was spent figuring out how all the existing hosts would be moved over to the new
    DNS name space and how the new protocols for exchanging DNS information would
    be implemented on them.
  prefs: []
  type: TYPE_NORMAL
- en: The creators of DNS knew they were making the new system because the old one
    didn't scale very well. They also knew that if migration was a difficult problem
    with the small number of hosts in existence at that time, it would be much more
    difficult if they needed to go to another new system in the future. This made
    the key challenge in DNS to create a system that would meet the needs of the Internet
    not just the day it was introduced, or the following year, but even ten years
    or more down the road.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Design Goals and Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in the 1980s, no one had any idea how the Internet would grow as it has
    in the last decade. That DNS still works as well as it does is a testament to
    the skill of its designers. Much of this success is due to the early groundwork
    put into the design of the system. DNS engineers documented some of what they
    considered to be the main design goals in creating it, which can help us understand
    not just what DNS does, but also why. These design goals and objectives are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creation of a Global, Scalable, Consistent Name Space** The name space needed
    to be capable of spanning a large, global internetwork containing millions of
    machines. It was necessary that it provide a consistent and predictable method
    for naming devices and resources, so they could be easily found. It was also,
    obviously, essential that name duplication be avoided, even when conflicts could
    potentially be between devices on different continents.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Control over Local Resources** Administrators of networks and small
    internetworks on the Internet as a whole needed to be able to have control over
    the naming of their own devices. It would not be acceptable to need to go through
    a central authority for naming every single object, nor would it be acceptable
    for every administrator to need to know the names of everyone else''s networks
    and machines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed Design to Avoid Bottlenecks** The designers of DNS knew that
    they would need to abandon the idea of a centralized database in favor of a distributed
    approach to data storage, to avoid the bottlenecks that would result in using
    DNS with many devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Universality** The system needed to be general enough that it
    would support a wide variety of applications. For example, it needed to support
    host identification, mail delivery, and other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Underlying Protocol Support** DNS needed to be inherently able to
    support different underlying protocols. Many people don''t realize, for example,
    that DNS can support not just IP addresses, but other types of addresses, simply
    because IP is so dominant in networking today.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Universality** Both large and small computers needed to be able
    to use the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep these objectives in mind as you learn more about DNS, and they will help
    you understand better why certain design attributes were chosen. For example,
    if we consider the first two objectives listed, they seem almost contradictory:
    How can we have a global name space with unique names if individual administrators
    were able to assign local names? As you will see, this is where the power of the
    DNS hierarchical name space shines through.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Design Assumptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The design goals tell us what DNS''s creators wanted to make sure the new system
    addressed. In addition, the engineers that worked on the protocol''s implementation
    details needed to make decisions based on certain assumptions of how it would
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rapidly Growing Database Size** By the mid-1980s, it was obvious that the
    DNS database of names would start out rather small but would grow quickly. The
    system needed to be capable of handling this rapid growth.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable Data Modification Rate** Most of the data in the name database would
    change only infrequently, but some data would change more often than that. This
    meant flexibility would be required in how data changes were handled and how information
    about those changes was communicated.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delegatable Organizational Responsibility** Responsibility for portions of
    the name database would be delegated primarily on the basis of organizational
    boundaries. Many organizations would also run their own hardware and software
    to implement portions of the overall system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relative Importance of Name Information Access** It was assumed that the
    most important thing about DNS was providing reliable name resolution, so the
    system was created so that it was always possible for a user to access a name
    and determine its address. A key decision in creating the system was deciding
    that even if the information were slightly out of date, it was better than no
    information at all. If a name server were unable to provide the latest data to
    fill a request, it would return the best information it had available.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling of Requests for Missing Information** Since the name data was to
    be distributed, a particular name server might not have the information requested
    by a user. In this case, the name server should not just say, "I don''t know."
    It should provide a referral to a more likely source of the information or take
    care of finding the data by issuing its own requests. This led to the creation
    of the several DNS name resolution techniques: local, iterative, and recursive.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use of Caching for Performance** From the start, it was assumed that DNS
    would make extensive use of caching to avoid unnecessary queries to servers containing
    parts of the distributed name database.'
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, a lot more assumptions were made in creating this system, as is the
    case in the development of every system. For example, DNS needed to make assumptions
    about how exactly data would be stored, the transport mechanism for sending messages,
    the role of administrators, and so on. You'll learn more about these as we go
    through our look at the system.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Components and General Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To meet the many objectives set for it by its designers, DNS requires a great
    deal of functionality. It is a true name system with the emphasis on *system*,
    and as such, is considerably more complex than the host table name system used
    earlier in TCP/IP. In [Chapter 50](ch50.html "Chapter 50. NAME SYSTEM ISSUES,
    CONCEPTS, AND TECHNIQUES"), I divided the many tasks of a full-featured name system
    into three categories. DNS includes functions in all of these categories, and
    so using these categories is a good way to take a high-level look at the way DNS
    works (see [Figure 52-1](ch52s03.html#dns_functions_dns_consists_of_three_main
    "Figure 52-1. DNS functions DNS consists of three main functional categories:
    name space, name registration, and name servers/resolution. Each of these consists
    of a number of specific tasks and responsibilites.")).'
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS functions DNS consists of three main functional categories: name space,
    name registration, and name servers/resolution. Each of these consists of a number
    of specific tasks and responsibilites.](httpatomoreillycomsourcenostarchimages288153.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 52-1. DNS functions DNS consists of three main functional categories:
    name space, name registration, and name servers/resolution. Each of these consists
    of a number of specific tasks and responsibilites.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DNS uses a hierarchical name space consisting of a single, complex, multiple-level
    structure into which all names in the system fit. The name space is organized
    starting from a single root into which containers (called *domains*) are placed.
    Each can contain either individual device names or more specific subcontainers.
    The overall structure is somewhat analogous to how a directory system on a computer
    organizes files from general to specific, using an arbitrary structure that can
    be optimized to various needs. A specific syntax is used to define valid names,
    and special terminology is used to describe parts of the structure and identify
    domain names, from the root down to the device level.
  prefs: []
  type: TYPE_NORMAL
- en: Name Registration (Including Administration and Authorities)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DNS name registration is used to enter individual names into the DNS distributed
    database. DNS uses a hierarchical arrangement of authorities that complements
    the hierarchical name space. A centralized authority determines the overall shape
    and structure of the name space and handles registration of names at the highest
    level. Authority is then *delegated* to different organizations to manage various
    parts of the name space. A set of universal policies controls the registration
    process and deals with problems and conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Name Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DNS uses a powerful, distributed, client/server name resolution mechanism. This
    is probably the area where the most attention needed to be put into the design
    of DNS, to ensure that it could scale to handle millions and eventually billions
    of name resolution requests each day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name resolution process is implemented using two basic software elements
    that play the role of server and client: name servers and name resolvers.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS name servers are special programs running on hardware servers that are the
    heart of DNS. Servers are maintained by organizations that have administrative
    control over part of the DNS name space. They contain *resource records* that
    describe names, addresses, and other characteristics of those portions of the
    name space. As such, the servers themselves are arranged into a hierarchy analogous
    to that of the name space, although not identical in structure.
  prefs: []
  type: TYPE_NORMAL
- en: The main job of name servers is to receive requests for name resolution and
    respond with either the data requested from the database or with the name of another
    name server that will lead to the requested information. Name servers are also
    responsible for data caching and other administrative tasks to ensure efficient
    operation of the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Name resolvers are the usual clients in the name resolution process. When a
    user makes reference to a name in a networking application, the name is passed
    to the resolver, which issues a request to a name server. Depending on the configuration,
    more than one request may be needed, and several different resolution processes
    may be combined to find the needed information. Resolvers also may employ caching
    or implement other features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The division between resolvers and servers is based on roles. As you''ll see
    when we look at name resolution, name servers may also function as clients in
    certain exchanges of data. See [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION
    CONCEPTS AND RESOLVER OPERATIONS") for an explanation of this apparent paradox*.'
  prefs: []
  type: TYPE_NORMAL
- en: If this seems a lot like the classic description of a name system that I gave
    in [Chapter 50](ch50.html "Chapter 50. NAME SYSTEM ISSUES, CONCEPTS, AND TECHNIQUES"),
    that's not a coincidence. DNS is considered *the* name system against which most
    others are usually compared. If you understand these high-level descriptions,
    then you already know the basics of how DNS works. The next three chapters delve
    into each of these three functional areas in more detail and will help you really
    learn how DNS does its thing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** As a complete name system, DNS provides numerous capabilities
    that implement each of the three basic name system functions. The DNS *name space*
    is hierarchical and is organized using a multilevel structure with particular
    naming rules. The DNS *name registration* system is based on the idea of a hierarchy
    of domains and registration authorities responsible for them. DNS *name resolution*
    is similarly hierarchical, and it is designed around interaction between *name
    resolver* and *name server* software components that consult databases of DNS
    *resource records* and communicate using a special messaging protocol to answer
    client queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The name space is the most fundamental part of any name system, since it is
    what defines the ways that the names themselves are created. The name space tells
    us what form names may take and provides the rules for how they are created. Most
    important, it specifies the *architecture* of the names—the internal structure
    of names themselves. This, in turn, has a critical influence on how name registration
    and resolution work, making an examination of name space and architecture issues
    the obvious place to start in learning the details of the Domain Name System (DNS).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe the concepts behind the DNS name space and its structure.
    I begin with an overview of the DNS name space and description of the hierarchical
    architecture it uses. I then explain the terminology often used to refer to parts
    of the name space. Next, I provide a formal description of DNS labels and the
    official and unofficial rules for creating domain names. I conclude with a description
    of domain name specifications, and I explain the concept of qualification and
    how fully qualified and partially qualified names differ.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Domains and the DNS Hierarchical Name Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important element of a name system's name space is its *name architecture*,
    which describes how names are constructed and interpreted. The architecture of
    DNS is, unsurprisingly, based on the concept of an abstraction called a *domain*.
    This is obviously a good place to start in explaining how DNS works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Essential Concept in the DNS Name Space: Domains'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dictionary definitions of the word *domain* generally convey the notion of a
    sphere of influence or an area of control or rulership. An essential concept is
    that in various contexts, control or authority can be exerted at many different
    levels. One sphere of influence may contain smaller ones, which can, in turn,
    contain still smaller ones. This means that such domains are naturally arranged
    in a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider geopolitical domains. We have no centralized "world
    government" on earth, but we do have the United Nations, which deals with worldwide
    issues. At the next level down, we have individual countries. Some of these countries
    have divisions such as states and provinces. Still lower levels have counties,
    municipalities, neighborhoods, and individual residences or businesses. The "domains"
    are inherently hierarchical in organization.
  prefs: []
  type: TYPE_NORMAL
- en: DNS uses the word *domain* in a manner very similar to this, and it employs
    a hierarchical structure that works in much the same way as the geopolitical example.
    In DNS, a *domain* is defined as either a single object or a set of objects that
    have been collected together based on some type of commonality. Usually, in DNS,
    that commonality is that they are all administered by the same organization or
    authority, which makes the name hierarchy tightly linked to the notion of the
    DNS hierarchical authority structure (see [Chapter 54](ch54.html "Chapter 54. DNS
    NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES")).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The term domain is also used in other contexts in the world of networking.
    The most notable example of this is in Microsoft networking, where domain is also
    used to represent the notion of a collection of objects under common authority.
    However, the two types of domains are completely different and not related beyond
    this conceptual level*.'
  prefs: []
  type: TYPE_NORMAL
- en: The DNS Hierarchical Tree Structure of Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could construct a tree diagram with the United Nations on top, with lines
    pointing to each of the countries in the world. Then, within the United States,
    we could draw lines to each of the states. Within each state, we could draw lines
    to each county, and so on. The result would be something that looks like an upside-down
    tree, as illustrated in [Figure 53-1](ch53.html#example_of_a_global_hierarchical_domain_
    "Figure 53-1. Example of a global hierarchical domain architecture This diagram
    shows an example of hierarchical architecture, based on political divisions. The
    United Nations is an umbrella organization representing (to one extent or another)
    all of the world's nations. It is the root of the tree; underneath it we find
    individual nations. Each nation then is further subdivided in a manner it chooses.
    For example, Canada has provinces and territories, and the United States has individual
    states. These can be further subdivided in any number of ways."). This is called
    a *tree structure*.
  prefs: []
  type: TYPE_NORMAL
- en: Tree structures are common in computing and networking. For example, trees are
    a type of topology used to connect networks into a local area network.
  prefs: []
  type: TYPE_NORMAL
- en: For understanding DNS, the best example of a tree structure is the directory
    tree used to store files on a computer's hard disk. The root directory is at the
    top of the structure and may contain named files and/or named directories. Each
    directory can itself contain individual files or subdirectories, which can, in
    turn, contain their own subdirectories, and so on. The domain name structure in
    DNS is conceptually arranged in the same way, but instead of dealing with files,
    DNS deals with named objects, usually devices like Internet Protocol (IP) hosts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a global hierarchical domain architecture This diagram shows an
    example of hierarchical architecture, based on political divisions. The United
    Nations is an umbrella organization representing (to one extent or another) all
    of the world''s nations. It is the root of the tree; underneath it we find individual
    nations. Each nation then is further subdivided in a manner it chooses. For example,
    Canada has provinces and territories, and the United States has individual states.
    These can be further subdivided in any number of ways.](httpatomoreillycomsourcenostarchimages288155.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 53-1. Example of a global hierarchical domain architecture This diagram
    shows an example of hierarchical architecture, based on political divisions. The
    United Nations is an umbrella organization representing (to one extent or another)
    all of the world's nations. It is the root of the tree; underneath it we find
    individual nations. Each nation then is further subdivided in a manner it chooses.
    For example, Canada has provinces and territories, and the United States has individual
    states. These can be further subdivided in any number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: The highest level is still the *root* of the tree. It contains a number of domains,
    each of which can contain individual objects (names) and/or lower-level domains.
    Lower-level domains can, in turn, have still lower-level domains, allowing the
    tree as a whole to take on an arbitrary structure.
  prefs: []
  type: TYPE_NORMAL
- en: Like a directory structure, the DNS hierarchical name architecture allows names
    to be organized from most general to most specific. It also has complete flexibility,
    allowing us to arrange the structure in any way that we want. For example, we
    could make a name system that is structured exactly paralleling the geopolitical
    organization chart shown in [Figure 53-1](ch53.html#example_of_a_global_hierarchical_domain_
    "Figure 53-1. Example of a global hierarchical domain architecture This diagram
    shows an example of hierarchical architecture, based on political divisions. The
    United Nations is an umbrella organization representing (to one extent or another)
    all of the world's nations. It is the root of the tree; underneath it we find
    individual nations. Each nation then is further subdivided in a manner it chooses.
    For example, Canada has provinces and territories, and the United States has individual
    states. These can be further subdivided in any number of ways."). We could have
    the root of the name structure represent the United Nations and create a domain
    for each country. Then, for those countries that have states, we could create
    state domains within those country domains. Smaller countries not needing those
    domains could have city domains directly under the country domain. The hierarchy
    is flexible, because at each level, it can be given a suitable substructure.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The DNS name space is arranged into a *hierarchy of domains*
    shaped like an inverted tree. It is structurally similar to the directory structure
    of a file system, with a root that contains domains, each of which can contain
    subdomains and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that every stand-alone internetwork can have its
    own name space and unique hierarchical structure. Many times, people conflate
    the idea of *a* DNS name space with *the* DNS name space. The latter refers to
    the DNS hierarchy used for the global Internet, and it's obvious that this deserves
    a great deal of attention. But it is just one possible arrangement, although an
    important one, of an infinite number of possible structures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*[Chapter 54](ch54.html "Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION,
    ZONES, AND AUTHORITIES") provides more specific information about the Internet''s
    DNS hierarchy. As you''ll see, geopolitical structures are, in fact, used to assign
    names to some of the Internet''s computers, but other parts of the hierarchy are
    different*.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Structural Elements and Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've reviewed the fundamentals of the DNS name space, let's look at
    its structure in more detail. At the same time, I'll define the many different
    terms used to refer to parts of the DNS domain name hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Tree-Related Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I explained in the previous section, the DNS name structure is shaped somewhat
    like a tree. The comparison between structured elements and trees is a common
    one in networking. The main difference between technology and biology is that
    DNS trees grow from the top down, instead of reaching for the sky. The analogy
    to a tree naturally leads to the use of several tree-related terms in describing
    the DNS name structure, some of which are illustrated in [Figure 53-2](ch53s02.html#dns_tree-related_and_domain-related_term
    "Figure 53-2. DNS tree-related and domain-related terminology The top of the DNS
    name space is the root of the tree, and it has no name. Under the root comes any
    number of top-level domains (TLDs). Within each of these can be placed second-level
    domains, then within those subdomains, and so forth. Some of the tree terminology
    used in DNS is also shown here. The portion of the tree with the light shading
    is one branch; the darker area highlights a smaller subbranch within that branch.
    The darkest nodes within that area are the leaves of that smaller branch of the
    tree."):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root** This is the conceptual top of the DNS name structure. The *root* domain
    in DNS contains the entire structure. By definition, it has no name; it is *null*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Branch** A *branch* is any contiguous portion of DNS hierarchy. It consists
    of a domain and all the domains and objects within it. All branches connect together
    to the root, just as in a real tree. (Yes, it would be better if the root were
    called the *trunk*, but computer science majors apparently don''t take botany
    electives.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Leaf** This is an end object in the structure; that is, a domain that doesn''t
    have anything underneath it. The analogy to a leaf being at the end of a sequence
    of branches is apt.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no specific term to refer to a domain that is not a leaf. These are
    sometimes called *interior nodes*, meaning that they are in the middle of the
    structure. A *node* is the generic computing term for an object in a topology
    or structure. So, in DNS, every node is a domain, and it may be an interior node
    that contains additional domains and/or objects or a leaf that is a specific,
    named device. The term *domain* is thus somewhat ambiguous, as it can refer to
    either a collection of objects that represents a branch of the tree or to a specific
    leaf.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Domain-Related Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are also several domain-like terms that are often used to refer to domains
    at different levels of the hierarchy. These terms are also shown in [Figure 53-2](ch53s02.html#dns_tree-related_and_domain-related_term
    "Figure 53-2. DNS tree-related and domain-related terminology The top of the DNS
    name space is the root of the tree, and it has no name. Under the root comes any
    number of top-level domains (TLDs). Within each of these can be placed second-level
    domains, then within those subdomains, and so forth. Some of the tree terminology
    used in DNS is also shown here. The portion of the tree with the light shading
    is one branch; the darker area highlights a smaller subbranch within that branch.
    The darkest nodes within that area are the leaves of that smaller branch of the
    tree."):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root Domain** This is the root of the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-Level Domains (TLDs)** These are the highest-level domains directly under
    the root of the tree. They are also sometimes called *first-level domains*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second-Level Domains** Shockingly enough, these are the domains located directly
    below the top-level domains.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subdomains** In some contexts, this term refers only to domains that are
    located directly below the second-level domains.'
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS tree-related and domain-related terminology The top of the DNS name space
    is the root of the tree, and it has no name. Under the root comes any number of
    top-level domains (TLDs). Within each of these can be placed second-level domains,
    then within those subdomains, and so forth. Some of the tree terminology used
    in DNS is also shown here. The portion of the tree with the light shading is one
    branch; the darker area highlights a smaller subbranch within that branch. The
    darkest nodes within that area are the leaves of that smaller branch of the tree.](httpatomoreillycomsourcenostarchimages288157.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 53-2. DNS tree-related and domain-related terminology The top of the
    DNS name space is the root of the tree, and it has no name. Under the root comes
    any number of top-level domains (TLDs). Within each of these can be placed second-level
    domains, then within those subdomains, and so forth. Some of the tree terminology
    used in DNS is also shown here. The portion of the tree with the light shading
    is one branch; the darker area highlights a smaller subbranch within that branch.
    The darkest nodes within that area are the leaves of that smaller branch of the
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The top of the DNS name space is the *root*. Under the root
    come *top-level domains*, and within these are *second-level domains* and then
    *subdomains*. In theory, any number of levels of subdomains can be created. A
    branch is any contiguous portion of the DNS tree. A leaf is a domain with nothing
    underneath it in the structure, and it usually represents a single device.'
  prefs: []
  type: TYPE_NORMAL
- en: The term *subdomain* can also be used generically, like the word *domain* itself.
    In that case, it refers simply to the relationship between two domains, with a
    subdomain being under another domain in the structure. This means, for example,
    that top-level domains can be said to be subdomains of the root; every second-level
    domain is a subdomain of a top-level domain, and so on. But again, sometimes *subdomain*
    means specifically a third-level or lower domain.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Family-Related Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another set of terminology related to DNS compares the tree structure not to
    a living tree, but to another analogy: a family tree. These terms are most often
    used to describe how a particular domain relates to the other domains or subdomains
    around it, so they are relative terms. The following family-related terms are
    common (see [Figure 53-3](ch53s02.html#dns_name_space_family_tree_this_diagram_
    "Figure 53-3. DNS name space "family tree" This diagram is similar to Figure 53-2,
    but the nodes are labeled to show the family-oriented terminology sometimes used
    in DNS. In this case, the names are relative to the interior node shown in the
    darker shade. The domain immediately above it is its parent node. Other nodes
    on the same level are siblings, and subdomains within it are children of that
    node.")).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent Domain** This is the domain that is above this one in the hierarchy.
    For example, the root domain is the parent of all top-level domains.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Child** This is a domain at the next level down from this one in the hierarchy.
    Thus, the top-level domains are *children* of the root.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sibling** This is a peer at the same level as this one in the hierarchy,
    with the same parent. Thus, all top-level domains are *siblings* with the root
    as a parent; all second-level domains within a particular top-level domain are
    siblings, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS name space "family tree" This diagram is similar to , but the nodes are
    labeled to show the family-oriented terminology sometimes used in DNS. In this
    case, the names are relative to the interior node shown in the darker shade. The
    domain immediately above it is its parent node. Other nodes on the same level
    are siblings, and subdomains within it are children of that node.](httpatomoreillycomsourcenostarchimages288159.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 53-3. DNS name space "family tree" This diagram is similar to [Figure 53-2](ch53s02.html#dns_tree-related_and_domain-related_term
    "Figure 53-2. DNS tree-related and domain-related terminology The top of the DNS
    name space is the root of the tree, and it has no name. Under the root comes any
    number of top-level domains (TLDs). Within each of these can be placed second-level
    domains, then within those subdomains, and so forth. Some of the tree terminology
    used in DNS is also shown here. The portion of the tree with the light shading
    is one branch; the darker area highlights a smaller subbranch within that branch.
    The darkest nodes within that area are the leaves of that smaller branch of the
    tree."), but the nodes are labeled to show the family-oriented terminology sometimes
    used in DNS. In this case, the names are relative to the interior node shown in
    the darker shade. The domain immediately above it is its parent node. Other nodes
    on the same level are siblings, and subdomains within it are children of that
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The domain above a given domain in the DNS name space is called
    its *parent domain*. Domains at the same level within the same parent are *siblings*.
    Subdomains are called *children* of that domain.'
  prefs: []
  type: TYPE_NORMAL
- en: Like a real tree, the DNS name structure must be a true tree in its structure.
    Every domain can have only one parent (except the root), just as every branch
    of a tree connects to only one limb (except the root/trunk). Also, no loops can
    appear in the structure; you cannot have a domain whose child is also its parent,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A DNS name space must be arranged as a true topological tree.
    This means each domain can have only one parent, and no loops are permitted in
    the structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that even though the name hierarchy represents an arrangement of
    named devices, it is only a logical structure. There is no necessary correspondence
    to the physical location of devices. A domain with 10 children may represent 11
    devices in 11 different countries. We'll explore this more when we look at DNS
    authority structures in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Labels, Names, and Syntax Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen how the DNS name space hierarchy allows us to arrange domains into
    a virtual tree that reflects the characteristics of how the devices themselves
    are organized. While using a hierarchical name space is inherently more complex
    than a flat name space, it yields a powerful result: the ability to specify names
    that can be locally managed while remaining globally unique. At the same time,
    the complexity of the tree yields the benefit of relatively simple name construction
    using domain identifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Labels and Label Syntax Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Naming in DNS begins with giving each domain, or node, in the DNS name space
    a text *label*. The label identifies the domain within the structure and must
    follow several syntax rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Length** Each label can theoretically be from 0 to 63 characters in length.
    In practice, a length of 1 to about 20 characters is most common, with a special
    exception for the label assigned to the root of the tree (which is 0 characters
    in length, as explained in the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbols** Letters and numbers are allowed, as well as the dash character
    (-). No other punctuation is permitted. For example, an underscore (_) cannot
    be used in a label.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case** Labels are not case-sensitive. For example, *Jabberwocky* and *jabberwocky*
    are equivalent domain name labels.'
  prefs: []
  type: TYPE_NORMAL
- en: Every label must be unique within its parent domain. So, for example, if we
    have a top-level domain called Rocks, we can have only one subdomain within Rocks
    called Crystal. Due to the case-insensitivity of labels, we cannot have both CRYSTAL
    and Crystal within Rocks, because they are considered the same.
  prefs: []
  type: TYPE_NORMAL
- en: It is this concept of *local uniqueness* within a parent domain that ensures
    the uniqueness of names as a whole, while allowing local control over naming.
    Whoever is in charge of the Rocks domain can assign names to as many individual
    objects or subdomains as he likes, as long as those names are unique within the
    domain. Someone else, say, the maintainer of the Glass domain, can also create
    a subdomain called Crystal within Glass. There will not be a conflict, because
    the Glass and Rocks domains are separate. Of course, since all top-level domains
    have the same parent (the root), all top-level domains must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each node in the DNS name space is identified by a label. Each
    *label* must be unique within a parent domain, but it does not need to be unique
    across domains. This enables each domain to have local control over the names
    of subdomains, without causing any conflicts in the full domain names created
    on a global level.'
  prefs: []
  type: TYPE_NORMAL
- en: Domain Name Construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each individual domain within the domain name structure can be uniquely identified
    using the sequence of labels that starts from the root of the tree and progresses
    down to that domain. The labels at each level in the hierarchy are listed in sequence,
    starting with the highest level, from right to left, separated by dots. The result
    is the formal definition of a *domain name*.
  prefs: []
  type: TYPE_NORMAL
- en: The root of the name space is given a zero-length, null name by default; that
    is, the label for the root exists, but it's empty. This is done because the root
    technically is part of every domain name, so it must be included in every domain
    name. If it were something long like Root, we would need to include that at the
    end of every domain name. This would simply make every name longer, while not
    really adding any useful information—we already know every domain name is under
    the root.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example of a top-level domain called Rocks, within which is a second-level
    domain Crystal. The domain name of Rocks is Rocks., with the dot separating Rocks
    and the empty label (the null root). In practice, the trailing dot is often omitted,
    so the domain name of the top-level domain Rocks can be considered as just Rocks.
    The subdomain Crystal within Rocks has the domain name Crystal.Rocks. If we had
    a device named Salt within the Crystal.Rocks domain, it would be called Salt.Crystal.Rocks.
    This is fairly straightforward, as you can see in [Figure 53-4](ch53s03.html#dns_labels_and_domain_name_construction_
    "Figure 53-4. DNS labels and domain name construction Each node in the DNS name
    space has a label (except the root, whose label is null). The domain name for
    a node is constructed simply by placing in order the sequence of labels from the
    top of the tree down to the individual domain, going from right to left, separating
    each label with a dot (period).").
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS labels and domain name construction Each node in the DNS name space has
    a label (except the root, whose label is null). The domain name for a node is
    constructed simply by placing in order the sequence of labels from the top of
    the tree down to the individual domain, going from right to left, separating each
    label with a dot (period).](httpatomoreillycomsourcenostarchimages288161.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 53-4. DNS labels and domain name construction Each node in the DNS name
    space has a label (except the root, whose label is null). The domain name for
    a node is constructed simply by placing in order the sequence of labels from the
    top of the tree down to the individual domain, going from right to left, separating
    each label with a dot (period).
  prefs: []
  type: TYPE_NORMAL
- en: We can use these names to easily identify subdomains of a particular domain.
    For example, if we start with Salt.Crystal.Rocks, it's obvious that Crystal.Rocks
    is its parent domain. It's also clear that both Crystal.Rocks and Salt.Crystal.Rocks
    are subdomains of Rocks; one is a single level down from Rocks, and the other
    is two levels down.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a maximum limit of 255 characters for a complete domain name,
    for implementation purposes. In practice, most domain names are much shorter than
    this limit, as it would violate the whole purpose of domain names if we let them
    get so long that no one could remember them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A *domain name* is a string of text that uniquely identifies
    a particular node in the name space. The domain name for a node is constructed
    by concatenating in right-to-left order all the labels in the branch of the DNS
    tree, starting from the top of the tree down to the particular node, separating
    each by a dot (period).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, note that in many protocols, it is possible to specify a particular
    resource within a domain name by providing a directory structure after a name.
    This is done using the standard TCP/IP URL syntax, where a path is indicated using
    slashes to separate subdirectories. For example, a specific file at Salt.Crystal.Rocks
    might be located at Salt.Crystal.Rocks/chem/composition. While DNS names are case-insensitive,
    the labels in a path are case-sensitive. So, this example would be different from
    Salt.Crystal.Rocks/chem/Composition. See the discussion of URL syntax in [Chapter 70](ch70.html
    "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS,
    LOCATORS, AND NAMES (URIS, URLS, AND URNS)") for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute (Fully Qualified) and Relative (Partially Qualified) Domain Name Specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in the previous section, we can specify the domain name of any
    node in the DNS name hierarchy by simply starting at the root node and following
    the sequence of subdomains down to the node in question, listing each level's
    labels separated by a dot. When we do this, we get a single name that uniquely
    identifies a particular device. In practice, domain names can be specified by
    their fully qualified names or their partially qualified names.
  prefs: []
  type: TYPE_NORMAL
- en: Fully Qualified Domain Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technically, if a top-level domain A contains a subdomain B that contains subdomain
    C, the full domain name for C is C.B.A.. This is called the *fully qualified domain
    name (FQDN)* for the node. Here, the word *qualified* is synonymous with *specified*.
    The domain name C.B.A. is fully qualified because it gives the full location of
    the specific domain that bears its name within the whole DNS name space.
  prefs: []
  type: TYPE_NORMAL
- en: FQDNs are also sometimes called *absolute* domain names. This term reflects
    the fact that you can refer unambiguously to the name of any device using its
    FQDN from any other portion of the name space. Using the FQDN always instructs
    the person or software interpreting the name to start at the root, and then follow
    the sequence of domain labels from right to left, going top to bottom within the
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Partially Qualified Domain Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also some situations in which you may refer to a device using an incomplete
    name specification. This is called a *partially qualified domain name (PQDN)*,
    which means that the name only partially specifies the location of the device.
    By definition, a PQDN is ambiguous, because it doesn't give the full path to the
    domain. Thus, you can use a PQDN only within the context of a particular parent
    domain, whose absolute domain name is known.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the FQDN of a partially specified domain name by appending the partial
    name to the absolute name of the parent domain. For example, if we have the PQDN
    Z within the context of the FQDN Y.X., we know the FQDN for Z is Z.Y.X.
  prefs: []
  type: TYPE_NORMAL
- en: Why bother with this? The answer is convenience. An administrator for a domain
    can use PQDNs as a shorthand to refer to devices or subdomains without needing
    to repeat the entire full name. For example, suppose you are in charge of the
    computer science department at the University of Widgetopia. The domain name for
    the department as a whole is cs.widgetopia.edu., and the individual hosts you
    manage are named after fruit. In the DNS files you maintain, you could refer to
    each device by its FQDN every time; for example, apple.cs.widgetopia.edu., banana.cs.widgetopia.edu.,
    and so on. But it's easier to tell the software, "If you see a name that is not
    fully qualified, assume it is in the cs.widgetopia.edu domain." Then you can just
    call the machines apple, banana, and so on. Whenever the DNS software sees a PQDN
    such as kiwi, it will treat it as kiwi.cs.widgetopia.edu.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A *fully qualified domain name (FQDN)* is a complete domain
    name that uniquely identifies a node in the DNS name space by giving the full
    path of labels from the root of the tree down to that node. It defines the absolute
    location of a domain. In contrast, a *partially qualified domain name (PQDN)*
    specifies only a portion of a domain name. It is a relative name that has meaning
    only within a particular context. The partial name must be interpreted within
    that context to fully identify the node.'
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned earlier in this chapter that the trailing dot for the null root
    domain is usually omitted. This is true in common parlance and when users specify
    a domain name in an application. You don't use the trailing dot in your web browser,
    for instance. However, the dot is used to clearly distinguish a FQDN from a PQDN
    within DNS master files. This allows us to use both FQDNs and PQDNs together.
    In our example, apple would refer to apple.cs.widgetopia.edu., but apple.com.
    would refer to the FQDN for Apple Computer, Inc. You must be careful about watching
    the dots here, because apple.com (without a trailing period) would be a PQDN and
    would refer to apple.com.cs.widgetopia.edu., not the domain of Apple Computer.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous chapter explained how the Domain Name System (DNS) name space
    consists of a hierarchy of domains and subdomains. From the root, we have a number
    of top-level domains, then second-level domains below them, and still lower-level
    domains below that. The obvious questions then become: How do we determine the
    shape and structure of the name space, and who will manage it? More specifically,
    who will control the root of the tree and decide what the top-level domains will
    be called? How will we then subdivide control over the rest of the name space?
    How do we ensure there are no conflicts in choosing the names of sibling subdomains
    within a domain?'
  prefs: []
  type: TYPE_NORMAL
- en: DNS can be used on private networks controlled by a single organization, and
    if so, that organization is obviously in charge of the name space. We'll discuss
    private naming, but in reality, it's just not that interesting. The vast majority
    of DNS use occurs on the public Internet. Here, we have a much greater challenge,
    because we need to construct a name space that spans the globe and covers millions
    of machines managed by different organizations. For this, we need a very capable
    *name registration* process and administration methods to support it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will describe the process of name registration and how authorities
    are managed within DNS, focusing on the public Internet. I begin with a description
    of the DNS hierarchical authority structure and how it relates to the hierarchical
    name space, and a discussion of the concepts behind the DNS distributed name database.
    I describe the Internet's organizational and geopolitical top-level domains, and
    how they are administered by various authorities. I then discuss how authority
    is delegated to the second-level and lower-level domains, and how public registration
    of domain names works, including how public registration issues and problems are
    resolved. I explain how the DNS name space is partitioned into administrative
    zones of authority, and then I conclude with a brief discussion of private DNS
    name registration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *Most TCP/IP implementations include a special utility
    called whois that can be used to interrogate the DNS distributed name database
    to obtain registration information about domains. This application can be very
    useful for troubleshooting. For details, see the section discussing whois in [Chapter 88](ch88.html
    "Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS")*.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Hierarchical Authority Structure and the Distributed Name Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, I explained that the central concept of naming in DNS
    is based on *domains*. Each domain can be considered akin to a sphere of influence
    or control. A domain "spreads its wings" over all the objects and subdomains that
    it contains. Due to this concept of influence, when we consider any DNS name space,
    we see that it is hierarchical because it reflects a hierarchy of organizations
    that control domains and the nodes within them. This means that there is a *hierarchical
    authority structure* that complements the hierarchical name structure in DNS.
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason why the name space hierarchy leads to an authority hierarchy
    is the requirement that sibling subdomains be unique within a domain. As soon
    as we have a need for uniqueness, we must have some sort of authority or process
    that ensures that each subdomain or object picks a different name within that
    domain. This is what name registration is all about.
  prefs: []
  type: TYPE_NORMAL
- en: This concept of a hierarchical authority structure is a bit abstract, but it's
    easier to understand if we examine a sample DNS name space and discuss the issues
    involved in assigning names within it. Naturally, we want to start at the top
    of the name hierarchy, with the root domain, null.
  prefs: []
  type: TYPE_NORMAL
- en: The DNS Root Domain Central Authority
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start off the name space, we must create top-level domains (TLDs) within
    the root. Now, each of these must be unique, so one authority must manage the
    creation of all TLDs. This means that the authority that controls the root domain
    controls the entire name space.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Internet, this central authority is ultimately responsible
    for every name in DNS. The central DNS authority for the Internet, which controls
    the creation of TLDs, was initially called the *Network Information Center*. It
    was later the *Internet Assigned Numbers Authority (IANA)*, which is also responsible
    for protocol numbers, IP addresses, and more. These functions are now shared by
    IANA and the *Internet Corporation for Assigned Names and Numbers (ICANN)*. We'll
    discuss the specific TLDs of the Internet in the next few chapters; IANA, ICANN,
    and related organizations are discussed in the section on Internet registration
    authorities in [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS
    ORGANIZATIONS").
  prefs: []
  type: TYPE_NORMAL
- en: TLD Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the next level down in the authority hierarchy, we create second-level domains
    within each of the TLDs. Each TLD must itself be managed using a coordinating
    authority, however, this is not necessarily the organization that runs the root
    (IANA). IANA *delegates* authority for some of the TLDs to other organizations.
  prefs: []
  type: TYPE_NORMAL
- en: IANA may delegate control for each TLD to a different authority at this level
    of the hierarchy. In fact, there can be completely different rules for managing
    the creation of second-level domains in one TLD than there are in another. And
    in some TLDs, there are multiple authorities that work together on name registration.
  prefs: []
  type: TYPE_NORMAL
- en: Lower-Level Authority Delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This process of authority delegation continues as we move down the name space
    hierarchy. At each level, the name space becomes more specific.
  prefs: []
  type: TYPE_NORMAL
- en: If we use an organizational hierarchy, like the .COM TLD, we generally delegate
    authority for each second-level domain to the organization whose name it represents.
    So, for example, IBM.COM is managed by IBM. Since IBM is huge, it may itself subdivide
    the authority structure further, but smaller organizations probably won't.
  prefs: []
  type: TYPE_NORMAL
- en: Authority Hierarchy's Relationship to the Name Hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The authority hierarchy is complementary to the name hierarchy; they are not
    exactly the same. It is not necessary that there be a different authority for
    every level of the hierarchy. In many cases, a single authority may manage a section
    of the name space that spans more than one level of the structure. For example,
    IANA manages the Internet root domain (null) and also the .INT TLD, but other
    TLDs are managed by other organizations. The name hierarchy is divided into *zones
    of authority* that reflect the hierarchy of authorities that manage parts of the
    name space.
  prefs: []
  type: TYPE_NORMAL
- en: Also, authority over a domain doesn't necessarily imply physical control. A
    domain can contain subdomains that are managed by organizations on different continents,
    and a single subdomain can contain named devices that are on different continents
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The DNS Distributed Name Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, with authority comes responsibility, and the main responsibility
    an authority has for a domain is registering names within the domain. When a name
    is registered, a set of data is created for it, which can then be used by internetwork
    devices to resolve the name into an address or perform other functions.
  prefs: []
  type: TYPE_NORMAL
- en: The set of all the data describing all DNS domains constitutes the DNS *name
    database*. Just as registration authority is distributed and hierarchical, this
    database is distributed and hierarchical. In other words, there is no single place
    where all DNS name information is stored. Instead, DNS servers carry resource
    records (see [Chapter 57](ch57.html "Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE
    RECORD, AND MASTER FILE FORMATS")) that describe the domains for which they have
    authority. As you'll see, the fact that this database is distributed has major
    implications on how name resolution is carried out.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The name space of the public Internet is managed by a *hierarchy
    of authorities* that is similar in structure to the hierarchical DNS name space,
    though not identical. The top of the hierarchy is centrally managed by IANA/ICANN,
    which delegates authority to other organizations for registering names in various
    other parts of the hierarchy. The information about name registrations is maintained
    in resource records stored in various locations, which form a distributed name
    database on the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Organizational (Generic) TLDs and Authorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The top of the DNS name hierarchy is managed by a central authority, which controls
    the entire name space by virtue of deciding which TLDs are allowed to exist. Obviously,
    it is very important that a great deal of thought go into how the TLDs are chosen.
    A poor design at this top level would make the entire hierarchy poorly reflect
    the actual structure of organizations using the name space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creators of DNS could have chosen any number of ways to structure the Internet''s
    name hierarchy. One obvious possibility is to structure the Internet based on
    geopolitical boundaries: countries, states, and so forth. Another sensible idea
    is to structure the name space based on types of organizations.'
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of the hierarchical name space is that we don't need to choose between
    different methods of structuring the name space. We can use more than one technique
    at the same time, and this is exactly what was done when DNS was first implemented.
    Both the organization type and geography structures were used for TLDs. This gives
    multiple options for name registration for most groups and individuals.
  prefs: []
  type: TYPE_NORMAL
- en: I'll begin here by discussing organizational TLDs, and then we'll look at geopolitical
    ones. As you'll see, although there are only a handful of organizational TLDs,
    there is no doubt that they have been much more popular than the geopolitical
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Original Generic TLDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initial deployment of DNS featured a set of seven top-level domains that
    are called *generic* TLDs. The idea was that each company or organization could
    choose a name within one of these TLDs; they were generic enough that every organization
    would find a place that suited them. I prefer to call them *organizational*, because
    they divide the generic portion of the name space by organization type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial TLDs and their original intended organization types were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.ARPA** A temporary domain used many years ago for transition to DNS; today,
    this domain is used for reverse name resolution (see [Chapter 56](ch56.html "Chapter 56. DNS
    RESOLUTION CONCEPTS AND RESOLVER OPERATIONS")).'
  prefs: []
  type: TYPE_NORMAL
- en: '**.COM** Corporations and businesses'
  prefs: []
  type: TYPE_NORMAL
- en: '**.EDU** Universities and other educational organizations'
  prefs: []
  type: TYPE_NORMAL
- en: '**.GOV** Government agencies'
  prefs: []
  type: TYPE_NORMAL
- en: '**.MIL** Military organizations'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET** Organizations that implement, deal with, or manage networking technologies
    and/or the Internet'
  prefs: []
  type: TYPE_NORMAL
- en: '**.ORG** Other organizations that don''t fit into any of the previous classifications'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this seems like a reasonable way to cover the organizations
    of the world. However, since the .ARPA domain (whose name refers to the ARPAnet,
    the precursor of the modern Internet, as described in [Chapter 8](ch08.html "Chapter 8. TCP/IP
    PROTOCOL SUITE AND ARCHITECTURE")) was temporary, this left only six categories
    for all other organizations. Also, the TLDs weren't all used as was originally
    foreseen. For example, the .GOV and .MIL domains were not used for all types of
    government and military organizations, but primarily for the United States federal
    government and military. The .EDU domain ended up being used only for universities,
    again in the United States.
  prefs: []
  type: TYPE_NORMAL
- en: This left only three common TLDs—.COM, .NET, and .ORG—for almost all other groups
    and companies that wanted to use the organizational hierarchy. Since there were
    only three such TLDs, they quickly became very crowded, especially the .COM domain.
    A new fourth domain, .INT for international organizations, was added fairly soon
    to the original seven. However, it was intended only for a small number of organizations,
    such as international standards bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there was no inherent reason why the generic domains should be limited
    to only the few that were originally created.
  prefs: []
  type: TYPE_NORMAL
- en: New Generic TLDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the years, many suggestions were made for new generic TLDs that would expand
    the number of possible second-level domain names and also provide better categorization
    for different organization types—that is, to make the generic TLDs less generic.
    There was some resistance at first to adopting these new names, especially because
    there were so many different ideas about what new TLDs should be created.
  prefs: []
  type: TYPE_NORMAL
- en: IANA took input from a lot of people and followed a complex procedure to determine
    what new TLDs should be made. In 2001 and 2002, approval was given for the creation
    of several new TLDs, and decisions were made about authorities for administering
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Of the new TLDs approved in the past few years, the number that has achieved
    widespread popularity is, to my knowledge, zero. Humans are creatures of inertia,
    and most people are still used to names ending in .COM, .NET, or .ORG. In time
    this may change, but it will probably take a few years.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some people actually felt that adding new generic TLDs was a bad idea, since
    it makes organizations potentially more difficult to locate (due to the possibility
    of a name ending in a variety of different TLDs). This is debatable, however,
    especially since the exhaustion of address space in the existing TLDs means many
    companies have needed to choose unintuitive domain names anyway*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 54-1](ch54s02.html#internet_dns_organizational_generic_top_ "Table 54-1. Internet
    DNS Organizational (Generic) Top-Level Domains") shows all the current generic
    TLDs and describes how they are used, and it lists the current central authority
    that manages each. The original TLDs are highlighted in italics (I am including
    .INT as an original TLD, since it was created long before the "new" ones). [Figure 54-1](ch54s02.html#internet_dns_organizational_generic_tlds
    "Figure 54-1. Internet DNS organizational (generic) TLDs There are 15 generic
    TLDs currently defined for the Internet. They are shown here in alphabetical order,
    with the original TLDs shown in light shading and the new ones added in 2001/2002
    in darker shading.") shows the 15 generic TLDs in graphical form.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Internet DNS organizational (generic) TLDs There are 15 generic TLDs currently
    defined for the Internet. They are shown here in alphabetical order, with the
    original TLDs shown in light shading and the new ones added in 2001/2002 in darker
    shading.](httpatomoreillycomsourcenostarchimages288163.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 54-1. Internet DNS organizational (generic) TLDs There are 15 generic
    TLDs currently defined for the Internet. They are shown here in alphabetical order,
    with the original TLDs shown in light shading and the new ones added in 2001/2002
    in darker shading.
  prefs: []
  type: TYPE_NORMAL
- en: Table 54-1. Internet DNS Organizational (Generic) Top-Level Domains
  prefs: []
  type: TYPE_NORMAL
- en: '| Generic TLD | Abbreviation For | Authority | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| .AERO | Aerospace | Société Internationale de Télécommunications Aéronautiques
    (SITA) | Used for members of the aerospace industry, such as airlines and airports.
    (Yes, that is French!) |'
  prefs: []
  type: TYPE_TB
- en: '| *.ARPA* | Address and Routing Parameter Area | IANA/ ICANN | First defined
    as a temporary domain for migration from the older host table system, the *ARPA*
    of course originally stood for the Advanced Research Projects Agency, creators
    of the predecessors of the Internet. Today, the .ARPA domain is used for internal
    Internet management purposes; the expanded name shown in this table was, I believe,
    chosen to fit the acronym. The best-known use of this domain is for reverse DNS
    lookups. |'
  prefs: []
  type: TYPE_TB
- en: '| .BIZ | Business | NeuLevel, Inc. | Used for businesses. Intended as a competitor
    to .COM. |'
  prefs: []
  type: TYPE_TB
- en: '| *.COM* | Commercial Organizations | VeriSign, Inc. | Originally intended
    for corporations and other commercial interests, .COM is also widely used for
    other purposes, including small businesses and even individuals who like the popularity
    of the .COM domain. |'
  prefs: []
  type: TYPE_TB
- en: '| .COOP | Cooperative Associations | Dot Cooperation, LLC | Used for cooperative
    associations. |'
  prefs: []
  type: TYPE_TB
- en: '| *.EDU* | Education | Educause | Originally intended for all types of educational
    organizations, .EDU is now used only for degree-granting higher-education institutions
    accredited in the US. Other educational institutions such as public schools usually
    use the country code TLDs. |'
  prefs: []
  type: TYPE_TB
- en: '| *.GOV* | Government | U.S. General Services Administration | Reserved for
    the U.S. federal government. |'
  prefs: []
  type: TYPE_TB
- en: '| .INFO | Information | Afilias, Ltd. | A very generic TLD designed for information
    resources of various sorts. It is unrestricted, in that anyone can register any
    sort of organization in .INFO. It''s also positioned as an alternative to .COM.
    |'
  prefs: []
  type: TYPE_TB
- en: '| *.INT* | International | IANA .int Domain Registry | Used only for large
    organizations established by international treaty. |'
  prefs: []
  type: TYPE_TB
- en: '| *.MIL* | Military | U.S. DoD Network Information Center | Reserved for the
    U.S. military. |'
  prefs: []
  type: TYPE_TB
- en: '| .MUSEUM | Museum | Museum Domain Management Association | Take a guess. See
    http://index.museum for a complete list of museums using this TLD. |'
  prefs: []
  type: TYPE_TB
- en: '| .NAME | Names | Global Name Registry | In the original generic hierarchy,
    there was no place set aside for individuals to register names for themselves,
    so people would create domains like jonesfamily.org. This was not ideal, so .NAME
    was created as a place for individuals and families to register a domain for their
    names. .NAME also competes with the country code TLDs. |'
  prefs: []
  type: TYPE_TB
- en: '| *.NET* | Network | VeriSign, Inc. | This was supposed to be used only for
    Internet service providers (ISPs) and other organizations working intimately with
    the Internet or networking. Due to the exhaustion of name spaces in .COM and .ORG,
    many .NET domains are registered to other organizations, however. |'
  prefs: []
  type: TYPE_TB
- en: '| *.ORG* | Organizations | Public Interest Registry | Originally intended for
    organizations not fitting into the other generic TLDs, .ORG quickly became associated
    with professional and nonprofit organizations. It is possible, however, to have
    a for-profit company use an .ORG name. |'
  prefs: []
  type: TYPE_TB
- en: '| .PRO | Professional | RegistryPro | Reserved for credentialed professionals
    such as lawyers and doctors. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the two ways in which the Internet''s DNS name space
    is divided is using a set of generic TLDs. These TLDs are intended to provide
    a place for all companies and organizations to be named based on their organization
    type. There were originally six such domains, but this has been expanded so that
    there are now 15.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Geopolitical (Country Code) TLDs and Authorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, the generic TLDs would be sufficient to meet the needs of all the
    individuals, companies, and groups in the world. This is especially true since
    .ORG, by definition, is a catchall that can include anyone or anything. Thus,
    in an ideal world, everyone in the world would have been able to find a place
    in those simple domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, back at the beginning of DNS, its creators recognized that the generic
    TLDs might not meet the needs of everyone around the world, especially in certain
    cases. There are several reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Americentricism of the Generic Domains** I don''t mean this as a criticism
    (I''m an American citizen and love my country!). It is indisputable, however,
    that United States organizations and companies dominate the generic TLDs. This
    is not surprising, given that the Internet was first developed in the United States,
    but it still presents a problem for certain groups. For example, if the United
    States military controls the .MIL domain, where does, say, Great Britain''s military
    fit into the name space?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Language** Most of the generic domains are populated by organizations that
    primarily do business in English. There are hundreds of languages in the world,
    however, and it''s easier for the speakers of those tongues if they can more readily
    locate resources they can understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Control** Countries around the world rarely agree on much, and they
    certainly differ on how organizations within their nations should have their Internet
    presence arranged. There was a desire on the parts of many to allow nations to
    have the ability to set up subsets of the name space for their own use.'
  prefs: []
  type: TYPE_NORMAL
- en: For these and other reasons, the Internet's name space was set up with a set
    of *country code* TLDs paralleling the generic ones, sometimes called *ccTLDs*.
    I call these *geopolitical* TLDs, since they are based on geopolitical divisions
    of the world (similar to the example I used in the overview of the DNS name space
    in [Chapter 53](ch53.html "Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY")).
    In this hierarchy, every country of the world is assigned a particular two-letter
    code as a TLD, with a specific authority put in charge of administering the domain.
    For example, the ccTLD for Great Britain is .UK, the one for Canada is .CA, and
    the one for Japan is .JP. The codes often are more meaningful in the local language
    than in English. For example, Germany's is .DE, and Switzerland's is .CH.
  prefs: []
  type: TYPE_NORMAL
- en: Country Code Designations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I said that countries rarely agree on anything, I wasn't kidding. In fact,
    they can't even agree on what's a country! Real shooting wars have been fought
    over whether or not a particular territory was independent or part of another
    nation, and the creators of DNS wanted no part of this sort of controversy. As
    the IANA website says, "The IANA is not in the business of deciding what is and
    what is not a country, nor what code letters are appropriate for a particular
    country."
  prefs: []
  type: TYPE_NORMAL
- en: To remain neutral, IANA's ccTLD codes are taken directly from the standard country
    abbreviations maintained by the International Organization for Standardization
    (ISO) in ISO Standard 3166-1\. When a country is recognized by the ISO and a code
    assigned to it on this list, IANA creates it as a TLD. There are presently more
    than 200 different geopolitical TLDs. You can find the current list of IANA country
    code TLDs at [http://www.iana.org/cctld/cctld-whois.htm](http://www.iana.org/cctld/cctld-whois.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Due to the limitations of the generic TLDs, a set of *country*
    code top-level domains was created. This *geopolitical hierarchy* allows each
    nation on earth to set up its own name system based on its own requirements and
    to administer it in the manner it sees fit. The IANA determines what is a country
    based on official decisions made by ISO.'
  prefs: []
  type: TYPE_NORMAL
- en: Country Code TLD Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each country has the authority to set up its TLD with whatever internal substructure
    it chooses; again, this is the power of a hierarchical structure.
  prefs: []
  type: TYPE_NORMAL
- en: Some countries enforce a further geographical substructure at the lower levels.
    For example, the .US domain for the United States was originally set up so that
    all second-level domains were two-letter state abbreviations (this was later changed).
  prefs: []
  type: TYPE_NORMAL
- en: Other countries may actually use organizational subdomains within their country
    code. For example, Great Britain has .CO.UK for companies in the country (like
    .COM but for the UK only; they left off the *M*), and .COM.AU is for corporations
    in Australia.
  prefs: []
  type: TYPE_NORMAL
- en: Other countries may not have any particular substructure at all, especially
    if they are small.
  prefs: []
  type: TYPE_NORMAL
- en: Leasing/Sale of Country Code Domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interestingly, some very small countries with recognizable country codes, especially
    to English speakers, have used their codes for very creative purposes, including
    selling or renting the name space to enterprising companies.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is the .TV domain, which technically belongs to the island nation
    of *Tuvalu*. Of course, to most people, "TV" means something quite different.
    Some folks thought that domain names ending in .TV might be popular in the English-speaking
    world, so they formed a company called The .TV Corporation and negotiated with
    the government of Tuvalu to use the .TV domain. Today, the authority for this
    TLD is this corporation, headquartered in California! Similar arrangements can
    be found with the .CC, .NU, .TO, and other TLDs.
  prefs: []
  type: TYPE_NORMAL
- en: This serves as a good reminder that the name space is logical and not physical.
    Obviously, the many computers with .TV names are not actually located on a remote
    island in the South Pacific. Similarly, if a website ends with .CA, for example,
    it probably represents a Canadian organization, but that doesn't necessarily mean
    the website itself is actually hosted in Canada.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of the Geopolitical TLDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The geopolitical domains have been very popular for certain uses. National governments
    and other official institutions like to use them, for obvious reasons. Typing
    www.gov.*xx* or www.government.*xx*, where *xx* is a country code is likely to
    bring you to the national government website of most countries. Some companies
    and organizations use the ccTLDs because they allow them to choose a name already
    taken in the generic hierarchies or simply to express national pride.
  prefs: []
  type: TYPE_NORMAL
- en: For many other companies and organizations, however, the generic TLDs have been
    much more popular than the country codes. I think the most important reason for
    this is that organizations are easier to locate using the generic domains.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a good example of what I mean. In the town near where I live, a new grocery
    store called Aldi recently opened. I like the store and wanted to learn more about
    it, so I fired up my web browser and sought out its website. Yes, I could have
    typed it into a search engine, but like most people, I'm lazy. It was much easier
    to just enter www.aldi.com into my browser, and lo and behold, up popped the website
    of Aldi International.
  prefs: []
  type: TYPE_NORMAL
- en: Now, Aldi is actually headquartered in Germany, and the company does have a
    website at www.aldi.de as well. But I didn't know that. I found them easily by
    going to www.aldi.com, because I didn't need to know their physical location,
    and because I know that most large companies have a .COM domain. Of course, being
    findable is very important, especially for commercial organizations trying to
    do business.
  prefs: []
  type: TYPE_NORMAL
- en: Another good example is the United States, which has its own country code, .US,
    in addition to dominating the generic TLDs. The authority in charge of this domain
    initially chose to make it follow a strict geographical hierarchy, so every domain
    had to be of the form *organization.city.state-code*.us. So, to use this part
    of the name space, a company in Boston must be within the .boston.ma.us domain.
    That's very neat and logical, but it makes names both longer and harder to guess
    than the generic equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you wanted to get information on metals giant Alcoa. If you''re in
    the industry, you might know Alcoa is located in Pittsburgh, but if not, which
    is easier to find: www.alcoa.pittsburgh.pa.us or www.alcoa.com? Anyone here know
    how to spell Albuquerque?'
  prefs: []
  type: TYPE_NORMAL
- en: It is for this reason that the .US domain achieved success in certain segments
    of society but not in others, especially commercial entities (corporations). The
    strict hierarchy does have some real advantages, such as avoiding name space conflicts,
    but its disadvantages were such that the rules were recently relaxed in the .US
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Public Registration for Second-Level and Lower Domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IANA is in charge of deciding which TLDs exist in the Internet name space,
    and as such, they are ultimately responsible for all names in the Internet. The
    entire point of the authority hierarchy, however, is that IANA should not be responsible
    for the whole name space. So, while IANA maintains control over certain TLDs,
    such as .INT and .ARPA, control for managing the others is delegated to secondary
    authorities for each TLD.
  prefs: []
  type: TYPE_NORMAL
- en: Just as IANA had the choice of how to delegate authority to the subdomains of
    the root domain, the organization in charge of each TLD gets to make the same
    decision about how second-level domains are to be created under the TLD.
  prefs: []
  type: TYPE_NORMAL
- en: In many TLDs, especially the generic ones, second-level domains are assigned
    directly to individuals or organizations. For example, a company named XYZ Industries
    might want to get the domain xyzindustries.com.
  prefs: []
  type: TYPE_NORMAL
- en: In other TLDs, second-level domains are set up in a particular structure, like
    the state codes used in the .US domain. There, you need to go down more levels,
    but eventually you get to the point where companies and people register their
    own domains. For example, in the .US domain, XYZ Industries might want to register
    xyz.phoenix.az.us if it were headquartered in Phoenix.
  prefs: []
  type: TYPE_NORMAL
- en: This transition point between the authorities granted responsibility for parts
    of the name space and the regular people and groups who want to get names is important.
    A process of *public registration* had to be established to allow such name assignment
    to occur in a consistent and manageable way. This was not that difficult to accomplish
    back when the original generic TLDs and country code TLDs were first created.
    The Internet was quite small, and it made sense to just have the authority in
    charge of each TLD perform registrations within that TLD. This ensured that there
    was no duplication of names within a TLD with a minimum of fuss.
  prefs: []
  type: TYPE_NORMAL
- en: Registration Authority
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For very important generic TLDs such as .COM, .NET, and .ORG, the authority
    in charge of registration was the Internet Network Information Center (the InterNIC).
    The InterNIC was set up as a service administered by the United States government,
    who later granted the contract to manage it to Network Solutions Inc. (NSI). NSI
    was eventually purchased by VeriSign, who later spun it off as a separate venture.
    (Things change quickly in the networking world!)
  prefs: []
  type: TYPE_NORMAL
- en: NSI single-handedly performed all registrations within the .COM, .NET, and .ORG
    TLDs for many years. The popularity of the original generic TLDs, however, led
    to an explosion in demand for name registration in these domains in the 1990s.
    Having a single company in charge of registration led to this becoming another
    bottleneck in the Internet's Domain Name System. There were also many folks who
    didn't like the lack of accountability and competition that came with having a
    single monopoly in charge of registration. The InterNIC could set its own price
    and originally charged $35 per year per domain name, then later $50 per year.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 1990s, responsibility for name registration was given to ICANN.
    The registration process was *deregulated*, to borrow a term referring to removal
    of monopolies from industries like power generation. As of December 1999, there
    was still a single authority with overall responsibility for each TLD, including
    .COM, .NET, and .ORG.
  prefs: []
  type: TYPE_NORMAL
- en: Today, NSI is still the authority running .COM and .NET. However, it isn't the
    only organization that registers names within these TLDs. It further delegates
    registration authority to a multitude of other companies, called *accredited registrars*.
    Any registrar can register names within the TLD(s) for which they are accredited.
  prefs: []
  type: TYPE_NORMAL
- en: Registration Coordination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naturally, coordination becomes much more of a concern when you have multiple
    companies registering names in a TLD. A special set of technical and administrative
    procedures is followed to ensure that there are no problems, such as two registrars
    trying to grab a name at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system has worked well, and those who wish to use TLDs where competition
    exists now can choose from a variety of registering companies. The most noticeable
    result of this was also the most predictable one: the cost of registering a domain
    name in the deregulated generic TLDs is usually much lower than the fees originally
    charged by the InterNIC.'
  prefs: []
  type: TYPE_NORMAL
- en: Once a company, individual, or organization has a registered lower-level domain,
    he/she/it becomes the authority for that domain. Use of the domain then becomes
    private, but depending on how the domain is used, further public name registration
    may be required. See the discussion of private registration, near the end of this
    chapter, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Public Registration Disputes and Dispute Resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Internet started off as a medium for research into networking, evolved into
    a system for interconnecting scientists, and ended up as a global communications
    tool used by just about everyone. As part of this evolution, the Internet also
    became a very important part of how business is done in the world. Money started
    to come into the Internet picture in the early 1990s, and just a few short years
    later, its impact on the Internet was so significant that the growth of the stock
    market to dizzying heights in the late 1990s is now often called "the Internet
    bubble."
  prefs: []
  type: TYPE_NORMAL
- en: Public Registration Disputes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, the increasing importance of the Internet to commercial interests
    crashed headlong into the noncommercial original design of Internet technology,
    and nowhere was this more evident than in DNS. Since there were only a few generic
    TLDs, each name within a TLD had to be unique, and humans are often confrontational
    creatures, it didn't take long before arguments broke out over who should be able
    to use what name and why. And, of course, from there, it didn't take long before
    lawsuits and other unpleasantries were common.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a surprising number of significant problems associated with public
    registration of domain names:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Corporate Name Conflicts** The .COM domain is for corporations, but many
    corporations have the same name. The ACME Furniture Company, the ACME Restaurant
    Supply Corporation, and ACME Footwear, Inc., probably all would like to have the
    acme.com domain. But there can be only one such domain within .COM. (These are
    fictional examples; acme.com is actually owned by an organization called *Acme
    Labs*.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Corporate/Individual/Small Business Name Conflicts** There are many corporations
    that have names similar to or even identical to the names of individuals, leading
    to potential conflicts. For example, suppose your first name is Wendy and you
    own a small fabric store called Wendy''s Fabrics. But you are Internet savvy and
    decide you want to register wendys.com as soon as you hear about the Internet
    in 1993\. Then this big hamburger chain comes along and has a problem with that.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*To my knowledge, no such issue arose with respect to Wendy''s, but there actually
    was a widely publicized case that shows just how recently most corporations were
    out of the loop with respect to domain naming. In 1994, a writer for Wired magazine
    was astonished to find that the mcdonalds.com domain name was unregistered! To
    show just how unregulated the registration process was, he registered it himself,
    and caused a bit of a stir as a result. The Golden Arches folks eventually acquired
    the domain from him in an amicable arrangement, where he relinquished the name
    and they made a donation to charity*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Corporate Warfare** A particularly ugly type of conflict is when companies
    intentionally try to take business from each other by registering names that have
    nothing to do with their own companies. An example would be if Burger King had
    tried to register mcdonalds.com and use it to advertise Burger King products.
    (Which they didn''t do, I might add, so please nobody sue me!) Another example
    is when companies try to use alternate TLDs, such as registering burgerking.org
    to confuse people trying to find burgerking.com. In fact, many companies have
    taken the step of registering their names in many different TLDs to prevent this
    sort of thing from happening.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cybersquatting** Some ambitious (to choose a nice term) individuals, recognizing
    early on the potential value of certain names, registered large volumes of names
    with the hopes of reselling them. Many people condemned this as exploitative,
    and the term *cybersquatting* was created to refer to this type of activity. Unfortunately,
    a lot of money was made this way, and there are many domain names that, to this
    day, cannot be used because they have been reserved indefinitely by people or
    individuals who will never use them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deceptive Naming Practices** Another type of somewhat diabolic creativity
    has been displayed by people who seek to take advantage of the inability of some
    of us to spell. For example, if you were a competitor of a large company called
    Superb Transceivers Inc., which registered superbtransceivers.com, you might register
    superbtranscievers.com and redirect traffic from there to your own domain. Another
    example takes advantage of the common mix-up between the letter *O* and 0 (zero).
    For example, a software company once registered micros0ft.com, much to the chagrin
    of the Redmond, Washington software giant.'
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, it was all this nonsense that led, in part, to the clamor for
    new generic TLDs. Even though the more complicated schemes used by TLDs like .US
    are not very popular, they have a huge advantage over the generic domains. Since
    all these registrations are geographic, there are far fewer conflicts. For example,
    the ACME Furniture Company might use acme.seattle.wa.us, the ACME Restaurant Supply
    Corporation might have acme.mendocino.ca.us, and ACME Footwear, Inc., could go
    with acme.anchorage.ak.us. A dispute would arise only when organizations have
    the same name and also are in the same state and town. You could still have three
    Joe's Pizza Parlors in Chicago duke it out, but it's not likely to be a problem
    for big companies.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of Registration Dispute Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, how do we resolve these situations? As the saying goes, it can be done
    either the easy way or the hard way. Here are some methods that have been used
    for dispute resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain Name Sharing** Sometimes, the antagonists agree on a productive solution.
    One particularly constructive idea is to agree to *share* the domain name. For
    example, the three different ACME companies could each create their own more specifically
    named domains, such as acmefurniture.com, acmerestaurantsupply.com, and acmefootwear.com.
    Then they might agree to have the www.acme.com registered to nobody, by having
    one company register it and not use it for anything. Even better, they could set
    it up with a simple web page that says the domain is shared, with a link to the
    three sites. Unfortunately, it seems grade school children understand the concept
    of sharing better than most corporate executives do, so this type of resolution
    is rare.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain Name Purchase** Another option is purchase. If a big company wants
    a domain name already registered by an individual or a small business, it will
    often just purchase the name, as this is the easiest thing to do. During the height
    of the Internet mania, there were domain names that sold for *millions* of dollars—just
    for the right to use the name! Many cybersquatters and other speculators got rich
    selling names.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Litigation** Often, the combatants don''t play nice, and the usual occurs:
    threats, intimidation, lawsuits, and so forth. Sometimes, a letter from a lawyer
    is enough to resolve the issue, especially when some poor individual owning a
    website gets threatened with legal action by a large company—this has happened
    many times. However, often the disagreeing parties stick to their guns, especially
    if two companies lock horns and their lawyers refused to back down. Usually, the
    matter then ends up in the courts, where it is eventually resolved one way or
    the other. Usually, claims of trademark infringement would be used by a company
    challenging a prior domain name registration.'
  prefs: []
  type: TYPE_NORMAL
- en: The Uniform Domain Name Dispute Resolution Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lawsuits are expensive and time-consuming, so there was a desire that some other
    mechanism exist for resolving these conflicts as well. Since the authority for
    each TLD controls what happens within it, it also has the right to create its
    own policies for how to deal with these sorts of issues. For the generic TLDs,
    the original registering authority, the InterNIC, had a dispute resolution policy
    that allowed people with a complaint to challenge a domain name registration if
    they had a trademark interest in that name. The policy was controversial for a
    number of reasons, not the least of which because it led to some domain names
    being successfully challenged, even if there was no proof of trademark infringement.
  prefs: []
  type: TYPE_NORMAL
- en: The current authority for the generic TLDs, IANA/ICANN, created a new Uniform
    Domain Name Dispute Resolution Policy (UDRP) in 1999, to better handle domain
    name conflicts. This policy specifies a procedure whereby a company that has a
    valid trademark can challenge a domain name if it infringes on the trademark,
    is confusingly similar to it, or was registered by someone else in bad faith.
    At the same time, it also lists ways that the original registrant can prove that
    the registration is valid and should be maintained. This new system eliminates
    many of the problems associated with public registration of domain names—such
    as deceptive naming, corporate warfare, and cybersquatting—while not automatically
    allowing a second-comer to shut down a legitimate domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS Name Space Administrative Hierarchy Partitioning: DNS Zones of Authority'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I explained earlier in this chapter that the DNS name space is arranged in a
    hierarchy and that there is also a hierarchy of authorities that is related to
    that hierarchical name structure. However, the two hierarchies are not exactly
    the same. If they were the same, we would need a separate authority for every
    domain at every level of the tree, and that's something we are very unlikely to
    want to have everywhere in the structure.
  prefs: []
  type: TYPE_NORMAL
- en: At the very top levels of the DNS tree, it seems reasonable that we might want
    to designate a separate authority at each level of the structure. Consider the
    geopolitical name hierarchy; IANA/ICANN manages the root domain, but each of the
    ccTLDs is managed by a distinct national authority.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when we get to the lower levels of the structure, it is often inconvenient
    or downright impossible to have each level correspond to a separate authority.
    As an example, let''s suppose you are in charge of the Googleplex University IT
    department, which runs its own DNS servers for the googleplex.edu domain. Suppose
    there were only two schools at this university, teaching fine arts and computer
    science. Suppose also that the name space for the computers were divided into
    three subdomains: finearts.googleplex.edu, compsci.googleplex.edu, and admin.googleplex.edu
    (for central administrative functions, including the IT department itself).'
  prefs: []
  type: TYPE_NORMAL
- en: Most likely, you don't want or need the Fine Arts department running its own
    DNS servers. The same is likely true of the administration machines. However,
    it's possible that the Computer Science department does want to run its own DNS
    servers, because this department probably has many more computers than the other
    departments, and the staff might use running a DNS server as part of the curriculum.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you might want yourself, the administrator for googleplex.edu,
    to maintain authority for the finearts.googleplex.edu and admin.googleplex.edu
    subdomains and everything within them, while delegating authority for compsci.
    googleplex.edu to whomever in the Computer Science department is designated for
    the task. DNS is specifically designed to allow these divisions between the name
    hierarchy and the authority structure to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of Dividing a Name Space into Zones of Authority
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete DNS name structure is divided by making *cuts* (as RFC 1034 calls
    them) between adjacent nodes to create groups of contiguous nodes in the structure.
    Each group is called a *zone of authority*, or more commonly, just a *zone*. Each
    zone is usually identified by the domain name of the highest-level node in the
    zone; that is, the one closest to the root. The zones in DNS are by definition
    *non-overlapping*—every domain or subdomain is in exactly one zone. The division
    of the name space into zones can be made in an arbitrary way. At one extreme,
    we could place a cut between every node, and thereby divide the entire name space
    so each domain (and subdomain, and so on) was a separate zone. If we did this,
    the name hierarchy and authority hierarchy would indeed be the same for the entire
    DNS tree. At the other end of the scale, we could use no cuts at all, defining
    a single zone encompassing the entire DNS structure. This would mean the root
    was the authority for the entire tree.
  prefs: []
  type: TYPE_NORMAL
- en: Of course in practice, neither of these methods is particularly useful, as neither
    reflects how the real-world administration of DNS works. Instead, we generally
    divide the name structure in a variety of places, depending on the needs of different
    parts of the name space. There are many cases where we might want to create a
    subdomain that is responsible for its own DNS server operation; there are others
    where we might not want to do that. The significance of a cut in the name hierarchy
    is that making such a cut represents, in essence, a *declaration of DNS independence*
    by the node below the cut from the one above the cut.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our example, if googleplex.edu is in charge of its own DNS servers,
    then there would be a cut in the name space between googleplex.edu and .EDU at
    the next-higher level. This means that the DNS server for .EDU is no longer in
    charge of DNS for the googleplex.edu domain; instead, either the unversity itself
    or someone hired as a third party must provide DNS for it. In this case, we are
    assuming the folks at Googleplex U. themselves run their own DNS. Without making
    any other cuts, the googleplex.edu domain would be a single zone containing everything
    below that name, including both finearts.googleplex.edu and compsci.googleplex.edu.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, however, we would make another cut, between googleplex.edu
    and compsci.googleplex.edu. This, in effect, *liberates* compsci.googleplex.edu,
    allowing its administrators to be in charge of their own DNS server. In doing
    this, we end up with two distinct zones: one encompassing googleplex.edu, finearts.googleplex.edu,
    and admin.googleplex.edu (and everything underneath them) and another for compsci.googleplex.edu
    (and everything below it). This is illustrated in [Figure 54-2](ch54s06.html#dns_zones_of_authority_cuts_can_be_made_
    "Figure 54-2. DNS zones of authority Cuts can be made between nodes in the DNS
    name tree to create an arbitrary hierarchy of name authorities. This example shows
    the DNS tree branch for googleplex.edu, with each zone indicated using a different
    shading. IANA/ICANN is responsible for the root domain, and a separate authority
    named Educause takes care of .EDU. The third zone covers much of googleplex.edu,
    except that a cut has been made between googleplex and compsci to create an independent
    zone of authority for compsci.googleplex.edu.").'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Impact of Zones on Name Resolution: Authoritative Servers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of zones is critical to understanding how DNS name servers work,
    and therefore, how name resolution is performed. All of the information about
    the subdomains and individual devices in the zone is represented using a set of
    resource records stored on a DNS name server. Usually, this name server is associated
    with the highest-level domain name in the zone. A name server that contains the
    definitive information for the zone is said to be *authoritative* for the zone.
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS zones of authority Cuts can be made between nodes in the DNS name tree
    to create an arbitrary hierarchy of name authorities. This example shows the DNS
    tree branch for googleplex.edu, with each zone indicated using a different shading.
    IANA/ICANN is responsible for the root domain, and a separate authority named
    Educause takes care of .EDU. The third zone covers much of googleplex.edu, except
    that a cut has been made between googleplex and compsci to create an independent
    zone of authority for compsci.googleplex.edu.](httpatomoreillycomsourcenostarchimages288165.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 54-2. DNS zones of authority Cuts can be made between nodes in the DNS
    name tree to create an arbitrary hierarchy of name authorities. This example shows
    the DNS tree branch for googleplex.edu, with each zone indicated using a different
    shading. IANA/ICANN is responsible for the root domain, and a separate authority
    named Educause takes care of .EDU. The third zone covers much of googleplex.edu,
    except that a cut has been made between googleplex and compsci to create an independent
    zone of authority for compsci.googleplex.edu.
  prefs: []
  type: TYPE_NORMAL
- en: An authoritative server for a zone is one that maintains the official information
    about the zone, and the one that is ultimately responsible for providing name
    resolution information about it. We'll discuss this in the section on DNS servers
    and name resolution in [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS
    AND RESOLVER OPERATIONS").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The DNS name registration hierarchy is divided into regions
    called *zones of authority*. Each zone represents an area that is administered
    independently and consists of a contiguous segment of the DNS name tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Every DNS zone has a set of authoritative servers, which are usually a pair
    called the *primary* (or *master*) and *secondary* (or *slave*) servers. However,
    it is also possible for a single DNS name server to be authoritative for more
    than one zone.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, it is not always necessary for the actual owner of a domain
    to provide DNS services for it. Very often, especially for the domains owned by
    small businesses or individuals, DNS services are provided by a third party, often
    an ISP. For example, I have had pcguide.com registered as a domain since 1997,
    but my long-time web-hosting provider, pair Networks, has provided DNS services
    for me since the beginning. This means that pair's DNS servers in the pair.com
    hierarchy are responsible for pcguide.com. They are also responsible for many
    other domains for the company's customers.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Private Name Registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now reviewed the hierarchical nature of the DNS name space and the authority
    structure that administers it. Name registration begins with the generic and country
    code TLDs within the root of the name hierarchy, then proceeds to second-level
    domains within the TLDs and then lower-level subdomains below those. As we progress
    down the name tree, we move from the most general, public authority (IANA/ICANN,
    which runs all of DNS), through the high-level TLD authorities, and eventually
    down to the level of individual organizations, corporations, and individuals.
  prefs: []
  type: TYPE_NORMAL
- en: This dividing line between public authorities and private authorities occurs
    in many different places in the name structure. Wherever it does occur, below
    that line, responsibility for the domain becomes that of the organization that
    registered it. The organization can further subdivide the name space, granting
    parts of it to other organizations, or even reselling it. Alternatively, an organization
    may decide to use the name space to create a purely internal structure. I call
    this *private name registration*, in contrast to the *public name registration*
    described earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a company called XYZ Industries registers xyzindustries.com,
    that company becomes the owner of not just that domain name, but any subdomain
    structure or named items within it that the company may choose to create. This
    is the beauty and power of authority delegation and the hierarchical structure.
    The company has an important decision to make, however: whether they want to create
    names that are part of the global DNS name structure or use names within the structure
    purely privately.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Publicly Accessible Private Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an organization's administrators want names within their domain to be part
    of the global DNS name structure, they must perform the work required to properly
    set up and manage these names so they fit into DNS. The most common example is
    creating a public World Wide Web server. Most companies name such servers beginning
    with www, so XYZ Industries would probably wish to have the name www.xyzindustries.com
    for its web server address.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the XYZ Industries owners want and need anyone on the Internet to
    be able to locate this server. Thus, even though they have private control of
    the xyzindustries.com domain, and own the name www.xyzindustries.com, they must
    follow proper procedures for ensuring that DNS resource records are set up for
    their www subdomain so everyone on the Internet can find it. They may do this
    themselves, if they run their own DNS servers, or may have an ISP or other third
    party do it for them, as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Using Private Names for Internal Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The alternative is to create purely private names for use only within the organization.
    For example, it is likely that even if XYZ wants a public web server, the administrators
    may wish to name many other machines that are to be accessed only within the company
    itself. In this case, they don't need to set up these machines so they are publicly
    recognizable. They can create private machine names and manage them internally
    within their own network.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Once an organization registers a particular domain name, it
    becomes the owner of that name and can decide whether and how to create a substructure
    within that domain. If an organization wants objects in the domain to be accessible
    on the public Internet, it must structure its domain to be consistent with Internet
    DNS standards. Alternately, it can create a purely private domain using any structure
    and rules it prefers.'
  prefs: []
  type: TYPE_NORMAL
- en: One common way to do this is to make use of the older host table name system.
    This system is now archaic for large internetworks, but is often still used in
    smaller companies due to its simplicity. A name is *registered* by being added
    to the host tables on each of the computers within the organization, and *resolved*
    when the operating system on a host checks this file prior to using standard DNS
    resolution methods. The host table supplements DNS in this case (it is not really
    a part of DNS). The two systems are complementary and can work together, as explained
    in [Chapter 51](ch51.html "Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST
    TABLE NAME SYSTEM").
  prefs: []
  type: TYPE_NORMAL
- en: Using Private Names on Networks Not Connected to the Internet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that if you are running a purely private network not connected to the Internet
    at all, you can actually set up your own entirely private name hierarchy and run
    DNS yourself. In this case, you are in charge of the DNS root and can use any
    naming system you like.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is sometimes considered attractive, because you can then use very
    simple machine names on small networks, without needing to perform any public
    registration or use names that correspond to the global hierarchy. Instead of
    the accounting computer in XYZ Industries being named accounting.xyzindustries.com,
    internally it could be named accounting. You can mix these with real DNS names,
    too, when accessing resources. For example, Joe's machine could be called just
    joe, while the website of UPS would, of course, still be www.ups.com.
  prefs: []
  type: TYPE_NORMAL
- en: The most common example of this mixing of private and public names is the definition
    of the private local name for the loopback address of a computer. Most Windows
    and UNIX machines define the name *localhost* to be the address 127.0.0.1, which
    means "this computer" on any TCP/IP machine.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of all the components and functional elements that combine to form the Domain
    Name System (DNS), name servers are arguably the most important. These servers,
    which may be either dedicated devices or software processes running on machines
    that also perform other tasks, are the workhorses of DNS. They store and manage
    information about domains, and respond to resolution requests for clients—in some
    cases, millions of times each day. Understanding how they perform this most basic
    task and the many support jobs for which they are also responsible is crucial
    to understanding DNS as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe the concepts related to DNS name servers and explain
    how they operate. I begin with an overview of DNS name server functions and general
    operation. I describe the way that DNS name server data is stored in resource
    records and the role of classes. I discuss the different roles of name servers
    in DNS and explain the all-important root name servers. I discuss how DNS zones
    are managed, the notions of domain contacts and zone transfers, and how caching
    and load balancing are used to improve efficiency in DNS. I conclude with a brief
    outline of several enhancements to basic DNS server operation, including the new
    Notify and Update message types and incremental zone transfers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *The information in this section should be considered
    complementary to that in the following chapter on DNS resolvers*.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS General Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three major functions of a name system are creating a name space, performing
    name registration, and providing name resolution services. The previous chapters
    describe how DNS uses a hierarchical tree structure for its name space ([Chapter 53](ch53.html
    "Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY")), and a hierarchical
    tree for name authorities and registration ([Chapter 54](ch54.html "Chapter 54. DNS
    NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES")). I'm sure
    that, given this, you will have to struggle to contain your surprise when I tell
    you that name resolution is also oriented around the notion of a hierarchical
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: The devices that are primarily charged with performing the functions required
    to enable name resolution are *name servers*. They are arranged in a hierarchy
    that is closely related to the authority structure of the name system. Just as
    the authority structure complements the name structure but is not exactly the
    same as it, the name server architecture complements both the authority structure
    and the name structure, but may be different from them in its actual composition.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Server Architecture and the Distributed Name Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a large DNS implementation, information about domains is not centralized
    in a single database run by one authority. Instead, it is *distributed* across
    many different authorities that manage particular top-level domains (TLDs), second-level
    domains, or lower-level subdomains. In the case of the global Internet, literally
    millions of different authorities, many of them responsible only for their own
    local domain space, participate cooperatively in running the DNS system.
  prefs: []
  type: TYPE_NORMAL
- en: With authority for registration distributed in this manner, the information
    about domains is similarly spread among many entities, resulting in a *distributed
    database*. A key concept in DNS name resolution is that each entity that maintains
    responsibility for a part of the name space must also arrange to have that information
    stored on a DNS server. This is required so that the server can provide the information
    about that part of the name space when resolution is performed. As you can see,
    the existence of a structured hierarchy of authorities directly implies the need
    for a hierarchy of servers that store that hierarchical name information.
  prefs: []
  type: TYPE_NORMAL
- en: Each DNS zone of authority is required to have one or more DNS servers that
    are in charge of managing information about that zone. These servers are said
    to be *authoritative* for the zone. Storing information about the domains, subdomains,
    and objects in the zone is done by recording the data in special resource records
    that are read from DNS master lists maintained by administrators. Servers then
    respond to requests for this information.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** DNS public name information is stored in a *distributed database*
    of DNS name servers that are structured in a hierarchy comparable to the hierarchy
    of authorities. Each zone has one or more DNS name servers in charge of the zone''s
    information, called *authoritative name servers*.'
  prefs: []
  type: TYPE_NORMAL
- en: Since information in DNS is stored in a distributed form, there is no single
    server that has information about every domain in the system. As you'll see in
    the next chapter, the process of resolution instead relies on the hierarchy of
    name servers. At the top of the DNS hierarchy is the *root* domain, and in that
    domain are root name servers. These are the most important servers, because they
    maintain information about the TLDs within the root. They also have knowledge
    of the servers that can be used to resolve domains one level below them. Those
    servers, in turn, are responsible for the TLDs and can reference servers that
    are responsible for second-level domains. Thus, a DNS resolution may require that
    requests be sent to more than one server.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Server Support Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The storing and serving of name data (through responses to requests from DNS
    resolvers) is the main function of a DNS server. However, other support jobs are
    also typically required of a DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interacting with Other Servers** Because the DNS resolution process often
    requires that multiple servers be involved, servers must maintain not just name
    information, but information about the existence of other servers. Depending on
    the type of DNS request, servers may themselves become clients and generate requests
    to other servers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone Management and Transfers** The server must provide a way for DNS information
    within the zone to be managed. A facility also exists to allow a *zone transfer*
    to be performed between the master (primary) server for a zone and slave (secondary)
    servers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance Enhancement Functions** Due to the large number of requests servers
    handle, they employ numerous techniques to reduce the time required to respond
    to queries. The most important of these is caching of name information. A variation
    of regular caching called *negative caching* may also be used to improve performance,
    and load balancing is a feature that can be used to improve efficiency of busy
    devices registered within the DNS system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Administration** Various other administrative details are required of name
    servers, such as storing information about the different types of contacts (humans)
    who are responsible for certain tasks related to management of a domain or zone.'
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see later in this chapter, not all name servers perform all of these
    tasks described; some perform only a subset.
  prefs: []
  type: TYPE_NORMAL
- en: The Logical Nature of the DNS Name Server Hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the other hierarchies, the name server hierarchy is logical in nature.
    I already mentioned that it often is not exactly the same as the authority hierarchy.
    For one thing, it is common for a single DNS name server to be the authoritative
    server for a number of domains. Even if a particular group has authority for a
    subdomain of a particular domain, it's possible they will share the DNS servers
    with the authority of their parent domain for efficiency reasons. For example,
    a university might delegate control over parts of its domain space to different
    groups (as in the example of DNS zones in [Chapter 54](ch54.html "Chapter 54. DNS
    NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES")) but still
    manage all subdomains on the same server. In practice, the lower the level of
    the subdomain in the DNS name hierarchy, the less likely that subdomain has its
    own DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of the logical nature of the name server hierarchy
    is that there is no necessary relationship between the structure of the name servers
    and their location. In fact, in many cases, name servers are specifically put
    in different places for reliability reasons. The best example of this is the set
    of root name servers. These are all at the top of the DNS server architecture,
    but they are spread around the globe to prevent a single problem from taking all
    of them out. Also remember not to be fooled by the structure of a name in the
    geopolitical DNS name hierarchy (as discussed in [Chapter 53](ch53.html "Chapter 53. DNS
    NAME SPACE, ARCHITECTURE, AND TERMINOLOGY")). A name server called ns1.blahblah.ca
    might be in Canada, but it very well might not be located there.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The DNS name server hierarchy is logical in nature and not
    exactly the same as the DNS name server tree. One server may be responsible for
    many domains and subdomains. Also, the structure of the DNS name server hierarchy
    doesn''t necessarily indicate the physical locations of name servers.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Server Data Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important jobs performed by name servers is the storage of name
    data. Since the authority for registering names is distributed across the internetwork
    using DNS, the database of name information is likewise distributed. An *authoritative*
    server is responsible for storing and managing all the information for the zones
    of authority it is assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Each DNS server is, in essence, a type of database server. The database contains
    many kinds of information about the subdomains and individual devices within the
    domain or zone for which the server is responsible. In DNS, the database entries
    that contain this name information are called *resource records (RRs)*. A specific
    set of RRs is associated with each node within the zone.
  prefs: []
  type: TYPE_NORMAL
- en: Binary and Text Representations of Resource Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entire point of DNS is to allow humans to work with names and computers
    to work with numbers. This principle is further reflected in the two very different
    representations that exist for the DNS RRs themselves (see [Figure 55-1](ch55s02.html#dns_rr_master_file_and_binary_field_form
    "Figure 55-1. DNS RR master file and binary field formats")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**RR Field Format (Binary) Representation** Name servers are required to respond
    to queries for name information by sending RRs within DNS messages. Obviously,
    we want to do this in as efficient a way as possible, so each RR is internally
    stored using a special field format that is similar to the many field formats
    used for messages in other protocols. All RRs use a general field format for some
    of their fields and then have a unique portion that is specific to the RR type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Master File (Text) Representation** Computers are happy to exchange binary-encoded
    field formats and have no problem remembering that, for example, RR type 15 corresponds
    to a mail exchange (MX) record. However, human administrators want to be able
    to quickly and easily maintain DNS information without needing to remember cryptic
    codes or work with binary values. For this reason, DNS uses a *master file* format
    for its user-machine interface, which allows RRs to be specified in text form
    for easier maintenance.'
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS RR master file and binary field formats](httpatomoreillycomsourcenostarchimages288167.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 55-1. DNS RR master file and binary field formats
  prefs: []
  type: TYPE_NORMAL
- en: To meet the needs of humans and computers, DNS uses two representations for
    the data stored in RRs. Administrators enter and maintain information in textual
    DNS master files. These are read by DNS server software and internally stored
    in binary format for answering DNS requests.
  prefs: []
  type: TYPE_NORMAL
- en: Use of RRs and Master Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each node may have a variable number of records, depending on the node type
    and what information is being kept for it. The RRs are added, changed, or deleted
    when DNS information changes, by administrators who make modifications to the
    text master files on the server computer. These files are then read into memory
    by the DNS server software, parsed (interpreted), and converted into binary form.
    Then they are ready for use in resolving DNS name requests and other queries.
    I describe both the binary RR field formats and master file format in [Chapter 57](ch57.html
    "Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** DNS name servers store DNS information in the form of *resource
    records (RRs)*. Each RR contains a particular type of information about a node
    in the DNS tree. There are two representations for RRs: Conventional binary field
    formats are used for communication between DNS name servers and resolvers, and
    text *master files* are edited by administrators to manage DNS zones.'
  prefs: []
  type: TYPE_NORMAL
- en: Common RR Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main DNS standards, RFC 1034 and 1035, defined a number of RR types. Over
    time, the list has changed, with new RR types being created in subsequent standards
    and the use of others changed. Like other Internet parameters, the list of DNS
    RR types is maintained in a file by the Internet Assigned Numbers Authority (IANA).
    Also like other Internet parameters, there are actually several dozen defined
    RRs in DNS, but only a few are commonly used; others are now obsolete, used for
    special purposes, or experimental in nature. The current list of DNS resource
    records is maintained in a file that can be found at [http://www.iana.org/assignments/dns-parameters](http://www.iana.org/assignments/dns-parameters).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 55-1](ch55s02.html#summary_of_common_dns_resource_records "Table 55-1. Summary
    of Common DNS Resource Records") summarizes the most important RR types. For each,
    I have shown the numeric Type value for the record, which is used to identify
    the RR type in message exchanges, and the text code used for the RR in master
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 55-1. Summary of Common DNS Resource Records
  prefs: []
  type: TYPE_NORMAL
- en: '| RR Type Value | RR Text Code | RR Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | A | Address | Contains a 32-bit IP address. This is the "meat and potatoes"
    of DNS, since it is where the address of a node is stored for name resolution
    purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | NS | Name Server | Specifies the name of a DNS name server that is authoritative
    for the zone. Each zone must have at least one NS record that points to its primary
    name server, and that name must also have a valid Address (A) record. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | CNAME | Canonical Name | Used to allow aliases to be defined that point
    to the real name of a node. The CNAME record provides a mapping between this alias
    and the canonical (real) name of the node. It is commonly used to hide changes
    in the internal DNS structure from outside users, by letting them use an unchanging
    alias, while the internal names are modified based on the needs of the organization.
    See the discussion of name resolution in [Chapter 56](ch56.html "Chapter 56. DNS
    RESOLUTION CONCEPTS AND RESOLVER OPERATIONS") for an example. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | SOA | Start Of Authority | Used to mark the start of a DNS zone and provide
    important information about it. Every zone must have exactly one SOA record, which
    contains the name of the zone, its primary (master) authoritative server name,
    and technical details such as the email address of its administrator and parameters
    for how often slave (secondary) name servers are updated. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | PTR | Pointer | Provides a pointer to another location in the name space.
    These records are best known for their use in reverse resolution through the IN-ADDR.ARPA
    domain (described in [Chapter 54](ch54.html "Chapter 54. DNS NAME REGISTRATION,
    PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES")). |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | MX | Mail Exchange | Specifies the location (device name) that is responsible
    for handling email sent to the domain. |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | TXT | Text String | Allows arbitrary additional text associated with
    the domain to be stored. |'
  prefs: []
  type: TYPE_TB
- en: All of these RRs are used in different ways to define zones and devices within
    them and then permit name resolution and other functions to take place. You'll
    see how they are used in more detail in [Chapter 56](ch56.html "Chapter 56. DNS
    RESOLUTION CONCEPTS AND RESOLVER OPERATIONS"), which covers name resolution. You
    can also find a more lengthy description of some of them in the section in [Chapter 57](ch57.html
    "Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS")
    devoted to RR field formats.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *See the topic on IPv6 DNS support near the end of
    [Chapter 57](ch57.html "Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD,
    AND MASTER FILE FORMATS") for IPv6-specific RR types*.'
  prefs: []
  type: TYPE_NORMAL
- en: RR Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, I would like to mention a historical note about RRs. When DNS was first
    created, its inventors wanted it to be as generic as possible. To that end, they
    designed it so that a DNS server could, theoretically, provide name service for
    more than one type of underlying protocol; that is, DNS could support TCP/IP as
    well as other protocols simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, protocols have different addressing schemes and also varying needs
    for name resolution. Therefore, DNS was defined so that each protocol could have
    a distinct set of RR types. Each set of RR types was called a *class*. Technically,
    an RR must be identified using both a class identifier and an RR type. Like the
    RR types, classes have a numeric code number and a text abbreviation. The class
    for TCP/IP uses the number 1, with the text code IN (for Internet).
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, this notion of multiple classes of RRs never took off. Today,
    DNS is, to my knowledge, used only for TCP/IP. (There may be some obscure exceptions.)
    Several other classes have been defined by RFC 1035 and are in the IANA DNS parameters
    list, but they are for relatively obscure, experimental, or obsolete network types,
    with names such as CSNET, CHAOS, and Hesiod. You''ll still see this concept of
    class in the specification of DNS message and RR formats, but there really is
    only class today: IN for TCP/IP. For this reason, in most cases, the class name
    can be omitted in DNS-related commands and data entries, and IN will be assumed
    by default.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The DNS standards were originally created to allow them to
    work with multiple protocols, by specifying the class of each RR. Today, the only
    class commonly used is that for TCP/IP, which is called IN (for Internet).'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Server Types and Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at the functions of DNS servers, focusing on the important
    job of storing name server information. There are many thousands of DNS servers
    on the Internet, and not all are used in the same way. Each DNS server has a particular
    role in the overall operation of the name system. The different kinds of servers
    also interact with each other in a variety of ways.
  prefs: []
  type: TYPE_NORMAL
- en: Master (Primary)/Slave (Secondary) Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every zone needs to have at least one DNS name server that is responsible for
    it. These DNS name servers are called *authoritative* servers for the zone, because
    they contain the full set of RRs that describe the zone. When any device on the
    Internet wants to know something about a zone, it consults one of its authoritative
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a strictly theoretical perspective, having one name server for each zone
    or domain is sufficient to provide name resolution services for the entire DNS
    name structure. From an implementation standpoint, however, having only one name
    server for each part of the name space is not a wise idea. Instead, each zone
    usually has associated with it at least two name servers: one *primary* or *master*
    name server, and one *secondary* or *slave* name server. Some zones may have more
    than one secondary name server.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The terms primary and secondary are used often in the DNS standards to refer
    to the roles of the two authoritative servers for a zone. However, master and
    slave are now the preferred terms, because primary and secondary are somewhat
    ambiguous and used in other contexts. You should be prepared to see both terms
    used*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The master name server is obviously the most essential server. It is on this
    name server that the master files for the zone''s RRs are maintained, so the master
    name server is the final word on information on the zone. However, there are several
    reasons why slave servers are also important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redundancy** If there were only one name server and it failed, no one would
    be able to resolve names such as [www.xyzindustries.com](http://www.xyzindustries.com)
    into IP addresses, and that would be a Bad Thing. Slave name servers act as a
    backup for the masters they support. Redundancy is the most important consideration
    in setting up master and slave name servers. Sticking two machines side by side
    in a server room, plugged into the same electrical service, both connected to
    the Internet with the same Internet service provider (ISP), and making one your
    master DNS server and the other your slave is not a smart move. Ideally, the primary
    and secondary servers should be as independent as possible; they should be physically
    distant and have separate connections to the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance** With more than one server, we can easily take the primary server
    down for maintenance when needed without name resolution service being disrupted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load Handling** Busy zones can use multiple servers to spread the load of
    name resolution requests to improve performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiency** There are many cases where there is an advantage to positioning
    a name server in a particular geographical location for the sake of efficiency.
    For example, a company may have an office in a distant location connected using
    a low-speed wide area network link. To reduce name resolution traffic across that
    link, it makes sense to have that zone''s information available in a name server
    on both sides of the connection, which would require two physical servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as the names *master* and *slave* suggest, the secondary name servers are
    not the original source of information about a zone. They normally obtain their
    RRs not from human-edited master files, but from updates from the master server.
    This is accomplished using a process called a *zone transfer*. These transfers
    are performed on a regular basis to ensure that the slave servers are kept up-to-date.
    The slaves can then respond to name resolution requests with current information.
    Both the master and the slave are considered authoritative for the zone.
  prefs: []
  type: TYPE_NORMAL
- en: Name Server Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The master and slave roles for a zone are logical and do not always correspond
    to individual physical hardware devices. A single physical name server can play
    multiple roles in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be the master name server for more than one zone. Each zone in this case
    has a distinct set of RRs maintained in separate master files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be a slave name server for more than one zone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be a slave name server for certain zones as well as a primary for others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, however, that a single physical name server cannot be a master and a slave
    server for the same zone.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The master DNS server for a zone is its primary server, which
    maintains the master copy of DNS information. Most DNS zones also have at least
    one slave or secondary DNS server. These are important because they serve as backups
    for the primary server, and they can also help share the load of responding to
    requests in busy zones. Secondary name servers get their information from primary
    servers on a routine basis. Both master and slave servers are considered authoritative
    for the zones whose data they maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching-Only Name Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For efficiency, all DNS servers—both masters and slaves—perform caching of DNS
    information so it can be used again if requested in the near future. (Caching
    is described in the "Name Server Caching" section later in this chapter.) The
    importance of caching is so significant that some servers are set up only to cache
    information from other DNS servers. Unsurprisingly, these are called *caching-only*
    name servers.
  prefs: []
  type: TYPE_NORMAL
- en: These name servers are not authoritative for any zone or domain, and they don't
    maintain any RRs of their own. They can answer name resolution requests only by
    contacting other name servers that *are* authoritative and then relaying the information.
    They then store the information for future requests. Why bother? The reason is
    performance. Through strategic placement, a caching-only server can increase DNS
    resolution performance substantially in some networks by cutting down on requests
    to authoritative servers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** There are DNS servers that do not maintain DNS RRs of their
    own but solely hold recently used information from other zones. These are called
    *caching-only* name servers and are not authoritative for any zone.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Zone Management, Contacts, and Zone Transfers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The authority for a particular DNS zone is responsible for performing a variety
    of tasks to manage it. *Zone management* encompasses the entire gamut of jobs
    related to a zone: deciding on the name hierarchy within the zone, specifying
    procedures for name registration, technical work related to keeping DNS servers
    running, and other administrative overhead of all sorts. This job can be either
    very small or incredibly large, depending on the type of organization. A small
    domain owned by an individual doesn''t require much work to manage, while one
    for a huge company might require a dedicated staff to maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: Domain Contacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important that it be possible for anyone on an internetwork to be able
    to determine who the owner of a domain is, so that person can be reached for whatever
    reason. On the Internet, each DNS domain has associated with it a set of three
    *contacts* that are responsible for different facets of managing a domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Administrative Contact** The main contact, responsible for the domain as
    a whole. This individual or organization is considered the overall owner of the
    domain.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Billing Contact** A contact responsible for handling payment for domain services
    and other accounting matters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Technical Contact** A contact who handles the technical details of setting
    up DNS for the domain and making sure it works.'
  prefs: []
  type: TYPE_NORMAL
- en: For smaller domains, there usually is no separate billing contact; it is the
    same as the administrative contact. In contrast, the technical contact is often
    different from the administrative contact in both large and small domains. Large
    organizations will make the technical contact someone in their information technology
    department. Small organizations often let their ISP provide DNS services, and
    in that case, the technical contact will be someone at that ISP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each DNS domain has associated with it a set of three contact
    names that indicate who is responsible for managing it. The *administrative* contact
    is the person with overall responsibility for the domain. The *billing contact*
    is responsible for payment issues; this may be the same as the administrative
    contact. The *technical contact* is in charge of technical matters for the domain
    and is often a different person than the administrative contact, especially when
    DNS services are outsourced.'
  prefs: []
  type: TYPE_NORMAL
- en: Zone Transfers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ultimate purpose of zone management is to ensure that information about
    the zone is kept current on the zone's master and slave name servers, so it can
    be efficiently provided to name resolvers. Thus, the management of a zone begins
    with decision-making and administrative actions that result in changes to the
    RRs for the zone. These are reflected in changes made to the DNS master files
    on the master (primary) DNS server for the zone.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, each zone's secondary DNS server(s) act as slaves to the master
    primary server. They carry information about the zone, but do not load it from
    local master files that are locally edited. Instead, they obtain their information
    from the master name server on a regular basis. The procedure responsible for
    this is called a *zone transfer*.
  prefs: []
  type: TYPE_NORMAL
- en: The records on the master name server can be updated at any time. As soon as
    the master name server's records have been changed, the information at the slave
    name servers becomes partially out-of-date. This is not generally a big deal,
    because most of the data will still be accurate, and the secondary server will
    continue to respond to resolution requests using the most current information
    it has. However, it is obviously important that we update the slave servers on
    a regular basis; if this is not done, eventually their data will become stale
    and unreliable. To this end, it is necessary that zone transfers be performed
    on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: Control of When Zone Transfers Occur
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Controlling when zone transfers happen requires implementation of a communication
    process between the servers that consists of two basic parts. First, we need a
    mechanism to allow slave servers to regularly check for changes to the data on
    the master. Second, we must have a mechanism for copying the RRs for the zone
    from the primary name server to the secondary server when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Both mechanisms make use of standard DNS query/response facilities and special
    fields in the RRs for the zone. Of particular importance is the Start Of Authority
    (SOA) record for the zone, which contains several parameters that control zone
    status checking and zone transfers. While the formal description of these parameters
    can be found in the description of RR formats in [Chapter 57](ch57.html "Chapter 57. DNS
    MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS"), I'll discuss
    how they are used here.
  prefs: []
  type: TYPE_NORMAL
- en: When a slave name server starts up, it may have no information about the zone
    at all, or it may have a copy of the zone's RRs stored on its local storage, from
    the last time it was running. In the former case, it must immediately perform
    a full zone transfer, since it has no information. In the latter case, it will
    read its last-known copy of the zone from local storage; it may immediately perform
    a *poll* on the master server to see if the data has changed, depending on configuration.
    A poll is done by requesting the SOA RR for the zone.
  prefs: []
  type: TYPE_NORMAL
- en: The Serial field in the SOA record contains a serial number (which may be arbitrary
    or may be encoded so it has a particular meaning) that acts as the version number
    of the master server's zone database. Each time the master file for the zone is
    modified (either manually by editing or automatically through another means),
    this serial number is increased. Therefore, a slave server can detect when changes
    have been made on the master by seeing if the Serial field in the most recent
    SOA record is greater than the one the slave stored the last time it polled the
    master. If the serial number has changed, the slave begins a zone transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three other fields in the SOA record control the timing that slave name servers
    use for polling and updating their information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Refresh** This field specifies how many seconds a slave server waits between
    attempts to check for an update on the master. Assuming the slave can make contact,
    this is the longest period of time that data on a slave will become stale when
    the master changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retry** This field controls how long the slave must wait before trying again
    to check in with the master if its last attempt failed. This is used to prevent
    rapid-fire attempts to contact a master that may clog the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expire** If, for whatever reason, the slave name server is not able to make
    contact with the master for a number of seconds given by this field''s value,
    it must assume that the information it has is stale and stop using it. This means
    that it will stop acting as an authoritative name server for the zone until it
    receives an update.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that these parameters are part of the SOA record for the zone gives
    the administrator of the zone complete control over how often master name servers
    are updated. In a small zone where changes are rare, the interval between checks
    made by the slave servers can be increased; for larger zones or ones that are
    changed often, the Refresh interval can be decreased.
  prefs: []
  type: TYPE_NORMAL
- en: Zone Transfer Mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a zone transfer is required, it is accomplished using a DNS query sent
    to the master server using the regular DNS query/response messaging method used
    for name resolution (discussed in the next section). A special DNS question type,
    called AXFR (address transfer) is used to initiate the zone transfer. The server
    will then transfer the RRs for the zone using a series of DNS response messages
    (assuming that the server that requested the transfer is authorized to do so).
    Since it's important that zone transfers be received reliably, and since the amount
    of data to be sent is large and needs to be managed, a Transmission Control Protocol
    (TCP) session must first be established and used for zone transfers. This is in
    contrast to the simpler User Datagram Protocol (UDP) transport used for regular
    DNS messages (as described in the section discussing the use of UDP and TCP for
    DNS at the start of [Chapter 57](ch57.html "Chapter 57. DNS MESSAGING AND MESSAGE,
    RESOURCE RECORD, AND MASTER FILE FORMATS")).
  prefs: []
  type: TYPE_NORMAL
- en: Once the zone transfer is complete, the slave name server will update its database
    and return to regular operation. It will continue to perform regular polls of
    the master server every Refresh seconds. If it has a problem with a regular poll,
    it will try again after Retry seconds. Finally, if an amount of time equal to
    Expires seconds elapses, the master name server will stop serving data from the
    zone until it reestablishes contact with the primary name server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Slave name servers do not have their DNS information managed
    directly by an administrator. Instead, they obtain information from their master
    name server on a periodic basis through a process called a *zone transfer*. Several
    fields in the Start Of Authority (SOA) DNS RR control the zone transfer process,
    including specifying how often transfers are done and how slave name servers handle
    problem conditions such as an inability to contact the master server.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the DNS *Notify* feature is an enhancement to the basic zone status
    check/zone transfer model. It allows the master server to notify a slave server
    when the master's database has changed. Another new feature allows only part of
    a zone to be transferred instead of the entire zone. See the discussion of DNS
    name server enhancements later in this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Root Name Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS is strongly oriented around the notion of hierarchical structure. The name
    space, registration authorities, and name servers are all arranged in a tree structure.
    Like these structures, the name resolution process is also hierarchical. As explained
    in [Chapter 53](ch53.html "Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY"),
    a fully qualified domain name (FQDN) is resolved by starting with the least specific
    domain name element (label) and working toward the most specific one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, the least specific portion of every name is the root node under
    which the entire DNS structure exists. This means that, absent caching and other
    performance enhancements, all name resolution begins with the root of the name
    tree. We find here a set of name servers that are responsible for name server
    functions for the DNS root: the DNS *root name servers*.'
  prefs: []
  type: TYPE_NORMAL
- en: Like all name servers, DNS root name servers store information about and provide
    name resolution services for all the nodes within the root zone. This includes
    certain specific TLDs and subdomains. Most TLDs, however, are in their own zones.
    The root name servers are used as the "go-to" spot to obtain the names and addresses
    of the authoritative servers for each of these TLDs. For example, if we want to
    resolve the name [www.xyzindustries.co.uk](http://www.xyzindustries.co.uk), the
    root name servers are where a resolver would find the identity of the name server
    that is responsible for .UK.
  prefs: []
  type: TYPE_NORMAL
- en: Root Name Server Redundancy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clearly, these root name servers are extremely important to the functioning
    of the DNS system as a whole. If anything were to ever happen to cause the root
    name servers to stop operating, the entire DNS system would essentially shut down.
    For this reason, there obviously isn't just one root server, nor are there two
    or three; there are (at present) thirteen different root name servers.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there are actually far more than 13 physical servers. Most of the 13
    name servers are implemented as clusters of several independent physical hardware
    servers. Some are distributed collections of servers that are in different physical
    locations. The best example is the F root server, which has been implemented as
    a set of more than a dozen *mirrors* in various places around the world, to provide
    better service.
  prefs: []
  type: TYPE_NORMAL
- en: The principles of redundancy that are a good idea for choosing a secondary name
    server for a regular domain obviously apply that much more to the root. This is
    why the various physical devices that compose the 13 root servers are all located
    in different places all around the globe. Many of them are in the United States,
    but even these are in many locations throughout the country (albeit concentrated
    in a couple of hot spots in California and near Washington, DC) and are set up
    to use different networks to connect to the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The root name servers are, of course, rather powerful. Despite there being several
    dozen pieces of hardware to spread the load, they must each handle large amounts
    of data, 24 hours a day. They are run by networking professionals who ensure that
    they function efficiently. An Internet standard, RFC 2870, "Root Name Server Operational
    Requirements," spells out the basic rules and practices for the operation of these
    name servers. It specifies extensive procedures for ensuring the security of the
    servers and for avoiding performance problems due to their pivotal role.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Information about the DNS root and its TLDs is managed by a
    set of *root name servers*. These servers are essential to the operation of DNS.
    They are arranged into 13 groups and physically distributed around the world.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite all the efforts taken to ensure that the root servers are widely distributed
    and secure, they still collectively represent a point of weakness in the global
    Internet. Millions and millions of people depend on these servers. There have
    been incidents in the past where rogue elements on the Internet have attempted
    to disrupt DNS by attacking the root name servers. One widely publicized incident
    was a denial-of-service (DoS) attack against the root servers on October 21, 2002\.
    The attack failed, but it significantly raised awareness of the importance of
    these servers and how essential DNS security is.
  prefs: []
  type: TYPE_NORMAL
- en: Current Root Name Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Originally, the root name servers were given domain names reflecting the organizations
    that ran them. In these historical names, we can see a veritable who''s who of
    the big players in the development of the Internet: the Information Sciences Institute
    (ISI), National Aeronautics and Space Administration (NASA), United States military,
    and others. Several of the servers are still run by government agencies or the
    United States military, where added security can be put into place to protect
    them. For convenience, however, all the root name servers are now given alphabetical
    letter names in the special domain root-servers.net.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 55-2](ch55s05.html#internet_dns_root_name_servers "Table 55-2. Internet
    DNS Root Name Servers") shows the most current information about the DNS root
    name servers as of the date of publishing of this book. For your interest and
    amusement, I have also mapped the locations of these servers in [Figure 55-2](ch55s05.html#geographic_locations_of_internet_dns_roo
    "Figure 55-2. Geographic locations of Internet DNS root name servers").'
  prefs: []
  type: TYPE_NORMAL
- en: Table 55-2. Internet DNS Root Name Servers
  prefs: []
  type: TYPE_NORMAL
- en: '| Root Server Name | IP Address | Historical Name | Location(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a.root-servers.net | 198.41.0.4 | ns.internic.net | Dulles, VA, U.S. |'
  prefs: []
  type: TYPE_TB
- en: '| b.root-servers.net | 128.9.0.107 | ns1.isi.edu | Marina Del Rey, CA, U.S.
    |'
  prefs: []
  type: TYPE_TB
- en: '| c.root-servers.net | 192.33.4.12 | c.psi.net | Herndon, VA and Los Angeles,
    CA, U.S. |'
  prefs: []
  type: TYPE_TB
- en: '| d.root-servers.net | 128.8.10.90 | terp.umd.edu | College Park, MD, U.S.
    |'
  prefs: []
  type: TYPE_TB
- en: '| e.root-servers.net | 192.203.230.10 | ns.nasa.gov | Mountain View, CA, U.S.
    |'
  prefs: []
  type: TYPE_TB
- en: '| f.root-servers.net | 192.5.5.241 | ns.isc.org | Auckland, New Zealand; Sao
    Paulo, Brazil; Hong Kong, China; Johannesburg, South Africa; Los Angeles, CA,
    U.S.; New York, NY, U.S.; Madrid, Spain; Palo Alto, CA, U.S.; Rome, Italy; Seoul,
    Korea; San Francisco, CA, U.S.; San Jose, CA, U.S.; Ottawa, ON, Canada |'
  prefs: []
  type: TYPE_TB
- en: '| g.root-servers.net | 192.112.36.4 | ns.nic.ddn.mil | Vienna, VA, U.S. |'
  prefs: []
  type: TYPE_TB
- en: '| h.root-servers.net | 128.63.2.53 | aos.arl.army.mil | Aberdeen, MD, U.S.
    |'
  prefs: []
  type: TYPE_TB
- en: '| i.root-servers.net | 192.36.148.17 | nic.nordu.net | Stockholm, Sweden; Helsinki,
    Finland |'
  prefs: []
  type: TYPE_TB
- en: '| j.root-servers.net | 192.58.128.30 | — | Dulles, VA, U.S.; Mountain View,
    CA, U.S.; Sterling, VA, U.S.; Seattle, WA, U.S.; Atlanta, GA, U.S.; Los Angeles,
    CA, U.S.; Amsterdam, The Netherlands |'
  prefs: []
  type: TYPE_TB
- en: '| k.root-servers.net | 193.0.14.129 | — | London, UK; Amsterdam, The Netherlands
    |'
  prefs: []
  type: TYPE_TB
- en: '| l.root-servers.net | 198.32.64.12 | — | Los Angeles, CA, U.S. |'
  prefs: []
  type: TYPE_TB
- en: '| m.root-servers.net | 202.12.27.33 | — | Tokyo, Japan |'
  prefs: []
  type: TYPE_TB
- en: '![Geographic locations of Internet DNS root name servers](httpatomoreillycomsourcenostarchimages288169.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 55-2. Geographic locations of Internet DNS root name servers
  prefs: []
  type: TYPE_NORMAL
- en: The current list of root name servers can be found in the file [ftp://ftp.rs.internic.net/domain/named.root](ftp://ftp.rs.internic.net/domain/named.root).
    You can also find the information in a more user-friendly format at [http://www.root-servers.org](http://www.root-servers.org).
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Server Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the grunt work done by name servers is responding to name resolution
    requests. Busy servers—like the root name servers, the ones that carry zone information
    for the TLDs, and ones that serve very busy zones—must handle hundreds or even
    thousands of name resolution requests each *second*. Each of these requests takes
    time and resources to resolve and takes internetwork bandwidth away from the business
    of transferring data. It is essential, therefore, that DNS server implementations
    employ mechanisms to improve their efficiency and cut down on unnecessary name
    resolution requests. One of the most important of these is *caching*.
  prefs: []
  type: TYPE_NORMAL
- en: Name Server Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word *cache* refers to a store, or a place where something is kept. In the
    computer world, the term usually refers to an area of memory set aside for storing
    information that has been recently obtained so it can be used again. In the case
    of DNS, caching is used by DNS name servers to store the results of recent name
    resolution and other requests, so that if the request occurs again, it can be
    satisfied from the cache without requiring another complete run of the name resolution
    process. Due to how most people use computers, a particular request is often followed
    by another request for the same name, so caching can significantly reduce the
    number of requests that result in complete name resolution procedures.
  prefs: []
  type: TYPE_NORMAL
- en: An example is the best way to illustrate this. Suppose you are using a host
    on your company's local network. This host is probably configured to use your
    company's DNS name server to handle resolution requests. You type [www.xyzindustries.com](http://www.xyzindustries.com)
    into your web browser, which causes a resolution attempt to be made for that address.
    Most likely, your local DNS server doesn't know that name, so it will follow the
    complete name resolution process (described in [Chapter 56](ch56.html "Chapter 56. DNS
    RESOLUTION CONCEPTS AND RESOLVER OPERATIONS")) to get its address. After doing
    this, your local DNS server will *cache* the name [www.xyzindustries.com](http://www.xyzindustries.com)
    and the address associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: If you click a link for a page at that website, that new page will also probably
    be somewhere at the [www.xyzindustries.com](http://www.xyzindustries.com) site.
    This will result in another DNS resolution request being sent off to your local
    DNS server. However, this time, the local server will not need to perform a resolution.
    It remembers that this name is in its cache and returns the saved address for
    the name immediately. Voilà! You get your answer faster, and unnecessary Internet
    traffic is avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** *Caching* is an essential efficiency feature that reduces DNS
    message traffic by eliminating unnecessary requests for recently resolved names.
    Whenever a name is resolved, the resulting DNS information is cached so it can
    be used for subsequent requests that occur shortly thereafter.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, things aren't entirely this simple. One very important issue that
    comes up with every caching system, including the one used in DNS, is the matter
    of the *freshness* of the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Caching Data Persistence and the Time to Live Interval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose your local DNS server resolves the name [www.xyzindustries.com](http://www.xyzindustries.com),
    and then caches its address. In this example, where you click a link a few seconds
    after the XYZ Industries home page loads, you aren't likely to be too concerned
    about how fresh the DNS data is. But how about if you shut down your computer
    to go on vacation for two weeks, and then come back to work and type the name
    into your browser again. If your local server still has the name in its cache,
    how do you know the IP address of [www.xyzindustries.com](http://www.xyzindustries.com)
    hasn't changed during that two-week period?
  prefs: []
  type: TYPE_NORMAL
- en: Two different mechanisms are used to address this issue. The first is that when
    data is cached, the caching server also makes a note of the authoritative server
    from which it came. When a resolver (client) asks for a name resolution and the
    address is drawn from the cache, the server marks the answer as *non-authoritative*
    to clearly tell the client that the name came from the cache. The server also
    supplies the name of the authoritative server that originally supplied the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client then has a choice: It can either use the non-authoritative answer
    or issue a request for a fresh name resolution from the authoritative server.
    This is a trade-off between performance (using the cached data) and currency (asking
    for a fresh resolution each time). Usually, the cached data can be used safely,
    because DNS information doesn''t change very often.'
  prefs: []
  type: TYPE_NORMAL
- en: The second technique for ensuring that caching data doesn't get too old is a
    procedure for limiting the *persistence* of DNS cached data. Each RR has associated
    with it a time interval, called the *Time to Live (TTL)*. Whenever an RR is read
    from a server, the TTL for the record is also read. Any server caching the record
    is supposed to discard the record after that time interval expires.
  prefs: []
  type: TYPE_NORMAL
- en: Each zone also has associated with it a default value for the TTL field to be
    applied to all records in the zone. This allows an administrator to select a TTL
    value for all records in a zone without needing to enter TTL numbers for each
    record individually. At the same time, the administrator can assign an override
    TTL value to any records that need a number that is different from the default.
    This default TTL was originally kept in the special SOA RR for each zone, but
    is now handled using a special directive in the zone's master file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This Time to Live (TTL) field is not related to the one used in Internet Protocol
    (IP) datagrams (see [Chapter 21](ch21.html "Chapter 21. INTERNET PROTOCOL DATAGRAM
    ENCAPSULATION AND FORMATTING")). Obviously, IP and DNS are totally different protocols,
    but more than that, the TTL fields in IP and DNS don''t have the same meaning
    at all*.'
  prefs: []
  type: TYPE_NORMAL
- en: It's worth emphasizing that DNS gives control over caching to the owner of the
    record, not whoever is running the DNS server doing the caching. While it is possible
    for a particular caching server to override the TTL and specify how long data
    will be held in its own cache, DNS is not supposed to work that way. The ability
    to specify a TTL on a record-by-record basis allows the persistence of cache data
    to be tailored to the needs of the individual data elements. Data that changes
    often can be given a small TTL value; infrequently modified records can be given
    a higher TTL. Selecting the TTL value must be done carefully. This is another
    trade-off between performance (which is optimized with higher TTL values, reducing
    the number of queries made for cached data) and freshness of the data (which increases
    as the TTL values are lowered).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Cached information can become stale over time and result in
    incorrect responses sent to queries. Each RR can have associated with it a time
    interval, called the *Time to Live (TTL)*, that specifies how long the record
    may be held in a cache. The value of this field is controlled by the owner of
    the RR, who can tailor it to the specific needs of each RR type.'
  prefs: []
  type: TYPE_NORMAL
- en: Negative Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classic DNS caching stores only the results of successful name resolutions.
    It is also possible for DNS servers to cache the results of *unsuccessful* name
    resolution attempts; this is called *negative caching*. To extend the example
    we've been using in this section, suppose you mistakenly thought the name of the
    company's website was [www.xyz-industries.com](http://www.xyz-industries.com)
    and typed that into your browser. Your local DNS server would be unable to resolve
    the name and would mark that name as unresolvable in its cache—a negative cache
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you typed the name in incorrectly because someone mistyped it on an
    internal memo. If a colleague later tried the same name, the DNS server would
    say, "I already know this is a bogus name," and not try to resolve it again. Since
    there is no RR for an invalid name, the server itself must decide how long to
    cache this negative information. Negative caching improves performance because
    resolving a name that doesn't exist takes resources, just as resolving an existing
    one does. Note that regular caching is sometimes called *positive caching* to
    contrast it with negative caching.
  prefs: []
  type: TYPE_NORMAL
- en: The value to be used for negative caching in a zone is now specified by the
    Minimum field in the SOA RR for each zone. As mentioned in the previous section,
    this was formerly used to specify the default TTL for a zone.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Server Load Balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Address (A) RR is the most fundamental one in DNS, since it records an actual
    mapping between a domain name and an IP address. Let's consider for a moment one
    of the words in that sentence in more detail. No, I don't mean *address* or *RR*
    or *mapping*. I mean the word *an*!
  prefs: []
  type: TYPE_NORMAL
- en: The Address record mentions only a single address for each domain name. This
    means that each domain name maps to only a single physical hardware device. When
    the number of requests that a particular server or other device needs to handle
    is relatively small, this is not a problem; the function can usually be implemented
    using a single physical hardware device. If the server gets busier, the usual
    solution is to throw more hardware at the problem—get a bigger machine.
  prefs: []
  type: TYPE_NORMAL
- en: However, some hosts on a large internetwork, especially the Internet, feature
    servers that must handle tremendous amounts of traffic from many clients. There
    simply is no single hardware device that can readily handle the traffic of a site
    like [www.cnn.com](http://www.cnn.com) or [www.microsoft.com](http://www.microsoft.com),
    for example, without becoming unwieldy. Sites like these must use a technique
    called *load balancing* to spread requests across multiple hardware servers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple Address Records to Spread Out Requests to a Domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One simple way to do load balancing would be to have multiple machine names.
    For example, CNN could create several different websites called [www1.cnn.com](http://www1.cnn.com),
    [www2.cnn.com](http://www2.cnn.com), and so on, each pointing to a different hardware
    device. DNS certainly supports this type of solution. The problem with this solution
    is that it is cumbersome; it requires users to remember multiple server names.
  prefs: []
  type: TYPE_NORMAL
- en: It would be better if we could balance the load automatically. DNS supports
    this by providing a simple way to implement load balancing. Instead of specifying
    a single Address RR for a name, we can create several such records, thereby associating
    more than one IP address with a particular DNS name. When we do this, each time
    the authoritative name server for the zone in which that name exists resolves
    that name, it sends all the addresses on the list back to the requester. The server
    changes the order of the addresses supplied in the response, choosing the order
    randomly or in a sequential, round-robin fashion. The client will usually use
    the first address in the list returned by the server, so by changing the list,
    the server ensures that requests for that device's name are resolved to multiple
    hardware units.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Rather than creating a single Address (A) RR for a DNS domain
    name, it is possible to create multiple ones. This associates several IP addresses
    with one name, which can be used to spread a large number of requests for one
    domain name over many physical IP devices. This allows DNS to implement load balancing
    for busy Internet servers.'
  prefs: []
  type: TYPE_NORMAL
- en: As Internet traffic increases, load balancing is becoming more popular. In early
    2003, I saw a survey that indicated approximately 10 percent of Internet names
    at that time used load balancing—a fairly significant number. Most employed either
    two or three addresses, but some used as many as sixty addresses! Incidentally,
    at last check, [www.cnn.com](http://www.cnn.com) was associated with eight different
    IP addresses. (You can check the number of addresses associated with a name using
    the `host` command, as described in [Chapter 88](ch88.html "Chapter 88. TCP/IP
    ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS").)
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple DNS Servers to Spread Out DNS Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *DNS load balancing* also has a completely different meaning from what
    I described in the previous section. In the discussion of DNS server roles, I
    talked about how each zone should have at least one slave (secondary) DNS server
    in addition to the master (primary) server. The usually stated main reason for
    this is redundancy, in case something happens to cause the master server to fail.
    However, having a slave server can also allow the load of DNS resolution requests
    to be balanced between the servers. In fact, some busy domains have more than
    two servers specifically for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, *DNS load balancing* can refer to either using DNS to spread the load
    of requests (such as web page requests) to a device that is named using DNS or
    to spreading the load of DNS requests themselves.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Server Enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fundamentals of operation of DNS servers, as explained in the preceding
    sections in this chapter, are specified in the main DNS standards, RFC 1034 and
    1035\. These documents are pretty old by computer industry standards; they were
    published in 1987\. To the credit of the designers of DNS, most of what they originally
    put into the DNS protocol is still valid and in use today. The creators of DNS
    knew that it had to be able to scale to a large size, and the system has successfully
    handled the expansion of the Internet to a degree far beyond what anyone could
    have imagined 15 or so years ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'As originally defined, DNS requires that DNS information be updated manually
    by editing master files on the master server for a zone. The zone is then copied
    in its entirety to slave servers using the polling/zone-transfer mechanism described
    earlier in this chapter. This method is satisfactory when the internetwork is
    relatively small and changes to a zone are made infrequently. However, in the
    modern Internet, large zones may require nearly constant changes to their RRs.
    Hand-editing and constantly copying master files can be impractical, especially
    when they grow large, and having slave servers get out of date between zone transfers
    may lead to reliability and performance concerns. For these reasons, several enhancements
    to the operation of DNS servers have been proposed over the years. We''ll take
    a closer look at three of them here: DNS Notify, incremental zone transfers, and
    Dynamic DNS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Automating Zone Transfers: DNS Notify'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first problem that many DNS administrators wanted to tackle was the reliance
    on polling for updating slave name servers. Imagine that you placed an order for
    a new music CD at your favorite online music store, but it was out of stock—backordered.
    Which makes more sense: having you call them every six hours to ask if your CD
    has arrived yet, or having the store simply call you when it shows up?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is so obvious that the question seems ridiculous. Yet DNS uses the
    first model: slave name servers must constantly call up their zone masters and
    ask them, "Has anything changed yet?" This both generates unnecessary traffic
    and results in the slave name server being out of date from the time the master
    *does* change until the next poll is performed. Tweaking the Refresh time for
    the zone allows only the choice between more polls or more staleness when changes
    happen; neither is really good.'
  prefs: []
  type: TYPE_NORMAL
- en: To improve this situation, a new technique was developed and formalized in RFC
    1996, published in 1996 (weird coincidence!). This standard, "A Mechanism for
    Prompt Notification of Zone Changes (DNS NOTIFY)," defines a new DNS message type
    called *Notify* and describes a protocol for its use. The Notify message is a
    variation on the standard DNS message type, with some of the fields redefined
    to support this new feature.
  prefs: []
  type: TYPE_NORMAL
- en: If both the master and slave name servers support this feature, when a modification
    is made to an RR, the master server will automatically send a Notify message to
    its slave server(s), saying, "Your CD has arrived!" er… "The database has changed."
    The slave then acts as if its Refresh timer had just expired. Enabling this feature
    allows the Refresh interval to be dramatically increased, since slave servers
    don't need to constantly poll the master for changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The optional DNS Notify feature allows a master name server
    to inform slave name servers when changes are made to a zone. This has two advantages:
    It cuts down on unnecessary polling by the slave servers to find out if changes
    have occurred to DNS information, and it also reduces the amount of time that
    slave name servers have out-of-date records.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Improving Zone Transfer Efficiency: Incremental Transfers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second issue with regular DNS is the need to transfer the entire zone whenever
    a change to any part of it is made. There are many zones on the Internet that
    have truly enormous master files that change constantly. Consider the master files
    for the .COM zone, for example. Having to copy the entire database to slave name
    servers every time there is a change to even one record is beyond inefficient—it's
    downright insane!
  prefs: []
  type: TYPE_NORMAL
- en: RFC 1995, "Incremental Zone Transfer in DNS," specifies a new type of zone transfer
    called an *incremental zone transfer*. When this feature is implemented on master
    and slave name servers in a zone, the master server keeps track of the most recent
    changes made to the database. Each time a slave server determines that a change
    has occurred and the slave's database needs to be updated, it sends an IXFR (incremental
    transfer) query to the master, which contains the serial number of the slave's
    current copy of the database. The master then looks to see what RRs have changed
    since that serial number was the current one and sends only the updated RRs to
    the slave server.
  prefs: []
  type: TYPE_NORMAL
- en: To conserve storage, the master server obviously doesn't keep all the changes
    made to its database forever. It will generally track the last few modifications
    to the database, with the serial number associated with each. If the slave sends
    an IXFR request that contains a serial number for which recent change information
    is still on the master server, only the changes are sent in reply. If the request
    has a serial number so old that the master server no longer has information about
    some of the changes since that version of the database, a complete zone transfer
    is performed instead of an incremental one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The DNS *incremental zone transfer* enhancement uses a special
    message type that allows a slave name server to determine what changes have occurred
    since it last synchronized with the master server. By transferring only the changes,
    the amount of time and bandwidth used for zone transfers can be significantly
    reduced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with Dynamic IP Addresses: DNS Update/Dynamic DNS'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third problem with classic DNS is that it assumes changes are made infrequently
    to zones, so they can be handled by hand-editing master files. Some zones are
    so large that hand-editing of the master files would be nearly continuous. However,
    the problem goes beyond just inconvenience. Regular DNS assumes that the IP address
    for a host is relatively static. Modern networks, however, make use of host technologies
    such as the Dynamic Host Configuration Protocol (DHCP) (described in [Part III-3](pt14.html
    "Part III-3. HOST CONFIGURATION AND TCP/IP HOST CONFIGURATION PROTOCOLS")), to
    assign IP addresses dynamically to devices. When DHCP is used, the IP address
    of each host in a zone could change on a weekly, daily, or even hourly basis!
    Clearly, there would be no hope of keeping up with this rate of change using a
    human being and a text editor.
  prefs: []
  type: TYPE_NORMAL
- en: In April 1997, RFC 2136, "Dynamic Updates in the Domain Name System (DNS UPDATE),"
    was published. This standard describes an enhancement to basic DNS operation that
    allows DNS information to be dynamically updated. When this feature is implemented,
    the resulting system is sometimes called *Dynamic DNS (DDNS)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 2136 defines a new DNS message type: the Update message. Like the Notify
    message, the Update message is designed around the structure of regular DNS messages,
    but with changes to the meanings of several of the fields. As the name implies,
    Update messages allow RRs to be selectively changed within the master name server
    for a zone. Using a special message syntax, it is possible to add, delete, or
    modify RRs.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, care must be taken in how this feature is used, since we don't want
    just anyone to be making changes willy-nilly to our master records. The standard
    specifies a detailed process for verifying Update messages, as well as security
    procedures that must be put into place so the server accepts such messages from
    only certain individuals or systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic DNS allows administrators to make changes much more easily, but its
    true power becomes evident only when it is used to integrate DNS with other address-related
    protocols and services. Dynamic DNS solves a major weakness with traditional DNS:
    the inability to easily associate a host name with an address assigned using a
    protocol like DHCP.'
  prefs: []
  type: TYPE_NORMAL
- en: With DNS servers supporting this feature, DNS and DHCP can be integrated, allowing
    automatic address and name assignment, and automatic update of DNS records when
    a host's IP address changes. One common application of Dynamic DNS is to allow
    the use of DNS names by those who access the Internet using a service provider
    that dynamically assigns IP addresses. Dynamic DNS is similarly used by certain
    directory services, notably Microsoft's Active Directory, to associate addresses
    with device names.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** An enhancement to DNS, commonly called *Dynamic DNS (DDNS)*,
    allows DNS information in a server''s database to be updated automatically, rather
    than always requiring hand-editing of master files. This can not only save time
    and energy on the part of administrators, but it also allows DNS to better handle
    dynamic address assignment, such as the type performed by host configuration protocols
    like DHCP.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding three chapters, I have described the Domain Name System (DNS)
    name space, authorities, registration mechanism, and name servers. These elements
    can all be considered part of the infrastructure of DNS; they are the parts of
    the system that must be established first to enable it to be used. Once we have
    these components in place, we can actually get down to the business at hand: name
    resolution. This is accomplished using a specific set of procedures carried out
    by DNS clients called *resolvers*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I describe DNS name resolvers and the process of name resolution
    itself. I begin with an overview of the functions performed by DNS resolvers and
    how they work in general terms. I then describe the two fundamental methods of
    name resolution used in DNS: iterative and recursive resolution. I discuss the
    way that resolvers improve efficiency through local resolution and caching. I
    describe the steps in the actual name resolution algorithm. I then cover two special
    cases of name resolution: reverse name resolution using the special IN-ADDR.ARPA
    domain, and the way that DNS provides mail support using Mail Exchange resource
    records.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *The information in this section complements that in
    the previous chapter on DNS name servers. I assume in the topics here that you
    have at least basic familiarity with DNS servers*.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Resolver Functions and General Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name servers are arguably the most important part of the DNS system as a whole.
    After all, they store all the data on the system and actually provide the addresses
    we need when names are given to them. Without these servers, there would be no
    DNS at all. Of course, what use is a server if nobody is asking for service? The
    clients in the system, called *resolvers*, are also important, because they initiate
    the process of name resolution. Resolvers are where the rubber meets the road,
    so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: The operation of DNS resolvers is explained in the two main DNS standards. RFC
    1034 describes the functions performed by resolvers and how they work in general
    terms. This includes a discussion of the algorithm used to conduct name resolution.
    RFC 1035 deals more with the implementation details of resolvers and the fine
    points of how they do their jobs. Several subsequent standards have modified these
    base standards, changing some of the ways that resolvers work in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Name Resolution Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as the main job of a DNS server is to store DNS name data and serve it
    when it receives requests, the main job of a DNS resolver is to, well, resolve.
    While most people think of name resolution as only the process of transforming
    a DNS name into an IP address, this is just one of several types of resolution
    services performed by DNS. The following are a few of the most typical types of
    DNS resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard Name Resolution** Taking a DNS name as input and determining its
    corresponding IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverse Name Resolution** Taking an IP address and determining what name
    is associated with it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Mail Resolution** Determining where to send electronic mail (email)
    messages based on the email address used in a message.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions Performed by Name Resolvers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are other types of resolution activities as well, though again, most
    name resolution requests are of the standard variety, making it the primary focus
    in our discussion. To accomplish this task, name resolvers perform a number of
    related functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Providing the User Interface** Normal name resolution usually doesn''t involve
    explicitly running a piece of resolver software. In your web browser, you don''t
    have to say, "Please find the IP address for [www.xyzindustries.com](http://www.xyzindustries.com),"
    and then say, "Please connect to this IP address for XYZ Industries." You just
    type [www.xyzindustries.com](http://www.xyzindustries.com), and the name resolution
    happens. There is no magic involved. The resolver is just called *implicitly*
    instead of explicitly. The web browser recognizes that a name has been entered
    instead of an IP address and feeds it to the resolver, saying, "I need you to
    resolve this name, please." (Hey, it never hurts to be polite.) The resolver takes
    care of resolution and provides the IP address to the web browser, which connects
    to the site. Thus, the resolver is the interface between the user (both the human
    user and the software user, the browser) and the DNS system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forming and Sending Queries** Given a name to resolve, the DNS resolver must
    create an appropriate query using the DNS messaging system, determine what type
    of resolution to perform, and send the query to the appropriate name server.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing Responses** The resolver must accept back responses from the DNS
    server to which it sent its query and decide what to do with the information within
    the reply. As you''ll see, it may be necessary for more than one server to be
    contacted for a particular name resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The primary clients in DNS are software modules called DNS
    *name resolvers*. They are responsible for accepting names from client software,
    generating resolution requests to DNS servers, and processing and returning responses.'
  prefs: []
  type: TYPE_NORMAL
- en: These tasks seem fairly simple, and they are in some ways, but implementation
    can become rather complicated. The resolver may need to juggle several outstanding
    name resolutions simultaneously. It must keep track of the different requests,
    queries, and responses and make sure everything is kept straight.
  prefs: []
  type: TYPE_NORMAL
- en: Name resolvers don't need to perform nearly as many administrative jobs as name
    servers do; clients are usually simpler than servers in this regard. One important
    support function that many name resolvers do perform, however, is caching. Like
    name servers, name resolvers can cache the results of the name resolutions they
    perform to save time if the same resolution is required again. (Not all resolvers
    perform caching, however.)
  prefs: []
  type: TYPE_NORMAL
- en: Even though resolvers are the DNS components that are most associated with name
    resolution, name servers can also act as clients in certain types of name resolution.
    In fact, it is possible to set up a network so that the resolvers on each of the
    client machines do nothing more than hand resolution requests to a local DNS server
    and let the server take care of it. In this case, the client resolver becomes
    little more than a shell, sometimes called a *stub resolver*. This has the advantage
    of centralizing name resolution for the network, but a potential disadvantage
    of performance reduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS Name Resolution Techniques: Iterative and Recursive Resolution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conventional name resolution transforms a DNS name into an IP address. At the
    highest level, this process can be considered to have two phases. In the first
    phase, we locate a DNS name server that has the information we need: the address
    that goes with a particular name. In the second phase, we send that server a request
    containing the name we want to resolve, and it sends back the address required.'
  prefs: []
  type: TYPE_NORMAL
- en: Somewhat ironically, the second phase (the actual mapping of the name into an
    address) is fairly simple. It is the first phase—finding the right server—that
    is potentially difficult and represents most of the work in DNS name resolution.
    While perhaps surprising, this is a predictable result of how DNS is structured.
    Name information in DNS is not centralized, but rather distributed throughout
    a hierarchy of servers, each of which is responsible for one zone in the DNS name
    space. This means we must follow a special sequence of steps to find the server
    that has the information we need.
  prefs: []
  type: TYPE_NORMAL
- en: The formal process of name resolution parallels the treelike hierarchy of the
    DNS name space, authorities, and servers. Resolution of a particular DNS name
    starts with the most general part of the name and proceeds to the most specific
    part. Naturally, the most general part of every name is the *root* of the DNS
    tree, represented in a name as a trailing dot (.), sometimes omitted. The next
    most specific part is the top-level domain (TLD), then the second-level domain,
    and so forth. The DNS name servers are linked in that the DNS server at one level
    knows the name of the servers that are responsible for subdomains in zones below
    it at the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we start with C.B.A. as the fully qualified domain name (FQDN). Formally,
    every name resolution begins with the root of the tree—this is why the root name
    servers are so important. It''s possible that the root name servers are authoritative
    for this name, but this is probably not the case; that''s not what the root name
    servers are usually used for. What the root name server does know is the name
    of the server responsible for the TLD: A.. The name server for A. may have the
    information to resolve C.B.A., but it''s still fairly high level, so C.B.A. is
    probably not directly within its zone. In that case, it will not know the address
    we seek, but it will know the name of the server responsible for B.A.. In turn,
    that name server may be authoritative for C.B.A., or it may just know the address
    of the server for C.B.A., which will have the information we need. As you can
    see, it is very possible that several different servers may be needed in a name
    resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Since DNS name information is stored as a distributed database
    spread across many servers, name resolution cannot usually be performed using
    a single request/response communication. It is first necessary to find the server
    that has the information that the resolver requires. This usually requires a sequence
    of message exchanges, starting from a root name server and proceeding down to
    the specific server containing the resource records (RRs) that the client requires.'
  prefs: []
  type: TYPE_NORMAL
- en: The DNS standards actually define two distinct ways of following this hierarchy
    of servers to discover the correct one. They both eventually lead to the right
    device, but they differ in how they assign responsibility for resolution when
    it requires multiple steps. The two techniques are *iterative resolution* and
    *recursive resolution*.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a client sends an iterative request to a name server, the server responds
    with either the answer to the request (for a regular resolution, the IP address
    we want) *or* the name of another server that has the information or is closer
    to it. The original client must then *iterate* by sending a new request to this
    referred server, which again may either answer it or provide another server name.
    The process continues until the correct server is found. The iterative resolution
    method is illustrated in [Figure 56-1](ch56s02.html#iterative_dns_name_resolution_in_this_ex
    "Figure 56-1. Iterative DNS name resolution In this example, the client is performing
    a name resolution for C.B.A. using strictly iterative resolution. It is thus responsible
    for forming all DNS requests and processing all replies. It starts by sending
    a request to the root name server for this mythical hierarchy. That server doesn't
    have the address of C.B.A., so it instead returns the address of the name server
    for A. The client then sends its query to that name server, which points the client
    to the server for B.A. That name server refers the client to the name server that
    actually has the address for C.B.A., which returns it to the client. Contrast
    this to Figure 56-2.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Iterative DNS name resolution In this example, the client is performing a
    name resolution for C.B.A. using strictly iterative resolution. It is thus responsible
    for forming all DNS requests and processing all replies. It starts by sending
    a request to the root name server for this mythical hierarchy. That server doesn''t
    have the address of C.B.A., so it instead returns the address of the name server
    for A. The client then sends its query to that name server, which points the client
    to the server for B.A. That name server refers the client to the name server that
    actually has the address for C.B.A., which returns it to the client. Contrast
    this to .](httpatomoreillycomsourcenostarchimages288171.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 56-1. Iterative DNS name resolution In this example, the client is performing
    a name resolution for C.B.A. using strictly iterative resolution. It is thus responsible
    for forming all DNS requests and processing all replies. It starts by sending
    a request to the root name server for this mythical hierarchy. That server doesn't
    have the address of C.B.A., so it instead returns the address of the name server
    for A. The client then sends its query to that name server, which points the client
    to the server for B.A. That name server refers the client to the name server that
    actually has the address for C.B.A., which returns it to the client. Contrast
    this to [Figure 56-2](ch56s02.html#recursive_dns_name_resolution_this_is_th "Figure 56-2. Recursive
    DNS name resolution This is the same theoretical DNS resolution shown in Figure 56-1,
    but this time, the client asks for the name servers to perform recursive resolution,
    and they agree to do so. As in the iterative case, the client sends its initial
    request to the root name server. That server doesn't have the address of C.B.A.,
    but instead of merely returning to the client the address of the name server for
    A., it sends a request to that server itself. That name server sends a request
    to the server for B.A., which sends a request to the server for C.B.A.. The address
    of C.B.A. is then carried back up the chain of requests, from the server of C.B.A.
    to that of B.A., then A., then the root, and then finally, back to the client.").
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a client sends a recursive request to a name server, the server responds
    with the answer if it has the information sought. If it doesn't, the server takes
    responsibility for finding the answer by becoming a client on behalf of the original
    client and sending new requests to other servers. The original client sends only
    one request and eventually gets the information it wants (or an error message
    if it is not available). This technique is shown in [Figure 56-2](ch56s02.html#recursive_dns_name_resolution_this_is_th
    "Figure 56-2. Recursive DNS name resolution This is the same theoretical DNS resolution
    shown in Figure 56-1, but this time, the client asks for the name servers to perform
    recursive resolution, and they agree to do so. As in the iterative case, the client
    sends its initial request to the root name server. That server doesn't have the
    address of C.B.A., but instead of merely returning to the client the address of
    the name server for A., it sends a request to that server itself. That name server
    sends a request to the server for B.A., which sends a request to the server for
    C.B.A.. The address of C.B.A. is then carried back up the chain of requests, from
    the server of C.B.A. to that of B.A., then A., then the root, and then finally,
    back to the client.").
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting Iterative and Recursive Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help explain the difference between iterative and recursive resolution, let's
    take a side trip to a real-world case. Suppose you are trying to find the phone
    number of your old friend Carol, with whom you haven't spoken in years. You call
    your friend Joe. He doesn't have Carol's number, but he gives you John's number,
    suggesting you call him. So you call John. He doesn't have the information, but
    he knows the number of Carol's best friend, Debbie, and gives that to you. You
    call Debbie, and she gives you Carol's information. This is an example of an iterative
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursive DNS name resolution This is the same theoretical DNS resolution
    shown in , but this time, the client asks for the name servers to perform recursive
    resolution, and they agree to do so. As in the iterative case, the client sends
    its initial request to the root name server. That server doesn''t have the address
    of C.B.A., but instead of merely returning to the client the address of the name
    server for A., it sends a request to that server itself. That name server sends
    a request to the server for B.A., which sends a request to the server for C.B.A..
    The address of C.B.A. is then carried back up the chain of requests, from the
    server of C.B.A. to that of B.A., then A., then the root, and then finally, back
    to the client.](httpatomoreillycomsourcenostarchimages288173.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 56-2. Recursive DNS name resolution This is the same theoretical DNS
    resolution shown in [Figure 56-1](ch56s02.html#iterative_dns_name_resolution_in_this_ex
    "Figure 56-1. Iterative DNS name resolution In this example, the client is performing
    a name resolution for C.B.A. using strictly iterative resolution. It is thus responsible
    for forming all DNS requests and processing all replies. It starts by sending
    a request to the root name server for this mythical hierarchy. That server doesn't
    have the address of C.B.A., so it instead returns the address of the name server
    for A. The client then sends its query to that name server, which points the client
    to the server for B.A. That name server refers the client to the name server that
    actually has the address for C.B.A., which returns it to the client. Contrast
    this to Figure 56-2."), but this time, the client asks for the name servers to
    perform recursive resolution, and they agree to do so. As in the iterative case,
    the client sends its initial request to the root name server. That server doesn't
    have the address of C.B.A., but instead of merely returning to the client the
    address of the name server for A., it sends a request to that server itself. That
    name server sends a request to the server for B.A., which sends a request to the
    server for C.B.A.. The address of C.B.A. is then carried back up the chain of
    requests, from the server of C.B.A. to that of B.A., then A., then the root, and
    then finally, back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, suppose you call Joe and Joe says, "I don't know, but I think I
    know how to find out." He calls John, and then Debbie, and then calls you back
    with the phone number. That would be like recursive resolution.
  prefs: []
  type: TYPE_NORMAL
- en: So, in essence, iteration is like doing the job yourself, while recursion is
    like passing the buck. You might think that everyone would always want to use
    recursion since it makes the other guy do the work. This is true, but passing
    the buck is not considered good form if it is not done with permission. Not all
    name servers support recursion, especially servers near the top of the hierarchy.
    Obviously, we don't want to bog down certain name servers—such as the root name
    servers, the ones that handle .COM, and other critical TLDs—with doing recursion.
    It is for this reason that clients must request that name servers perform recursion
    for them. One place where recursion is often used is with the local name server
    on a network. Rather than making client machine resolvers perform iterative resolution,
    it is common for the resolver to generate a recursive request to the local DNS
    server, which then generates iterative requests to other servers as needed. As
    you can see, recursive and iterative requests can be combined in a single resolution,
    providing significant flexibility to the process as a whole. This is demonstrated
    in a more realistic example in the "DNS Name Resolution Process" section later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Again, remember that for the purpose of understanding resolution, a DNS server
    can act as a client. As soon as a DNS server accepts a recursive request for resolution
    on a name it cannot resolve itself, it becomes a client in the process. Also,
    it is common for resolvers to know the names of not one, but two local DNS servers,
    so if a problem occurs reaching the first, they can try the second.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The two methods of name resolution in DNS are *iterative resolution*
    and *recursive resolution*. In iterative resolution, if a client sends a request
    to a name server that does not have the information the client needs, the server
    returns a pointer to a different name server, and the client sends a new request
    to that server. In recursive resolution, if a client sends a request to a server
    that doesn''t have the requested information, that server takes on the responsibility
    for sending requests to other servers to find the necessary records, and then
    returns them to the client. A server doing this takes on the role of client for
    its requests to other servers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS Name Resolution Efficiency Improvements: Caching and Local Resolution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic resolution techniques—iterative and recursive—can be considered complete
    from an algorithmic standpoint. By starting at the top (root) and working our
    way down, we are "guaranteed" to always eventually arrive at the server that has
    the information we need. I put *guaranteed* in quotation marks because, as always,
    there are no real guarantees in networking—we might have asked for a nonexistent
    name, or a server might have bad data, for example. But in the absence of such
    atypical problems, the process leads to the information eventually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that last word: *eventually*. Both iterative and recursive resolution
    will get us to the right server, but they take a long time to do it, especially
    if the name we are trying to resolve is in a deep part of the DNS hierarchy (for
    example, F.E.D.C.B.A.). Since resolution is done so often, it is helpful to define
    changes to the basic resolution process that improve efficiency as much as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Motivation for Caching: Locality of Reference'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A computer science principle called *locality of reference* describes two common
    phenomena related to how computers (and networks) are used. The first, sometimes
    called *spatial locality of reference*, observes that a resource is more likely
    to be referenced if it is near another resource that was recently referenced.
    The second, *temporal locality of reference*, says a resource is more likely to
    be accessed if it was recently accessed.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe both of these phenomena by using the example of browsing the
    Web. To observe spatial locality of reference, notice what happens when you visit
    a site such as [http://www.tcpipguide.com](http://www.tcpipguide.com). The initial
    request asks the server for the main index document of *The TCP/IP Guide*. However,
    that document contains links to several images and other items, all of which are
    also located at the domain [tcpipguide.com](http://tcpipguide.com). When your
    browser asks for the main document, it will shortly thereafter also ask for a
    number of graphics. As you navigate the site, you will click links to go to other
    web pages. Again, most of these will be at the same domain, [tcpipguide.com](http://tcpipguide.com).
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that if we resolve a particular domain name, it is likely
    that we will need to resolve it again very soon in the future. It would be silly
    to need to interrogate the same domain server dozens of times, asking it to resolve
    the same name each time.
  prefs: []
  type: TYPE_NORMAL
- en: The second phenomenon, *temporal locality of reference*, is one you have probably
    noticed yourself. You are far more likely to access a resource you have used recently
    than one you have not looked at in a year. This means that maintaining information
    about recently used resources can be inherently advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: These two phenomena are the rationale for caching in the computer world in general,
    and as you have seen in [Chapter 55](ch55.html "Chapter 55. DNS NAME SERVER CONCEPTS
    AND OPERATION"), in DNS servers in particular. The same advantages apply to resolvers,
    and many of them perform caching also, in a way rather similar to how it is done
    in servers.
  prefs: []
  type: TYPE_NORMAL
- en: Name Resolver Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On a particular client computer, once a particular name is resolved, it is cached
    and remains ready for the next time it is needed. Again, this eliminates traffic
    and load on DNS servers. (Note, however, that not all resolvers perform caching.)
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we bother having caching on both resolvers and servers.
    This is not redundant, as it may appear. Or rather, it's redundant, but in a good
    way. To understand why, we must recognize that a fundamental trade-off in caching
    is that a cache provides better performance the closer it is the requester of
    the data, but better coverage the farther it is from the user.
  prefs: []
  type: TYPE_NORMAL
- en: If resolvers didn't cache results but our local server did, we could get the
    information from the server's cache, but it would require waiting for the exchange
    of a query and response. The resolver's cache is closer to the user and so more
    efficient. At the same time, this doesn't obviate the need for caching at our
    network's local DNS server. The server is farther away from the user than the
    resolver, but its cache is shared by many machines. They can all benefit from
    its cache. For example, if you look up a particular name, and then someone else
    does a few minutes later, she can use your cached resolution, even though she
    is typing it for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In addition to the caching performed by DNS name servers, many
    (but not all) DNS resolvers also cache the results of recent resolution requests.
    This cache is checked prior to beginning a name resolution, to save time when
    multiple requests are made for the same name.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching by name resolvers follows the same general principles and rules as caching
    by name servers, outlined in [Chapter 55](ch55.html "Chapter 55. DNS NAME SERVER
    CONCEPTS AND OPERATION"). The amount of time a resource record (RR) is held in
    the cache is specified by its Time to Live (TTL) value. Also, resolvers will not
    cache the results of certain queries, such as reverse lookups, and may also not
    cache a resolution if they suspect (for whatever reason) that the data returned
    is unreliable or corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Local Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One other area where resolution efficiency can be improved is the special case
    where we are trying to resolve the names of computers in our own organizations.
    Suppose that you, an employee at XYZ Industries, want to get some sales information
    using the File Transfer Protocol (FTP) from [sales.xyzindustries.com](http://sales.xyzindustries.com).
    Your FTP client will invoke your local resolver to resolve that name, by sending
    it to your local DNS server. Now, would it be smart for that server, which is
    here inside the company, to start the resolution process up at the root name server?
    Not really.
  prefs: []
  type: TYPE_NORMAL
- en: The local DNS server that accepts local resolution requests from resolvers on
    the network may be the authoritative name server for [sales.xyzindustries.com](http://sales.xyzindustries.com).
    In other cases, it may know how to answer certain resolution requests directly.
    Obviously, it makes sense for the server to check to see if it can answer a resolver's
    query before heading up to the root server, since this provides a faster answer
    to the client and saves internetwork traffic. This is called *local resolution*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most DNS servers will perform this check to see if they have the information
    needed for a request before commencing the formal top-down resolution process.
    The exception is DNS servers that do not maintain information about any zones:
    *caching-only servers*. In some cases, DNS resolvers on client machines may also
    have access to certain local zone information, in which case, they can use it
    instead of sending a resolution query at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Most operating systems support the use of the old host table mechanism (described
    in [Chapter 51](ch51.html "Chapter 51. TCP/IP NAME SYSTEMS OVERVIEW AND THE HOST
    TABLE NAME SYSTEM")), which can be useful for local machines on a network. If
    a host has a host table, the resolver will check the host table to see if it can
    find a mapping for a name before it will bother with the more time-consuming DNS
    resolution process. This is not technically part of DNS, but is often used in
    conjunction with it*.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Name Resolution Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first half of this chapter, I have described what name resolvers do,
    explained the basic top-down resolution process using iterative and recursive
    resolution, and discussed how local resolution and caching are used to improve
    resolution performance. Now it's time to tie all this background material together
    and see how the name resolution process works as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, the best way to do this is by example. Here, I will actually combine
    two examples I have used earlier: the fictitious company XYZ Industries and the
    nonexistent college, Googleplex University.'
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Example of DNS Name Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that XYZ Industries runs its own DNS servers for the [xyzindustries.com](http://xyzindustries.com)
    zone. The master name server is called [ns1.xyzindustries.com](http://ns1.xyzindustries.com),
    and the slave is [ns2.xyzindustries.com](http://ns2.xyzindustries.com). These
    are also used as local DNS servers for resolvers on client machines. We'll assume
    for this example that, as is often the case, our DNS servers will accept recursive
    requests from machines within our company, but we will not assume that other machines
    will accept such requests. Let's also assume that both the server and resolver
    perform caching, and that the caches are empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that Googleplex University runs its own DNS servers for the googleplex.edu
    domain, as in the example in [Chapter 54](ch54.html "Chapter 54. DNS NAME REGISTRATION,
    PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES"). There are three subdomains: finearts.googleplex.edu,
    compsci.googleplex.edu, and admin.googleplex.edu. Of these, compsci.googleplex.edu
    is in a separate zone with dedicated servers, while the other subdomains are in
    the googleplex.edu zone (see [Figure 54-2](ch54s06.html#dns_zones_of_authority_cuts_can_be_made_
    "Figure 54-2. DNS zones of authority Cuts can be made between nodes in the DNS
    name tree to create an arbitrary hierarchy of name authorities. This example shows
    the DNS tree branch for googleplex.edu, with each zone indicated using a different
    shading. IANA/ICANN is responsible for the root domain, and a separate authority
    named Educause takes care of .EDU. The third zone covers much of googleplex.edu,
    except that a cut has been made between googleplex and compsci to create an independent
    zone of authority for compsci.googleplex.edu.")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose you are an employee within XYZ Industries and one of your clients
    is in charge of the networking department at Googleplex U. You type into your
    web browser the address of that department''s web server, [www.net.compsci.googleplex.edu](http://www.net.compsci.googleplex.edu).
    In simplified terms, the procedure would involve the following steps ([Figure 56-3](ch56s04.html#example_of_the_dns_name_resolution_proce
    "Figure 56-3. Example of the DNS name resolution process This fairly complex example
    illustrates a typical DNS name resolution using both iterative and recursive resolution.
    The user types a DNS name (www.net.compsci.googleplex.edu) into a web browser,
    which causes a DNS resolution request to be made from her client machine''s resolver
    to a local DNS name server. That name server agrees to resolve the name recursively
    on behalf of the resolver, but uses iterative requests to accomplish it. These
    requests are sent to a DNS root name server, followed in turn by the name servers
    for .edu, googleplex.edu, and compsci.googleplex.edu. The IP address is then passed
    to the local name server and then back to the user''s resolver, and finally, to
    her web browser software.") shows the process graphically):'
  prefs: []
  type: TYPE_NORMAL
- en: Your web browser recognizes the request for a name and invokes your local resolver,
    passing to it the name [www.net.compsci.googleplex.edu](http://www.net.compsci.googleplex.edu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resolver checks its cache to see if it already has the address for this
    name. If it does, it returns it immediately to the web browser, but in this case,
    we are assuming that it does not. The resolver also checks to see if it has a
    local host table file. If so, it scans the file to see if this name has a static
    mapping. If so, it resolves the name using this information immediately. Again,
    let's assume it does not, since that would be boring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resolver generates a recursive query and sends it to [ns1.xyzindustries.com](http://ns1.xyzindustries.com)
    (using that server's IP address, of course, which the resolver knows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local DNS server receives the request and checks its cache. Again, let's
    assume it doesn't have the information needed. If it did, it would return the
    information, marked non-authoritative, to the resolver. The server also checks
    to see if it has in its zone resource records that can resolve [www.net.compsci.googleplex.edu](http://www.net.compsci.googleplex.edu).
    Of course, it does not in this case, since they are in totally different domains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ns1.xyzindustries.com](http://ns1.xyzindustries.com) generates an iterative
    request for the name and sends it to a root name server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root name server does not resolve the name. It returns the name and address
    of the name server for the .edu domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ns1.xyzindustries.com](http://ns1.xyzindustries.com) generates an iterative
    request and sends it to the name server for .edu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name server for .edu returns the name and address of the name server for
    the googleplex.edu domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ns1.xyzindustries.com](http://ns1.xyzindustries.com) generates an iterative
    request and sends it to the name server for googleplex.edu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name server for googleplex.edu consults its records. It sees, however, that
    this name is in the compsci.googleplex.edu subdomain, which is in a separate zone.
    It returns the name server for that zone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ns1.xyzindustries.com](http://ns1.xyzindustries.com) generates an iterative
    request and sends it to the name server for compsci.googleplex.edu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name server for compsci.googleplex.edu is authoritative for [www.net.compsci.googleplex.edu](http://www.net.compsci.googleplex.edu).
    It returns the IP address for that host to [ns1.xyzindustries.com](http://ns1.xyzindustries.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ns1.xyzindustries.com](http://ns1.xyzindustries.com) caches this resolution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local name server returns the resolution to the resolver on your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your local resolver also caches the information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local resolver gives the address to your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your browser commences an HTTP request to the Googleplex machine's IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This seems rather complicated and slow. Of course, computers work faster than
    you can read (or I can type, for that matter). Even given that, the benefits of
    caching are obvious—if the name were in the cache of the resolver or the local
    DNS server, most of these steps would be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example is highly simplified and also shows only one possible
    way that servers might be set up. For one thing, it is possible that even though
    compsci.googleplex.edu is in a separate zone from googleplex.edu, they might use
    the same server. In that case, one iteration in the process would be skipped.
    The example also doesn't show what happens if an error occurs in the process.
    Also, if the name entered were an alias, indicated by a CNAME record, this would
    change the processing as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the DNS name resolution process This fairly complex example illustrates
    a typical DNS name resolution using both iterative and recursive resolution. The
    user types a DNS name (www.net.compsci.googleplex.edu) into a web browser, which
    causes a DNS resolution request to be made from her client machine''s resolver
    to a local DNS name server. That name server agrees to resolve the name recursively
    on behalf of the resolver, but uses iterative requests to accomplish it. These
    requests are sent to a DNS root name server, followed in turn by the name servers
    for .edu, googleplex.edu, and compsci.googleplex.edu. The IP address is then passed
    to the local name server and then back to the user''s resolver, and finally, to
    her web browser software.](httpatomoreillycomsourcenostarchimages288175.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 56-3. Example of the DNS name resolution process This fairly complex
    example illustrates a typical DNS name resolution using both iterative and recursive
    resolution. The user types a DNS name ([www.net.compsci.googleplex.edu](http://www.net.compsci.googleplex.edu))
    into a web browser, which causes a DNS resolution request to be made from her
    client machine's resolver to a local DNS name server. That name server agrees
    to resolve the name recursively on behalf of the resolver, but uses iterative
    requests to accomplish it. These requests are sent to a DNS root name server,
    followed in turn by the name servers for .edu, googleplex.edu, and compsci.googleplex.edu.
    The IP address is then passed to the local name server and then back to the user's
    resolver, and finally, to her web browser software.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to Resolution to Handle Aliases (CNAME Records)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CNAME records are used to allow a constant name for a device to be presented
    to the outside world, while allowing the actual device that corresponds to the
    name to vary inside the organization. When a CNAME is used, it changes the name
    resolution process by adding an extra step: First we resolve the alias to the
    canonical name, and then we resolve the canonical name.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, web servers are almost always named starting with www., so at XYZ
    Industries, we want people to be able to find our website at [www.xyzindustries.com](http://www.xyzindustries.com).
    However, the web server may be shared with other services on [bigserver.xyzindustries.com](http://bigserver.xyzindustries.com).
    We can set up a CNAME record to point [www.xyzindustries.com](http://www.xyzindustries.com)
    to [bigserver.xyzindustries.com](http://bigserver.xyzindustries.com). Resolution
    of www will result in a CNAME pointing to bigserver, which is then itself resolved.
    If in the future, our business grows and we decide to upgrade our web service
    to run on [biggerserver.xyzindustries.com](http://biggerserver.xyzindustries.com),
    we just change the CNAME record, and users are unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Reverse Name Resolution Using the IN-ADDR.ARPA Domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If most people were asked to identify the core job of DNS to one function, they
    would probably say it was converting the names of objects into the numeric IP
    addresses associated with them. (Well, they would if they knew much about DNS.)
    For this reason, DNS is sometimes compared to a telephone book, or to telephone
    411 (information) service. There are certain problems with this analogy, but at
    the highest level, it is valid. In both cases, we take a name, consult a database
    (of one type or another), and produce from it a number that matches that name.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, there are sometimes situations where you don't want to find
    the phone number that goes with a name, but rather, you have a phone number and
    want to know what person it belongs to. For example, this might happen if your
    telephone records the number of incoming calls but you don't have caller ID to
    display the name associated with a number. You might also find a phone number
    on a piece of paper and not remember whose number it is.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in the networking world, there are many situations where we have
    an IP address and want to know what name goes with it. For example, a World Wide
    Web server records the IP address of each device that connects to it in its server
    logs, but these numbers are generally meaningless to humans, who prefer to see
    the names that go with them. A more serious example might be a hacker trying to
    break into your computer; by converting the IP address into a name, you might
    be able to find out what part of the world he is from, what Internet service provider
    (ISP) he is using, and so forth. There are also many reasons why a network administrator
    might want to find out the name that goes with an address, for setup or troubleshooting
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: DNS originally included a feature called *inverse querying* that would allow
    this type of "opposite" resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Original Method: Inverse Querying'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For inverse querying, a resolver could send a query which, instead of having
    a name filled in and a space for the server to fill in the IP address, had the
    IP address and a space for the name. The server would check its RRs and return
    the name to the resolver.
  prefs: []
  type: TYPE_NORMAL
- en: This works fine in theory, and even in practice, if the internetwork is very
    small. However, remember that due to the distributed nature of DNS information,
    the biggest part of the job of resolution is finding the right server. Now, in
    the case of regular resolution, we can easily find the right server by traversing
    the hierarchy of servers. This is possible because the servers are connected together
    following a hierarchy of names.
  prefs: []
  type: TYPE_NORMAL
- en: DNS servers are not, however, arranged based on IP address. This means that
    to use inverse queries, we need to use the right name server for the IP address
    we want to resolve into a name, with no easy way to find out what it is. Sure,
    we could try sending the inverse query to the authoritative DNS server for every
    zone in the hierarchy. If you tried, it would probably take you longer than it
    took to write this book, so let's not go there. The end result of all of this
    is that inverse queries were never popular, except for local server troubleshooting.
    They were formally removed from DNS in November 2002 through the publishing of
    RFC 3425.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what to do? Well, the problem is that the servers are arranged by name
    and not by IP address. The solution, therefore, is as simple as it sounds: Arrange
    the servers by IP address. This doesn''t mean we remove the name hierarchy, or
    duplicate all the servers, or anything silly like that. Instead, we create an
    additional, numerical hierarchy that coexists with the name hierarchy. We then
    use this to find names from numbers, using a process commonly called *reverse
    name resolution*.'
  prefs: []
  type: TYPE_NORMAL
- en: The IN-ADDR.ARPA Name Structure for Reverse Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name hierarchy for the Internet is implemented using a special domain called
    *IN-ADDR.ARPA*, located within the reserved .ARPA TLD (*IN-ADDR* stands for *INternet
    ADDRess*). Recall from the discussion in [Chapter 54](ch54.html "Chapter 54. DNS
    NAME REGISTRATION, PUBLIC ADMINISTRATION, ZONES, AND AUTHORITIES") that .ARPA
    was originally used to transition old Internet hosts to DNS and is now used by
    the folks that run the Internet for various purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special numerical hierarchy is created within IN-ADDR.ARPA that covers the
    entire IP address space (see [Figure 56-4](ch56s05.html#the_dns_in-addrarpa_reverse_name_resolut
    "Figure 56-4. The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special
    IN-ADDR.ARPA hierarchy was created to allow easy reverse lookups of DNS names.
    IN-ADDR.ARPA contains 256 subdomains numbered 0 to 255, each of which has 256
    subdomains numbered 0 to 255, and so forth, down to four levels. Thus, each IP
    address is represented in the hierarchy. This example shows the DNS domain name
    www.xyzindustries.com. It would have a conventional RR pointing to its IP address,
    191.27.203.8, as well as a reverse resolution record at 8.203.27.191.IN-ADDR.ARPA,
    pointing to the domain name www.xyzindustries.com.")):'
  prefs: []
  type: TYPE_NORMAL
- en: At the first level within IN-ADDR.ARPA there are 256 subdomains called 0, 1,
    2, and so on, up to 255; for example, 191.IN-ADDR.ARPA. (Actually, there may not
    be all 256 of these, since some IP addresses are reserved, but let's ignore that
    for now.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within each of the first-level subdomains, there are 256 further subdomains
    at the second level, numbered the same way. So, for example, one of these would
    be 27.191.IN-ADDR.ARPA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, there are 256 subdomains at the third level within each of the second-level
    subdomains, such as 203.27.191.IN-ADDR.ARPA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there are 256 subdomains at the fourth level within each of the third-level
    subdomains, such as 8.203.27.191.IN-ADDR.ARPA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, within IN-ADDR.ARPA, we have created a name space that parallels
    the address space of the Internet Protocol (IP). Yes, this means there are several
    billion nodes and branches in this part of the Internet DNS name space!
  prefs: []
  type: TYPE_NORMAL
- en: RR Setup for Reverse Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this structure in place, we can now associate one entry in this name space
    with each entry in the real DNS name space. We do this using the Pointer (PTR)
    RR type. For example, if [www.xyzindustries.com](http://www.xyzindustries.com)
    has the IP address 191.27.203.8, then the DNS server for its zone will have an
    Address (A) RR indicating this. In master file text format, it will say something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special IN-ADDR.ARPA
    hierarchy was created to allow easy reverse lookups of DNS names. IN-ADDR.ARPA
    contains 256 subdomains numbered 0 to 255, each of which has 256 subdomains numbered
    0 to 255, and so forth, down to four levels. Thus, each IP address is represented
    in the hierarchy. This example shows the DNS domain name www.xyzindustries.com.
    It would have a conventional RR pointing to its IP address, 191.27.203.8, as well
    as a reverse resolution record at 8.203.27.191.IN-ADDR.ARPA, pointing to the domain
    name www.xyzindustries.com.](httpatomoreillycomsourcenostarchimages288177.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 56-4. The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special
    IN-ADDR.ARPA hierarchy was created to allow easy reverse lookups of DNS names.
    IN-ADDR.ARPA contains 256 subdomains numbered 0 to 255, each of which has 256
    subdomains numbered 0 to 255, and so forth, down to four levels. Thus, each IP
    address is represented in the hierarchy. This example shows the DNS domain name
    [www.xyzindustries.com](http://www.xyzindustries.com). It would have a conventional
    RR pointing to its IP address, 191.27.203.8, as well as a reverse resolution record
    at 8.203.27.191.IN-ADDR.ARPA, pointing to the domain name [www.xyzindustries.com](http://www.xyzindustries.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there will also be the following entry for it within the IN-ADDR.ARPA
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Remember that DNS names are case-insensitive, so* IN-ADDR.ARPA *could also
    be given* as in-addr.arpa.'
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, reverse name resolution can be easily performed by doing
    a name resolution on 8.203.27.191.in-addr.arpa. If we do this, a server for the
    IN-ADDR.ARPA domain will return to us the name [www.xyzindustries.com](http://www.xyzindustries.com).
    This is shown in [Figure 56-4](ch56s05.html#the_dns_in-addrarpa_reverse_name_resolut
    "Figure 56-4. The DNS IN-ADDR.ARPA reverse name resolution hierarchy The special
    IN-ADDR.ARPA hierarchy was created to allow easy reverse lookups of DNS names.
    IN-ADDR.ARPA contains 256 subdomains numbered 0 to 255, each of which has 256
    subdomains numbered 0 to 255, and so forth, down to four levels. Thus, each IP
    address is represented in the hierarchy. This example shows the DNS domain name
    www.xyzindustries.com. It would have a conventional RR pointing to its IP address,
    191.27.203.8, as well as a reverse resolution record at 8.203.27.191.IN-ADDR.ARPA,
    pointing to the domain name www.xyzindustries.com.").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Most name resolutions require that we transform a DNS domain
    name into an IP address. However, there are cases where we want to perform a *reverse
    name resolution*, by starting with an IP address and finding out what domain name
    matches it. This is difficult to do using the conventional DNS distributed name
    hierarchy, because there is no easy way to find the DNS server containing the
    entries for a particular IP address. To this end, a special hierarchy called *IN-ADDR.ARPA*
    was set up for reverse name lookups. This hierarchy contains four levels of numerical
    subdomains structured so that each IP address has its own node. The node for an
    IP address contains an entry that points to the DNS domain name associated with
    that address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure you''ve noticed that the numbers are backward in the IN-ADDR.ARPA
    domain. We''ve already seen the reason for this: Name resolution proceeds from
    the least specific to the most specific element, going from right to left. In
    contrast, IP addresses have the least specific octet on the left and the most
    specific on the right. Thus, we reverse them to maintain consistency with the
    DNS name space.'
  prefs: []
  type: TYPE_NORMAL
- en: This immediately yields one extra benefit. Just as we can delegate authority
    for portions of the regular name space, for example, letting XYZ Industries be
    in charge of everything in [xyzindustries.com](http://xyzindustries.com), we can
    also delegate authority for parts of the IN-ADDR.ARPA name space. For example,
    since the Massachusetts Institute of Technology (MIT) owns all IP addresses with
    a first octet of 18 (at least, I think it still does), it is possible that if
    MIT wanted to, it could control the 18.IN-ADDR.ARPA domain as well for reverse
    queries. This would not be possible without reversing the octets.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this system to work reliably, it is essential that the data in
    the regular name space and the reverse name space remain consistent. Whenever
    a new DNS name is registered, an appropriate entry must be made within IN-ADDR.ARPA
    as well. Special procedures have been put into place to allow these pointer entries
    to be created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *A similar scheme using a different reverse domain
    is used for DNS under version 6 of the Internet Protocol (IPv6). See the end of
    [Chapter 57](ch57.html "Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD,
    AND MASTER FILE FORMATS") for more information*.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Electronic Mail Support and Mail Exchange (MX) Resource Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most savvy users of the Internet know that DNS exists, and they usually associate
    it with the most common Internet applications. Of these applications, the "Big
    Kahuna" is the World Wide Web. It's probably the case that the majority of DNS
    name resolution requests are spawned as a result of web server domain names being
    typed into browsers billions of times a day, as well as requests for named pages
    generated by both user mouse clicks and web-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, DNS is not tied specifically to any one application. We can specify
    names in any place where an IP address would go. For example, you can use a DNS
    name instead of an address for an FTP client, or even for a troubleshooting utility
    like traceroute or ping (see [Chapter 88](ch88.html "Chapter 88. TCP/IP ADMINISTRATION
    AND TROUBLESHOOTING UTILITIES AND PROTOCOLS")). The resolver will, in each case,
    take care of translating the name for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one application that has always used DNS, but it''s one that doesn''t
    usually spring to mind when you think about DNS: electronic mail (discussed in
    [Part III-7](pt18.html "Part III-7. TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND
    PROTOCOLS")). Electronic mail (email) is, in fact, more reliant on DNS than just
    about any other TCP/IP application. Consider that while you may sometimes type
    an IP address for a command like traceroute, or even type it into a browser, you
    probably have never sent anyone mail by entering [joe@14.194.29.60](mailto:joe@14.194.29.60)
    into your email client. You type something like [joe@xyzindustries.com](mailto:joe@xyzindustries.com),
    and DNS takes care of figuring out where email for XYZ Industries is to go.'
  prefs: []
  type: TYPE_NORMAL
- en: Special Requirements for Email Name Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Name resolution for email addresses is different from other applications in
    DNS, for three reasons (which I describe in more detail in the discussion of TCP/IP
    email addressing and address resolution in [Chapter 75](ch75.html "Chapter 75. TCP/IP
    ELECTRONIC MAIL ADDRESSES AND ADDRESSING")):'
  prefs: []
  type: TYPE_NORMAL
- en: We may not want email to go to the exact machine specified by the address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to change server names without changing everyone's email
    address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to support multiple servers for handling mail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, XYZ Industries might want to use a dedicated mail server called
    [mail.xyzindustries.com](http://mail.xyzindustries.com) to handle incoming mail,
    but actually construct all of its email addresses to use [@xyzindustries.com](mailto:@xyzindustries.com).
    This makes addresses shorter and allows the server's name to be changed without
    affecting user addresses. If the company wishes, it might decide to use two servers,
    [mail1.xyzindustries.com](http://mail1.xyzindustries.com) and [mail2.xyzindustries.com](http://mail2.xyzindustries.com),
    for redundancy, and again have just [@xyzindustries.com](mailto:@xyzindustries.com)
    for addresses.
  prefs: []
  type: TYPE_NORMAL
- en: To allow the flexibility needed for these situations, a special DNS RR type,
    called a *Mail Exchange (MX)* record, is defined.
  prefs: []
  type: TYPE_NORMAL
- en: The Mail Exchange (MX) Record and Its Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each MX record specifies a particular mail server that is to be used to handle
    incoming email for a particular domain. Once this record is established, resolution
    of email messages is pretty much similar to regular resolution. Suppose you want
    to send a message to [joe@xyzindustries.com](mailto:joe@xyzindustries.com). The
    basic process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Your email client invokes the resolver on your local machine to perform an email
    resolution on [xyzindustries.com](http://xyzindustries.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your local resolver and local DNS server follow the process described earlier
    in this chapter to find the authoritative server for [xyzindustries.com](http://xyzindustries.com),
    which is [ns1.xyzindustries.com](http://ns1.xyzindustries.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ns1.xyzindustries.com](http://ns1.xyzindustries.com) finds the MX record for
    [xyzindustries.com](http://xyzindustries.com) and replies back indicating that
    [mail.xyzindustries.com](http://mail.xyzindustries.com) should be used for email.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The email client can't actually send anything to [mail.xyzindustries.com](http://mail.xyzindustries.com);
    it needs its IP address. So, it would then need to resolve that name. This resolution
    request will likely end up right back at the same DNS name server that just handled
    the MX request. To eliminate the inefficiency of two separate resolutions, the
    DNS name server can combine the information. In our example, [ns1.xyzindustries.com](http://ns1.xyzindustries.com)
    will include the A (Address) RR for [mail.xyzindustries.com](http://mail.xyzindustries.com)
    in the Additional section of the DNS message that it sends in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*RFC 1035 originally defined several other RR types related to email as well:
    Mailbox (MB), Mail Group (MG), and Mail Rename (MR). These are called "experimental"
    in the standard. I think the experiment failed, whatever it was, because I don''t
    believe these are used today. There are also two even older mail-related RRs,
    Mail Destination (MD) and Mail Forwarder (MF), which must have been used at one
    time but were already obsolete at the time RFC 1035 itself was written*.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to specify multiple MX records for a particular domain,
    each pointing to a different mail server's name. This provides redundancy, so
    if there is a problem with one mail server, another can pick up the slack. DNS
    allows each mail server to be specified with a *preference* value, so you can
    clearly indicate which is the main mail server, which is the first backup, the
    second backup, and so on. The DNS server will choose the mail server with the
    lowest preference value first, then the next highest one, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Since email is sent using host names and not IP addresses,
    DNS contains special provisions to support the transfer of email between sites.
    Special *Mail Exchange (MX)* DNS RRs are set up that contain the names of mail
    servers that a domain wants to use for handling incoming email. Before sending
    email to a site, a device performs a name resolution to get that site''s MX record,
    so it knows where to send the message.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 57. DNS MESSAGING AND MESSAGE, RESOURCE RECORD, AND MASTER FILE FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Networking is all about the communication of information between connected devices.
    In the case of the Domain Name System (DNS), information about names and objects
    on the internetwork is exchanged during each of the many types of operations DNS
    performs. This involves sending *messages* between devices. Like most protocols,
    DNS uses its own set of messages with distinct field formats, and it follows a
    particular set of rules for generating them and transporting them over the internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I explain how messages are generated and sent in DNS, and I
    describe the formats used for messages and resource records (RRs). I begin with
    an overview discussion of DNS messages and how they are generated and transported.
    I provide an overview of the general DNS message format and the five sections
    it contains. I describe the notation used for names and the special compression
    method that helps keep DNS messages down in size. I then show the fields in the
    DNS message Header and Question section. I illustrate the common field format
    used for all RRs and the specific fields in the most important record types. I
    also provide a description of the format used for DNS text master files.
  prefs: []
  type: TYPE_NORMAL
- en: I conclude with a brief discussion of the changes made to DNS to support Internet
    Protocol version 6 (IPv6). Most of these changes (but not all of them) are associated
    with message formats and RRs, the subject of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *This chapter assumes that you are already familiar
    with DNS concepts and operation as described in Chapters [Chapter 52](ch52.html
    "Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS, AND CHARACTERISTICS")
    through [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER
    OPERATIONS")*.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Message Generation and Transport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding chapters in this part of the book, we have explored the many
    different tasks that servers and resolvers perform: regular name resolution, reverse
    name resolution, email resolution, zone transfers, and more. Each of these operations
    requires that information be exchanged between a pair of DNS devices. Like so
    many other TCP/IP protocols, DNS is designed to accomplish this information transfer
    using a *client/server* model. All DNS exchanges begin with a client sending a
    request and a server responding with an answer.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Client/Server Messaging Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE")''s
    overview of TCP/IP''s client/server nature, I explained a potential source of
    confusion regarding these terms: the fact that they refer to hardware roles, software
    roles, and transactional roles. This issue definitely applies when it comes to
    DNS. You''ve already seen that DNS implementation consists of two sets of software
    elements: resolvers that act as clients and name servers that are the servers.
    Resolver software usually runs on client machines like PCs, while name server
    software often runs on dedicated server hardware. However, these designations
    are based on the overall role of the hardware and software.'
  prefs: []
  type: TYPE_NORMAL
- en: From a messaging viewpoint, the client is the initiator of the communication,
    regardless of what type of machine does this initiating, and the server is the
    device that responds to the client. A resolver usually acts as a client and a
    name server as a server. However, in a particular exchange, a DNS name server
    can act as a client, in at least two cases. First, in recursive name resolution,
    a server generates requests to others servers and therefore acts as a client.
    Second, in administrative functions like zone transfers, one server acts as a
    client and sends a request to another server. (There are no cases in DNS that
    I know of where a resolver acts as a server, incidentally.)
  prefs: []
  type: TYPE_NORMAL
- en: Most transactions in DNS consist of the exchange of a single query message and
    a single response message. The device acting as client for the transaction creates
    the query and sends it to the server; the server then sends back a reply. In certain
    cases where a great deal of data needs to be sent, such as zone transfers, the
    server may send back multiple messages. Multiple such transactions may be required
    to perform a complete name resolution, as the example of the DNS resolution process
    in the previous chapter demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Message Transport Using UDP and TCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP/IP has two different transport layer protocols: the User Datagram Protocol
    (UDP) and Transmission Control Protocol (TCP) (see [Part II-8](pt11.html "Part II-8. TCP/IP
    TRANSPORT LAYER PROTOCOLS")). UDP and TCP share layer 4 in the TCP/IP model, because
    they are so different in terms of capabilities and operation. Some application
    layer protocols need the services of TCP and can use it to take advantage of them,
    while others are better off with the simpler UDP. DNS is itself a perfect example
    of the valid reasons for having both UDP and TCP in the protocol suite (see [Chapter 42](ch42.html
    "Chapter 42. OVERVIEW AND COMPARISON OF TCP AND UDP")), because it uses both.'
  prefs: []
  type: TYPE_NORMAL
- en: UDP is a simple connectionless protocol that provides no real features but is
    very fast. It is ideally suited for small, quick exchanges of information and
    can be faster than TCP because there is no need to establish a connection. This
    makes it a good choice for most of the conventional queries used in DNS, because
    they are normally very short, and fast data exchange is important. For this reason,
    the DNS standards recommend use of UDP for queries and replies as part of regular
    and reverse name resolution. UDP DNS messages are limited to 512 bytes; longer
    messages are truncated, and a special bit in the header is set to indicate that
    this has occurred. If a message being truncated causes a problem for its recipient,
    the query must be repeated using TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The 512-byte limit on DNS UDP messages can be surpassed if the optional Extension
    Mechanisms for DNS (EDNS0) are implemented. These are described in RFC 2671*.'
  prefs: []
  type: TYPE_NORMAL
- en: Since UDP does not provide reliable delivery of messages, DNS clients must keep
    track of requests they have sent. If no response is received after a particular
    amount of time, the request must be retransmitted. The need to take care of these
    details is considered an acceptable trade-off for the lower setup costs involved
    with UDP, such as not requiring a connection. The rate at which retransmissions
    are sent is usually set at a minimum of two to five seconds to prevent excessive
    DNS traffic on the internetwork.
  prefs: []
  type: TYPE_NORMAL
- en: For certain special DNS transactions, UDP is simply inappropriate. The most
    common example of such a transaction is a zone transfer. While the query for a
    zone transfer is small in size, the amount of data sent in response can be quite
    large. The limit of 512 bytes for UDP is not even close to enough. Furthermore,
    we really do need to make sure that a zone transfer is accomplished reliably and
    with flow control and other data transfer management features, or we risk having
    corrupted zone information in our secondary DNS server databases.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to use TCP for these types of exchanges. TCP allows messages
    to be of arbitrary length, and as a connection-oriented, acknowledged, reliable
    protocol, automatically provides the mechanisms we need to ensure that zone transfers
    and other lengthy operations complete successfully. The cost is the small amount
    of overhead needed to establish the connection, but since zone transfers are infrequent
    (compared to the sheer volume of regular name resolutions), this is not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how DNS nicely illustrates the roles of both TCP and UDP in TCP/IP.
    Since both transport protocols can be used, name servers listen for UDP and TCP
    requests on the same well-known port number, 53\. The device acting as the client
    uses an ephemeral port number for the transaction. All DNS messages are sent unicast
    from one device directly to another.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** DNS uses both UDP and TCP to send messages. Conventional message
    exchanges are short, and thus well suited to the use of the very fast UDP; DNS
    itself handles the detection and retransmission of lost requests. For larger or
    more important exchanges of information, especially zone transfers, TCP is used—both
    for its reliability and its ability to handle messages of any size.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Message Processing and General Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've just discussed, DNS message exchanges are all based on the principle
    of client/server computing. In a particular exchange, one device acts as a client,
    initiating the communication by sending a query; the other acts as the server
    by responding to the query with an answer. This query/response behavior is an
    integral part of DNS, and it is reflected in the format used for DNS messages.
  prefs: []
  type: TYPE_NORMAL
- en: A common message format is used for DNS queries and responses. This message
    format contains five sections that provide a place for the query asked by the
    client, the answer(s) provided by the server, and header information that controls
    the entire process. [Table 57-1](ch57.html#dns_general_message_format-id001 "Table 57-1. DNS
    General Message Format") describes the DNS general message format, providing a
    brief summary of each of its sections and how they are used. You can also see
    a simplified illustration of the message format in [Figure 57-1](ch57.html#dns_general_message_format-id002
    "Figure 57-1. DNS general message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-1. DNS General Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Section Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Header | Contains fields that describe the type of message and provide important
    information about it. Also contains fields that indicate the number of entries
    in the other sections of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| Question | Carries one or more questions—that is, queries for information
    being sent to a DNS name server. |'
  prefs: []
  type: TYPE_TB
- en: '| Answer | Carries one or more RRs that answer the question(s) indicated in
    the Question section. |'
  prefs: []
  type: TYPE_TB
- en: '| Authority | Contains one or more RRs that point to authoritative name servers
    that can be used to continue the resolution process. |'
  prefs: []
  type: TYPE_TB
- en: '| Additional | Conveys one or more RRs that contain additional information
    related to the query that is not strictly necessary to answer the queries (questions)
    in the message. |'
  prefs: []
  type: TYPE_TB
- en: The Header section is always present in all messages and is fixed in length.
    In addition to containing important DNS control information, it has a flag (QR)
    that indicates whether a message is a query or a response. It also has four "count"
    fields that tell the recipient the number of entries in the other four sections.
  prefs: []
  type: TYPE_NORMAL
- en: When a client initiates a query, it creates a message with the fields in the
    Header section filled in, and one or more queries (requests for information) in
    the Question section. It sets the QR flag to 0 to indicate that this is a query,
    and it places a number in the QDCount field of the header that indicates the number
    of questions in the Question section. The number of entries in the other sections
    are usually 0, so their count fields (ANCount, NSCount, and ARCount) are set to
    0 in the header. (Although more than one question can be put into a query, usually
    only one is included.)
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS general message format](httpatomoreillycomsourcenostarchimages288179.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 57-1. DNS general message format
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives the query, it processes it and performs the information
    retrieval operation requested (if it can). It then uses the query as the basis
    for its response message. The Header and Question sections are copied to the response
    message, and the QR flag is set to 1 to indicate that the message is a reply.
    Certain fields are also changed in the Header section to provide information back
    to the client. For example, the server sets the RCode (Response Code) field to
    indicate whether the query was successful or if an error occurred, and if one
    did occur, to indicate what the problem was. The next section of this chapter
    illustrates all the Header fields and indicates how each is used by both client
    and server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is also responsible for filling in the other three sections of the
    message: Answer, Authority, and Additional. These sections share the same basic
    format, each carrying one or more RRs that use a common record format. The number
    of records in each section is indicated using the count fields in the message
    header. The sections differ only in terms of the types of records they carry.
    Answer records are directly related to the question asked, while Authority records
    carry RRs that identify other name servers. Authority records are thus the means
    by which name servers are hierarchically linked when the server doesn''t have
    the information the client requested.'
  prefs: []
  type: TYPE_NORMAL
- en: The Additional section exists for the specific purpose of improving DNS efficiency.
    There are cases where a server supplies an answer to a query that it has reason
    to believe will lead to a subsequent question that the server can also answer.
    For example, suppose a server provides the name of another name server in the
    Authority section (an NS RR). The client may not have the address for that server,
    which would mean it must perform an extra name resolution to contact the referenced
    server. If the server providing the NS record already knows the IP address for
    this name server, it can include it in the Additional section. The same goes for
    a server providing an MX record as I explained in the discussion of DNS mail support
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** DNS uses a general message format for all messages. It consists
    of a fixed 12-byte header, a Question section that contains a query, and then
    three additional sections that can carry RRs of different types. The Answer section
    usually contains records that directly answer the question of the message; the
    Authority section holds the names of name servers being sent back to the client;
    and the Additional section holds extra information that may be of value to the
    client, such as the IP address of a name server mentioned in the Authority section.'
  prefs: []
  type: TYPE_NORMAL
- en: Another optimization by DNS is a special compression technique used to reduce
    the size of DNS messages. This is explained in the "DNS Name Notation and Message
    Compression" section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the special Notify and Update messages use a different format than
    the regular DNS query/response messages. These special messages (whose use is
    described in the section about DNS server enhancements in [Chapter 55](ch55.html
    "Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION")) are based on the regular
    format but with the meanings of certain fields changed. You can find these field
    formats in RFC 1996 and RFC 2136, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client/server information exchange in DNS is facilitated using query/response
    messaging. Both queries and responses have the same general format, containing
    up to five individual sections carrying information. Of these, two are usually
    found in both queries and responses: the Header section and the Question section.
    We will look at these two sections first, and then examine the RR formats used
    by servers for the other three message sections.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Message Header Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The header is the most important part of any message, since it is where critical
    control fields are carried. In DNS messages, the Header section carries several
    key control flags, and it also indicates which of the other sections are used
    in the message. Examining the Header section can help you understand several of
    the nuances of how messaging works in DNS.
  prefs: []
  type: TYPE_NORMAL
- en: The format of the Header section used in all DNS messages is illustrated in
    [Figure 57-2](ch57s02.html#dns_message_header_format-id002 "Figure 57-2. DNS message
    header format") and described in detail in Tables [Table 57-2](ch57s02.html#dns_message_header_format-id001
    "Table 57-2. DNS Message Header Format"), [Table 57-3](ch57s02.html#header_opcode_values
    "Table 57-3. Header OpCode Values"), and [Table 57-4](ch57s02.html#header_rcode_values
    "Table 57-4. Header RCode Values"). Where fields are used differently by the client
    and server in an exchange, I have mentioned in [Table 57-2](ch57s02.html#dns_message_header_format-id001
    "Table 57-2. DNS Message Header Format") how the use is differentiated between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the current lists of valid question types, query operation codes,
    and response codes are maintained by the Internet Assigned Numbers Authority (IANA)
    as one of its many lists of Internet parameters. Response codes 0 to 5 are part
    of regular DNS and are defined in RFC 1035; codes 6 to 10 implement Dynamic DNS
    and are defined in RFC 2136.
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-2. DNS Message Header Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ID | 2 | Identifier: A 16-bit identification field generated by the device
    that creates the DNS query. It is copied by the server into the response, so it
    can be used by that device to match that query to the corresponding reply received
    from a DNS server. This is used in a manner similar to how the Identifier field
    is used in many of the Internet Control Message Protocol (ICMP) message types.
    |'
  prefs: []
  type: TYPE_TB
- en: '| QR | 1/8 (1 bit) | Query/Response Flag: Differentiates between queries and
    responses. Set to 0 when the query is generated; changed to 1 when that query
    is changed to a response by a replying server. |'
  prefs: []
  type: TYPE_TB
- en: '| OpCode | 1/2 (4 bits) | Operation Code: Specifies the type of query the message
    is carrying. This field is set by the creator of the query and copied unchanged
    into the response. See [Table 57-3](ch57s02.html#header_opcode_values "Table 57-3. Header
    OpCode Values") for the OpCode values. |'
  prefs: []
  type: TYPE_TB
- en: '| AA | 1/8 (1 bit) | Authoritative Answer Flag: This bit is set to 1 in a response
    to indicate that the server that created the response is authoritative for the
    zone in which the domain name specified in the Question section is located. If
    it is 0, the response is non-authoritative. |'
  prefs: []
  type: TYPE_TB
- en: '| TC | 1/8 (1 bit) | Truncation Flag: When set to 1, indicates that the message
    was truncated due to its length being longer than the maximum permitted for the
    type of transport mechanism used. TCP doesn''t have a length limit for messages;
    UDP messages are limited to 512 bytes, so this bit being sent usually is an indication
    that the message was sent using UDP and was too long to fit. The client may need
    to establish a TCP session to get the full message. On the other hand, if the
    portion truncated was part of the Additional section, it may choose not to bother.
    |'
  prefs: []
  type: TYPE_TB
- en: '| RD | 1/8 (1 bit) | Recursion Desired: When set in a query, requests that
    the server receiving the query attempt to answer the query recursively, if the
    server supports recursive resolution. The value of this bit is not changed in
    the response. |'
  prefs: []
  type: TYPE_TB
- en: '| RA | 1/8 (1 bit) | Recursion Available: Set to 1 or cleared to 0 in a response
    to indicate whether the server creating the response supports recursive queries.
    This can then be noted by the device that sent the query for future use. |'
  prefs: []
  type: TYPE_TB
- en: '| Z | 3/8 (3 bits) | Zero: Three reserved bits set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| RCode | 1/2 (4 bits) | Response Code: Set to 0 in queries, then changed by
    the replying server in a response to convey the results of processing the query.
    This field is used to indicate if the query was answered successfully or if some
    sort of error occurred. See [Table 57-4](ch57s02.html#header_rcode_values "Table 57-4. Header
    RCode Values") for the RCode values. |'
  prefs: []
  type: TYPE_TB
- en: '| QDCount | 2 | Question Count: Specifies the number of questions in the Question
    section of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| ANCount | 2 | Answer Record Count: Specifies the number of RRs in the Answer
    section of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| ARCount | 2 | Additional Record Count: Specifies the number of RRs in the
    Additional section of the message. |'
  prefs: []
  type: TYPE_TB
- en: Table 57-3. Header OpCode Values
  prefs: []
  type: TYPE_NORMAL
- en: '| OpCode Value | Query Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Query | A standard query. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | IQuery | An inverse query; now obsolete. RFC 1035 defines the inverse
    query as an optional method for performing inverse DNS lookups; that is, finding
    a name from an IP address. Due to implementation difficulties, the method was
    never widely deployed, however, in favor of reverse mapping using the IN-ADDR.ARPA
    domain. Use of this OpCode value was formally obsoleted in RFC 3425, November
    2002. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Status | A server status request. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Reserved | Reserved, not used. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Notify | A special message type added by RFC 1996\. It is used by a primary
    (master, authoritative) server to tell secondary servers that data for a zone
    has changed and prompt them to request a zone transfer. See the discussion of
    DNS server enhancements in [Chapter 55](ch55.html "Chapter 55. DNS NAME SERVER
    CONCEPTS AND OPERATION") for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Update | A special message type added by RFC 2136 to implement Dynamic
    DNS. It allows RRs to be added, deleted, or updated selectively. See the discussion
    of DNS server enhancements in [Chapter 55](ch55.html "Chapter 55. DNS NAME SERVER
    CONCEPTS AND OPERATION") for more details. |'
  prefs: []
  type: TYPE_TB
- en: Table 57-4. Header RCode Values
  prefs: []
  type: TYPE_NORMAL
- en: '| RCode Value | Response Code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | No Error | No error occurred. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Format Error | The server was unable to respond to the query due to a
    problem with how it was constructed. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Server Failure | The server was unable to respond to the query due to
    a problem with the server itself. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Name Error | The name specified in the query does not exist in the domain.
    This code can be used by an authoritative server for a zone (since it knows all
    the objects and subdomains in a domain) or by a caching server that implements
    negative caching. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Not Implemented | The type of query received is not supported by the
    server. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Refused | The server refused to process the query, generally for policy
    reasons and not technical ones. For example, certain types of operations, such
    as zone transfers, are restricted. The server will honor a zone transfer request
    only from certain devices. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | YX Domain | A name exists when it should not. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | YX RR Set | An RR set exists that should not. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | NX RR Set | An RR set that should exist does not. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Not Auth | The server receiving the query is not authoritative for the
    zone specified. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Not Zone | A name specified in the message is not within the zone specified
    in the message. |'
  prefs: []
  type: TYPE_TB
- en: '![DNS message header format](httpatomoreillycomsourcenostarchimages288181.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 57-2. DNS message header format
  prefs: []
  type: TYPE_NORMAL
- en: DNS Question Section Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS queries always contain at least one entry in the Question section that specifies
    what the client in the exchange is trying to find out. These entries are copied
    to the response message unchanged, for reference on the part of the client if
    needed. The format used for each entry in the Question section of a DNS message
    described in detail in Tables [Table 57-5](ch57s03.html#dns_message_question_section_format
    "Table 57-5. DNS Message Question Section Format") and [Table 57-6](ch57s03.html#question_section_qtype_values
    "Table 57-6. Question Section QType Values"), and illustrated in [Figure 57-3](ch57s03.html#dns_message_question_section_forma-id001
    "Figure 57-3. DNS message Question section format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-5. DNS Message Question Section Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| QName | Variable | Question Name: Contains the object, domain, or zone name
    that is the subject of the query, encoded using standard DNS name notation, which
    is explained later in this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| QType | 2 | Question Type: Specifies the type of question being asked by
    the device acting as a client. This field may contain a code number corresponding
    to a particular type of RR being requested. ([Table 55-1](ch55s02.html#summary_of_common_dns_resource_records
    "Table 55-1. Summary of Common DNS Resource Records") in [Chapter 55](ch55.html
    "Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION") contains the numbers for
    the most common RRs.) If so, this means the client is asking for that type of
    record to be sent for the domain name listed in QName. The QType field may also
    contain one of the codes listed in [Table 57-6](ch57s03.html#question_section_qtype_values
    "Table 57-6. Question Section QType Values"), corresponding to a special type
    of requests. |'
  prefs: []
  type: TYPE_TB
- en: '| QClass | 2 | Question Class: Specifies the class of the RR being requested,
    normally the value 1 for Internet (IN). See the discussion of classes and RR types
    in [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS")
    for an explanation. In addition, the QClass value 255 is defined to have the special
    meaning "any class." |'
  prefs: []
  type: TYPE_TB
- en: Table 57-6. Question Section QType Values
  prefs: []
  type: TYPE_NORMAL
- en: '| QType Value | Question Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 251 | IXFR | A request for an incremental (partial) zone transfer, per RFC
    1995 |'
  prefs: []
  type: TYPE_TB
- en: '| 252 | AXFR | A request for a zone transfer |'
  prefs: []
  type: TYPE_TB
- en: '| 253 | MAILB | A request for mailbox-related records (RR types MB, MG, or
    MR; now obsolete) |'
  prefs: []
  type: TYPE_TB
- en: '| 254 | MAILA | A request for mail agent RR (now obsolete; MX records are used
    instead) |'
  prefs: []
  type: TYPE_TB
- en: '| 255 | * (asterisk) | A request for all records |'
  prefs: []
  type: TYPE_TB
- en: '![DNS message Question section format](httpatomoreillycomsourcenostarchimages288183.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 57-3. DNS message Question section format
  prefs: []
  type: TYPE_NORMAL
- en: DNS Message Resource Record Field Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've learned in this and the previous chapter, the exchange of information
    in DNS consists of a series of client/server transactions. Clients send requests,
    or *queries*, to servers, and the servers send back *responses*. DNS servers are
    database servers, and they store DNS name database information in the form of
    RRs. The questions asked by clients are requests for information from a DNS server's
    database, and they are answered by the DNS server looking up the requested RRs
    and putting them into the DNS response message.
  prefs: []
  type: TYPE_NORMAL
- en: The Answer, Authority, and Additional sections of the overall DNS message format
    are the places where servers put DNS RRs to be sent back to a client. Each section
    consists of zero or more records, and in theory, any record can be placed in any
    section. The sections differ only in the semantics (meaning) that the client draws
    from a record being in one section rather than in another section.
  prefs: []
  type: TYPE_NORMAL
- en: 'RRs have two representations: binary and text. The text format is used for
    master files edited by humans and is discussed in the "DNS Master File Format"
    section later in this chapter. The binary representation consists of regular numeric
    and text fields, just like the other fields in the DNS message format.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Common RR Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are certain types of information that are common to all RRs and other
    types that are unique to each type of record. To handle this, all RRs are represented
    using a common field format, which contains a single RData field that varies by
    record type. The common RR format is described in [Table 57-7](ch57s04.html#dns_common_resource_record_format
    "Table 57-7. DNS Common Resource Record Format") and illustrated in [Figure 57-4](ch57s04.html#dns_common_rr_format-id001
    "Figure 57-4. DNS common RR format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-7. DNS Common Resource Record Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Variable | Name: Contains the object, domain, or zone name that is
    the subject of the RR, encoded using standard DNS name notation, which is explained
    later in this chapter. All of the information in the RR is associated with this
    object, which I call the named object for the record. |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 2 | Type: A code value specifying the type of resource record. The
    type values for the most common kinds of RRs are shown in [Table 55-1](ch55s02.html#summary_of_common_dns_resource_records
    "Table 55-1. Summary of Common DNS Resource Records"), in [Chapter 55](ch55.html
    "Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION") and also in the following
    sections of this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| Class | 2 | Class: Specifies the class of the RR being requested, normally
    the value 1 for Internet (IN). See [Chapter 55](ch55.html "Chapter 55. DNS NAME
    SERVER CONCEPTS AND OPERATION") for an explanation. |'
  prefs: []
  type: TYPE_TB
- en: '| TTL | 4 | Time to Live: Specifies the number of seconds that the record should
    be retained in the cache of the device reading the record. See the discussion
    of DNS name server caching in [Chapter 55](ch55.html "Chapter 55. DNS NAME SERVER
    CONCEPTS AND OPERATION") for a full explanation. A value of 0 means to use this
    information for the current name resolution only; do not cache it. |'
  prefs: []
  type: TYPE_TB
- en: '| RDLength | 2 | Resource Data Length: Indicates the size of the RData field,
    in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| RData | Variable | Resource Data: The data portion of the RR. |'
  prefs: []
  type: TYPE_TB
- en: RData Field Formats for Common RRs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RData field consists of one or more subfields that carry the actual payload
    for the RR. The following sections present the most common RR types. For each,
    I have indicated the RR text code, name, and type value; provided a brief summary
    of the RR's use; and shown the structure of the RData field in a table.
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS common RR format](httpatomoreillycomsourcenostarchimages288185.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 57-4. DNS common RR format
  prefs: []
  type: TYPE_NORMAL
- en: A (Address) RR (Type Value 1)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A (Address) is the primary RR type in DNS. It contains a 32-bit IP address associated
    with a domain name, as shown in [Table 57-8](ch57s04.html#dns_address_rr_data_format
    "Table 57-8. DNS Address RR Data Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-8. DNS Address RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Address | 4 | Address: The 32-bit IP address corresponding to this record''s
    named object. |'
  prefs: []
  type: TYPE_TB
- en: NS (Name Server) RR (Type Value 2)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NSDName data field carries the domain name of a name server, as shown in
    [Table 57-9](ch57s04.html#dns_name_server_rr_data_format "Table 57-9. DNS Name
    Server RR Data Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-9. DNS Name Server RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NSDName | Variable | Name Server Domain Name: A variable-length name of a
    name server that should be authoritative for this record''s named object. Like
    all names, this name is encoded using standard DNS name notation. A request for
    this RR type normally results in an A record for the name server specified also
    being returned in the Additional section of the response, if available. |'
  prefs: []
  type: TYPE_TB
- en: CName (Canonical Name) RR (Type Value 5)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CName data field contains the real name of a named object that has been
    referenced using an alias, as shown in [Table 57-10](ch57s04.html#dns_canonical_name_rr_data_format
    "Table 57-10. DNS Canonical Name RR Data Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-10. DNS Canonical Name RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CName | Variable | Canonical Name: The canonical (real) name of the named
    object. This name is then resolved using the standard DNS resolution procedure
    to get the address for the originally specified name. |'
  prefs: []
  type: TYPE_TB
- en: SOA (Start Of Authority) RR (Type Value 6)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SOA record marks the start of a DNS zone and contains key information about
    how it is to be managed and used. The SOA record is the most complex of the DNS
    RR types. Its format is explained in [Table 57-11](ch57s04.html#dns_start_of_authority_rr_data_format
    "Table 57-11. DNS Start Of Authority RR Data Format") and illustrated in [Figure 57-5](ch57s04.html#dns_start_of_authority_soa_rr_data_forma
    "Figure 57-5. DNS Start Of Authority (SOA) RR Data Format"). See the discussion
    of zone transfers in [Chapter 55](ch55.html "Chapter 55. DNS NAME SERVER CONCEPTS
    AND OPERATION") for information about how the fields in this RR are used.
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-11. DNS Start Of Authority RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MName | Variable | Master Name: The domain name of the name server that is
    the source of the data for the zone. This is normally the primary authoritative
    server for the zone. It is encoded using the standard DNS name format. |'
  prefs: []
  type: TYPE_TB
- en: '| RName | Variable | Responsible Name: The email address of the person responsible
    for this zone. Email addresses in DNS are encoded using a special variation of
    the regular DNS name notation, discussed later in this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| Serial | 4 | Serial Number: The serial number, or version number, of the
    RR database for this zone. Used to determine when changes have been made to the
    database to trigger zone transfers. |'
  prefs: []
  type: TYPE_TB
- en: '| Refresh | 4 | Refresh Interval: The number of seconds that secondary name
    servers for this zone will wait between attempts to check for changes made to
    the zone database on the primary name server. |'
  prefs: []
  type: TYPE_TB
- en: '| Retry | 4 | Retry Interval: The number of seconds a secondary name server
    waits before trying again to check with a primary for changes if its previous
    attempt failed. |'
  prefs: []
  type: TYPE_TB
- en: '| Expire | 4 | Expire Interval: The number of seconds that can elapse between
    successful contacts with the primary name server before a secondary name server
    must consider the information it holds stale. |'
  prefs: []
  type: TYPE_TB
- en: '| Minimum | 4 | Negative Caching TTL: Originally carried the default TTL value
    for records where no explicit TTL value was specified. Now represents the zone''s
    negative cache TTL. See the discussion of DNS name server caching in [Chapter 55](ch55.html
    "Chapter 55. DNS NAME SERVER CONCEPTS AND OPERATION"). |'
  prefs: []
  type: TYPE_TB
- en: PTR (Pointer) RR (Type Value 12)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PTR record carries a pointer to an RR. It's used for reverse address lookups.
    It contains one data field, shown in [Table 57-12](ch57s04.html#dns_pointer_rr_data_format
    "Table 57-12. DNS Pointer RR Data Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-12. DNS Pointer RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PTRDName | Variable | Pointer Domain Name: A variable-length domain name.
    This is a name pointed to by the RR. See the description of reverse resolution
    in [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS AND RESOLVER OPERATIONS")
    for the most common way that this record type is used. |'
  prefs: []
  type: TYPE_TB
- en: '![DNS Start Of Authority (SOA) RR Data Format](httpatomoreillycomsourcenostarchimages288187.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 57-5. DNS Start Of Authority (SOA) RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: MX (Mail Exchange) RR (Type Value 15)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The special MX record contains information about the mail server(s) to be used
    for sending email to the domain (see [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION
    CONCEPTS AND RESOLVER OPERATIONS")). Each record contains two fields, as shown
    in [Table 57-13](ch57s04.html#dns_mail_exchange_rr_data_format "Table 57-13. DNS
    Mail Exchange RR Data Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-13. DNS Mail Exchange RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Preference | 2 | Preference Value: The preference level for this mail exchange.
    Lower values signify higher preference. |'
  prefs: []
  type: TYPE_TB
- en: '| Exchange | Variable | Exchange Domain Name: The domain name, encoded using
    standard DNS name notation, of a host willing to provide mail exchange services
    for this named object. |'
  prefs: []
  type: TYPE_TB
- en: TXT (Text) RR (Type Value 16)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The TXT record contains additional descriptive information about the named object,
    as shown in [Table 57-14](ch57s04.html#dns_text_rr_data_format "Table 57-14. DNS
    Text RR Data Format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 57-14. DNS Text RR Data Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| TXT-Data | Variable | Text Data: Variable-length descriptive text. |'
  prefs: []
  type: TYPE_TB
- en: DNS Name Notation and Message Compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, the entire DNS protocol is oriented around dealing with names for
    domains, subdomains, and objects. As you've seen in the preceding topics, there
    are many fields in DNS messages and RRs that carry the names of objects, name
    servers, and so forth. DNS uses a special notation for encoding names in RRs and
    fields, a variation of this notation for email addresses, and a special compression
    method that reduces the size of messages for efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Standard DNS Name Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 53](ch53.html "Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY"),
    you learned how DNS names are constructed. Each node in the name hierarchy has
    a label associated with it. The fully qualified domain name (FQDN) for a particular
    device consists of the sequence of labels that starts from the root of the tree
    and progresses down to that device. The labels at each level in the hierarchy
    are listed in sequence, starting with the highest level, from right to left, separated
    by dots. This results in the domain names we are used to working with, such as
    [www.xyzindustries.com](http://www.xyzindustries.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be possible to encode these names into RRs or other DNS message fields
    directly: Put the letter *w* into each of the first three bytes of the name, then
    put a dot (.) into the fourth byte, an *x* into the fifth byte, and so on. The
    disadvantage of this is that as a computer was reading the name, it wouldn''t
    be able to tell when each name was finished. We would need to include a length
    field for each name.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, DNS uses a special notation for DNS names. Each label is encoded, one
    after the next, in the name field. Before each label, a single byte is used that
    holds a binary number indicating the number of characters in the label. Then the
    label's characters are encoded, one per byte. The end of the name is indicated
    by a null label, representing the root; this has a length of zero, so each name
    ends with just a 0 character, indicating this zero-length root label.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the dots between the labels aren't necessary, since the length numbers
    delineate the labels. The computer reading the name also knows how many bytes
    are in each label as it reads the name, so it can easily allocate space for the
    label as it reads it from the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, [www.xyzindustries.com](http://www.xyzindustries.com) would be
    encoded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I have shown the label lengths in square brackets to distinguish them. Remember
    that these label lengths are binary encoded numbers, so a single byte can hold
    a value from 0 to 255; that [13] is one byte, not two, as you can see in [Figure 57-6](ch57s05.html#dns_standard_name_notation_in_dns_every_
    "Figure 57-6. DNS standard name notation In DNS, every named object or other name
    is represented by a sequence of label lengths and then labels, with each label
    length taking one byte and each label taking one byte per character. This example
    shows the encoding of the name www.xyzindustries.com."). Labels are actually limited
    to a maximum of 63 characters, and you'll see shortly why this is significant.
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS standard name notation In DNS, every named object or other name is represented
    by a sequence of label lengths and then labels, with each label length taking
    one byte and each label taking one byte per character. This example shows the
    encoding of the name www.xyzindustries.com.](httpatomoreillycomsourcenostarchimages288189.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 57-6. DNS standard name notation In DNS, every named object or other
    name is represented by a sequence of label lengths and then labels, with each
    label length taking one byte and each label taking one byte per character. This
    example shows the encoding of the name [www.xyzindustries.com](http://www.xyzindustries.com).
  prefs: []
  type: TYPE_NORMAL
- en: DNS Electronic Mail Address Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Email addresses are used in certain DNS resource records, such as the RName
    field in the SOA RR. Email addresses take the form <*name*>@<*domain-name*>. DNS
    encodes these in exactly the same way as regular DNS domains, simply treating
    the @ like another dot. So, [johnny@somewhere.org](mailto:johnny@somewhere.org)
    would be treated as johnny.somewhere.org and encoded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no specific indication that this is an email address. The
    name is interpreted as an email address instead of a device name based on context.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Message Compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A single DNS message may contain many domain names. Now, consider that when
    a particular name server sends a response containing multiple domain names, they
    are all usually in the same zone or are related to the zone. Most of these names
    will have common elements to their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider our previous mail example of a client asking for an MX record for
    [xyzindustries.com](http://xyzindustries.com). The response to this client will
    contain, among other things, these two records:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MX Record** An MX record that has [xyzindustries.com](http://xyzindustries.com)
    in the Name field of the record and [mail.xyzindustries.com](http://mail.xyzindustries.com)
    in the RData field.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Record** Assuming the name server knows the IP address of [mail.xyzindustries.com](http://mail.xyzindustries.com),
    the Additional section will contain an A record that has [mail.xyzindustries.com](http://mail.xyzindustries.com)
    in the Name field and its address in the RData field.'
  prefs: []
  type: TYPE_NORMAL
- en: This is just one small example of name duplication. It can be much more extreme
    with other types of DNS messages, with certain string patterns being repeated
    many times. Normally, this would require that each name be spelled out fully using
    the encoding method described here. But this would be wasteful, since a large
    portion of these names is common. To cut down on this duplication, a special technique
    called *message compression* is used.
  prefs: []
  type: TYPE_NORMAL
- en: Using Message Compression to Avoid Duplication of a Full Name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using message compression, instead of a DNS name encoded using the combination
    of labels and label lengths, a two-byte subfield represents a *pointer* to another
    location in the message where the name can be found. The first two bits of this
    subfield are set to 1 (the value 11 in binary), and the remaining 14 bits contain
    an *offset* that specifies where in the message the name can be found, counting
    the first byte of the message (the first byte of the ID field) as 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our example. Suppose that in the DNS message, the RData field
    of the MX record, containing [mail.xyzindustries.com](http://mail.xyzindustries.com),
    begins at byte 47\. In this first instance, we would find the name encoded in
    full as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, in the second instance, where [mail.xyzindustries.com](http://mail.xyzindustries.com)
    shows up in the Name field of the A record, we would instead put two 1 bits, followed
    by the number 47 encoded in binary. So, this would be the 16-bit binary pattern
    11000000 00101111, or two numeric byte values 192 and 47\. This second instance
    now takes 2 bytes instead of duplicating the 24 bytes needed for the first instance
    of the name.
  prefs: []
  type: TYPE_NORMAL
- en: How does a device reading a Name field differentiate a pointer from a real name?
    This is the reason that 11 is used at the start of the field. Doing this guarantees
    that the first byte of the pointer will always have a value of 192 or larger.
    Since labels are restricted to a length of 63 or less, when the host reads the
    first byte of a name, if it sees a value of 63 or less in a byte, it knows this
    is a real name; a value of 192 or more means it is a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Using Message Compression to Avoid Duplication of Part of a Name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous example shows how pointers can be used to eliminate duplication
    of a whole name: The name [mail.xyzindustries.com](http://mail.xyzindustries.com)
    was used in two places, and a pointer was used instead of the second. Pointers
    are even more powerful than this, however. They can also be used to point to only
    part of a real name or can be combined with additional labels to provide a compressed
    representation of a name related to another name in a RR. This provides even greater
    space savings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, this means that even the first instance of [mail.xyzindustries.com](http://mail.xyzindustries.com)
    can be compressed. Recall that the MX record will have [xyzindustries.com](http://xyzindustries.com)
    in the Name field and [mail.xyzindustries.com](http://mail.xyzindustries.com)
    in the RData field. If the Name field of that record starts at byte 19, then we
    can encode the RData field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The device reading the record will get "mail" for the first label and then read
    "[xyzindustries.com](http://xyzindustries.com)" from the Name field to get the
    complete name, [mail.xyzindustries.com](http://mail.xyzindustries.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, suppose we had a record in this same message that contained a reference
    to the parent domain for [xyzindustries.com](http://xyzindustries.com), which
    is "com." This could simply be encoded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that byte 33 is where we find the `[3] c o m [0]` part of the
    Name field containing `[13] x y z i n d u s t r i e s [3] c o m [0]`.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Master File Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS servers answer queries from clients by sending reply messages containing
    RRs. You have already seen in this chapter the binary message formats used to
    encode these RRs. These message formats are great for transmitted messages, because
    they are compact and efficient. Computers have no problem reading fields very
    quickly and knowing how to interpret a particular string of ones and zeros.
  prefs: []
  type: TYPE_NORMAL
- en: Humans, on the other hand, don't deal well with cryptic codes in binary. Before
    an RR can be provided by a server, it is necessary for a human administrator to
    tell the server what those records are and what information they contain. To make
    this job easier, DNS includes a special text representation for zones and RRs.
    Administrators edit special *master files* that describe the zone and the records
    it contains. These files are then read into memory by the server's DNS software
    and converted into binary form for responding to client requests. This is described
    in more detail in [Chapter 56](ch56.html "Chapter 56. DNS RESOLUTION CONCEPTS
    AND RESOLVER OPERATIONS").
  prefs: []
  type: TYPE_NORMAL
- en: Each master file consists of a simple, flat text file that can be created with
    any sort of text editor. Each file contains a number of lines expressed using
    a simple set of syntax rules that describe a zone and the records within it. The
    basic syntactic rules for DNS master files are specified in RFC 1035, Section
    5.1\. Certain DNS implementations use their own variations on the syntax in the
    standard, though they are all pretty similar.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Common Master File Record Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as all RRs are stored internally using a common field format, they also
    use a common master file format. Each record normally appears on a separate line
    of the file. This format is as follows, with optional fields shown in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '``<*`domain-name`*>`` A DNS domain name, which may be either an FQDN or a partially
    qualified name (PQDN).'
  prefs: []
  type: TYPE_NORMAL
- en: '``<*`ttl`*>`` A TTL value, in seconds, for the record. If omitted, the default
    TTL value for the zone is used. In fact, most RRs do not have a specified TTL
    and just use the default provided by the SOA record.'
  prefs: []
  type: TYPE_NORMAL
- en: '``<*`class`*>`` The RR class. For modern DNS, this field is optional, and it
    defaults to IN, for Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: '``<*`type`*>`` The RR type, specified using a text code such as A or NS, not
    the numeric code.'
  prefs: []
  type: TYPE_NORMAL
- en: '``<*`rdata`*>`` RR data, which is a set of space-separated entries that depends
    on the record type.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<`*`rdata`*`>` can be either a single piece of information or a set of
    entries, depending on the record type. In the case of longer record types, especially
    the SOA record, multiple entry `<`*`rdata`*`>` fields are spread over several
    lines and enclosed in parentheses; the parentheses make all the entries act as
    if they were on a single line. Note that if the `<`*`ttl`*`>` field is present,
    the order of it and the `<`*`class`*`>` field may be switched without any problems,
    because one is a number and the other text (IN).
  prefs: []
  type: TYPE_NORMAL
- en: Use and Interpretation of Partially Qualified Domain Names (PQDNs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Domain names may be mixed between FQDNs and PQDNs (described in [Chapter 53](ch53.html
    "Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY")). PQDNs are used
    to make master files faster to create and more readable, by cutting down on the
    common parts of names. They are sort of the human equivalent of DNS message compression.
    An FQDN is shown as a full domain name ending in a dot (.) to represent the DNS
    name tree root. A PQDN is given as just a partial name with no root, and is interpreted
    as an FQDN by the software reading the master file. (See the description of the
    `$ORIGIN` directive in the next section for more information.)
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember the trailing dot to mark FQDNs. If the origin is
    [xyzindustries.com](http://xyzindustries.com) and in its zone file the name bigisp.net
    appears, the server will read this as [bigisp.net.xyzindustries.com](http://bigisp.net.xyzindustries.com)—probably
    not what you want. Also, email addresses, such as the `<`*`r-name`*`>` field in
    the SOA record, have the @ of the email address converted to a dot, following
    the standard DNS convention.
  prefs: []
  type: TYPE_NORMAL
- en: Master File Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to RRs, most master file implementations also support the use of
    *directives*. These are commands that specify certain important pieces of information
    to guide how the master file is to be interpreted. The following are three of
    the most common directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ORIGIN` Specifies the domain name that is appended to unqualified specifications.
    This is the base used to convert PQDNs to FQDNs. For example, if the origin is
    [xyzindustries.com](http://xyzindustries.com)., then a PQDN such as "sales" will
    be interpreted as [sales.xyzindustries.com](http://sales.xyzindustries.com). Once
    defined, the origin can be referenced by just using @ in place of a name, as you
    will see in the example of a sample master file shown at the end of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$TTL` Specifies the default TTL value to be used for any RRs that do not specify
    a TTL value in the record itself. (This value was formerly specified by the Minimum
    field in the SOA record.)'
  prefs: []
  type: TYPE_NORMAL
- en: '`$INCLUDE` Allows one master file to include the contents of another. This
    is sometimes used to save the duplication of certain entries that are common between
    zones.'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax Rules for Master Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few other syntax rules for DNS master files, some of which are
    intended to save time or energy on the part of administrators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple-Record Shorthand** If multiple consecutive records pertain to the
    same domain, the `<`*`domain-name`*`>` is specified for the first one and can
    be then be left blank for the subsequent ones. The server will assume that any
    RRs without a `<`*`domain-name`*`>` indicated apply to the last `<`*`domain-name`*`>`
    it saw.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments** A semicolon (;) marks a comment. Any text from the semicolon until
    the end of the line is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Escape Character** A backslash (\) is used to "escape" the special meaning
    of a character. For example, a double-quotation (quote) mark (") is used to delimit
    text strings; a literal double-quote character is indicated by a backslash–double-quote
    combination (\").'
  prefs: []
  type: TYPE_NORMAL
- en: '**White Space** Tabs and spaces are used as delimiters and blank lines are
    ignored. For readability, most smart administrators indent using tabs to clarify
    which records belong with which names, and group records using blank lines and
    comments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case** Like DNS domain names, master file entries are case-insensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: Specific RR Syntax and Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following sections show the specific formats and examples for each of the
    common RR types. The fields are basically the same as the ones explained in the
    NS binary record formats. The examples include explanatory comments using the
    DNS comment format. Assume that these examples are for the zone googleplex.edu.
  prefs: []
  type: TYPE_NORMAL
- en: A (Address) RR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format for an A record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: NS (Name Server) RR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format for an NS record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: CName (Canonical Name) RR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format for a CName record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: SOA (Start Of Authority) RR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format for an SOA record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: PTR (Pointer) RR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format for a PTR record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the PTR record would actually be in the IN-ADDR.ARPA domain.
  prefs: []
  type: TYPE_NORMAL
- en: MX (Mail Exchange) RR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format of an MX record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: TXT (Text) RR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format of a TXT record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sample Master File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is a real-world example of a DNS master file, taken from my own
    [pcguide.com](http://pcguide.com) server (slightly modified), hosted by (and DNS
    information provided by) the fine folks at [pair.com](http://pair.com). Note the
    use of @ as a shortcut to mean "this domain" ([pcguide.com](http://pcguide.com)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: DNS Changes to Support IPv6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version 4 of the Internet Protocol (IPv4) is the basis of today's Internet and
    the foundation upon which the TCP/IP protocol suite is built. While IPv4 has served
    us well for over two decades, it has certain important drawbacks that would limit
    internetworks of the future if it were to continue to be used. For this reason,
    the next generation of IP, IP version 6 (IPv6), has been in development for many
    years. IPv6 will eventually replace IPv4 and take TCP/IP into the future.
  prefs: []
  type: TYPE_NORMAL
- en: The change from IPv4 to IPv6 will have effects that ripple to other TCP/IP protocols,
    including DNS. DNS is a higher-level protocol, so you might think that based on
    the principle of layering, a change to IP should not affect it. However, this
    is another example of how strict layering doesn't always apply. DNS works directly
    with IP addresses, and one of the most significant modifications that IPv6 makes
    to IP is in the area of addressing, so this means that using DNS on IPv6 requires
    some changes to how the protocol works.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 DNS Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In fact, because DNS is so architecturally distant from IP down there at layer
    3, the changes required are not extensive. RFC 1886, "IPv6 DNS Extensions," published
    in December 1995, was the Internet Engineering Task Force''s (IETF''s) first formalized
    attempt to describe the changes needed in DNS to support IPv6\. It defines three
    specific modifications to DNS for IPv6:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New RR Type—AAAA (IPv6 Address)** The regular DNS Address (A) RR is defined
    for a 32-bit IPv4 address, so a new one was created to allow a domain name to
    be associated with a 128-bit IPv6 address. The four *A*s (AAAA) are a mnemonic
    to indicate that the IPv6 address is four times the size of the IPv4 address.
    The AAAA record is structured in very much the same way as the A record in both
    binary and master file formats; it is just much larger. The DNS RR Type value
    for AAAA is 28.'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Reverse Resolution Hierarchy** A new hierarchical structure similar to
    IN-ADDR.ARPA is defined for IPv6 reverse lookups, but the IETF put it in a different
    top-level domain (TLD). The new domain is *IP6.INT* and is used in a way similar
    to how IN-ADDR.ARPA works. However, since IPv6 addresses are expressed in hexadecimal
    instead of dotted-decimal, IP6.INT has 16 subdomains 0 through F, and each of
    those has 16 subdomains 0 through F, and so on, 16 layers deep. Yes, this leads
    to a potentially frightfully large reverse resolution database!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changes to Query Types and Resolution Procedure** All query types that work
    with A records or result in A records being included in the Additional section
    of a reply must be changed to also handle AAAA records. Also, queries that would
    normally result in A records being returned in the Additional section must return
    the corresponding AAAA records only in the Answer section, not in the Additional
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Even though DNS resides far above IP in the TCP/IP protocol
    suite architecture, it works intimately with IP addresses. For this reason, changes
    are required to allow it to support the new IPv6\. These changes include the definition
    of a new IPv6 address RR (AAAA), a new reverse resolution domain hierarchy, and
    certain changes to how messaging is performed.'
  prefs: []
  type: TYPE_NORMAL
- en: Proposed Changes to the IPv6 DNS Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2000, the IETF published RFC 2874, "DNS Extensions to Support IPv6 Address
    Aggregation and Renumbering." This standard proposed a replacement for the IPv6
    support introduced in RFC 1886, using a new record type, A6, instead of RFC 1886's
    AAAA. The main difference between AAAA and A6 records is that the former are just
    whole addresses like A records, while A6 records can contain either a whole or
    partial address.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind RFC 2874 was that A6 records could be set up in a manner that
    complements the IPv6 format for unicast addresses (see [Chapter 25](ch25.html
    "Chapter 25. IPV6 ADDRESSING")). Then name resolution would involve a technique
    called *chaining* to determine a full address for a name from a set of partially
    specified address components. In essence, this would make the addresses behave
    much the way hierarchical names themselves work, providing some potential flexibility
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: For a couple of years, both RFC 1886 and RFC 2874 were proposed standards, and
    this led to considerable confusion. In August 2002, RFCs 3363 and 3364 were published,
    which clarified the situation with these two proposals. RFC 3363 represents the
    "Supreme Court decision," which was that RFC 2874 and the A6 record be changed
    to experimental status and the AAAA record of RFC 1886 be kept as the DNS IPv6
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: The full explanation for the decision can be found in RFC 3364\. In a nutshell,
    it boiled down to the IETF believing that there were significant potential risks
    in the successful implementation of RFC 2874\. While the capabilities of the A6
    record were interesting, it was not clear that they were needed, and given those
    risks, the IETF felt that sticking with RFC 1886 was the better move.
  prefs: []
  type: TYPE_NORMAL
