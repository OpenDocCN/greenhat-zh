<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;YAML"><div class="titlepage"><div><div><h1 class="title"><a id="yaml"/>Chapter 14. YAML</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id17"/><div class="mediaobject"><a id="I_mediaobject14_d1e16742"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>At some point, most desktop applications are going to want to save and read structured data to and from disk. You’ve already seen how to read and write data using simple IO routines such as <code class="literal">gets</code> and <code class="literal">puts</code>. But how would you go about saving and restoring data from, say, lists of mixed object types? One simple way of doing this with Ruby is by using YAML.<a id="IDX-CHP-14-0001" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>YAML is an acronym that is (debatably) either short for Yet Another Markup Language or (recursively) for YAML Ain’t Markup Language.</p></div><div class="sect1" title="Converting to YAML"><div class="titlepage"><div><div><h1 class="title"><a id="converting_to_yaml"/>Converting to YAML</h1></div></div></div><p>YAML defines a serialization (data-saving) format that stores information as human-readable text. YAML can be used with a variety of programming languages; in order to use it in Ruby, your code needs access to routines from Ruby’s <span class="emphasis"><em>yaml.rb</em></span> file. Generally, this would be done by loading or “requiring” the file at the top of a code unit like this:<a id="IDX-CHP-14-0002" class="indexterm"/></p><a id="I_programlisting14_d1e16774"/><pre class="programlisting">require "yaml"</pre><p>Having done this, you will have access to a variety of methods to convert Ruby objects to the YAML format so that they can write their data to a file. Subsequently, you will be able to read back this saved data and use it to reconstruct Ruby objects. To convert an object to YAML format, you can use the <code class="literal">to_yaml</code> method. This will convert standard object types such as strings, integers, arrays, hashes, and so on. For example, this is how you would convert a string:<a id="IDX-CHP-14-0003" class="indexterm"/><a id="IDX-CHP-14-0004" class="indexterm"/></p><p><span class="emphasis"><em>to_yaml1.rb</em></span></p><a id="I_programlisting14_d1e16792"/><pre class="programlisting">"hello world".to_yaml</pre><p>And this is how you would convert an array:</p><a id="I_programlisting14_d1e16796"/><pre class="programlisting">["a1", "a2" ].to_yaml</pre><p>This is the YAML format that you would obtain as a result of this array conversion:</p><a id="I_programlisting14_d1e16800"/><pre class="programlisting">---
- a1
- a2</pre><p>Notice the three dashes that define the start of a new YAML “document” and the single dash that defines each new element in a list. In YAML terms, a document is not a separate file on disk but a separate YAML definition; one disk file may contain many YAML documents. For more information on the YAML format, refer to <a class="xref" href="ch14s07.html#digging_deeper-id13" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch14s07.html#digging_deeper-id13" title="Digging Deeper">Digging Deeper</a>.<a id="IDX-CHP-14-0005" class="indexterm"/></p><p>You can also convert objects of nonstandard types to YAML. For example, let’s suppose you create this class and object:</p><p><span class="emphasis"><em>to_yaml2.rb</em></span></p><a id="I_programlisting14_d1e16819"/><pre class="programlisting">class MyClass
    def initialize( anInt, aString )
        @myint = anInt
        @mystring =aString
    end
end

ob1 = MyClass.new( 100, "hello world" ).to_yaml</pre><p>The YAML representation of this object will be preceded by the text <code class="literal">!ruby/object:</code> followed by the class name, the names of variables with a colon appended (but minus the <code class="literal">@</code>), and their values, one per line:<a id="IDX-CHP-14-0006" class="indexterm"/><a id="IDX-CHP-14-0007" class="indexterm"/><a id="IDX-CHP-14-0008" class="indexterm"/></p><a id="I_programlisting14_d1e16842"/><pre class="programlisting">--- !ruby/object:MyClass
myint: 100
mystring: hello world</pre><p>If you want to print out the YAML representation of an object, you can use the method <code class="literal">y()</code>, which is a sort of YAML equivalent of the familiar <code class="literal">p()</code> method used to inspect and print normal Ruby objects:</p><p><span class="emphasis"><em>yaml_test1.rb</em></span></p><a id="I_programlisting14_d1e16855"/><pre class="programlisting">y( ['Bert', 'Fred', 'Mary'] )</pre><p>This displays the following:</p><a id="I_programlisting14_d1e16859"/><pre class="programlisting">---
- Bert
- Fred
- Mary</pre><p>You could similarly display a hash:</p><a id="I_programlisting14_d1e16864"/><pre class="programlisting">y({ 'fruit' =&gt; 'banana', :vegetable =&gt; 'cabbage', 'number' =&gt; 3 })</pre><p>in which case each key-value pair is placed onto a new line:</p><a id="I_programlisting14_d1e16868"/><pre class="programlisting">---
fruit: banana
:vegetable: cabbage
number: 3</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The ordering of hash elements may differ according to which version of Ruby you are using (see <a class="xref" href="ch04.html" title="Chapter 4. Arrays and Hashes">Chapter 4</a>). It is best to assume no intrinsic order when working with a hash.</p></div><p>Or you could display your own “custom” objects:</p><a id="I_programlisting14_d1e16877"/><pre class="programlisting">t = Treasure.new( 'magic lamp', 500 )
y( t )</pre><p>This displays data formatted, as in the earlier example where I used <code class="literal">to_yaml</code>, with the class name at the top and with pairs of variable names and values on successive lines. This is the YAML representation of a Treasure object containing the instance variables <code class="literal">@name</code> and <code class="literal">@value</code>:</p><a id="I_programlisting14_d1e16890"/><pre class="programlisting">--- !ruby/object:Treasure
name: magic lamp
value: 500</pre><p>You can even use <code class="literal">y()</code> to display quite complex objects such as nested arrays:<a id="IDX-CHP-14-0009" class="indexterm"/></p><p><span class="emphasis"><em>yaml_test2.rb</em></span></p><a id="I_programlisting14_d1e16905"/><pre class="programlisting">arr1 =    [    ["The Groovesters", "Groovy Tunes", 12 ],
               [  "Dolly Parton", "Greatest Hits", 38 ]
          ]
y( arr1 )</pre><p>This is the YAML representation of <code class="literal">arr1</code>:</p><a id="I_programlisting14_d1e16913"/><pre class="programlisting">---
- - The Groovesters
  - Groovy Tunes
  - 12
- - Dolly Parton
  - Greatest Hits
  - 38</pre><p>Here is another example of an array containing objects of user-defined types:</p><a id="I_programlisting14_d1e16917"/><pre class="programlisting">class CD
    def initialize( anArtist, aName, theNumTracks )
        @artist = anArtist
        @name   = aName
        @numtracks    = theNumTracks
    end
end

arr2 = [CD.new("The Beasts", "Beastly Tunes", 22),
       CD.new("The Strolling Bones","Songs For Senior Citizens",38)
]

y( arr2 )</pre><p>This outputs the following YAML:</p><a id="I_programlisting14_d1e16921"/><pre class="programlisting">---
- !ruby/object:CD
  artist: The Beasts
  name: Beastly Tunes
  numtracks: 22
- !ruby/object:CD
  artist: The Strolling Bones
  name: Songs For Senior Citizens
  numtracks: 38</pre></div></div>
<div class="sect1" title="Nested Sequences"><div class="titlepage"><div><div><h1 class="title"><a id="nested_sequences"/>Nested Sequences</h1></div></div></div><p>When related sequences of data (such as arrays) are nested inside other sequences of data, this relationship is indicated by indentation. So, for example, let’s suppose you have this array declared in Ruby:<a id="IDX-CHP-14-0010" class="indexterm"/><a id="IDX-CHP-14-0011" class="indexterm"/><a id="IDX-CHP-14-0012" class="indexterm"/><a id="IDX-CHP-14-0013" class="indexterm"/><a id="IDX-CHP-14-0014" class="indexterm"/><a id="IDX-CHP-14-0015" class="indexterm"/></p><p><span class="emphasis"><em>nested_arrays.rb</em></span></p><a id="I_programlisting14_d1e16961"/><pre class="programlisting">arr = [1,[2,3,[4,5,6,[7,8,9,10],"end3"],"end2"],"end1"]</pre><p>When rendered as YAML (for example, by <code class="literal">y( arr )</code>), this becomes as follows:</p><a id="I_programlisting14_d1e16968"/><pre class="programlisting">---
- 1
- - 2
  - 3
  - - 4
    - 5
    - 6
    - - 7
      - 8
      - 9
      - 10
    - end3
  - end2
- end1</pre></div>
<div class="sect1" title="Saving YAML Data"><div class="titlepage"><div><div><h1 class="title"><a id="saving_yaml_data"/>Saving YAML Data</h1></div></div></div><p>Another handy way of turning your Ruby objects into YAML format is provided by the <code class="literal">dump</code> method. At its simplest, this converts your Ruby data into YAML format and “dumps” it into a string:</p><p><span class="emphasis"><em>yaml_dump1.rb</em></span></p><a id="I_programlisting14_d1e16981"/><pre class="programlisting">arr = ["fred", "bert", "mary"]
yaml_arr = YAML.dump( arr )
    # yaml_arr is now: "--- \n- fred\n- bert\n- mary\n"</pre><p>More usefully, the <code class="literal">dump</code> method can take a second argument, which is some kind of IO object, typically a file. You can open a file and dump data to it:</p><p><span class="emphasis"><em>yaml_dump2.rb</em></span></p><a id="I_programlisting14_d1e16991"/><pre class="programlisting">f = File.open( 'friends.yml', 'w' )
YAML.dump( ["fred", "bert", "mary"], f )
f.close</pre><p>Or you can open the file (or some other type of IO object) and pass this into an associated block:</p><a id="I_programlisting14_d1e16995"/><pre class="programlisting">File.open( 'morefriends.yml', 'w' ){ |friendsfile|
    YAML.dump( ["sally", "agnes", "john" ], friendsfile )
}</pre><p>In each case, the YAML representation of the data from the array will be saved, as plaintext, into the specified file. For example, when the previous code executes, it writes this text into the <span class="emphasis"><em>morefriends.yml</em></span> file:<a id="IDX-CHP-14-0016" class="indexterm"/></p><p><span class="emphasis"><em>morefriends.yml</em></span></p><a id="I_programlisting14_d1e17011"/><pre class="programlisting">---
- sally
- agnes
- john</pre><p>If you use a block, the file will be closed automatically on exiting the block; otherwise, you should explicitly close the file using the <code class="literal">close</code> method. You can also use a block in a similar way to open a file and read in YAML data:</p><a id="I_programlisting14_d1e17018"/><pre class="programlisting">File.open( 'morefriends.yml' ){ |f|
    $arr= YAML.load(f)
}</pre><p>Assuming <span class="emphasis"><em>morefriends.yml</em></span> contains the data saved earlier, once it is loaded and assigned to the global variable <code class="literal">$arr</code> in the block shown earlier, <code class="literal">$arr</code> will contain this array of strings:</p><a id="I_programlisting14_d1e17031"/><pre class="programlisting">["sally", "agnes", "john"]</pre></div>
<div class="sect1" title="Omitting Variables on Saving"><div class="titlepage"><div><div><h1 class="title"><a id="omitting_variables_on_saving"/>Omitting Variables on Saving</h1></div></div></div><p>If, for some reason, you want to omit some instance variables when serializing objects, you can do so by defining a method named <code class="literal">to_yaml_properties</code>. In the body of this method, place an array of strings. Each string should match the name of the instance variable to be saved. Any variables that are not specified will not be saved. Take a look at this example:<a id="IDX-CHP-14-0017" class="indexterm"/></p><p><span class="emphasis"><em>limit_y.rb</em></span></p><a id="I_programlisting14_d1e17049"/><pre class="programlisting">class Yclass
    def initialize(aNum, aStr, anArray)
        @num = aNum
        @str = aStr
        @arr = anArray
    end

    def to_yaml_properties
        ["@num", "@arr"]     #&lt;= @str will not be saved!
    end
end</pre><p>Here <code class="literal">to_yaml_properties</code> limits the variables that will be saved when you call <code class="literal">YAML.dump</code> to <code class="literal">@num</code> and <code class="literal">@arr</code>. The string variable, <code class="literal">@str</code>, will not be saved. If you want to reconstruct the objects based on the saved YAML data, it is your responsibility to ensure that any “missing” variables are either not needed (in which case they may be ignored) or, if they are needed, that they are initialized with some meaningful value.</p><a id="I_programlisting14_d1e17068"/><pre class="programlisting">ob = Yclass.new( 100, "fred", [1,2,3] )
    # ...creates object with @num=100, @str="fred", @arr=[1,2,3]

yaml_ob = YAML.dump( ob )
    #...dumps to YAML only the @num and @arr data (omits @str)

ob2 = YAML.load( yaml_ob )
    #...creates ob2 from dumped data with @num=100, @arr=[1,2,3]
    # but without @str</pre></div>
<div class="sect1" title="Multiple Documents, One File"><div class="titlepage"><div><div><h1 class="title"><a id="multiple_documents_comma_one_file"/>Multiple Documents, One File</h1></div></div></div><p>Earlier, I mentioned that three dashes are used to mark the start of a new YAML section known as a <span class="emphasis"><em>document</em></span>. For example, let’s assume you want to save two arrays, <code class="literal">arr1</code> and <code class="literal">arr2</code>, to a file, <span class="emphasis"><em>multidoc.yml</em></span>. Here <code class="literal">arr1</code> is an array containing two nested arrays, and <code class="literal">arr2</code> is an array containing two CD objects:</p><p><span class="emphasis"><em>multi_docs.rb</em></span></p><a id="I_programlisting14_d1e17097"/><pre class="programlisting">arr1 =  [   ["The Groovesters", "Groovy Tunes", 12 ],
            [  "Dolly Parton", "Greatest Hits", 38 ]
        ]

arr2 =  [ CD.new("Gribbit Mcluskey", "Fab Songs", 22),
          CD.new("Wayne Snodgrass", "Singalong-a-Snodgrass", 24)
        ]</pre><p>This is my routine to dump these arrays to YAML and write them to a file (as explained in <a class="xref" href="ch13.html" title="Chapter 13. Files and IO">Chapter 13</a>, the <code class="literal">'w'</code> argument causes the file to be opened for writing):</p><a id="I_programlisting14_d1e17106"/><pre class="programlisting">File.open( 'multidoc.yml', 'w' ){ |f|
    YAML.dump( arr1, f )
    YAML.dump( arr2, f )
}</pre><p>If you now look at the file <span class="emphasis"><em>multidoc.yml</em></span>, you’ll see that the data has been saved as two separate “documents,” each one beginning with three dashes:<a id="IDX-CHP-14-0018" class="indexterm"/></p><a id="I_programlisting14_d1e17118"/><pre class="programlisting">---
- - The Groovesters
  - Groovy Tunes
  - 12
- - Dolly Parton
  - Greatest Hits
  - 38
---
- !ruby/object:CD
  artist: Gribbit Mcluskey
  name: Fab Songs
  numtracks: 22
- !ruby/object:CD
  artist: Wayne Snodgrass
  name: Singalong-a-Snodgrass
  numtracks: 24</pre><p>Now, I need to find a way of reconstructing these arrays by reading in the data as two documents. This is where the <code class="literal">load_documents</code> method comes to the rescue. The <code class="literal">load_documents</code> method calls a block and passes to it each consecutive document. Here is an example of how to use this method in order to reconstruct two arrays (placed inside another array, <code class="literal">$new_arr</code>) from the two YAML documents:<a id="IDX-CHP-14-0019" class="indexterm"/><a id="IDX-CHP-14-0020" class="indexterm"/><a id="IDX-CHP-14-0021" class="indexterm"/><a id="IDX-CHP-14-0022" class="indexterm"/></p><a id="I_programlisting14_d1e17149"/><pre class="programlisting">File.open( 'multidoc.yml' ) {|f|
    YAML.load_documents( f ) { |doc|
      $new_arr &lt;&lt; doc
    }
 }</pre><p>You can verify that <code class="literal">$new_arr</code> has been initialized with the two arrays by executing the following:</p><a id="I_programlisting14_d1e17157"/><pre class="programlisting">p( $new_arr )</pre><p>This displays an array containing the loaded data in two nested arrays:</p><a id="I_programlisting14_d1e17161"/><pre class="programlisting">[[["The Groovesters", "Groovy Tunes", 12], ["Dolly Parton",
 "Greatest Hits", 38]], [#&lt;CD:0x2c30e98 @artist="Gribbit Mcluskey", @name="Fab
 Songs", @numtracks=22&gt;, #&lt;CD:0x2c30ad8 @artist="Wayne Snodgrass",
 @name="Singalong-a-Snodgrass", @numtracks=24&gt;]]</pre><p>Because this is a bit unmanageable, you might prefer to display each of the nested arrays individually using an index into the outer array:</p><a id="I_programlisting14_d1e17165"/><pre class="programlisting">p( $new_arr[0] )
p( $new_arr[1] )</pre><p>The previous assumes that you know, in advance, the number of nested arrays available. Alternatively, here’s a more generic way of doing the same thing, using the <code class="literal">each</code> method to pass all available items into a block; this works with any number of arrays:</p><a id="I_programlisting14_d1e17172"/><pre class="programlisting">$new_arr.each{ |arr| p( arr ) }</pre></div>
<div class="sect1" title="A YAML Database"><div class="titlepage"><div><div><h1 class="title"><a id="a_yaml_database"/>A YAML Database</h1></div></div></div><p>For an example of a slightly more complicated application that saves and loads data in YAML format, take a look at the <span class="emphasis"><em>cd_db.rb</em></span> sample program. This implements a simple CD database. It defines three types of CD objects: a basic <code class="literal">CD</code> that contains data on the name, artist, and number of tracks; and two more specialized descendants, <code class="literal">PopCD</code>, which adds data on the genre (for example, rock or country), and <code class="literal">ClassicalCD</code>, which adds data on the conductor and composer:</p><p><span class="emphasis"><em>cd_db.rb</em></span></p><a id="I_programlisting14_d1e17194"/><pre class="programlisting">class CD
    def initialize( arr )
        @name       = arr[0]
        @artist     = arr[1]
        @numtracks  = arr[2]
    end

    def getdetails
        return[@name, @artist, @numtracks]
    end
end

class PopCD &lt; CD

    def initialize( arr )
        super( arr  )
        @genre = arr[3]
    end

    def getdetails
        return( super &lt;&lt; @genre )
    end
end

class ClassicalCD &lt; CD
    def initialize( arr )
        super( arr )
        @conductor  = arr[3]
        @composer   = arr[4]
    end

    def getdetails
        return( super &lt;&lt; @conductor &lt;&lt; @composer )
    end
end</pre><p>When the program is run, the user can enter data to create new CD objects of any of these three types. There is also an option to save data to disk. When the application is run subsequently, the existing data is reloaded.</p><p>The data itself is organized very simply (trivially even) in the code, with the data for each object being read into an array before the object itself is created. The whole database of CD objects is saved into the global variable <code class="literal">$cd_arr</code>, and this is written to disk and reloaded into memory using YAML methods:</p><a id="I_programlisting14_d1e17203"/><pre class="programlisting">def saveDB
    File.open( $fn, 'w' ) {
        |f|
        f.write($cd_arr.to_yaml)
    }
end

def loadDB
    input_data = File.read( $fn )
    $cd_arr = YAML::load( input_data )
end</pre><p>Bear in mind that this program has been written for simplicity rather than beauty. In a real-world application, you would, I am sure, want to create somewhat more elegant data structures to manage your Dolly Parton collection!<a id="IDX-CHP-14-0023" class="indexterm"/></p></div>
<div class="sect1" title="Adventures in YAML"><div class="titlepage"><div><div><h1 class="title"><a id="adventures_in_yaml"/>Adventures in YAML</h1></div></div></div><p>As one final example of using YAML, I’ve provided an elementary framework for an adventure game (<span class="emphasis"><em>gamesave_y.rb</em></span>). This creates some Treasure objects and some Room objects. The Treasure objects are put “into” the Room objects (that is, they are placed into arrays contained by the Rooms), and the Room objects are then put into a Map object. This has the effect of constructing a moderately complex data structure in which an object of one type (a Map) contains an arbitrary number of objects of another type (Rooms), each of which may contain zero or more objects of yet other types (Treasures).<a id="IDX-CHP-14-0024" class="indexterm"/></p><p>At first sight, finding a way of storing this entire network of mixed object types to disk and reconstructing that network at a later stage might look like a programming nightmare. In fact, thanks to the serialization capabilities supplied by Ruby’s YAML library, saving and restoring this data could hardly be easier. This is because serialization relieves you of the chore of saving each object one by one. Instead, you have to “dump” only the top-level object; here, that is the Map object, <code class="literal">mymap</code>.</p><p>When this is done, any objects that the top-level object “contains” (such as Rooms) or that the <span class="emphasis"><em>contained</em></span> objects themselves contain (such as Treasures) are automatically saved for you. They can then be reconstructed just by loading all the saved data in a single operation and assigning it to the “top-level” object (here the map):</p><p><span class="emphasis"><em>gamesave_y.rb</em></span></p><a id="I_programlisting14_d1e17238"/><pre class="programlisting"># Save mymap
File.open( 'game.yml', 'w' ){ |f|
    YAML.dump( mymap, f )
}

# Reload mymap
File.open( 'game.yml' ){ |f|
    mymap = YAML.load(f)
}</pre><p>The full code of this program is too long to show here, so I suggest you try the program supplied in the source code archive in order to appreciate how simple it is to save and load a fairly complex data structure with YAML.</p><div class="sidebar"><a id="digging_deeper-id13"/><p class="title">Digging Deeper</p><p>This section summarizes the structure of a YAML datafile and explains how to save nested hashes in YAML format.<a id="IDX-CHP-14-0025" class="indexterm"/><a id="IDX-CHP-14-0026" class="indexterm"/><a id="IDX-CHP-14-0027" class="indexterm"/></p><p><span class="bolditalic">A Brief Guide to YAML</span></p><p>As I mentioned earlier, YAML stores information in the form of chunks of text known as <span class="emphasis"><em>documents</em></span> containing <span class="emphasis"><em>sequences</em></span> of data. Each document begins with three hyphens (<code class="literal">---</code>), and each individual element in a list begins with a single hyphen (<code class="literal">-</code>) character. Here, for example, is a YAML datafile comprising one document and two list items:</p><a id="I_programlisting14_d1e17279"/><pre class="programlisting">---
- artist: The Groovesters
  name: Groovy Tunes
  numtracks: 12
- artist: Dolly Parton
  name: Greatest Hits
  numtracks: 38</pre><p>In the previous example, you can see that each list item consists of two parts: a name such as <code class="literal">artist:</code> (which is the same in each list item) and a piece of data to its right, such as <code class="literal">Dolly Parton</code>, which may vary for each list item. These items are like the key-value pairs in a Ruby hash. YAML refers to key-value lists as <span class="emphasis"><em>maps</em></span>.</p><p>The following is a YAML document containing a list of two items, each of which contains three items; in other words, it is the YAML representation of an array containing two three-item “nested” arrays:<a id="IDX-CHP-14-0028" class="indexterm"/></p><a id="I_programlisting14_d1e17299"/><pre class="programlisting">---
- - The Groovesters
  - Groovy Tunes
  - 12
- - Dolly Parton
  - Greatest Hits
  - 38</pre><p>Now let’s see how YAML would deal with nested hashes. Consider this hash:</p><p><span class="emphasis"><em>hash_to_yaml.rb</em></span></p><a id="I_programlisting14_d1e17306"/><pre class="programlisting">hsh = { :friend1 =&gt; 'mary',
        :friend2 =&gt; 'sally',
        :friend3 =&gt; 'gary',
        :morefriends =&gt; { :chap_i_met_in_a_bar =&gt; 'simon',
                          :girl_next_door =&gt; 'wanda'
                         }
}</pre><p>As you’ve already seen, a hash is quite naturally represented in YAML as a list of key-value pairs. However, in the example shown previously, the <span class="emphasis"><em>key</em></span> <code class="literal">:morefriends</code> is associated with a nested hash as its <span class="emphasis"><em>value</em></span>. How does YAML represent that? It turns out that, as with arrays (see <a class="xref" href="ch14s02.html" title="Nested Sequences">Nested Sequences</a> in <a class="xref" href="ch14s02.html" title="Nested Sequences">Nested Sequences</a>), it simply indents the nested hash:<a id="IDX-CHP-14-0029" class="indexterm"/></p><a id="I_programlisting14_d1e17330"/><pre class="programlisting">:friend1: mary
:friend2: sally
:friend3: gary
:morefriends:
     :chap_i_met_in_a_bar: simon
     :girl_next_door: wanda</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>For in-depth information on YAML, see <a class="ulink" href="http://www.yaml.org/">http://www.yaml.org/</a>.</p></div><p>The YAML libraries supplied with Ruby are quite large and complex, and many more methods are available than have been described in this chapter. However, you should now have enough of an understanding of YAML to use it to good effect in your own programs. You may explore the outer reaches of the YAML libraries at your leisure. It turns out, though, that YAML is not the only way of serializing data in Ruby. You’ll be looking at another way in the next chapter.</p></div></div></body></html>