["```\nirb(main):001:0> double_me = lambda { |x| x * 2 }\n=> #<Proc:0xb7d1f890@(irb):1>\nirb(main):002:0> double_me.call(5)\n=> 10\n```", "```\nirb(main):003:0> triple_me = lambda { |x| x * 3 }\n=> #<Proc:0xb7d105bc@(irb):3>\nirb(main):004:0> triple_me.call(5)\n=> 15\n```", "```\n  #!/usr/bin/env ruby\n  # make_incrementer.rb\n\n❶ def make_incrementer(delta)\n    return lambda { |x| x + delta }    *Procs*\n  end\n\n❷ incrementer_proc_of = Hash.new()\n  [10, 20].each do |delta|\n    incrementer_proc_of[delta] = make_incrementer(delta)\n  end\n\n❸ incrementer_proc_of.each_pair do |delta,incrementer_proc|\n    puts \"#{delta} + 5 = #{incrementer_proc.call(5)}\\n\"    *Calling Procs*\n  end\n\n❹ puts\n\n❺ incrementer_proc_of.each_pair do |delta,incrementer_proc|    *The **`each_pair`** Method*\n❻   (0..5).to_a.each do |other_addend|\n      puts \"#{delta} + #{other_addend} = \" +\n        incrementer_proc.call(other_addend) + \"\\n\"\n    end\n  end\n```", "```\n20 + 5 = 25\n10 + 5 = 15\n\n20 + 0 = 20\n20 + 1 = 21\n20 + 2 = 22\n20 + 3 = 23\n20 + 4 = 24\n20 + 5 = 25\n10 + 0 = 10\n10 + 1 = 11\n10 + 2 = 12\n10 + 3 = 13\n10 + 4 = 14\n10 + 5 = 15\n```", "```\n  #!/usr/bin/env ruby\n  # matching_members.rb\n\n  =begin rdoc\n  Extend the built-in <b>Array</b> class.\n  =end\n  class Array\n\n  =begin rdoc\n  Takes a <b>Proc</b> as an argument, and returns all members\n  matching the criteria defined by that <b>Proc</b>.\n  =end\n❶   def matching_members(some_proc)    *Procs as Arguments*\n      find_all { |i| some_proc.call(i) }\n    end\n\n  end\n\n❷ digits = (0..9).to_a\n  lambdas = Hash.new()\n  lambdas['five+']   = lambda { |i| i >= 5 }\n  lambdas['is_even'] = lambda { |i| (i % 2).zero? }\n\n❸ lambdas.keys.sort.each do |lambda_name|\n❹   lambda_proc  = lambdas[lambda_name]\n❺   lambda_value = digits.matching_members(lambda_proc).join(',')\n❻   puts \"#{lambda_name}\\t[#{lambda_value}]\\n\"\n  end\n```", "```\nfive+   [5,6,7,8,9]\nis_even [0,2,4,6,8]\n```", "```\n  #!/usr/bin/env ruby\n  # matching_compound_members.rb\n\n  =begin rdoc\n  Extend the built-in <b>Array</b> class.\n  =end\n  class Array\n\n  =begin rdoc\n  Takes a block as an argument and returns a list of\n  members matching the criteria defined by that block.\n  =end\n❶   def matching_members(&some_block)    *Block Arguments*\n      find_all(&some_block)\n    end\n\n  =begin rdoc\n  Takes an <b>Array</b> of <b>Proc</b>s as an argument\n  and returns all members matching the criteria defined\n  by each <b>Proc</b> via <b>Array.matching_members</b>.\n  Note that it uses the ampersand to convert from\n  <b>Proc</b> to block.\n  =end\n❷   def matching_compound_members(procs_array)\n      procs_array.map do |some_proc|\n        # collect each proc operation\n❸       matching_members(&some_proc)\n❹     end.inject(self) do |memo,matches|\n        # find all the intersections, starting with self\n        # and whittling down until we only have members\n        # that have matched every proc\n❺       memo & matches    *Array Intersections*\n      end\n❻   end\n\n  end\n\n  # Now use these methods in some operations.\n❼ digits = (0..9).to_a\n  lambdas = Hash.new()\n  lambdas['five+']   = lambda { |i| i if i >= 5 }\n  lambdas['is_even'] = lambda { |i| i if (i % 2).zero? }\n  lambdas['div_by3'] = lambda { |i| i if (i % 3).zero? }\n\n  lambdas.keys.sort.each do |lambda_name|\n    lambda_proc   = lambdas[lambda_name]\n    lambda_values = digits.matching_members(&lambda_proc).join(',')\n❽   puts \"#{lambda_name}\\t[#{lambda_values}]\\n\"\n  end\n\n❾ puts \"ALL\\t[#{digits.matching_compound_members(lambdas.values).join(',')}]\"\n```", "```\nirb(main):001:0> class Array\nirb(main):002:1> def matches_block( &some_block )    *& Notation for Blocks and Procs*\nirb(main):003:2> find_all( &some_block )\nirb(main):004:2> end\nirb(main):005:1> def matches_proc( some_proc )\nirb(main):006:2> find_all( &some_proc )\nirb(main):007:2> end\nirb(main):008:1> end\n=> nil\n```", "```\nirb(main):009:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):010:0> digits.matches_block { |x| x > 5 }\n=> [6, 7, 8, 9]\nirb(main):011:0> digits.matches_proc( lambda { |x| x > 5 } )\n=> [6, 7, 8, 9]\n```", "```\nirb(main):001:0> class Array\nirb(main):002:1> def matches_block( some_block )\nirb(main):003:2> find_all( some_block )\nirb(main):004:2> end\nirb(main):005:1> end\n=> nil\nirb(main):006:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):007:0> digits.matches_block { |x| x > 5 }\nArgumentError: wrong number of arguments (0 for 1)\n        from (irb):7:in `matches_block'\n        from (irb):7\n        from :0\n```", "```\nirb(main):001:1> class Array\nirb(main):002:1> def matching_compound_members( procs_array )\nirb(main):003:2> procs_array.map do |some_proc|\nirb(main):004:3* find_all( &some_proc )\nirb(main):005:3> end\nirb(main):006:2> end\nirb(main):007:1> end\n=> nil\nirb(main):008:0> digits.matching_compound_members( [ lambda { |x| x > 5 },\nlambda { |x| (x % 2).zero? }])\n=> [[6, 7, 8, 9], [0, 2, 4, 6, 8]]\n```", "```\nirb(main):001:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):002:0> evens = digits.find_all { |x| (x % 2).zero? }\n=> [0, 2, 4, 6, 8]\nirb(main):003:0> digits & evens\n=> [0, 2, 4, 6, 8]\nirb(main):004:0> half_digits = digits.find_all { |x| x < 5 }\n=> [0, 1, 2, 3, 4]\nirb(main):005:0> evens & half_digits\n=> [0, 2, 4]\n```", "```\ndiv_by3 [0,3,6,9]\nfive+   [5,6,7,8,9]\nis_even [0,2,4,6,8]\nALL     [6]\n```", "```\n  #!/usr/bin/env ruby\n  # return_proc.rb\n\n❶ def return_proc(criterion, further_criterion=1)\n\n    proc_of_criterion = {    *Procs as Hash Values*\n      'div_by?' => lambda { |i| i if (i % further_criterion).zero? },\n      'is?'     => lambda { |i| i == further_criterion }\n    }\n\n    # allow 'is_even' as an alias for divisible by 2\n❷   return return_proc('div_by?', 2) if criterion == ('is_even')\n\n❸   proc_to_return = proc_of_criterion[criterion]\n    fail \"I don't understand the criterion #{criterion}\" unless proc_to_return\n    return proc_to_return\n\n  end\n\n❹ require 'boolean_golf.rb'\n\n  # Demonstrate calling the proc directly\n❺ even_proc = return_proc('is_even') # could have been ('div_by', 2)\n  div3_proc = return_proc('div_by?', 3)\n  is10_proc = return_proc('is?', 10)\n❻ [4, 5, 6].each do |num|\n    puts %Q[Is #{num} even?: #{even_proc[num].true?}]    *Making Strings with **`%Q`***\n    puts %Q[Is #{num} divisible by 3?: #{div3_proc[num].true?}]\n    puts %Q[Is #{num} 10?: #{is10_proc[num].true?}]\n❼   printf(\"%d is %s.\\n\\n\", num, even_proc[num].true? ? 'even' : 'not even')\n  end\n\n  # Demonstrate using the proc as a block for a method\n❽ digits = (0..9).to_a\n  even_results = digits.find_all(&(return_proc('is_even')))\n  div3_results = digits.find_all(&(return_proc('div_by?', 3)))\n❾ puts %Q[The even digits are #{even_results.inspect}.]    *The **`inspect`** Method*\n  puts %Q[The digits divisible by 3 are #{div3_results.inspect}.]\n  puts\n```", "```\nIs 4 even?: true\nIs 4 divisible by 3?: false\nIs 4 10?: false\n4 is even.\n\nIs 5 even?: false\nIs 5 divisible by 3?: false\nIs 5 10?: false\n5 is not even.\n\nIs 6 even?: true\nIs 6 divisible by 3?: true\nIs 6 10?: false\n6 is even.\n\nThe even digits are [0, 2, 4, 6, 8].\nThe digits divisible by 3 are [0, 3, 6, 9].\n```", "```\nirb(main):001:0> is_ten = lambda { |x| x == 10 }\n=> #<Proc:0xb7d0c8a4@(irb):1>\nirb(main):002:0> is_ten.call(10)\n=> true\nirb(main):003:0> is_ten[10]\n=> true\nirb(main):004:0> is_ten.call(9)\n=> false\nirb(main):005:0> is_ten[9]\n=> false\n```", "```\nirb(main):001:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):002:0> digits.to_s=\n> \"0123456789\"\nirb(main):003:0> digits.inspect\n=> \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\"\n```", "```\nirb(main):001:0> digits = (0..9).to_a\n=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nirb(main):002:0> make_exp_proc = lambda { |exp| lambda { |x| x ** exp } }    *Nested Lambdas*\n=> #<Proc:0xb7c97adc@(irb):2>\nirb(main):003:0> square_proc = make_exp_proc.call(2)\n=> #<Proc:0xb7c97b18@(irb):2>\nirb(main):004:0> square_proc.call(5)\n=> 25\nirb(main):005:0> squares = digits.map { |x| square_proc[x] }\n=> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```", "```\nirb(main):006:0> cube_proc = make_exp_proc.call(3)\n=> #<Proc:0xb7c97b18@(irb):2>\nirb(main):007:0> cube_proc.call(3)\n=> 27\nirb(main):008:0> cubes = digits.map { |x| cube_proc[x] }\n=> [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n```", "```\n  #!/usr/bin/env ruby -w\n  # him.rb\n\n❶ class Him\n\n    EPISODE_NAME = 'Him'\n    BASE         = 'love spell'\n\n    ANTIDOTE_FOR = lambda { |input| \"anti-(#{input}) spell\" }    *Constant Procs*\n\n❷   def Him.describe()    *Class Methods*\n      return <<DONE_WITH_HEREDOC\n\n  In #{EPISODE_NAME},\n    Willow refers to an \"#{ANTIDOTE_FOR[BASE]}\".\n    Anya mentions an \"#{ANTIDOTE_FOR[ANTIDOTE_FOR[BASE]]}\".\n    Xander mentioning an \"#{ANTIDOTE_FOR[ANTIDOTE_FOR[ANTIDOTE_FOR[BASE]]]}\"\n  might have been too much.\n\n  DONE_WITH_HEREDOC\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby -w\n  # same_time_same_place.rb\n\n❸ class SameTimeSamePlace\n\n    EPISODE_NAME = 'Same Time, Same Place'\n\n  =begin rdoc\n  This Hash holds various procedure objects. One is formed by the generally\n  preferred Kernel.lambda method. Others are created with the older Proc.new\n  method, which has the benefit of allowing more flexibility in its argument\n  stack.\n  =end\n❹   QUESTIONS = {\n\n      :ternary => Proc.new do |args|\n        state    = args ? args[0] : 'what'\n        location = args ? args[1] : 'what'\n        \"Spike's #{state} in the #{location}ment?\"\n      end,\n\n      :unless0th => Proc.new do |*args|\n        args = %w/what what/ unless args[0]\n        \"Spike's #{args[0]} in the #{args[1]}ment?\"\n      end,\n\n      :nitems => Proc.new do |*args|    *Flexible Arity with **`Proc.new`***\n        args.nitems >= 2 || args.replace(['what', 'what'])\n        \"Spike's #{args[0]} in the #{args[1]}ment?\"\n      end,\n\n      :second_or => Proc.new do |*args|\n        args[0] || args.replace(['what', 'what'])\n        \"Spike's #{args[0]} in the #{args[1]}ment?\"\n      end,\n\n      :needs_data => lambda do |args|\n        \"Spike's #{args[0]} in the #{args[1]}ment?\"\n      end\n\n    }\n\n❺   DATA_FROM_ANYA = ['insane', 'base']\n\n❻   def SameTimeSamePlace.describe()\n\n      same_as_procs = [\n        SameTimeSamePlace.yield_block(&QUESTIONS[:nitems]),\n        QUESTIONS[:second_or].call(),\n        QUESTIONS[:unless0th].call(),\n        SameTimeSamePlace.willow_ask,\n      ]\n\n           return <<DONE\n  In #{EPISODE_NAME},\n    Willow asks \"#{QUESTIONS[:ternary].call(nil)}\",\n    #{same_as_procs.map do |proc_output|\n      'which is the same as \"' + proc_output + '\"'\n      end.join(\"\\n  \")\n    }\n    Anya provides \"#{DATA_FROM_ANYA.join(', ')}\", which forms the full question\n    \"#{SameTimeSamePlace.yield_block(DATA_FROM_ANYA, &QUESTIONS[:needs_data])}\".\n\n  DONE\n    end\n\n  =begin rdoc\n  Wrapping a lambda call within a function can provide\n  default values for arguments.\n  =end\n❼   def SameTimeSamePlace.willow_ask(args = ['what', 'what'])\n      QUESTIONS[:needs_data][args]\n    end\n  =begin rdoc\n  Passing a block as an argument to a method\n  =end\n❽   def SameTimeSamePlace.yield_block(*args, &block)\n      # yield with any necessary args is the same as calling block.call(*args)\n      yield(*args)    *The **`yield`** Method*\n    end\n\n  end\n```", "```\n  #!/usr/bin/env ruby -w\n  # willow_and_anya.rb\n\n  %w[him same_time_same_place].each do |lib_file|    *Arrays with **`%w`***\n    require \"#{lib_file}\"\n  end\n\n  [Him, SameTimeSamePlace].each do |episode|\n❾   puts episode.describe()\n  end\n```", "```\nirb(main):001:0> is_even_proc1 = lambda { |x| (x % 2).zero? }\n=> #<Proc:0xb7cb687c@(irb):1>\nirb(main):002:0> is_even_proc2 = Proc.new { |x| (x % 2).zero? }\n=> #<Proc:0xb7cacb4c@(irb):2>\nirb(main):003:0> is_even_proc1.call(7)\n=> false\nirb(main):004:0> is_even_proc2.call(7)\n=> false\nirb(main):005:0> is_even_proc1.call(8)\n=> true\nirb(main):006:0> is_even_proc2.call(8)\n=> true\n```", "```\nirb(main):001:0> def yield_block(*args, &block)\nirb(main):002:1> yield(*args)\nirb(main):003:1> end\n=> nil\nirb(main):004:0> yield_block(0) { |x| x + 1 }\n=> 1\nirb(main):005:0> yield_block(\"I am a String\") { |x| x.class }\n=> String\nirb(main):006:0> yield_block(\"How many words?\") { |x| x.split(' ').nitems }\n=> 3\nirb(main):007:0> yield_block(0, 1) { |x,y| x == y }\n=> false\nirb(main):008:0> yield_block(0, 1) { |x,y| x < y }\n=> true\n```", "```\nIn Him,\n  Willow refers to an \"anti-(love spell) spell\".\n  Anya mentions an \"anti-(anti-(love spell) spell) spell\".\n  Xander mentioning an \"anti-(anti-(anti-(love spell) spell) spell) spell\"\n  might have been too much.\n\nIn Same Time, Same Place,\n  Willow asks \"Spike's what in the whatment?\",\n  which is the same as \"Spike's what in the whatment?\"\n  which is the same as \"Spike's what in the whatment?\"\n  which is the same as \"Spike's what in the whatment?\"\n  which is the same as \"Spike's what in the whatment?\"\n  Anya provides \"insane, base\", which forms the full question\n  \"Spike's insane in the basement?\".\n```", "```\ndef Him.describe2(iterations=3)\n  (1..iterations).to_a.inject(BASE) do |memo,output|\n    ANTIDOTE_FOR[memo]\n  end\nend\n```"]