- en: Chapter 3. LI(U)NIX SYSTEM ADMINISTRATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![LI(U)NIX SYSTEM ADMINISTRATION](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'No computing system runs optimally straight out of the box. Whether you need
    to adjust security settings, add users, define permissions, or install applications—there
    is always something left to do. Once the system is configured exactly how you
    want it, the next task is maintaining the system until an upgrade is needed. Then
    the cycle starts all over again. This cycle is known as system administration.
    Administrators well versed in Linux or Unix system administration understand the
    power and flexibility that simple scripts can add to the geek''s toolbox. Forget
    about the mundane tasks: Let the scripts deal with them.'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing Bad Filenames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixing Bad Filenames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: fixFilename.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to naming files, endless possibilities exist. There can be short
    abbreviated filenames, long descriptive filenames, or even random filenames that
    don't make sense. Filenames can be too long for some systems or contain special,
    reserved characters for other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Working in *a graphical user interface*, or *GUI*, environment can lead to bad
    habits, as far as naming conventions go. The GUI environment can deal with almost
    any character used in a filename, but when these filenames are accessed at the
    command line, they create a lot of headaches. The idea behind this script is to
    remember the poor souls who still use the command line … myself included. For
    all of the uncertainty of naming files, a simple script can help clean up and
    organize them. This script will rename files according to a specific set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: When I think of weird filenames, picture and music files always come to mind.
    If you're sharing photographs from that special vacation or showing off your band's
    latest jam session, the naming scheme will be different from person to person,
    and it may clash with the recipient's operating system. The script I'm about to
    show you will take each filename and format it based on your specifications. This
    script is highly customizable and super efficient, so find some files with questionable
    filenames and send them through. You'll be pleasantly surprised when the script
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`` #!/usr/bin/ruby   unless ARGV[0]      puts "Usage: ruby fixFilename.rb <filename.ext>"
         puts "Example: ruby fixFilename.rb \''How to (make) 20% more on $500.pdf\''"
         exit  end  ![](../Images/00002.jpg) old_filename = ARGV[0]   unless File.exist?(old_filename)''
         puts "#{old_filename} does not exist.  Please try again." ![](../Images/00003.jpg)  
       exit  end  ![](../Images/00004.jpg) name = File.basename(old_filename, ".*")
     ext = File.extname(old_filename)  ![](../Images/00005.jpg) replacements = {  /;/
    => "-",                  /\s/ => "_",                  /\''\`/ => "=",       
              /\&/ => "_and_",                  /\$/ => "dollar_",               
      /%/ => "_percent",                  /[\(\)\[\]<>]/ => ""                }    replacements.each
    do |orig, fix|       name.gsub!(orig,fix)  end  ![](../Images/00006.jpg) File.rename(old_filename,
    name + ext)  ![](../Images/00007.jpg) puts "#{old_filename} ---> #{name + ext}"``'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script runs with one command-line argument, the filename to scan and potentially
    fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The resulting output will show the old filename and what it was converted to.
    For this example, I made a bogus file with some nasty characters in it.
  prefs: []
  type: TYPE_NORMAL
- en: '``*`How to (make) 20% more on $500.pdf ---> How_to_make_20_percent_more_on_dollar_500.pdf`*``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in "Running the Code," this script relies on the user passing a
    filename as an argument to the script ![](../Images/00002.jpg). The script, in
    turn, attaches to the file and ensures that it actually exists. If a user mistyped
    some of the filename, instead of crashing, the script will inform the user that
    something is amiss with the input and exit cleanly ![](../Images/00003.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Next, a new variable called `name` is created so that you can tweak the original
    filename without disrupting it. The filename is stripped from its extension ![](../Images/00004.jpg).
    I isolated the extension so the file will still function properly in the off chance
    that one of the filters was set up in a way that could accidentally alter an extension.
    In the script's current configuration, it will only alter the filename.
  prefs: []
  type: TYPE_NORMAL
- en: The script uses a hash data structure named `replacements` to hold all of the
    invalid characters and their corresponding acceptable values. A code block containing
    the `gsub` method will be used to make all of the substitutions. The end result
    is that `name` will be returned with all occurrences of the specified pattern
    substituted by a replacement. Each line of the hash focuses on a specific "bad
    character" ![](../Images/00005.jpg). First is the semicolon, which is a reserved
    character in Linux and must be escaped. Instead of dealing with the semi-colon,
    the script substitutes it with a dash. All whitespace in the filename is turned
    into underscores, which look similar to whitespace. Backticks (on American keyboards
    this key is on the upper-left side, immediately to the left of the number 1, shared
    with the tilde) and apostrophes are turned into equal signs. Symbols such as &,
    %, and $ are converted to words. Finally, the name is checked for any parentheses,
    curly brackets, and angle brackets. Any found are removed.
  prefs: []
  type: TYPE_NORMAL
- en: The last step in the script renames the file. Using the `rename` method, the
    script gives the file our brand new operating-system friendly name ![](../Images/00006.jpg).
    As a courtesy to the user, the old filename is shown, as well as what it is being
    transformed into ![](../Images/00007.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further expansion on this script is really easy because of the way each rule
    is created. If you have a better way of representing the percentage sign, then
    you can easily edit the corresponding line of code. Additionally, there is always
    the possibility of adding prefixes or suffixes to each file. The script is flexible,
    so try some variations to see how you like them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a User
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: addUser.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the advent of GUIs, adding users to Unix and Linux systems has become
    much easier. You fill out the boxes, click Add, and you're done. Before GUIs,
    and still too often today, system administrators had to manually create each user
    account on a system.
  prefs: []
  type: TYPE_NORMAL
- en: While the task of manually creating user accounts for small organizations can
    be trivial, big businesses with thousands of users are a different story. Manually
    inputting account information into a computer system for 1,000 users is time consuming,
    tedious, and, most importantly, a waste of human productivity. This script automates
    the addition of user accounts to a system.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This script is platform dependent, so ensure that your systems are compatible
    with the commands to avoid corrupting your user files*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` #!/usr/bin/env ruby   #Using the command ''useradd'' with various arguments   print
    "Enter new username: " ![](../Images/00002.jpg)    user_name = gets.chomp   #Add
    the groups to the user ![](../Images/00003.jpg)    print "\nEnter primary group:
    "  gname = gets.chomp  add_user = "-g #{gname} "   while gname      print "\nEnter
    next group (return blank line when finished): "      gname = gets.chomp      break
    if gname.empty?      add_user << "-G #{gname} "  end  ![](../Images/00004.jpg) #Define
    which program will start when the user logs in  puts "\n\n\n[1] Bourne Again Shell
    (bash)"  puts "[2] Korn Shell (ksh)"  puts "[3] Z Shell (zsh)"  puts "[4] C Shell
    (csh)"  print "Which shell do you prefer (default bash)? "   sh_num = gets.chomp.to_i
     shell = case sh_num      when 1 then ''/bin/bash''      when 2 then ''/bin/ksh''
         when 3 then ''/bin/zsh''      when 4 then ''/bin/csh''      else ''/bin/bash''
     end   add_user << "-s #{shell} "   #Define home directory  add_user << "-d /home/#{user_name}
    "   #Define starting folder  add_user << "-m #{user_name}"   #Add user to the
    system and look at return value ![](../Images/00005.jpg) if(system("useradd #{add_user}"))
         puts "\n\nSuccessfully added: #{user_name}"  else      puts "\n\nUnable to
    add: #{user_name}"  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add users to your Unix-type system by following the prompts given by
    the script. Run it by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script will result in a user being added to your system with the configuration
    specified by you. You will see the following lines if the script was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '``Successfully added: *`steve`*``'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are able to change the password of the new account, you''ll know the
    script actually worked. I ran this script on a Gentoo Linux computer and all of
    my accounts were disabled upon creation if no password was specified. Simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and enter your chosen password twice. Next, you can switch users, log in with
    your new credentials, and take a break. If the script was unsuccessful in creating
    the account, you will receive an error message.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will no longer need to remember each flag or read through the `man` pages
    to simply add a user. The `useradd` command is a clean way to add users to a system,
    but the flags and options can be a bit cryptic. Also, adding more than a handful
    of accounts can become tedious. This script is fully interactive and will allow
    anyone with basic system knowledge to easily add users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example above, the script essentially creates the following string and
    uses the `system()` command to execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '``useradd -g *`admin`* -G *`printer`* -s /bin/*`bash`* -d /home/*`steve`* -m
    *`steve`*``'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script begins building the string by requesting the username for the new
    account ![](../Images/00002.jpg). The username is important for two reasons: It
    specifies the first piece of the logon credential, and it completes the home directory.
    Next are the groups ![](../Images/00003.jpg). Groups matter in Unix-style systems
    because they associate permissions to a specific username. In this example, I
    used the administrator and printer groups—these are entirely dependent upon the
    groups in your system.'
  prefs: []
  type: TYPE_NORMAL
- en: After the permissions are given to the user, the shell preference is requested
    ![](../Images/00004.jpg). The list of shells I provided (bash, ksh, zsh, and csh)
    may not all be installed on your system, so you'll need to edit accordingly. Bash
    is the most common shell to use, so I have defined that as the default entry and
    also used it in my example.
  prefs: []
  type: TYPE_NORMAL
- en: The last addition to our command string is the home directory and username.
    The script asked for the username in the beginning, so that value is used. The
    home directory ends up being */home/steve*, and the username is, obviously, *steve*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the string is executed using the `system()` command ![](../Images/00005.jpg),
    which spawns a subprocess and waits for the subprocess to terminate. The value
    `true` is returned if the subprocess exits successfully; otherwise, `false` is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully, you realize that not all of the flags are required to create a user,
    but they do make life simpler during the initial account creation process. With
    some additional code, this script could be integrated with a CSV file for automated
    user creation.
  prefs: []
  type: TYPE_NORMAL
- en: Try not to be overwhelmed by the amount of data I'm describing by hacking these
    scripts. If you are serious about writing your own scripts, a good starting point
    is to tweak other scripts and build up to writing scripts from scratch … especially
    when they involve many complex sections.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a User
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modifying a User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: modUser.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have ever administered a computer system that had multiple users, chances
    are you have had to modify existing accounts. In my experience, user accounts
    can be modified to update an expiration date, change a home directory, tweak a
    username, or, more commonly, to add a new group to the mix. Below you will find
    a generic script for guiding the user through the modification process. Keep in
    mind that this script needs to be run with elevated permissions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This script is platform dependent, so ensure that your systems are compatible
    with the commands to avoid corrupting your user files*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` #!/usr/bin/env ruby   #Using the command ''useradd'' with various arguments   print
    "Enter the username to modify: "  user_name = gets.chomp   #Determine how many
    groups the account will belong to ![](../Images/00002.jpg) print "Would you like
    to add this account to any groups [y/n]? "  gresult = gets.chomp ![](../Images/00003.jpg)  
      if (gresults == ''y'' || gresults == ''Y'')      #Add the groups to the user
         print "\nEnter primary group: "      gname = gets.chomp      mod_user = "-g
    #{gname} "       while gname          print "\nEnter next group: "          gname
    = gets.chomp          break if gname.empty?          add_user << "-G #{gname}
    "      end  end    #Define which program will start when the user logs in  print
    "Would you like to change the starting shell [y/n]?  sresult = gets.chomp  if
    (sresults == ''y'' || sresults == ''Y'')      puts "\n\n\n[1] Bourne Again Shell
    (bash)"      puts "[2] Korn Shell (ksh)"      puts "[3] Z Shell (zsh)"      puts
    "[4] C Shell (csh)"      print "Which shell would you like? "       sh_num = gets.chomp.to_i
         shell = case sh_num          when 1 then ''/bin/bash''          when 2 then
    ''/bin/ksh''          when 3 then ''/bin/zsh''          when 4 then ''/bin/csh''
             else ''/bin/bash''      end      mod_user << "-s ${shell} "  end   #Define
    home directory  print "Would you like to change the home directory [y/n]?  dresult
    = gets.chomp  if (dresults == ''y'' || dresults == ''Y'')      print "Enter new
    directory: "      dir = gets.chomp      mod_user << "-d #{dir} "  end   #Define
    new Login  print "Would you like to change the login name [y/n]?  lresult = gets.chomp
     if (lresults == ''y'' || lresults == ''Y'')      print "Enter new login: "   
      name = gets.chomp      mod_user << "-l #{name}"  end   #Modify user and look
    at return value  if(''usermod #{mod_user}'')      puts "\n\nSuccessfully modified:
    #{user_name}\n"  else      puts "\n\nUnable to modify: #{user_name}\n"`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will be prompted for information a minimum of five times. The first prompt
    will ask for the username of the account you want to modify. The remaining four
    prompts will ask questions about which part of the account needs modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example above, I only changed the starting shell. The script interaction
    is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results will be one of two messages. Either
  prefs: []
  type: TYPE_NORMAL
- en: '``Successfully modified: *`steve`*``'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '``Unable to modify: *`steve`*``'
  prefs: []
  type: TYPE_NORMAL
- en: If you are unable to modify the user, you will need to break out your troubleshooting
    hat to find the reason.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, whenever I log back into the account steve, I will now start
    off with the Z Shell instead of Bash. See how easy it is? This script could be
    given to a Unix novice and run from a terminal without any worries.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script's main components are similar to the script in "#18 Adding a User"
    on [Hacking the Script](../Text/dummy_split_128.html#filepos283804), because the
    attributes for a user account are the same whether you are creating, modifying,
    or deleting it. While I chose four attributes that I felt would be modified most
    frequently, they can always be removed to shorten runtime, or you can add others
    to suit your needs. The attributes to modify are `groups`, `starting shell`, `home
    directory`, and `login name`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the username, the script begins to prompt the system administrator
    for each attribute to determine whether any modifications are needed ![](../Images/00002.jpg).
    A simple conditional statement is used each time and looks for the letter *y*.
    In case the user left her CAPS LOCK enabled, the script will also accept an uppercase
    letter *Y*. Any other input, whether it's *n*, *N*, or some other character, will
    be interpreted as a dismissal of the modification ![](../Images/00003.jpg). Instead
    of adding this option to the conditional statement, I could have easily applied
    `.downcase` to the `gets` statement to ensure the input is always lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because most of the script is self-explanatory and thoroughly covered in "#18
    Adding a User" on [Hacking the Script](../Text/dummy_split_128.html#filepos283804),
    I won''t belabor the details. An interesting point to note: If you wish to modify
    the username of an account, that account cannot be logged into. If you try to
    `su` to an admin account, then modify the account you just came from, or you will
    surely see a friendly message declaring that you cannot modify the specific user.'
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a user and modifying a user are very similar operations, lending themselves
    to the creation of a turnkey script for all user manipulations. You could easily
    combine the script in "#18 Adding a User" on [Hacking the Script](../Text/dummy_split_128.html#filepos283804)
    with this script and extract some of the methods for another clean script.
  prefs: []
  type: TYPE_NORMAL
- en: Killing a Stuck Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Killing a Stuck Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: killProcess.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications are wonderful additions to operating systems. But occasionally
    they get stuck and begin to cause a self-inflicted Denial of Service attack on
    your system. Some processes are very stubborn and take extra effort to completely
    kill. This wicked little script will intuitively identify the stuck processes
    and automatically terminate them. How's that for avoiding additional manual work?
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`` #!/usr/bin/ruby ![](../Images/00002.jpg) max_time = 300 ![](../Images/00003.jpg) ps_list
    = `ps h -eo cputime, pcpu, pid, user, cmd`  ![](../Images/00004.jpg) list = ps_list.split(/\n/)  ![](../Images/00005.jpg) list.each
    do |p| ![](../Images/00006.jpg)     process = p.split ![](../Images/00007.jpg)  
      process[0] =~ /(\d+):(\d+):(\d+)/ ![](../Images/00008.jpg)     cpu_time = $1*3600
    + $2*60 + $3 ![](../Images/00009.jpg)     next if cpu_time < $max_time      next
    if process[3] == "root" or process[3] == "postfix"      next if process[4] ==
    "kdeinit"       begin          print "Would you like to kill: #{process[4]} (y/n)?
    "          if gets.downcase == "y" ![](../Images/00011.jpg)               Process.kill
    :TERM,process[2]          end      rescue          puts "Couldn''t kill the process...check
    permission." ![](../Images/00012.jpg)            retry      end  end``'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script is almost completely autonomous and only requires confirmation before
    killing a process. To run it, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`./killProcess.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will get a series of questions asking about the process identified as being
    an offender. The questions will look like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of this code lies in the way the script extracts CPU time. If a process
    has been expending CPU cycles for more than a reasonable amount of time, then
    it's time to kill the process. Chances are the process is hung, blocking other
    applications, and wasting precious system resources. You can change the time constraint
    to match the needs of your situation, but any time period will gain efficiency
    out of the processor by allowing the CPU to focus on meaningful data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum time allowed in this script is set in seconds. In the script, I
    arbitrarily choose 5 minutes, or 300 seconds ![](../Images/00002.jpg). The data
    used in this script is retrieved from the system using Ruby''s awesome backticks
    ![](../Images/00003.jpg). The `ps` command is executed with several arguments
    that will enable the script to target abusive processes. The `h` flag removes
    the header from the `ps` output. Since we are dictating the fields used, we don''t
    need to label the fields. Next, `-e` is used to show all processes on the system;
    `-A` could have also been used instead of `-e`. The second part of that flag is
    `o`, and that flag allows us to specify the output. The rest of the command shows
    which fields we are interested in retrieving: `cputime`, `pcpu`, `pid`, `user`,
    and `command`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the data is captured into the variable `ps_list` as a string, it must
    be broken down into manageable pieces of information. The highly effective `.split`
    command comes into play here, directed to split up the string by every new line
    ![](../Images/00004.jpg). If you recall the `ps` output, each process has its
    own line. After the processes are broken down into their elements, we can begin
    examining these.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't yet realize the power of `.each`, you will soon. The variable `list`
    contains an array of each process and its details. The `.each` instruction will
    go through each process no matter how many or how few there are ![](../Images/00005.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we have split each process from the others, we need to drill down
    the specific process information further to isolate the fields ![](../Images/00006.jpg).
    The default delimiter for `.split` is whitespace. A process string before the
    `.split` might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '``*`"00:03:04    0.0    1    steve    /usr/bin/ruby"`*``'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the split it will be an array with five items:'
  prefs: []
  type: TYPE_NORMAL
- en: '``*`["00:06:04", "0.0", "1", "steve", "/usr/bin/ruby"]`*``'
  prefs: []
  type: TYPE_NORMAL
- en: How cool is that?
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you see that the first field of each process will be what decides
    the process's fate. In this example, the process has been running for six minutes
    and four seconds. To get the data into a usable form, we need to convert the time
    into seconds. I've used a regular expression and groupings based on the time format.
    The `=~` operator is another slick feature; it allows you to take a shortcut around
    the regular expression `match` method. I use regular expressions a lot for input
    validation—if you don't know them, they are well worth the time it takes to learn!
  prefs: []
  type: TYPE_NORMAL
- en: After the regular expression has evaluated the data, the evaluation will return
    each grouping, signified by parentheses, into `$1-$`*`n`* with *`n`* being the
    number of groups ![](../Images/00007.jpg). The next step is to break each value
    down into seconds. We know there are 3,600 seconds in every hour and 60 seconds
    in every minute. So we multiply each grouping by its corresponding seconds and
    add them together ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'The evaluation is done using three `if` statements. An alternative would be
    to use a really long `if` statement, but I decided against it for the sake of
    keeping the code readable. For a process to be a target, it must meet three conditions.
    If any of those conditions are not satisfied, then we disregard the process. The
    three conditions are: the time being more than `$max_time` in seconds, the owner
    not being a protected user, and the process not being a system-critical one ![](../Images/00009.jpg).
    In the script, I threw in some examples like `root` and `kdeinit`. Play around
    in this area to customize for your purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: If you trust the script to do everything it said and no more, you can remove
    the confirmation statement. I'm not entirely trusting, so I prefer to know when
    I'm about to kill a process. If the user answers anything but a capitalized or
    lowercase y, the process will not be killed—again, I am using a regular expression.
    If the script is directed to kill the process, it will attempt to use `TERM` ![](../Images/00011.jpg).
    Feel free to change to `SIGTERM` if you're feeling especially grumpy since it
    is a more forceful kill. Every once in a while a process won't die, and the script
    will let you know. You can continue retrying ![](../Images/00012.jpg), or skip
    it by answering no to the confirmation line. Once the script has gone through
    each process, it exits.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Symlinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validating Symlinks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: symlinkCheck.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Symlinks, or symbolic links*, are awesome for a lot of reasons: They simplify
    obnoxiously long path names; you can put them anywhere you like; you can call
    them whatever you want; and they are generally transparent to the user. While
    symlinks can do magical things, they really suck when they become orphans (that
    is, no longer point to a valid target). So, in an effort to uphold the symlink
    reputation, I wrote this script to clean up after myself … and others. It''s a
    housekeeping script.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` #!/usr/bin/ruby  ![](../Images/00002.jpg) unless File.directory?(ARGV[0])
         puts "Not a valid directory...\nCheck path and try again.\n\n"      exit
     end  ![](../Images/00003.jpg) Dir.open(ARGV[0]) do |adir|      adir.each do |afile|
    ![](../Images/00004.jpg)            next unless FileTest.symlink?(afile) ![](../Images/00005.jpg)  
             next if File.file?(afile) ![](../Images/00006.jpg)            puts "Bad
    Link: #{File.expand_path(afile)}"      end  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script runs off a single directory input. If you have a directory where
    you keep symlinks, this script will scrub the list in a matter of seconds. Just
    type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script will immediately output the path of each symlink identified as being
    orphaned—all other symlinks are skipped. The output will be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '``Bad Link: *`/home/steve/Desktop/symlink.txt`*``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User input drives the script's direction, so the first step is to collect the
    user input (the directory in which we are symlink hunting). If an invalid argument
    is supplied, the user is notified and the script exits ![](../Images/00002.jpg).
    The directory is opened using the `Dir.open()` command ![](../Images/00003.jpg).
    After the directory has been successfully opened, the process is iterated and
    each file analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two conditions must be met for a file to be considered an orphaned symlink.
    The first condition is checked by the `next unless` statement ![](../Images/00004.jpg).
    This statement checks to see if the file is a symlink. If the file is not a symbolic
    link, then the script doesn''t need to waste any more time analyzing it; `next`
    is called and the rest of the files are analyzed. If you''re lucky and the file
    is a symlink, then the script will verify that the symlink actually links to something.
    This second check is based on the symlink pointing to a target: the method `File.file?`
    will be asking if the target is a file ![](../Images/00005.jpg). If the target
    does not exist, the link is orphaned and must be reported to the user for further
    action ![](../Images/00006.jpg). The output shows the entire path of the bad symlink
    for easy identification once the script has finished. All that is left is for
    the user to find the target for each bad link or delete the symlink.'
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this script only looks at symbolic links of files, directories can also
    have symbolic links. You can change this script to look for invalid directories
    along with invalid file links. Give it a try and see how many unexpectedly invalid
    links exist on your machine!
  prefs: []
  type: TYPE_NORMAL
