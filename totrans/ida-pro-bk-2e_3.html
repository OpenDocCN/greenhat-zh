<html><head></head><body><div class="part" title="Part&#xA0;III.&#xA0;Advanced IDA Usage"><div class="titlepage"><div><div><h1 class="title"><a id="advanced_ida_usage"/>Part III. Advanced IDA Usage</h1></div></div></div><div class="partintro" id="id3175544" title="Advanced IDA Usage"><div/><p/></div></div>
<div class="chapter" title="Chapter&#xA0;11.&#xA0;Customizing IDA"><div class="titlepage"><div><div><h1 class="title"><a id="customizing_ida"/>Chapter 11. Customizing IDA</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id11"/><div class="mediaobject"><a id="I_mediaobject1_d1e14839"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>After spending some time with IDA, you may have developed some preferred settings that you wish to use as defaults every time you open a new database. Some of the options you have changed may already carry over from session to session, while other options seem to need resetting every time you load a new database. In this chapter we examine the various ways in which you can modify IDA’s behavior through configuration files and menu-accessible options. We also examine where IDA stores various configuration settings and discuss the difference between database-specific settings and global settings.<a class="indexterm" id="IDX-CHP-11-0001"/><a class="indexterm" id="IDX-CHP-11-0002"/><a class="indexterm" id="IDX-CHP-11-0003"/><a class="indexterm" id="IDX-CHP-11-0004"/></p><div class="sect1" title="Configuration Files"><div class="titlepage"><div><div><h1 class="title"><a id="configuration_files"/>Configuration Files</h1></div></div></div><p>Much of IDA’s default behavior is governed by settings contained in various configuration files. For the most part, configuration files are stored in the <span class="emphasis"><em>&lt;IDADIR&gt;/cfg</em></span> directory, with one notable exception being the plug-ins configuration file, which resides at <span class="emphasis"><em>&lt;IDADIR&gt;/plugins/plugins.cfg</em></span> (<span class="emphasis"><em>plugins.cfg</em></span> will be covered in <a class="xref" href="ch17.html" title="Chapter 17. The IDA Plug-in Architecture">Chapter 17</a>). While you may notice quite a few files in the main configuration directory, the majority of the files are used by processor modules and are applicable only when certain CPU types are being analyzed. The three principal configuration files are <span class="emphasis"><em>ida.cfg</em></span>, <span class="emphasis"><em>idagui.cfg</em></span>, and <span class="emphasis"><em>idatui.cfg</em></span>. Options that apply to all versions of IDA are generally found in <span class="emphasis"><em>ida.cfg</em></span>, while <span class="emphasis"><em>idagui.cfg</em></span> and <span class="emphasis"><em>idatui.cfg</em></span> contain options specific to the GUI versions and the text-mode versions of IDA, respectively.<a class="indexterm" id="IDX-CHP-11-0005"/><a class="indexterm" id="IDX-CHP-11-0006"/><a class="indexterm" id="IDX-CHP-11-0007"/><a class="indexterm" id="IDX-CHP-11-0008"/><a class="indexterm" id="IDX-CHP-11-0009"/><a class="indexterm" id="IDX-CHP-11-0010"/><a class="indexterm" id="IDX-CHP-11-0011"/><a class="indexterm" id="IDX-CHP-11-0012"/><a class="indexterm" id="IDX-CHP-11-0013"/></p><div class="sect2" title="The Main Configuration File: ida.cfg"><div class="titlepage"><div><div><h2 class="title"><a id="the_main_configuration_file_colon_ida.cf"/>The Main Configuration File: ida.cfg</h2></div></div></div><p>IDA’s principal configuration file is <span class="emphasis"><em>ida.cfg</em></span>. Early in the startup process, this file is read to assign default processor types for various file extensions and to tune IDA’s memory usage parameters. Once a processor type has been specified, the file is then read a second time to process additional configuration options. The options contained in <span class="emphasis"><em>ida.cfg</em></span> apply to all versions of IDA regardless of the user interface that is being used.<a class="indexterm" id="IDX-CHP-11-0014"/></p><p>General options of interest in <span class="emphasis"><em>ida.cfg</em></span> include memory-tuning parameters (<code class="literal">VPAGESIZE</code>), whether backup files are created (<code class="literal">CREATE_BACKUPS</code>), and the name of the external graph viewer (<code class="literal">GRAPH_VISUALIZER</code>).</p><p>Occasionally when working with very large input fields, IDA may report that not enough memory is available to create a new database. In such cases, increasing the <code class="literal">VPAGESIZE</code> and then reopening the input file is usually sufficient to solve the problem.</p><p>A large number of options that control the format of disassembly lines are also contained in <span class="emphasis"><em>ida.cfg</em></span>, including the default values for many of the options accessible via Options ▸ General. These include default values for the number of opcode bytes to display (<code class="literal">OPCODE_BYTES</code>), how far instructions should be indented (<code class="literal">INDENTATION</code>), whether the stack pointer offset should be displayed with each instruction (<code class="literal">SHOW_SP</code>), and the maximum number of cross-references to be displayed with a disassembly line (<code class="literal">SHOW_XREFS</code>). Additional options control the format of disassembly lines while in graph mode.<a class="indexterm" id="IDX-CHP-11-0015"/></p><p>The global option specifying the maximum name length for named program locations (as opposed to stack variables) is contained in <span class="emphasis"><em>ida.cfg</em></span> and is called <code class="literal">MAX_NAMES_LENGTH</code>. This option defaults to 15 characters and causes IDA to generate a warning message any time you enter a name longer than the current limit. The default length is kept small because some assemblers cannot handle names longer than 15 characters. If you do not plan to run an IDA-generated disassembly back through an assembler, then you may safely increase the limit.</p><p>The list of characters allowed in user-assigned names is governed by the <code class="literal">NameChars</code> options. By default this list allows alphanumeric characters and the four special characters <code class="literal">_$?@</code>. If IDA complains about the characters that you wish to use when you assign new names to locations or stack variables, then you may want to add additional characters to the <code class="literal">NameChars</code> set. For example, <code class="literal">NameChars</code> is the option to modify if you want to make the dot (<code class="literal">.</code>) character legal for use in IDA names. You should avoid the use of the semicolon, colon, comma, and space characters within names because they may lead to confusion, as these characters are typically considered delimiters for various disassembly line parts.<a class="indexterm" id="IDX-CHP-11-0016"/><a class="indexterm" id="IDX-CHP-11-0017"/><a class="indexterm" id="IDX-CHP-11-0018"/><a class="indexterm" id="IDX-CHP-11-0019"/><a class="indexterm" id="IDX-CHP-11-0020"/><a class="indexterm" id="IDX-CHP-11-0021"/><a class="indexterm" id="IDX-CHP-11-0022"/></p><p>The last two options worth mentioning influence IDA’s behavior when parsing C header files (see <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>). The <code class="literal">C_HEADER_PATH</code> option specifies a list of directories that IDA will search to resolve <code class="literal">#include</code> dependencies. By default, a common directory used by Microsoft’s Visual Studio is listed. If you use a different compiler or if your C header files are in a nonstandard location, you should consider editing this option. The <code class="literal">C_PREDEFINED_MACROS</code> option can be used to specify a default list of preprocessor macros that IDA will incorporate regardless of whether IDA has encountered them while parsing a C header file. This option offers a limited workaround facility for dealing with macros that may be defined in header files to which you do not have access.</p><p>The second half of <span class="emphasis"><em>ida.cfg</em></span> contains options specific to various processor modules. The only documentation available for options in this section of the file comes in the form of the comments (if any) associated with each option. The processor-specific options specified in <span class="emphasis"><em>ida.cfg</em></span> generally dictate the default settings in the <code class="literal">Processor options</code> section of IDA’s initial file-loading dialog.</p><p>The last step in processing <span class="emphasis"><em>ida.cfg</em></span> is to search for a file named <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/idauser.cfg</em></span>. If present,<sup>[<a class="footnote" href="#ftn.CHP-11-FN-1" id="CHP-11-FN-1">72</a>]</sup> this file is treated as an extension of <span class="emphasis"><em>ida.cfg</em></span>, and any options in the file will override corresponding options in <span class="emphasis"><em>ida.cfg</em></span>. If you do not feel comfortable editing <span class="emphasis"><em>ida.cfg</em></span>, then you should create <span class="emphasis"><em>idauser.cfg</em></span> and add to it all of the options that you wish to override. In addition, <span class="emphasis"><em>idauser.cfg</em></span> offers the easiest means for transferring your customized options from one version of IDA to another. For example, with <span class="emphasis"><em>idauser.cfg</em></span> you do not need to re-edit <span class="emphasis"><em>ida.cfg</em></span> each time you upgrade your copy of IDA. Instead, simply copy your existing <span class="emphasis"><em>idauser.cfg</em></span> to your new IDA installation any time you upgrade.</p></div><div class="sect2" title="The GUI Configuration File: idagui.cfg"><div class="titlepage"><div><div><h2 class="title"><a id="the_gui_configuration_file_colon_idagui"/>The GUI Configuration File: idagui.cfg</h2></div></div></div><p>Configuration items specific to the GUI version of IDA are located in their own file: <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/idagui.cfg</em></span>. This file is organized into roughly three sections: default GUI behaviors, keyboard hotkey mappings, and file extension configuration for the File ▸ Open dialog. In this section we discuss a few of the more interesting options. Consult <span class="emphasis"><em>idagui.cfg</em></span> for the complete list of available options, which in most cases are accompanied by comments describing their purpose.</p><p>The Windows GUI version of IDA allows a secondary help file to be specified using the <code class="literal">HELPFILE</code> option. Any file specified here does not replace IDA’s primary help file. The intended purpose of this option is to provide access to supplemental information that may apply in specific reverse engineering situations. When a supplemental help file is specified, <span class="keycap">ctrl</span>-F1 causes IDA to open the named file and search for a topic that matches the word under the cursor. If no match is found, then you are taken to the help file’s index. As an example, unless you count auto comments, IDA does not offer any help information regarding the instruction mnemonics in a disassembly. If you are analyzing an x86 binary, you might like to have an x86 instruction reference available on command. If you can locate a help file that happens to contain topics for each x86 instruction,<sup>[<a class="footnote" href="#ftn.CHP-11-FN-2" id="CHP-11-FN-2">73</a>]</sup> then help for any instruction is only a hotkey away. The only word of caution concerning supplemental help files is that IDA supports only the older WinHelp-style help files (<span class="emphasis"><em>.hlp</em></span>). IDA does not support the use of compiled HTML help files (<span class="emphasis"><em>.chm</em></span>) as secondary help files.<a class="indexterm" id="IDX-CHP-11-0023"/><a class="indexterm" id="IDX-CHP-11-0024"/><a class="indexterm" id="IDX-CHP-11-0025"/><a class="indexterm" id="IDX-CHP-11-0026"/><a class="indexterm" id="IDX-CHP-11-0027"/><a class="indexterm" id="IDX-CHP-11-0028"/><a class="indexterm" id="IDX-CHP-11-0029"/><a class="indexterm" id="IDX-CHP-11-0030"/><a class="indexterm" id="IDX-CHP-11-0031"/><a class="indexterm" id="IDX-CHP-11-0032"/><a class="indexterm" id="IDX-CHP-11-0033"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Microsoft Windows Vista and later do not provide native support for 32-bit WinHelp files because the <span class="emphasis"><em>WinHlp32.exe</em></span> file does not ship with these operating systems. Please refer to Microsoft Knowledge Base article 917607<sup>[<a class="footnote" href="#ftn.CHP-11-FN-3" id="CHP-11-FN-3">74</a>]</sup> for more information.</p></div><p>A common question asked about using IDA is “How can I patch binaries using IDA?” In a nutshell, the answer is “You can’t,” but we will put off discussing the details of this issue until <a class="xref" href="ch14.html" title="Chapter 14. Patching Binaries and Other IDA Limitations">Chapter 14</a>. What you can do with IDA is patch the database to modify instructions or data in almost any way you see fit. Once we discuss scripting (<a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>), you will understand that modifying the database is not terribly difficult. But what if you are not interested in or not ready to learn IDA’s scripting language? IDA contains a database-patching menu that is not shown by default. The <code class="literal">DISPLAY_PATCH_SUBMENU</code> option is used to show or hide IDA’s patching menu, which shows up as Edit ▸ Patch Program. The options available on this menu are discussed in <a class="xref" href="ch14.html" title="Chapter 14. Patching Binaries and Other IDA Limitations">Chapter 14</a>.</p><p>The single-line input box at the bottom of your IDA workspace is known as the IDA comand line. You can use the <code class="literal">DISPLAY_COMMAND_LINE</code> option to control whether this field is displayed or not. By default the command will be shown. If you are tight on screen space and you don’t anticipate the need to enter one-line scripts, then turning this feature off can help you regain a small amount of room in your IDA display. Note that this command line does not allow you to execute operating system commands as if you were entering them at a command prompt.</p><p>The hotkey configuration section of <span class="emphasis"><em>idagui.cfg</em></span> is used to specify mappings between IDA actions and hotkey sequences. Hotkey reassignment is useful in many instances, including making additional commands available via hot-keys, changing default sequences to sequences that are easier to remember, or changing sequences that might conflict with other sequences in use by the operating system or your terminal application (useful primarily for the console version of IDA).</p><p>Virtually every option that IDA makes available through menu items or toolbar buttons is listed in this section. Unfortunately, the names of the commands tend not to match the text used on IDA’s menus, so it may take some effort to determine exactly which configuration file option maps to a specific menu option. For example, the Jump ▸ Jump to Problem command equates to the <code class="literal">JumpQ</code> option (which <span class="emphasis"><em>does</em></span> happen to match its hotkey: <span class="keycap">ctrl</span>-Q) in <span class="emphasis"><em>idagui.cfg</em></span>. In addition, while many commands have matching comments to describe their purpose, many commands have no description at all, so you are left to determine the behavior of a command based on its name within the configuration file. A trick that may help you figure out what menu item a configuration file action is associated with is to <span class="emphasis"><em>search</em></span> for the action in IDA’s help system. The results of such searches usually lead to the description of the action’s corresponding menu item.<a class="indexterm" id="IDX-CHP-11-0034"/><a class="indexterm" id="IDX-CHP-11-0035"/><a class="indexterm" id="IDX-CHP-11-0036"/></p><p>The following lines represent example hotkey assignments in <span class="emphasis"><em>idagui.cfg</em></span>:</p><a id="I_programlisting1_d1e15215"/><pre class="programlisting">"Abort"                =      0               // Abort IDA, don't save changes
"Quit"                 =      "Alt-X"         // Quit to DOS, save changes</pre><p>The first line is the hotkey assignment for IDA’s <code class="literal">Abort</code> command, which in this case has no hotkey assignment. The unquoted value <code class="literal">0</code> indicates that no hotkey has been assigned to a command. The second line shows the hotkey assignment for IDA’s <code class="literal">Quit</code> action. Hotkey sequences are specified as a quoted string naming the key sequence. Numerous examples of hotkey assignments exist within <span class="emphasis"><em>idagui.cfg</em></span>.</p><p>The final portion of <span class="emphasis"><em>idagui.cfg</em></span> associates file type descriptions with their associated file extensions and specifies which file types will be listed in the Files of type drop-down list within the File ▸ Open dialog. A large number of file types are already described in the configuration file; however, if you find yourself frequently working with a file type that is not available, you may want to edit the file types list to add your file type to the list. The <code class="literal">FILE_EXTENSIONS</code> option describes all file associations known to IDA. The following line is an example of a typical file type association.</p><a id="I_programlisting1_d1e15240"/><pre class="programlisting">CLASS_JAVA,  "Java Class Files",                           "*.cla*;*.cls"</pre><p>The line contains three comma-separated components: a name for the association (<code class="literal">CLASS_JAVA</code>), a description, and a filename pattern. Wildcards are allowed in the filename pattern, and multiple patterns can be specified by using a semicolon to separate them. A second type of file association allows several existing associations to be grouped into a single category. For example, the following line groups all associations whose names begin with <code class="literal">EXE_</code> into a single association named <code class="literal">EXE</code>.<a class="indexterm" id="IDX-CHP-11-0037"/><a class="indexterm" id="IDX-CHP-11-0038"/></p><a id="I_programlisting1_d1e15259"/><pre class="programlisting">EXE,         "Executable Files",                           EXE_*</pre><p>Note that the pattern specifier in this case is not quoted. We might define our own file association as follows:</p><a id="I_programlisting1_d1e15263"/><pre class="programlisting">IDA_BOOK,    "Ida Book Files",                             "*.book"</pre><p>We can choose any name we like for the association as long as it is not already in use; however, simply adding a new association to the <code class="literal">FILE_EXTENSIONS</code> list is not sufficient to make that association appear in the File ▸ Open dialog. The <code class="literal">DEFAULT_FILE_FILTER</code> option lists the names of all associations that will appear in the File ▸ Open dialog. To complete the process and make our new association available, we would need to add <code class="literal">IDA_BOOK</code> to the <code class="literal">DEFAULT_FILE_FILTER</code> list.<a class="indexterm" id="IDX-CHP-11-0039"/><a class="indexterm" id="IDX-CHP-11-0040"/><a class="indexterm" id="IDX-CHP-11-0041"/><a class="indexterm" id="IDX-CHP-11-0042"/><a class="indexterm" id="IDX-CHP-11-0043"/><a class="indexterm" id="IDX-CHP-11-0044"/><a class="indexterm" id="IDX-CHP-11-0045"/></p><p>Similar to the <span class="emphasis"><em>idauser.cfg</em></span> file, the last line in <span class="emphasis"><em>idagui.cfg</em></span> contains a directive to include a file named <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/idauserg.cfg</em></span>. If you do not feel comfortable editing <span class="emphasis"><em>idagui.cfg</em></span>, then you should create <span class="emphasis"><em>idauserg.cfg</em></span> and add to it all of the options that you wish to override.</p></div><div class="sect2" title="The Console Configuration File: idatui.cfg"><div class="titlepage"><div><div><h2 class="title"><a id="the_console_configuration_file_colon_ida"/>The Console Configuration File: idatui.cfg</h2></div></div></div><p>The analog to <span class="emphasis"><em>idagui.cfg</em></span> for users of the console version of IDA is <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/idatui.cfg</em></span>. This file is very similar in layout and functionality to <span class="emphasis"><em>idagui.cfg</em></span>. Among other things, hotkey specifications are made in the exact same manner as they are in <span class="emphasis"><em>idagui.cfg</em></span>. Because the two files are so similar, we will detail only the differences here.</p><p>First, the options <code class="literal">DISPLAY_PATCH_SUBMENU</code> and <code class="literal">DISPLAY_COMMAND_LINE</code> are not available in the console version and are not included in <span class="emphasis"><em>idatui.cfg</em></span>. The File ▸ Open dialog used in the console version is far simpler than the dialog used in the GUI version, so all of the file association commands available in <span class="emphasis"><em>idagui.cfg</em></span> are missing in <span class="emphasis"><em>idatui.cfg</em></span>.</p><p>On the other hand, a few options are available <span class="emphasis"><em>only</em></span> for console versions of IDA. For example, you can use the <code class="literal">NOVICE</code> option to have IDA start in a beginner mode, in which it disables some of its more complex functionality in an attempt to be easier to learn. A notable difference in novice mode is the almost complete lack of subviews.<a class="indexterm" id="IDX-CHP-11-0046"/></p><p>Console users are far more likely to rely on the use of hotkey sequences. To facilitate the automation of common hotkey sequences, console mode IDA provides a keyboard macro definition syntax. Several example macros can be found in <span class="emphasis"><em>idatui.cfg</em></span>; however, the ideal location to place any macros that you develop is <span class="emphasis"><em>&lt;IDADIR&gt;/cfg/idausert.cfg</em></span> (the console equivalent of <span class="emphasis"><em>idauserg.cfg</em></span>). A sample macro contained in the default <span class="emphasis"><em>idatui.cfg</em></span> might look like the following (in the actual <span class="emphasis"><em>idatui.cfg</em></span>, this macro is commented out):<a class="indexterm" id="IDX-CHP-11-0047"/></p><a id="I_programlisting1_d1e15384"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> MACRO   <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>"Alt-H"        // this sample macro jumps to "start" label
  {
          "G"
          's' 't' 'a' 'r', 't'
          "Enter"
  }</pre><p><code class="literal">Macro</code> definitions are introduced with the <code class="literal">MACRO</code> keyword <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e15404"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> followed by the hotkey <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e15410"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> to be associated with the macro. The macro sequence itself is specified between braces as a sequence of key name strings or characters, which may in turn represent hotkey sequences themselves. The preceding example macro, activated using <span class="keycap">alt</span>-H, opens the Jump to Address dialog using the G hotkey, enters the label <span class="emphasis"><em>start</em></span> into the dialog one character at a time, and then closes the dialog using the <span class="keycap">enter</span> key. Note that we could not use the syntax “start” to enter the name of the symbol, as this would be taken as the name of a hotkey and result in an error.<a class="indexterm" id="IDX-CHP-11-0048"/><a class="indexterm" id="IDX-CHP-11-0049"/><a class="indexterm" id="IDX-CHP-11-0050"/><a class="indexterm" id="IDX-CHP-11-0051"/><a class="indexterm" id="IDX-CHP-11-0052"/><a class="indexterm" id="IDX-CHP-11-0053"/><a class="indexterm" id="IDX-CHP-11-0054"/><a class="indexterm" id="IDX-CHP-11-0055"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Macros and novice mode are not available in the GUI version of IDA.</p></div><p>As a final note about configuration file options, it is important to know that if IDA encounters any errors while parsing its configuration files, it immediately terminates with an error message that attempts to describe the nature of the problem. It is not possible to start IDA until the error condition has been corrected.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-1" id="ftn.CHP-11-FN-1">72</a>] </sup>This file does not ship with IDA. Users must generate this file on their own if they wish IDA to find it.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-2" id="ftn.CHP-11-FN-2">73</a>] </sup>Pedram Amini swears by this WinHelp32 file: <a class="ulink" href="http://pedram.redhive.com/openrce/opcodes.hlp">http://pedram.redhive.com/openrce/opcodes.hlp</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-3" id="ftn.CHP-11-FN-3">74</a>] </sup>See <a class="ulink" href="http://support.microsoft.com/kb/917607">http://support.microsoft.com/kb/917607</a>.</p></div></div></div>
<div class="sect1" title="Additional IDA Configuration Options"><div class="titlepage"><div><div><h1 class="title"><a id="additional_ida_configuration_options"/>Additional IDA Configuration Options</h1></div></div></div><p>IDA has a tremendous number of additional options that must be configured through the IDA user interface. Options for formatting individual disassembly lines were discussed in <a class="xref" href="ch07.html" title="Chapter 7. Disassembly Manipulation">Chapter 7</a>. Additional IDA options are accessed via the Options menu, and in most cases, any options that you modify apply only to the currently opened database. Values for those options are stored in the associated database file when the database is closed. IDA’s Color (Options ▸ Colors) and Font (Options ▸ Font) options are two of the exceptions to this rule in that they are global options that, once set, remain in effect in all future IDA sessions. For Windows versions of IDA, option values are stored in the Windows registry under the <code class="literal">HKEY_CURRENT_USER\Software\Hex-Rays\IDA</code> registry key. For non-Windows versions of IDA, these values are stored in your home directory in a proprietary format file named <code class="literal">$HOME/.idapro/ida.reg</code>.</p><p>Another piece of information that is saved in the registry concerns dialogs for which you may choose the Do not display this dialog box again option. This message occasionally appears in the form of a checkbox in the lower-right portion of some informational message dialogs that you may not wish to see in the future. Should you select this option, a registry value is created under the <code class="literal">HKEY_CURRENT_USER\Software\Hex-Rays\IDA\Hidden Messages</code> registry key. If, at a later time, you wish to have a hidden dialog displayed once again, you will need to delete the appropriate value under this registry key.<a class="indexterm" id="IDX-CHP-11-0056"/></p><div class="sect2" title="IDA Colors"><div class="titlepage"><div><div><h2 class="title"><a id="ida_colors"/>IDA Colors</h2></div></div></div><p>The color of virtually every item in an IDA display can be customized via the Options ▸ Colors dialog shown in <a class="xref" href="ch11s02.html#the_color_selection_dialog" title="Figure 11-1. The color selection dialog">Figure 11-1</a>.</p><div class="figure"><a id="the_color_selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e15488"/><img alt="The color selection dialog" src="httpatomoreillycomsourcenostarchimages854231.png.jpg"/></div></div><p class="title">Figure 11-1. The color selection dialog</p></div><p>The Disassembly tab controls the colors used for various parts of each line in the disassembly window. Examples of each type of text that can appear in a disassembly are given in the example window <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e15495"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. When you select an item in the example window, the item’s type is listed at <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e15501"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Using the Change Color button, you may assign any color you wish to any item you wish.<a class="indexterm" id="IDX-CHP-11-0057"/><a class="indexterm" id="IDX-CHP-11-0058"/><a class="indexterm" id="IDX-CHP-11-0059"/><a class="indexterm" id="IDX-CHP-11-0060"/><a class="indexterm" id="IDX-CHP-11-0061"/><a class="indexterm" id="IDX-CHP-11-0062"/><a class="indexterm" id="IDX-CHP-11-0063"/><a class="indexterm" id="IDX-CHP-11-0064"/></p><p>The color selection dialog contains tabs for assigning colors used in the navigation band, the debugger, the jump arrows in the left margin of the text disassembly view, and various components in the graph view. Specifically, the Graph tab controls the coloring of graph nodes, their title bars, and the edges that connect each node, while the Disassembly tab controls the coloring of disassembled text in the graph view. The Misc tab allows for customizing the colors used in IDA’s message window.<a class="indexterm" id="IDX-CHP-11-0065"/></p></div><div class="sect2" title="Customizing IDA Toolbars"><div class="titlepage"><div><div><h2 class="title"><a id="customizing_ida_toolbars"/>Customizing IDA Toolbars</h2></div></div></div><p>In addition to menus and hotkeys, the GUI version of IDA offers a large number of toolbar buttons spread across more than two dozen toolbars. Toolbars are typically docked in the main toolbar area beneath IDA’s menu bar. Two predefined toolbar arrangements accessible using the View ▸ Toolbars menu are Basic mode, which enables seven of IDA’s toolbars, and Advanced mode, which enables every IDA toolbar. Individual toolbars can be detached, dragged, and relocated to any location on the screen to suit your personal taste. If you find that you have no need for a particular toolbar, you can remove it from the display entirely via the View ▸ Toolbars menu, which is shown in <a class="xref" href="ch11s02.html#the_toolbar_configuration_menu" title="Figure 11-2. The toolbar configuration menu">Figure 11-2</a>.<a class="indexterm" id="IDX-CHP-11-0066"/><a class="indexterm" id="IDX-CHP-11-0067"/><a class="indexterm" id="IDX-CHP-11-0068"/></p><p>This menu also appears if you right-click anywhere within the docking area of the IDA display. Turning off the Main toolbar removes all toolbars from the docking area and is useful if you need to maximize the amount of screen space dedicated to the disassembly window. Any changes that you make to your toolbar arrangement are stored with the current database. Opening a second database will restore the toolbars to the arrangement that was in effect when the second database was last saved. Opening a new binary to create a new database restores the toolbar arrangement based on IDA’s current default toolbar settings.<a class="indexterm" id="IDX-CHP-11-0069"/><a class="indexterm" id="IDX-CHP-11-0070"/><a class="indexterm" id="IDX-CHP-11-0071"/><a class="indexterm" id="IDX-CHP-11-0072"/><a class="indexterm" id="IDX-CHP-11-0073"/></p><div class="figure"><a id="the_toolbar_configuration_menu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e15585"/><img alt="The toolbar configuration menu" src="httpatomoreillycomsourcenostarchimages854233.png.jpg"/></div></div><p class="title">Figure 11-2. The toolbar configuration menu</p></div><p>If you settle on a toolbar arrangement that you happen to like and wish to make it the default, then you should save the current desktop arrangement as your default desktop using Windows ▸ Save Desktop, which opens the dialog shown in <a class="xref" href="ch11s02.html#the_save_disassembly_desk-top_dialog" title="Figure 11-3. The Save Disassembly Desktop dialog">Figure 11-3</a>.</p><div class="figure"><a id="the_save_disassembly_desk-top_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e15597"/><img alt="The Save Disassembly Desktop dialog" src="httpatomoreillycomsourcenostarchimages854235.png.jpg"/></div></div><p class="title">Figure 11-3. The Save Disassembly Desktop dialog</p></div><p>Each time you save a desktop configuration, you are asked to supply a name for the configuration. When the Default checkbox is selected, the current desktop layout becomes the default for all new databases and the desktop to which you will revert if you choose Windows ▸ Reset desktop. To restore the display to one of your custom desktops, select <span class="strong"><strong>Windows</strong></span> ▸ <span class="strong"><strong>Load Desktop</strong></span> and choose the named layout that you wish to load. Saving and restoring desktops is particularly useful in situations that involve using multiple monitors with different sizes and/or resolutions (which may be common with laptops using different docking stations or when connecting to projectors for presentations).</p></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id10"/>Summary</h1></div></div></div><p>When starting out with IDA, you may be perfectly satisfied with both its default behaviors and its default GUI layout. As you become more comfortable with IDA’s basic features, you are certain to find ways to customize IDA to your particular tastes. While there is no way to provide complete coverage of every possible option IDA offers in a single chapter, we have attempted to provide pointers to the principal locations in which those options may be found. We have also attempted to highlight those options that you are most likely to want to manipulate at some point in your IDA experience. Discovering additional useful options is left as a matter of exploration for inquisitive readers.</p></div>
<div class="chapter" title="Chapter&#xA0;12.&#xA0;Library Recognition Using FLIRT Signatures"><div class="titlepage"><div><div><h1 class="title"><a id="library_recognition_using_flirt_signatur"/>Chapter 12. Library Recognition Using FLIRT Signatures</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id12"/><div class="mediaobject"><a id="I_mediaobject2_d1e15619"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>At this point it is time to start moving beyond IDA’s more obvious capabilities and begin our exploration of what to do after “The initial autoanalysis has been finished.”<sup>[<a class="footnote" href="#ftn.CHP-12-FN-1" id="CHP-12-FN-1">75</a>]</sup> In this chapter we discuss techniques for recognizing standard code sequences such as the library code contained in statically linked binaries or standard initialization and helper functions inserted by compilers.<a class="indexterm" id="IDX-CHP-12-0001"/><a class="indexterm" id="IDX-CHP-12-0002"/></p><p>When you set out to reverse engineer any binary, the last thing that you want to do is waste time reverse engineering library functions whose behavior you could learn much more easily simply by reading a man page, reading some source code, or doing a little Internet research. The challenge presented by statically linked binaries is that they blur the distinction between application code and library code. In a statically linked binary, entire libraries are combined with application code to form a single monolithic executable file. Fortunately for us, tools are available that enable IDA to recognize and mark library code, allowing us to focus our attention on the unique code within the application.<a class="indexterm" id="IDX-CHP-12-0003"/><a class="indexterm" id="IDX-CHP-12-0004"/><a class="indexterm" id="IDX-CHP-12-0005"/><a class="indexterm" id="IDX-CHP-12-0006"/></p><div class="sect1" title="Fast Library Identification and Recognition Technology"><div class="titlepage"><div><div><h1 class="title"><a id="fast_library_identification_and_recognit"/>Fast Library Identification and Recognition Technology</h1></div></div></div><p>Fast Library Identification and Recognition Technology, better known as FLIRT,<sup>[<a class="footnote" href="#ftn.CHP-12-FN-2" id="CHP-12-FN-2">76</a>]</sup> encompasses the set of techniques employed by IDA to identify sequences of code as library code. At the heart of FLIRT are pattern-matching algorithms that enable IDA to quickly determine whether a disassembled function matches one of the many signatures known to IDA. The <span class="emphasis"><em>&lt;IDADIR&gt;/sig</em></span> directory contains the signature files that ship with IDA. For the most part, these are libraries that ship with common Windows compilers, though a few non-Windows signatures are also included.<a class="indexterm" id="IDX-CHP-12-0007"/></p><p>Signature files utilize a custom format in which the bulk of the signature data is compressed and wrapped in an IDA-specific header. In most cases, signature filenames do not clearly indicate which library the associated signatures were generated from. Depending on how they were created, signature files may contain a library name comment that describes their contents. If we view the first few lines of extracted ASCII content from a signature file, this comment is often revealed. The following Unix-style command<sup>[<a class="footnote" href="#ftn.CHP-12-FN-3" id="CHP-12-FN-3">77</a>]</sup> generally reveals the comment in the second or third line of output:</p><a id="I_programlisting2_d1e15685"/><pre class="programlisting"># strings <em class="replaceable"><code>sigfile</code></em> | head -n 3</pre><p>Within IDA, there are two ways to view comments associated with signature files. First, you can access the list of signatures that have been applied to a binary via View ▸ Open Subviews ▸ Signatures. Second, the list of all signature files is displayed as part of the manual signature application process, which is initiated via File ▸ Load File ▸ FLIRT Signature File.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-1" id="ftn.CHP-12-FN-1">75</a>] </sup>IDA generates this message in the Output window when it has finished its automated processing of a newly loaded binary.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-2" id="ftn.CHP-12-FN-2">76</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/flirt.htm">http://www.hex-rays.com/idapro/flirt.htm</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-3" id="ftn.CHP-12-FN-3">77</a>] </sup>The <code class="literal">strings</code> command was discussed in <a class="xref" href="ch02.html" title="Chapter 2. Reversing and Disassembly Tools">Chapter 2</a>, while the <code class="literal">head</code> command is used to view only the first few lines (three in the example) of its input source.</p></div></div></div>
<div class="sect1" title="Applying FLIRT Signatures"><div class="titlepage"><div><div><h1 class="title"><a id="applying_flirt_signatures"/>Applying FLIRT Signatures</h1></div></div></div><p>When a binary is first opened, IDA attempts to apply special signature files, designated as startup signatures, to the entry point of the binary. It turns out that the entry point code generated by various compilers is sufficiently unique that matching entry point signatures is a useful technique for identifying the compiler that may have been used to generate a given binary.</p><div class="sidebar"><a id="main_vs._underscore_start"/><p class="title">MAIN VS. _START</p><p>Recall that a program’s entry point is the address of the first instruction that will be executed. Many longtime C programmers incorrectly believe that this is the address of the function named <code class="literal">main</code>, when in fact it is not. The file type of the program, <span class="emphasis"><em>not</em></span> the language used to create the program, dictates the manner in which command-line arguments are provided to a program. In order to reconcile any differences between the way the loader presents command-line arguments and the way the program expects to receive them (via parameters to <code class="literal">main</code>, for example), some initialization code must execute prior to transferring control to <code class="literal">main</code>. It is this initialization that IDA designates as the entry point of the program and labels <code class="literal">_start</code>.<a class="indexterm" id="IDX-CHP-12-0008"/><a class="indexterm" id="IDX-CHP-12-0009"/><a class="indexterm" id="IDX-CHP-12-0010"/></p><p>This initialization code is also responsible for any initialization tasks that must take place before <code class="literal">main</code> is allowed to run. In a C++ program, this code is responsible for ensuring that constructors for globally declared objects are called prior to execution of <code class="literal">main</code>. Similarly, cleanup code is inserted that executes after <code class="literal">main</code> completes in order to invoke destructors for all global objects prior to the actual termination of the program.</p></div><p>If IDA identifies the compiler used to create a particular binary, then the signature file for the corresponding compiler libraries is loaded and applied to the remainder of the binary. The signatures that ship with IDA tend to be related to proprietary compilers such as Microsoft Visual C++ or Borland Delphi. The reason behind this is that a finite number of binary libraries ship with these compilers. For open source compilers, such as GNU gcc, the binary variations of the associated libraries are as numerous as the operating systems the compilers ship with. For example, each version of FreeBSD ships with a unique version of the C standard library. For optimal pattern matching, signature files would need to be generated for each version of the library. Consider the difficulty in collecting every variation of <span class="emphasis"><em>libc.a</em></span><sup>[<a class="footnote" href="#ftn.CHP-12-FN-4" id="CHP-12-FN-4">78</a>]</sup> that has shipped with every version of every Linux distribution. It simply is not practical. In part, these differences are due to changes in the library source code that result in different compiled code, but huge differences also result from the use of different compilation options, such as optimization settings and the use of different compiler versions to build the library. The net result is that IDA ships with very few signature files for open source compiler libraries. The good news, as you shall soon see, is that Hex-Rays makes tools available that allow you to generate your own signature files from static libraries.</p><p>So, under what circumstances might you be required to manually apply signatures to one of your databases? Occasionally IDA properly identifies the compiler used to build the binary but has no signatures for the related compiler libraries. In such cases, either you will need to live without signatures, or you will need to obtain copies of the static libraries used in the binary and generate your own signatures. Other times, IDA may simply fail to identify a compiler, making it impossible to determine which signatures should be applied to a database. This is common when analyzing obfuscated code in which the startup routines have been sufficiently mangled to preclude compiler identification. The first thing to do, then, would be to de-obfuscate the binary sufficiently before you could have any hope of matching library signatures. We will discuss techniques for dealing with obfuscated code in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>.<a class="indexterm" id="IDX-CHP-12-0011"/><a class="indexterm" id="IDX-CHP-12-0012"/><a class="indexterm" id="IDX-CHP-12-0013"/><a class="indexterm" id="IDX-CHP-12-0014"/><a class="indexterm" id="IDX-CHP-12-0015"/></p><p>Regardless of the reason, if you wish to manually apply signatures to a database, you do so via File ▸ Load File ▸ FLIRT Signature File, which opens the signature selection dialog shown in <a class="xref" href="ch12s02.html#flirt_signature_selection" title="Figure 12-1. FLIRT signature selection">Figure 12-1</a>.<a class="indexterm" id="IDX-CHP-12-0016"/></p><div class="figure"><a id="flirt_signature_selection"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15777"/><img alt="FLIRT signature selection" src="httpatomoreillycomsourcenostarchimages854237.png.jpg"/></div></div><p class="title">Figure 12-1. FLIRT signature selection</p></div><p>The File column reflects the name of each <span class="emphasis"><em>.sig</em></span> file in IDA’s <span class="emphasis"><em>&lt;IDADIR&gt;/sig</em></span> directory. Note that there is no means to specify an alternate location for <span class="emphasis"><em>.sig</em></span> files. If you ever generate your own signatures, they need to be placed into <span class="emphasis"><em>&lt;IDADIR&gt;/sig</em></span> along with every other <span class="emphasis"><em>.sig</em></span> file. The Library name column displays the library name comment that is embedded within each file. Keep in mind that these comments are only as descriptive as the creator of the signatures (which could be you!) chooses to make them.</p><p>When a library module is selected, the signatures contained in the corresponding <span class="emphasis"><em>.sig</em></span> file are loaded and compared against every function within the database. Only one set of signatures may be applied at a time, so you will need to repeat the process if you wish to apply several different signature files to a database. When a function is found to match a signature, the function is marked as a library function, and the function is automatically renamed according to the signature that has been matched.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Only functions named with an IDA dummy name can be automatically renamed. In other words, if you have renamed a function, and that function is later matched by a signature, then the function will not be renamed as a result of the match. Therefore, it is to your benefit to apply signatures as early in your analysis process as possible.</p></div><p>Recall that statically linked binaries blur the distinction between application code and library code. If you are fortunate enough to have a statically linked binary that has not had its symbols stripped, you will at least have useful function names (as useful as the trustworthy programmer has chosen to create) to help you sort your way through the code. However, if the binary has been stripped, you will have perhaps hundreds of functions, all with IDA-generated names that fail to indicate what the function does. In both cases, IDA will be able to identify library functions only if signatures are available (function names in an unstripped binary do not provide IDA with enough information to definitively identify a function as a library function). <a class="xref" href="ch12s02.html#statically_linked_with_no_signatures" title="Figure 12-2. Statically linked with no signatures">Figure 12-2</a> shows the Overview Navigator for a statically linked binary.<a class="indexterm" id="IDX-CHP-12-0017"/><a class="indexterm" id="IDX-CHP-12-0018"/><a class="indexterm" id="IDX-CHP-12-0019"/></p><div class="figure"><a id="statically_linked_with_no_signatures"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15824"/><img alt="Statically linked with no signatures" src="httpatomoreillycomsourcenostarchimages854239.png.jpg"/></div></div><p class="title">Figure 12-2. Statically linked with no signatures</p></div><p>In this display, no functions have been identified as library functions, so you may find yourself analyzing far more code than you really need to. After application of an appropriate set of signatures, the Overview Navigator is transformed as shown in <a class="xref" href="ch12s02.html#statically_linked_binary_with_signatures" title="Figure 12-3. Statically linked binary with signatures applied">Figure 12-3</a>.</p><div class="figure"><a id="statically_linked_binary_with_signatures"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15836"/><img alt="Statically linked binary with signatures applied" src="httpatomoreillycomsourcenostarchimages854241.png.jpg"/></div></div><p class="title">Figure 12-3. Statically linked binary with signatures applied</p></div><p>As you can see, the Overview Navigator provides the best indication of the effectiveness of a particular set of signatures. With a large percentage of matched signatures, substantial portions of code will be marked as library code and renamed accordingly. In the example in <a class="xref" href="ch12s02.html#statically_linked_binary_with_signatures" title="Figure 12-3. Statically linked binary with signatures applied">Figure 12-3</a>, it is highly likely that the actual application-specific code is concentrated in the far left portion of the navigator display.</p><p>There are two points worth remembering when applying signatures. First, signatures are useful even when working with a binary that has not been stripped, in which case you are using signatures more to help IDA identify library functions than to rename those functions. Second, statically linked binaries may be composed of several separate libraries, requiring the application of several sets of signatures in order to completely identify all library functions. With each additional signature application, additional portions of the Overview Navigator will be transformed to reflect the discovery of library code. <a class="xref" href="ch12s02.html#static_binary_with_first_of_several_sign" title="Figure 12-4. Static binary with first of several signatures applied">Figure 12-4</a> shows one such example. In this figure, you see a binary that was statically linked with both the C standard library and the OpenSSL<sup>[<a class="footnote" href="#ftn.CHP-12-FN-5" id="CHP-12-FN-5">79</a>]</sup> cryptographic library.</p><div class="figure"><a id="static_binary_with_first_of_several_sign"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15858"/><img alt="Static binary with first of several signatures applied" src="httpatomoreillycomsourcenostarchimages854243.png.jpg"/></div></div><p class="title">Figure 12-4. Static binary with first of several signatures applied</p></div><p>Specifically, you see that following application of the appropriate signatures for the version of OpenSSL in use in this application, IDA has marked a small band (the lighter band toward the left edge of the address range) as library code. Statically linked binaries are often created by taking the application code first and then appending required libraries to create the resulting executable. Given this picture, we can conclude that the memory space to the right of the OpenSSL library is likely occupied by additional library code, while the application code is most likely in the very narrow band to the left of the OpenSSL library. If we continue to apply signatures to the binary shown in <a class="xref" href="ch12s02.html#static_binary_with_first_of_several_sign" title="Figure 12-4. Static binary with first of several signatures applied">Figure 12-4</a>, we eventually arrive at the display of <a class="xref" href="ch12s02.html#static_binary_following_application_of_s" title="Figure 12-5. Static binary following application of several signatures">Figure 12-5</a>.<a class="indexterm" id="IDX-CHP-12-0020"/><a class="indexterm" id="IDX-CHP-12-0021"/><a class="indexterm" id="IDX-CHP-12-0022"/><a class="indexterm" id="IDX-CHP-12-0023"/></p><div class="figure"><a id="static_binary_following_application_of_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e15886"/><img alt="Static binary following application of several signatures" src="httpatomoreillycomsourcenostarchimages854245.png.jpg"/></div></div><p class="title">Figure 12-5. Static binary following application of several signatures</p></div><p>In this example, we have applied signatures for <span class="emphasis"><em>libc</em></span>, <span class="emphasis"><em>libcrypto</em></span>, <span class="emphasis"><em>libkrb5</em></span>, <span class="emphasis"><em>libresolv</em></span>, and others. In some cases we selected signatures based on strings located within the binary; in other cases we chose signatures based on their close relationship to other libraries already located within the binary. The resulting display continues to show a dark band in the middle of the navigation band and a smaller dark band at the extreme left edge of the navigation band. Further analysis is required to determine the nature of these remaining nonlibrary portions of the binary. In this case we would learn that the wider dark band in the middle is part of an unidentified library, while the dark band on the left is the application code.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-4" id="ftn.CHP-12-FN-4">78</a>] </sup><span class="emphasis"><em>libc.a</em></span> is the version of the C standard library used in statically linked binaries on Unix-style systems.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-5" id="ftn.CHP-12-FN-5">79</a>] </sup>See <a class="ulink" href="http://www.openssl.org/">http://www.openssl.org/</a>.</p></div></div></div>
<div class="sect1" title="Creating FLIRT Signature Files"><div class="titlepage"><div><div><h1 class="title"><a id="creating_flirt_signature_files"/>Creating FLIRT Signature Files</h1></div></div></div><p>As we discussed previously, it is simply impractical for IDA to ship with signature files for every static library in existence. In order to provide IDA users with the tools and information necessary to create their own signatures, Hex-Rays distributes the Fast Library Acquisition for Identification and Recognition (FLAIR) tool set. The FLAIR tools are made available on your IDA distribution CD or via download from the Hex-Rays website<sup>[<a class="footnote" href="#ftn.CHP-12-FN-6" id="CHP-12-FN-6">80</a>]</sup> for authorized customers. Like several other IDA add-ons, the FLAIR tools are distributed in a Zip file. Hex-Rays does not necessarily release a new version of the FLAIR tools with each version of IDA, so you should use the most recent version of FLAIR that does not exceed your version of IDA.<a class="indexterm" id="IDX-CHP-12-0024"/></p><p>Installation of the FLAIR utilities is a simple matter of extracting the contents of the associated Zip file, though we highly recommend that you create a dedicated <span class="emphasis"><em>flair</em></span> directory as the destination because the Zip file is not organized with a top-level directory. Inside the FLAIR distribution you will find several text files that constitute the documentation for the FLAIR tools. Files of particular interest include these:<a class="indexterm" id="IDX-CHP-12-0025"/><a class="indexterm" id="IDX-CHP-12-0026"/><a class="indexterm" id="IDX-CHP-12-0027"/><a class="indexterm" id="IDX-CHP-12-0028"/><a class="indexterm" id="IDX-CHP-12-0029"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>readme.txt</strong></span></span></dt><dd><p>This is a top-level overview of the signature-creation process.</p></dd><dt><span class="term"><span class="strong"><strong>plb.txt</strong></span></span></dt><dd><p>This file describes the use of the static library parser, <span class="emphasis"><em>plb.exe</em></span>. Library parsers are discussed in more detail in <a class="xref" href="ch12s03.html#creating_pattern_files" title="Creating Pattern Files">Creating Pattern Files</a> in <a class="xref" href="ch12s03.html#creating_pattern_files" title="Creating Pattern Files">Creating Pattern Files</a>.</p></dd><dt><span class="term"><span class="strong"><strong>pat.txt</strong></span></span></dt><dd><p>This file details the format of pattern files, which represent the first step in the signature-creation process. Pattern files are also described in <a class="xref" href="ch12s03.html#creating_pattern_files" title="Creating Pattern Files">Creating Pattern Files</a> in <a class="xref" href="ch12s03.html#creating_pattern_files" title="Creating Pattern Files">Creating Pattern Files</a>.</p></dd><dt><span class="term"><span class="strong"><strong>sigmake.txt</strong></span></span></dt><dd><p>This file describes the use of <span class="emphasis"><em>sigmake.exe</em></span> for generating <span class="emphasis"><em>.sig</em></span> files from pattern files. Please refer to <a class="xref" href="ch12s03.html#creating_signature_files" title="Creating Signature Files">Creating Signature Files</a> in <a class="xref" href="ch12s03.html#creating_signature_files" title="Creating Signature Files">Creating Signature Files</a> for more details.</p></dd></dl></div><p>Additional top-level content of interest includes the <span class="emphasis"><em>bin</em></span> directory, which contains all of the FLAIR tools executable files, and the <span class="emphasis"><em>startup</em></span> directory, which contains pattern files for common startup sequences associated with various compilers and their associated output file types (PE, ELF, and so on). Prior to version 6.1, the FLAIR tools area is available for Windows only; however, the resulting signature files may be used with all IDA variants (Windows, Linux, and OS X).</p><div class="sect2" title="Signature-Creation Overview"><div class="titlepage"><div><div><h2 class="title"><a id="signature-creation_overview"/>Signature-Creation Overview</h2></div></div></div><p>The basic process for creating signatures files does not seem complicated, as it boils down to four simple-sounding steps.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Obtain a copy of the static library for which you wish to create a signature file.</p></li><li class="listitem"><p>Utilize one of the FLAIR parsers to create a pattern file for the library.</p></li><li class="listitem"><p>Run <span class="emphasis"><em>sigmake.exe</em></span> to process the resulting pattern file and generate a signature file.</p></li><li class="listitem"><p>Install the new signature file in IDA by copying it to <span class="emphasis"><em>&lt;IDADIR&gt;/sig</em></span>.</p></li></ol></div><p>Unfortunately, in practice, only the last step is as easy as it sounds. In the following sections, we discuss the first three steps in more detail.</p></div><div class="sect2" title="Identifying and Acquiring Static Libraries"><div class="titlepage"><div><div><h2 class="title"><a id="identifying_and_acquiring_static_librari"/>Identifying and Acquiring Static Libraries</h2></div></div></div><p>The first step in the signature-generation process is to locate a copy of the static library for which you wish to generate signatures. This can pose a bit of a challenge for a variety of reasons. The first obstacle is to determine which library you actually need. If the binary you are analyzing has not been stripped, you might be lucky enough to have actual function names available in your disassembly, in which case an Internet search will probably provide several pointers to likely candidates.<a class="indexterm" id="IDX-CHP-12-0030"/><a class="indexterm" id="IDX-CHP-12-0031"/></p><p>Stripped binaries are not quite as forthcoming regarding their origins. Lacking function names, you may find that a good <code class="literal">strings</code> search may yield sufficiently unique strings to allow for library identification, such as the following, which is a dead giveaway:</p><a id="I_programlisting2_d1e16048"/><pre class="programlisting">OpenSSL 1.0.0b-fips 16 Nov 2010</pre><p>Copyright notices and error strings are often sufficiently unique that once again you can use an Internet search to narrow your candidates. If you choose to run <code class="literal">strings</code> from the command line, remember to use the <code class="literal">-a</code> option to force <code class="literal">strings</code> to scan the entire binary; otherwise you may miss some potentially useful string data.<a class="indexterm" id="IDX-CHP-12-0032"/><a class="indexterm" id="IDX-CHP-12-0033"/></p><p>In the case of open source libraries, you are likely to find source code readily available. Unfortunately, while the source code may be useful in helping you understand the behavior of the binary, you cannot use it to generate your signatures. It might be possible to use the source to build your own version of the static library and then use that version in the signature-generation process. However, in all likelihood, variations in the build process will result in enough differences between the resulting library and the library you are analyzing that any signatures you generate will not be terribly accurate.</p><p>The best option is to attempt to determine the exact origin of the binary in question. By this we mean the exact operating system, operating system version, and distribution (if applicable). Given this information, the best option for creating signatures is to copy the libraries in question from an identically configured system. Naturally, this leads to the next challenge: Given an arbitrary binary, on what system was it created? A good first step is to use the <code class="literal">file</code> utility to obtain some preliminary information about the binary in question. In <a class="xref" href="ch02.html" title="Chapter 2. Reversing and Disassembly Tools">Chapter 2</a> we saw some sample output from <code class="literal">file</code>. In several cases, this output was sufficient to provide likely candidate systems. The following is just one example of very specific output from <code class="literal">file</code>:</p><a id="I_programlisting2_d1e16082"/><pre class="programlisting">$ <strong class="userinput"><code>file sample_file_1</code></strong>
sample_file_1: ELF 32-bit LSB executable, Intel 80386, version 1 (FreeBSD),
statically linked, for FreeBSD 8.0 (800107), stripped</pre><p>In this case we might head straight to a FreeBSD 8.0 system and track down <span class="emphasis"><em>libc.a</em></span> for starters. The following example is somewhat more ambiguous, however:</p><a id="I_programlisting2_d1e16092"/><pre class="programlisting">$ <strong class="userinput"><code>file sample_file_2</code></strong>
sample_file_2: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux),
statically linked, for GNU/Linux 2.6.32, stripped</pre><p>We appear to have narrowed the source of the file to a Linux system, which, given the abundance of available Linux distributions, is not saying much. Turning to <code class="literal">strings</code> we find the following:<a class="indexterm" id="IDX-CHP-12-0034"/><a class="indexterm" id="IDX-CHP-12-0035"/><a class="indexterm" id="IDX-CHP-12-0036"/><a class="indexterm" id="IDX-CHP-12-0037"/></p><a id="I_programlisting2_d1e16119"/><pre class="programlisting">GCC: (GNU) 4.5.1 20100924 (Red Hat 4.5.1-4)</pre><p>Here the search has been narrowed to Red Hat distributions (or derivatives) that shipped with gcc version 4.5.1. GCC tags such as this are not uncommon in binaries compiled using gcc, and fortunately for us, they survive the stripping process and remain visible to <code class="literal">strings</code>.<a class="indexterm" id="IDX-CHP-12-0038"/><a class="indexterm" id="IDX-CHP-12-0039"/></p><p>Keep in mind that the <code class="literal">file</code> utility is not the be all and end all in file identification. The following output demonstrates a simple case in which <code class="literal">file</code> seems to know the type of the file being examined but for which the output is rather nonspecific.</p><a id="I_programlisting2_d1e16140"/><pre class="programlisting">$ <strong class="userinput"><code>file sample_file_3</code></strong>
sample_file_3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV),
dynamically linked (uses shared libs), stripped</pre><p>This example was taken from a Solaris 10 x86 system. Here again, the <code class="literal">strings</code> utility might be useful in pinpointing this fact.<a class="indexterm" id="IDX-CHP-12-0040"/></p></div><div class="sect2" title="Creating Pattern Files"><div class="titlepage"><div><div><h2 class="title"><a id="creating_pattern_files"/>Creating Pattern Files</h2></div></div></div><p>At this point you should have one or more libraries for which you wish to create signatures. The next step is to create a pattern file for each library. Pattern files are created using an appropriate FLAIR parser utility. Like executable files, library files are built to various file format specifications. FLAIR provides parsers for several popular library file formats. As detailed in FLAIR’s <span class="emphasis"><em>readme.txt</em></span> file, the following parsers can be found in FLAIR’s <span class="emphasis"><em>bin</em></span> directory:<a class="indexterm" id="IDX-CHP-12-0041"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>plb.exe/plb</strong></span></span></dt><dd><p>Parser for OMF libraries (commonly used by Borland compilers)<a class="indexterm" id="IDX-CHP-12-0042"/></p></dd><dt><span class="term"><span class="strong"><strong>pcf.exe/pcf</strong></span></span></dt><dd><p>Parser for COFF libraries (commonly used by Microsoft compilers)<a class="indexterm" id="IDX-CHP-12-0043"/></p></dd><dt><span class="term"><span class="strong"><strong>pelf.exe/pelf</strong></span></span></dt><dd><p>Parser for ELF libraries (found on many Unix systems)<a class="indexterm" id="IDX-CHP-12-0044"/></p></dd><dt><span class="term"><span class="strong"><strong>ppsx.exe/ppsx</strong></span></span></dt><dd><p>Parser for Sony PlayStation PSX libraries<a class="indexterm" id="IDX-CHP-12-0045"/></p></dd><dt><span class="term"><span class="strong"><strong>ptmobj.exe/ptmobj</strong></span></span></dt><dd><p>Parser for TriMedia libraries<a class="indexterm" id="IDX-CHP-12-0046"/></p></dd><dt><span class="term"><span class="strong"><strong>pomf166.exe/pomf166</strong></span></span></dt><dd><p>Parser for Kiel OMF 166 object files<a class="indexterm" id="IDX-CHP-12-0047"/></p></dd></dl></div><p>To create a pattern file for a given library, specify the parser that corresponds to the library’s format, the name of the library you wish to parse, and the name of the resulting pattern file that should be generated. For a copy of <span class="emphasis"><em>libc.a</em></span> from a FreeBSD 8.0 system, you might use the following:<a class="indexterm" id="IDX-CHP-12-0048"/><a class="indexterm" id="IDX-CHP-12-0049"/><a class="indexterm" id="IDX-CHP-12-0050"/><a class="indexterm" id="IDX-CHP-12-0051"/><a class="indexterm" id="IDX-CHP-12-0052"/><a class="indexterm" id="IDX-CHP-12-0053"/></p><a id="I_programlisting2_d1e16253"/><pre class="programlisting">$ <strong class="userinput"><code>./pelf libc.a libc_FreeBSD80.pat</code></strong>
libc.a: skipped 1, total 1089</pre><p>Here, the parser reports the file that was parsed (<span class="emphasis"><em>libc.a</em></span>), the number of functions that were skipped (1),<sup>[<a class="footnote" href="#ftn.CHP-12-FN-7" id="CHP-12-FN-7">81</a>]</sup> and the number of signature patterns that were generated (1089). Each parser accepts a slightly different set of command-line options documented only through the parser’s usage statement. Executing a parser with no arguments displays the list of command-line options accepted by that parser. The <span class="emphasis"><em>plb.txt</em></span> file contains more detailed information on the options accepted by the <span class="emphasis"><em>plb</em></span> parser. This file is a good basic source of information, since other parsers accept many of the options it describes as well. In many cases, simply naming the library to be parsed and the pattern file to be generated is sufficient.</p><p>A pattern file is a text file that contains, one per line, the extracted patterns that represent functions within a parsed library. A few lines from the pattern file created previously are shown here:</p><a id="I_programlisting2_d1e16275"/><pre class="programlisting">57568B7C240C8B742410FC8B4C2414C1E902F3A775108B4C241483E10
3F3A675 1E A55D 003E :0000 _memcmp
0FBC442404740340C39031C0C3...................................... 00
 0000 000D :0000 _ffs
57538B7C240C8B4C2410FC31C083F90F7E1B89FAF7DA83E20389CB29D389D1F3
 12 9E31 0032 :0000 _bzero</pre><p>The format of an individual pattern is described in FLAIR’s <span class="emphasis"><em>pat.txt</em></span> file. In a nutshell, the first portion of a pattern lists the initial byte sequence of the function to a maximum of 32 bytes. Allowance is made for bytes that may vary as a result of relocation entries. Such bytes are displayed using two dots. Dots are also used to fill the pattern out to 64 characters<sup>[<a class="footnote" href="#ftn.CHP-12-FN-8" id="CHP-12-FN-8">82</a>]</sup> when a function is shorter than 32 bytes (as <code class="literal">_ffs</code> is in the previous code). Beyond the initial 32 bytes, additional information is recorded to provide more precision in the signature-matching process. Additional information encoded into each pattern line includes a CRC16<sup>[<a class="footnote" href="#ftn.CHP-12-FN-9" id="CHP-12-FN-9">83</a>]</sup> value computed over a portion of the function, the length of the function in bytes, and a list of symbol names referenced by the function. In general, longer functions that reference many other symbols yield more complex pattern lines. In the file <span class="emphasis"><em>libc_FreeBSD80.pat</em></span> generated previously, some pattern lines exceed 20,000 characters in length.</p><p>Several third-party programmers have created utilities designed to generate patterns from existing IDA databases. One such utility is IDB_2_PAT,<sup>[<a class="footnote" href="#ftn.CHP-12-FN-10" id="CHP-12-FN-10">84</a>]</sup> an IDA plug-in written by J.C. Roberts that is capable of generating patterns for one or more functions in an existing database. Utilities such as these are useful if you expect to encounter similar code in additional databases and have no access to the original library files used to create the binary being analyzed.<a class="indexterm" id="IDX-CHP-12-0054"/><a class="indexterm" id="IDX-CHP-12-0055"/><a class="indexterm" id="IDX-CHP-12-0056"/><a class="indexterm" id="IDX-CHP-12-0057"/><a class="indexterm" id="IDX-CHP-12-0058"/><a class="indexterm" id="IDX-CHP-12-0059"/></p></div><div class="sect2" title="Creating Signature Files"><div class="titlepage"><div><div><h2 class="title"><a id="creating_signature_files"/>Creating Signature Files</h2></div></div></div><p>Once you have created a pattern file for a given library, the next step in the signature-creation process is to generate a <span class="emphasis"><em>.sig</em></span> file suitable for use with IDA. The format of an IDA signature file is substantially different from that of a pattern file. Signature files utilize a proprietary binary format designed both to minimize the amount of space required to represent all of the information present in a pattern file and to allow for efficient matching of signatures against actual database content. A high-level description of the structure of a signature file is available on the Hex-Rays website.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-11" id="CHP-12-FN-11">85</a>]</sup></p><p>FLAIR’s <span class="emphasis"><em>sigmake</em></span> utility is used to create signature files from pattern files. By splitting pattern generation and signature generation into two distinct phases, the signature-generation process is completely independent of the pattern-generation process, which allows for the use of third-party pattern generators. In its simplest form, signature generation takes place by using <span class="emphasis"><em>sigmake</em></span> to parse a <span class="emphasis"><em>.pat</em></span> file and create a <span class="emphasis"><em>.sig</em></span> file, as shown here:</p><a id="I_programlisting2_d1e16352"/><pre class="programlisting">$ <strong class="userinput"><code>./sigmake libssl.pat libssl.sig</code></strong></pre><p>If all goes well, a <span class="emphasis"><em>.sig</em></span> file is generated and ready to install into <span class="emphasis"><em>&lt;IDADIR&gt;/sig</em></span>. However, the process seldom runs that smoothly.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">sigmake</code> documentation file, <span class="emphasis"><em>sigmake.txt</em></span>, recommends that signature filenames follow the MS-DOS 8.3 name-length convention. This is not a hard-and-fast requirement, however. When longer filenames are used, only the first eight characters of the base filename are displayed in the signature-selection dialog.<a class="indexterm" id="IDX-CHP-12-0060"/></p></div><p>Signature generation is often an iterative process, as it is during this phase when <span class="emphasis"><em>collisions</em></span> must be handled. A collision occurs anytime two functions have identical patterns. If collisions are not resolved in some manner, it is not possible to determine which function is actually being matched during the signature-application process. Therefore, <code class="literal">sigmake</code> must be able to resolve each generated signature to exactly one function name. When this is not possible, based on the presence of identical patterns for one or more functions, <code class="literal">sigmake</code> refuses to generate a <span class="emphasis"><em>.sig</em></span> file and instead generates an <span class="emphasis"><em>exclusions file</em></span> (<span class="emphasis"><em>.exc</em></span>). A more typical first pass using <code class="literal">sigmake</code> and a new <span class="emphasis"><em>.pat</em></span> file (or set of <span class="emphasis"><em>.pat</em></span> files) might yield the following.<a class="indexterm" id="IDX-CHP-12-0061"/><a class="indexterm" id="IDX-CHP-12-0062"/><a class="indexterm" id="IDX-CHP-12-0063"/></p><a id="I_programlisting2_d1e16415"/><pre class="programlisting">$ ./sigmake libc_FreeBSD80.pat libc_FreeBSD80.sig
libc_FreeBSD80.sig: modules/leaves: 1088/1024, COLLISIONS: 10
See the documentation to learn how to resolve collisions.</pre><p>The documentation being referred to is <span class="emphasis"><em>sigmake.txt</em></span>, which describes the use of <code class="literal">sigmake</code> and the collision-resolution process. In reality, each time <code class="literal">sigmake</code> is executed, it searches for a corresponding exclusions file that might contain information on how to resolve any collisions that <code class="literal">sigmake</code> may encounter while processing the named pattern file. In the absence of such an exclusions file, and when collisions occur, <code class="literal">sigmake</code> generates such an exclusions file rather than a signature file. In the previous example, we would find a newly created file named <span class="emphasis"><em>libc_FreeBSD80.exc</em></span>. When first created, exclusions files are text files that detail the conflicts that <code class="literal">sigmake</code> encountered while processing the pattern file. The exclusions file must be edited to provide <code class="literal">sigmake</code> with guidance as to how it should resolve the conflicting patterns. The general process for editing an exclusions file follows.</p><p>When generated by <code class="literal">sigmake</code>, all exclusions files begin with the following lines:</p><a id="I_programlisting2_d1e16449"/><pre class="programlisting">;--------- (delete these lines to allow sigmake to read this file)
; add '+' at the start of a line to select a module
; add '−' if you are not sure about the selection
; do nothing if you want to exclude all modules</pre><p>The intent of these lines it to remind you what to do to resolve collisions before you can successfully generate signatures. The most important thing to do is delete the four lines that begin with semicolons, or <code class="literal">sigmake</code> will fail to parse the exclusions file during subsequent execution. The next step is to inform <code class="literal">sigmake</code> of your desire for collision resolution. A few lines extracted from <span class="emphasis"><em>libc_FreeBSD80.exc</em></span> appear here:</p><a id="I_programlisting2_d1e16463"/><pre class="programlisting">_index   00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............
_strchr  00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............
_rindex  00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........
_strrchr 00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........
_flsl    01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0
_fls     01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0</pre><p>These lines detail three separate collisions. In this case, we are being told that the function <code class="literal">index</code> is indistinguishable from <code class="literal">strchr</code>, <code class="literal">rindex</code> has the same signature as <code class="literal">strrchr</code>, and <code class="literal">flsl</code> collides with <code class="literal">fls</code>. If you are familiar with any of these functions, this result may not surprise you, as the colliding functions are essentially identical (for example, <code class="literal">index</code> and <code class="literal">strchr</code> perform the same action).</p><p>In order to leave you in control of your own destiny, <code class="literal">sigmake</code> expects you to designate no more than one function in each group as the proper function for the associated signature. You select a function by prefixing the name with a plus character (<code class="literal">+</code>) if you want the name applied anytime the corresponding signature is matched in a database or a minus character (<code class="literal">-</code>) if you simply want a comment added to the database whenever the corresponding signature is matched. If you do not want any names applied when the corresponding signature is matched in a database, then you do not add any characters. The following listing represents one possible way to provide a valid resolution for the three collisions noted previously:<a class="indexterm" id="IDX-CHP-12-0064"/></p><a id="I_programlisting2_d1e16506"/><pre class="programlisting">+_index   00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............
_strchr  00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............
_rindex  00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........
_strrchr 00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........
_flsl    01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0
-_fls     01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0</pre><p>In this case we elect to use the name <code class="literal">index</code> whenever the first signature is matched, do nothing at all when the second signature is matched, and have a comment about <code class="literal">fls</code> added when the third signature is matched. The following points are useful when attempting to resolve collisions:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>To perform minimal collision resolution, simply delete the four commented lines at the beginning of the exclusions file.</p></li><li class="listitem"><p>Never add a <code class="literal">+/-</code> to more than one function in a collision group.</p></li><li class="listitem"><p>If a collision group contains only a single function, <span class="emphasis"><em>do not</em></span> add a <code class="literal">+/-</code> in front of that function; simply leave it alone.</p></li><li class="listitem"><p>Subsequent failures of <code class="literal">sigmake</code> cause data, including comment lines, to be appended to any existing exclusions file. This extra data should be removed and the original data corrected (if the data was correct, <code class="literal">sigmake</code> would not have failed a second time) before rerunning <code class="literal">sigmake</code>.</p></li></ol></div><p>Once you have made appropriate changes to your exclusions file, you must save the file and rerun <code class="literal">sigmake</code> using the same command-line arguments that you used initially. The second time through, <code class="literal">sigmake</code> should locate, and abide by, your exclusions file, resulting in the successful generation of a <span class="emphasis"><em>.sig</em></span> file. Successful operation of <code class="literal">sigmake</code> is noted by the lack of error messages and the presence of a <span class="emphasis"><em>.sig</em></span> file, as shown here:</p><a id="I_programlisting2_d1e16564"/><pre class="programlisting">$ <strong class="userinput"><code>./sigmake libc_FreeBSD80.pat libc_FreeBSD80.sig</code></strong></pre><p>After a signature file has been successfully generated, you make it available to IDA by copying it to your <span class="emphasis"><em>&lt;IDADIR&gt;/sig</em></span> directory. Then your new signatures are available using File ▸ Load File ▸ FLIRT Signature File.</p><p>Note that we have purposefully glossed over all of the options that can be supplied to both the pattern generators and <code class="literal">sigmake</code>. A rundown of available options is provided in <span class="emphasis"><em>plb.txt</em></span> and <span class="emphasis"><em>sigmake.txt</em></span>. The only option we will make note of is the <code class="literal">-n</code> option used with <code class="literal">sigmake</code>. This option allows you to embed a descriptive name inside a generated signature file. This name is displayed during the signature-selection process (see <a class="xref" href="ch12s02.html#flirt_signature_selection" title="Figure 12-1. FLIRT signature selection">Figure 12-1</a>), and it can be very helpful when sorting through the list of available signatures. The following command line embeds the name string “FreeBSD 8.0 C standard library” within the generated signature file:<a class="indexterm" id="IDX-CHP-12-0065"/><a class="indexterm" id="IDX-CHP-12-0066"/><a class="indexterm" id="IDX-CHP-12-0067"/><a class="indexterm" id="IDX-CHP-12-0068"/><a class="indexterm" id="IDX-CHP-12-0069"/><a class="indexterm" id="IDX-CHP-12-0070"/><a class="indexterm" id="IDX-CHP-12-0071"/><a class="indexterm" id="IDX-CHP-12-0072"/><a class="indexterm" id="IDX-CHP-12-0073"/><a class="indexterm" id="IDX-CHP-12-0074"/></p><a id="I_programlisting2_d1e16627"/><pre class="programlisting">$ ./sigmake -n"FreeBSD 8.0 C standard library" libc_FreeBSD80.pat libc_FreeBSD80.sig</pre><p>As an alternative, library names can be specified using directives within exclusion files. However, since exclusion files may not be required in all signature-generation cases, the command-line option is generally more useful. For further details, please refer to <span class="emphasis"><em>sigmake.txt</em></span>.</p></div><div class="sect2" title="Startup Signatures"><div class="titlepage"><div><div><h2 class="title"><a id="startup_signatures"/>Startup Signatures</h2></div></div></div><p>IDA also recognizes a specialized form of signatures called <span class="emphasis"><em>startup signatures</em></span>. Startup signatures are applied when a binary is first loaded into a database in an attempt to identify the compiler that was used to create the binary. If IDA can identify the compiler used to build a binary, then additional signature files, associated with the identified compiler, are automatically loaded during the initial analysis of the binary.<a class="indexterm" id="IDX-CHP-12-0075"/><a class="indexterm" id="IDX-CHP-12-0076"/></p><p>Given that the compiler type is initially unknown when a file is first loaded, startup signatures are grouped by and selected according to the file type of the binary being loaded. For example, if a Windows PE binary is being loaded, then startup signatures specific to PE binaries are loaded in an effort to determine the compiler used to build the PE binary in question.</p><p>In order to generate startup signatures, <code class="literal">sigmake</code> processes patterns that describe the startup routine<sup>[<a class="footnote" href="#ftn.CHP-12-FN-12" id="CHP-12-FN-12">86</a>]</sup> generated by various compilers and groups the resulting signatures into a single type-specific signature file. The <code class="literal">startup</code> directory in the FLAIR distribution contains the startup patterns used by IDA, along with the script, <span class="emphasis"><em>startup.bat</em></span>, used to create the corresponding startup signatures from those patterns. Refer to <span class="emphasis"><em>startup.bat</em></span> for examples of using <code class="literal">sigmake</code> to create startup signatures for a specific file format.<a class="indexterm" id="IDX-CHP-12-0077"/></p><p>In the case of PE files, you would notice several <span class="emphasis"><em>pe_*.pat</em></span> files in the startup directory that describe startup patterns used by several popular Windows compilers, including <span class="emphasis"><em>pe_vc.pat</em></span> for Visual Studio patterns and <span class="emphasis"><em>pe_gcc.pat</em></span> for Cygwin/gcc patterns. If you wish to add additional startup patterns for PE files, you would need to add them to one of the existing PE pattern files or create a new pattern file with a <code class="literal">pe_</code> prefix in order for the startup signature-generation script to properly find your patterns and incorporate them into the newly generated PE signatures.</p><p>One last note about startup patterns concerns their format, which unfortunately is slightly different from patterns generated for library functions. The difference lies in the fact that a startup pattern line is capable of relating the pattern to additional sets of signatures that should also be applied if a match against the pattern is made. Other than the example startup patterns included in the <span class="emphasis"><em>startup</em></span> directory, the format of a startup pattern is not documented in any of the text files included with FLAIR.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-6" id="ftn.CHP-12-FN-6">80</a>] </sup>The current version is <span class="emphasis"><em>flair61.zip</em></span> and is available here: <a class="ulink" href="http://www.hex-rays.com/idapro/ida/flair61.zip">http://www.hex-rays.com/idapro/ida/flair61.zip</a>. A username and password supplied by Hex-Rays are required to access the download.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-7" id="ftn.CHP-12-FN-7">81</a>] </sup>The plb and pcf parsers may skip some functions depending on the command-line options supplied to the parsers and the structure of the library being parsed.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-8" id="ftn.CHP-12-FN-8">82</a>] </sup>At two characters per byte, 64 hexadecimal characters are required to display the contents of 32 bytes.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-9" id="ftn.CHP-12-FN-9">83</a>] </sup>This is a 16-bit cyclic redundancy check value. The CRC16 implementation utilized for pattern generation is included with the FLAIR tool distribution in the file <span class="emphasis"><em>crc16.cpp</em></span>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-10" id="ftn.CHP-12-FN-10">84</a>] </sup>See <a class="ulink" href="http://www.openrce.org/downloads/details/26/IDB_2_PAT">http://www.openrce.org/downloads/details/26/IDB_2_PAT</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-11" id="ftn.CHP-12-FN-11">85</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/flirt.htm">http://www.hex-rays.com/idapro/flirt.htm</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-12" id="ftn.CHP-12-FN-12">86</a>] </sup>The startup routine is generally designated as the program’s entry point. In a C/C++ program, the purpose of the startup routine is to initialize the program’s environment prior to passing control to the <code class="literal">main</code> function.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id11"/>Summary</h1></div></div></div><p>Automated library code identification is an essential capability that significantly reduces the amount of time required to analyze statically linked binaries. With its FLIRT and FLAIR capabilities, IDA makes such automated code recognition not only possible but extensible by allowing users to create their own library signatures from existing static libraries. Familiarity with the signature-generation process is an essential skill for anyone who expects to encounter statically linked binaries.</p></div>
<div class="chapter" title="Chapter&#xA0;13.&#xA0;Extending IDA&#x2019;s Knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="extending_idaas_knowledge"/>Chapter 13. Extending IDA’s Knowledge</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id13"/><div class="mediaobject"><a id="I_mediaobject3_d1e16708"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>By now it should be clear that a high-quality disassembly is much more than a list of mnemonics and operands derived from a sequence of bytes. In order to make a disassembly useful, it is important to augment the disassembly with information derived from the processing of various API-related data such as function prototypes and standard datatypes. In <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a> we discussed IDA’s handling of data structures, including how to access standard API data structures and how to define your own custom data structures. In this chapter, we continue our discussion of extending IDA’s knowledge by examining the use of IDA’s <code class="literal">idsutils</code> and <code class="literal">loadint</code> utilities. These utilities are available on your IDA distribution CD or via download at the Hex-Rays download site.<sup>[<a class="footnote" href="#ftn.CHP-13-FN-1" id="CHP-13-FN-1">87</a>]</sup></p><div class="sect1" title="Augmenting Function Information"><div class="titlepage"><div><div><h1 class="title"><a id="augmenting_function_information"/>Augmenting Function Information</h1></div></div></div><p>IDA derives its knowledge of functions from two sources: type library (<span class="emphasis"><em>.til</em></span>) files and IDS utilities (<span class="emphasis"><em>.ids</em></span>) files. During the initial analysis phase, IDA uses information stored in these files to both improve the accuracy of the disassembly and make the disassembly more readable. It does so by incorporating function parameter names and types as well as comments that have been associated with various library functions.<a class="indexterm" id="IDX-CHP-13-0001"/><a class="indexterm" id="IDX-CHP-13-0002"/><a class="indexterm" id="IDX-CHP-13-0003"/><a class="indexterm" id="IDX-CHP-13-0004"/><a class="indexterm" id="IDX-CHP-13-0005"/></p><p>In <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a> we discussed type library files as the mechanism by which IDA stores the layout of complex data structures. Type library files are also the means by which IDA records information about a function’s calling conventions and parameter sequence. IDA uses function signature information in several ways. First, when a binary uses shared libraries, IDA has no way to know what calling conventions may be employed by the functions in those libraries. In such cases, IDA attempts to match library functions against their associated signatures in a type library file. If a matching signature is found, IDA can understand the calling convention used by the function and make adjustments to the stack pointer as necessary (recall that <code class="literal">stdcall</code> functions perform their own stack cleanup). The second use for function signatures is to annotate the parameters being passed to a function with comments that denote exactly which parameter is being pushed on the stack prior to calling the function. The amount of information present in the comment depends on how much information was present in the function signature that IDA was able to parse. The two signatures that follow are both legal C declarations, though the second provides more insight into the function, as it provides formal parameter names in addition to datatypes.<a class="indexterm" id="IDX-CHP-13-0006"/><a class="indexterm" id="IDX-CHP-13-0007"/><a class="indexterm" id="IDX-CHP-13-0008"/></p><a id="I_programlisting3_d1e16774"/><pre class="programlisting">LSTATUS _stdcall RegOpenKey(HKEY, LPCTSTR, PHKEY);
LSTATUS _stdcall RegOpenKey(HKEY hKey, LPCTSTR lpSubKey, PHKEY phkResult);</pre><p>IDA’s type libraries contain signature information for a large number of common API functions, including a substantial portion of the Windows API. A default disassembly of a call to the <code class="literal">RegOpenKey</code> function is shown here:</p><a id="I_programlisting3_d1e16781"/><pre class="programlisting">.text:00401006   00C      lea     eax, [ebp+<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>hKey]
.text:00401009   00C      push    eax            <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>; phkResult
.text:0040100A   010      push    offset <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>SubKey   ; "Software\\Hex-Rays\\IDA"
.text:0040100F   014      push    80000001h      <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>; hKey
.text:00401014   018      call    ds:RegOpenKeyA
.text:0040101A <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>00C       mov     [ebp+var_8], eax</pre><p>Note that IDA has added comments in the right margin <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e16815"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, indicating which parameter is being pushed at each instruction leading up to the call to <code class="literal">RegOpenKey</code>. When formal parameter names are available in the function signature, IDA attempts to go one step further and automatically name variables that correspond to specific parameters. In two cases in the preceding example <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e16824"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, we can see that IDA has named a local variable (<code class="literal">hKey</code>) and a global variable (<code class="literal">SubKey</code>) based on their correspondence with formal parameters in the <code class="literal">RegOpenKey</code> prototype. If the parsed function prototype had contained only type information and no formal parameter names, then the comments in the preceding example would name the datatypes of the corresponding arguments rather than the parameter names. In the case of the <code class="literal">lpSubKey</code> parameter, the parameter name is not displayed as a comment because the parameter happens to point to a global string variable, and the content of the string is being displayed using IDA’s repeating comment facility. Finally, note that IDA has recognized <code class="literal">RegOpenKey</code> as a <code class="literal">stdcall</code> function and automatically adjusted the stack pointer <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e16849"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> as <code class="literal">RegOpenKey</code> would do upon returning. All of this information is extracted from the function’s signature, which IDA also displays as a comment within the disassembly at the appropriate import table location, as shown in the following listing:<a class="indexterm" id="IDX-CHP-13-0009"/><a class="indexterm" id="IDX-CHP-13-0010"/><a class="indexterm" id="IDX-CHP-13-0011"/><a class="indexterm" id="IDX-CHP-13-0012"/><a class="indexterm" id="IDX-CHP-13-0013"/></p><a id="I_programlisting3_d1e16876"/><pre class="programlisting">.idata:0040A000 ; LSTATUS __stdcall RegOpenKeyA(HKEY hKey,
 LPCSTR lpSubKey, PHKEY phkResult)
.idata:0040A000                 extrn RegOpenKeyA:dword ; CODE XREF: _main+14p
.idata:0040A000                                         ; DATA XREF: _main+14r</pre><p>The comment displaying the function prototype comes from an IDA .<span class="emphasis"><em>til</em></span> file containing information on Windows API functions.</p><p>Under what circumstances might you wish to generate your own function type signatures?<sup>[<a class="footnote" href="#ftn.CHP-13-FN-2" id="CHP-13-FN-2">88</a>]</sup> Whenever you encounter a binary that is linked, either dynamically or statically, to a library for which IDA has no function prototype information, you may want to generate type signature information for all of the functions contained in that library in order to provide IDA with the ability to automatically annotate your disassembly. Examples of such libraries might include common graphics or encryption libraries that are not part of a standard Windows distribution but that might be in widespread use. The OpenSSL cryptographic library is one example of such a library.<a class="indexterm" id="IDX-CHP-13-0014"/><a class="indexterm" id="IDX-CHP-13-0015"/></p><p>Just as we were able to add complex datatype information to a database’s local .<span class="emphasis"><em>til</em></span> file in <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>, we can add function prototype information to that same .<span class="emphasis"><em>til</em></span> file by having IDA parse one or more function prototypes via File ▸ Load File▸ Parse C Header File. Similarly, you may use <span class="emphasis"><em>tilib.exe</em></span> (see <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a>) to parse header files and create standalone <span class="emphasis"><em>.til</em></span> files, which can be made globally available by copying them into <span class="emphasis"><em>&lt;IDADIR&gt;/til</em></span>.</p><p>This is all well and good when you happen to have access to source code that you then allow IDA (or <span class="emphasis"><em>tilib.exe</em></span>)to parse on your behalf. Unfortunately, more often than you would like, you will have no access to source code, yet you will want the same high-quality disassembly. How can you go about educating IDA if you have no source code for it to consume? This is the precisely the purpose of the IDS utilities, or <code class="literal">idsutils</code>. The IDS utilities are a set of three utility programs used to create .<span class="emphasis"><em>ids</em></span> files. We first discuss what a .<span class="emphasis"><em>ids</em></span> file is and then turn our attention to creating our own .<span class="emphasis"><em>ids</em></span> files.<a class="indexterm" id="IDX-CHP-13-0016"/></p><div class="sidebar"><a id="manually_overriding_purged_bytes"/><p class="title">MANUALLY OVERRIDING PURGED BYTES</p><p>Library functions that make use of the <code class="literal">stdcall</code> calling convention can wreak havoc with IDA’s stack-pointer analysis. Lacking any type library or <span class="emphasis"><em>.ids</em></span> file information, IDA has no way of knowing whether an imported function uses the <code class="literal">stdcall</code> convention. This is significant, as IDA may not be able to properly track the behavior of the stack pointer across calls to functions for which it has no calling convention information. Beyond knowing that a function utilizes <code class="literal">stdcall</code>, IDA must also know exactly how many bytes the function removes from the stack when the function completes. Lacking information on calling conventions, IDA attempts to automatically determine whether a function utilizes <code class="literal">stdcall</code> using a mathematical analysis technique known as the <span class="emphasis"><em>simplex</em></span> method.<sup>[<a class="footnote" href="#ftn.CHP-13-FN-3" id="CHP-13-FN-3">89</a>]</sup> Alternatively, users may intervene manually to specify the number of purged bytes themselves. <a class="xref" href="ch13.html#editing_an_imported_function" title="Figure 13-1. Editing an imported function">Figure 13-1</a> shows a specialized form of the function editing dialog used for imported functions.<a class="indexterm" id="IDX-CHP-13-0017"/><a class="indexterm" id="IDX-CHP-13-0018"/><a class="indexterm" id="IDX-CHP-13-0019"/><a class="indexterm" id="IDX-CHP-13-0020"/><a class="indexterm" id="IDX-CHP-13-0021"/><a class="indexterm" id="IDX-CHP-13-0022"/><a class="indexterm" id="IDX-CHP-13-0023"/><a class="indexterm" id="IDX-CHP-13-0024"/><a class="indexterm" id="IDX-CHP-13-0025"/><a class="indexterm" id="IDX-CHP-13-0026"/><a class="indexterm" id="IDX-CHP-13-0027"/><a class="indexterm" id="IDX-CHP-13-0028"/><a class="indexterm" id="IDX-CHP-13-0029"/></p><div class="figure"><a id="editing_an_imported_function"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e17025"/><img alt="Editing an imported function" src="httpatomoreillycomsourcenostarchimages854247.png.jpg"/></div></div><p class="title">Figure 13-1. Editing an imported function</p></div><p>You can access this dialog by navigating to the import table entry for a given function and then editing the function (Edit ▸ Functions ▸ Edit Function, or <span class="keycap">alt</span>-P). Note the limited functionality of this particular dialog (as opposed to the Edit Function dialog of <a class="xref" href="ch07s03.html#function_editing_dialog" title="Figure 7-7. Function editing dialog">Figure 7-7</a>). Because this is an imported function entry, IDA has no access to the compiled body of the function and therefore no associated information regarding the structure of the function’s stack frame and no direct evidence that the function uses the <code class="literal">stdcall</code> convention. Lacking such information, IDA sets the Purged bytes field to −1, indicating that it does not know whether the function clears any bytes from the stack upon return. To override IDA in such cases, enter the correct value for the number of purged bytes, and IDA will incorporate the provided information into its stack-pointer analysis wherever the associated function is called. In cases for which IDA is aware of the behavior of the function (as in <a class="xref" href="ch13.html#editing_an_imported_function" title="Figure 13-1. Editing an imported function">Figure 13-1</a>), the Purged bytes field may already be filled in. Note that this field is never filled in as a result of simplex method analysis.<a class="indexterm" id="IDX-CHP-13-0030"/></p></div><div class="sect2" title="IDS Files"><div class="titlepage"><div><div><h2 class="title"><a id="ids_files"/>IDS Files</h2></div></div></div><p>IDA uses .<span class="emphasis"><em>ids</em></span> files to supplement its knowledge of library functions. A .<span class="emphasis"><em>ids</em></span> file describes the content of a shared library by listing every exported function contained within the library. Information detailed for each function includes the function’s name, its associated ordinal number,<sup>[<a class="footnote" href="#ftn.CHP-13-FN-4" id="CHP-13-FN-4">90</a>]</sup> whether the function utilizes <code class="literal">stdcall</code>, and if so, how many bytes the function clears from the stack upon return, and optional comments to be displayed when the function is referenced within a disassembly. In practice, .<span class="emphasis"><em>ids</em></span> files are actually compressed .<span class="emphasis"><em>idt</em></span> files, with .<span class="emphasis"><em>idt</em></span> files containing the textual descriptions of each library function.<a class="indexterm" id="IDX-CHP-13-0031"/><a class="indexterm" id="IDX-CHP-13-0032"/><a class="indexterm" id="IDX-CHP-13-0033"/><a class="indexterm" id="IDX-CHP-13-0034"/><a class="indexterm" id="IDX-CHP-13-0035"/></p><p>When an executable file is first loaded into a database, IDA determines which shared library files the executable depends on. For each shared library, IDA searches for a corresponding .<span class="emphasis"><em>ids</em></span> file in the <span class="emphasis"><em>&lt;IDADIR&gt;/ids</em></span> hierarchy in order to obtain descriptions of any library functions that the executable may reference. It is important to understand that .<span class="emphasis"><em>ids</em></span> files do not necessarily contain function signature information. Therefore, IDA may not provide function parameter analysis based on information contained solely in .<span class="emphasis"><em>ids</em></span> files. IDA can, however, perform accurate stack pointer accounting when a .<span class="emphasis"><em>ids</em></span> file contains correct information concerning the calling conventions employed by functions and the number of bytes that the functions clear from the stack. In situations where a DLL exports mangled names, IDA may be able to infer a function’s parameter signature from the mangled name, in which case this information becomes available when the .<span class="emphasis"><em>ids</em></span> file is loaded. We describe the syntax of .<span class="emphasis"><em>idt</em></span> files in the next section. In this regard, .<span class="emphasis"><em>til</em></span> files contain more useful information with respect to disassembling function calls, though source code is required in order to generate .<span class="emphasis"><em>til</em></span> files.</p></div><div class="sect2" title="Creating IDS Files"><div class="titlepage"><div><div><h2 class="title"><a id="creating_ids_files"/>Creating IDS Files</h2></div></div></div><p>IDA’s <code class="literal">idsutils</code> utilities are used to create .<span class="emphasis"><em>ids</em></span> files. The utilities include two library parsers, <span class="emphasis"><em>dll2idt</em></span> for extracting information from Windows DLLs and <span class="emphasis"><em>ar2idt</em></span> for extracting information from ar-style libraries. In both cases, the output is a text .<span class="emphasis"><em>idt</em></span> file containing a single line per exported function that maps the exported function’s ordinal number to the function’s name. The syntax for .<span class="emphasis"><em>idt</em></span> files, which is very straightforward, is described in the <span class="emphasis"><em>readme.txt</em></span> file included with <code class="literal">idsutils</code>. The majority of lines in a .<span class="emphasis"><em>idt</em></span> file are used to describe exported functions according to the following scheme:<a class="indexterm" id="IDX-CHP-13-0036"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An export entry begins with a positive number. This number represents the ordinal number of the exported function.<a class="indexterm" id="IDX-CHP-13-0037"/></p></li><li class="listitem"><p>The ordinal number is followed by a space and then a <code class="literal">Name</code> directive in the form <code class="literal">Name=</code><em class="replaceable"><code>function</code></em>, for example, <code class="literal">Name=RegOpenKeyA</code>. If the special ordinal value zero is used, then the <code class="literal">Name</code> directive is used to specify the name of the library described in the current .<span class="emphasis"><em>idt</em></span> file, such as in this example:</p><a id="I_programlisting3_d1e17186"/><pre class="programlisting">0 Name=advapi32.dll</pre></li><li class="listitem"><p>An optional <code class="literal">Pascal</code> directive may be used to specify that a function uses the <code class="literal">stdcall</code> calling convention and to indicate how many bytes the function removes from the stack upon return. Here is an example:</p><a id="I_programlisting3_d1e17197"/><pre class="programlisting">483 Name=RegOpenKeyA Pascal=12</pre></li><li class="listitem"><p>An optional <code class="literal">Comment</code> directive can be appended to an export entry to specify a comment to be displayed with the function at each reference to the function within a disassembly. A completed export entry might look like the following:<a class="indexterm" id="IDX-CHP-13-0038"/><a class="indexterm" id="IDX-CHP-13-0039"/><a class="indexterm" id="IDX-CHP-13-0040"/></p><a id="I_programlisting3_d1e17214"/><pre class="programlisting">483 Name=RegOpenKeyA Pascal=12 Comment=Open a registry key</pre></li></ul></div><p>Additional, optional directives are described in the <code class="literal">idsutils</code> <span class="emphasis"><em>readme.txt</em></span> file. The purpose of the <code class="literal">idsutils</code> parsing utilities is to automate, as much as possible, the creation of .<span class="emphasis"><em>idt</em></span> files. The first step in creating a .<span class="emphasis"><em>idt</em></span> file is to obtain a copy of the library that you wish to parse; the next step is to parse it using the appropriate parsing utility. If we wished to create a .<span class="emphasis"><em>idt</em></span> file for the OpenSSL -related library <span class="emphasis"><em>ssleay32.dll</em></span>, we would use the following command:</p><a id="I_programlisting3_d1e17240"/><pre class="programlisting">$ <strong class="userinput"><code>./dll2idt.exe ssleay32.dll</code></strong>
Convert DLL to IDT file. Copyright 1997 by Yury Haron. Version 1.5
File: ssleay32.dll   ... ok</pre><p>Successful parsing in this case results in a file named <span class="emphasis"><em>SSLEAY32.idt</em></span>. The difference in capitalization between the input filename and the output filename is due to the fact that <span class="emphasis"><em>dll2idt</em></span> derives the name of the output file based on information contained within the DLL itself. The first few lines of the resulting .<span class="emphasis"><em>idt</em></span> file are shown here:</p><a id="I_programlisting3_d1e17256"/><pre class="programlisting">ALIGNMENT 4
;DECLARATION
;
0 Name=SSLEAY32.dll
;
121 Name=BIO_f_ssl
173 Name=BIO_new_buffer_ssl_connect
122 Name=BIO_new_ssl
174 Name=BIO_new_ssl_connect
124 Name=BIO_ssl_copy_session_id</pre><p>Note that it is not possible for the parsers to determine whether a function uses <code class="literal">stdcall</code> and, if so, how many bytes are purged from the stack. The addition of any <code class="literal">Pascal</code> or <code class="literal">Comment</code> directives must be performed manually using a text editor prior to creating the final .<span class="emphasis"><em>ids</em></span> file. The final steps for creating a .<span class="emphasis"><em>ids</em></span> are to use the <span class="emphasis"><em>zipids</em></span> utility to compress the .<span class="emphasis"><em>idt</em></span> file and then to copy the resulting .<span class="emphasis"><em>ids</em></span> file to <span class="emphasis"><em>&lt;IDADIR&gt;/ids</em></span>.</p><a id="I_programlisting3_d1e17288"/><pre class="programlisting">$ <strong class="userinput"><code>./zipids.exe SSLEAY32.idt</code></strong>
File: SSLEAY32.idt   ... {219 entries [0/0/0]}          packed
$ cp SSLEAY32.ids ../Ida/ids</pre><p>At this point, IDA loads <span class="emphasis"><em>SSLEAY32.ids</em></span> anytime a binary that links to <span class="emphasis"><em>ssleay32.dll</em></span> is loaded. If you elect not to copy your newly created .<span class="emphasis"><em>ids</em></span> files into <span class="emphasis"><em>&lt;IDADIR&gt;/ids</em></span>, you can load them at any time via File ▸ Load File ▸ IDS File.</p><p>An additional step in the use of .<span class="emphasis"><em>ids</em></span> files allows you to link .<span class="emphasis"><em>ids</em></span> files to specific .<span class="emphasis"><em>sig</em></span> or .<span class="emphasis"><em>til</em></span> files. When you choose .<span class="emphasis"><em>ids</em></span> files, IDA utilizes an IDS configuration file named <span class="emphasis"><em>&lt;IDADIR&gt;/ida/idsnames</em></span>. This text file contains lines to allow for the following:<a class="indexterm" id="IDX-CHP-13-0041"/><a class="indexterm" id="IDX-CHP-13-0042"/><a class="indexterm" id="IDX-CHP-13-0043"/><a class="indexterm" id="IDX-CHP-13-0044"/><a class="indexterm" id="IDX-CHP-13-0045"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Map a shared library name to its corresponding .<span class="emphasis"><em>ids</em></span> filename. This allows IDA to locate the correct .<span class="emphasis"><em>ids</em></span> file when a shared library name does not translate neatly to an MS-DOS-style 8.3 filename as with the following:</p><a id="I_programlisting3_d1e17356"/><pre class="programlisting">libc.so.6     libc.ids      +</pre></li><li class="listitem"><p>Map a .<span class="emphasis"><em>ids</em></span> file to a .<span class="emphasis"><em>til</em></span> file. In such cases, IDA automatically loads the specified .<span class="emphasis"><em>til</em></span> file whenever it loads the specified .<span class="emphasis"><em>ids</em></span> file. The following example would cause <span class="emphasis"><em>openssl.til</em></span> to be loaded anytime <span class="emphasis"><em>SSLEAY32.ids</em></span> is loaded (see <code class="literal">idsnames</code> for syntax details):<a class="indexterm" id="IDX-CHP-13-0046"/></p><a id="I_programlisting3_d1e17388"/><pre class="programlisting">SSLEAY32.ids    SSLEAY32.ids      +   openssl.til</pre></li><li class="listitem"><p>Map a .<span class="emphasis"><em>sig</em></span> file to a corresponding .<span class="emphasis"><em>ids</em></span> file. In this case, IDA loads the indicated .<span class="emphasis"><em>ids</em></span> file anytime the named .<span class="emphasis"><em>sig</em></span> file is applied to a disassembly. The following line directs IDA to load <span class="emphasis"><em>SSLEAY32.ids</em></span> anytime a user applies the <span class="emphasis"><em>libssl.sig</em></span> FLIRT signature:</p><a id="I_programlisting3_d1e17412"/><pre class="programlisting">libssl.sig      SSLEAY32.ids      +</pre></li></ul></div><p>In <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a> we will look at a script-oriented alternative to the library parsers provided by <code class="literal">idsutils</code>, and we’ll leverage IDA’s function-analysis capabilities to generate more descriptive .<span class="emphasis"><em>idt</em></span> files.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-1" id="ftn.CHP-13-FN-1">87</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/idadown.htm">http://www.hex-rays.com/idapro/idadown.htm</a>. A valid IDA username and password are required.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-2" id="ftn.CHP-13-FN-2">88</a>] </sup>In this case we are using the term <span class="emphasis"><em>signature</em></span> to refer to a function’s parameter type(s), quantity, and sequence rather than a pattern of code to match the compiled function.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-3" id="ftn.CHP-13-FN-3">89</a>] </sup>Use of the simplex method as introduced in IDA version 5.1 is described in a blog post by Ilfak here: <a class="ulink" href="http://www.hexblog.com/2006/06/">http://www.hexblog.com/2006/06/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-4" id="ftn.CHP-13-FN-4">90</a>] </sup>An <span class="emphasis"><em>ordinal number</em></span> is an integer index associated with each exported function. The use of ordinals allows a function to be located using an integer lookup table rather than by a slower string comparison against the function’s name.</p></div></div></div>
<div class="sect1" title="Augmenting Predefined Comments with loadint"><div class="titlepage"><div><div><h1 class="title"><a id="augmenting_predefined_comments_with_load"/>Augmenting Predefined Comments with loadint</h1></div></div></div><p>In <a class="xref" href="ch07.html" title="Chapter 7. Disassembly Manipulation">Chapter 7</a> we covered IDA’s concept of <span class="emphasis"><em>auto comments</em></span>, which, when enabled, cause IDA to display comments describing each assembly language instruction. Two examples of such comments are shown in the following listing:<a class="indexterm" id="IDX-CHP-13-0047"/></p><a id="I_programlisting3_d1e17437"/><pre class="programlisting">.text:08048654                 lea     ecx, [esp+arg_0] ; Load Effective Address
.text:08048658                 and     esp, 0FFFFFFF0h ; Logical AND</pre><p>The source of these predefined comments is the file <span class="emphasis"><em>&lt;IDADIR&gt;/ida.int</em></span>, which contains comments sorted first by CPU type and second by instruction type. When auto comments are turned on, IDA searches for comments associated with each instruction in the disassembly and displays them in the right margin if they are present in <span class="emphasis"><em>ida.int</em></span>.</p><p>The <code class="literal">loadint</code><sup>[<a class="footnote" href="#ftn.CHP-13-FN-5" id="CHP-13-FN-5">91</a>]</sup> utilities provide you with the ability to modify existing comments or add new comments to <span class="emphasis"><em>ida.int</em></span>. As with the other add-on utilities we have discussed, <code class="literal">loadint</code> is documented in a <span class="emphasis"><em>readme.txt</em></span> file included with the <code class="literal">loadint</code> distribution. The <code class="literal">loadint</code> distribution also contains the predefined comments for all of IDA’s processor modules in the form of numerous .<span class="emphasis"><em>cmt</em></span> files. Modifying existing comments is a simple matter of locating the comment file associated with your processor of interest (for example, <span class="emphasis"><em>pc.cmt</em></span> for x86), making changes to any comments whose text you wish to modify, running <span class="emphasis"><em>loadint</em></span> to re-create the <span class="emphasis"><em>ida.int</em></span> comment file, and finally copying the resulting <span class="emphasis"><em>ida.int</em></span> file into your main IDA directory, where it will be loaded the next time IDA is launched. A simple run to rebuild the comment database looks like the following:<a class="indexterm" id="IDX-CHP-13-0048"/><a class="indexterm" id="IDX-CHP-13-0049"/><a class="indexterm" id="IDX-CHP-13-0050"/><a class="indexterm" id="IDX-CHP-13-0051"/><a class="indexterm" id="IDX-CHP-13-0052"/></p><a id="I_programlisting3_d1e17505"/><pre class="programlisting">$ <strong class="userinput"><code>./loadint comment.cmt ida.int</code></strong>
Comment base loader. Version 2.04. Copyright (c) 1991-2011 Hex-Rays

17566 cases, 17033 strings, total length: 580575</pre><p>Examples of changes that you might wish to make include modifying existing comments or enabling comments for instructions that have no assigned comment. In the <span class="emphasis"><em>pc.cmt</em></span> file, for example, several of the more common instructions are commented out so as not to generate too many comments when auto comments are enabled. The following lines, extracted from <span class="emphasis"><em>pc.cmt</em></span>, demonstrate that x86 <code class="literal">mov</code> instructions do not generate comments by default:</p><a id="I_programlisting3_d1e17521"/><pre class="programlisting">NN_ltr:                 "Load Task Register"
//NN_mov:               "Move Data"
NN_movsp:               "Move to/from Special Registers"</pre><p>Should you wish to enable comments for <code class="literal">mov</code> instructions, you would uncomment the middle line and rebuild the comment database as detailed previously.</p><p>A note buried within the documentation for <code class="literal">loadint</code> points out that <span class="emphasis"><em>loadint</em></span> must be able to locate the file <span class="emphasis"><em>ida.hlp</em></span>, which is included with your IDA distribution. If you receive the following error message, you should copy <span class="emphasis"><em>ida.hlp</em></span> into your <span class="emphasis"><em>loadint</em></span> directory and then rerun <span class="emphasis"><em>loadint</em></span>.</p><a id="I_programlisting3_d1e17549"/><pre class="programlisting">$ <strong class="userinput"><code>./loadint comment.cmt ida.int</code></strong>
Comment base loader. Version 2.04. Copyright (c) 1991-2011 Hex-Rays
Can't initialize help system.
File name: 'ida.hlp', Reason: can't find file (take it from IDA distribution).</pre><p>Alternatively, you may use the <code class="literal">-n</code> switch with <code class="literal">loadint</code> to specify the location of <code class="literal">&lt;IDADIR&gt;</code>, as shown in the following command line:</p><a id="I_programlisting3_d1e17566"/><pre class="programlisting">$ ./loadint -n &lt;IDADIR&gt; comment.cmt ida.int</pre><p>The file <span class="emphasis"><em>comment.cmt</em></span> serves as the master input file to the <code class="literal">loadint</code> process. The syntax for this file is described in the <code class="literal">loadint</code> documentation. In a nutshell, <span class="emphasis"><em>comment.cmt</em></span> creates the mappings from processor types to associated comment files. Individual processor-specific comment files in turn specify the mappings from specific instructions to the associated comment text for each instruction. The entire process is governed by several sets of enumerated (C-style enums) constants that define all of the processor types (found in <span class="emphasis"><em>comment.cmt</em></span>) and all of the possible instructions for each processor (found in <span class="emphasis"><em>allins.hpp</em></span>).<a class="indexterm" id="IDX-CHP-13-0053"/></p><p>If you want to add predefined comments for a completely new processor type, the process is somewhat more involved than simply changing existing comments and is fairly closely linked to the process for creating new processor modules (see <a class="xref" href="ch19.html" title="Chapter 19. IDA Processor Modules">Chapter 19</a>). Without diving too deeply into processor modules, providing comments for a completely new processor type requires that you first create a new enumerated constant set (shared with your processor module) within <span class="emphasis"><em>allins.hpp</em></span> that defines one constant for each instruction in the instruction set of interest. Second, you must create a comment file that maps each enumerated instruction constant to its associated comment text. Third, you must define a new constant for your processor type (again, shared with your processor module) and create an entry in <span class="emphasis"><em>comment.cmt</em></span> that maps your processor type to its associated comment file. Once you have completed these steps, you must run <span class="emphasis"><em>loadint</em></span> to build a new comment database that incorporates your new processor type and associated comments.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-5" id="ftn.CHP-13-FN-5">91</a>] </sup>The current version is <span class="emphasis"><em>loadint61.zip</em></span>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id12"/>Summary</h1></div></div></div><p>While <code class="literal">idsutils</code> and <code class="literal">loadint</code> may not seem immediately useful to you, you will learn to appreciate their capabilities once you begin to step outside IDA’s more common use cases. For a relatively small investment of time, the creation of a single .<span class="emphasis"><em>ids</em></span> or .<span class="emphasis"><em>til</em></span> file can save you countless hours whenever you encounter the libraries described by those files in future projects. Keep in mind that it is not possible for IDA to ship with descriptions for every library in existence. The intended purpose of the tools covered in this chapter is to provide you with the flexibility to address gaps in IDA’s library coverage whenever you stray off IDA’s beaten path.</p></div>
<div class="chapter" title="Chapter&#xA0;14.&#xA0;Patching Binaries and Other IDA Limitations"><div class="titlepage"><div><div><h1 class="title"><a id="patching_binaries_and_other_ida_limitati"/>Chapter 14. Patching Binaries and Other IDA Limitations</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id14"/><div class="mediaobject"><a id="I_mediaobject4_d1e17626"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>One of the most frequently asked questions by new or prospective IDA users is “How can I use IDA to patch binaries?” The simple answer is “You can’t.” IDA’s intended purpose is to assist you in understanding the behavior of a binary by offering you the best disassembly possible. IDA is not designed to make it easy for you to modify the binaries you are examining. Not wanting to take no for an answer, die-hard patchers often follow up with questions such as “What about the Edit ▸ Patch Program menu?” and “What is the purpose of File ▸ Produce File ▸ Create EXE File?” In this chapter we discuss these apparent anomalies and see if we can’t coax IDA into helping us, at least a little bit, with developing patches for binary program files.<a class="indexterm" id="IDX-CHP-14-0001"/></p><div class="sect1" title="The Infamous Patch Program Menu"><div class="titlepage"><div><div><h1 class="title"><a id="the_infamous_patch_program_menu"/>The Infamous Patch Program Menu</h1></div></div></div><p>First mentioned in <a class="xref" href="ch11.html" title="Chapter 11. Customizing IDA">Chapter 11</a>, the Edit ▸ Patch Program menu is a hidden feature in the GUI version of IDA that must be enabled by editing the <span class="emphasis"><em>idagui.cfg</em></span> configuration file (the Patch menu is available by default in console versions of IDA). <a class="xref" href="ch14.html#the_patch_program_submenu" title="Figure 14-1. The Patch Program submenu">Figure 14-1</a> shows the options available on the Edit ▸ Patch Program submenu.<a class="indexterm" id="IDX-CHP-14-0002"/><a class="indexterm" id="IDX-CHP-14-0003"/><a class="indexterm" id="IDX-CHP-14-0004"/><a class="indexterm" id="IDX-CHP-14-0005"/><a class="indexterm" id="IDX-CHP-14-0006"/><a class="indexterm" id="IDX-CHP-14-0007"/></p><div class="figure"><a id="the_patch_program_submenu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e17674"/><img alt="The Patch Program submenu" src="httpatomoreillycomsourcenostarchimages854250.png.jpg"/></div></div><p class="title">Figure 14-1. The Patch Program submenu</p></div><p>Each of the submenu items teases you with the notion that you are going to be able to modify the binary in potentially interesting ways. In actuality, what these options offer are three different ways to modify the database. In fact, these menu items, perhaps more than any others, make perfectly clear the distinction between an IDA database and the binary file from which the database was created. Once a database is created, IDA never references the original binary. Given its true behavior, this menu item would be more aptly named <span class="emphasis"><em>Patch Database</em></span>.</p><p>All is not completely lost, however, as the menu options in <a class="xref" href="ch14.html#the_patch_program_submenu" title="Figure 14-1. The Patch Program submenu">Figure 14-1</a> do offer you the easiest way to observe the effect of any changes that you might eventually make to the original binary. Later in this chapter you will learn how to export the changes you have made and eventually use that information to patch the original binary.</p><div class="sect2" title="Changing Individual Database Bytes"><div class="titlepage"><div><div><h2 class="title"><a id="changing_individual_database_bytes"/>Changing Individual Database Bytes</h2></div></div></div><p>The Edit ▸ Patch Program ▸ Change Byte menu option is used to edit one or more byte values within an IDA database. <a class="xref" href="ch14.html#the_patch_bytes_dialog" title="Figure 14-2. The Patch Bytes dialog">Figure 14-2</a> shows the related byte-editing dialog.</p><div class="figure"><a id="the_patch_bytes_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e17698"/><img alt="The Patch Bytes dialog" src="httpatomoreillycomsourcenostarchimages854253.png.jpg"/></div></div><p class="title">Figure 14-2. The Patch Bytes dialog</p></div><p>The dialog displays 16-byte values beginning at the current cursor location. You may change some or all of the displayed bytes, but you cannot make changes beyond the 16th byte without closing the dialog, repositioning the cursor to a new location farther into the database, and reopening the dialog. Note that the dialog displays the virtual address and the file offset value for the bytes that you are changing. This File offset value reflects the hexa-decimal offset at which the bytes reside within the original binary file. The fact that IDA retains the original file offset information for every byte in the database will be useful if you do wish to develop a patch for the original binary. Finally, regardless of the number of changes that have been made to the bytes in the database, the Original value field of the dialog always displays the original byte values loaded into the database. There is no automated capability for reverting changes to their original byte values, though it is possible to create an IDA script to perform such a task.<a class="indexterm" id="IDX-CHP-14-0008"/><a class="indexterm" id="IDX-CHP-14-0009"/><a class="indexterm" id="IDX-CHP-14-0010"/><a class="indexterm" id="IDX-CHP-14-0011"/><a class="indexterm" id="IDX-CHP-14-0012"/><a class="indexterm" id="IDX-CHP-14-0013"/></p><p>A better method for editing database bytes was introduced in IDA 5.5 in the form of a more capable Hex View window (see <a class="xref" href="ch05.html" title="Chapter 5. IDA Data Displays">Chapter 5</a>). With an integrated hex-editing capability, there is little need to use IDA’s change bytes capability.</p></div><div class="sect2" title="Changing a Word in the Database"><div class="titlepage"><div><div><h2 class="title"><a id="changing_a_word_in_the_database"/>Changing a Word in the Database</h2></div></div></div><p>Somewhat less useful than the byte-patching capability is IDA’s word-patching capability. <a class="xref" href="ch14.html#the_patch_word_dialog" title="Figure 14-3. The Patch Word dialog">Figure 14-3</a> shows IDA’s Patch Word dialog, which is capable of patching only one 2-byte word at a time.<a class="indexterm" id="IDX-CHP-14-0014"/><a class="indexterm" id="IDX-CHP-14-0015"/></p><div class="figure"><a id="the_patch_word_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e17747"/><img alt="The Patch Word dialog" src="httpatomoreillycomsourcenostarchimages854256.png.jpg"/></div></div><p class="title">Figure 14-3. The Patch Word dialog</p></div><p>As with the byte-patching dialog, the virtual address and file offset are displayed. An important point to remember is that the word value is displayed using the natural byte ordering of the underlying processor. For example, in an x86 disassembly, words are treated as little-endian values, while in a MIPS disassembly, words are treated as big-endian values. Keep this in mind when entering new word values. As with the byte-patching dialog, the Original value field always displays the initial value loaded from the original binary file regardless of the number of times the word value may have been modified using the word-patching dialog. As with byte editing, it may be easier to perform your editing within IDA’s Hex View window.</p></div><div class="sect2" title="Using the Assemble Dialog"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_assemble_dialog"/>Using the Assemble Dialog</h2></div></div></div><p>Perhaps the most interesting capability accessible from the Patch Program menu is the Assemble option (Edit ▸ Patch Program ▸ Assemble). Unfortunately, this capability is not available for all processor types, as it relies on the presence of an internal assembler capability within the current processor module. For example, the x86 processor module is known to support assembly, while the MIPS processor module is known not to support assembly. When an assembler is not available, you will receive an error message stating, “Sorry, this processor module doesn’t support the assembler.”<a class="indexterm" id="IDX-CHP-14-0016"/><a class="indexterm" id="IDX-CHP-14-0017"/><a class="indexterm" id="IDX-CHP-14-0018"/><a class="indexterm" id="IDX-CHP-14-0019"/><a class="indexterm" id="IDX-CHP-14-0020"/></p><p>The Assemble option allows you to enter assembly language statements that are assembled using an internal assembler. The resulting instruction bytes are then written to the current screen location. <a class="xref" href="ch14.html#the_assemble_instruction_dialog" title="Figure 14-4. The Assemble Instruction dialog">Figure 14-4</a> shows the Assemble Instruction dialog used for instruction entry.</p><div class="figure"><a id="the_assemble_instruction_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e17781"/><img alt="The Assemble Instruction dialog" src="httpatomoreillycomsourcenostarchimages854259.png.jpg"/></div></div><p class="title">Figure 14-4. The Assemble Instruction dialog</p></div><p>You can enter one instruction at a time into the Instruction field. The assembler component for IDA’s x86 processor module accepts the same syntax used in x86 disassembly listings. When you click OK (or press <span class="keycap">enter</span>), your instruction is assembled, and the corresponding instruction bytes are entered into the database beginning at the virtual address displayed in the Address field. The internal IDA assembler allows you to use symbolic names within your instructions as long as those names exist within the program. Syntax such as <code class="literal">mov [ebp+var_4], eax</code> and <code class="literal">call sub_401896</code> is perfectly legal, and the assembler will correctly resolve symbolic references.</p><p>Following entry of an instruction, the dialog remains open and ready to accept a new instruction at the virtual address immediately following the previously entered instruction. While you enter additional instructions, the dialog displays the previous instruction entered in the Previous line field.</p><p>When entering new instructions, you must pay attention to instruction alignment, especially when the instruction that you are entering is a different length than the instruction it is replacing. When a new instruction is shorter than the instruction it is replacing, you need to consider what to do with the excess bytes left over from the old instruction (inserting NOP<sup>[<a class="footnote" href="#ftn.CHP-14-FN-1" id="CHP-14-FN-1">92</a>]</sup> instructions is one possible option). When a new instruction is longer than the instruction that it is replacing, IDA will overwrite as many bytes of subsequent instructions as is required to fit the new instruction. This may or may not be the behavior you want, which is why careful planning is necessary before using the assembler to modify program bytes. One way to view the assembler is as a word processor that is stuck in overwrite mode. There is no easy way to open up space to insert new instructions without overwriting existing instructions.</p><p>It is important to remember that IDA’s database-patching capabilities are limited to small, simple patches that easily fit into existing space within the database. If you have a patch that requires substantial additional space, you will need to locate space that is allocated within the original binary but not used by the binary. Such space is often present in the form of padding, inserted by compilers to align sections of a binary to particular file boundaries. For example, in many Windows PE files, individual program sections must begin at file offsets that are multiples of 512 bytes. When a section does not consume an even multiple of 512 bytes of space, that section must be padded within the file in order to maintain a 512-byte boundary for the next section. The following lines from a disassembled PE file demonstrate this situation:<a class="indexterm" id="IDX-CHP-14-0021"/><a class="indexterm" id="IDX-CHP-14-0022"/></p><a id="I_programlisting4_d1e17818"/><pre class="programlisting">.text:0040963E     ; [00000006 BYTES: COLLAPSED FUNCTION
 RtlUnwind. PRESS KEYPAD "+" TO EXPAND]
.text:00409644                    <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>align 200h
.text:00409644     _text           ends
.text:00409644
.idata:0040A000     ; Section 2. (virtual address 0000A000)</pre><p>In this case, IDA is using an align directive <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e17828"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> to indicate that the section is padded to a 512-byte (<code class="literal">200h</code>) boundary beginning from address <code class="literal">.text:00409644</code>. The upper end of the padding is the next multiple of 512 bytes, or <code class="literal">.text:00409800</code>. The padded area is generally filled with zeros by the compiler and stands out quite prominently in hex view. In this particular binary, there is space within the file to insert up to 444 (0x1BC = 409800h – 409644h) bytes of patched program data, which would overwrite some or all of the zero padding at the end of the <code class="literal">.text</code> section. You might patch a function to jump to this area of the binary, execute the newly inserted program instructions, and then jump back to the original function.</p><p>Note that the next section in the binary, the <code class="literal">.idata</code> section, does not actually begin until address <code class="literal">.idata:0040A000</code>. This is a result of a memory- (not file-) alignment restriction that requires PE sections to begin in 4Kb (one memory page) boundaries. In theory it should be possible to inject an additional 2,048 bytes of patched data into the memory range <code class="literal">00409800-0040A000</code>. The difficulty in doing so lies in the fact that no bytes corresponding to this memory range are present within the disk image of the executable. In order to use this space, we would need to perform more than a simple overwrite of portions of the original binary file. First we would need to insert a 2,048-byte block of data between the end of the existing <code class="literal">.text</code> section and the beginning of the <code class="literal">.idata</code> section. Second, we would need to adjust the size of the <code class="literal">.text</code> section within the PE file headers. Finally, we’d need to adjust the location of <code class="literal">.idata</code> and all subsequent sections within the PE headers to reflect the fact that all following sections are now located 2,048 bytes deeper into the file. These changes may not sound terribly complicated, but they require some attention to detail and a good working knowledge of the PE file format.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-1" id="ftn.CHP-14-FN-1">92</a>] </sup><span class="emphasis"><em>NOP</em></span> stands for <span class="emphasis"><em>no operation</em></span> and is an instruction often used simply to fill in space in a program.</p></div></div></div>
<div class="sect1" title="IDA Output Files and Patch Generation"><div class="titlepage"><div><div><h1 class="title"><a id="ida_output_files_and_patch_generation"/>IDA Output Files and Patch Generation</h1></div></div></div><p>One of the more interesting menu options in IDA is the File ▸ Produce File menu. According to the options on this menu, IDA can generate MAP, ASM, INC, LST, EXE, DIF, and HTML files. Many of these sound intriguing, so each is described in the following sections.<a class="indexterm" id="IDX-CHP-14-0023"/><a class="indexterm" id="IDX-CHP-14-0024"/></p><div class="sect2" title="IDA-Generated MAP Files"><div class="titlepage"><div><div><h2 class="title"><a id="ida-generated_map_files"/>IDA-Generated MAP Files</h2></div></div></div><p>A <span class="emphasis"><em>.map</em></span> file describes the overall layout of a binary, including information about the sections that make up the binary and the location of symbols within each section. When generating a <span class="emphasis"><em>.map</em></span> file, you are asked for the name of the file you wish to create and the types of symbols you would like to store in the <span class="emphasis"><em>.map</em></span> file. <a class="xref" href="ch14s02.html#map_file-generation_options" title="Figure 14-5. MAP file-generation options">Figure 14-5</a> shows the MAP file options dialog, in which you select the information you wish to include in the <span class="emphasis"><em>.map</em></span> file.<a class="indexterm" id="IDX-CHP-14-0025"/><a class="indexterm" id="IDX-CHP-14-0026"/><a class="indexterm" id="IDX-CHP-14-0027"/><a class="indexterm" id="IDX-CHP-14-0028"/><a class="indexterm" id="IDX-CHP-14-0029"/><a class="indexterm" id="IDX-CHP-14-0030"/></p><div class="figure"><a id="map_file-generation_options"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e17936"/><img alt="MAP file-generation options" src="httpatomoreillycomsourcenostarchimages854262.png.jpg"/></div></div><p class="title">Figure 14-5. MAP file-generation options</p></div><p>Address information in a <span class="emphasis"><em>.map</em></span> file is represented using <span class="emphasis"><em>logical addresses</em></span>. A logical address describes a symbol’s location using a segment number and a segment offset. The first few lines of a simple <span class="emphasis"><em>.map</em></span> file are shown in the following listing. In this listing we show three segments and the first two of many symbols. The logical address of <code class="literal">_fprintf</code> indicates that it resides at byte offset <code class="literal">69h</code> within the first (<code class="literal">.text</code>) segment.<a class="indexterm" id="IDX-CHP-14-0031"/></p><a id="I_programlisting4_d1e17965"/><pre class="programlisting">Start         Length     Name                   Class
 0001:00000000 000008644H .text                  CODE
 0002:00000000 000001DD6H .rdata                 DATA
 0003:00000000 000002B84H .data                  DATA

  Address         Publics by Value

 0001:00000000       _main
 0001:00000069       _fprintf</pre><p>MAP files generated by IDA are compatible with Borland’s Turbo Debugger. The principle purpose of <span class="emphasis"><em>.map</em></span> files is to assist in restoring symbol names when debugging binaries that may have been stripped.</p></div><div class="sect2" title="IDA-Generated ASM Files"><div class="titlepage"><div><div><h2 class="title"><a id="ida-generated_asm_files"/>IDA-Generated ASM Files</h2></div></div></div><p>IDA can generate a <span class="emphasis"><em>.asm</em></span> file from the current database. The general idea is to create a file that could be run through an assembler to re-create the underlying binary file. IDA attempts to dump enough information, including such things as structure layouts, to make successful assembly possible. Whether you will be able to successfully assemble the generated <span class="emphasis"><em>.asm</em></span> file depends on a number of factors, not the least of which is whether your particular assembler understands the syntax IDA uses.<a class="indexterm" id="IDX-CHP-14-0032"/><a class="indexterm" id="IDX-CHP-14-0033"/><a class="indexterm" id="IDX-CHP-14-0034"/><a class="indexterm" id="IDX-CHP-14-0035"/><a class="indexterm" id="IDX-CHP-14-0036"/><a class="indexterm" id="IDX-CHP-14-0037"/><a class="indexterm" id="IDX-CHP-14-0038"/><a class="indexterm" id="IDX-CHP-14-0039"/><a class="indexterm" id="IDX-CHP-14-0040"/><a class="indexterm" id="IDX-CHP-14-0041"/><a class="indexterm" id="IDX-CHP-14-0042"/><a class="indexterm" id="IDX-CHP-14-0043"/><a class="indexterm" id="IDX-CHP-14-0044"/><a class="indexterm" id="IDX-CHP-14-0045"/></p><p>The target assembly language syntax is determined by the Target assembler setting found on the Analysis tab under the Options ▸ General menu. By default IDA generates an assembly file representing the entire database. However, you may limit the scope of the listing by clicking and dragging or using <span class="keycap">shift</span>-up arrow or <span class="keycap">shift</span>-down arrow to scroll and select the region you wish to dump. In console versions of IDA, you would utilize the <code class="literal">Anchor</code> (<span class="keycap">alt</span>-L) command to set an anchor point at the start of a selection region and then use the arrow keys to extend the size of the region.<a class="indexterm" id="IDX-CHP-14-0046"/><a class="indexterm" id="IDX-CHP-14-0047"/></p></div><div class="sect2" title="IDA-Generated INC Files"><div class="titlepage"><div><div><h2 class="title"><a id="ida-generated_inc_files"/>IDA-Generated INC Files</h2></div></div></div><p>An INC (include) file contains definitions of data structures and enumerated datatypes. This is essentially a dump of the contents of the Structures windows in a form suitable for consumption by an assembler.</p></div><div class="sect2" title="IDA-Generated LST Files"><div class="titlepage"><div><div><h2 class="title"><a id="ida-generated_lst_files"/>IDA-Generated LST Files</h2></div></div></div><p>An LST file is nothing more than a text file dump of the contents of the IDA disassembly window. You can narrow the scope of the generating listing by selecting a range of addresses to dump, as described previously for ASM files.</p></div><div class="sect2" title="IDA-Generated EXE Files"><div class="titlepage"><div><div><h2 class="title"><a id="ida-generated_exe_files"/>IDA-Generated EXE Files</h2></div></div></div><p>While this is the most promising menu option, it unfortunately is also the most crippled. In a nutshell, it doesn’t work for most file types, and you can expect to receive an error message stating, “This type of output file is not supported.”</p><p>While this would be an ideal capability for a patcher, in general it is very difficult to regenerate executable files from an IDA database. The information that you are presented with in an IDA database is comprised primarily of the contents of the sections that make up the original input file. In many cases, however, IDA does not process every section of an input file, and certain information is lost when the file is loaded into the database, making generation of an executable from the database impossible. The simplest example of such loss is the fact that IDA does not load the resource (<code class="literal">.rsrc</code>) section of PE files by default, which makes restoration of the resource section from the database impossible.</p><p>In other cases, IDA processes information from the original binary but does not make it easily accessible in its original form. Examples include symbol tables, import tables, and export tables, which would require a fair amount of effort to properly reconstruct in order to generate a functional executable file.</p><p>One effort to provide an EXE-generation capability for IDA is the pe_scripts<sup>[<a class="footnote" href="#ftn.CHP-14-FN-2" id="CHP-14-FN-2">93</a>]</sup> of Atli Mar Gudmundsson. These are a set of IDA scripts for working with PE files. One of the scripts is titled <span class="emphasis"><em>pe_write.idc</em></span>, and its goal is to dump a working PE image out of an existing database. If you intend to patch a PE file, the proper sequence of events for using the scripts is as follows:<a class="indexterm" id="IDX-CHP-14-0048"/><a class="indexterm" id="IDX-CHP-14-0049"/><a class="indexterm" id="IDX-CHP-14-0050"/><a class="indexterm" id="IDX-CHP-14-0051"/><a class="indexterm" id="IDX-CHP-14-0052"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Load the desired PE file into IDA. Make sure that you uncheck the <span class="strong"><strong>Make imports section</strong></span> option in the loader dialog.</p></li><li class="listitem"><p>Run the included <span class="emphasis"><em>pe_sections.idc</em></span> script to map all sections from the original binary into the new database.</p></li><li class="listitem"><p>Make any desired changes to the database.</p></li><li class="listitem"><p>Execute the <span class="emphasis"><em>pe_write.idc</em></span> script to dump the database contents to a new PE file.</p></li></ol></div><p>Scripting with IDC is the subject of <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>.</p></div><div class="sect2" title="IDA-Generated DIF Files"><div class="titlepage"><div><div><h2 class="title"><a id="ida-generated_dif_files"/>IDA-Generated DIF Files</h2></div></div></div><p>An IDA DIF file is a plaintext file that lists all bytes that have been modified within an IDA database. This is the most useful file format if your goal is to patch an original binary based on changes made to an IDA database. The format of the file is quite simple, as shown in the example <span class="emphasis"><em>.dif</em></span> file here:</p><a id="I_programlisting4_d1e18152"/><pre class="programlisting">This difference file is created by The Interactive Disassembler

dif_example.exe
000002F8: 83 FF
000002F9: EC 75
000002FA: 04 EC
000002FB: FF 68</pre><p>The file includes a one-line header comment followed by the name of the original binary file and then a list of bytes within the file that have changed. Each change line specifies the file offset (not virtual address) of the changed byte, the original value of the byte, and the current value of the byte within the database. In this example, the database for <span class="emphasis"><em>dif_example.exe</em></span> has been modified at four locations corresponding to byte offsets <code class="literal">0x2F8</code>–<code class="literal">0x2FB</code> within the original file. It is a trivial task to write a program to parse IDA <span class="emphasis"><em>.dif</em></span> files and apply the changes to the original binary file to generate a patched version of the binary. One such utility is available at the companion website for this book.<sup>[<a class="footnote" href="#ftn.CHP-14-FN-3" id="CHP-14-FN-3">94</a>]</sup></p></div><div class="sect2" title="IDA-Generated HTML Files"><div class="titlepage"><div><div><h2 class="title"><a id="ida-generated_html_files"/>IDA-Generated HTML Files</h2></div></div></div><p>IDA takes advantage of the markup capabilities available with HTML in order to generate colorized disassembly listings. An IDA-generated HTML file is essentially an LST file with HTML tags added to produce a listing that is colored similarly to the actual IDA disassembly window. Unfortunately, the generated HTML files do not contain any hyperlinks that would make navigating the file any easier than if one used a standard text listing. For example, one useful feature would be the addition of hyperlinks to all name references, which would make following name references as simple as following a link.<a class="indexterm" id="IDX-CHP-14-0053"/><a class="indexterm" id="IDX-CHP-14-0054"/><a class="indexterm" id="IDX-CHP-14-0055"/><a class="indexterm" id="IDX-CHP-14-0056"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-2" id="ftn.CHP-14-FN-2">93</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip">http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-3" id="ftn.CHP-14-FN-3">94</a>] </sup>See <a class="ulink" href="http://www.idabook.com/chapter14/ida_patcher.c">http://www.idabook.com/chapter14/ida_patcher.c</a>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id13"/>Summary</h1></div></div></div><p>IDA is not a binary file editor. Keep that fact in mind anytime you think about patching a binary with IDA. However, it is a particularly good tool for helping you enter and visualize potential changes. By familiarizing yourself with IDA’s full range of features and combining the information that IDA can generate with appropriate scripts or external programs, binary patching easily becomes possible.</p><p>In the coming chapters, we will cover the many ways in which IDA’s capabilities can be extended. For anyone interested in making the most out of IDA’s capabilities, basic scripting skills and an understanding of IDA’s plug-in architecture are essential, as they offer you the capability to add behaviors wherever you feel IDA is lacking.</p></div></body></html>