<html><head></head><body><div class="part" title="Part&#xA0;I.&#xA0;Lisp is Power"><div class="titlepage"><div><div><h1 class="title"><a id="lisp_is_power"/>Part I. Lisp is Power</h1></div></div></div><div class="partintro" title="Lisp is Power" id="id2800707"><div/><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject_d1e531"/><img src="httpatomoreillycomsourcenostarchimages703119.png.jpg" alt="image with no caption"/></div></div></div></div>
<div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="getting_started_with_lisp"/>Chapter 1. Getting Started with Lisp</h1></div></div></div><p>This chapter begins with an introduction to the various dia lects of Lisp. Then we’ll talk a bit about ANSI Common Lisp, the dialect that we’ll be using in this book. Finally, you’ll get started by installing and testing CLISP, the implementation of ANSI Common Lisp that will let you run all the Lisp games you’re going to be creating!<a id="IDX-CHP-1-0001" class="indexterm"/><a id="IDX-CHP-1-0002" class="indexterm"/><a id="IDX-CHP-1-0003" class="indexterm"/></p><div class="sect1" title="Lisp Dialects"><div class="titlepage"><div><div><h1 class="title"><a id="lisp_dialects"/>Lisp Dialects</h1></div></div></div><p>Any language that obeys the central principles of Lisp is considered a Lisp dialect. Since these principles are so simple, it’s not surprising that literally hundreds of dialects of Lisp have been created. In fact, since so many budding Lispers create their own Lisp dialect as an exercise, there may be <span class="emphasis"><em>thousands</em></span> of partially completed Lisps slumbering in long-abandoned directories on hard drives across the planet. However, the vast majority of the Lisp community uses two Lisps: ANSI Common Lisp (often abbreviated CL) and Scheme.<a id="IDX-CHP-1-0004" class="indexterm"/><a id="IDX-CHP-1-0005" class="indexterm"/></p><p>In this book, we’ll be talking exclusively about the ANSI Common Lisp dialect, the slightly more popular of the two. Nevertheless, most of the knowledge you’ll gain from reading this book will also be relevant to Scheme (although the names of functions tend to differ somewhat between the dialects).<a id="IDX-CHP-1-0006" class="indexterm"/><a id="IDX-CHP-1-0007" class="indexterm"/></p><div class="sect2" title="A Tale of Two Lisps"><div class="titlepage"><div><div><h2 class="title"><a id="a_tale_of_two_lisps"/>A Tale of Two Lisps</h2></div></div></div><p>Some deep philosophical differences exist between ANSI Common Lisp and Scheme, and they appeal to different programmer personalities. Once you learn more about Lisp languages, you can decide which dialect you prefer. There is no right or wrong choice.</p><p>To aid you in your decision, I have created the following personality test for you:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e582"/><img src="httpatomoreillycomsourcenostarchimages703121.png" alt="image with no caption"/></div></div><p>If you chose A, you like raw power in your language. You don’t mind if your language is a bit ugly, due to a lot of pragmatic compromises, as long as you can still write tight code. ANSI Common Lisp is the best language for you! ANSI Common Lisp traces its ancestry most directly from the ancient Lisp dialects, built on top of millions of programmer hours, giving it incredibly rich functionality. Sure, it has some baroque function names due to countless historical accidents, but this Lisp can really fly in the right hacker’s hands.</p><p>If you chose B, you like languages that are clean and elegant. You are more interested in fundamental programming problems and are happy to while away on a beautiful meadow, contemplating the beauty of your code, occasionally writing a research paper on theoretical computing problems. Scheme is the language for you! It was created in the mid-1970s by Guy L. Steele and Gerald Jay Sussman and involved some soul-searching about the ideal Lisp. Code in Scheme tends to be slightly more verbose, since Schemers care more about mathematical purity in their code than creating the shortest programs possible.</p><p>If you chose C, you’re someone who wants it all: the power of ANSI CL and the mathematical beauty of Scheme. At this time, no Lisp dialect completely fits the bill, but that could change in the future. One language that might work for you (although it is sacrilege to make this claim in a Lisp book) is Haskell. It is not considered a Lisp dialect, but its followers obey paradigms popular among Lispers, such as keeping the syntax uniform, supporting native lists, and relying heavily on higher-order functions. More important, it has an extreme mathematical rigor (even more so than Scheme) that allows it to hide very powerful functionality under a squeaky clean surface. It’s essentially a wolf in sheep’s clothing. Like Lisp, Haskell is a language that any programmer would benefit from investigating further.<a id="IDX-CHP-1-0008" class="indexterm"/><a id="IDX-CHP-1-0009" class="indexterm"/><a id="IDX-CHP-1-0010" class="indexterm"/><a id="IDX-CHP-1-0011" class="indexterm"/><a id="IDX-CHP-1-0012" class="indexterm"/><a id="IDX-CHP-1-0013" class="indexterm"/><a id="IDX-CHP-1-0014" class="indexterm"/><a id="IDX-CHP-1-0015" class="indexterm"/><a id="IDX-CHP-1-0016" class="indexterm"/><a id="IDX-CHP-1-0017" class="indexterm"/></p></div><div class="sect2" title="Up-and-Coming Lisps"><div class="titlepage"><div><div><h2 class="title"><a id="up-and-coming_lisps"/>Up-and-Coming Lisps</h2></div></div></div><p>As just mentioned, there really isn’t a true Lisp dialect available yet that possesses both the power and flexibility of ANSI Common Lisp and the elegance of Scheme. However, some new contenders on the horizon may attain the best-of-both-worlds crown in the near future.</p><p>One new Lisp that is showing promise is Clojure, a dialect developed by Rich Hickey. Clojure is built on the Java platform, allowing it to leverage a lot of mature Java libraries right out of the box. Also, Clojure contains some clever and well-thought-out features to ease multithreaded programming, which makes it a useful tool for programming seemingly ubiquitous multicore CPUs.</p><p>Another interesting challenger is Arc. It is a true Lisp language being principally developed by Paul Graham, a well-known Lisper. Arc is still in an early stage of development, and opinion varies widely on how much of an improvement it is over other Lisps. Also, its development has been progressing at a glacially slow pace. It will be a while before anyone can say if Arc might be a meaningful contender.</p><p>We’ll be dipping our toes in some Arc and Clojure in the epilogue.</p></div><div class="sect2" title="Lisp Dialects Used for Scripting"><div class="titlepage"><div><div><h2 class="title"><a id="lisp_dialects_used_for_scripting"/>Lisp Dialects Used for Scripting</h2></div></div></div><p>Some Lisp dialects are used for scripting, including these:<a id="IDX-CHP-1-0018" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Emacs Lisp is used for scripting inside the popular (and overall awesome) Emacs text editor.<a id="IDX-CHP-1-0019" class="indexterm"/></p></li><li class="listitem"><p>Guile Scheme is used as a scripting language in several open source applications.<a id="IDX-CHP-1-0020" class="indexterm"/></p></li><li class="listitem"><p>Script-Fu Scheme is used with the GIMP image editor.<a id="IDX-CHP-1-0021" class="indexterm"/></p></li></ul></div><p>These dialects are forks from older versions of the main Lisp branches and are not typically used for creating stand-alone applications. However, they are still perfectly respectable dialects of Lisp.</p></div><div class="sect2" title="ANSI Common Lisp"><div class="titlepage"><div><div><h2 class="title"><a id="ansi_common_lisp"/>ANSI Common Lisp</h2></div></div></div><p>In 1981, in order to cope with the dizzying number of dialects of the language, members of the varying Lisp communities drafted a specification for a new dialect named Common Lisp. In 1986, this language, after further adjustments, was turned into the ANSI Common Lisp standard. Many of the developers of older versions of Lisp modified their interpreters and compilers to conform to this new standard, which became the most popular version of Lisp and remains so to this day.<a id="IDX-CHP-1-0022" class="indexterm"/><a id="IDX-CHP-1-0023" class="indexterm"/><a id="IDX-CHP-1-0024" class="indexterm"/><a id="IDX-CHP-1-0025" class="indexterm"/><a id="IDX-CHP-1-0026" class="indexterm"/><a id="IDX-CHP-1-0027" class="indexterm"/><a id="IDX-CHP-1-0028" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Throughout this book, the term <span class="emphasis"><em>Common Lisp</em></span> refers to the version of Common Lisp defined by the ANSI standard.</p></div><p>A key design goal with Common Lisp was to create a <span class="emphasis"><em>multiparadigm language</em></span>, meaning it includes support for many different styles of programming. You’ve probably heard of <span class="emphasis"><em>object-oriented programming</em></span>, which can be done quite nicely in Common Lisp. Other programming styles you may not have heard of before include <span class="emphasis"><em>functional programming, generic programming</em></span>, and <span class="emphasis"><em>domain-specific language programming</em></span>. These are all well supported within Common Lisp. You’ll be learning about each of these styles, along with others, as we progress through this book.<a id="IDX-CHP-1-0029" class="indexterm"/></p></div></div></div>
<div class="sect1" title="Getting Started with CLISP"><div class="titlepage"><div><div><h1 class="title"><a id="getting_started_with_clisp"/>Getting Started with CLISP</h1></div></div></div><p>Many great Lisp compilers are available, but one in particular is easiest to get started with: CLISP, an open source Common Lisp. CLISP is simple to install and runs on any operating system.<a id="IDX-CHP-1-0030" class="indexterm"/></p><p>Other popular Lisps include Steel Bank Common Lisp (SBCL), a fast Common Lisp that’s considered a bit more heavy-duty than CLISP and also open source; Allegro Common Lisp, a powerful commercial Lisp by Franz, Inc; LispWorks; Clozure CL; and CMUCL. Mac users may want to consider LispWorks or Clozure CL, which will be easier to get running on their machines. However, for our purposes, CLISP is the best choice.<a id="IDX-CHP-1-0031" class="indexterm"/><a id="IDX-CHP-1-0032" class="indexterm"/><a id="IDX-CHP-1-0033" class="indexterm"/><a id="IDX-CHP-1-0034" class="indexterm"/><a id="IDX-CHP-1-0035" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Starting with <a class="xref" href="ch13.html" title="Chapter 12. Working with Streams">Chapter 12</a>, we’ll be using some CLISP-specific commands that are considered nonstandard. However, up until that point, any implementation of Common Lisp will work for running the examples in this book.</p></div><div class="sect2" title="Installing CLISP"><div class="titlepage"><div><div><h2 class="title"><a id="installing_clisp"/>Installing CLISP</h2></div></div></div><p>You can download a CLISP installer from <a class="ulink" href="http://clisp.cons.org/">http://clisp.cons.org/</a>. It will run on Windows PCs, Macs, and Linux variants. On a Windows PC, you simply run an install program. On a Mac, there are some additional steps, which are detailed on the website.</p><p>On a Debian-based Linux machine, you should find that CLISP already exists in your standard sources. Just type <strong class="userinput"><code>apt-get install clisp</code></strong> at the command line, and you’ll have CLISP installed automatically.<a id="IDX-CHP-1-0036" class="indexterm"/></p><p>For other Linux distributions (Fedora, SUSE, and so on), you can use standard packages listed under “Linux packages” on the CLISP website. And experienced Linux users can compile CLISP from source.</p></div><div class="sect2" title="Starting Up CLISP"><div class="titlepage"><div><div><h2 class="title"><a id="starting_up_clisp"/>Starting Up CLISP</h2></div></div></div><p>To run CLISP, type <strong class="userinput"><code>clisp</code></strong> from your command line. If all goes according to plan, you’ll see the following prompt:<a id="IDX-CHP-1-0037" class="indexterm"/><a id="IDX-CHP-1-0038" class="indexterm"/><a id="IDX-CHP-1-0039" class="indexterm"/><a id="IDX-CHP-1-0040" class="indexterm"/><a id="IDX-CHP-1-0041" class="indexterm"/><a id="IDX-CHP-1-0042" class="indexterm"/></p><a id="I_programlisting1_d1e799"/><pre class="programlisting">$ <strong class="userinput"><code>clisp</code></strong>
  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo
  I I I I I I I      8     8   8           8     8     o  8    8
  I  \ `+' /  I      8         8           8     8        8    8
   \  `-+-'  /       8         8           8      ooooo   8oooo
    `-__|__-'        8         8           8           8  8
        |            8     o   8           8     o     8  8
  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8

Copyright (c) Bruno Haible, Michael Stoll 1992, 1993
Copyright (c) Bruno Haible, Marcus Daniels 1994-1997
Copyright (c) Bruno Haible, Pierpaolo Bernardi, Sam Steingold 1998
Copyright (c) Bruno Haible, Sam Steingold 1999-2000
Copyright (c) Sam Steingold, Bruno Haible 2001-2006

[1]&gt;</pre><p>Like all Common Lisp environments, CLISP will automatically place you into a <span class="emphasis"><em>read-eval-print loop</em></span> (<span class="emphasis"><em>REPL</em></span>) after you start it up. This means you can immediately start typing in Lisp code.</p><p>Try it out by typing <strong class="userinput"><code>(+ 3 (* 2 4))</code></strong>. You’ll see the result printed below the expression:</p><a id="I_programlisting1_d1e817"/><pre class="programlisting">[1]&gt; <strong class="userinput"><code>(+ 3 (* 2 4))</code></strong>
11</pre><p>This shows how the REPL works. You type in an expression, and then the Lisp will immediately evaluate it and return the resulting value. When you want to shut down CLISP, just type <strong class="userinput"><code>(quit)</code></strong>.</p><p>Now that you have CLISP working on your computer, you’re ready to write a Lisp game!</p></div></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned"/>What You've Learned</h1></div></div></div><p>In this chapter, we discussed the different dialects of Lisp and installing CLISP. You learned the following along the way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are two main dialects of Lisp: Common Lisp and Scheme. Both have a lot to offer, but we’ll focus on Common Lisp in this book.</p></li><li class="listitem"><p>Common Lisp is a multiparadigm language, meaning that it supports many different programming styles.</p></li><li class="listitem"><p>CLISP is a Common Lisp implementation that is easy to set up, making it a great choice for a Lisp novice.<a id="IDX-CHP-1-0043" class="indexterm"/></p></li><li class="listitem"><p>You can type in Lisp commands directly from the CLISP <span class="emphasis"><em>REPL</em></span>.</p></li></ul></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e854"/><img src="httpatomoreillycomsourcenostarchimages703123.png.jpg" alt="image with no caption"/></div></div></div>
<div class="chapter" title="Chapter&#xA0;2.&#xA0;Creating Your First Lisp Program"><div class="titlepage"><div><div><h1 class="title"><a id="creating_your_first_lisp_program"/>Chapter 2. Creating Your First Lisp Program</h1></div></div></div><p>Now that we’ve discussed some of the philosophy of Lisp and have a running CLISP environment, we’re ready to write some actual Lisp code in the form of a simple game.</p><div class="sect1" title="The Guess-My-Number Game"><div class="titlepage"><div><div><h1 class="title"><a id="the_guess-my-number_game"/>The Guess-My-Number Game</h1></div></div></div><p>This first game we’ll write is pretty much the simplest game imaginable. It’s the classic guess-my-number game.<a id="IDX-CHP-2-0001" class="indexterm"/><a id="IDX-CHP-2-0002" class="indexterm"/><a id="IDX-CHP-2-0003" class="indexterm"/></p><p>In this game, you pick a number from 1 to 100, and the computer has to guess it.</p><p>The following shows what game play might look like if you pick the number 23. The computer starts by guessing 50, and with each successive guess, you enter <code class="literal">(smaller)</code> or <code class="literal">(bigger)</code> until the computer guesses your number.</p><a id="I_programlisting2_d1e892"/><pre class="programlisting">&gt; <strong class="userinput"><code>(guess-my-number)</code></strong>
50
&gt; <strong class="userinput"><code>(smaller)</code></strong>
25
&gt; <strong class="userinput"><code>(smaller)</code></strong>
12
&gt; <strong class="userinput"><code>(bigger)</code></strong>
18
&gt; <strong class="userinput"><code>(bigger)</code></strong>
21
&gt; <strong class="userinput"><code>(bigger)</code></strong>
23</pre><p>To create this game, we need to write three functions: <code class="literal">guess-my-number</code>, <code class="literal">smaller</code>, and <code class="literal">bigger</code>. The player simply calls these functions from the REPL. As you saw in the previous chapter, when you start CLISP (or any other Lisp), you are presented with the REPL, from which the commands you type will be <span class="emphasis"><em>read</em></span>, then <span class="emphasis"><em>evaluated</em></span>, and finally <span class="emphasis"><em>printed</em></span>. In this case, we’re running the commands <code class="literal">guess-my-number</code>, <code class="literal">smaller</code>, and <code class="literal">bigger</code>.<a id="IDX-CHP-2-0004" class="indexterm"/><a id="IDX-CHP-2-0005" class="indexterm"/><a id="IDX-CHP-2-0006" class="indexterm"/><a id="IDX-CHP-2-0007" class="indexterm"/><a id="IDX-CHP-2-0008" class="indexterm"/><a id="IDX-CHP-2-0009" class="indexterm"/><a id="IDX-CHP-2-0010" class="indexterm"/><a id="IDX-CHP-2-0011" class="indexterm"/></p><p>To call a function in Lisp, you put parentheses around it, along with any parameters you wish to give the function. Since these particular functions don’t require any parameters, we simply surround their names in parentheses when we enter them.</p><p>Let’s think about the strategy behind this simple game. After a little thought, we come up with the following steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Determine the upper and lower (big and small) limit of the player’s number. Since the range is between 1 and 100, the smallest possible number would be 1 and the biggest would be 100.</p></li><li class="listitem"><p>Guess a number in between these two numbers.</p></li><li class="listitem"><p>If the player says the number is smaller, lower the big limit.</p></li><li class="listitem"><p>If the player says the number is bigger, raise the small limit.</p></li></ol></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e994"/><img src="httpatomoreillycomsourcenostarchimages703125.png.jpg" alt="image with no caption"/></div></div><p>By following these simple steps, cutting the range of possible numbers in half with every guess, the computer can quickly hone in on the player’s number.<a id="IDX-CHP-2-0012" class="indexterm"/><a id="IDX-CHP-2-0013" class="indexterm"/><a id="IDX-CHP-2-0014" class="indexterm"/><a id="IDX-CHP-2-0015" class="indexterm"/><a id="IDX-CHP-2-0016" class="indexterm"/><a id="IDX-CHP-2-0017" class="indexterm"/><a id="IDX-CHP-2-0018" class="indexterm"/></p><p>This type of search is called a <span class="emphasis"><em>binary search</em></span>. As you may know, binary searches like this are used all the time in computer programming. You could follow these same steps, for instance, to efficiently find a specific number given a sorted table of values. In that case, you would simply track the smallest and largest row in that table, and then quickly hone in on the correct row in an analogous manner.<a id="IDX-CHP-2-0019" class="indexterm"/></p></div></div>
<div class="sect1" title="Defining Global Variables in Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="defining_global_variables_in_lisp"/>Defining Global Variables in Lisp</h1></div></div></div><p>As the player calls the functions that make up our game, the program will need to track the small and big limits. In order to do this, we’ll need to create two global variables called <code class="literal">*small*</code> and <code class="literal">*big*</code>.</p><div class="sect2" title="Defining the small and big Variables"><div class="titlepage"><div><div><h2 class="title"><a id="defining_the_small_and_big_variables"/>Defining the small and big Variables</h2></div></div></div><p>A variable that is defined globally in Lisp is called a <span class="emphasis"><em>top-level definition</em></span>. We can create new top-level definitions with the <code class="literal">defparameter</code> function:</p><a id="I_programlisting2_d1e1057"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defparameter *small* 1)</code></strong>
*SMALL*
&gt; <strong class="userinput"><code>(defparameter *big* 100)</code></strong>
*BIG*</pre><p>The function name <code class="literal">defparameter</code> is a bit confusing, since it doesn’t really have anything to do with parameters. What it does is let you define a <span class="emphasis"><em>global variable</em></span>.</p><p>The first argument we send to <code class="literal">defparameter</code> is the name of the new variable. The asterisks surrounding the names <code class="literal">*big*</code> and <code class="literal">*small*</code>—affectionately called <span class="emphasis"><em>earmuffs</em></span>—are completely arbitrary and optional. Lisp sees the asterisks as part of the variable names and ignores them. Lispers like to mark all their global variables in this way as a convention, to make them easy to distinguish from local variables, which are discussed later in this chapter.<a id="IDX-CHP-2-0020" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although earmuffs may be “optional” in a strictly technical sense, I suggest that you use them. I cannot vouch for your safety if you ever post any code to a Common Lisp newsgroup and your global variables are missing their earmuffs.</p></div></div><div class="sect2" title="An Alternative Global Variable Definition Function"><div class="titlepage"><div><div><h2 class="title"><a id="an_alternative_global_variable_definitio"/>An Alternative Global Variable Definition Function</h2></div></div></div><p>When you set the value of a global variable using <code class="literal">defparameter</code>, any value previously stored in the variable will be overwritten:</p><a id="I_programlisting2_d1e1101"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defparameter *foo* 5)</code></strong>
FOO
&gt; <strong class="userinput"><code>*foo*</code></strong>
5
&gt; <strong class="userinput"><code>(defparameter *foo* 6)</code></strong>
FOO
&gt; <strong class="userinput"><code>*foo*</code></strong>
6</pre><p>As you can see, when we redefine the variable <code class="literal">*foo*</code>, its value changes.<a id="IDX-CHP-2-0021" class="indexterm"/><a id="IDX-CHP-2-0022" class="indexterm"/><a id="IDX-CHP-2-0023" class="indexterm"/><a id="IDX-CHP-2-0024" class="indexterm"/><a id="IDX-CHP-2-0025" class="indexterm"/><a id="IDX-CHP-2-0026" class="indexterm"/><a id="IDX-CHP-2-0027" class="indexterm"/><a id="IDX-CHP-2-0028" class="indexterm"/></p><p>Another command that you can use for declaring global variables, called <code class="literal">defvar</code>, won’t overwrite previous values of a global variable:</p><a id="I_programlisting2_d1e1155"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defvar *foo* 5)</code></strong>
FOO
&gt; <strong class="userinput"><code>*foo*</code></strong>
5
&gt; <strong class="userinput"><code>(defvar *foo* 6)</code></strong>
FOO
&gt; <strong class="userinput"><code>*foo*</code></strong>
5</pre><p>Some Lispers prefer to use <code class="literal">defvar</code> instead of <code class="literal">defparameter</code> when defining global variables. In this book, however, we’ll be using <code class="literal">defparameter</code> exclusively.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When you read about Lisp in other places, you may also see programmers using the term <span class="emphasis"><em>dynamic variable</em></span> or <span class="emphasis"><em>special variable</em></span> when referring to a global variable in Common Lisp. This is because global variables in Common Lisp have some special abilities, which we’ll be discussing in future chapters.<a id="IDX-CHP-2-0029" class="indexterm"/><a id="IDX-CHP-2-0030" class="indexterm"/></p></div></div></div>
<div class="sect1" title="Basic Lisp Etiquette"><div class="titlepage"><div><div><h1 class="title"><a id="basic_lisp_etiquette"/>Basic Lisp Etiquette</h1></div></div></div><p>The way commands are called and the way code is formatted in Lisp is somewhat strange compared with other languages. First of all, you need to surround the command (and its arguments) with parentheses, as with the <code class="literal">defparameter</code> function:</p><a id="I_programlisting2_d1e1203"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defparameter *small* 1)</code></strong>
*SMALL*</pre><p>Without the parentheses, a command will not be called.</p><p>Also, spaces and line breaks are completely ignored when Lisp reads in your code. That means you could call this command in any crazy way, with the same result:</p><a id="I_programlisting2_d1e1212"/><pre class="programlisting">&gt; <strong class="userinput"><code>(               defparameter</code></strong>
           <strong class="userinput"><code>*small* 1)</code></strong>
*SMALL*</pre><p>Because Lisp code can be formatted in such flexible ways, Lispers have a lot of conventions for formatting commands, including when to use multiple lines and indentation. We’ll loosely follow some of the common indentation conventions in the code examples in this book. However, we’re more interested in writing games than in discussing source code indentation rules, so we’re not going to be spending too much time on code layout rules in this book.<a id="IDX-CHP-2-0031" class="indexterm"/><a id="IDX-CHP-2-0032" class="indexterm"/><a id="IDX-CHP-2-0033" class="indexterm"/><a id="IDX-CHP-2-0034" class="indexterm"/><a id="IDX-CHP-2-0035" class="indexterm"/><a id="IDX-CHP-2-0036" class="indexterm"/><a id="IDX-CHP-2-0037" class="indexterm"/></p></div>
<div class="sect1" title="Defining Global Functions in Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="defining_global_functions_in_lisp"/>Defining Global Functions in Lisp</h1></div></div></div><p>Our guess-my-number game has the computer respond to the player’s request to start the game, and then to requests for either smaller or bigger guesses. For these, we need to define three global functions: <code class="literal">guess-my-number</code>, <code class="literal">smaller</code>, and <code class="literal">bigger</code>. We’ll also define a function to start over with a different number, called <code class="literal">start-over</code>. In Common Lisp, functions are defined with <code class="literal">defun</code>, like this:</p><a id="I_programlisting2_d1e1267"/><pre class="programlisting">(defun <em class="replaceable"><code>function_name</code></em> (<em class="replaceable"><code>arguments</code></em>)
  ...)</pre><p>First, we specify the name and arguments for the function. Then we follow it up with the code that composes the function’s logic.</p><div class="sect2" title="Defining the guess-my-number Function"><div class="titlepage"><div><div><h2 class="title"><a id="defining_the_guess-my-number_function"/>Defining the guess-my-number Function</h2></div></div></div><p>The first function we’ll define is <code class="literal">guess-my-number</code>. This function uses the values of the <code class="literal">*big*</code> and <code class="literal">*small*</code> variables to generate a guess of the player’s number. The definition looks like this:</p><a id="I_programlisting2_d1e1291"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defun guess-my-number ()</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>      <strong class="userinput"><code>(ash (+ *small* *big*) −1))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> GUESS-MY-NUMBER</pre><p>The empty parentheses, <code class="literal">()</code>, after the function name <code class="literal">guess-my-number</code> indicate that this function doesn’t require any parameters.</p><p>Although you don’t need to worry about indentation or line breaks when entering code snippets at the REPL, you must be sure to place parentheses correctly. If you forget a parenthesis or put one in the wrong place, you’ll most likely get an error.</p><p>Whenever we run a piece of code like this in the REPL, the resulting value of the entered expression will be printed. Every command in Common Lisp generates a return value. The <code class="literal">defun</code> command, for instance, simply returns the name of the newly created function. This is why we see the name of the function parroted back to us in the REPL after we call <code class="literal">defun</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1329"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>.</p><p>What does this function do? As discussed earlier, the computer’s best guess in this game will be a number in between the two limits. To accomplish this, we choose the average of the two limits. However, if the average number ends up being a fraction, we’ll want to use a near-average number, since we’re guessing only whole numbers.</p><p>We implement this in the <code class="literal">guess-my-number</code> function by first adding the numbers that represent the high and low limits, then using the arithmetic shift function, <code class="literal">ash</code>, to halve the sum of the limits and shorten the result. The code <code class="literal">(+ *small* *big*)</code> adds together those two variables. Because the addition happens within another function call, <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1348"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, the resulting sum is then passed to the <code class="literal">ash</code> function.</p><p>The parentheses surrounding the <code class="literal">ash</code> function and the addition (<code class="literal">+</code>) function are mandatory in Lisp. These parentheses are what tell Lisp, “I want you to call this function.”</p><p>The built-in Lisp function <code class="literal">ash</code> looks at a number in binary form, and then shifts its binary bits to the left or right, dropping any bits lost in the process. For example, the number 11 written in binary is 1011. We can move the bits in this number to the left with <code class="literal">ash</code> by using <code class="literal">1</code> as the second argument:</p><a id="I_programlisting2_d1e1376"/><pre class="programlisting">&gt; <strong class="userinput"><code>(ash 11 1)</code></strong>
22</pre><p>This produces 22, which is 10110 in binary. We can move the bits to the right (and lop off the bit on the end) by passing in <code class="literal">−1</code> as the second argument:</p><a id="I_programlisting2_d1e1387"/><pre class="programlisting">&gt; <strong class="userinput"><code>(ash 11 −1)</code></strong>
5</pre><p>This produces 5, which is 101 in binary.</p><p>By using the <code class="literal">ash</code> function in <code class="literal">guess-my-number</code>, we are continually halving our search space of possible numbers to quickly narrow down to the final correct number. As already mentioned, this halving process is called a <span class="emphasis"><em>binary search</em></span>, a useful technique in computer programming. The ash function is commonly used for such binary searches in Lisp.<a id="IDX-CHP-2-0038" class="indexterm"/></p><p>Let’s see what happens when we call our new function:</p><a id="I_programlisting2_d1e1410"/><pre class="programlisting">&gt; <strong class="userinput"><code>(guess-my-number)</code></strong>
50</pre><p>Since this is our first guess, the output we see when calling this function tells us that everything is working as planned: The program picked the number 50, right in between 1 and 100.</p><p>When programming in Lisp, you’ll write many functions that won’t explicitly print values on the screen. Instead, they’ll simply return the value calculated in the body of the function. For instance, let’s say we wanted a function that just returns the number 5. Here’s how we could write this:</p><a id="I_programlisting2_d1e1419"/><pre class="programlisting">&gt; <strong class="userinput"><code>(defun return-five ()</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/>     <strong class="userinput"><code>(+ 2 3))</code></strong></pre><p>Because the value calculated in the body of the function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1434"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> evaluates to 5, calling <code class="literal">(return-five)</code> will just return 5.</p><p>This is how <code class="literal">guess-my-number</code> is designed. We see this calculated result on the screen (the number 50) not because the function causes the number to display, but because this is a feature of the REPL.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you’ve used other programming languages before, you may remember having to write something like <code class="literal">return...</code> to cause a value to be returned. In Lisp, this is not necessary. The final value calculated in the body of the function is returned automatically.<a id="IDX-CHP-2-0039" class="indexterm"/><a id="IDX-CHP-2-0040" class="indexterm"/><a id="IDX-CHP-2-0041" class="indexterm"/><a id="IDX-CHP-2-0042" class="indexterm"/><a id="IDX-CHP-2-0043" class="indexterm"/><a id="IDX-CHP-2-0044" class="indexterm"/></p></div></div><div class="sect2" title="Defining the smaller and bigger Functions"><div class="titlepage"><div><div><h2 class="title"><a id="defining_the_smaller_and_bigger_function"/>Defining the smaller and bigger Functions</h2></div></div></div><p>Now we’ll write our <code class="literal">smaller</code> and <code class="literal">bigger</code> functions. Like <code class="literal">guess-my-number</code>, these are global functions defined with <code class="literal">defun</code>:</p><a id="I_programlisting2_d1e1492"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(defun smaller ()</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>      <strong class="userinput"><code>(setf *big* (1- (guess-my-number)))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>      <strong class="userinput"><code>(guess-my-number))</code></strong>
  SMALLER
  &gt; <strong class="userinput"><code>(defun bigger ()</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>      <strong class="userinput"><code>(setf *small* (1+ (guess-my-number)))</code></strong>
     <strong class="userinput"><code>(guess-my-number))</code></strong>
  BIGGER</pre><p>First, we use <code class="literal">defun</code> to start the definition of a new global function <code class="literal">smaller.</code> Because this function takes no parameters, the parentheses are empty <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1544"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>.</p><p>Next, we use the <code class="literal">setf</code> function to change the value of our global variable <code class="literal">*big*</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1558"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Since we know the number must be smaller than the last guess, the biggest it can now be is one less than that guess. The code <code class="literal">(1- (guess-my-number)</code>) calculates this: It first calls our <code class="literal">guess-my-number</code> function to get the most recent guess, and then it uses the function <code class="literal">1-</code>, which subtracts 1 from the result.</p><p>Finally, we want our <code class="literal">smaller</code> function to show us a new guess. We do this by putting a call to <code class="literal">guess-my-number</code> as the final line in the function body <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1582"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. This time, <code class="literal">guess-my-number</code> will use the updated value of <code class="literal">*big*</code>, causing it to calculate the next guess. The final value of our function will be returned automatically, causing our new guess (generated by <code class="literal">guess-my-number</code>) to be returned by the <code class="literal">smaller</code> function.</p><p>The <code class="literal">bigger</code> function works in exactly the same manner, except that it raises the <code class="literal">*small*</code> value instead. After all, if you call the <code class="literal">bigger</code> function, you are saying your number is bigger than the previous guess, so the smallest it can now be (which is what the <code class="literal">*small*</code> variable represents) is <span class="emphasis"><em>one more</em></span> than the previous guess. The function <code class="literal">1+</code> simply adds 1 to the value returned by <code class="literal">guess-my-number</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1625"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>Here we see our functions in action, with the number 56 as our guess:</p><a id="I_programlisting2_d1e1633"/><pre class="programlisting">&gt; <strong class="userinput"><code>(bigger)</code></strong>
75
&gt; <strong class="userinput"><code>(smaller)</code></strong>
62
&gt; <strong class="userinput"><code>(smaller)</code></strong>
56</pre></div><div class="sect2" title="Defining the start-over Function"><div class="titlepage"><div><div><h2 class="title"><a id="defining_the_start-over_function"/>Defining the start-over Function</h2></div></div></div><p>To complete our game, we’ll add the function <code class="literal">start-over</code> to reset our global variables:<a id="IDX-CHP-2-0045" class="indexterm"/><a id="IDX-CHP-2-0046" class="indexterm"/><a id="IDX-CHP-2-0047" class="indexterm"/><a id="IDX-CHP-2-0048" class="indexterm"/><a id="IDX-CHP-2-0049" class="indexterm"/><a id="IDX-CHP-2-0050" class="indexterm"/><a id="IDX-CHP-2-0051" class="indexterm"/></p><a id="I_programlisting2_d1e1681"/><pre class="programlisting">(defun start-over ()
   (defparameter *small* 1)
   (defparameter *big* 100)
   (guess-my-number))</pre><p>As you can see, the <code class="literal">start-over</code> function resets the values of <code class="literal">*small*</code> and <code class="literal">*big*</code> and then calls <code class="literal">guess-my-number</code> again to return a new starting guess. Whenever you want to start a brand-new game with a different number, you can call this function to reset the game.</p></div></div>
<div class="sect1" title="Defining Local Variables in Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="defining_local_variables_in_lisp"/>Defining Local Variables in Lisp</h1></div></div></div><p>For our simple game, we’ve defined global variables and functions. However, in most cases you’ll want to limit your definitions to a single function or a block of code. These are called <span class="emphasis"><em>local</em></span> variables and functions.</p><p>To define a local variable, use the command <code class="literal">let</code>. A <code class="literal">let</code> command has the following structure:</p><a id="I_programlisting2_d1e1713"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (let (<em class="replaceable"><code>variable declarations</code></em>)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>   ...body...)</pre><p>The first thing inside the <code class="literal">let</code> command is a list of variable declarations <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1734"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. This is where we can declare one or more local variables. Then, in the body of the command (and only within this body), we can use these variables <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1740"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Here is an example of the <code class="literal">let</code> command:<a id="IDX-CHP-2-0052" class="indexterm"/></p><a id="I_programlisting2_d1e1752"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(let ((a 5)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>         <strong class="userinput"><code>(b 6))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>     <strong class="userinput"><code>(+ a b))</code></strong>
  11</pre><p>In this example, we’ve declared the values <code class="literal">5</code> and <code class="literal">6</code> for the variables <code class="literal">a</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1791"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> and <code class="literal">b</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1801"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, respectively. These are our variable declarations. Then, in the body of the <code class="literal">let</code> command, we added them together <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1810"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>, resulting in the displayed value of <code class="literal">11</code>.</p><p>When using a let expression, you must surround the entire list of declared variables with parentheses. Also, you must surround each pair of variable names and initial variables with another set of parentheses.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although the indentation and line breaks are completely arbitrary, because the names of the variables and their values in a <code class="literal">let</code> expression form a kind of simple table, common practice is to align the declared variables vertically. This is why the <code class="literal">b</code> is placed directly underneath the <code class="literal">a</code> in the preceding example.<a id="IDX-CHP-2-0053" class="indexterm"/></p></div></div>
<div class="sect1" title="Defining Local Functions in Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="defining_local_functions_in_lisp"/>Defining Local Functions in Lisp</h1></div></div></div><p>We define local functions using the <code class="literal">flet</code> command. The <code class="literal">flet</code> command has the following structure:<a id="IDX-CHP-2-0054" class="indexterm"/><a id="IDX-CHP-2-0055" class="indexterm"/><a id="IDX-CHP-2-0056" class="indexterm"/><a id="IDX-CHP-2-0057" class="indexterm"/><a id="IDX-CHP-2-0058" class="indexterm"/></p><a id="I_programlisting2_d1e1862"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> (flet ((<em class="replaceable"><code>function_name</code></em> (<em class="replaceable"><code>arguments</code></em>)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>          ...function body...))
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>   ...body...)</pre><p>At the top of the <code class="literal">flet</code>, we declare a function (in the first two lines). This function will then be available to us in the body <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1892"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. A function declaration consists of a function name, the arguments to that function <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1898"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>, and the function body <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1904"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, where we put the function’s code.</p><p>Here is an example:</p><a id="I_programlisting2_d1e1912"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(flet ((f (n)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>             <strong class="userinput"><code>(+ n 10)))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>     <strong class="userinput"><code>(f 5))</code></strong>
  15</pre><p>In this example, we define a single function, <code class="literal">f</code>, which takes a single argument, <code class="literal">n</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1948"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. The function <code class="literal">f</code> then adds <code class="literal">10</code> to this variable <code class="literal">n</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1964"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>, which has been passed in it. Then we call this function with the number <code class="literal">5</code> as the argument, causing the value <code class="literal">15</code> to be returned <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1976"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>.</p><p>As with <code class="literal">let</code>, you can define one or more functions within the scope of the <code class="literal">flet</code>.</p><p>A single <code class="literal">flet</code> command can be used to declare multiple local functions at once. Simply add multiple function declarations in the first part of the command:</p><a id="I_programlisting2_d1e1995"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(flet ((f (n)</code></strong>
            <strong class="userinput"><code>(+ n 10))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>          <strong class="userinput"><code>(g (n)</code></strong>
            <strong class="userinput"><code>(- n 3)))</code></strong>
    <strong class="userinput"><code>(g (f 5)))</code></strong>
  12</pre><p>Here, we have declared two functions: one named <code class="literal">f</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e2029"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span> and one named <code class="literal">g</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e2038"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. In the body of the <code class="literal">flet</code>, we can then refer to both functions. In this example, the body first calls <code class="literal">f</code> with <code class="literal">5</code> to yield 15, then calls <code class="literal">g</code> to subtract <code class="literal">3</code>, leading to <code class="literal">12</code> as a final result.</p><p>To make function names available in defined functions, we can use the <code class="literal">labels</code> command. It’s identical in its basic structure to the <code class="literal">flet</code> command. Here’s an example:<a id="IDX-CHP-2-0059" class="indexterm"/></p><a id="I_programlisting2_d1e2077"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(labels ((a (n)</code></strong>
              <strong class="userinput"><code>(+ n 5))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/>            <strong class="userinput"><code>(b (n)</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/>               <strong class="userinput"><code>(+ (a n) 6)))</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/>    <strong class="userinput"><code>(b 10))</code></strong>
  21</pre><p>In this example, the local function <code class="literal">a</code> adds <code class="literal">5</code> to a number <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e2126"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, the function <code class="literal">b</code> is declared <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e2135"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. It calls the function <code class="literal">a</code>, and then adds <code class="literal">6</code> to the result <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e2148"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Finally, the function <code class="literal">b</code> is called with the value <code class="literal">10</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e2160"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Since 10 plus 6 plus 5 equals 21, the number 21 becomes the final value of the entire expression. The special step that requires us to use <code class="literal">labels</code> instead of <code class="literal">flet</code> is where the function <code class="literal">b</code> calls the function <code class="literal">a</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e2179"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. If we had used <code class="literal">flet</code>, the function <code class="literal">b</code> would not have “known” about the function <code class="literal">a</code>.<a id="IDX-CHP-2-0060" class="indexterm"/></p><p>The <code class="literal">labels</code> command lets you call one local function from another, and it allows you to have a function call itself. This is commonly done in Lisp code and is called <span class="emphasis"><em>recursion</em></span>. (You will see many examples of recursion in future chapters.)<a id="IDX-CHP-2-0061" class="indexterm"/></p></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id1"/>What You've Learned</h1></div></div></div><p>In this chapter, we discussed the basic Common Lisp commands for defining variables and functions. Along the way, you learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To define a global variable, use the <code class="literal">defparameter</code> command.</p></li><li class="listitem"><p>To define a global function, use the <code class="literal">defun</code> command.</p></li><li class="listitem"><p>Use the <code class="literal">let</code> and <code class="literal">flet</code> commands to define local variables and functions, respectively.</p></li><li class="listitem"><p>The function <code class="literal">labels</code> is like <code class="literal">flet</code>, but it lets functions call themselves. Functions that call themselves are called <span class="emphasis"><em>recursive</em></span> functions.</p></li></ul></div></div>
<div class="chapter" title="Chapter&#xA0;3.&#xA0;Exploring the Syntax of Lisp Code"><div class="titlepage"><div><div><h1 class="title"><a id="exploring_the_syntax_of_lisp_code"/>Chapter 3. Exploring the Syntax of Lisp Code</h1></div></div></div><p>As you’ve learned so far, Lisp commands must be entered in a rather unorthodox way, with parentheses surrounding each command. In this chapter, we’ll explore why Lisp works this way.</p><p>To understand why any language—whether it’s a programming language or a human language—looks a certain way, we need to begin with two concepts from the field of linguistics: syntax and semantics.<a id="IDX-CHP-3-0001" class="indexterm"/><a id="IDX-CHP-3-0002" class="indexterm"/></p><div class="sect1" title="Syntax and Semantics"><div class="titlepage"><div><div><h1 class="title"><a id="syntax_and_semantics"/>Syntax and Semantics</h1></div></div></div><p>Here is a typical sentence in the English language:</p><table border="0" summary="Simple list" class="simplelist"><tr><td>My dog ate my homework.</td></tr></table><p>This sentence has the correct syntax for a sentence in English. The <span class="emphasis"><em>syntax</em></span> of a piece of text represents the basic rules that it needs to follow to be a valid sentence. Here are some of the rules of sentences in the English language that this text obeys:<a id="IDX-CHP-3-0003" class="indexterm"/><a id="IDX-CHP-3-0004" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The sentence ends in a punctuation mark.</p></li><li class="listitem"><p>The sentence contains a subject and a verb.</p></li><li class="listitem"><p>The sentence is made up of letters in the English alphabet (as opposed to Egyptian hieroglyphics or Sumerian cuneiform).</p></li></ul></div><p>However, there is more to a sentence than just its syntax. We also care about what the sentence actually means. When we talk about the <span class="emphasis"><em>semantics</em></span> of a sentence, we’re referring to its meaning.<a id="IDX-CHP-3-0005" class="indexterm"/></p><p>For instance, here are some sentences that all roughly have identical semantics:</p><table border="0" summary="Simple list" class="simplelist"><tr><td>My dog ate my homework.</td></tr><tr><td>The canine, which I possess, has consumed my school assignment.</td></tr><tr><td>Der Hund hat meine Hausarbeit gefressen.</td></tr></table><p>The first two are just different ways of saying the same thing in English. The third sentence is in German, but it still has the same meaning and, hence, semantics as the first two.</p><p>The same distinction between these two ideas exists in programming languages. For instance, here is a valid line of code written in C++:</p><a id="I_programlisting3_d1e2317"/><pre class="programlisting">((foo&lt;bar&gt;)*(g++)).baz(!&amp;qux::zip-&gt;ding());</pre><p>This line of code obeys the rules of C++ syntax. To make my point, I put in a lot of weird syntax that is unique to C++, which differentiates it from other languages. If you were to place this line of code in a program of another programming language with a different syntax, it would probably be invalid and cause an error.</p><p>Of course, this C++ programming code also means something. If we were to put this line of code in a C++ program (in the proper context), it would cause your computer to <span class="emphasis"><em>do</em></span> something. The actions that a program performs are the <span class="emphasis"><em>semantics</em></span> of the program. It is usually possible to write a program that has the same semantics in different programming languages; that is, the program will do the same thing in both languages.</p><p>What all this boils down to is that most programming languages have similar semantic powers. However, basic Lisp code is different from code in any other major programming language in that it has a far simpler syntax. <span class="emphasis"><em>Having a simple syntax is a defining feature of the Lisp language</em></span>.</p></div></div>
<div class="sect1" title="The Building Blocks of Lisp Syntax"><div class="titlepage"><div><div><h1 class="title"><a id="the_building_blocks_of_lisp_syntax"/>The Building Blocks of Lisp Syntax</h1></div></div></div><p>From the crazy line of C++ code in the previous section, you can get the idea that C++ has a lot of weird syntax—for indicating namespaces, dereferencing pointers, performing casts, referencing member functions, performing Boolean operations, and so on.</p><p>If you were to write a C++ compiler, you would need to do a lot of hard work so that the compiler could read this code and obey the many C++ syntax rules, before you could make any sense of the code.<a id="IDX-CHP-3-0006" class="indexterm"/><a id="IDX-CHP-3-0007" class="indexterm"/><a id="IDX-CHP-3-0008" class="indexterm"/><a id="IDX-CHP-3-0009" class="indexterm"/><a id="IDX-CHP-3-0010" class="indexterm"/><a id="IDX-CHP-3-0011" class="indexterm"/></p><p>Writing a Lisp compiler or interpreter is much easier. The part of a Lisp compiler or interpreter that reads in the code (which Lispers actually call the <span class="emphasis"><em>reader</em></span>) is simpler than in C++ or any other major programming language. Take a random piece of Lisp code:<a id="IDX-CHP-3-0012" class="indexterm"/></p><a id="I_programlisting3_d1e2372"/><pre class="programlisting">(defun square (n)
     (* n n))</pre><p>This function declaration, which creates a function that simply squares a number, consists of nothing more than parentheses and symbols. In fact, you can view it as just a bunch of nested lists, delimited by parentheses.</p><p>Lisp only has one way of organizing bits of code: It uses parentheses to organize the code into <span class="emphasis"><em>lists</em></span>.</p><p>All basic Lisp code uses this simple list-like syntax:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2384"/><img src="httpatomoreillycomsourcenostarchimages781268.png" alt="image with no caption"/></div></div><p>But what sorts of things can we put into these lists? Well, besides other lists, we can also put symbols, numbers, and strings into our code. Here, we’ll look at these basic building blocks, or datatypes, you’ll use in Lisp. (We’ll discuss many other Common Lisp datatypes in later chapters.)</p><div class="sect2" title="Symbols"><div class="titlepage"><div><div><h2 class="title"><a id="symbols"/>Symbols</h2></div></div></div><p><span class="emphasis"><em>Symbols</em></span> are a fundamental type of data in Lisp and are used extensively. A symbol in Lisp is a stand-alone word. Common Lisp symbols are typically made up of letters, numbers, and characters like <code class="literal">+ - / * = &lt; &gt; ? ! _</code>. Some examples of valid Lisp symbols are <code class="literal">foo</code>, <code class="literal">ice9</code>, <code class="literal">my-killer-app27</code>, and even <code class="literal">—&lt;&lt;==&gt;&gt;—</code>.</p><p>Symbols in Common Lisp are <span class="emphasis"><em>case-insensitive</em></span> (although most Lispers avoid using uppercase). To illustrate this, we’ll use a function called <code class="literal">eq</code>, which lets us see if two symbols are identical:</p><a id="I_programlisting3_d1e2421"/><pre class="programlisting">&gt; <strong class="userinput"><code>(eq 'fooo 'FoOo)</code></strong>
T</pre><p>As you can see, this function returned <code class="literal">T</code>, which tells us that Lisp considers these two symbols to be identical. (For now, ignore the quotation mark in front of the symbols. This will be explained shortly, when we discuss <span class="emphasis"><em>data mode</em></span>.)<a id="IDX-CHP-3-0013" class="indexterm"/><a id="IDX-CHP-3-0014" class="indexterm"/><a id="IDX-CHP-3-0015" class="indexterm"/></p></div><div class="sect2" title="Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="numbers"/>Numbers</h2></div></div></div><p>Lisp supports both floating-point numbers and integers. When you write a number, the presence of a decimal point determines whether your number is seen as a floating-point number or an integer. The numbers 1 and 1.0 are two different entities in Common Lisp.<a id="IDX-CHP-3-0016" class="indexterm"/><a id="IDX-CHP-3-0017" class="indexterm"/><a id="IDX-CHP-3-0018" class="indexterm"/></p><p>For instance, if you use most math functions with both an integer and a floating-point number, the integer will become “poisoned,” and a floating-point number will be returned. Here’s a case in point:</p><a id="I_programlisting3_d1e2460"/><pre class="programlisting">&gt; <strong class="userinput"><code>(+ 1 1.0)</code></strong>
2.0</pre><p>Note that the decimal point in the returned number, <code class="literal">2.0</code>, indicates that it is a floating-point number.</p><p>Lisp can perform some amazing feats with numbers, especially when compared with most other languages. For instance, here we’re using the function <code class="literal">expt</code> to calculate the fifty-third power of 53:</p><a id="I_programlisting3_d1e2475"/><pre class="programlisting">&gt; <strong class="userinput"><code>(expt 53 53)</code></strong>
2435684816502271213247760652010472551853345312868564084450513087957
6720609150223301256150373</pre><p>Isn’t that cool? Most languages would choke on a calculation involving such a large number.</p><p>Finally, you should know that something weird could happen if you divide two integers:</p><a id="I_programlisting3_d1e2484"/><pre class="programlisting">&gt; <strong class="userinput"><code>(/ 4 6)</code></strong>
2/3</pre><p>The division function is dividing the 4 by 6. But instead of returning a fraction (0.66666...) as you might expect, it returns a <span class="emphasis"><em>rational number</em></span>, represented as two integers with a division symbol between them. So the <code class="literal">2/3</code> result represents a single rational number, which is the mathematically ideal way to encode a fraction such as this.<a id="IDX-CHP-3-0019" class="indexterm"/></p><p>Note that we get a different answer if there is a floating-point number in our calculation:</p><a id="I_programlisting3_d1e2503"/><pre class="programlisting">&gt;<strong class="userinput"><code> (/ 4.0 6)</code></strong>
0.6666667</pre><p>As in the previous example, the number with the decimal point (<code class="literal">4.0</code>) has poisoned our numbers to give us a fraction as a result.<a id="IDX-CHP-3-0020" class="indexterm"/><a id="IDX-CHP-3-0021" class="indexterm"/><a id="IDX-CHP-3-0022" class="indexterm"/><a id="IDX-CHP-3-0023" class="indexterm"/><a id="IDX-CHP-3-0024" class="indexterm"/><a id="IDX-CHP-3-0025" class="indexterm"/><a id="IDX-CHP-3-0026" class="indexterm"/><a id="IDX-CHP-3-0027" class="indexterm"/><a id="IDX-CHP-3-0028" class="indexterm"/><a id="IDX-CHP-3-0029" class="indexterm"/></p><p>If you’re not a math geek, this might not be of much use to you, but at least you now know what’s happening if you see this sort of thing while you’re coding. You can also rest assured that Lisp will do the right thing with this number when you use it later on in another calculation. Lisp is smart.</p></div><div class="sect2" title="Strings"><div class="titlepage"><div><div><h2 class="title"><a id="strings"/>Strings</h2></div></div></div><p>The last basic building block in Lisp is the <span class="emphasis"><em>string</em></span>. Although strings aren’t really that fundamental to Lisp from a theoretical standpoint, any program that communicates with a human will usually need strings, because humans like to communicate with text.</p><p>To indicate a string in Lisp, surround characters with double quotes. For example, <code class="literal">"Tutti Frutti"</code> is a valid string.</p><p>We can display a string using a function called <code class="literal">princ</code>:</p><a id="I_programlisting3_d1e2568"/><pre class="programlisting">&gt; <strong class="userinput"><code>(princ "Tutti Frutti")</code></strong>
<img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> Tutti Frutti
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> "Tutti Frutti"</pre><p>Notice that printing our text at the REPL<sup>[<a id="CHP-3-FN-1" href="#ftn.CHP-3-FN-1" class="footnote">1</a>]</sup> will cause the text to appear twice. First, we see the actual printing caused by the <code class="literal">princ</code> command <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e2596"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. However, since the REPL will always show the result of evaluating the entered expression, we see our string parroted back to us <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e2602"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. This is because the <code class="literal">princ</code> function also returns a value, which happens to be the source string.</p><p>A string can also contain so-called <span class="emphasis"><em>escaped characters</em></span>. If you want a string to include double quotes or a backslash, you’ll need to prefix these characters with a backslash. For example, this string has two escaped quotes:</p><a id="I_programlisting3_d1e2616"/><pre class="programlisting">&gt; <strong class="userinput"><code>(princ "He yelled \"Stop that thief!\" from the busy street.")</code></strong>
He yelled "Stop that thief!" from the busy street.</pre><p>As you can see, the backslashes in front of the two quotes tell Lisp that these are literal quotation marks in the string, shown in the displayed string just like any other character.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-3-FN-1" href="#CHP-3-FN-1" class="para">1</a>] </sup>As discussed in <a class="xref" href="ch02.html" title="Chapter 2. Creating Your First Lisp Program">Chapter 2</a>, in a read-eval-print loop (or REPL), the functions we enter will be read, then evaluated, and finally printed.</p></div></div></div>
<div class="sect1" title="How Lisp Distinguishes Between Code and Data"><div class="titlepage"><div><div><h1 class="title"><a id="how_lisp_distinguishes_between_code_and"/>How Lisp Distinguishes Between Code and Data</h1></div></div></div><p>When we write our Lisp program, how does Lisp decide which parts of our program consist of code (stuff to be executed) and which parts are just data? The syntax of Lisp has a special way of distinguishing between the two.</p><p>Common Lisp uses two modes when it reads your code: a <span class="emphasis"><em>code mode</em></span> and a <span class="emphasis"><em>data mode</em></span>. You can switch between these two modes when writing Lisp code.<a id="IDX-CHP-3-0030" class="indexterm"/><a id="IDX-CHP-3-0031" class="indexterm"/></p><div class="sect2" title="Code Mode"><div class="titlepage"><div><div><h2 class="title"><a id="code_mode"/>Code Mode</h2></div></div></div><p>Whenever you type something into the Lisp REPL, the compiler assumes that you’re entering a command you want to execute. In other words, Lisp always assumes that you’re writing code and defaults to code mode.<a id="IDX-CHP-3-0032" class="indexterm"/><a id="IDX-CHP-3-0033" class="indexterm"/><a id="IDX-CHP-3-0034" class="indexterm"/></p><p>As we’ve already discussed, Lisp will expect Lisp code to be entered as a list. However, the code should be in a special type of list: a <span class="emphasis"><em>form</em></span>. So when you’re in code mode, as you are when you start typing into the REPL, the commands you enter need to be structured as forms:<a id="IDX-CHP-3-0035" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2665"/><img src="httpatomoreillycomsourcenostarchimages781095.png.jpg" alt="image with no caption"/></div></div><p>A form is simply a list with a special command at the beginning—typically the name of a function.</p><p>When reading a form, Lisp sends all other items in the list to the function as parameters. For example, enter the following into your REPL:</p><a id="I_programlisting3_d1e2674"/><pre class="programlisting">&gt; <strong class="userinput"><code>(expt 2 3)</code></strong>
8</pre><p>This calculates 2^3 = 8. It does this by calling <code class="literal">expt</code>, which computes an exponent. This command was entered in the standard way for Lisp: as a form with the function name at the beginning.<a id="IDX-CHP-3-0036" class="indexterm"/></p><p>When Lisp reads the text for the parameters of such a command, it usually assumes that these parameters are <span class="emphasis"><em>also</em></span> in code mode. Here’s an example:</p><a id="I_programlisting3_d1e2692"/><pre class="programlisting">&gt; <strong class="userinput"><code>(expt 2 (+ 3 4))</code></strong>
128</pre><p>This example has two nested forms. Lisp first looks at the entire expression in code mode. It determines that we’ve entered a form for the <code class="literal">expt</code> command. Then Lisp looks at the arguments to this command, also in code mode. One of these arguments <code class="literal">(+ 3 4)</code> is a form in its own right. This form is then executed, yielding <code class="literal">7</code>. Afterward, this result is passed to the outer <code class="literal">expt</code> form, which is then executed.<a id="IDX-CHP-3-0037" class="indexterm"/><a id="IDX-CHP-3-0038" class="indexterm"/></p></div><div class="sect2" title="Data Mode"><div class="titlepage"><div><div><h2 class="title"><a id="data_mode"/>Data Mode</h2></div></div></div><p>As you might imagine, any stuff written in data mode is treated as data. This means the computer will not try to “execute” it, which allows us to have information in our code that’s just plain old data.<a id="IDX-CHP-3-0039" class="indexterm"/><a id="IDX-CHP-3-0040" class="indexterm"/><a id="IDX-CHP-3-0041" class="indexterm"/></p><p>Let’s take a look at data mode in action. We’ll enter the same form that we entered in code mode in the previous example, with one difference:</p><a id="I_programlisting3_d1e2735"/><pre class="programlisting">&gt; <strong class="userinput"><code>'(expt 2 3)</code></strong>
(expt 2 3)</pre><p>This time, we put a single quote in front of the list. Instead of responding with the sum of the numbers 1 and 2, Lisp simply parrots our expression to us. The single quote tells Lisp to treat the subsequent form as a chunk of data—simply a list of items. Lisp then prints the result of evaluating what we entered, which is the list itself. It ignores any functions or variables in our list, treating everything as data.</p><p>Placing a quote in front of lists so that they won’t be evaluated as a command is called <span class="emphasis"><em>quoting</em></span>. By using quoting, you can tell Lisp, “This next part isn’t a command. It’s just a chunk of data for my program.”<a id="IDX-CHP-3-0042" class="indexterm"/><a id="IDX-CHP-3-0043" class="indexterm"/></p></div></div>
<div class="sect1" title="Lists in Lisp"><div class="titlepage"><div><div><h1 class="title"><a id="lists_in_lisp"/>Lists in Lisp</h1></div></div></div><p>Lists are a crucial feature in Lisp. They are what hold all your Lisp code (as well as data) together. Take any basic piece of Lisp code, such as the following:</p><a id="I_programlisting3_d1e2758"/><pre class="programlisting">(expt 2 3)</pre><p>This piece of code contains a symbol (<code class="literal">expt</code>) and two numbers, all tied together as a list, indicated by the parentheses.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2766"/><img src="httpatomoreillycomsourcenostarchimages783176.png.jpg" alt="image with no caption"/></div></div><p>You can think of a Lisp program as a house. If you were to build a house in Lisp, your walls would be made out of lists. The bricks would be made out of symbols, numbers, and strings. However, a wall needs mortar to hold it together. In the same way, lists in Lisp are held together by structures called <span class="emphasis"><em>cons cells</em></span>.<a id="IDX-CHP-3-0044" class="indexterm"/></p><div class="sect2" title="Cons Cells"><div class="titlepage"><div><div><h2 class="title"><a id="cons_cells"/>Cons Cells</h2></div></div></div><p>Lists in Lisp are held together with cons cells. Understanding the relationship between cons cells and lists will give you a better idea of how Lisp works.<a id="IDX-CHP-3-0045" class="indexterm"/><a id="IDX-CHP-3-0046" class="indexterm"/><a id="IDX-CHP-3-0047" class="indexterm"/></p><p>A cons cell looks like this:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2796"/><img src="httpatomoreillycomsourcenostarchimages781418.png" alt="image with no caption"/></div></div><p>It’s made of two little connected boxes, both of which can point at other things. A cons cell can point to another cons cell or another type of Lisp data. By being able to point to two different things, it’s possible to link cons cells together into lists. In fact, lists in Lisp are just an abstract illusion—all of them are actually composed of cons cells.</p><p>For instance, suppose we create the list '(1 2 3). Here’s how this list is represented in computer memory:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2806"/><img src="httpatomoreillycomsourcenostarchimages781207.png" alt="image with no caption"/></div></div><p>It’s created using three cons cells. Each cell points to a number, as well as the next cons cell for the list. The final cons cell then points at <code class="literal">nil</code>, to terminate the list. (If you’ve ever used a linked list in another programming language, this is the same basic idea.) You can think of this arrangement like a calling chain for your friends: “When I know about a party this weekend, I’ll call Bob, and then Bob will call Lisa, who will call . . .” Each person in a calling chain is responsible for only one phone call, which activates the next call in the list.<a id="IDX-CHP-3-0048" class="indexterm"/></p></div><div class="sect2" title="List Functions"><div class="titlepage"><div><div><h2 class="title"><a id="list_functions"/>List Functions</h2></div></div></div><p>Manipulating lists is extremely important in Lisp programming. There are three basic functions for manipulating cons cells (and hence lists) in Lisp: <code class="literal">cons</code>, <code class="literal">car</code>, and <code class="literal">cdr</code>.<a id="IDX-CHP-3-0049" class="indexterm"/></p><div class="sect3" title="The cons Function"><div class="titlepage"><div><div><h3 class="title"><a id="the_cons_function"/>The cons Function</h3></div></div></div><p>If you want to link any two pieces of data in your Lisp program (regardless of type), the usual way to do that is with the <code class="literal">cons</code> function. When you call <code class="literal">cons</code>, the Lisp compiler typically allocates a small chunk of memory, the cons cell, that can hold two references to the objects being linked. (Usually, the second of the two items being linked will be a list.) For example, let’s link the symbol <code class="literal">chicken</code> to the symbol <code class="literal">cat</code>:<a id="IDX-CHP-3-0050" class="indexterm"/><a id="IDX-CHP-3-0051" class="indexterm"/><a id="IDX-CHP-3-0052" class="indexterm"/><a id="IDX-CHP-3-0053" class="indexterm"/></p><a id="I_programlisting3_d1e2870"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cons 'chicken 'cat)</code></strong>
(CHICKEN . CAT)</pre><p>As you can see, <code class="literal">cons</code> returns a single object, the cons cell, represented by parentheses and a dot between the two connected items. Don’t confuse this with a regular list. The dot in the middle makes this a cons cell, just linking those two items together.</p><p>Notice how we prefix our two pieces of data with a single quote to make sure that Lisp sees them as just data and doesn’t try to evaluate them as code.</p><p>If instead of another piece of data, we attach the symbol <code class="literal">nil</code> on the right side of the list, something special happens:<a id="IDX-CHP-3-0054" class="indexterm"/></p><a id="I_programlisting3_d1e2890"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cons 'chicken 'nil)</code></strong>
(CHICKEN)</pre><p>Unlike with our <code class="literal">cat</code>, the <code class="literal">nil</code> does not show in the output this time. There’s a simple reason for this: <code class="literal">nil</code> is a special symbol that is used to terminate a list in Lisp. That said, the Lisp REPL is taking a shortcut and just saying that we created a list with one item, our <code class="literal">chicken</code>. It could have displayed the result by explicitly showing our cons cell and printing <code class="literal">(CHICKEN . NIL)</code>. However, because this result is coincidentally also a list, it instead will show the list notation.</p><p>The lesson here is that Lisp will always go out of its way to “hide” the cons cells from you. When it can, it will show your results using lists. It will show a cons cell (with the dot between the objects) only if there isn’t a way to show your result using lists.</p><p>The previous example can also be written like this:</p><a id="I_programlisting3_d1e2916"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cons 'chicken ())</code></strong>
(CHICKEN)</pre><p>The <span class="emphasis"><em>empty list</em></span>, <code class="literal">()</code>, can be used interchangeably with the <code class="literal">nil</code> symbol in Common Lisp. Thinking of the terminator of a list as an empty list makes sense. What do you get when you add a chicken to an empty list? Just a list with a chicken in it. The <code class="literal">cons</code> function also can add a new item to the front of the list. For example, to add <code class="literal">pork</code> to the front of a list containing <code class="literal">(beef chicken)</code>, use <code class="literal">cons</code> like so:</p><a id="I_programlisting3_d1e2946"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cons 'pork '(beef chicken))</code></strong>
(PORK BEEF CHICKEN)</pre><p>When Lispers talk about using <code class="literal">cons</code>, they say they are <span class="emphasis"><em>consing</em></span> something. In this example, we consed pork to a list containing beef and chicken.<a id="IDX-CHP-3-0055" class="indexterm"/></p><p>Since all lists are made of cons cells, our <code class="literal">(beef chicken)</code> list must have been created from its own two cons cells, perhaps like this:<a id="IDX-CHP-3-0056" class="indexterm"/><a id="IDX-CHP-3-0057" class="indexterm"/><a id="IDX-CHP-3-0058" class="indexterm"/><a id="IDX-CHP-3-0059" class="indexterm"/></p><a id="I_programlisting3_d1e2979"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cons 'beef (cons 'chicken ()))</code></strong>
(BEEF CHICKEN)</pre><p>Combining the previous two examples, we can see what all the lists look like when viewed as conses. This is what is <span class="emphasis"><em>really</em></span> happening:</p><a id="I_programlisting3_d1e2989"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cons 'pork (cons 'beef (cons 'chicken ())))</code></strong>
(PORK BEEF CHICKEN)</pre><p>Basically, this is telling us that when we cons together a list of three items, we get a list of three items. No wholesale copying or deleting of data ever needs to take place.</p><p>The REPL echoed back to us our entered items as a list, <code class="literal">(pork beef chicken)</code>, but it could just as easily (though a little less conveniently) have reported back the items exactly as we entered them: <code class="literal">(cons 'pork (cons 'beef (cons 'chicken ())))</code>. Either response would have been perfectly correct. <span class="emphasis"><em>In Lisp, a chain of cons cells and a list are exactly the same thing</em></span>.<a id="IDX-CHP-3-0060" class="indexterm"/></p></div><div class="sect3" title="The car and cdr Functions"><div class="titlepage"><div><div><h3 class="title"><a id="the_car_and_cdr_functions"/>The car and cdr Functions</h3></div></div></div><p>Lists are just long chains of two-item cells.</p><p>The <code class="literal">car</code> function is used for getting the thing out of the <span class="emphasis"><em>first</em></span> slot of a cell:</p><a id="I_programlisting3_d1e3023"/><pre class="programlisting">&gt; <strong class="userinput"><code>(car '(pork beef chicken))</code></strong>
PORK</pre><p>The <code class="literal">cdr</code> function is used to grab the value out of the <span class="emphasis"><em>second</em></span> slot, or the remainder of a list:</p><a id="I_programlisting3_d1e3036"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cdr '(pork beef chicken))</code></strong>
(BEEF CHICKEN)</pre><p>You can string together <code class="literal">car</code> and <code class="literal">cdr</code> into new functions like <code class="literal">cadr</code>, <code class="literal">cdar</code>, or <code class="literal">cadadr</code>. This lets you succinctly extract specific pieces of data out of complex lists. Entering <code class="literal">cadr</code> is the same as using <code class="literal">car</code> and <code class="literal">cdr</code> together—it returns the second item from a list. (The first slot of the second cons cell would contain that item.) Take a look at this example:</p><a id="I_programlisting3_d1e3068"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(cdr '(pork beef chicken))</code></strong>
  (BEEF CHICKEN)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &gt; <strong class="userinput"><code>(car '(beef chicken))</code></strong>
  BEEF
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> &gt; <strong class="userinput"><code>(car (cdr '(pork beef chicken)))</code></strong>
  BEEF
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> &gt; <strong class="userinput"><code>(cadr '(pork beef chicken))</code></strong>
  BEEF</pre><p>We know that <code class="literal">cdr</code> will take away the first item in a list <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3111"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. If we then take that shortened list and use <code class="literal">car</code>, we’ll get the first item in the new list <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3120"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Then, if we use these two commands together, we’ll get the second item in the original list <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3126"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Finally, if we use the <code class="literal">cadr</code> command, it gives us the same result as using <code class="literal">car</code> and <code class="literal">cdr</code> together <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3142"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>. Essentially, using the <code class="literal">cadr</code> command is the same as saying that you want the second item in the list.<a id="IDX-CHP-3-0061" class="indexterm"/><a id="IDX-CHP-3-0062" class="indexterm"/></p></div><div class="sect3" title="The list Function"><div class="titlepage"><div><div><h3 class="title"><a id="the_list_function"/>The list Function</h3></div></div></div><p>For convenience, Common Lisp has many functions built on top of the basic three—<code class="literal">cons</code>, <code class="literal">car</code>, and <code class="literal">cdr</code>. A useful one is the <code class="literal">list</code> function, which does the dirty work of creating all the cons cells and builds our list all at once:</p><a id="I_programlisting3_d1e3175"/><pre class="programlisting">&gt; <strong class="userinput"><code>(list 'pork 'beef 'chicken)</code></strong>
(PORK BEEF CHICKEN)</pre><p>Remember that there is no difference between a list created with the <code class="literal">list</code> function, one created by specifying individual cons cells, or one created in data mode using the single quote. They’re all the same animal.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e3186"/><img src="httpatomoreillycomsourcenostarchimages781830.png" alt="image with no caption"/></div></div></div></div><div class="sect2" title="Nested Lists"><div class="titlepage"><div><div><h2 class="title"><a id="nested_lists"/>Nested Lists</h2></div></div></div><p>Lists can contain other lists. Here’s an example:</p><a id="I_programlisting3_d1e3196"/><pre class="programlisting">'(cat (duck bat) ant)</pre><p>This is a list containing three items. The second item of this list is <code class="literal">(duck bat)</code>, which is a list itself. This is an example of a <span class="emphasis"><em>nested list</em></span>.<a id="IDX-CHP-3-0063" class="indexterm"/></p><p>However, under the hood, these nested lists are still just made out of cons cells. Let’s look at an example where we pull items out of nested lists. Here, the first item is <code class="literal">(peas carrots tomatoes)</code> and the second item is <code class="literal">(pork beef chicken)</code>:<a id="IDX-CHP-3-0064" class="indexterm"/><a id="IDX-CHP-3-0065" class="indexterm"/><a id="IDX-CHP-3-0066" class="indexterm"/></p><a id="I_programlisting3_d1e3230"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/> &gt; <strong class="userinput"><code>(car '((peas carrots tomatoes) (pork beef chicken)))</code></strong>
  (PEAS CARROTS TOMATOES)
<img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/> &gt; <strong class="userinput"><code>(cdr '(peas carrots tomatoes))</code></strong>
  (CARROTS TOMATOES)
<img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/> &gt; <strong class="userinput"><code>(cdr (car '((peas carrots tomatoes) (pork beef chicken))))</code></strong>
  (CARROTS TOMATOES)
<img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/> &gt; <strong class="userinput"><code>(cdar '((peas carrots tomatoes) (pork beef chicken)))</code></strong>
  (CARROTS TOMATOES)</pre><p>The <code class="literal">car</code> function gives us the first item in the list, which is a list in this case <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3273"/><img src="httpatomoreillycomsourcenostarchimages783564.png" alt=""/></span>. Next, we use the cdr command to chop off the first item from this inner list, leaving us with (<code class="literal">CARROTS TOMATOES</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3282"/><img src="httpatomoreillycomsourcenostarchimages783562.png" alt=""/></span>. Using these commands together gives this same result <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3288"/><img src="httpatomoreillycomsourcenostarchimages783560.png" alt=""/></span>. Finally, using <code class="literal">cdar</code> gives the same result as using <code class="literal">cdr</code> and <code class="literal">car</code> separately <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e3304"/><img src="httpatomoreillycomsourcenostarchimages783554.png" alt=""/></span>.</p><p>As demonstrated in this example, cons cells allow us to create complex structures, and we use them here to build a nested list. To prove that our nested list consists solely of cons cells, here is how we could create this nested list using only the <code class="literal">cons</code> command:</p><a id="I_programlisting3_d1e3315"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cons (cons 'peas (cons 'carrots (cons 'tomatoes ())))</code></strong>
<strong class="userinput"><code>        (cons (cons 'pork (cons 'beef (cons 'chicken ()))) ()))</code></strong>
((PEAS CARROTS TOMATOES) (PORK BEEF CHICKEN))</pre><p>Here are some more examples of functions based on <code class="literal">car</code> and <code class="literal">cdr</code> that we could use on our data structure:</p><a id="I_programlisting3_d1e3331"/><pre class="programlisting">&gt; <strong class="userinput"><code>(cddr '((peas carrots tomatoes) (pork beef chicken) duck))</code></strong>
(DUCK)
&gt; <strong class="userinput"><code>(caddr '((peas carrots tomatoes) (pork beef chicken) duck))</code></strong>
DUCK
&gt; <strong class="userinput"><code>(cddar '((peas carrots tomatoes) (pork beef chicken) duck))</code></strong>
(TOMATOES)
&gt; <strong class="userinput"><code>(cadadr '((peas carrots tomatoes) (pork beef chicken) duck))</code></strong>
BEEF</pre><p>Common Lisp already defines all these functions for you. You can use any function with the name <code class="literal">c*r</code> right out of the box, up to four levels deep. In other words, <code class="literal">cadadr</code> will already exist for you to use, whereas <code class="literal">cadadar</code> (which is five levels deep) does not (you would need to write that function yourself). These functions make it easy to manipulate cons cells-based structures in Lisp, no matter how complicated they might be.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e3358"/><img src="httpatomoreillycomsourcenostarchimages780154.png" alt="image with no caption"/></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e3364"/><img src="httpatomoreillycomsourcenostarchimages783324.png" alt="image with no caption"/></div></div></div></div>
<div class="sect1" title="What You've Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_apostrophy_ve_learned-id2"/>What You've Learned</h1></div></div></div><p>In this chapter, we discussed the basic Lisp syntax. Along the way, you learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Parentheses in Lisp are there to keep the amount of syntax to a minimum.</p></li><li class="listitem"><p>Lists are created from cons cells.</p></li><li class="listitem"><p>You can create lists by making cons cells with the <code class="literal">cons</code> command.</p></li><li class="listitem"><p>You can inspect the pieces of a list with <code class="literal">car</code> and <code class="literal">cdr</code>.</p></li></ul></div></div></body></html>