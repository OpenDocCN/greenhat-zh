- en: Part II. Lisp is Symmetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782344.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4. Making Decisions with Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned some basic Lisp commands, as well as some
    of the philosophy behind Lisp. In this chapter, we’ll be looking in detail at
    commands for handling conditions. The elegance of these commands shows that the
    unusual philosophy and design of Lisp has real practical benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The Symmetry of nil and ()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing is particularly striking when we look at how Lisp commands and data
    structures work: They are imbued with symmetry in every conceivable way. This
    symmetry can give your Lisp code a certain elegance that other languages cannot
    have, and Lisp’s simple syntax is an important factor in making this symmetry
    possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Empty Equals False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the Lisp philosophy strongly emphasizes the use of lists to store and
    manipulate information, it will come as no surprise that the design of Common
    Lisp favors behaviors that make it easy to slice and dice such lists. The most
    profound design decision made in Common Lisp, with regard to lists, is that it
    automatically treats an empty list as a false value when evaluating a condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that when we pass the empty list `()` into an `if` form,
    it evaluates as a false value, whereas a list that contains an item evaluates
    as true.
  prefs: []
  type: TYPE_NORMAL
- en: Because we can easily detect an empty list, we can process lists using *recursion*.
    With this technique, we can take items from the front of a list and send the rest
    of the list back to the same function until the list is empty. (It’s a good thing
    that detecting empty lists is so easy, because so many functions in Lisp end up
    being list-eaters.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782394.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s look at a common list-eating function, which calculates the length of
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function is written in classic Lisp style. It calls itself recursively
    as it chomps items off the front of the list. Calling yourself in this way is
    not only allowed in Lisp, but is often strongly encouraged. Lists in Lisp are
    recursive (conses of conses of conses . . .), so the act of consuming a list maps
    naturally onto functions that are recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling yourself recursively can sometimes make for slow code. In [Chapter 14](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming"), we’ll rewrite
    the `my-length` function using a special, potentially faster, type of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: The Four Disguises of ()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not only does the empty list evaluate to false, but it is the *only* false
    value in Common Lisp. *Any value not equivalent to an empty list will be considered
    a true* value. This explains why the expression `''(1)` in the earlier example
    was treated as true. However, there are some other expressions in Lisp that are
    disguises for the one and only empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782038.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the expressions in this table are equivalent by comparing them
    with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the only value in the table that seems normal is the quoted list
    on the left side of the comparisons. The other three all seem to break the rules
    of Lisp forms that we talked about in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The first two examples are particularly puzzling. They are missing the quotation
    mark that tells the Lisp environment, “Hey, this item is a piece of data, not
    code!” In the case of `nil`, you would expect that this would actually be the
    name of a variable that could have some kind of arbitrary value. In the case of
    the unquoted `()`, there’s no way you could tell what would happen. The parentheses
    look like a form of code that needs to be evaluated, but a Lisp form always has
    a symbol at the beginning, telling it what to do. What do we do when there’s nothing
    inside the form at all?
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that Common Lisp is architected behind the scenes to make
    sure all four of these values look like an empty list when you use them in your
    program, allowing most Lisp conditionals to be written with an elegant brevity.
    For instance, there is a constant named `nil` that evaluates to itself and allows
    you to omit the quotation mark in the first case ![](httpatomoreillycomsourcenostarchimages783564.png).
    The second case ![](httpatomoreillycomsourcenostarchimages783562.png) is a natural
    by-product of how Common Lisp parses an empty form. The third case ![](httpatomoreillycomsourcenostarchimages783560.png)
    is due to a requirement in the Common Lisp spec that says that `()` and `nil`
    should be treated the same.
  prefs: []
  type: TYPE_NORMAL
- en: Although there’s a certain beauty to having all of these values be the same,
    not every Lisper agrees with this sentiment. After all, are false and empty list
    really the same kind of thing? The creators of the other popular dialect of Lisp,
    Scheme, felt differently about this issue, and preferred to keep the concepts
    of falsity and empty list completely separate, at a slight cost to code brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Conditionals: if and Beyond'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand how Lisp handles true and false, let’s look at `if`
    and some of the other conditional commands.
  prefs: []
  type: TYPE_NORMAL
- en: One Thing at a Time with if
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `if` command can be used to make different things happen when things are
    true (such as when 1 + 2 = 3) or false (such as when 1 + 2 = 4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` command can also be used to check whether a list is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the only way to branch on a condition that we’ve looked at has been
    the `if` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All we’re doing here is checking whether the number 5 is odd, then, depending
    on the result, evaluating one of the two following expressions in the if form.
    Since 5 is odd, it evaluates the first such expression, and the form as a whole
    returns `odd-number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a lot happening in this harmless-looking little command—stuff that’s
    important to understanding Lisp. Here are two important observations:'
  prefs: []
  type: TYPE_NORMAL
- en: Only one of the expressions after the `if` is actually evaluated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can only do one thing in an `if` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usually, when a function is executed in Lisp, all the expressions after the
    function name are evaluated, before the function itself is evaluated. However,
    `if` does not follow these rules. To see this, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Any self-respecting, law-abiding Lisp function would kick your butt to the curb
    if you tried to run this code, because you’re dividing by zero.
  prefs: []
  type: TYPE_NORMAL
- en: But `if` is not just a function. It’s a *special form*, which gives it special
    privileges, such as the right to not evaluate all its parameters in the normal
    way. This makes sense, since the whole point of a condition is to run some stuff
    but not other stuff. In this case, it just merrily ignores the division by zero,
    since it’s in the part of the branch that applies only to even numbers. Conditional
    commands in Lisp are typically special forms.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781852.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the conditional commands may be macros, which are something like user-created
    special forms. Being a special form usually implies that a command is directly
    “baked in” to the language. In [Chapter 16](ch18.html "Chapter 16. The Magic of
    Lisp Macros"), you’ll learn how to write such macros yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Since only one expression inside an `if` is ever evaluated, it’s impossible
    to do two or more separate things inside your branch.
  prefs: []
  type: TYPE_NORMAL
- en: There is actually a clever style of programming (called *functional programming*,
    as we’ll discuss in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch
    with Functional Programming")), which considers this a Good Thing. However, for
    cases when you really want to do more than one thing, you can use a special command,
    `progn`, to wedge in extra commands in a single expression. With `progn`, only
    the last evaluation is returned as the value of the full expression. In this next
    example, for instance, we use the command to set a special global variable directly
    inside our conditional branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782500.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Going Beyond if: The when and unless Alternatives'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since it’s kind of a pain to use `progn` every time you want to do multiple
    things inside an `if`, Lisp has several other commands that include an *implicit*
    `progn`. The most basic of these are `when` and `unless`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With `when`, all the enclosed expressions are evaluated when the condition is
    true. With `unless`, all the enclosed expressions are evaluated when the condition
    is false. The trade-off is that these commands can’t do anything when the condition
    evaluates in the opposite way; they just return `nil` and do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Command That Does It All: cond'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But what do you do if you’re the kind of coder who wants it all? Maybe you just
    ain’t in a compromisin’ mood and want a function that will do everything! Well,
    Lisp has you covered.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781360.png)'
  prefs: []
  type: TYPE_IMG
- en: The `cond` form is the classic way to do branching in Lisp. Through the liberal
    use of parentheses, it allows for an implicit `progn`, can handle more than one
    branch, and can even evaluate several conditions in succession. Since `cond` has
    been around since the Lisp Stone Age, and it’s comprehensive in its abilities,
    many Lisp programmers consider it to be the one true Lisp conditional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779845.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the body of a `cond` uses a layer of parentheses to separate
    the different branches of the condition. Then the first expression of each parenthesized
    part contains the condition for making that branch active. In our example, we
    have different branches for each type of pudding thief: one for Henry ![](httpatomoreillycomsourcenostarchimages783564.png),
    one for Johnny ![](httpatomoreillycomsourcenostarchimages783562.png), and one
    for everyone else ![](httpatomoreillycomsourcenostarchimages783560.png). We use
    `eq` to compare the supplied person’s name with each potential perpetrator.'
  prefs: []
  type: TYPE_NORMAL
- en: The conditions in a `cond` form are always checked from the top down, so the
    first successful match drives the behavior. In this example, the last branch ![](httpatomoreillycomsourcenostarchimages783560.png)
    has a condition of `t` (for true), guaranteeing that at least the last branch
    will always be evaluated. This is a common `cond` idiom.
  prefs: []
  type: TYPE_NORMAL
- en: As with `when` and `unless`, the triggered branch may contain more than one
    command, since there is an implicit `progn`. In this case, the first two branches
    ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)
    set an extra `*arch-enemy*` variable, besides supplying a return variable.
  prefs: []
  type: TYPE_NORMAL
- en: Branching with case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at one final Lisp command: the `case` form. It is common to use
    the `eq` function for conditionals, and `case` lets you supply a value to compare
    against. Using `case`, we can rewrite the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This version of the code is a lot easier on the eyes. The name of the person
    handled by each part of the `case` statement is clearly visible—it’s not hidden
    inside an equality check. Depending on which version of Lisp you use, a `case`
    statement like this may also be more efficient, especially with longer statements,
    where larger numbers of cases are handled.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the `case` command uses `eq` for comparisons, it is usually used only
    for branching on symbol values. It cannot be used to branch on string values,
    among other things. See [Comparing Stuff: eq, equal, and More](ch04s04.html "Comparing
    Stuff: eq, equal, and More") in [Comparing Stuff: eq, equal, and More](ch04s04.html
    "Comparing Stuff: eq, equal, and More") for details.'
  prefs: []
  type: TYPE_NORMAL
- en: Cool Tricks with Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fundamental design of Lisp lets you get a lot of mileage out of a few simple
    commands. Specifically, a couple of counterintuitive tricks involving conditions
    in Lisp can help you write cleaner code. The first involves two new conditional
    commands. The second takes advantage of Lisp’s simple conception of true and false.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Stealth Conditionals and and or
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The conditionals `and` and `or` are simple mathematical operators, which allow
    you to manipulate Boolean values in the same way you might manipulate numbers
    using addition and subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how we could use `and` to see if three numbers are odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because 5, 7, and 9 are odd, the entire expression evaluates as true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use or to see whether at least one of a set of numbers is
    odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because 7 is odd, the `or` command still evaluates as true, despite the fact
    that 4 and 8 are even.
  prefs: []
  type: TYPE_NORMAL
- en: But there’s something a bit more interesting about `and` and `or` that you might
    not notice just by looking at these first two examples. So far, these two commands
    look like completely ordinary mathematical operators; they do not look like conditional
    commands, such as `if` or `cond`. However, they can be used for conditional behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, here’s how we could use these conditionals to set a global variable
    to true only when a number is even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do the same thing using an odd number, the variable remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates that Lisp uses *shortcut Boolean evaluation*. This
    means that once Lisp determines that an earlier statement in a list of or values
    is true, it simply returns true and doesn’t bother evaluating the remaining statements.
    Similarly, once it determines that an earlier statement in a list of `and` values
    is false, it stops without bothering to evaluate the rest of the statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this may seem like a minor esoteric observation, it can actually be very
    useful in many situations. For instance, imagine if you want to save a file to
    disk, but only if the file was modified, and only when the user wants it to be
    saved. The basic structure could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the function `ask-user-about-saving` would ask the user about the file,
    and then return true or false based on the user’s wishes. However, since shortcut
    Boolean evaluation is guaranteed to be used for Boolean operations under Common
    Lisp and most other Lisp dialects, we could write this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using this cleaner style for evaluating conditional code is possible only if
    you think beyond the typical use of the Boolean operators as simply mathematical
    operators. This form has an elegant symmetry between the three expressions, which
    some Lispers may like. However, others would argue that a reader of your code
    may easily miss the fact that `(save-file)` does something beyond returning a
    Boolean value. A bit of time is required to wrap your head around this more-general
    conception of what `and` and `or` actually mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third way to write this code, which is a compromise between the previous
    approaches, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Many experienced Lispers will consider this version a bit clearer than the previous
    two versions, because only expressions that are expressly designed to return a
    Boolean value are treated as part of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: Using Functions That Return More than Just the Truth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s look at another benefit of Lisp’s simple way of thinking about true
    and false. As we’ve already discussed, any value in Common Lisp (except for the
    different variations on `nil`) is true. This means that functions that are commonly
    used in conditions have the option of returning *more than just the truth*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the Lisp command `member` can be used to check for list membership
    for an item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems pretty straightforward. However, once again, there is something
    happening behind the scenes that you may not expect. Let’s run the `member` command
    in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What the heck happened here? Why is it returning `(1 5)`?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, there’s a perfectly rational explanation for this. Whenever a Lisper
    writes a function that returns true and false, she will think to herself, “Is
    there anything else I could return other than just t?” Since all non-nil values
    in Common Lisp evaluate to true, returning some other value is essentially a freebie.
    The implementers of the `member` function decided that some crazy Lisper somewhere
    may see the value in having the tail of the list for some calculation that uses
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember from [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of Lisp
    Code") that the list `'(3 4 1 5)` is the same as the nested contraption `(cons
    3 (cons 4 (cons 1 (cons 5 nil))))`. This should make it clear why the value `(cons
    1 (cons 5 nil))` is an easy thing for the `member` function to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why doesn’t it just return the value it found, instead of the tail? In
    fact, this would have been a useful way to define the `member` function, because
    it would allow passing the original value to some other function in such a manner.
    Unfortunately, one edge case in particular would ruin this plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, the `member` function still gives the correct
    answer, even when we search for `nil` as the member! If the `member` function
    had actually returned `nil` (in other words, the original value we were searching
    for), it would have evaluated as false, and the example would have incorrectly
    stated that nil isn’t in the list. However, since the `member` function returns
    the tail of the list at the point of the found item, it can be guaranteed to always
    be a true value. A successful discovery of the desired value will always return
    a list with at least one value, which we know always evaluates as true.
  prefs: []
  type: TYPE_NORMAL
- en: 'One function that really benefits from rich return values is `find-if`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `find-if` function actually takes another function, in this case `oddp`,
    as a parameter. `find-if` will find the first value in the list for which `oddp`
    returns true. In this case, it will find the first number (if any) that is an
    odd number.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see clearly how `find-if` can fill dual roles: either as a retriever
    of values matching some constraint or as a true/false value inside a condition.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don’t worry yet about the weird hash mark (`#`) in front of `oddp` in the example.
    We’ll discuss the `find-if` function, and other so-called higher-order functions,
    in greater detail in [Chapter 7](ch08.html "Chapter 7. Going Beyond Basic Lists")
    and [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with Functional
    Programming").
  prefs: []
  type: TYPE_NORMAL
- en: 'Alas, the elegant symmetry of the `find-if` function has a single, small, ugly
    wart. If we try our edge case again, searching for a `nil` value, we get a rather
    disappointing result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `null` function, which returns true for any of the `nil` values, correctly
    finds the `nil`. Unfortunately, in this one annoying case, we would not want to
    use `find-if` inside a conditional statement, because a correctly found value
    still returns a result that evaluates as false. The symmetry has been broken.
  prefs: []
  type: TYPE_NORMAL
- en: These are the kinds of small things that make even grown Lispers shed a tear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing Stuff: eq, equal, and More'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s a lot of beautiful symmetry in Lisp. One part of Lisp that isn’t so
    beautiful, though, involves the commands for comparing things.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to compare two values in Lisp to find out if they are “the same,”
    you will find a bewildering assortment of different functions that purport to
    accomplish this. Of these, `equal`, `eql`, `eq`, `=`, `string-equal`, and `equalp`
    are the most commonly used. A Lisper must understand the subtleties of these functions
    intimately in order to know how to compare values correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782684.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we start dissecting this madness, let me give you Conrad’s Rule of Thumb
    for Comparing Stuff. Follow this rule, and though you may not be writing the world’s
    cleanest Lisp code, you will probably be able to post some samples to a newsgroup
    without more seasoned Lispers running you out of town with torches and pitchforks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782114.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Symbols should always be compared to other symbols with `eq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `eq` function is the simplest of all the Lisp comparison functions, and
    it’s also very fast. It doesn’t really work for comparing items besides symbols,
    but if you consider the central role symbols play in Lisp, you’ll realize how
    useful this function can be. Experienced Lispers might look down on code if it
    compares two things, known to be symbols, with something other than `eq`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`eq` can also be used to compare conses (the links created by the cons command).
    However, it returns true values only when a cons is compared directly to itself,
    created by the same cons call. This means, two unrelated conses that “look” exactly
    the same can fail an eq test. Since `eq` can check a cons cell only against itself,
    using `eq` with conses isn’t really that useful for a beginner. However, an advanced
    Lisper may want to compare conses with `eq` under certain circumstances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not dealing with two symbols, just use `equal`. This command will
    tell you when two things are `isomorphic`, meaning they “look the same.” It works
    for the whole suite of basic Lisp datatypes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most items in Lisp can be effectively compared with `equal`,
    including strings and characters (which are discussed in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the bare minimum about Lisp comparisons to fake your way through
    your next cocktail party, let’s look at all the other comparison commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783512.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `eql` command is similar to the `eq` command, but unlike `eq`, it also
    handles comparisons of numbers and characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equalp` command is essentially the same as the `equal` command, except
    that it can handle some difficult comparison cases with a bit of extra sophistication.
    For instance, it can compare strings with different capitalizations and can compare
    integers against floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The remaining comparison commands are just specializations for specific datatypes.
    Otherwise, they are similar to `equal`. For instance, the = (equal sign) function
    handles numbers, `string-equal` handles strings, and `char-equal` handles characters.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you can now appreciate just how seriously Lispers take comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed how conditions work in Lisp. Along the way, you
    learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The values `nil`, `'nil`, `()`, and `'()` are all basically the same thing in
    Common Lisp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp makes it easy to check for empty lists. This makes it simple to write list-eaters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp conditionals, such as the `if` command, cause Lisp code to be evaluated
    only under the right conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a conditional command that does everything, then you want to use
    `cond`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing stuff in Lisp is complicated, but you can get by if you just use `eq`
    for comparing symbols and `equal` for comparing everything else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 5. Building a Text Game Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write a program, no matter which programming language you’re using
    or what your program does, it will probably need to work with text. Sure, one
    day we may all have Ethernet ports at the base of our skulls (100Mbps Ethernet
    will have been fully adopted by then, of course). But until the day arrives when
    you can just exchange thoughts with your MacBook using a direct hookup, you’ll
    be stuck using alphabetic text for input and output in your software.
  prefs: []
  type: TYPE_NORMAL
- en: Computers have always had a bit of a tenuous relationship with text. Although
    we tend to think of text processing as a central task for computer hardware and
    software (indeed, the 8-bit byte is the standard design element in modern computers,
    in large part, due to how well suited it is for encoding Western character sets),
    the truth of the matter is that the human concept of *text* is really alien to
    a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to use Lisp to manipulate text. You’ll see,
    once again, that the Lispy approach to solving problems allows you to create code
    that is full of elegance and symmetry. To demonstrate this approach, we will do
    something that would seem to make thinking with text unavoidable: build the engine
    for a simple text adventure game. However, we’ll do this in a way that avoids
    constraining our code by artificially forcing the human notion of text into its
    design. This will allow us to write code that focuses on the strengths of a computer.'
  prefs: []
  type: TYPE_NORMAL
- en: As you read this chapter, remember that handling text is not a computer’s strength.
    It is a necessary evil best kept to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: The Wizard's Adventure Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this game, you are a wizard’s apprentice. You’ll explore the wizard’s house.
    When we complete the game (in [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages")), you’ll be able to solve puzzles and win a magical donut.
  prefs: []
  type: TYPE_NORMAL
- en: Our Game World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a picture of our game world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780116.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we can visit three different locations: a living room, an attic,
    and a garden. Players can move between places using the door and the ladder to
    the attic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of this game world as a simple directed graph with three nodes (represented
    as ellipses) and four edges (represented as arrows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782728.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Players move between nodes by traveling along the edges in either direction.
    Wherever the players are, they can interact with various objects around them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782136.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Basic Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our game code will need to handle a few basic things:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking to different locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking up objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing actions on the objects picked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we’ll address the first three of these requirements. To perform
    more complex actions on objects, we’ll use the more advanced Lisp techniques covered
    in later chapters. Because of this, our game engine will be somewhat limited in
    its abilities until we finish it in [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages").
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking around in our game world, you will be able to “see” three kinds
    of things from any location:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic scenery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more paths to other locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects that you can pick up and manipulate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s add features for these one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the Scenery with an Association List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The world inside our adventure game is very simple, containing only three locations.
    Let’s first create a top-level variable, `*nodes*`, to contain descriptions of
    the locations that exist in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This variable contains a list and description of our three locations. In essence,
    the `*nodes*` variable basically gives us a way to find a piece of data associated
    with a lookup key. In this case, the key is the name of the place (`living-room`,
    `garden`, or `attic`), and the data is a text description of the scenery at that
    place. This type of structure is called an *association list*, or *alist* for
    short (alists are covered in greater detail in [Chapter 7](ch08.html "Chapter 7. Going
    Beyond Basic Lists")).
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing is rather unusual about the definition of this `*nodes*` variable:
    Even though it contains descriptions of the various locations in our game world,
    it does not actually contain any text strings. Since Common Lisp has a string
    datatype, we could have written descriptions using quotes. For instance, we could
    have written `"You are in a beautiful garden. There is a well in front of you."`
    Instead, we use more fundamental datatypes—symbols and lists—to encode this information.'
  prefs: []
  type: TYPE_NORMAL
- en: Why wouldn’t we just use strings? As I mentioned at the beginning of this chapter,
    the manipulation of text is not really a fundamental computing concept. In this
    game, we’ll manipulate the messages displayed to players based on their interaction
    with the game world in complicated ways. For most real-world programs, the information
    you’ll generate as output (such as HTML, PDFs, or even richer graphical formats)
    will probably be far more complicated than just simple text.
  prefs: []
  type: TYPE_NORMAL
- en: By keeping your source data structures free from assumptions regarding the output
    format from the start, your coding can take full advantage of your programming
    language. Since the easiest things to manipulate in Lisp are symbols and lists,
    most experienced Lispers will try to focus on these datatypes in the design of
    their software whenever possible. So, we will stay away from strings in our design.
    (In the next chapter, we will translate these lists and symbols into properly
    formatted text.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common Lisp doesn’t force you to represent strings with lists and symbols in
    this way. If it’s more convenient, you can work with strings directly. (You’ll
    see examples of working with strings later in the book, especially in [Chapter 11](ch12.html
    "Chapter 11. Printing Text with the format Function").) Using lists and symbols
    as an intermediary for manipulating text is definitely an old-school Lisp technique.
    However, it can often lead to very elegant code, since list operations are so
    fundamental to Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we’ve created an alist of our game world, we need to create a command
    to describe a location. To accomplish this, we’ll use the `assoc` function to
    find the correct item in the list using a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `assoc`, we can easily create the `describe-location` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this function, we pass in a location and the `*nodes*` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Why don’t we just reference the `*nodes*` variable directly from the `describe-location`
    function? Because this function is written in the *functional programming* style.
    In this style, a function will reference only parameters or variables declared
    in the function itself, and it will do nothing besides return a value, which is
    the description of the location in this case.
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that don’t reference variables in the “outside world” directly
    and that don’t perform any actions other than returning a value, you can write
    code that can easily be tested in isolation. You should try to write your Lisp
    functions in this style whenever possible. (We will discuss the functional programming
    style in greater detail in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up
    a Notch with Functional Programming").)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782164.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Describing the Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have basic descriptions of each location, we need descriptions of
    paths to other locations as well. We’ll create a second variable, `*edges*`, that
    contains the paths that players can take to move between places on our map. (We
    use the term *edges* because that’s the proper math term for the lines connecting
    nodes in a graph.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using this structure, we create the `describe-path` function, which builds a
    textual description of a given edge using our symbols system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This `describe-path` function looks pretty strange—almost like a piece of data
    more than a function. Let’s try it, and then figure out how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function basically returns a piece of data with small bits of calculated
    information inserted into it. This feature of Lisp, called *quasiquoting*, allows
    us to create chunks of data that have small pieces of Lisp code embedded in them.
  prefs: []
  type: TYPE_NORMAL
- en: How Quasiquoting Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable quasiquoting, you must use a backquote [`` ` ``] not a single quote
    [`'`] when switching from code to data mode. The `describe-path` function has
    just such a backquote in it.
  prefs: []
  type: TYPE_NORMAL
- en: Both the single quote and backquote in Lisp “flip” a piece of code into data
    mode, but only a backquote can also be *unquoted* using the comma character, to
    flip back into code mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a little imagination, this should make sense to you. After all, a comma
    does look just like an upside-down backquote, doesn’t it? Here’s how the flip-flop
    in the `describe-path` function works (the parts in code mode are shaded):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779865.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Lisp attempts to make list manipulation as easy as possible. Here, you can see
    how our program, which uses lists of symbols to store our text, can now leverage
    the quasiquoting feature to construct sentences in a very concise and clear way.
  prefs: []
  type: TYPE_NORMAL
- en: Describing Multiple Paths at Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s use our `describe-path` function to create a more advanced function.
    Since a location may have any number of paths exiting from it, we need a function
    that can generate descriptions for all edges from a given location by looking
    up the location from our data structure of edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This function uses a bunch of commands that may seem very exotic to a person
    not accustomed to the world of Lisp. Many programming languages would use some
    kind of for-next loop to run through the edges, and then cram the descriptions
    of each path together using a temporary variable. Lisp uses a much more elegant
    approach. Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `describe-paths` function takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the relevant edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the edges to descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join the descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s see how it performs each of these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Relevant Edges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first, inner part of the `describe-paths` function is pretty straightforward.
    To find the relevant paths and edges leading from the living room, we use `assoc`
    again to look up the location in our list of edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Converting the Edges to Descriptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, the edges are converted to descriptions. Here is just the code to accomplish
    this, shown in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mapcar` function is used frequently by Lispers. This function takes another
    function and a list, and then applies this function to every member of a list.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This example passes the `sqrt` (square root) function, along with the `(1 2
    3 4 5)` list, into `mapcar`. As a result, the function generates a list of the
    square roots of the original numbers by applying `sqrt` to every member of the
    list and creating a new list.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that take other functions as parameters, such as `mapcar`, are very
    useful and a distinguishing feature of Lisp. Such functions are called *higher-order
    functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This time, our source list contains two smaller lists. The `car` function, which
    grabs the first item in a list, causes `mapcar` to return the first items from
    each smaller list, `foo` and `baz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering why the function names we pass into `mapcar` have the
    `#''` symbols in front of them. This symbol sequence is a shorthand for the `function`
    operator. The Lisp reader (the part of your Lisp environment that reads the code
    you type) will convert the previous example into the following longer version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Common Lisp requires you to use the `function` operator when referring to a
    function as a value directly like this, because the name of a function may conflict
    with other named items in a program, causing unpredictable errors. For instance,
    imagine if we added more stuff to the previous example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this version, the `car` symbol could have two different meanings. The first
    meaning of car is that it is a standard function built into Lisp (introduced in
    [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of Lisp Code")). However,
    we’re also creating a local variable named `car` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Because we prepended the word `car` with `#'` in our call to `mapcar` ![](httpatomoreillycomsourcenostarchimages783562.png),
    there is no confusion about which `car` we are talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the `describe-paths` function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `append` and `describe-path` functions are passed in as values
    to the `apply` and `mapcar` functions, which are designed to receive and use the
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp tracks function names differently from variable names. It has multiple
    *namespaces*, including one for variables and one for functions. (We’ll learn
    more about namespaces later, especially in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").) Scheme, the other popular Lisp dialect, doesn’t force
    you to mark functions with a function operator when using them as values.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Scheme has only one namespace for both functions and variables.
    For instance, in Scheme, you can just write `(map sqrt '(1 2 3 4 5))` to generate
    the square roots of the numbers 1 through 5 without generating an error (`map`
    is the Scheme version of `mapcar`). As a result of this design, in Scheme, a variable
    and a separate function can’t be available in the same block of code. That design
    decision is one of the great benefits (or curses) of Scheme, depending on your
    point of view. Because of this difference in the number of namespaces, Scheme
    is sometimes called a *Lisp-1*, whereas Common Lisp is sometimes referred to as
    a *Lisp-2*.
  prefs: []
  type: TYPE_NORMAL
- en: Joining the Descriptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we’ve used `mapcar` to generate a list of descriptions for all the paths
    and edges, we need to combine them into a single description. We accomplish this
    with the `append` function, which joins several lists into one big list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We use the `append` function to cram the list of path descriptions into one
    list that describes the whole enchilada, in one swoop. The problem is that `append`
    needs all of the lists handed to it as separate parameters. In `describe-paths`,
    we have our lists in one big list, not as separate objects we can pass as parameters.
    Heck, we don’t even know how many paths there may be from any given spot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apply` function solves this problem. You pass it a function and a list
    of objects, and it pretends that the items in the list are separate objects and
    passes them to the given function as such. For example, if we have the nested
    list `''((mary had) (a) (little lamb))`, the `apply` function will add in that
    little bit of duct tape needed to make the `append` function work with a single
    big list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the `apply` function passes each item in a list as an argument to the
    `target` function, you can run into problems when calling it on very large lists
    that have thousands of items or more. You can check the value of the `call-arguments-limit`
    variable in the REPL to see the maximum number of allowed arguments to a function.
    (More recent dialects of Lisp are typically designed to allow argument lists of
    any size, without an artificial limit.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how `apply` enables the `describe-paths` function to build one
    long list describing all paths leading from a single location. Let’s use this
    same approach on the path description lists we constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve looked at each part of the `describe-paths` function, let’s
    review how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The function takes two parameters: the current player’s location, as well as
    an alist of edges/paths for the game map. First, it uses `assoc` to look up the
    correct location from the edge alist. Since `assoc` returns both the key and the
    value from the alist, we call `cdr` to retrieve only the value. Next, we use `mapcar`
    to map the `describe-path` function against each edge that we found. Finally,
    we concatenate the lists for describing all the paths into one long list by applying
    `append` against the list.'
  prefs: []
  type: TYPE_NORMAL
- en: The programming style used by `describe-path` is very typical for Lisp code.
    It involves passing along a complicated chunk of data and manipulating it in several
    steps, often using higher-order functions. To become a proficient Lisp programmer,
    you should try to get comfortable reading code written in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Describing Objects at a Specific Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the final piece of code to help us visualize our game world, we need
    to describe the objects on the floor at a given location, which a player can pick
    up and use.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Visible Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do so, we first create a list of the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780738.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also create a second variable, `*object-locations*`, to track the location
    of each object in the form of an alist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write a function that lists the objects visible from a given location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This `objects-at` function declares a new function named `at-loc-p` using the
    `labels` command ![](httpatomoreillycomsourcenostarchimages783564.png). (Remember
    that the `labels` function allows you to define functions locally.) Since the
    `at-loc-p` function won’t be used elsewhere, we can just declare it directly within
    `objects-at`, hiding it from the rest of the code in our program.
  prefs: []
  type: TYPE_NORMAL
- en: The `at-loc-p` function takes the symbol for an object and returns `t` or `nil`,
    depending on whether that object exists at the location `loc`. It does this by
    looking up the object in the `obj-locs` alist. Then, it uses `eq` to see whether
    the location it finds matches the location in question ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Why did we name this function `at-loc-p`? When a function returns `nil` or a
    truth value, it’s a Common Lisp convention to append a `p` to the end of that
    function’s name. For instance, you can check that the number 5 is odd by calling
    `(oddp 5)`. Such true/false functions are called *predicates*, which is why we
    use the letter `p`.
  prefs: []
  type: TYPE_NORMAL
- en: The `remove-if-not` function in the last line of the listing ![](httpatomoreillycomsourcenostarchimages783560.png),
    as you might expect, removes all things from a list for which a passed-in function
    (in this case, `at-loc-p`) doesn’t return true. Essentially, it returns a filtered
    list of objects consisting of those items for which `at-loc-p` is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what `object-at` looks like in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Describing Visible Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can write a function to describe the objects visible at a given location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, `describe-objects` first creates the `describe-obj` function
    ![](httpatomoreillycomsourcenostarchimages783564.png). This function generates
    a pretty sentence stating that a given object is on the floor, using quasiquoting
    ![](httpatomoreillycomsourcenostarchimages783562.png). The main part of the function
    consists of calling `objects-at` to find the objects at the current location,
    mapping `describe-obj` across this list of objects, and finally appending the
    descriptions into a single list ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try running `describe-objects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Perfect!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783048.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Describing It All
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we’ll tie all of these description functions into one easy command called
    `look`. Because this will be the actual command players can enter to look around
    them in the game, `look` will need to know a player’s current location. So, we
    need a variable to track the player’s current position. Let’s call it `*location*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `*location*` value is initialized to the `living-room` symbol,
    which occurs at the very start of the game, players will find themselves in the
    living room of the wizard’s house. At this point, we can write a `look` function
    to describe everything we need by having it call all of our descriptor functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Since the `look` function uses global variable names (such as `*location*`,
    `*nodes*`, and so on), the player won’t need to pass in any funky values in order
    to look out at the world. However, this also means that the `look` function is
    not in the functional programming style, because functions in the functional programming
    style reference only parameters or variables declared in the function itself.
    `*location*` and its ilk are global variables, so the `look` function doesn’t
    hold up muster.
  prefs: []
  type: TYPE_NORMAL
- en: Since the player’s location changes as the game progresses, `look` will do *different
    things at different times* in the game. In other words, the things you see when
    looking around will change depending on your location. In contrast, a function
    in the functional programming style always returns the same result, as long as
    the same values are given as parameters. The earlier functions we created, such
    as `describe-location`, `describe-paths`, and `describe-objects`, always return
    the same thing, no matter when they are called, *as long as their parameters are
    kept the same*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here’s what we see when we use `look`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781300.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Walking Around in Our World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can see things in our world, let’s write some code so that we can
    walk around. The `walk` function (not in the functional style) takes a direction
    and lets us walk there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: First, this function looks up the available walking paths in the `*edges*` table,
    using the current location ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is used by the `find` function to locate the path marked with the appropriate
    direction ![](httpatomoreillycomsourcenostarchimages783564.png). (`find` searches
    a list for an item, then returns that found item.) The `direction` (such as `west`,
    `upstairs`, and so on) will be in the `cadr` of each path, so we need to tell
    `find` to match the `direction` against the `cadr` of all the paths in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by passing `find` a *keyword parameter* ![](httpatomoreillycomsourcenostarchimages783560.png).
    In Common Lisp, many functions (such as `find`) have built-in features that can
    be accessed by passing in special parameters at the end of the function call.
    For instance, the following code finds the first item in a list that has the symbol
    `y` in the `cadr` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A keyword parameter has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the name (in this case `:key`), which begins with a colon. (We’ll
    discuss the meaning of this colon in more detail in [Chapter 7](ch08.html "Chapter 7. Going
    Beyond Basic Lists").)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the value, which in this case is `#'cadr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use keyword parameters the same way in our `walk` function to find the proper
    path based on the given direction.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the correct path, we store the result in the variable `next` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `if` expression then checks whether `next` has a value ![](httpatomoreillycomsourcenostarchimages783554.png)
    (the `next` variable isn’t `nil`). If `next` has a value, `if` adjusts the player’s
    position because this is a valid direction ![](httpatomoreillycomsourcenostarchimages783510.png).
    The call to `look` ![](httpatomoreillycomsourcenostarchimages783544.png) retrieves
    the description for the new location and returns it as a value. If the player
    chooses an invalid direction, `look` will generate an admonishment instead of
    a new description ![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what our `walk` function looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There’s a quote in front of the direction, since the direction name needs to
    be written in data mode. It’s kind of awkward to force a player to put a quote
    in a game command, but the interface we are creating now is intended for easy
    debugging and development. Heck, it’s almost not even worth calling an “interface,”
    since we just enter the game commands directly into the REPL. In the next chapter,
    we’ll create a much nicer interface using a custom REPL designed for playing text
    games that will take care of this wart.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could use Lisp *macros* to create a command in a vanilla Lisp REPL that
    doesn’t require the quote in front of the direction, so that you could just write
    `(walk west)`, for instance. You’ll learn more about macros in [Chapter 16](ch18.html
    "Chapter 16. The Magic of Lisp Macros").
  prefs: []
  type: TYPE_NORMAL
- en: Picking Up Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let’s create a command to pick up objects in our world. To do so, we
    modify the variable `*object-locations*` that we’re using to track the location
    of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `pickup` function uses the `member` ![](httpatomoreillycomsourcenostarchimages783564.png)
    function to see if the `object` is indeed on the floor of the current location.
    (The `member` function checks to see if a particular item is found in a list of
    items.) We use the `objects-at` command ![](httpatomoreillycomsourcenostarchimages783562.png)
    to generate the lists of objects at the current location.
  prefs: []
  type: TYPE_NORMAL
- en: If the object is at the current location, we use the push command ![](httpatomoreillycomsourcenostarchimages783560.png)
    to push a new item onto the `*object-locations*` list, consisting of the item
    and its new location. The new location will just be `body`, for the player’s body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` command ![](httpatomoreillycomsourcenostarchimages783560.png) simply
    adds a new item to the front of a list variable’s list. For example, the following
    example adds the number `7` to the list `1 2 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This `push` command is basically a convenience function built on top of `setf`.
    For example, we could have replaced the preceding `push` command with `(setf *foo*
    (cons 7 *foo*))` and obtained the same result. It’s just easier to use `push`.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a new location for an object onto our `*object-locations*` alist does
    seem a bit odd. Since we’re never removing old locations for objects, just pushing
    new ones, it means that `*object-locations*` may contain multiple entries for
    a single object, and that this list now has two stored locations for the object
    in question. Fortunately, the `assoc` command, which we use to find objects in
    a given location (within the `objects-at` command), always returns the first item
    it finds in a list. Therefore, using the `push` command makes the `assoc` command
    behave as if the value in the list for a given key has been replaced altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `push` and `assoc` commands together in this way allows us to pretend
    that values in an alist are changing, while still preserving old values. Old values
    are simply suppressed by newer values, thus preserving a history of all old values.
    The `push`/`assoc` idiom is a common technique used by Lispers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s walk back to the living room and try to pick up an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It worked. We’re carrying the whiskey, which means that we can now pick up things
    in our world!
  prefs: []
  type: TYPE_NORMAL
- en: Checking Our Inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let’s create a function that lets players see an inventory of objects
    they are carrying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This inventory function uses the `objects-at` function to retrieve a list of
    objects at a requested location. What location does it search for? If you remember,
    when an object was picked up by the player, we changed its location to `''body`:
    This is the location we now use to query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out this `inventory` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are carrying only one item right now: the whiskey bottle
    we just picked up.'
  prefs: []
  type: TYPE_NORMAL
- en: There you have it! We now have a basic engine for a text adventure game. We
    can look around the world with `look`; walk between places with `walk`; pick up
    objects with `pickup`; and check our inventory with `inventory`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don’t really have much of a game, since we can’t *do* anything
    with the objects we find. We’ll add a mechanism for actually manipulating objects
    in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages"). In the next
    chapter, we’ll focus on improving our game’s user interface. Even though the REPL
    is perfect for prototyping our game, adding a custom text game interface will
    make the game play more seamless for the player.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we put together a simple engine for a text adventure game.
    Along the way, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A game world can be represented by a mathematical graph, consisting of *nodes*
    for the places the player can visit and *edges* for the paths between these places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can store these nodes in an *association list* (*alist*) called `*nodes*`.
    This *alist* allows you to look up properties of a node/place by using its name.
    In the case of our game, the property we’re storing is a description of each node/place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use the assoc function to look up a key (location name in our example) in
    an alist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quasiquoting* is a technique that allows you to insert small bits of computer
    code into larger pieces of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Lisp functions accept other functions as arguments. These are called *higher-order
    functions*. The `mapcar` function is the most popular higher-order function in
    Common Lisp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To replace a value from an alist, you `push` new items onto the list. Only the
    most recent value will be reported by the `assoc` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 6. Interacting with the World: Reading and Printing in Lisp'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven’t written any code that directly interacts with the outside
    world. Instead, all the results generated by commands are just returned as values,
    which we can see by calling functions from our Lisp REPL.
  prefs: []
  type: TYPE_NORMAL
- en: However, code can’t just spend its whole life sitting in a black box. At some
    point, it’s going to need to interact with the world, so it will need a user interface.
    Luckily, Lisp has much to offer to help you create user interfaces. There are
    many graphical user interface libraries for different flavors of Common Lisp,
    as well as libraries for building web interfaces. In fact, we’ll be building our
    own toy web interface in [Chapter 13](ch14.html "Chapter 13. Let's Create a Web
    Server!").
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll focus on the most basic of all user interfaces, the *command-line
    interface*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783418.png)'
  prefs: []
  type: TYPE_IMG
- en: Printing and Reading Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a command-line interface, we need commands that can directly print text
    from the screen and read in text entered by the user. The two commands that do
    this are, appropriately enough, `print` and `read`. As you might expect by now,
    there is a lot of symmetry between these two commands.
  prefs: []
  type: TYPE_NORMAL
- en: Printing to the Screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `print` function simply lets you print stuff to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Don’t get confused by the fact that calling the `print` function caused `"foo"`
    to be printed twice. The first `"foo"` ![](httpatomoreillycomsourcenostarchimages783564.png)
    is what the `print` function *actually printed*. The second `"foo"` ![](httpatomoreillycomsourcenostarchimages783562.png)
    is there because, as you know, the REPL always prints the value of any expression
    that is entered. It so happens that the value of `(print "foo")` is `"foo"`, causing
    the word to be shown twice. In the examples that follow in this chapter, I’ll
    typically omit this extra final value printed by the REPL, just to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print` function is an easy way to print a Lisp value to the screen. However,
    advanced Lispers often favor a related function called `prin1`. To understand
    the difference, let’s try both of these functions out in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print` function causes each item to be printed on a separate line. Now,
    let’s try `prin1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `prin1` does not put the printed items on separate lines. To
    be precise, the `print` and `prin1` commands are the same in every way, except
    that `print` will start a new line before printing a value. Additionally, print
    places a space character at the end of the printed value.
  prefs: []
  type: TYPE_NORMAL
- en: Because `prin1` does less, it is really a simpler, more fundamental function.
    It is more flexible and, therefore, is commonly used in more serious Lisp code.
    We’ll use the `print` function more frequently in this book, but you should be
    aware of the `prin1` command, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Saying Hello to the User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following example is a simple function, `say-hello`, that you can call from
    your Lisp prompt. It asks users for their name and responds with a greeting. *When
    you run the program, be sure to type quotes around your name, even if this may
    seem odd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the `say-hello` function, we print a message asking users
    for their name ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we
    define a local variable called `name`, which is set to the value returned by the
    `read` function ![](httpatomoreillycomsourcenostarchimages783562.png). The `read`
    function will cause Lisp to wait for the user to type in something at the REPL.
    Only after the user has typed something in at the prompt and pressed enter will
    the variable `name` be set to the result. Once we know the user’s name, a personalized
    message is printed, greeting the user ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from this simple function, the `print` and `read` functions
    do (almost) exactly what you would expect. The `print` function prints something
    on the screen. The `read` function lets the user enter something into the program.
    However, there is one glaring idiosyncrasy in these functions: Every value displayed
    and entered is surrounded by quotation marks.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with print and read
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you need to print something on the screen, you should first think of the
    `print` command. If you need to read something in, you should first think of the
    `read` command. Other printing commands let you create the previous example without
    having superfluous quotes, but whenever you have an input or output task in Lisp,
    you should ask yourself, “Can `print` or `read` do the job?” You will save yourself
    a lot of trouble if you always use these two functions as your starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `read` command can be dangerous if used in the wrong way. See [The Dangers
    of read and eval](ch06s05.html "The Dangers of read and eval") in [The Dangers
    of read and eval](ch06s05.html "The Dangers of read and eval") for details.
  prefs: []
  type: TYPE_NORMAL
- en: The `print` and `read` functions think about values with the mind of a computer,
    not the mind of a human. A computer loves having strings of text surrounded by
    quotes. It doesn’t have a human brain, and consequently, it can’t understand what
    we mean when we feed it raw textual information. However, if a text fragment is
    surrounded by quotes, even a dumb old computer can figure out that the value we’re
    handing it is probably a string of text.
  prefs: []
  type: TYPE_NORMAL
- en: The `print` and `read` commands actually take this philosophy to the extreme.
    Almost any conceivable type of data in Lisp (with the exception of actual functions
    and some advanced data structures) can be printed and read using these commands,
    without the slightest bit of loss along the way. You can probably already imagine
    some scenarios where this feature would be immensely valuable, such as writing
    some hairy and huge piece of data to a file, and loading it in again at a later
    date.
  prefs: []
  type: TYPE_NORMAL
- en: As a simple example, the following code has *exactly* the same design as the
    previous function, but amazingly, it can read and print a number instead of a
    string. Notice how the program prints and reads numbers without the use of quotes,
    since Lisp knows when something is a number just by seeing the number in its raw
    form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at some more examples of what happens when we use `print` to write
    out values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: These examples are all really boring, since `print` pretty much just prints
    out exactly what we put in. Note that we put an explicit quote on the front of
    each value. It could be omitted and would be implicit in all cases but the symbol
    name, since a symbol can also refer to functions.
  prefs: []
  type: TYPE_NORMAL
- en: The last example shows how literal characters are entered in Lisp. To create
    a Lisp character, just place the `#\` symbols in front of the actual character.
    Lisp also has special literals defined for nonvisible characters. The most important
    for everyday use are `#\newline`, `#\tab`, and `#\space`.
  prefs: []
  type: TYPE_NORMAL
- en: A table of output from the `read` function would look just as boring as this
    table for `print`, in the same symmetrical way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the examples above I stated that Common Lisp symbols are blind to letter
    case. While this is true for most strings, it is in fact possible to create case-sensitive
    symbols by surrounding the symbol with the vertical pipe `|`. So the symbol `|CaseSensitiveSymbol|`
    will retain its case. Symbols surrounded by vertical pipes can even contain punctuation.
    Hence `|even this is a legal Lisp symbol!|`
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Printing Stuff the Way Humans Like It
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, our initial little `say-hello` function does a pretty awful job
    of greeting people, even if it has some interesting properties. It would be much
    better if we had more functions that could make it friendlier for humans. Actually,
    we can create a (very symmetrical) little table that summarizes what we would
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782488.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, Lisp has a command that can print pieces of data in a way that
    is appealing to humans. The princ function can take any piece of Lisp data, and
    it tries to print that data in a way humans would prefer. It will do the basic
    things you might expect: leave off the quotes on a string, print characters in
    their raw form, and so on. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of `princ`ing a character that has a special meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: By its nature, `princ` could be used to print any arbitrary output of characters
    you want. This is fundamentally different from `print`. As we’ve discussed, the
    cool thing about the `print` command is that it prints objects in such a way that
    they can always be “read” back into their internal representation. However, this
    means `print` can’t be used to generate any arbitrary bit of text. On the other
    hand, `princ` can be used to print anything you want.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, although `princ` can print stuff in a way that humans prefer, it’s
    a one-way street. Once we’ve printed things with `princ`, only a humanlike intelligence
    could decipher how to change things back into a meaningful, appropriate Lisp data
    structure. Since computers are too stupid to do this right now, it means our beloved
    symmetry has been broken.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could always cheat and come up with some arbitrary rules for how
    the computer should interpret what the human enters. An obvious way to do this
    would be to say to the computer, “Just let the users type in whatever they want
    until they hit the enter key, then treat the whole thing as a string.” The function
    that does this in Common Lisp is called `read-line`. However, it has none of the
    sophistication of the `read`, `print`, and `princ` functions, since it knows about
    nothing beyond characters and strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new knowledge, we can finally go full circle and create a proper
    function for greeting someone, without ugly quotes or other oddities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This version of the `say-hello` function is similar to our first version. However,
    when the computer asks users for their name ![](httpatomoreillycomsourcenostarchimages783564.png),
    it now does so without printing quotes around the text string. The same holds
    true to when we print the greeting ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png).
    Also, users can now enter in *any* name (including a name with spaces and quotes),
    since the `read-line` command ![](httpatomoreillycomsourcenostarchimages783562.png)
    captures and returns all the text entered until the enter key is pressed, without
    any fuss.
  prefs: []
  type: TYPE_NORMAL
- en: The Symmetry Between Code and Data in Lisp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen that Lisp has very elegant and symmetrical facilities for translating
    raw string data from the outside world and converting it to and from Lisp syntax
    expressions. But Lisp has an even deeper symmetry. It can treat program code and
    data interchangeably. A programming language that uses the same data structures
    to store data and program code is called *homoiconic*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You saw an example of homoiconicity in [Chapter 3](ch03.html "Chapter 3. Exploring
    the Syntax of Lisp Code"), when we discussed code mode and data mode. In that
    example, we used the quote to change between the two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter, we took this concept one step further by using a quasiquote
    when defining the `describe-path` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the quoting and quasiquoting facilities in Lisp are somewhat limited in
    their abilities. What if we generate a piece of Lisp code from scratch somehow
    and wish to execute it as if it were a piece of code? For example, let’s store
    a raw chunk of code inside a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'How could we execute the code that’s in the `*foo*` variable? We need an even
    more powerful command to make this possible. This is the `eval` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Because the `eval` command is so powerful and yet so simple, it is extremely
    enticing to beginning Lispers. You want to write a program with self-modifying
    code? Then `eval` will be your best friend. In fact, this is probably the main
    reason why the artificial intelligence (AI) freaks back in the day loved Lisp
    so much. Go ahead and try writing some programs that use the `eval` command. You’ll
    find that it’s a lot of fun.
  prefs: []
  type: TYPE_NORMAL
- en: However, an experienced Lisper will only rarely use `eval`. Until you have a
    few thousand lines of Lisp code under your belt, you really won’t know when it
    is appropriate to use this extremely powerful command. Often, a beginning Lisper
    will use the `eval` command instead of defining a Lisp macro. We will discuss
    macros in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros").
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that the symmetry of data and code in Lisp pretty much makes
    Lisp the poster child of homoiconicity. Quoting, quasiquoting, the `eval` command,
    and macros allow you to take advantage of this property in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inexperienced use of `eval` can pose a security risk. See [The Dangers of read
    and eval](ch06s05.html "The Dangers of read and eval") in [The Dangers of read
    and eval](ch06s05.html "The Dangers of read and eval") for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Custom Interface to Our Game Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve been using the Lisp REPL to enter our game commands. It’s amazing
    how well this works for prototyping our game. But now that you’ve gained an understanding
    of the basic Common Lisp input and output commands, we can begin to put in place
    our own custom text game interface, which will be better suited for interacting
    with the player.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Custom REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating your own REPL in Lisp is almost laughably easy. Here’s a simple custom
    REPL for our game, which lets us call the `look` command in exactly the same way
    as the standard REPL did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop me if this explanation of `game-repl` is confusing: First it `read`s a
    command, then `eval`s it, and finally `print`s it. The only command you haven’t
    seen before is `loop` (covered in detail in [Chapter 10](ch11.html "Chapter 10. Looping
    with the loop Command")), which as you might expect, simply loops forever. (In
    CLISP, you’ll need to hit ctrl-C and type `:a` to get out of the infinite loop.)
    As you can see, it’s easy to build your own REPL by simply calling `read`, `eval`,
    `print`, and `loop`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779964.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, to customize the behavior of our REPL, we’ll want to call our own
    versions of these functions. Also, we’ll want a way to exit from our game in a
    more graceful manner. So, let’s redefine `game-repl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we first capture the command the player types using a local
    variable, `cmd` ![](httpatomoreillycomsourcenostarchimages783564.png). This way,
    we can intercept any attempt to call `quit` and use it to exit our `game-repl`.
    In other words, we want to continue running our REPL unless the user typed `quit`
    ![](httpatomoreillycomsourcenostarchimages783562.png). Otherwise, the function
    `eval`s and `print`s ![](httpatomoreillycomsourcenostarchimages783560.png), but
    using our custom versions of these functions, which we’ll write shortly. Finally,
    the `game-repl` function calls itself recursively ![](httpatomoreillycomsourcenostarchimages783554.png),
    causing it to loop back, as long as we had not decided to quit earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Custom read Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of our `game-read` function is to fix the two annoyances that make
    the standard Lisp `read` function wrong for playing our game:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard Lisp `read` forces us to put parentheses around our commands. As
    any old-school text adventure player knows, we should be able to just type `look`
    without any parentheses. To accomplish this, we can just call `read-line` and
    stick in our own parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `read`, we must put a quote in front of any function commands. We should
    be able to type `walk east` without a quote in front of `east`. To do this, we’ll
    stick a quote in front of the parameters after the fact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780882.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s a definition of `game-read` that does both of these things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `read-from-string` command ![](httpatomoreillycomsourcenostarchimages783564.png)
    works just like the `read` command, but lets us read a syntax expression (or any
    other basic Lisp datatype) from a string instead of directly from the console.
  prefs: []
  type: TYPE_NORMAL
- en: The string we use for this is a tweaked version of a string we get from `read-line`
    ![](httpatomoreillycomsourcenostarchimages783562.png). We tweak it by adding quotes
    around it using the `concatenate` command, which can be used for concatenating
    strings together, as well as some parentheses. The result is that the `cmd` variable
    will be set to the player’s requested command and converted into a Lisp syntax
    expression. For example, if the player types in `walk east`, the `cmd` variable
    will be set to the expression `(walk east)`, which is a list containing two symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a local function called `quote-it` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which we can use to quote any arguments the player has in a command. How exactly
    does it manage to quote a parameter? Well, it turns out that the single quote
    is just shorthand for a Lisp command called `quote`. This means that `'foo` and
    `(quote foo)` are the same. We can quote a raw parameter by simply putting the
    parameter in a list with the `quote` command in front.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that local functions can be defined with `labels` or `flet`. Since
    we are not using any recursion in the `quote-it` function ![](httpatomoreillycomsourcenostarchimages783560.png),
    we can use the simpler `flet` command. The final line in the `game-read` function
    applies `quote-it` to every argument in the player’s command. It does this by
    mapping `quote-it` across the `cdr` of the `cmd` variable ![](httpatomoreillycomsourcenostarchimages783554.png)
    (and then attaching the first word in the command back on front with `car`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `game-read` function is able to add parentheses and quotes—just
    what our game needs!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our custom reader has some limitations that a sufficiently boneheaded game player
    could conceivably bring to the surface. The player could enter a weird string
    like `"(look"`, with mismatched parentheses, and it would cause a Lisp exception
    in the `game-read` command. There’s nothing wrong with this, per se, since the
    standard `read` command will also act strangely when given garbled input. (In
    this case, it will let you enter another line of input in the hopes that you will
    eventually supply it with the missing parenthesis.) However, our `game-repl` doesn’t
    handle this situation properly, causing the actual `game-repl` to crash. This
    would be as if you were playing Zork and typed in a command so vile that it took
    down the Zork game itself. This rare situation could be addressed by having additional
    exception handling, as discussed in [Chapter 13](ch14.html "Chapter 13. Let's
    Create a Web Server!").
  prefs: []
  type: TYPE_NORMAL
- en: Writing a game-eval Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve created a nigh-perfect Lisp reader, let’s think about how we
    could improve the `eval` command. The main problem with using `eval` in a game
    is it allows you to call any Lisp command, even if that command has nothing to
    do with playing the game. To help protect our program from hackers, we’ll create
    a `game-eval` function that allows only certain commands to be called, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `game-eval` function checks if the first word in the entered command is
    in the list of allowed commands, using the `member` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    If it is, we then use the standard `eval` to execute the player’s command ![](httpatomoreillycomsourcenostarchimages783562.png).
    By checking that the command called by the player is in the official list, we
    protect ourselves against any attempts to call malicious commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780092.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `game-eval` function does not offer 100 percent protection against hacking.
    See [The Dangers of read and eval](ch06s05.html "The Dangers of read and eval")
    in [The Dangers of read and eval](ch06s05.html "The Dangers of read and eval")
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a game-print Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final missing piece in our `game-repl` system is the `game-print` function.
    Of all the limitations in the Lisp REPL version of our game, one was the most
    obvious: All the text descriptions printed in the game were in uppercase.'
  prefs: []
  type: TYPE_NORMAL
- en: Last I checked, throughout the current millennium, computers have been able
    to display both uppercase *and* lowercase characters. By writing our own `game-print`
    function, we can solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we step through the `game-print` function’s code, let’s look at an example
    of its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `game-print` function converts our symbol-based writing
    into properly capitalized text. By having this function available, we can store
    the text in our game engine in the most comfortable format possible: lists of
    symbols. This format makes it easier to manipulate the text. Then, at the point
    of presentation, we can decorate these symbol lists with presentation details.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in this example, the decorations are very simple. All we do is adjust
    the case. But you can already see some small benefits of separating the presentation
    details from the data model. For instance, suppose we changed the `describe-path`
    function to write sentences like “Left of here lies a door.” No further changes
    would be needed; the program would automatically know to capitalize the *Left*
    at the beginning of the sentence.
  prefs: []
  type: TYPE_NORMAL
- en: However, the real benefits come into play when you want to use more sophisticated
    methods of presentation, such as generating HTML code. You might want to incorporate
    custom semantics for your text game to enhance the appearance of the text, such
    as changing colors, fonts, and so on. For instance, you could allow your game
    descriptions to contain phrases such as “You are being attacked by a (red evil
    demon).” Then you could just catch the keyword `red` in the `game-print` function
    to write the enclosed text in red. We will be creating an HTML presentation system
    similar to this in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages").
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783352.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we’re ready to look at the `game-print` function’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `game-print` function and its helper function are a bit more complicated
    than the other functions we’ve looked at so far. The first important part of the
    code that is executed is in `game-print`, where it converts the symbol list (containing
    the text whose layout we want to fix) into a string with `prin1-to-string` ![](httpatomoreillycomsourcenostarchimages783566.png),
    one of Lisp’s many `print` variants. The `to-string` part means this function
    doesn’t dump the result to the screen, but just returns it as a string. The `1`
    means it will stay on a single line. The standard `print` command precedes its
    output with a newline character and also follows it with a space. The functions
    `prin1` and `prin1-to-string` variants don’t add these extra characters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `game-print` converts the string to a list of characters with the `coerce`
    function ![](httpatomoreillycomsourcenostarchimages783556.png). By coercing our
    string into a list, we can reduce the bigger goal of the function into a list-processing
    problem. This is smack-dab in the Lisp comfort zone. In this case, we’re creating
    a list of the characters making up the text we want to fix.
  prefs: []
  type: TYPE_NORMAL
- en: We can now send the data to the list-eater function `tweak-text` ![](httpatomoreillycomsourcenostarchimages783556.png).
    Notice that some of the arguments used in the code of the `game-print` function
    are printed on their own line for clarity. You can easily see which arguments
    are meant for which commands by looking at the indentation. For instance, the
    `t` and `nil` arguments ![](httpatomoreillycomsourcenostarchimages783498.png)
    belong to `tweak-text`.
  prefs: []
  type: TYPE_NORMAL
- en: The `tweak-text` function looks at each character in the list and modifies it
    as needed. At the top of this function, we define two local variables, `item`
    and `rest`, which we get by chewing off an item from the front of the sentence
    we’re tweaking ![](httpatomoreillycomsourcenostarchimages783564.png). Then, the
    `tweak-text` function uses a `cond` to check the character at the top of the list
    for different conditions ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: The first condition it checks for is whether the character is a space character
    ![](httpatomoreillycomsourcenostarchimages783562.png). If so, it just leaves the
    space unchanged and processes the next character in the list. If the character
    is a period, question mark, or exclamation point ![](httpatomoreillycomsourcenostarchimages783560.png),
    we turn on the `cap` parameter for the rest of the string (by using the value
    `t` as an argument in the recursive call) to indicate that the next symbol is
    at the beginning of a sentence and needs a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also track whether we’ve encountered a quotation mark ![](httpatomoreillycomsourcenostarchimages783554.png).
    We do this because, infrequently, a symbol list is not adequate for encoding English
    text. Examples include having a comma (commas are not allowed in standard Common
    Lisp symbols) or product names with nonstandard capitalization. In these cases,
    we can just fall back on using text strings. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Our sample game doesn’t actually need the fallback facility. Nonetheless, this
    feature allows the `game-print` function to handle many basic exceptional text
    situations that you may encounter if you try to expand the game on your own. We
    tell the function to treat the capitalization as shown literally by turning on
    the `lit` variable in the recursive call. As long as this value is set, the `tweak-text`
    function prevents the capitalization rules (which start at ![](httpatomoreillycomsourcenostarchimages783510.png))
    from being reached.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing the `tweak-text` function checks is whether the next character
    is supposed to be capitalized. If it is, we use the `char-upcase` function to
    change the current character to uppercase (if it isn’t already) before processing
    the next item in the list ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: If none of the other conditions were met, we know that the current character
    should be lowercase ![](httpatomoreillycomsourcenostarchimages783544.png), and
    we can convert it using the `char-downcase` function.
  prefs: []
  type: TYPE_NORMAL
- en: After `tweak-text` is finished correcting the text in the character list, the
    `game-print` function coerces it back into a proper string and `princ`s it ![](httpatomoreillycomsourcenostarchimages783556.png).
    The `fresh-line` function at the end of `game-print` makes sure that the next
    item appearing on the screen will start on a fresh line.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed the task of printing the original list of symbols to the
    screen, using a set of decorations appropriate for the needs of an adventure game
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Trying Out Our Fancy New Game Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now completed all the pieces needed for a custom REPL for our game engine.
    Simply call the `game-repl` function and explore our new game world. Remember
    that we will be expanding this engine into a full game, with additional commands,
    in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Success! We now have an extremely flexible text game engine. It can be expanded
    and debugged within the Lisp REPL. It also has a fully customizable interface
    to offer the player a seamless text adventure experience. As we put it together,
    you saw some mind-bending Lisp techniques that let us construct this engine with
    a minimum of filler code or other overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779944.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Dangers of read and eval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve used both the `eval` and the `read` commands in creating a custom Lisp
    REPL. These commands are very powerful, but also very dangerous. Using them without
    taking the proper precautions might allow a hacker to attack your software by
    running malicious commands.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose our program needed a function called `format-harddrive`.
    This is *not* a function we would want just any person to have access to, and
    it could be very dangerous if a hacker somehow tricked our game REPL into calling
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `game-eval` function we created earlier in this chapter has some crude
    safeguards to prevent a player from entering `format-harddrive` as a game command.
    Here’s what happens if we try to run this command in our new game REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Our `game-eval` function will run only commands that are in an approved list.
    This gives our game a sort of firewall, which lets us access the powers of Lisp
    to evaluate commands while still preventing the player from hacking the game.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are also more sophisticated exploits players could try. For instance,
    they could enter `walk (format-harddrive)`. Fortunately, our `game-read` function
    forces all function parameters into data mode by using `quote-it`. By using `quote-it`
    in `game-read`, the actual code that is executed is `(walk '(format-`harddrive)).
    The quote in front of (`format-hardrive`) puts the malicious command into data
    mode, so nothing bad can happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'One attack method that *will* break our program is to use *reader macros*.
    These are an advanced set of features, built into the Common Lisp `read` command,
    that open another avenue for executing malicious computer code. (Remember that
    before we use `eval` on game commands, they first pass through `read`.) An example
    of a game command that will successfully execute evil code is `walk #.{format-harddrive}`.'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that you can never be sure that a Lisp program using `eval`
    or `read` is completely safe from a hacker. When writing production Lisp code,
    you should try to avoid these two commands when possible.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we created a custom REPL to supercharge our text adventure
    game. Along the way, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `print` and `read` functions let you directly communicate with the user
    through the console. These two functions work in a computer-friendly way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other input/output functions are not as elegant as `read` and `print`, but are
    friendlier for interacting with humans. Examples include `princ` and `read-line`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *homoiconic* programming language stores its program code and program data
    in a similar format. Lisp’s quoting, quasiquoting, `eval`, and macro features
    make it extremely homoiconic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easy to write your own custom REPL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s simple to transform your internal Lisp data into the format most suitable
    for your program’s interface. This makes it easy to separate presentation details
    from your program’s internal data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 6.5. lambda: A Function So Important It Deserves Its Own Chapter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s impossible to overstate the importance of the `lambda` command in Lisp.
    In fact, this command is pretty much the entire reason that Lisp exists in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: What lambda Does
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In short, `lambda` lets you create a function without giving it a name. For
    example, let’s say we create a `half` function that takes a number and divides
    it in half. Until now, we’ve written such a function this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781778.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It turns out that, in Lisp, functions are actually values that we can view
    and pass around just as if they were numbers or lists. An experienced Lisp programmer
    would say that functions are *first-class values* in Lisp. As you saw in [Chapter 5](ch05.html
    "Chapter 5. Building a Text Game Engine"), you can actually get at the function
    represented by the word `half` by using the function operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lambda` command just lets you do these same two things in a single step.
    You can define a function and then get it, without giving your function a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter to the `lambda` command is a parameter list, no different
    from the parameter list used in `defun`. The rest of the parameters are just the
    commands for the body of the unnamed function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a value representing your unnamed halving function, you can pass
    it directly to other Common Lisp commands, such as the `mapcar` or `apply` commands.
    For instance, we could do the following to elegantly halve all the values in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Because not all parameters of the `lambda` command are evaluated, `lambda` itself
    is not actually a true function. It is something called a *macro*. Remember from
    [Chapter 2](ch02.html "Chapter 2. Creating Your First Lisp Program") that all
    parameters to a Lisp function are evaluated before the function itself is evaluated.
    Macros, on the other hand, have special powers and are allowed to break those
    rules. You’ll learn more about macros in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").
  prefs: []
  type: TYPE_NORMAL
- en: Also, to confuse matters a bit, the actual value that `lambda` returns is a
    regular Lisp function—in this case, a function that cuts a number in half. When
    Lispers talk about lambda functions—which they pretty much do for breakfast, lunch,
    and dinner—they’re talking about functions created using `lambda`. They’re not
    talking about the `lambda` macro itself, which is not a function. Got that?
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda` lets your programs do very complicated things.'
  prefs: []
  type: TYPE_NORMAL
- en: The `lambda` form allows your programming code to take a conceptual leap.
  prefs: []
  type: TYPE_NORMAL
- en: While most programming languages try to keep the worlds of functions and values
    separate, Lisp lets you bridge these worlds as desired. For instance, if you want
    to package up a little ad hoc function and pass it off to another part of your
    program, `lambda` does exactly what you need.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that most Lisp programs use this command very heavily. The same
    holds true for the remaining examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Why lambda Is So Important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to pass around functions as if they were just plain old pieces of
    data is incredibly valuable. Once you get used to doing this, you open up all
    kinds of conceptual possibilities in the design of your programs. Eventually,
    your programs will start looking very different from programs in more (dare I
    say) pedestrian languages, such as Java or C. The name for the style of programming
    that relies heavily on passing functions as values is called higher-order *functional
    programming*. We will look at this style in more detail in [Chapter 14](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming").
  prefs: []
  type: TYPE_NORMAL
- en: An even more important reason why Lispers go gaga over `lambda` is that, as
    it turns out, in a purely mathematical sense, `lambda` is actually the only Lisp
    command there is!
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that Lisp is unusual among programming languages in that it was derived
    directly from a mathematical concept called the *lambda calculus*. In short, the
    lambda calculus is a theoretical programming language that contains only one command:
    the `lambda` command. By having only this single command and using special code
    transformations, it’s possible to create a fully functioning (though perhaps not
    practical) programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: The take-home point is that the `lambda` special form is the most fundamental
    command in a Lisp system, and the central concept from which other functions in
    Lisp derive. In fact, it is the central concept from which the very idea of Lisp
    itself originated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of `lambda`, you’re ready to tackle
    some more complicated programming examples that would be hard to write without
    the anonymous functions this command permits.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This short chapter discussed how to create anonymous functions. Here are the
    main points:'
  prefs: []
  type: TYPE_NORMAL
- en: By using `lambda`, you can create a function without needing to give it a name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many functions in Lisp accept functions as parameters. If you use these functions,
    you are using a technique called *higher-order functional programming*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 7. Going Beyond Basic Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll go beyond basic list concepts. We’ll talk about special
    kinds of lists, and we’ll write a game that will take list manipulation to a new
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Exotic Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of
    Lisp Code"), lists in Lisp are built out of cons cells—small data structures that
    allow you to link together two pieces of data. The right slot in the last cons
    cell in a list should contain a `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By stringing together several cons cells, you can create a list of any length.
    For instance, this is how we would use cons cells to create a list of the numbers
    1, 2, and 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782574.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since it’s so cumbersome for humans to think of a chain of cons cells as a
    list, Lisp has a special, simplified syntax for printing out such lists. You can
    see this for yourself by evaluating a chain of cons cells in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Lisp uses the simpler list syntax when it parrots our chain back to us in the
    REPL. It shows our string of cons cells as a list of three items. The important
    point to remember is that *this difference in appearance is entirely superficial*.
    No matter how a Lisp list is displayed, fundamentally, it always remains a chain
    of cons cells.
  prefs: []
  type: TYPE_NORMAL
- en: Dotted Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what happens if we deviate from the classic “string of conses” formula?
    How will a Lisp environment deal with this when printing lists?
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we try to create a list of the numbers 1, 2, and 3, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, instead of creating a third cons cell for the third number of our list,
    we stuff it into the right slot of the previous cell. What would the printed response
    look like if we were to enter this structure into a Lisp REPL? Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: To indicate that the final item in the list wasn’t found in the proper location
    for a `nil`-terminated list, Lisp places a dot in front of this final item. This
    dot is basically Lisp’s way of saying, “I tried to print this structure you entered
    using list notation, but the last item in the list didn’t contain the usual `nil`
    I expected; instead, it contained `3`.”
  prefs: []
  type: TYPE_NORMAL
- en: A list in Lisp that ends in something other than a `nil` is referred to as a
    *dotted list*. Dotted lists are kind of an oddity in the Land of Lisp. In and
    of themselves, they are not that useful a tool for Lisp programming. It would
    be quite unusual for a Lisp programmer to store data in dotted lists as a regular
    practice. However, given the pervasiveness of cons cells in Lisp, you will frequently
    encounter a non-`nil` value at the end of a chain of cons cells. That’s why you
    should become familiar with dotted lists, even if you may never use them directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of thinking about this dot notation is to consider it as simply
    an alternate syntax for the `cons` command, used in data mode. In fact, if we
    wanted to make life hard for ourselves, we could even create regular, proper lists
    using the dot notation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Using this line of thinking, the dot appears in a dotted list simply because
    Lisp is forced to show the final cons cell in order to maintain the consistency
    of its list-printing mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common and practical use for dotted lists in Lisp programs is to elegantly
    represent pairs. For instance, suppose we wanted to represent a pair of the numbers
    2 and 3\. One way to do this would be to cons together these two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, all we’re doing here is creating a dotted list of length two. As
    expected, Lisp uses dot notation to display this pair.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pairs in this manner in Lisp is very convenient and efficient. It’s
    convenient because we can extract members from the pair using the standard `car`
    and `cdr` commands. It’s relatively efficient because the Lisp environment needs
    to allocate only a single cons cell to connect the two items.
  prefs: []
  type: TYPE_NORMAL
- en: These types of pairs are commonly used in Lisp programs. For instance, you could
    use them to store the x- and y-coordinates of a point or a key/value pair in a
    complex data structure. You will see this latter use for pairs when we discuss
    association lists.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the picture we used in [Chapter 3](ch03.html "Chapter 3. Exploring
    the Syntax of Lisp Code") to illustrate the cons cells that make up the list `''(1
    2 3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782916.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now suppose that we created a weird mutant of this list. Let’s have the `cdr`
    of the third cons cell point back to the first cons cell, rather than to `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781690.png)'
  prefs: []
  type: TYPE_IMG
- en: Every cons cell in a list theoretically exists as a separate object in memory.
    Since the `car` and `cdr` slots in a cell can point to any other object in memory,
    a cons cell can point to an upstream cons cell of a list. We call this a *circular
    list*.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before you experiment with circular lists in any Common Lisp environment,
    you should run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Setting `*print-circle*` to true warns Lisp that you plan on playing shenanigans
    with self-referential data structures, and that it needs to be extra careful when
    printing on the screen any of the monstrosities you may create. If you were to
    print a circular list without this variable set, there’s no telling what would
    happen, but whatever the outcome, it wouldn’t be pretty (unless you find some
    beauty in stack overflows and infinite loop printing).
  prefs: []
  type: TYPE_NORMAL
- en: When you have `*print-circle*` set to true, Common Lisp will use more complex
    printing routines for printing data structures. These routines (which are disabled
    by default to improve performance) will check to see if you’ve run into a previously
    seen cons cell, so that printing doesn’t end up putting you into an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how would you go about creating a circular list? The most straightforward
    way is to use the `setf` command to put extra stuff in the first parameter, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve created an infinite list of `'(1 2 3 1 2 3 1 2 3 ...)`
    by replacing the `nil` at the end of a simple list with a reference to the list
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to place complex expressions in the first parameter of a `setf`
    command, as in this example, is very cool, and we’ll explore it in greater detail
    in [Chapter 9](ch10.html "Chapter 9. Advanced Datatypes and Generic Programming").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CLISP (and other Common Lisps) can deal with the printing of circular lists
    very sensibly. Somehow, it must address the fact that one part of the list refers
    to another part. As you can see, it uses an esoteric, but quite clever, notation
    to link the self-referential parts of the expression. However, I’m sure you can
    also appreciate that, as the complexity of any self-referential data increases,
    the printed results offered by a Lisp printer for this type of data can become
    hard for a programmer to grok.
  prefs: []
  type: TYPE_NORMAL
- en: Association Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One particularly useful data structure that can be created out of cons cells
    is an *association list*, or *alist* for short. An alist consists of key/value
    pairs stored in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, if a key appears multiple times in the list, it is assumed that
    the first appearance of the key contains the desired value. For instance, here
    is an alist representing an order for coffee drinks placed by Bill, Lisa, and
    John:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To look up the order for a given person, use the function `assoc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This function searches the list from the beginning for the desired key, and
    then returns the key/value pair. Now suppose that, before picking up the drink
    order, Lisa flags you down and opts to change her order to something slightly
    more decadent. You can change her order using the `push` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This function simply adds a new item to the front of an existing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because, by default, the first reference to a key in an association list takes
    precedence over later references to the same key, the order Lisa placed for a
    small drip coffee is superseded by her more recent order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, alists are a great way to keep track of any changeable collection
    of key/value pairs. Alists are easy to understand, to manipulate with Lisp functions,
    and to comprehend when printed out (they’re just lists of pairs, after all).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, once a value is stored in an alist, it remains there forever, making
    it easy to audit the history of any data. For instance, in our coffee example,
    the order Lisa placed for her drip coffee is still available even after it has
    been replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, alists do have one serious limitation: They are not a very efficient
    way to store and retrieve data, unless you’re dealing with very short lists (under
    a dozen items). Because of this inefficiency, although alists are often one of
    the first tools in the Lisp programmer’s toolbox, they may be replaced by other
    types of data structures as a program matures. (In [Chapter 9](ch10.html "Chapter 9. Advanced
    Datatypes and Generic Programming"), we’ll discuss the performance limitations
    of list-based data structures, such as alists, in greater detail.)'
  prefs: []
  type: TYPE_NORMAL
- en: Coping with Complicated Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cons cells are a great tool for representing a wide variety of list-like structures.
    In fact, most Lisp programmers, when faced with a programming task that is not
    bound by performance constraints, will rely on them almost exclusively. Because
    the manipulation and visualization of structures made of cons cells are central
    to the design of Lisp, these structures are extremely convenient to use and debug.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, even if you do have performance constraints, structures made of cons
    cells can often be a great choice. A Lisp compiler can often reduce a change to
    a cons cell down to a single assembly instruction!
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Tree-like Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of Lisp
    Code"), the data (and code) in a Lisp program is represented with syntax expressions.
    In this format, data is represented using nested lists, often with Lisp symbols
    at the front of each list explaining the structure of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we wanted to represent the component parts of a house
    in Lisp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This data structure very elegantly captures the hierarchical nature of the parts
    that make up a house. Since it is structured as a Lisp syntax expression, we can
    see the lists that make up the levels of the hierarchy. Also, it follows the convention
    of a syntax expression by putting a symbol at the front of each list. For instance,
    we can see how the list describing the windows first contains the Lisp symbol
    `windows` ![](httpatomoreillycomsourcenostarchimages783564.png), which is then
    followed by three items, representing the glass, frame, and finally the curtains
    ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, data that is hierarchical and tree-like in nature can be very
    naturally expressed in this way. In fact, many Lispers consider XML (a popular
    format for representing hierarchical data) somewhat of a reinvention of the syntax
    expression format that Lisp pioneered.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, we move beyond tree-like structures, data stored in a syntax expression
    can start becoming hard to visualize, even if it’s relatively easy to store the
    data in cons cells. For instance, suppose we have a mathematical graph stored
    in a syntax expression. These types of graphs, where any arbitrary node of the
    graph may be connected to another by an edge, are notoriously hard to visualize
    in a computer program. Even Lisp’s elegant system for representing cons cells
    can’t help much for such data. Next, we’ll look at our options for visualizing
    such graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematics, a *graph* consists of a bunch of nodes connected by edges. These
    nodes or edges might have additional data associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such graphs can be stored in cons cells, but they are difficult to visualize.
    We saw this in [Chapter 5](ch05.html "Chapter 5. Building a Text Game Engine"),
    when we stored the map of the wizard’s house (which consisted of a directed graph)
    in two alists: one containing the node information and one containing the edge
    information. I’ve renamed them `*wizard-nodes*` and `*wizard-edges*` for this
    chapter, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is hard to get a decent understanding of the structure of
    this game world from these raw data tables. Unfortunately, data that has the shape
    of a graph or contains other properties that go beyond simple tree structures
    are very common. Wouldn’t it be great if we had a tool that could optimally arrange
    this data to create a pretty drawing of a graph? Luckily, there is a fantastic
    open source tool that performs exactly this task, which you’ll try out next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphviz generates graphs from your data. Indeed, you saw a simple Graphviz
    representation of the wizard’s house in [Chapter 5](ch05.html "Chapter 5. Building
    a Text Game Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781548.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Graphviz is open source and available from the Graphviz website ([http://www.graphviz.org/](http://www.graphviz.org/)).
    After you’ve downloaded and installed it, creating a graph is easy. First, you’ll
    create a DOT file that describes the shape of your graph. For example, in Graphviz,
    create a file named *test.dot* on your computer and enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This defines a directed graph with nodes A and B connected by an arrow. (There
    are numerous syntax options available in the DOT file format, as documented at
    the Graphviz website.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to generate a graphical bitmap from the DOT file, run `neato` (one of
    the Graphviz utilities) from the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a picture in the file *test.dot.png* that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782744.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, Graphviz is simple to use. It can even generate large, complicated
    graphs quickly, with only minor graphical glitches. (Since perfect graph layouts
    are still an unsolved problem in computer science, Graphviz layouts aren’t perfect.
    They are, however, closer to perfect than you might expect.)
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have Graphviz up and running, let’s create a library of commands
    that will let us conveniently draw graphs with Lisp. We can use this to draw some
    graphs of our adventure game world.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The graph utilities used in the examples in this chapter perform certain system
    calls in a way that is not part of the Common Lisp standard. They are available
    only in the CLISP environment. The code would require some modifications to run
    within other Lisp systems.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the DOT Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a graph drawing library, we want to generate a Graphviz DOT
    file that captures all the details of a graph. To do this, we will need to convert
    the identifiers of the nodes the player can visit, convert the edges connecting
    these nodes, and generate labels for every node and edge. We will test our library
    using the nodes representing the map of the wizard’s world.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Node Identifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When converting nodes into DOT format, the first thing we need to do is to
    convert the node identifiers into valid DOT identifiers. We do this by writing
    a `dot-name` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'A node in DOT format can contain only letters, digits, and the underscore character.
    To make sure the node identifier we’re using is legal, we’ll change any forbidden
    characters to underscores. Here are examples of the `dot-name` function in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This function accepts any basic Lisp type, which we can then convert to a string
    using the `prin1-to-string` function. We can process the resulting string and
    substitute underscores as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the sake of simplicity, our `dot-name` function assumes that no node identifiers
    differ only in their nonalphanumeric components. For instance, if we had one node
    called `foo?` and another node called `foo*`, the `dot-name` function would convert
    them both to `foo`, causing the names to clash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `substitute-if` function substitutes values based on the result of a test
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The test function in this example, `digit-char-p`, tells us if a character in
    a string is a numerical digit. Test functions like this, which accept a value
    and determine truth based on that value, are often referred to as *predicates*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting property of the `substitute-if` function is that we can
    use it on lists as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Here, all odd numbers in a list have been replaced by the number 0\. The `substitute-if`
    function is one example of a *generic function*—a function that can accept multiple
    datatypes as parameters and handle them appropriately. (Generic programming is
    discussed in [Chapter 9](ch10.html "Chapter 9. Advanced Datatypes and Generic
    Programming").)
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use `substitute-if` in our `dot-name` function, we substitute only
    those characters that aren’t alphanumeric. While no predicate that tests for exactly
    this is available for us in Common Lisp, it is easy to create this predicate on
    the fly. The following fragment in the `dot-name` function creates a predicate
    function for us with exactly the right behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Lisp already has a predicate function that tells us if a character is alphanumeric,
    called `alphanumericp`. However, we want to substitute only characters that are
    *not* alphanumeric. We can create this opposite (or *complement*) function to
    `alphanumericp` by passing it to a higher-order function named `complement`.
  prefs: []
  type: TYPE_NORMAL
- en: By passing this function into `substitute-if`, we get the behavior we want,
    without needing to use `defun` to pollute the top level with a new function just
    to feed to `substitute-if`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common Lisp has a function called `substitute-if-not` that could have been used
    in the `dot-name` function in lieu of `substitute-if` to allow us to leave the
    `not` out of the `lambda` function. However, Lisp functions that end in `not`
    are better avoided. They may be removed from future versions in the ANSI Common
    Lisp standard, which means they are considered deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Labels to Graph Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we can tweak our node identifiers to make them appropriate for DOT,
    let’s write another function that will generate the label that should appear in
    the node when it is drawn. The label will consist of the node name and the data
    linked to the node in the node alist. But we also need to make sure that we are
    not trying to put too much text in the label. Here is the code that generates
    the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '`*max-label-length*` ![](httpatomoreillycomsourcenostarchimages783564.png)
    is a global variable that determines the maximum number of characters for the
    label. If a node label is larger than the limit ![](httpatomoreillycomsourcenostarchimages783560.png),
    it gets cropped, and an ellipsis is added to indicate that fact ![](httpatomoreillycomsourcenostarchimages783554.png).
    The `write-to-string` function ![](httpatomoreillycomsourcenostarchimages783562.png)
    is similar to the `prin1-to-string` function we used earlier—it writes an expression
    to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: The `:pretty` parameter is an example of a *keyword parameter*, which is used
    by certain Lisp functions to let you choose which parameters you want to pass
    in. In the case of `write-to-string`, it tells Lisp not to alter the string to
    make it pretty. Without this, Lisp would place new lines or tabs into our converted
    string to make it look more pleasing to the eye. By setting the `:pretty` keyword
    parameter to `nil`, we are telling Lisp to output the expression without any decorations.
    (Having new lines in a label can confuse Graphviz, so we don’t want to give Lisp
    any ideas.)
  prefs: []
  type: TYPE_NORMAL
- en: Generating the DOT Information for the Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we can generate both a name and label for each node, we can write
    a function that takes an alist of nodes and generates the DOT information that
    encodes them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This function uses `mapc` to go through every node in the list of nodes ![](httpatomoreillycomsourcenostarchimages783564.png),
    and `princ` prints each node in the DOT format directly to the screen. `mapc`
    is a slightly more efficient variant of `mapcar;` the difference is that it does
    not return the transformed list. The `nodes->dot` function uses the `dot-name`
    ![](httpatomoreillycomsourcenostarchimages783562.png) and `dot-label` ![](httpatomoreillycomsourcenostarchimages783560.png)
    functions we created to convert the data.
  prefs: []
  type: TYPE_NORMAL
- en: Later, when we want to generate a file that contains this information, we’ll
    write a function that takes this data from the console.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem a bit odd to use the console as an intermediary for generating a
    file, instead of just writing directly into a file, but this is actually a common
    paradigm in Lisp. One immediate benefit of this approach is that we can easily
    debug the code in the REPL, where the printed lines are easy to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try using the `nodes->dot` function to generate the DOT information
    for the nodes in the wizard’s house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the nodes of the wizard’s house and an abbreviated version
    of the information attached to each node, shown in DOT format. Notice that we
    are not interested in the value returned from the `nodes->dot` function—only in
    the information it prints in the REPL. Lispers would say that we are only interested
    in the *side effects* of this function. Although `mapc` does not return the list,
    it still causes the code to iterate through the list and generate the same printed
    output that using `mapcar` would have, so it generates the same side effects as
    `mapcar`, a bit more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Edges into DOT Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to generate the DOT information for the edges that link our
    nodes. These will become the arrows in our visual graph. The function `edges->dot`
    generates the necessary data, again by printing it directly to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use this function to generate the DOT information for the edges of the
    wizard’s house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can clearly see the relationships between the nodes in the wizard’s
    house, in the DOT format. For instance, the first line ![](httpatomoreillycomsourcenostarchimages783564.png)
    indicates that the player can walk from the `LIVING_ROOM` node to the `GARDEN`
    node by using an edge labeled `(WEST DOOR)`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating All the DOT Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To complete our generation of the DOT data, we call both `nodes->dot` and `edges->dot`,
    and wrap it up with some extra decoration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This function ties everything together by defining our graph as a directional
    graph ![](httpatomoreillycomsourcenostarchimages783564.png), and then calling
    our `nodes->dot` ![](httpatomoreillycomsourcenostarchimages783562.png) and `edges->dot`
    ![](httpatomoreillycomsourcenostarchimages783560.png) functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the final DOT information for our wizard game looks like, as created
    by our new library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We can now generate a proper Graphviz DOT file that captures all the details
    of our wizard map that we need to generate a pretty picture. These include the
    nodes the player can visit, the edges connecting these nodes, and labels for every
    node and edge.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the DOT File into a Picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To turn the DOT file into an actual bitmap, we capture the DOT file data, put
    it into a file, and then execute the `dot` command directly from the system command
    line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: This function performs the most critical actions in our graph drawing library,
    using some advanced Lisp techniques.
  prefs: []
  type: TYPE_NORMAL
- en: First, to keep this `dot->png` function as reusable as possible, the `graph->dot`
    function isn’t called directly. Instead, we write `dot->png` to accept a thunk
    ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: Using Thunks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common in Lisp to create small functions that have zero arguments. These
    functions are officially called *nullary functions*. However, Lispers will often
    create such functions in order to describe a computation that they don’t want
    to run until later. In this scenario, a function without arguments is commonly
    called a *thunk* or a *suspension*. In this case, the thunk our `dot->png` function
    needs would be a function that, when called, prints a DOT file to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Why is a thunk useful in our `dot->png` function? Remember that the easiest
    way for us to write and debug `graph->dot` and other DOT file functions is to
    have them print their results directly to the console. When we call `graph->dot`,
    it doesn’t return its results as a value, but, instead, prints them at the console
    as a side effect. Therefore, we can’t just pass the value of `graph->dot` to `dot->png`.
    Instead, we pass in `graph->dot` as a thunk. Then `dot->png` is responsible for
    calling `graph->dot`, capturing the results, and sending them to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is so common to generate textual data with a computer program, this
    particular technique is used a lot in Lisp code: First, we print stuff right to
    the console; next, we wrap it in a thunk; finally, we redirect the results to
    some other location.'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch
    with Functional Programming"), Lispers who follow the functional programming style
    eschew this technique, because side effects are required when printing to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function `with-open-file` enables `dot->png` to write information to a
    file ![](httpatomoreillycomsourcenostarchimages783562.png). To give you a feel
    for how this function works, here’s an example that creates a new file named *testfile.txt*
    and writes the text “Hello File!” to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see that the first item ![](httpatomoreillycomsourcenostarchimages783564.png)
    passed into `with-open-file` becomes the name of a special Common Lisp datatype
    called a *stream*, which is created for us by `with-open-file`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Printing functions, such as `princ`, can accept a stream as an optional parameter.
    In this case, these printing functions won’t print anything to the console, but
    instead will print to the stream object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand that `with-open-file` creates a stream variable
    from a stream variable name, in the same way that `let` creates a variable from
    a variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: So if we pass the name `my-stream` in at the front of the first list to `with-open-file`
    ![](httpatomoreillycomsourcenostarchimages783564.png), this is analogous to defining
    `my-variable` at the start of a `let` ![](httpatomoreillycomsourcenostarchimages783560.png).
    A variable named `my-stream` will be available to us in the body of `with-open-file`
    ![](httpatomoreillycomsourcenostarchimages783562.png), in the same way that `my-variable`
    will be available to us in the body of the `let` ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry too much about exactly what a stream is just yet. We’ll be looking
    at them more closely in [Chapter 12](ch13.html "Chapter 12. Working with Streams").
    For now, you just need to know that a stream is an object that can be connected
    to a file, and we can pass it to functions (such as `princ`) to write stuff to
    the connected file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Keyword Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `with-open-file` command also makes heavy use of keyword parameters. Let’s
    look at our previous example of this command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'A keyword parameter has two parts: the name of the parameter and the value
    of the parameter. The name of the parameter is always a symbol beginning with
    a colon. This example has two keyword parameters: `:direction` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which is set to `:output` (we’re only writing to the file and not reading it),
    and `:if-exists` ![](httpatomoreillycomsourcenostarchimages783562.png), which
    is set to `:superseded` (if a file by that name already exists, just toss out
    the old version).'
  prefs: []
  type: TYPE_NORMAL
- en: '`with-open-file` has keyword parameters because opening a file is a complex
    operation, and many esoteric options are available. If `with-open-file` just gave
    you regular parameters to set all this, every call to `with-open-file` would be
    long and cumbersome due to all the parameters. Also, humans have a hard time looking
    at a long list of parameters and remembering which one does what.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve probably noticed, symbols in Common Lisp sometimes begin with a colon.
    This includes keyword parameters, which always start with a colon. This is because
    a regular symbol in Lisp can refer to something else. For instance, we could set
    a variable `cigar` equal to `5` and then return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'However, sometimes we don’t want a symbol to refer to something else. We want
    to use the symbol outright, and we want it to have its own meaning. A colon-prepended
    symbol in Common Lisp (not surprisingly, called a *keyword symbol*) always means
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the keyword symbol `:cigar` can be evaluated right at the REPL
    and already has a value ![](httpatomoreillycomsourcenostarchimages783564.png).
    Its value is, conveniently, `:cigar`. If we try to redefine `:cigar` to something
    else, Common Lisp won’t let us ![](httpatomoreillycomsourcenostarchimages783562.png).
    The fact that it is constant is useful, because a Lisp compiler can potentially
    optimize this simple type of symbol more than it can optimize other types. Also,
    we can reduce errors in our code by using keyword symbols in places where we know
    a symbol just has a meaning in its own right. Sometimes a cigar is just a cigar.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the Console Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `dot->png` sends our data to the file in a slightly different way than
    is shown in this example: by declaring the name of the stream to be `*standard-output*`
    (a special global variable in Common Lisp that controls the default location to
    which printing functions send their output). As a result, any printing done inside
    the thunk will be redirected to our DOT file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at our `dot->png` function again to see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: So how exactly does the `dot->png` function cause our DOT data to get saved
    to a file instead of just going to the console? To answer this, you’ll need to
    exercise your brain a bit. Also, you’ll need to recall our discussion of local
    and dynamic variables in [Chapter 2](ch02.html "Chapter 2. Creating Your First
    Lisp Program").
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the let command usually creates a *lexical*, or local, variable.
    As we’ve discussed, the stream variable created by `with-open-file` is analogous
    to using `let` to create a variable. Hence, it usually leads to the creation of
    a lexical stream variable for us.
  prefs: []
  type: TYPE_NORMAL
- en: However, if a dynamic variable already exists with the same name, `let` will
    instead, temporarily, override the value of the dynamic variable to the new value.
    `*standard-output*` is such a dynamic variable. This means that we can temporarily
    override the value of `*standard-output*` to a new value by passing it into our
    `with-open-file` command ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the `with-open-file`, where we call our thunk ![](httpatomoreillycomsourcenostarchimages783562.png),
    any values printed to the console will now be automagically routed to our file,
    instead. The surprising thing (enabled by the design of lexical and dynamic variables
    in Common Lisp) is that this is also true for the `princ` statements in our `graph->dot`
    function, even though they are called indirectly from `dot->png`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Picture of Our Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lastly, we need a function that ties together all the pieces to let us easily
    create a graph from some nodes and edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the name of a DOT file (as the variable `fname`), as well
    as the graph’s nodes and edges ![](httpatomoreillycomsourcenostarchimages783564.png),
    and uses them to generate the graph. To do this, it calls `dot->png` ![](httpatomoreillycomsourcenostarchimages783562.png)
    and creates the appropriate thunk—a `lambda` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    As is usual for a thunk, it takes no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The `graph->dot` function is called inside the thunk ![](httpatomoreillycomsourcenostarchimages783554.png)
    as a *delayed computation*. Specifically, if we had called `graph->dot` directly,
    its output would just show up in the console. However, when inside the thunk,
    it will be called at the leisure of the `dot->png` function, and the output will
    be used to generate the DOT file with the filename passed in as the first parameter
    to `graph->png`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try out our new function to draw a graph of the wizard’s house!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling this function, you should now see a file named *wizard.dot.png*,
    a picture of the map of the wizard’s house:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783218.png)'
  prefs: []
  type: TYPE_IMG
- en: This may not be the prettiest graph on the planet, but it’s packed with information
    and is very easy to understand. Also, the code is extremely flexible, and places
    few dependencies on our node and edge data.
  prefs: []
  type: TYPE_NORMAL
- en: With these utilities in our arsenal, we can now easily create graphs from any
    interconnected data in our Lisp programs. You’ll find this technique to be a valuable
    debugging tool when you need to deal with complicated data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Undirected Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A graph that has arrows on its edges is called a *directed graph*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781434.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But sometimes we have data that is undirected, allowing us to travel in both
    directions along an edge. Such a graph is less busy than a directed graph, and
    can be easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781500.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code expands our graph utilities with new functions that let
    us draw undirected graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: This code is very similar to the code for creating our directed graphs. Let’s
    look at some of the differences.
  prefs: []
  type: TYPE_NORMAL
- en: The `uedges->dot` function is very similar to the `edges->dot` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    However, the graph we’re drawing may have multiple directed edges between the
    same nodes that we want to replace with a single, undirected edge. For instance,
    on our wizard map, we can walk from the garden to the living room by going *east*
    through the door. Of course, we can also walk from the living room to the garden
    by going *west* through the exact same door. In our undirected graph, we’ll want
    to collapse this; in essence, we just want to say, “There’s a door between the
    garden and living room.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The `uedges->dot` function erases such duplicate edges by running through the
    list of edges using the `maplist` function. This is like the `mapcar` function,
    except that the function inside it receives the entire remainder of the list,
    not just the current item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The `maplist` function sends the `print` function everything in the list from
    the current item until the end. `uedges->dot` ![](httpatomoreillycomsourcenostarchimages783564.png)
    then uses the information about future nodes it gets from `maplist` to check whether
    the destination of the node appears later in the edge list. The actual checking
    is done with the `assoc` function, looking for the current edge in the list of
    remaining edges, calculated as `(cdr lst)` ![](httpatomoreillycomsourcenostarchimages783562.png).
    In this case, it skips the edge so that only one of any pair of edges will be
    printed.
  prefs: []
  type: TYPE_NORMAL
- en: The `ugraph->dot` ![](httpatomoreillycomsourcenostarchimages783560.png) function
    is similar to the `graph->dot` function, except that it describes the graph as
    just a graph ![](httpatomoreillycomsourcenostarchimages783554.png) when generating
    the DOT data, instead of a digraph. The `ugraph->png` function ![](httpatomoreillycomsourcenostarchimages783510.png)
    is essentially identical to the `graph->png` function, except that it calls `ugraph->dot`
    instead of `graph->dot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We designed the `dot->png` function to accept different thunks so it could
    work with different DOT data generators. Now we’ve used this flexibility to generate
    these functions that output pictures for undirected graphs. For example, let’s
    try generating an undirected graph for the wizard’s house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `"uwizard.dot"` is the name of the DOT file we want to create. The `*wizard-nodes*`
    and `*wizard-edges*` variables contain the data describing the nodes and edges
    of the map of the wizard’s world. This code generates the *uwizard.dot.png* file,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781832.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have a full suite of utilities for both directed and undirected
    graphs, write these functions to a file named *graph-util.lisp*, so you can access
    them from other programs.
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed exotic types of lists and created a drawing library
    for mathematical graphs. Along the way, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can create lists in Lisp that end in a value other than nil. Such lists
    are displayed with an extra dot before the last item and are called *dotted lists*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pairs* are what you get when you cons together two items that are not lists
    themselves. They can also be thought of as dotted lists that contain only two
    items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Circular lists* are lists where the last cons cell points to an earlier cons
    cell in the same list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Association lists (alists)* are lists of pairs. They can be used to store
    data that is in the form of keys associated with values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp syntax expressions are great for storing and visualizing list-like and
    hierarchical data. Extra tools may be helpful for visualizing more complex data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your data is in the form of a mathematical graph, it’s helpful to be able
    to generate pictures of your data using Graphviz.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common technique for generating textual data in a Lisp program is to write
    functions that print the text to the console for easy debugging and wrap these
    functions in thunks. Then you can send these thunks to other functions, which
    capture the console output and route the text to the appropriate destination,
    such as writing it to a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 8. This Ain't Your Daddy's Wumpus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we worked with mathematical graphs in a simple game.
    However, as an old-school geek, the first thing I think of when I see these graphs
    is the old game Hunt the Wumpus. When I was nine, I could think of nothing more
    fun than sitting in front of my TI-99/4A and playing this excellent game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the original title screen:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hunt the Wumpus, you are a hunter searching through a network of caves to
    find a mysterious monster—the fabled Wumpus. Along the way, you also deal with
    bats and tar pits. Ah, those were the days!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779776.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But, unfortunately, those days are long gone. We’re in a new millennium now,
    and no one would be impressed by these crude graphics anymore. And the story line,
    well, let’s just say it sounds a bit corny by modern standards. I think we can
    all agree that Hunt the Wumpus is in serious need of a makeover. That’s quite
    a challenge, but one I think we can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, I present to you . . .
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783024.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Grand Theft Wumpus Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this new version of Hunt the Wumpus, you are the Lisp alien. You and the
    Wumpus have just robbed a liquor store and made off with the loot. However, during
    the escape, the Wumpus decides to double-cross you and run off with the money
    and your car. But before he drives off, you manage to cap him a couple of times
    in the kidney.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781862.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you’re in a pretty tough situation. You don’t have a car or any money, and
    no way to track down your former partner in crime. But you also have no choice.
    You have your principles, so you’re going to *hunt the Wumpus*. You know he won’t
    be able to get very far with his injuries. He will most likely need to lie low
    for a few days to recover, which means he will still be somewhere in Congestion
    City. The problem is that the roads in this town are impossibly convoluted, and
    no one can find their way around, especially an out-of-towner like yourself. How
    are you ever going to find the Wumpus in this impossible maze?
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781264.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Luckily, being the Lisp alien, you always carry your trusty pocket computer.
    Using Lisp and your graph utilities, you’re fully equipped to analyze complicated
    data such as the Congestion City roadways and intersections. Surely, you have
    the tools to conquer this impenetrable road system.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780646.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Wumpus has been your partner in crime for a while now, so you know his
    MO quite well. He will always carefully scout out any new hiding place before
    he uses it. And since he is injured, any location one or two blocks away (that
    is, one or two graph edges away) from his hiding place should be marked with some
    telltale signs: his blood stains.'
  prefs: []
  type: TYPE_NORMAL
- en: A problem is that he still has his trusty AK-47, while you have only a handgun
    with a single bullet. If you’re going to take him out, you’ll need to be absolutely
    sure you’ve tracked him down. You’ll need to charge into his hideout and shoot
    him down immediately, and you’ll have only one chance to pull this off.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780468.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, you and the Wumpus aren’t the only criminals in this town. The
    most feared outlaw group in Congestion City is the Gruesome Glowworm Gang. These
    guys are a band of ruthless kidnappers. If you run into them, they will kidnap
    you, beat you up, rob you, blindfold you, and then kick you out of their car and
    leave you in some random part of town.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, they can be avoided if you know to keep an eye out for their glowing
    thoraxes (hence their name). If you see some blinking lights, you know that these
    guys are one street away from your current location. Also, you know the gang has
    exactly three separate teams that work the city from three separate locations.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779895.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, you still need to contend with the cops. You know they’ve probably
    set up some roadblocks in town to try to catch you and the Wumpus. You should
    still be able to visit any location in Congestion City, but you need to be careful
    which streets you travel. (In other words, the cops will catch you if you travel
    along the wrong edge.) Unfortunately, you don’t know how many of these roadblocks
    there may be.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, finding the Wumpus and getting back your money and car will
    be tough. If you think you’re Lisp alien enough to take on the Wumpus, then let’s
    write this game and hunt him down!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Edges of Congestion City
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The map of Congestion City will be an undirected graph with data associated
    with each node stored in the variable `*congestion-city-nodes*`. The possible
    data at each node will include the presence of the Wumpus, a Glowworm team, and
    various danger signs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of edges stored in `*congestion-city-edges*` will connect the nodes,
    and data linked to these edges will alert us to the presence of any police roadblocks.
    We declare these and other global variables at the top of our program using `defparameter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: We first load our graph utilities with the `load` command ![](httpatomoreillycomsourcenostarchimages783564.png),
    which evaluates all the code in *graph-util.lisp* (which we created in the previous
    chapter) so the graph utility functions will be available. Notice that Congestion
    City will have 30 locations ![](httpatomoreillycomsourcenostarchimages783562.png)
    (nodes, defined with `*node-num*`), 45 edges ![](httpatomoreillycomsourcenostarchimages783560.png)
    (roads, defined with `*edge-num*`), and 3 worm teams ![](httpatomoreillycomsourcenostarchimages783554.png)
    (defined with `*worm-num*`). Each street will have a 1-in-15 chance ![](httpatomoreillycomsourcenostarchimages783510.png)
    of containing a roadblock (defined with `*cop-odds*`).
  prefs: []
  type: TYPE_NORMAL
- en: Generating Random Edges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we create a random list of edges to connect all the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare the `random-node` function ![](httpatomoreillycomsourcenostarchimages783564.png),
    which returns a random node identifier. It uses the `random` function, which returns
    a random natural number less than the integer you pass to it. Since we’re going
    to be showing the node identifiers in our user interface, we use the `1+` function
    to number our nodes 1 through 30 (the upper limit because the `*node-num*` variable
    is set to `30`), instead of 0 through 29.
  prefs: []
  type: TYPE_NORMAL
- en: The `make-edge-list` function ![](httpatomoreillycomsourcenostarchimages783560.png)
    generates the actual list of random edges. It uses the `loop` command to loop
    `*edge-num*` times ![](httpatomoreillycomsourcenostarchimages783554.png), and
    then collects the requisite number of edges ![](httpatomoreillycomsourcenostarchimages783510.png).
    We’ll take a closer look at the `loop` command in the next section. The graph
    of the city is undirected, so this function uses a helper function, `edge-pair`
    ![](httpatomoreillycomsourcenostarchimages783562.png), to create *two* directed
    edges between the randomly selected nodes. This extra step makes sense once you
    remember that an undirected graph is the same as a directed graph, with two opposing
    directed edges mirroring each undirected edge. (When we build our edges into an
    alist later in this chapter, this step will ensure that the list is properly formed.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781068.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try the `make-edge-list` function in the CLISP REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: You see the pairs of node numbers that make up the edges. This list of edge
    pairs will form the skeleton of the Congestion City road system.
  prefs: []
  type: TYPE_NORMAL
- en: Looping with the loop Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `make-edge-list` function employs the powerful `loop` command, which can
    be used to loop over various types of data. We’ll be looking at `loop` in detail
    in [Chapter 10](ch11.html "Chapter 10. Looping with the loop Command"). However,
    our game uses `loop` a few times, so let’s consider some simple examples to clarify
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'One handy thing you can do with `loop` is create a list of numbers. For instance,
    the following command will create a list of 10 ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Within the `loop` command, we specify how many times to `repeat`, and then specify
    an object to `collect` with every loop (in this case, the number 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to keep a running count as we’re looping. We can do this
    with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are saying that `n` should loop from 1 to 10\. Then we `collect`
    each `n` and return it as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we can put any Lisp code in the `collect` part of the loop. In the
    following example, we add 100 as we do our collecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Preventing Islands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now can generate random edges. Of course, if we just connect random nodes
    with random edges, there’s no guarantee that all of Congestion City will be connected
    because of all that randomness. For example, some parts of the city might form
    an island, with no connections to the main road system.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782588.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To prevent this, we’ll take our list of edges, find unconnected nodes, and
    connect these islands to the rest of the city network using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare a utility function called `direct-edges` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which finds all the edges in an edge list that start from a given node. It does
    this by creating a new list with all edges removed (using `remove-if-not` ![](httpatomoreillycomsourcenostarchimages783562.png))
    that don’t have the current node in the `car` position.
  prefs: []
  type: TYPE_NORMAL
- en: To find islands, we write the `get-connected` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    This function takes an edge list and a source node and builds a list of all nodes
    connected to that node, even if it requires walking across multiple edges.
  prefs: []
  type: TYPE_NORMAL
- en: The usual way to find connected nodes is to start a `visited` list ![](httpatomoreillycomsourcenostarchimages783554.png),
    and then perform a search along connected nodes, starting with the source node.
    Newly found nodes are added to the visited list with the `push` command ![](httpatomoreillycomsourcenostarchimages783510.png).
    We also traverse all the children of this found node, using `mapc` ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, we encounter a node that has already been visited, we
    know we can ignore it. Once the search is complete, the `visited` list will consist
    of all connected nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a function for finding nodes that are connected, we can use
    it to create a function that will find all the islands in our graph. The `find-islands`
    function first defines a local function, called `find-island` ![](httpatomoreillycomsourcenostarchimages783556.png).
    This function checks which nodes are connected to the first node in our list of
    nodes using the `connected` function. It then subtracts these nodes from the full
    list of nodes using the `set-difference` function. (`set-difference` takes two
    lists, and returns all items that are in the first list but not the second.)
  prefs: []
  type: TYPE_NORMAL
- en: Any remaining nodes are deemed unconnected. If any unconnected node exists ![](httpatomoreillycomsourcenostarchimages783566.png),
    we call the `find-islands` function again recursively to find additional islands.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve found all the islands, we need a way of bridging them together. This
    is the job of the `connect-with-bridges` function. It returns a list of additional
    edges that join all the islands together. To do this, it takes the list of islands
    and checks if there is a `cdr` in this list ![](httpatomoreillycomsourcenostarchimages783498.png).
    If there is, it means there are at least two land masses, which can be connected
    with a bridge. It uses the `edge-pair` function to create this bridge, and then
    calls itself recursively on the tail of the island list, in case additional bridges
    are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tie all of our island prevention functions together using the function
    `connect-all-islands` ![](httpatomoreillycomsourcenostarchimages783062.png). It
    uses `find-islands` to find all the land masses, and then calls `connect-with-bridges`
    to build appropriate bridges. It then appends these bridges to the initial list
    of edges to produce a final, fully connected land mass.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Final Edges for Congestion City
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete our edges for Congestion City, we need to convert the edges from
    an edge list into an alist. We also will add the police roadblocks, which will
    appear randomly on some of the edges. For these tasks, we will create the `make-city-edges`,
    `edges-to-alist`, and `add-cops` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: These are the most cumbersome functions in Grand Theft Wumpus. Let’s take a
    closer look at them.
  prefs: []
  type: TYPE_NORMAL
- en: The make-city-edges Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, the `make-city-edges` function creates a list of nodes, using a `loop`
    ![](httpatomoreillycomsourcenostarchimages783564.png). (This is simply a list
    of numbers from 1 to `*node-num*`.) Next, it creates a random (but fully connected)
    edge list by calling the `make-edge-list` and `connect-edge-list` functions ![](httpatomoreillycomsourcenostarchimages783562.png).
    This result is stored in the `edge-list` variable. It then creates a random list
    of edges that contains `cops` ![](httpatomoreillycomsourcenostarchimages783560.png).
    We define these variables with the `let*` command, which allows us to reference
    previously defined variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the difference between defining variables with
    `let` and `let*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `let` won’t allow you to refer to other defined variables (the
    variable `b` can’t reference the value of `a`). When defining variables with `let*`,
    on the other hand, this kind of reference is allowed. For our purposes, using
    `let*` allows our definition of `cops` ![](httpatomoreillycomsourcenostarchimages783560.png)
    to contain a reference to `edge-list`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve created the edge list and determined where the cops are, we need
    to convert our edge list into an alist and add the cops to it ![](httpatomoreillycomsourcenostarchimages783554.png).
    The edges are converted to an alist with the `edges-to-alist` function, and the
    cops are added with the `add-cops` function.
  prefs: []
  type: TYPE_NORMAL
- en: The edges-to-alist Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `edges-to-alist` function converts a list of edges into an alist of edges.
    For example, assume we have the following city, with only three locations and
    two edges connecting those locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780974.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We would describe this using an edge list as `'((1 . 2) (2 . 1) (2 . 3) (3 .
    2))`. Remember that each of the edges is repeated, since the edges are undirected
    and can be used in both directions. If we described this same city as an alist,
    what would that look like?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that an alist is a list that lets us look up a key (in this example,
    one of the three nodes in our city) and find the information associated with that
    key (in this case, a list of the roads connected to it). For this small city,
    the alist would be `'((1 (2)) (2 (1) (3)) (3 (2)))`.
  prefs: []
  type: TYPE_NORMAL
- en: To build this alist, the `edges-to-list` function first `mapcar`s ![](httpatomoreillycomsourcenostarchimages783510.png)
    over the nodes found in the edge list. To build the list of nodes, we use the
    `remove-duplicates` function, which removes duplicate items from a list. By default,
    `remove-duplicates` uses the `eql` function to check for equality, though it also
    allows you to choose a different test function using the :test keyword parameter.
    Since we’re checking for equality of cons pairs in our `make-city-edges` function,
    we set `:test` to `#'equal` ![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: Within this outer `mapcar` ![](httpatomoreillycomsourcenostarchimages783510.png),
    we use another `mapcar` ![](httpatomoreillycomsourcenostarchimages783544.png)
    to map across all the `direct-edges` to this node. Together, these nested `mapcar`
    functions allow `edges-to-alist` to convert the edges of a city into an alist.
  prefs: []
  type: TYPE_NORMAL
- en: The add-cops Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we wrote the `make-city-edges` function, we randomly marked some of the
    edges to show that they have cops on them ![](httpatomoreillycomsourcenostarchimages783554.png).
    We are now going to use this list of cop edges to mark the edges in our alist
    that contain cops. This is the job of the `add-cops` function.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we use nested `mapcar` commands to map across the edges within each
    node ![](httpatomoreillycomsourcenostarchimages783566.png)![](httpatomoreillycomsourcenostarchimages783498.png).
    We then check whether there are any cops on a given edge, using the `intersection`
    function ![](httpatomoreillycomsourcenostarchimages783062.png). (The `intersection`
    function tells us which items are shared between two lists.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand exactly what the `add-cops` function is doing, it will help to
    once again imagine our city with only three locations and two streets. In this
    example, one of the streets has cops on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783078.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The generated alist for this city, created by `add-cops`, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: This is actually a *nested* alist. The outer alist is organized based on the
    first node, and the inner alists are organized based on the second node.
  prefs: []
  type: TYPE_NORMAL
- en: With the edges in this format, we can easily find all edges connected to a given
    node by calling `(cdr (assoc node1 edges))`. To see if a given edge contains cops,
    we can call `(cdr (assoc node2 (cdr (assoc node1 edges))))`, which goes down two
    levels to grab the actual data linked to a specific edge between two nodes. (One
    additional benefit of using this nested alist format is that it is fully compatible
    with our graph libraries—a feature that we’ll take advantage of shortly.)
  prefs: []
  type: TYPE_NORMAL
- en: Building the Nodes for Congestion City
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we’ll build an alist for the nodes in our city. These nodes may contain
    the Wumpus or the Glowworms, or they might contain various clues, such as blood,
    lights, or sirens.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the clues in our game are based on proximity to another node, so we
    need to write some functions that tell us if two nodes are one node apart in the
    city graph. The `neighbors` function looks up the node’s neighbors using the alist
    of edges. If the second node is in that list, we know we’re one away.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: First, this function looks up the first node (`a`) in the alist of edges with
    `neighbors`. Then it uses `member` to see if the other node (`b`) is among these
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The blood stain clues for the Wumpus can also be seen from two nodes away.
    We can write a second function for checking two nodes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: First, we check if we are within one node of our goal ![](httpatomoreillycomsourcenostarchimages783564.png),
    since if we’re within one, we’re also within two. Next, we extract all the nodes
    that are one away ![](httpatomoreillycomsourcenostarchimages783560.png) (similar
    to what we did in the `within-one` function). Finally, we check if any of *these*
    new nodes are within one ![](httpatomoreillycomsourcenostarchimages783562.png),
    which would make them within two of the original node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have those utility functions, let’s write the function that builds
    the final node alist (basically, the final map of our city.) Here’s the listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The `make-city-nodes` function first picks random nodes for the Wumpus ![](httpatomoreillycomsourcenostarchimages783564.png)
    and the Glowworms ![](httpatomoreillycomsourcenostarchimages783562.png), and then
    it uses `loop` ![](httpatomoreillycomsourcenostarchimages783560.png) to run through
    the node numbers. As it runs through the nodes, it builds a list describing each
    node in the city, `appended` together from various sources ![](httpatomoreillycomsourcenostarchimages783554.png).
    By using `append`, each part of the code that describes these nodes (and is within
    the body of the `append`) can choose to add zero, one, or multiple items to the
    description, creating its own child lists with zero, one, or multiple items.
  prefs: []
  type: TYPE_NORMAL
- en: At the front of the list, we put the node name, `n` ![](httpatomoreillycomsourcenostarchimages783554.png).
    If the Wumpus is at the current node, we add the word *Wumpus* ![](httpatomoreillycomsourcenostarchimages783510.png)
    (but wrapped in a list, as we just described). If we’re within two nodes of the
    Wumpus, we show its blood ![](httpatomoreillycomsourcenostarchimages783544.png).
    If the node has a Glowworm gang, we show it next ![](httpatomoreillycomsourcenostarchimages783556.png),
    and if the Glowworm gang is one node away, we show its lights ![](httpatomoreillycomsourcenostarchimages783566.png).
    Finally, if an edge from the node contains cops, we indicate that sirens can be
    heard ![](httpatomoreillycomsourcenostarchimages783498.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for the sirens clue, we simply grab the edges with `(cdr (assoc n
    edges))` and see if some of these nodes have a value in the cdr. The `''cops`
    symbol would be attached to the edges at the `cdr`. Since we have only one data
    point for edges in this game, looking for the presence of a `cdr` is an adequate
    check for the presence of cops. For example, if we use our earlier example of
    an alist with cops on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: You can see that if an edge in the list has cops, such as here ![](httpatomoreillycomsourcenostarchimages783562.png),
    the `cdr` will lead to a non-`nil` value. An edge without cops ![](httpatomoreillycomsourcenostarchimages783564.png)
    will have a `cdr` that is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782874.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initializing a New Game of Grand Theft Wumpus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our graph construction stuff out of the way, we can write a simple function
    that initializes a brand-new game of Grand Theft Wumpus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two new functions here. One, the `find-empty-node` function ![](httpatomoreillycomsourcenostarchimages783564.png),
    ensures that the player doesn’t end up on top of a bad guy right at the beginning
    of the game. Here’s the code for that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The `find-empty-node` function is pretty simple. First, it picks a random node
    ![](httpatomoreillycomsourcenostarchimages783564.png) to consider as the player’s
    starting position. Then it checks whether it is a completely empty node ![](httpatomoreillycomsourcenostarchimages783562.png).
    If there’s stuff in that node, it simply calls itself again, trying another random
    spot ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you ever decide to modify the game and make it more crowded with bad guys,
    you could end up in a situation where no empty nodes exist. In that case, this
    function will search forever and lock up your Lisp REPL, since we didn’t put in
    any checks to detect this situation.
  prefs: []
  type: TYPE_NORMAL
- en: The other new function in our `new-game` command is `draw-city`, which we’ll
    write next.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a Map of Our City
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re finally ready to draw a map of our new city. We’re using a standard format
    for our graph data, so writing this function is a breeze:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: We created the `ugraph->png` function in the previous chapter, as part of our
    graph library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now call `(new-game)` from the REPL, and open the *city.dot.png* picture in
    your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783532.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since every city map created by our code is unique, your map will look completely
    different from the one in this picture.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can marvel at the results of our urban planning!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a City from Partial Knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, it’s awfully boring to hunt something if you already know where it
    is before the hunt starts. To solve this problem, we want a map of the city that
    shows only the nodes that we’ve visited so far. To that end, we use a global list
    called `*visited-nodes*` that is initially set to the player’s position only,
    but which we’ll update as we walk around the city visiting other nodes. Using
    this `*visited-nodes*` variable, we can calculate a smaller graph that includes
    only those parts of the city that are known to us.
  prefs: []
  type: TYPE_NORMAL
- en: Known Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we can build an alist of just the known nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: At the bottom of `known-city-nodes`, we need to figure out which nodes we can
    “see” based on where we’ve been. We’ll be able to see all visited nodes ![](httpatomoreillycomsourcenostarchimages783510.png),
    but we also want to track all nodes within one node of a visited node ![](httpatomoreillycomsourcenostarchimages783544.png).
    (We will discuss the `mapcan` function shortly.) We calculate who is “within one”
    using code similar to the previously discussed `within-one` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we `mapcar` over this list of relevant nodes, processing each ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the current node is occupied by the player, we mark it with an asterisk ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the node hasn’t been visited yet ![](httpatomoreillycomsourcenostarchimages783562.png),
    we mark it with a question mark ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Known Edges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we need to create an alist stripped of any cop sirens that we haven’t
    reached yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This function is similar to the `known-city-nodes` function. The noteworthy
    line of code is here ![](httpatomoreillycomsourcenostarchimages783564.png) where
    we strip the `cdr` from the edge list for edges so that cops are indicated on
    the map only if we’ve visited the nodes on both ends of an edge containing cops.
  prefs: []
  type: TYPE_NORMAL
- en: The mapcan Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mapcan` function we used in `known-city-nodes` is a variant of `mapcar`.
    However, unlike `mapcar`, `mapcan` assumes that the values generated by the mapping
    function are all lists that should be appended together. This is useful when there
    isn’t a one-to-one relationship between the items in a list and the result you
    want to generate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we run a burger shop and sell three types of burgers:
    the single, the double, and the double cheese. To convert a list of burgers into
    a list of patties and cheese slices, we could write the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Drawing Only the Known Parts of the City
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we now have functions that can generate the known information about
    nodes and edges, we can write a function that turns this information into a picture,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s redefine our `new-game` function to draw the known city when the
    game starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: This function is almost exactly the same as the previous version of `new-game`,
    except that we also create a drawing composed only of the known parts of the city
    ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we call the `new-game` function from the REPL, we’ll get a new picture
    named *known-city.dot.png* that we can view in our browser. It will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782216.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we’re ready to walk around our map of Congestion City!
  prefs: []
  type: TYPE_NORMAL
- en: Walking Around Town
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need two functions for traveling between the nodes in our city: a regular
    `walk` function and one for when we think we’ve found the Wumpus, and we want
    to `charge` that location with our final bullet. Since these two functions are
    very similar, we’ll have both of them delegate the bulk of the work to a common
    `handle-direction` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between these two functions is the flag they pass to `handle-direction`,
    which is set to either `nil` or `t`, depending on the kind of traveling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `handle-direction` function’s main job is to make sure that a move is legal,
    which it does by checking the edges of the city:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: First, this function looks up the legal directions players can move to from
    their current location ![](httpatomoreillycomsourcenostarchimages783564.png).
    It then uses the `pos` the player wants to move to and looks it up in that list
    of possible directions. Once we’ve determined that a direction is legal (that
    is, a node with that number shares an edge with the player’s current position),
    we need to find out what surprises are waiting as the player travels to this new
    place, using the `handle-new-place` function, which we’ll create next ![](httpatomoreillycomsourcenostarchimages783562.png).
    Otherwise, we display a helpful error message ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create the `handle-new-place` function, which gets called when the
    player has traveled to a new place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: First, we retrieve the node the player is traveling to from the alist of nodes
    ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we figure out if
    the node contains a Glowworm gang ![](httpatomoreillycomsourcenostarchimages783562.png).
    We ignore the gang if they’re in a node already visited, because they’ll only
    attack once.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `handle-new-place` function updates `*visited-nodes*` ![](httpatomoreillycomsourcenostarchimages783560.png)(adding
    the new position to the list) and `*player-pos*` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Then it calls `draw-known-city` ![](httpatomoreillycomsourcenostarchimages783510.png)
    again, since we now have a new place we know about.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it checks to see if there are any cops on the edge ![](httpatomoreillycomsourcenostarchimages783544.png),
    and then whether the Wumpus is at that location ![](httpatomoreillycomsourcenostarchimages783556.png).
    If the player encounters the Wumpus, our `handle-new-place` function needs to
    know whether we were charging the location. If we are charging at the Wumpus,
    we win the game. Otherwise, the Wumpus kills us and the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, we charge at a location that does not contain the Wumpus,
    we waste our single bullet and we lose the game as well ![](httpatomoreillycomsourcenostarchimages783566.png).
    Finally, if the location has a previously unencountered Glowworm gang, jump to
    a random new location, calling `handle-new-place` recursively ![](httpatomoreillycomsourcenostarchimages783498.png).
  prefs: []
  type: TYPE_NORMAL
- en: Our game is now complete!
  prefs: []
  type: TYPE_NORMAL
- en: Let's Hunt Some Wumpus!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To play our game, simply enter the traveling commands we created (`walk` and
    `charge`) at the REPL, then switch to your browser and refresh *known-city.dot.png*
    to plan your next move.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s where we left off in our sample game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782820.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have no clues, we know that any of these nodes will be safe to visit.
    Let’s try `(walk 20)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782246.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Uh oh! There’s blood here. That means the Wumpus must be two nodes away! It
    should still be safe to (`walk 11`) though, because that’s only one node away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782044.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Oh no! One of these streets has a police roadblock. Let’s backtrack with `(walk
    20) (walk 19)`, and then we can try `(walk 7)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780754.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Darn! Now we have the Wumpus and some Glowworms nearby. Let’s take a shot in
    the dark and try `(walk 10)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780248.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, that didn’t help, since there are cops down this path. However, because
    node 10 has only one other unexplored street, we can say with certainty that the
    street between 1 and 10 has cops on it.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it takes some serious thinking to become a master in Grand
    Theft Wumpus! Remember, you can always start a new game, with a new map, by using
    the `new-game` function. Once you’ve tracked down the Wumpus, use the `charge`
    function to attack him.
  prefs: []
  type: TYPE_NORMAL
- en: If you master the basic version of this game, try increasing the number of nodes,
    edges, cops, and Glowworms for an even greater challenge!
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ve used graph utilities with Lisp to make a more sophisticated
    game. Along the way, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `loop` function allows us to loop across various types of data. It will
    be discussed in more detail in [Chapter 10](ch11.html "Chapter 10. Looping with
    the loop Command").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `set-difference` function tells you which items are in one list but not
    in another list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `intersection` function tells you which items are shared by lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remove-duplicates` function removes duplicate items from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 9. Advanced Datatypes and Generic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen so far, a lot can be accomplished in Lisp by using cons cells,
    symbols, strings, and numeric datatypes. As a very mature language, Common Lisp
    contains many more datatypes that move well beyond these basics. In this chapter,
    we will discuss the most useful of these advanced datatypes, including arrays,
    hash tables, and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Common Lisp array* is very similar to a list. The main advantage of using
    arrays is that they require only a constant amount of time to access a value at
    any specific location. We’ll be discussing what this means shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new array, use the `make-array` command, specifying the array’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: This creates an array of length 3\. In order to indicate that the value created
    is not just a list, Common Lisp prepends a hash mark (#) in front of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get and set items in an array, use the `aref` function. For example, here’s
    how we get the item at index 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, our array is just filled with `nil`s right now, so there’s not much
    worth getting. To set items in the array to more interesting values, use `aref`
    in conjunction with the `setf` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `aref` is usually a command used to *get* a value out of an array,
    when used in this special way indicated in the example, it lets us *set* a value
    in an array, instead. This ability to use the `setf` and `aref` commands together
    shows off a feature in Common Lisp: its support for generic programming. Let’s
    take a closer look at the `setf` command to learn more about how this feature
    works.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Generic Setter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Common Lisp language is said to support *generic setters*. This means that
    in most cases, the code for *pulling a value out of* a data structure (whether
    an array, list, string, or something else) is identical to the code for *putting
    data into* that same data structure. The `setf` command can be used in conjunction
    with functions that perform getting operations and can use the same functions
    to perform setting operations, instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already seen that `aref` can be used to get values out of an array, and
    when used with `setf`, it can be used for setting values in the same array. The
    `setf` command can perform this trick in a general way across most of the commands
    in Common Lisp that get items from a data structure. Take, for instance, the following
    example involving a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, the expression `(second foo)` returns `B`. But, when we
    pass `(second foo)` to the `setf` command ![](httpatomoreillycomsourcenostarchimages783564.png),
    it somehow knows where the `B` came from, and it is able to treat the expression
    `(second foo)` as if it were a regular variable. Basically, the `setf` command
    asks itself the question, “Where did the item in my first argument originally
    come from?” In this case, the value came from the second item in the list named
    `foo`. Therefore, if we try to `setf` this location, the source variable, `foo`,
    is modified in response.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the first argument in `setf` is a special sublanguage of Common Lisp,
    called a *generalized reference*. Not every Lisp command is allowed in a generalized
    reference, but you can still put in some pretty complicated stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the true power of `setf` in Common Lisp. In the first
    use, we put the list `(x y z)` into an array as the third item ![](httpatomoreillycomsourcenostarchimages783564.png).
    If we now print `foo`, we can see that it worked ![](httpatomoreillycomsourcenostarchimages783562.png).
    In the second use, we replace the first item in this list inside the `foo` array
    with a hash table ![](httpatomoreillycomsourcenostarchimages783560.png). Hash
    tables are another advanced data type we’ll be learning about shortly, in [Hash
    Tables](ch10s02.html "Hash Tables"). It is surprisingly easy to do this with `setf`,
    because the generalized reference in the first argument to `setf` can be arbitrarily
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we go all out and insert the value `5` into this hash table with the
    key of `zoink` ![](httpatomoreillycomsourcenostarchimages783554.png). The `gethash`
    function lets you get a value out of a hash table, as we’ll see shortly. Here,
    with the help of `setf`, we are putting the number 5 into the hash table instead.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can appreciate from this example how useful `setf` can be when modifying
    complicated data structures in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Another cool feature of `setf` is that you can expand the generalized reference
    syntax to support new ways of accessing values. `setf` is a truly generic way
    of modifying values, regardless of the level of nesting or the datatypes being
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays vs. Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve now seen some basic examples of working with arrays in Lisp. However,
    to fully understand the benefits of arrays, we need to compare them with lists.
  prefs: []
  type: TYPE_NORMAL
- en: Almost anything that can be done with a list can also be done with an array.
    However, arrays are usually much faster than lists when accessing specific elements,
    so the difference is in performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the array-handling function `aref` is very similar to a list-handling
    function called `nth`, which allows you access to an item at a specific location
    in a regular list without using an array. Here is an example using `nth` on a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: However, it makes sense to use the `nth` function only with very small lists.
    If, for example, list X had thousands of items in it, running the command `(nth
    1000 x)` would be excruciatingly slow, because Lisp lists are made out of chains
    of cons cells. Hence, the only way Lisp can find the thousandth item in a list
    is to churn through the 999 preceding objects first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, running the command `(aref x 1000)` on a large array accesses
    the thousandth item directly, without counting through the previous 999 items.
    This means `aref` will execute much more quickly on a large array than the `nth`
    command would on a large list. In fact, an `aref` call will happen very quickly
    no matter how large the array. Even if you had an array with a billion items,
    retrieving the last item would still happen very quickly. The only real limiting
    factor is your system: the amount of RAM your computer has and how capable your
    Lisp environment is of taking advantage of it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782996.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not only can we quickly access array values, but we can also change values at
    any specific location, usually faster than we can by performing the same operations
    on a list.
  prefs: []
  type: TYPE_NORMAL
- en: Because setting and getting specific values in a large data structure is so
    important, keep arrays in mind as a tool to help you get the best performance
    possible with your code.
  prefs: []
  type: TYPE_NORMAL
- en: Hash Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that arrays are sort of like lists, *hash tables* are sort of
    like *alists*, except that they also allow you to access arbitrary elements more
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, hash tables are so efficient that they can, at times, seem like magic.
    Think of the Babel fish in the *Hitchhiker’s Guide to the Galaxy* trilogy—something
    so impossibly useful that it really has no business existing in the first place.
    That’s why almost all modern languages now offer the hash table datatype.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781664.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with Hash Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new hash table with the `make-hash-table` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Like alists, hash tables store items using a lookup key and a value. We can
    retrieve an item from the hash table using the item’s key with the `gethash` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: So far, our hash table remains empty. This means that when we look up any key
    in the hash table, such as `'yup` in this example, we receive `NIL` as an answer
    ![](httpatomoreillycomsourcenostarchimages783564.png). Actually, we receive two
    NILs ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)—the
    `gethash` command returns multiple values, which you can do in Common Lisp (discussed
    in the next section). The first returned value is the actual value stored in the
    hash table, and the second indicates whether the key was found in the table (in
    this case, it wasn’t).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with arrays, we can once again combine a command used for referencing
    data elements—in this case, `gethash`—with the `setf` command in order to fill
    our table with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve stored the value `25` in the hash table with a lookup
    key of `yup` ![](httpatomoreillycomsourcenostarchimages783564.png). Then, when
    we look up `yup` in the table, we get the answer of 25 ![](httpatomoreillycomsourcenostarchimages783562.png).
    We also get a second value of `t` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which means, “Yes, I found the key in the table.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember when we discussed alists, we set up a data structure containing an
    order for coffee drinks? Here is that same data, but this time it’s stored using
    a hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the drink order for any person is now simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Returning Multiple Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Common Lisp allows you to return more than one value as a result. Some of the
    core Common Lisp core functions do this, including the `gethash` function, as
    you’ve seen. Another commonly used function that does this is the `round` function,
    which rounds off a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Calling this function appropriately rounded our number to 2 ![](httpatomoreillycomsourcenostarchimages783564.png),
    but then it also generated a second value, which is the remainder of the rounding
    operation ![](httpatomoreillycomsourcenostarchimages783562.png). Both values are
    returned from this function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create multiple values in your own code by using the `values`
    function. Here, for instance, we can write a `foo` function that returns two separate
    numbers, 3 and 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these values are printed out at the REPL ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png),
    just as with the `round` function. However, Lisp considers the first value to
    be more important, and it will always be used by default during follow-up calculations.
    For instance, we can perform an addition after calling `foo`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the addition operator just ignores the second value that `foo`
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes you might need to use that additional returned value. You
    can do this by using the `multiple-value-bind` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve bound the variables `a` and `b` to both of the values
    returned by `foo` (`3` and `7`). Calling our function with `multiple-value-bind`
    lets us use the extra values returned from the function, which would otherwise
    be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering whether you could just return a list from your function
    instead of using the multiple-value feature. The answer is, yes, you could. However,
    it’s possible that using the multiple-value feature can lead to more optimized
    and cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will not be making much use of multiple values. In fact, more
    recent Lisp dialects, such as Arc and Clojure, do not support multiple values
    at all. Instead, they just return a list in the few cases where more than one
    value needs to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Hash Table Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with arrays, accessing and modifying a value inside a hash table requires
    only a constant amount of time, no matter how many items your hash table contains.
    For instance, suppose we have a hash table with only 10 items in it. We access
    a value in the table, using a key, and find it takes on average 1 millisecond
    to do so. Now suppose that the hash table has 1,000,000 items in it. Because of
    how hash tables are designed, we could still expect it to take only about 1 millisecond
    to retrieve a value. In other words, no matter how big the table is, we can access
    items at a constant time of 1 millisecond.
  prefs: []
  type: TYPE_NORMAL
- en: Think of how incredible that is! Even if your hash table contained 1,000,000
    items, the `gethash` function could take the key you gave it and determine in
    a constant amount of time exactly where your desired item could be found!
  prefs: []
  type: TYPE_NORMAL
- en: In this era of web-based programs backed by enormous amounts of data, the ability
    of hash tables to store large numbers of values with fast retrieval makes them
    indispensable. The efficient storage of key/value pairs is essential for most
    online storage systems. Even the latest tools for storing vast amounts of online
    data, like Google’s BigTable or Amazon’s S3, are built around the quick retrieval
    of values using keys, which makes them similar to hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can’t always expect hash tables to provide the best performance.
    Here’s why:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual memory paging and cache misses:**'
  prefs: []
  type: TYPE_NORMAL
- en: As with arrays, large hash tables may cause your operating system to start paging
    virtual memory to your hard drive, thus degrading performance. Similarly, they
    can increase the number of cache misses within your CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash collisions:**'
  prefs: []
  type: TYPE_NORMAL
- en: Internally, hash tables use a special function called a *hash function*, which
    converts keys into numbers. Such a hash function can cause *hash collisions*.
    Basically, a hash collision happens when, by chance, two keys are converted by
    the hash function into the same number. In this case, the hash table will still
    behave correctly, but at a slightly degraded performance. In rare cases, certain
    types of keys can interact with a hash function to increase the number of collisions
    and impede an application’s ability to perform lookups, degrading performance
    even more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inefficiency with small tables:**'
  prefs: []
  type: TYPE_NORMAL
- en: With very small tables, the creation and lookup time required by hash tables
    can make them less inefficient than simpler structures, such as alists. The performance
    benefits of hash tables are noticeable only when they contain larger amounts of
    data in them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Varying speed for operations:**'
  prefs: []
  type: TYPE_NORMAL
- en: In Common Lisp, if you create a small hash table, and then fill it with values,
    you will find that occasionally, adding a new value will be unusually slow. This
    is because the `make-hash-table` function is designed to minimize the cost for
    creating small hash tables. However, as you start adding values to make the table
    big, Lisp will need to take extra time to allocate more memory so that the table
    can hold more items. These extra allocations will lead to occasional slow insertions
    into the table as it grows.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one final reason why hash tables are not always the best solution:
    They are simply not as Lispy as traditional Lisp structures built from cons cells.
    This means they can be harder to debug than cons cells, since they cannot be read
    and printed as naturally in the Lisp REPL. Therefore, a good rule of thumb is
    to stay away from arrays and hash tables as you conceive a new piece of code.
    Then, if performance ends up becoming an issue, and only then, judiciously modify
    the critical sections of your code to take advantage of arrays and hash tables
    to resolve any performance problems.'
  prefs: []
  type: TYPE_NORMAL
- en: A Faster Grand Theft Wumpus Using Hash Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at a practical example of what hash tables can do for your code.
    There is a glaring inefficiency in our latest game, Grand Theft Wumpus, that we
    can now correct with hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from the previous chapter that Grand Theft Wumpus uses lists of nodes
    and edges to represent the graph of the city. This means that in order to find
    connections to a given node, we must do a linear search through a list. This isn’t
    a big deal in Grand Theft Wumpus, because Congestion City doesn’t have a lot of
    intersections. But what if our city had a thousand nodes with a thousand edges?
    Let’s time the `get-connected` function and see what kind of numbers we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: The `time` command is a Lisp utility that outputs all kinds of useful timing
    information about a chunk of code, and the `dotimes` function lets us run our
    code 100 times, building 100 cities. Using these commands, it took about a minute
    to run this code on my computer. Given how many gazillion instructions a CPU can
    crunch in a minute, this is absolutely horrifyingly bad performance.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this problem, we’ll replace our edge list for this code with a hash table
    so that the `get-connected` function will be able to find connections to a node
    in constant time. We’ll also replace our visited list with a visited table, so
    the function can quickly tell whether a node has already been visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that makes this happen, consisting of hashed versions of our
    previous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: First, we need `hash-edges`, a function that converts our edge list into a hash
    table ![](httpatomoreillycomsourcenostarchimages783564.png). At the beginning
    of the function, we create a new hash table and name it `tab` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then, we iterate through the table with `mapc` ![](httpatomoreillycomsourcenostarchimages783560.png).
    Remember that `mapc` is just like `mapcar`, except that you use it in places where
    you care only about the side effects and don’t care about generating a final list
    as a result.
  prefs: []
  type: TYPE_NORMAL
- en: For every node, we want the table to contain a list of nodes connected to it.
    Therefore, as we iterate through the list, we push a new neighbor onto the current
    list of neighbors for the current starting node ![](httpatomoreillycomsourcenostarchimages783554.png).
    We can use the `push` command on hash table values just as for regular Lisp variable
    values. This, again, makes use of the general variables system built into Common
    Lisp, which we’ll discuss in [Handling Data in a Generic Way](ch10s04.html "Handling
    Data in a Generic Way") in [Handling Data in a Generic Way](ch10s04.html "Handling
    Data in a Generic Way").
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we don’t need to deal with the case where there is
    no value yet for a node in the table. How can we `push` something into a value
    in the table if no value exists? Well, it turns out that because the `gethash`
    function returns `NIL` when a key is not found in the table, this code will simply
    push the new neighbor onto an empty list and stick a new record into the table
    where none was found before. In this way, the `push` command magically does the
    “right thing,” no matter whether the node is new or old.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once our table is populated, we return it as a result ![](httpatomoreillycomsourcenostarchimages783510.png).
    It contains the same data as the original edge list. The difference is that we
    can now find the neighbors of any node in Congestion City at blazing speeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Now we’re ready to write `get-connected-hash`, which retrieves all the nodes
    connected to a starting node in Congestion City ![](httpatomoreillycomsourcenostarchimages783564.png).
    It is identical in behavior to `get-connected`, but is optimized through hash
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing this function does is create a hash table of visited nodes ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we travel through the nodes of Congestion City, beginning with the starting
    node. Every time we visit a new node, we ask ourselves if we’ve visited it before.
    We can now answer this question very efficiently by looking up the current node
    in the `visited` table ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the answer is no, we’ll need to mark this node as visited ![](httpatomoreillycomsourcenostarchimages783554.png)
    and check all of its neighbors by `mapc`ing through them—checking our edge table
    ![](httpatomoreillycomsourcenostarchimages783510.png). Finally, we return our
    `visited` table, which in the end will hold all nodes that are connected to the
    starting node ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can rerun our test with this new logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, instead of taking a minute to calculate the connections in the
    graph, it now takes only one second to do the same thing! This is why you must
    know how to use hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *structure* is an advanced datatype available in Common Lisp. Structures and
    their properties can be a useful way to represent data in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Structures can be used to represent objects with properties, as you might find
    in a typical object-oriented programming (OOP) language using the `defstruct`
    command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the definition in this structure, a `person` has four properties
    (also called *slots* by Lispers): `name`, `age`, `waist-size`, and `favorite-color`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined this structure, we can create instances of a person using the
    `make-person` command, a special function that `defstruct` has automatically created
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we enter `*bob*` into the REPL, we see our new person marked as a
    structure with the `#S` prefix. We also see that the structure is of type `person`,
    and the values of each of its properties (`name`, `age`, `waist size`, and `favorite-color`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'We can determine Bob’s age by calling another automatically created function,
    `person-age`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: We can also use `setf` with these commands to change Bob’s age. (Happy birthday,
    Bob!)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'The Lisp reader can also create a person directly from the printed representation
    of the person, another great example of the print/read symmetry in Lisp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re creating a new variable called `*that-guy*`, and we set its value
    using only the printed representation of the person ![](httpatomoreillycomsourcenostarchimages783564.png).
    This variable now has a real `person` structure in it, just as if we had used
    the `make-person` function ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `defstruct` is quite a powerful command that can be used to
    build special functions that make it easy to create instances of a new object
    and access its properties.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These days, many mainstream programmers believe that object orientation is a
    necessity when developing large and robust applications. Many Lispers, on the
    other hand, believe that it’s possible to build high-quality software without
    taking a purely OOP approach.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with
    Functional Programming"), we’ll examine some of these alternate approaches, including
    higher-order functional programming and domain-specific language programming.
    The design of the Lisp language makes it much easier to take advantage of these
    alternate approaches than is possible with other, more object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, even if you’re not writing purely OOP-style software, structures
    and their properties can still prove to be a useful way to represent data in your
    code. For instance, instead of creating a `person` class with `defstruct`, we
    could do the same thing with a standard list and our own `make-person` function.
    After all, why bother with structures if we can just roll our own person using
    lists, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Although this approach will work, it has several downsides. First, in order
    to check a person’s age or other properties, we would need to write a lot of error-prone
    functions that pull properties out of the list from the correct locations. Also,
    the printed version of our ad hoc object ![](httpatomoreillycomsourcenostarchimages783564.png)
    is very hard to understand. How do we know `BOB` is a person? Is Bob’s age 35
    or 32? Regular lists just don’t lend themselves well to encoding objects with
    multiple properties.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with using lists to represent an object in the real world is
    that the properties of an object (like a `person` object) may change over time.
    Lists in Lisp work best when you are dealing with information that never changes
    once the list is created. When Bob turns 36, however, we need to change his age
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Having part of a data structure change over time is called a *mutation* by computer
    scientists. It’s easy to change the value of a specific property (mutate the property)
    in a structure created with `defstruct`, so these structures are very suitable
    for handling data that needs to be mutable. Therefore, it makes sense to store
    a `person` (or any other object that changes over time) in a structure. We will
    be discussing the issue of mutation in greater detail in [Chapter 14](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `defstruct` facility is not the only tool that can be used to create objects
    in Common Lisp. For example, in the epilogue of the book, you’ll see that Common
    Lisp’s Common Lisp Object System (CLOS) allows you to build very sophisticated
    object-based systems. If you care to code with a strongly object-oriented mindset,
    you will probably find all the OOP language functionality you need in Common Lisp.
    Indeed, CLOS has many advanced object-oriented features that you won’t find in
    many other places. Because of this, CLOS has often been used as a research tool
    for studying OOP ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Data in a Generic Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Common Lisp has many different datatypes available for writing elegant and efficient
    programs. But without some care, having so many datatypes can lead to ugly and
    repetitive code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we want to add several groups of numbers, which are stored
    as both lists and arrays. Since lists and arrays behave differently, will we need
    to write two different addition functions—one for lists and the other for arrays?
    It would be great if we could write a single chunk of code to handle both cases
    without caring about how the numbers are stored.
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp has all the features we need to write such generic code, including
    generic library functions, type predicates, `defmethod`, and generic accessors.
    We can use these features to write code that works with many types of data—including
    built-in as well as custom types that we might create with `defstruct`—without
    superfluous repetition in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to write code that works with any type of argument is to hand
    the type-checking work to someone else. The Common Lisp libraries are packed with
    functions that can generically handle data of varying types in their arguments,
    the most commonly used of which are the *sequence functions*. The sequence functions
    work generically across the three main ways of sequencing objects in Lisp: lists,
    arrays, and strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen one of these sequence functions without even realizing
    it: the `length` function. You can use the `length` function to check for the
    length of all three sequence types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Without the generic `length` function, you would need to use three separate
    functions to determine the length of strings, arrays, and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common Lisp has a specific function for checking the length of lists, called
    list-length. Because generic functions tend to require extra type-checking to
    determine the correct behavior, they can be slower to execute. The `list-length`
    function is useful for performance-sensitive code, but most Lispers prefer using
    the generic `length` function in regular code.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence Functions for Searching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some sequence functions let you search sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find-if` finds the first value that satisfies a predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count` finds out how often a certain object appears in sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`position` tells you where an item is located.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`some` and `every` tell you if some or every value in a sequence obeys a specific
    predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, we use `find-if` to find the first number in a sequence,
    which is the number 5 ![](httpatomoreillycomsourcenostarchimages783564.png). We
    use `count` to find out how many times the character `s` appears in `"mississippi"`
    ![](httpatomoreillycomsourcenostarchimages783562.png). We use `position` to find
    at what position the character 4 appears. In this case, it is in the fifth position,
    starting the count from zero ![](httpatomoreillycomsourcenostarchimages783560.png).
    We use `some` to see if any items in a sequence are numbers. Indeed, there is
    a number ![](httpatomoreillycomsourcenostarchimages783554.png). Finally, we use
    `every` to see if every item in the list is a number, which is not the case ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: Sequence Functions for Iterating Across a Sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One particularly useful generic sequence function is `reduce`. The `reduce`
    function allows you to iterate through a sequence and distill it down into a single
    result. Here, we use `reduce` to add together items in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'The sum of those numbers turns out to be 20\. Here is a diagram that shows
    exactly what is happening in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781410.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the right side, shown in gray, is our list. On the left side, you can see
    the pairs of numbers that are fed into the plus (`+`) function and the intermediate
    results that are calculated. This shows that the plus function always receives
    a single intermediate result as well as the next number in the list as its arguments.
    The only exception to this is in the very first call to the plus function. Since
    no intermediate result exists when we start, the first time we call the plus function,
    we promote the number 3, which is at the start of the list, into our intermediate
    result column. Therefore, the first time the plus function is called, it actually
    receives *two items* straight off the top of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a slightly more complicated example, this time using our own
    reduction function. We’re going to find the largest even number in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Our reduction function, which we pass to `reduce` to distill down our answer
    from the list, has two arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    The first argument is the best value we’ve found so far—in other words, the largest
    even number we’ve found so far. The second argument is the next number from the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Our `reduce` function needs to return as a result the new best number. Therefore,
    if the latest number is better than the previous best ![](httpatomoreillycomsourcenostarchimages783562.png),
    we return it ![](httpatomoreillycomsourcenostarchimages783560.png). Otherwise,
    we return the previous best ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the first number in the list we’re reducing will be used as a
    starting value. If this is a problem, we can instead pass an explicit initial
    value to the `reduce` function by passing in a keyword parameter named `:initial-value`
    ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: Specifying an initial value for the `reduce` function is often necessary, or
    a bug can sneak into your code. In our example, it could allow an odd number at
    the front of the list to erroneously be deemed the best large even number. Let’s
    see what happens if we leave out the initial value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Yes, things go horribly, horribly wrong, as a result of not specifying an initial
    `reduce` value.
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit of the `reduce` function is that it is generic, as is
    true for all these sequence functions. This means that it can `reduce` lists,
    arrays, or strings in exactly the same way, and you can use `reduce` to write
    functions that are oblivious to the difference between these different sequence
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, I mentioned that it would be convenient to be able to write a single
    function that could sum together numbers in lists or arrays equally well. Now
    we can write such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781742.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`sum` is blissfully unaware of the difference between arrays and lists; it
    works on both. However, since addition doesn’t make any sense for characters,
    the `sum` function returns an error when used on a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Another function that is useful for iterating across a sequence is the `map`
    function. This function is identical in behavior to `mapcar`. However, unlike
    `mapcar`, the `map` function works on all sequence types, not just lists. You
    specify the type of sequence to return from the mapping by passing an extra argument
    to the `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re turning every `s` character in a string to its uppercase
    version. The mapping function we pass into `map` simply checks if the current
    character is an `s` and returns the uppercase `S` if it is ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: The result of this calculation is a list of characters ![](httpatomoreillycomsourcenostarchimages783560.png).
    This is because we told the `map` function that we wanted a list as a result ![](httpatomoreillycomsourcenostarchimages783564.png).
    Had we asked for a `string` instead, a string would have been our result.
  prefs: []
  type: TYPE_NORMAL
- en: Two More Important Sequence Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `subseq` function lets you pull a subsequence out of a larger sequence
    by specifying starting and ending points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the word `america` contains the name `eric`, starting from the
    second character and ending at the sixth character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sort` function lets you pass it an arbitrary function to use for the sorting.
    In this case, we’re just using the less-than (`<`) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: There are many more sequence functions than we’ve discussed so far, but the
    examples in this chapter will get you off to a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a comprehensive list of sequence functions, and indeed all Common Lisp functions,
    visit the *Common Lisp Hyperspec* at [http://www.snipurl.com/rz3h0](http://www.snipurl.com/rz3h0)—an
    exhaustive, but daunting, description of all Common Lisp has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Generic Functions with Type Predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Common Lisp, like virtually all other Lisps, is a dynamically typed language.
    This means that parameters or variables in your code can hold any type of data—symbols,
    strings, numbers, functions, or whatever else you want to place in them. In fact,
    the same parameter or variable can even hold different types of data at different
    times in a running program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, it makes sense to have a bunch of functions that tell you whether
    a variable has a certain type of data in it. For instance, you can check whether
    you have a number with `numberp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The type predicates you will probably use most frequently are `arrayp`, `characterp`,
    `consp`, `functionp`, `hash-table-p`, `listp`, `stringp`, and `symbolp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use type predicates to write functions that handle different types
    of data generically. Suppose we wanted to write a function that lets us add both
    numbers or lists. Here’s one way we could write such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: In this `add` function, we use predicates to see if the arguments passed in
    are numbers or lists, and then we act appropriately. If we aren’t given two numbers
    or two lists, it simply returns `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can write functions supporting multiple types of data using type
    predicates, most Lispers wouldn’t write an `add` function this way, for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A single, monolithic function for all types:**'
  prefs: []
  type: TYPE_NORMAL
- en: This is fine for just two types, but if we wanted to handle a dozen or more
    types, our function would quickly turn into a giant monstrosity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifications required to accommodate new cases:**'
  prefs: []
  type: TYPE_NORMAL
- en: We would need to change the add function whenever we want to support a new type,
    increasing the chance that we would break existing code. Ideally, we would like
    to handle each new situation by itself without touching already working code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard to understand:**'
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to see exactly what the main cond statement is doing and if the types
    are all being routed to the right place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance:**'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting function might be slow. For instance, a Lisp interpreter/compiler
    might be able to create faster code for appending two lists if it knew for sure
    that both items were lists when the appending happens. However, in our first attempt
    at the add function, the type of the two arguments is never really completely
    obvious. Our compiler would need a bit of smarts to be able to tell from the condition
    `(and (listp a) (listp b))` that both variables are guaranteed to be lists. Life
    would be easier for the compiler if we explicitly stated the types of arguments
    for each type situation.
  prefs: []
  type: TYPE_NORMAL
- en: Because it is so useful to be able to have a single function that does different
    things when given certain datatypes, the Common Lisp command `defmethod` lets
    us define multiple versions of a function that each supports different types.
    When that function is called, Lisp checks the argument types at the time of the
    call and chooses the correct version of the function automatically. The proper
    term for having a compiler/interpreter choose among different versions of a function
    based on argument types is *type dispatching*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we would write our `add` function using `defmethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this version of the `add` function handles every type of situation
    with a separate function, and new cases can be added without modifying existing
    code. Overall, the code is much easier to understand. Also, the compiler can see
    the type of the parameters and may be able to write faster code using this knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: The `defmethod` function is like `defun`, except that it allows us to write
    multiple functions with the same name. When using `defmethod`, we can explicitly
    state the type of each parameter in the function’s argument list so that Lisp
    can use these type declarations to figure out the correct version of `add` for
    each situation.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with the world of OOP, the word *method* probably has a special
    meaning to you. Since this new command is called `defmethod`, does it have anything
    to do with OOP? In short, yes. This command can be used not only with Common Lisp’s
    built-in types, but also with structures you’ve created with `defstruct`. The
    combination of `defstruct` and `defmethod` basically constitutes a simple object
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll use this object system to write a game!
  prefs: []
  type: TYPE_NORMAL
- en: The Orc Battle Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Orc Battle game, you’re a knight surrounded by 12 monsters, engaged in
    a fight to the death. With your superior wits and your repertoire of sword-fighting
    maneuvers, you must carefully strategize in your battle with orcs, hydras, and
    other nasty enemies. One wrong move and you may be unable to kill them all before
    being worn down by their superior numbers. Using `defmethod` and `defstruct`,
    let’s dispatch some whoop ass on these vermin!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783116.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Global Variables for the Player and Monsters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll want to track three player stats: health, agility, and strength. When
    a player’s health reaches zero, that player will die. Agility will control how
    many attacks a player can perform in a single round of battle, and strength will
    control the ferocity of the attacks. As the game progresses, each of these will
    change and affect gameplay and strategy in subtle ways.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: We’ll store our monsters in an array called `*monsters*`. This array will be
    *heterogeneous*, meaning it can contain different types of monsters, be they orcs,
    hydras, or anything else. We’ll create our monster types with `defstruct`. Of
    course, we still need to figure out how to handle each type in the list in a meaningful
    way—that’s where we’ll use Lisp’s generic features.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also define a list of functions for building monsters that we’ll store
    in the variable `*monster-builders*`. As we write the code for each type of monster,
    we’ll create a function that builds a monster of each type. We’ll then push each
    of these monster builders onto this list. Having all the builder functions in
    this list will make it easy for us to create random monsters at will for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll create the variable `*monster-num*` to control how many opponents
    our knight must fight. Change this variable to increase (or decrease) the difficulty
    level of Orc Battle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Main Game Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to write our first real code for the game, starting with the
    big picture functions that drive the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll define a function called `orc-battle`. This function will initialize
    the monsters and start the game loop and, once the battle ends, it will determine
    the victor and print the appropriate ending message for the game. As you can see,
    `orc-battle` calls plenty of helper functions to do the actual work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: At the top, we call the initialization functions for the monsters and the player
    ![](httpatomoreillycomsourcenostarchimages783564.png). Then we start the main
    game loop ![](httpatomoreillycomsourcenostarchimages783562.png). The game loop
    will keep running until either the player or the monsters are dead. We’ll print
    a game-ending message depending on whether the player ![](httpatomoreillycomsourcenostarchimages783560.png)
    or monsters ![](httpatomoreillycomsourcenostarchimages783554.png) died.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create the function `game-loop` to handle the game loop. This function
    handles a round of the battle, and then calls itself recursively for the following
    round:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The `game-loop` function handles the repeated cycles of monster and player attacks.
    As long as both parties in the fight are still alive, the function will first
    show some information about the player in the REPL ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we allow the player to attack the monsters. The `game-loop` function uses
    the player’s agility to modulate how many attacks can be launched in a single
    round of battle, using some fudge factors to transform the agility to a small,
    appropriate number ![](httpatomoreillycomsourcenostarchimages783562.png). When
    the game begins, the player will have three attacks per round. Later stages of
    battle could cause this number to drop to a single attack per round.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculated agility factor for our player attack loop ![](httpatomoreillycomsourcenostarchimages783562.png)
    is passed into the `dotimes` command, which takes a variable name and a number
    *n*, and runs a chunk of code *n* times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: The `dotimes` function is one of Common Lisp’s looping commands (looping is
    covered in more detail in [Chapter 10](ch11.html "Chapter 10. Looping with the
    loop Command")).
  prefs: []
  type: TYPE_NORMAL
- en: After the player has attacked, we allow the monsters to attack. We do this by
    iterating through our list of monsters with the `map` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    Every type of monster has a special `monster-attack` command, which we’ll call
    as long as the monster is still alive ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `game-loop` function calls itself recursively, so that the battle
    can continue until one side or the other has been vanquished ![](httpatomoreillycomsourcenostarchimages783510.png).
  prefs: []
  type: TYPE_NORMAL
- en: Player Management Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functions we need for managing the player’s attributes (health, agility,
    and strength) are very simple. Following are the functions we need to initialize
    players, to see if they’ve died, and to output their attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The `player-attack` function lets us manage a player’s attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'First, this function prints out some different types of attacks from which
    the player can choose ![](httpatomoreillycomsourcenostarchimages783564.png). As
    you can see, the player is offered three possible attacks: a stab, a double swing,
    and a roundhouse swing. We read in the player’s selection, and then handle each
    type of attack in a `case` statement ![](httpatomoreillycomsourcenostarchimages783562.png).'
  prefs: []
  type: TYPE_NORMAL
- en: The stab attack is the most ferocious attack and can be delivered against a
    single foe. Since a stab is performed against a single enemy, we will first call
    the `pick-monster` function to let the player choose whom to attack ![](httpatomoreillycomsourcenostarchimages783560.png).
    The attack strength is calculated from the `*player-strength*`, using a random
    factor and some other little tweaks to generate a nice, but never too powerful,
    attack strength ![](httpatomoreillycomsourcenostarchimages783554.png). Once the
    player has chosen a monster to attack and the attack strength has been calculated,
    we call the `monster-hit` function to apply the attack ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the stab attack, the double swing is weaker, but allows two enemies to
    be attacked at once. An additional benefit of the attack is that the knight can
    tell, as the swing begins, how strong it will be—information that can then be
    used to choose the best enemies to attack midswing. This extra feature of the
    double swing adds strategic depth to the game. Otherwise, the double-swing code
    ![](httpatomoreillycomsourcenostarchimages783510.png) is similar to the stab code,
    printing a message and allowing the player to choose whom to attack. In this case,
    however, two monsters can be chosen ![](httpatomoreillycomsourcenostarchimages783544.png)![](httpatomoreillycomsourcenostarchimages783556.png).
  prefs: []
  type: TYPE_NORMAL
- en: The final attack, the roundhouse swing, is a wild, chaotic attack that does
    not discriminate among the enemies. We run through a `dotimes` loop based on the
    player’s strength ![](httpatomoreillycomsourcenostarchimages783566.png) and then
    attack random foes multiple times. However, each attack is very weak, with a strength
    of only 1 ![](httpatomoreillycomsourcenostarchimages783498.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'These attacks must be used correctly, at the right stages of a battle, in order
    to achieve victory. To add some randomness to the attacks in the `player-attack`
    function, we used the `randval` helper function to generate random numbers. It
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: The `randval` function returns a random number from one to *n*, while making
    sure that no matter how small *n* is, at least the number 1 will be returned.
    Using `randval` instead of just the `random` function for generating random numbers
    gives a reality check to the randomness of the game, since 0 doesn’t make sense
    for some of the values we use in our calculations. For instance, even the weakest
    player or monster should always have an attack strength of at least 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `random` function used by `randval` is the canonical random value function
    in Lisp. It can be used in several different ways, though most frequently it is
    used by passing in an integer *n* and receiving a random integer from 0 to *n*−1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Helper Functions for Player Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `player-attack` function needs two helper functions to do its job. First,
    it needs a `random-monster` function that picks a monster to target for the chaotic
    roundhouse attack, while ensuring that the chosen monster isn’t already dead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: The `random-monster` function first picks a random monster out of the array
    of monsters and stores it in the variable `m` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Since we want to pick a living monster to attack, we recursively try the function
    again if we inadvertently picked a dead monster ![](httpatomoreillycomsourcenostarchimages783562.png).
    Otherwise, we return the chosen monster ![](httpatomoreillycomsourcenostarchimages783560.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `player-attack` function also needs a function that allows the player to
    pick a monster to target for the nonrandom attacks. This is the job of the `pick-monster`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: In order to let the player pick a monster to attack, we first need to display
    a prompt ![](httpatomoreillycomsourcenostarchimages783564.png) and read in the
    player’s choice ![](httpatomoreillycomsourcenostarchimages783562.png). Then we
    need to make sure the player chose an integer that isn’t too big or too small
    ![](httpatomoreillycomsourcenostarchimages783560.png). If this has happened, we
    print a message and call `pick-monster` again to let the player choose again.
    Otherwise, we can safely place the chosen monster in the variable `m` ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: Another error the player could make is to attack a monster that is already dead.
    We check for this possibility next and, once again, allow the player to make another
    selection ![](httpatomoreillycomsourcenostarchimages783510.png). Otherwise, the
    player has successfully made a choice, and we return the selected monster as a
    result ![](httpatomoreillycomsourcenostarchimages783544.png).
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s work on our monsters.
  prefs: []
  type: TYPE_NORMAL
- en: Monster Management Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use the `init-monsters` function to initialize all the bad guys stored
    in the `*monsters*` array. This function will randomly pick functions out of the
    `*monster-builders*` list and call them with `funcall` to build the monsters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: First, the `init-monsters` function builds an empty array to hold the monsters
    ![](httpatomoreillycomsourcenostarchimages783560.png). Then it `maps` across this
    array to fill it up ![](httpatomoreillycomsourcenostarchimages783564.png). In
    the `lambda` function, you can see how random monsters are created by `funcall`ing
    random functions in our list of monster builders ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need some simple functions for checking if the monsters are dead. Notice
    how we use the every command on the `*monsters*` array to see if the function
    `monster-dead` is true for every monster. This will tell us whether the entire
    monster population is dead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use the `show-monsters` function to display a listing of all the monsters.
    This function will, in turn, defer part of the work to another function, so it
    doesn’t actually need to know a lot about the different monster types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Since our player will need to choose monsters with a number, we will maintain
    a count as we loop through monsters in our list, in the variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we `map` through our monster list, calling a `lambda` function on each monster,
    which will print out some pretty text for each monster ![](httpatomoreillycomsourcenostarchimages783562.png).
    We use our `x` variable to print out the number for each monster in our numbered
    list ![](httpatomoreillycomsourcenostarchimages783560.png). As we do this, we
    use the `incf` function, which will increment `x` as we work through the list.
  prefs: []
  type: TYPE_NORMAL
- en: For dead monsters, we won’t print much about them, just a message showing that
    they are dead ![](httpatomoreillycomsourcenostarchimages783554.png). For living
    monsters, we call generic monster functions, calculating the health ![](httpatomoreillycomsourcenostarchimages783510.png)
    and generating the monster description ![](httpatomoreillycomsourcenostarchimages783544.png)
    in a specialized way for each different type of foe.
  prefs: []
  type: TYPE_NORMAL
- en: The Monsters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we haven’t seen any functions that really give life to the monsters.
    Let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll describe a generic monster.
  prefs: []
  type: TYPE_NORMAL
- en: The Generic Monster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you would expect, orcs, hydras, and other bad guys all have one thing in
    common: a health meter that determines how many hits they can take before they
    die. We can capture this behavior in a `monster` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'This use of the `defstruct` function takes advantage of a special feature:
    When we declare each slot in the structure (in this case, `health`) we can put
    parentheses around the name and add a default value for that slot. But more important,
    we can declare a form that will be evaluated when a new `monster` is created.
    Since this form calls `randval`, every monster will start the battle with a different,
    random, health.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try creating some monsters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a function that takes away a monster’s health when it’s attacked.
    We’ll have this function output a message explaining what happened, including
    a message to be displayed when the monster dies. However, instead of creating
    this function with `defun`, we’ll use the generic `defmethod`, which will let
    us display special messages when the knight beats on particular monsters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'The `decf` function ![](httpatomoreillycomsourcenostarchimages783564.png) is
    a variant of `setf` that lets us subtract an amount from a variable. The `type-of`
    function lets `monster-hit` pretend it knows the type of the monster that was
    hit ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    This function can be used to find the type of any Lisp value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Currently, the type of a monster will always be `monster`, but soon we’ll have
    this value change for each monster type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use two more generic methods to create monsters: `monster-show`
    and `monster-attack`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `monster-attack` function doesn’t actually do anything. This is because
    all our monster attacks will be so unique that there’s no point in defining a
    generic attack. This function is simply a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have some generic monster code, we can finally create some actual
    bad guys!
  prefs: []
  type: TYPE_NORMAL
- en: The Wicked Orc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The orc is a simple foe. He can deliver a strong attack with his club, but otherwise
    he is pretty harmless. Every orc has a club with a unique attack level. Orcs are
    best ignored, unless there are orcs with an unusually powerful club attack that
    you want to cull from the herd at the beginning of a battle.
  prefs: []
  type: TYPE_NORMAL
- en: To create the orc, we define an `orc` datatype with `defstruct`. Here, we will
    use another advanced feature of `defstruct` to declare that the `orc` includes
    all the fields of `monster`.
  prefs: []
  type: TYPE_NORMAL
- en: By including the fields from our `monster` type in our `orc` type, the `orc`
    will be able to inherit the fields that apply to all monsters, such as the `health`
    field. This is similar to what you can accomplish in popular languages such as
    C++ or Java by defining a generic class and then creating other, more specialized,
    classes that inherit from this generic class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the structure is declared, we push the `make-orc` function (automatically
    generated by the `defstruct`) onto our list of `*monster-builders*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how powerful this approach is. We can create as many new monster types
    as we want, yet we’ll never need to change our basic Orc Battle code. This is
    possible only in languages like Lisp, which are dynamically typed and support
    functions as first-class values. In statically typed programming languages, the
    main Orc Battle code would need some hardwired way of calling the constructor
    for each new type of monster. With first-class functions, we don’t need to worry
    about this.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779881.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let’s specialize our `monster-show` and `monster-attack` functions for
    orcs. Notice these are defined in the same way as the earlier versions of these
    functions, except that we explicitly declare that these functions are orc-specific
    in the argument lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: The one unique thing about our `orc` type is that each orc has an `orc-club-level`
    field. These orc-specific versions of `monster-show` and `monster-attack` take
    this field into account. In the `monster-show` function, we display this club
    level ![](httpatomoreillycomsourcenostarchimages783564.png), so that the player
    can gauge the danger posed by each orc.
  prefs: []
  type: TYPE_NORMAL
- en: In the `monster-attack` function, we use the level of the club to decide how
    badly the player is hit by the club ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: The Malicious Hydra
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779984.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The hydra is a very nasty enemy. It will attack you with its many heads, which
    you’ll need to chop off to defeat it. The hydra’s special power is that it can
    grow a new head during each round of battle, which means you want to defeat it
    as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: The code for handling the hydra is similar to the code for handling the orc.
    The main difference is that a hydra’s health also acts as a stand-in for the number
    of hydra heads. In other words, a hydra with three health points will have three
    heads, as well. Therefore, when we write our hydra-specific `monster-show` function,
    we use the monster’s health to print a pretty message about the number of heads
    on the hydra ![](httpatomoreillycomsourcenostarchimages783564.png).
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between the orc and the hydra is that an orc doesn’t do anything
    particularly interesting when it is hit by the player. Because of this, we didn’t
    need to write a custom `monster-hit` function for the orc; the orc simply used
    the generic `monster-hit` function we created for a generic `monster`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A hydra, on the other hand, does something interesting when it is hit: It loses
    heads! We therefore create a hydra-specific `monster-hit` function, where heads
    are removed with every blow, which amounts to lowering the hydra’s health ![](httpatomoreillycomsourcenostarchimages783562.png).
    Also, we can now print a dramatic message about how the knight lopped off said
    heads ![](httpatomoreillycomsourcenostarchimages783560.png).'
  prefs: []
  type: TYPE_NORMAL
- en: The hydra’s `monster-attack` function is again similar to that for the orc.
    The one interesting difference is that we increment the health with every attack,
    so that the hydra grows a new head every turn ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: The Slimy Slime Mold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The slime mold is a unique monster. When it attacks you, it will wrap itself
    around your legs and immobilize you, letting the other bad guys finish you off.
    It can also squirt goo in your face. You must think quickly in battle to decide
    if it’s better to finish the slime off early in order to maintain your agility,
    or ignore it to focus on more vicious foes first. (Remember that by lowering your
    agility, the slime mold will decrease the number of attacks you can deliver in
    later rounds of battle.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780752.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: The `monster-attack` function for the slime mold must do some special things,
    which allow it to immobilize the player. First, it uses the slime mold’s sliminess
    (which is generated when each slime mold is built) to generate a random attack
    against the player, stored in the variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Unlike most other attacks in the game, this slime mold attack affects the agility
    of players, rather than their health ![](httpatomoreillycomsourcenostarchimages783562.png).
  prefs: []
  type: TYPE_NORMAL
- en: However, it would be pointless if the slime mold couldn’t attack the player’s
    health at least a little, or the battle could end awkwardly, with the player and
    slime mold frozen in place for all time. Therefore, the slime mold also has a
    superwimpy squirt attack that happens during half of all attacks ![](httpatomoreillycomsourcenostarchimages783560.png),
    but subtracts only a single health point from the player ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: The Cunning Brigand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The brigand is the smartest of all your foes. He can use his whip or slingshot
    and will try to neutralize your best assets. His attacks are not powerful, but
    they are a consistent two points for every round.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781748.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing the wily brigand does when performing an attack is to look at
    the player’s health, agility, and strength, and choose the `max` of those three
    as the focus of his attack ![](httpatomoreillycomsourcenostarchimages783564.png).
    If several of the attributes are equally large, the brigand will choose health
    over agility and agility over strength as the focus of attack. If health is the
    largest value, the player is hit with a slingshot ![](httpatomoreillycomsourcenostarchimages783562.png).
    If agility is the largest, the brigand will whip the player’s leg ![](httpatomoreillycomsourcenostarchimages783560.png).
    If strength is the largest, the brigand will whip the player’s arm ![](httpatomoreillycomsourcenostarchimages783554.png).
  prefs: []
  type: TYPE_NORMAL
- en: We have now completely defined all of our monsters for our game!
  prefs: []
  type: TYPE_NORMAL
- en: To Battle!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the game, call `orc-battle` from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'That hydra with seven heads looks pretty gnarly—let’s finish it off first with
    a stab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'No other bad guy really stands out, so we’ll try a roundhouse to bring down
    some of those health numbers overall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! That even killed one of the weaker enemies. Now, with full agility,
    we have three attacks per round. This means we should use our last attack to strategically
    take out some of the more powerful bad guys. Let’s use the double swing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: They got us pretty good, but we still have plenty of fight left. This battle
    isn’t over yet!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, careful strategy is needed if you want to survive Orc Battle.
    I hope you enjoy this new game!
  prefs: []
  type: TYPE_NORMAL
- en: What You've Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the more advanced data structures in Common Lisp.
    We then used this to create a monster-fighting game. Along the way, you learned
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are similar to lists, but allow you to access an item at a specific offset
    more efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables are similar to alists, but let you look up the value associated
    with a key more efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using arrays and hash tables in the appropriate places will usually make your
    code much faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only true way to tell if changing a data structure or algorithm makes your
    program faster is to time your code with the `time` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Lisp has generic functions that can be used against multiple datatypes.
    The most useful of these are sequence functions that can transparently handle
    lists, arrays, and strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create objects with properties in list using the `defstruct` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
