<html><head></head><body><div class="part" title="Part&#xA0;III-2.&#xA0;NETWORK FILE AND RESOURCE SHARING PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="network_file_and_resource_sharing_protoc"/>Part III-2. NETWORK FILE AND RESOURCE SHARING PROTOCOLS</h1></div></div></div><div class="partintro" id="id3312905" title="NETWORK FILE AND RESOURCE SHARING PROTOCOLS"><div/><p><a class="xref" href="ch58.html" title="Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM (NFS)">Chapter 58</a></p><p>To the typical end user, networks were created for one main reason: to permit the sharing of information. Most information on computers exists in the form of files that reside on storage devices such as hard disks; thus, one primary purpose of networks is to let users share files. File transfer and message transfer protocols allow users to manually move files from one place to the next, but a more automated method is preferable in many cases. Internetworking protocols provide such capabilities in the form of <span class="emphasis"><em>network file and resource sharing protocols</em></span>.</p><p>In this brief part, I describe network file and resource sharing protocols from the standpoint of TCP/IP networks. The one chapter here provides an overview of the concepts and operation of this class of protocols, discussing some of the elements common to the different types. It then describes the most common one defined specifically for TCP/IP: the Network File System (NFS).</p><p>Obviously, network file and resource sharing protocols and services are closely related to the file and message transfer protocols I mentioned earlier. For example, NFS can be used to accomplish tasks similar to those performed by TCP/IP file and message transfer applications such as the File Transfer Protocol (FTP) and the Hypertext Transfer Protocol (HTTP). I consider those protocols more like specific end-user applications unto themselves, and therefore describe them in later parts on application protocols (FTP in <a class="xref" href="pt17.html" title="Part III-6. TCP/IP GENERAL FILE TRANSFER PROTOCOLS">Part III-6</a> and HTTP in <a class="xref" href="pt19.html" title="Part III-8. TCP/IP WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)">Part III-8</a>). I realize that this distinction between manual and automatic file transfer is somewhat arbitrary, but then, so are a lot of other things in the great world of networking.</p></div></div>
<div class="chapter" title="Chapter&#xA0;58.&#xA0;NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM (NFS)"><div class="titlepage"><div><div><h1 class="title"><a id="network_file_and_resource_sharing_and_th"/>Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM (NFS)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e61575"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> File and resource sharing protocols are important because they let users seamlessly share files over a network. Due to the dominance of Microsoft operating systems in the industry, many people are familiar with the way Microsoft networking can be used in this way. However, Microsoft is somewhat of a "Johnny come lately" to file sharing protocols. Long before Microsoft Windows even existed, the <span class="emphasis"><em>Network File System (NFS)</em></span><a class="indexterm" id="idx-CHP-58-2128"/> was letting users share files over a network using the UNIX operating system.</p><p>In this chapter, I provide a brief look at <a class="indexterm" id="idx-CHP-58-2129"/>network file and resource sharing in TCP/IP, with a focus on the operation of NFS. I begin with a general look at file and resource sharing protocol concepts. Then I provide an overview and history of NFS, and discuss its common versions and standards. I describe the architecture of NFS and the three components that compose it. I then describe the NFS file system model and how data is encoded using the <span class="emphasis"><em>External Data Representation (XDR)</em></span> standard. I explain the client/server operation of NFS using <span class="emphasis"><em>Remote Procedure Calls (RPCs)</em></span>. I then list the procedures and operations used in NFS, and conclude with a description of the separate NFS Mount protocol, used to attach network resources to a device.</p><div class="sect1" title="File and Resource Sharing Concepts and Components"><div class="titlepage"><div><div><h1 class="title"><a id="file_and_resource_sharing_concepts_and_c"/>File and Resource Sharing Concepts and Components</h1></div></div></div><p>A primary reason why networks and internetworks are created is to allow files and other resources to be shared among computers. Thus, in any internetworking protocol stack, we need some mechanism by which users can easily move files across a network in a simple way. Application layer file and message transfer protocols like the File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP) were created for just this purpose: to let users access resources across a network while hiding the details of how the network operates at the layers below them.</p><p>However, even though these protocols hide the lower layers, they are somewhat <span class="emphasis"><em>manual</em></span> in nature. They require a user to invoke an application protocol and use specific commands that accomplish network-based resource access. In fact, the problem with such protocols isn't so much that they require manual intervention, but that they make sharing more difficult because they don't allow a file to be used directly on another resource.</p><p>Consider a protocol like FTP. It does lets you share files between machines, but it draws a clear distinction between a file that is yours and a file that is someone else's. If you want to use a file on Joe's machine, you must transfer it to your machine, use it, and then transfer it back. Also, if you don't transfer the file back, Joe might never even see the updated version.</p><div class="sect2" title="The Power of File and Resource Sharing Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="the_power_of_file_and_resource_sharing_p"/>The Power of File and Resource Sharing Protocols</h2></div></div></div><p>The ultimate in file and resource sharing is achieved when we can hide even the details of where the files are located and the commands required to move them around. Such a system would use an <span class="emphasis"><em>automatic</em></span> sharing protocol that lets files and resources be used over a network seamlessly. Once set up, a network resource in such a scheme can be used in much the same way that one on a local computer is. Such protocols are sometimes called <span class="emphasis"><em>network file and resource sharing protocols</em></span>.</p><p>It is this blurring of the line between a local file and a remote one that makes file and resource sharing protocols so powerful. Once the system is set up, users can access resources on another host as readily as on their own host. This is an extremely useful capability, especially in the modern era of client/server computing. For example, it allows a company to store information that is used by many individuals in a common place, such as in a directory on a server, where each of those individuals can access it. In essence, there is a virtual file system that spans network devices, instead of being simply on one storage device on a single computer.</p></div><div class="sect2" title="Components of a File and Resource Sharing Protocol"><div class="titlepage"><div><div><h2 class="title"><a id="components_of_a_file_and_resource_sharin"/>Components of a File and Resource Sharing Protocol</h2></div></div></div><p>File and transfer protocols allow users to share files effortlessly, but that doesn't mean no work is involved. The work is still there, but it's shouldered by those who write the protocol and those who administer its operation. Generally speaking, these protocols require at least the following general components:</p><p><span class="strong"><strong>File System Model and Architecture</strong></span> A mechanism for defining resources and files to be shared, and for describing how the virtual file system works.</p><p><span class="strong"><strong>Resource Access Method</strong></span> Procedures that describe how users can attach or detach a distant resource from their local host.</p><p><span class="strong"><strong>Operation Set</strong></span> A set of operations for accomplishing various tasks that the users need to perform on files on other hosts.</p><p><span class="strong"><strong>Messaging Protocol</strong></span> Message formats that carry operations to be performed, status information, and more, and a protocol for exchanging these messages between devices.</p><p><span class="strong"><strong>Administrative Tools</strong></span> Miscellaneous functionality needed to support the operation of the protocol and tie the other elements together.</p></div></div></div>
<div class="sect1" title="NFS Design Goals, Versions, and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="nfs_design_goals_versions_and_standards"/>NFS Design Goals, Versions, and Standards</h1></div></div></div><p><a class="indexterm" id="idx-CHP-58-2130"/>The histories of TCP/IP and the Internet are inextricably linked, as I discussed in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>. However, there is a third partner that is less often mentioned but very much part of the development history of these technologies. That is the operating system that ran on the machines in the early Internet and is still used on a large percentage of Internet servers today: the <span class="emphasis"><em>UNIX</em></span> operating system.</p><p>Sun Microsystems was one of the early pioneers in the development of UNIX and in TCP/IP networking. Early in the evolution of TCP/IP, certain tools were created to allow a user to access another machine over the network—after all, this is arguably the entire point of networking. Remote-access protocols such as Telnet allowed a user to log in to another host computer and use resources there. FTP allowed people to copy a file from a distant machine to their own and edit it. However, neither of these solutions really fit the bill of allowing a user to access a file on a remote machine in a way similar to how a local file is used. To fill this need, Sun created the <span class="emphasis"><em>Network File System (NFS)</em></span>.</p><div class="sect2" title="NFS Design Goals"><div class="titlepage"><div><div><h2 class="title"><a id="nfs_design_goals"/>NFS Design Goals</h2></div></div></div><p>NFS was specifically designed with the goal of eliminating the distinction between a local and a remote file. To a user, after the appropriate setup is performed, a file on a remote computer can be used as if it were on a hard disk on the user's local machine. Sun also crafted NFS specifically to be vendor-independent, to ensure that both hardware made by Sun and that made by other companies could interoperate.</p><p>One of the most important design goals of NFS was performance. Obviously, even if you set up a file on a distant machine as if it were local, the actual read and write operations must travel across a network. Usually, this takes more time than simply sending data within a computer, so the protocol itself needed to be as lean and mean as possible. This decision led to some interesting choices, such as the use of the unreliable User Datagram Protocol (UDP) for transport in TCP/IP, instead of the reliable Transmission Control Protocol (TCP), as with most file transfer protocols. This, in turn, has interesting implications on how the protocol works as a whole.</p><p>Another key design goal for NFS was simplicity (which of course is related to performance). NFS servers are said to be <span class="emphasis"><em>stateless</em></span>, which means that the protocol is designed so that servers do not need to keep track of which files have been opened by which clients. This allows requests to be made independently of each other, and allows a server to gracefully deal with events such as crashes without the need for complex recovery procedures.</p><p>The protocol is also designed so that if requests are lost or duplicated, file corruption will not occur.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-352"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Network File System (NFS)</em></span> was created to allow client hosts to access files on remote servers as if they were local. It was designed primarily with the goals of performance, simplicity, and cross-vendor compatibility.</p></div></div><div class="sect2" title="NFS Versions and Standards"><div class="titlepage"><div><div><h2 class="title"><a id="nfs_versions_and_standards"/>NFS Versions and Standards</h2></div></div></div><p><a class="indexterm" id="idx-CHP-58-2131"/><a class="indexterm" id="idx-CHP-58-2132"/>Since it was initially designed and marketed by Sun, NFS began as a de facto standard. The first widespread version of NFS was version 2 (NFSv2), and this is still the most common version of the protocol. NFSv2 was eventually codified as an official TCP/IP standard when RFC 1094, "NFS: Network File System Protocol Specification," was published in 1989.</p><p>NFS version 3 (NFSv3) was subsequently developed, and it was published in 1995 as RFC 1813, "NFS Version 3 Protocol Specification." It is similar to NFSv2, but makes a few changes and adds some new capabilities. These include support for larger files and file transfers, better support for setting file attributes, and several new file access and manipulation procedures.</p><p>NFS version 4 (NFSv4) was published in 2000 as RFC 3010, "NFS Version 4 Protocol." Where NFSv3 contained only relatively small changes to the previous version, NFSv4 is virtually a rewrite of NFS. It includes numerous changes, most notably the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Reflecting the needs of modern internetworking, NFSv4 puts greater emphasis on security.</p></li><li class="listitem"><p>NFSv4 introduces the concept of a <span class="emphasis"><em>compound</em></span> procedure, which allows several simpler procedures to be sent from a client to a server as a group.</p></li><li class="listitem"><p>NFSv4 almost doubles the number of individual procedures that a client can use in accessing a file on an NFS server.</p></li><li class="listitem"><p>NFSv4 makes a significant change in messaging, with the specification of TCP as the transport protocol for NFS.</p></li><li class="listitem"><p>NFSv4 integrates the functions of the Mount protocol into the basic NFS protocol, eliminating it as a separate protocol as it is in previous versions.</p></li></ul></div><p>The <a class="indexterm" id="idx-CHP-58-2133"/>NFSv4 standard also has a lot more details about implementation and optional features than the earlier standards—it's 275 pages long. So much for simplicity! RFC 3010 was later updated by RFC 3530, "Network File System (NFS) Version 4 Protocol," in April 2003. This standard makes several further revisions and clarifications to the operation of NFSv4.</p></div></div>
<div class="sect1" title="NFS Architecture and Components"><div class="titlepage"><div><div><h1 class="title"><a id="nfs_architecture_and_components"/>NFS Architecture and Components</h1></div></div></div><p><a class="indexterm" id="idx-CHP-58-2134"/>NFS follows the classic TCP/IP client/server model of operation. A hard disk or a directory on a storage device of a particular computer can be set up by an administrator as a shared resource. This resource can then be accessed by client computers, which <span class="emphasis"><em>mount</em></span> the shared drive or directory, causing it to appear as if it were a local directory on the client machine. Some computers may act as only servers or only clients; others may be both, sharing some of their own resources and accessing resources provided by others.</p><p>Considered from the perspective of the TCP/IP protocol suite as a whole, NFS is a single protocol that resides at the application layer of the TCP/IP (DOD) model (described in <a class="xref" href="ch08.html" title="Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE">Chapter 8</a>). This TCP/IP layer encompasses the session, presentation, and application layers of the OSI Reference Model (described in <a class="xref" href="ch06.html" title="Chapter 6. OSI REFERENCE MODEL LAYERS">Chapter 6</a>). As I have said before in this book, I don't see much value in trying to differentiate between layers 5 through 7 most of the time. In some situations, however, these layers can be helpful in understanding the architecture of a protocol, and that's the case with NFS.</p><div class="sect2" title="NFS Main Components"><div class="titlepage"><div><div><h2 class="title"><a id="nfs_main_components"/>NFS Main Components</h2></div></div></div><p><a class="indexterm" id="idx-CHP-58-2135"/>The operation of NFS is defined in the form of three main components that can be viewed as logically residing at each of the three OSI model layers corresponding to the TCP/IP application layer, as illustrated in <a class="xref" href="ch58s03.html#nfs_architectural_components" title="Figure 58-1. NFS architectural components">Figure 58-1</a>:</p><p><span class="strong"><strong>Remote Procedure Call (RPC)</strong></span> RPC is a generic session layer service used to implement client/server internetworking functionality. It extends the notion of a program calling a local procedure on a particular host computer to the calling of a procedure on a remote device across a network.</p><p><span class="strong"><strong>External Data Representation (XDR)</strong></span> XDR is a descriptive language that allows data types to be defined in a consistent manner. XDR conceptually resides at the presentation layer. Its universal representations allow data to be exchanged using NFS between computers that may use very different internal methods of storing data.</p><p><span class="strong"><strong>NFS Procedures and Operations</strong></span> The actual functionality of NFS is implemented in the form of procedures and operations that conceptually function at layer 7 of the OSI model. These procedures specify particular tasks to be carried out on files over the network, using XDR to represent data and RPC to carry the commands across an internetwork.</p><p>These three key "subprotocols," if you will, compose the bulk of the NFS protocol. Each is described in more detail in a separate section in this chapter.</p><div class="figure"><a id="nfs_architectural_components"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e61785"/><img alt="NFS architectural components" src="httpatomoreillycomsourcenostarchimages288191.png.jpg"/></div></div><p class="title">Figure 58-1. NFS architectural components</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-353"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> NFS resides architecturally at the TCP/IP application layer. Even though in the TCP/IP model no clear distinction is made generally between the functions of layers 5 through 7 of the OSI Reference Model, NFS's three subprotocols correspond well to those three layers as shown.NFS resides architecturally at the application layer of the TCP/IP model. Its functions are implemented primarily through three distinct functional components that implement the functions of layers 5 through 7 of the OSI Reference Model: the <span class="emphasis"><em>Remote Procedure Call (RPC)</em></span>, which provide session-layer services; the <span class="emphasis"><em>External Data Representation (XDR)</em></span> standard, which manages data representation and conversion; and <span class="emphasis"><em>NFS procedures and operations</em></span>, which allow application layer tasks to be performed using the other two components.</p></div></div><div class="sect2" title="Other Important NFS Functions"><div class="titlepage"><div><div><h2 class="title"><a id="other_important_nfs_functions"/>Other Important NFS Functions</h2></div></div></div><p>Aside from it three main components, the NFS protocol as a whole involves a number of other functions, most notably the following:</p><p><span class="strong"><strong>Mount Protocol</strong></span> A specific decision was made by the creators of NFS to not have NFS deal with the particulars of file opening and closing. Instead, a separate protocol called the <span class="emphasis"><em>Mount</em></span> protocol is used for this purpose. Accessing a file or other resource over the network involves first <span class="emphasis"><em>mounting</em></span> it using this protocol. The Mount protocol is architecturally distinct, but obviously closely related to NFS, and is even defined in an appendix of the NFS standard. I describe it in the last section in this chapter. (Note that in NFSv4, the functions of the Mount protocol have been incorporated into NFS proper.)</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-58-2136"/>NFS File System Model</strong></span> NFS uses a particular model to implement the directory and file structure of the systems that use it. This model is closely based on the file system model of UNIX, but is not specific to only that operating system. It is discussed in conjunction with the explanation of the Mount protocol at the end of this chapter.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-58-2137"/>Security</strong></span> Versions 2 and 3 of NFS include only limited security provisions. They use UNIX-style authentication to check permissions for various operations. NFSv4 greatly increases the security options available for NFS implementations. These include provisions for multiple authentication and encryption algorithms, and many changes to the protocol as a whole to make it more secure.</p></div></div>
<div class="sect1" title="NFS Data Definition with the External Data Representation (XDR) Standard"><div class="titlepage"><div><div><h1 class="title"><a id="nfs_data_definition_with_the_external_da"/>NFS Data Definition with the External Data Representation (XDR) Standard</h1></div></div></div><p><a class="indexterm" id="idx-CHP-58-2138"/><a class="indexterm" id="idx-CHP-58-2139"/>The overall idea behind NFS is to allow you to read from or write to a file on another computer as readily as you do on your local machine. Of course, the files on your local machine are all stored in the same file system, using the same file structure and the same means of representing different types of data. You can't be sure that this will be the case when accessing a remote device, and this creates a bit of a Tower of Babel problem.</p><p>One approach would be to simply restrict access only to remote files on machines that use the same operating system. However, this would remove much of the effectiveness of NFS. It would also be highly impractical to require every computer to understand the internal representation of every other one. A more general method is needed to allow even very dissimilar machines to share data. To this end, the creators of NFS defined NFS so that it deals with data using a universal data description language. This language is called the <span class="emphasis"><em>External Data Representation (XDR)</em></span><a class="indexterm" id="idx-CHP-58-2140"/> standard and was originally described in RFC 1014. It was updated in RFC 1832, "<a class="indexterm" id="idx-CHP-58-2141"/>XDR: External Data Representation Standard," in 1995.</p><div class="sect2" title="A Method of Universal Data Exchange: XDR"><div class="titlepage"><div><div><h2 class="title"><a id="a_method_of_universal_data_exchange_xdr"/>A Method of Universal Data Exchange: XDR</h2></div></div></div><p>The idea behind XDR is simple, and it can be easily understood in the form of an analogy. If you had delegates speaking 50 different languages at a convention, they would have a hard time communicating. You could hire translators to facilitate, but you would never find translators to handle all the different possible combinations of languages. A more practical solution is to declare one language, such as English, to be a common language. You then need only 49 translators: one to translate from English to each of the non-English languages and back again. To translate from Swedish to Portuguese, you translate from Swedish to English and then from English to Portuguese. The common language could be French, Spanish, or something else, as long as a translator could be found from all the other languages.</p><p>XDR works in the same manner. When information about how to access a file is to be transferred from Device A to Device B, Device A first converts it from Device A's internal representation to the XDR representation of those data types. The information is transmitted across the network using XDR encoding. Then Device B translates from XDR back to its own internal representation, so it can be presented to the user as if it were on the local file system. Each device needs to know only how to convert from its own language to XDR and back again; Device A doesn't need to know Device B's internal details and vice versa. This sort of translation is a classic job of the presentation layer, which is where XDR resides in the OSI Reference Model. XDR is itself based on an International Organization for Standardization (ISO) standard called "Abstract Syntax Notation."</p><div class="note" title="Note"><h3 class="title"><a id="note-141"/>Note</h3><p><span class="emphasis"><em>The idea behind XDR is also used in other protocols to allow the exchange of data independent of the nature of the underlying systems. For example, a similar idea is behind the way management information is exchanged using the Simple Network Management Protocol (SNMP), which is described in <a class="xref" href="ch66.html" title="Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)">Chapter 66</a>. The same basic idea underlies the important Network Virtual Terminal (NVT) paradigm used in the Telnet protocol, which is described in <a class="xref" href="ch87.html" title="Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS">Chapter 87</a></em></span>.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-354"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The purpose of the <span class="emphasis"><em>External Data Representation (XDR)</em></span> standard is to define a common method for representing common <a class="indexterm" id="idx-CHP-58-2142"/>data types. Using this universal representation, data can be exchanged between devices, regardless of what internal file system each uses. This enables NFS to exchange file data between clients and servers that may be implemented using very different hardware and software platforms.</p></div></div><div class="sect2" title="XDR Data Types"><div class="titlepage"><div><div><h2 class="title"><a id="xdr_data_types"/>XDR Data Types</h2></div></div></div><p><a class="indexterm" id="idx-CHP-58-2143"/>For XDR to be universal, it must allow the description of all the common types of data that are used in computers. For example, it must allow integers, floating-point numbers, strings, and other data constructs to be exchanged. The XDR standard describes the structure of many <a class="indexterm" id="idx-CHP-58-2144"/>data types using a notation somewhat similar to the C programming language. As you may know, this is one of the most popular languages in computing history, and it is closely associated with UNIX (and thus, certain TCP/IP technologies as well).</p><p><a class="xref" href="ch58s04.html#nfs_external_data_representation_xdr_dat" title="Table 58-1. NFS External Data Representation (XDR) Data Types">Table 58-1</a> shows the <a class="indexterm" id="idx-CHP-58-2145"/>data types defined by XDR, which can be used by NFS in exchanging data between the client and server. For each, I have included the data type code, its size in bytes, and a brief description.</p><div class="table"><a id="nfs_external_data_representation_xdr_dat"/><p class="title">Table 58-1. NFS External Data Representation (XDR) Data Types</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="NFS External Data Representation (XDR) Data Types"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data Type Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>int</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Signed integer: A 32-bit signed integer in two's complement notation, capable of holding a value from -2,147,483,648 to +2,147,483,647.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>unsigned int</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unsigned integer: A 32-bit unsigned integer, from 0 to 4,294,967,295.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>enum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Enumeration: An alternate way of expressing a signed integer where some of the integer values are used to stand for particular constant values. For example, you could represent the colors of the rainbow, by defining the value 1 to stand for PURPLE, 2 to stand for BLUE, and so on.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>bool</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Boolean: A logical representation of an integer, analogous to a two-level enumeration where a value of 0 is defined as FALSE and 1 is TRUE.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>hyper</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Signed hyper integer: Same as a regular signed integer, but 8 bytes wide to allow much larger numbers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>unsigned hyper</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Unsigned hyper integer: Same as a regular unsigned integer but 8 bytes wide to allow much larger numbers.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>float</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Floating-point number: A 32-bit signed floating-point number. 1 bit holds the sign (positive or negative), 8 bits hold the exponent (power), in base 2, and 23 bits hold the mantissa (fractional part of the number).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>double</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Double-precision floating-point number: The same as float but with more bits to allow greater precision. 1 bit is for the sign, 11 bits for the exponent, and 52 bits for the mantissa.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>quadruple</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Quadruple-precision floating-point number: The same as float and double but with still more bits to allow greater precision. 1 bit is for the sign, 15 bits for the exponent, and 112 bits for the mantissa.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>opaque</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Opaque data: Data that is to be passed between devices without being given a specific representation using XDR. The term <span class="emphasis"><em>opaque</em></span> means that the data is treated like a "black box" whose insides cannot be seen. Obviously, any machines using this data type must themselves know how to deal with it, since NFS does not.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>string</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>String: A variable-length string of ASCII characters.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(array)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Arrays: A group of any single type of the elements above, such as integers, floating-point numbers, and so on, may be specified in an array to allow many to be referenced as a single unit. They are not indicated using a separate data type code.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>struct</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Structure: An arbitrary structure containing other data elements from this table. This allows the definition of complex data types.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>union</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Discriminated union: A complex data type where a code value called a "discriminant" is used to determine the nature of the rest of the structure. See section 3.14 of RFC 1014 for details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>void</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>Void: A null data type that contains nothing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>const</p></td><td style="border-right: 0.5pt solid ; "><p>0</p></td><td style=""><p>Constant: A constant value used in other representations.</p></td></tr></tbody></table></div></div><p>As you can see, XDR provides considerable data description capabilities. If you know the C language, much of what is in <a class="xref" href="ch58s04.html#nfs_external_data_representation_xdr_dat" title="Table 58-1. NFS External Data Representation (XDR) Data Types">Table 58-1</a> is probably familiar to you. Unfortunately, I can't really describe many of the more complex data types without turning this into a guide to C programming.</p><p>XDR also provides a means of defining new data types and a method for specifying optional data. This offers even more flexibility beyond the large number of specific types already specifically described. Each version of NFS has a slightly different list of data types it supports.</p></div></div>
<div class="sect1" title="NFS Client/Server Operation Using Remote Procedure Calls (RPCs)"><div class="titlepage"><div><div><h1 class="title"><a id="nfs_clientserver_operation_using_remote_"/>NFS Client/Server Operation Using Remote Procedure Calls (RPCs)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-58-2146"/><a class="indexterm" id="idx-CHP-58-2147"/>Almost all applications deal with files and other resources. When a software program on a particular computer wants to read a file, write a file, or perform related tasks, it needs to use the correct software instructions for this purpose. It would be inefficient to require each software program to contain a copy of these instructions, so instead, they are encoded as standardized software modules, sometimes called <span class="emphasis"><em>procedures</em></span>. To perform an action, a piece of software <span class="emphasis"><em>calls</em></span> the procedure. The procedure temporarily takes over for the main program and performs a task such as reading or writing data. The procedure then returns control of the program back to the software that called it, and optionally, returns data as well.</p><p>Since the key concept of NFS was to make remote file access look like local file access, it was designed around the use of a network-based version of this procedure calling method. A software application that wants to do something with a file still makes a procedure call, but it makes the call to a procedure on a different computer instead of the local one. A special set of routines is used to handle the transmission of the call across the network, in a way largely invisible to software performing the call.</p><p>This functionality could have been implemented directly in NFS, but instead Sun created a separate session-layer protocol component called the <span class="emphasis"><em>Remote Procedure Call (RPC)</em></span> specification, which defines how this works. RPC was originally created as a subcomponent of NFS, but it is generic enough and useful enough that it has been used for other client/server applications in TCP/IP. For this reason, it is really considered in many respects a distinct protocol.</p><p>Because RPC is the actual process of communicating in NFS, NFS itself is different from many other TCP/IP protocols. Its operation can't be described in terms of specific message exchanges and state diagrams the way a protocol like HTTP or the Dynamic Host Configuration Protocol (DHCP), or even TCP can, because RPC does all of that. NFS is defined in terms of a set of RPC server procedures and operations that an NFS server makes available to NFS clients. These procedures and operations each allow a particular type of action to be taken on a file, such as reading from it, writing to it, or deleting it.</p><div class="sect2" title="RPC Operation and Transport Protocol Usage"><div class="titlepage"><div><div><h2 class="title"><a id="rpc_operation_and_transport_protocol_usa"/>RPC Operation and Transport Protocol Usage</h2></div></div></div><p>When a client wants to perform some type of action on a file on a particular machine, it uses RPC to make a call to the NFS server on that machine. The server accepts the request and performs the action required, then returns a result code and possibly data back to the client, depending on the request. The result code indicates if the action was successful. If it was, the client can assume that whatever it asked to be done was completed. For example, in the case of writing data, the client can assume the data has been successfully written to long-term storage.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-355"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> NFS does not use a dedicated message format, like most other protocols do. Instead, clients and servers use the <span class="emphasis"><em>Remote Procedure Call (RPC)</em></span> protocol to exchange file operation requests and data.</p></div><p>NFS can operate over any transport mechanism that has a valid RPC implementation at the session layer. NFS has seen an evolution of sorts in its use of transport protocol. The NFSv2 standard says that it operates normally using UDP, and this is still a common way that NFS information is carried. NFSv3 says that either UDP or TCP may be used, but NFSv4 specifies TCP to carry data. The nominal registered port number for use by NFS is 2049, but other port numbers are sometimes used for NFS, through the use of RPC's <a class="indexterm" id="idx-CHP-58-2148"/><span class="emphasis"><em>port mapper</em></span> capability.</p></div><div class="sect2" title="Client and Server Responsibilities in NFS"><div class="titlepage"><div><div><h2 class="title"><a id="client_and_server_responsibilities_in_nf"/>Client and Server Responsibilities in NFS</h2></div></div></div><p>Since UDP is unreliable, the use of that protocol to transport important information may seem strange. For example, we obviously don't want data that we are trying to write to a file to be lost in transit. Remember, however, that UDP doesn't preclude the use of measures to ensure reliable communications; it simply doesn't provide those capabilities itself. UDP can be used by <a class="indexterm" id="idx-CHP-58-2149"/>NFS because the protocol itself is designed to tolerate loss of transmitted data and to recover from it.</p><p>Consistent with this concept, the general design of NFS puts most of the responsibility for implementing the protocol on the client, not the server. As the NFSv3 standard says, "NFS servers are dumb, and NFS clients are smart." What this means is that the servers focus only on responding to requests, while clients must take care of most of the nitty-gritty details of the protocol, including recovery from failed communications. This is a common requirement when UDP is used, because if a client request is lost in transit, the server has no way of knowing that it was ever sent.</p><p>As mentioned in the NFS overview earlier in this chapter, NFS servers are designed to be stateless. In simplified terms, this means that the NFS server does not keep track of the state of the clients using it from one request to another. Each request is independent of the previous one, and the server in essence has no memory of what it did before when it gets a new command from a client. This again requires more intelligence to be put into the clients, but has the important advantage of simplifying recovery in the case that the server crashes. Since there is nothing that the server was keeping track of for the client, there's nothing that can be lost. This is an important part of ensuring that files are not damaged as a result of network problems or congestion.</p></div><div class="sect2" title="Client and Server Caching"><div class="titlepage"><div><div><h2 class="title"><a id="client_and_server_caching"/>Client and Server Caching</h2></div></div></div><p><a class="indexterm" id="idx-CHP-58-2150"/><a class="indexterm" id="idx-CHP-58-2151"/>Both NFS clients and servers can make use of caching to improve performance. Servers may use caching to store recently requested information in case it is needed again. They may also use <span class="emphasis"><em>predictive</em></span> caching, sometimes called <span class="emphasis"><em>prefetching</em></span>. In this technique, a server that receives a request to read a block of data from a file may load into memory the next block after it, on the theory that it will likely be requested next.</p><p>Client-side caching is used to satisfy repeat NFS requests from applications while avoiding additional RPC calls. Like almost everything else about NFS, caching is implemented much more thoroughly in NFSv4 than in the previous versions.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-356"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> NFS is designed to be a stateless protocol, with intelligent clients and relatively dumb servers that respond to requests and do not maintain status information about what files are in use. NFS was originally designed to use UDP for transport, for efficiency purposes. This requires that NFS clients take care of detecting lost requests and retransmitting them. NFSv4 uses TCP to take advantage of TCP's reliability and other features.</p></div></div></div>
<div class="sect1" title="NFS Server Procedures and Operations"><div class="titlepage"><div><div><h1 class="title"><a id="nfs_server_procedures_and_operations"/>NFS Server Procedures and Operations</h1></div></div></div><p>The actual exchange of information between an NFS client and server is performed by the underlying RPC protocol. NFS functionality is therefore described not in terms of specific protocol operations, but by delineating the different actions that a client may take on files residing on a server. In the original version of NFS, NFSv2, these are called NFS <span class="emphasis"><em>server procedures</em></span><a class="indexterm" id="idx-CHP-58-2152"/>.</p><p>Each procedure represents a particular action that a client may perform, such as reading from a file, writing to a file, or creating or removing a directory. The operations performed on the file require that the file be referenced using a data structure called a <span class="emphasis"><em>file handle</em></span>. As the name suggests, the file handle, like the handle of a real object, lets the client and server "grasp" the file. The Mount protocol, described later in this chapter, is used to mount a file system, to enable a file handle to be accessed for use by NFS procedures.</p><p>NFSv3 uses the same basic model for <a class="indexterm" id="idx-CHP-58-2153"/>server procedures, but makes certain changes. Two of the NFSv2 procedures were removed, and several new ones added to support new functionality. The numbers assigned to identify each procedure were also changed.</p><div class="sect2" title="NFS Version 2 and Version 3 Server Procedures"><div class="titlepage"><div><div><h2 class="title"><a id="nfs_version_2_and_version_3_server_proce"/>NFS Version 2 and Version 3 Server Procedures</h2></div></div></div><p><a class="indexterm" id="idx-CHP-58-2154"/><a class="xref" href="ch58s06.html#nfs_version__and_version__server_procedu" title="Table 58-2. NFS Version 2 and Version 3 Server Procedures">Table 58-2</a> shows the server procedures defined in versions 2 and 3 of NFS. The table shows the procedure numbers for both NFSv2 and NFSv3, as well as the name of each procedure and a description of what it does. I have kept the descriptions short so the table can serve as a useful summary of what NFS can do. They are listed in order of the procedure number used in NFSv2.</p><div class="table"><a id="nfs_version__and_version__server_procedu"/><p class="title">Table 58-2. NFS Version 2 and Version 3 Server Procedures</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="NFS Version 2 and Version 3 Server Procedures"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-58-2155"/>Procedure No. (v2)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure No. (v3)</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure Summary</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>null</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Do nothing</p></td><td style="border-bottom: 0.5pt solid ; "><p>Dummy procedure provided for testing purposes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>getattr</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Get file attributes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retrieves the attributes of a file on a remote server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>setattr</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Set file attributes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets (changes) the attributes of a file on a remote server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>root</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Get file system root (obsolete)</p></td><td style="border-bottom: 0.5pt solid ; "><p>This procedure was originally defined to allow a client to find the root of a remote file system, but is now obsolete. This function is instead now implemented as part of the Mount protocol. It was removed in NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>lookup</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Look up filename</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns the file handle of a file for the client to use.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>readlink</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read from symbolic link</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reads the name of a file specified using a symbolic link.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>read</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read from rile</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reads data from a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>writecache</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Write to cache</p></td><td style="border-bottom: 0.5pt solid ; "><p>Proposed for future use in NFSv2 but abandoned and removed from NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>write</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Write to file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Writes data to a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>create</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a file on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>remove</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remove file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes a file from the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>rename</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Rename file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Changes the name of a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>link</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create link to file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a hard (nonsymbolic) link to a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>symlink</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create symbolic link</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a symbolic link to a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>mkdir</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a directory on the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>rmdir</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remove directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Deletes a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>readdir</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read from directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reads the contents of a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>statfs</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Get file system attributes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides to the client general information about the remote file system, including the size of the file system and the amount of free space remaining. In NFSv3, this was replaced by fsstat and fsinfo.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>access</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Check access permission</p></td><td style="border-bottom: 0.5pt solid ; "><p>Determines the access rights that a user has for a particular file system object. This is new in NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>mknod</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create a special device</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a special file such as a named pipe or device file. This is new in NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>readdirplus</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extended read from directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retrieves additional information from a directory. This is new in NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>fsstat</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Get dynamic file system information</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns volatile (dynamic) file system status information such as the current amount of file system free space and the number of free file slots. This is new in NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>19</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>fsinfo</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Get static file system information</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns static information about the file system, such as general data about how the file system is used and parameters for how requests to the server should be structured. This is new in NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>20</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>pathconf</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Retrieve POSIX information</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retrieves additional information for a file or directory. This is new in NFSv3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>21</p></td><td style="border-right: 0.5pt solid ; "><p>commit</p></td><td style="border-right: 0.5pt solid ; "><p>Commit cached data on a server to stable storage</p></td><td style=""><p>Flushes any data that the server is holding in a write cache to storage. This is used to ensure that any data that the client has sent to the server but that the server has held pending write to storage is written out. This is new in NFSv3.</p></td></tr></tbody></table></div></div><p>It is common that a client may want to perform multiple actions on a file, such as several consecutive reads. One of the problems with the server procedure system in NFSv2 and NFSv3 is that each client action required a separate procedure call. This was somewhat inefficient, especially when NFS was used over a high-latency link.</p></div><div class="sect2" title="NFS Version 4 Server Procedures and Operations"><div class="titlepage"><div><div><h2 class="title"><a id="nfs_version_4_server_procedures_and_oper"/>NFS Version 4 Server Procedures and Operations</h2></div></div></div><p>To improve the efficiency of server procedures, NFSv4 makes a significant change to the way that server procedures are implemented. Instead of each client action being a separate procedure, a single procedure, called a <span class="emphasis"><em>compound procedure</em></span>, is defined. Within this compound procedure, a large number of <span class="emphasis"><em>server operations</em></span> are encapsulated. These are all sent as a single unit, and the server interprets and follows the instructions in each operation in sequence.</p><p>This change means there are actually only two RPC procedures in NFSv4, as shown in <a class="xref" href="ch58s06.html#nfs_version__server_procedures" title="Table 58-3. NFS Version 4 Server Procedures">Table 58-3</a>.</p><div class="table"><a id="nfs_version__server_procedures"/><p class="title">Table 58-3. NFS Version 4 Server Procedures</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="NFS Version 4 Server Procedures"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-58-2156"/>Procedure Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure Summary</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>null</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Do nothing</p></td><td style="border-bottom: 0.5pt solid ; "><p>Dummy procedure provided for testing purposes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; "><p>compound</p></td><td style="border-right: 0.5pt solid ; "><p>Compound operations</p></td><td style=""><p>Combines a number of NFS operations into a single request.</p></td></tr></tbody></table></div></div><p>All the real client actions are defined as operations within the compound procedure, as shown in <a class="xref" href="ch58s06.html#nfs_version__server_operations" title="Table 58-4. NFS Version 4 Server Operations">Table 58-4</a>. You'll notice that the number of NFSv4 operations is much larger than the number of procedures in NFSv2 and NFSv3. This is due both to the added features in NSFv4 and the fact that it incorporates functions formerly performed by the separate Mount protocol.</p><div class="table"><a id="nfs_version__server_operations"/><p class="title">Table 58-4. NFS Version 4 Server Operations</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="NFS Version 4 Server Operations"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-58-2157"/>Operation Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Operation Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Operation Summary</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>access</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Check access rights</p></td><td style="border-bottom: 0.5pt solid ; "><p>Determines the access rights a user has for an object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>close</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Close file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Closes a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>commit</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Commit cached data</p></td><td style="border-bottom: 0.5pt solid ; "><p>Flushes any data that the server is holding in a write cache to storage, to ensure that any pending data is permanently recorded.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>create</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create a nonregular file object</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is similar to the mknod procedure in NFSv3; it creates a "nonregular" (special) object file. (Regular files are created using the open operation.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>delepurge</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Purge delegations awaiting recovery</p></td><td style="border-bottom: 0.5pt solid ; "><p>NFSv4 has a feature where a server may delegate to a client responsibility for certain files. This operation removes delegations awaiting recovery from a client.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>delegreturn</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Return delegation</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns a delegation from a client to the server that granted it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>getattr</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Get attributes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Obtains the attributes for a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>getfh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Get current file handle</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns a file handle, which is a logical object used to allow access to a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>link</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create link to a file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a hard (nonsymbolic) link to a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>lock</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Create lock</p></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a lock on a file. Locks are used to manage access to a file—for example, to prevent two clients from trying to write to a file simultaneously and thus corrupting it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>lockt</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Test for lock</p></td><td style="border-bottom: 0.5pt solid ; "><p>Tests for the existence of a lock on an object and returns information about it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>locku</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unlock lile</p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes a lock previously created on a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>lookup</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Look up filename</p></td><td style="border-bottom: 0.5pt solid ; "><p>Looks up or finds a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>lookupp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Look up parent directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns the file handle of an object's parent directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>nverify</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Verify difference in attributes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Checks to see if attributes have changed on a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>open</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Open a regular file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Opens a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>19</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>openattr</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Open named attribute directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Opens an attribute directory associated with a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>20</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>open_confirm</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Confirm open</p></td><td style="border-bottom: 0.5pt solid ; "><p>Confirms information related to an opened file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>21</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>open_ downgrade</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reduce open file access</p></td><td style="border-bottom: 0.5pt solid ; "><p>Adjusts the access rights for a file that is already open.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>22</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>putfh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Set current file handle</p></td><td style="border-bottom: 0.5pt solid ; "><p>Replaces one file handle with another.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>23</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>putpubfh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Set public file handle</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the current file handle to be the public file handle of the server. This may or may not be the same as the root file handle.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>24</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>putrootfh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Set root file handle</p></td><td style="border-bottom: 0.5pt solid ; "><p>Sets the current file handle to be the root of the server's file system.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>25</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>read</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read from file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reads data from a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>26</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>readdir</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read directory</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reads the contents of a directory.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>27</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>readlink</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read symbolic link</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reads the name of a file specified using a symbolic link.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>28</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>remove</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remove file system object</p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes (deletes) an object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>29</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>rename</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Rename directory entry</p></td><td style="border-bottom: 0.5pt solid ; "><p>Changes the name of an object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>renew</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Renew a lease</p></td><td style="border-bottom: 0.5pt solid ; "><p>Renews an NFS delegation made by a server. (Note that these leases have nothing to do with DHCP leases, which are discussed in <a class="xref" href="ch61.html" title="Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS">Chapter 61</a>.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>31</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>restorefh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Restore saved file handle</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows a file handle previously saved to be made the current file handle.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>savefh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Save current file handle</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows a file handle to be saved so it can later be restored when needed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>33</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>secinfo</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Obtain available security</p></td><td style="border-bottom: 0.5pt solid ; "><p>Retrieves NFS security information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>34</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>setattr</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Set attributes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Changes one or more attributes of a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>35</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>setclientid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Negotiate client ID</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows a client to communicate information to the server regarding how the client wants to use NFS.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>36</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>setclientid_confirm</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Confirm client ID</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to confirm the results of a previous negotiation using setclientid.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>37</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>verify</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Verify same attributes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Allows a client to verify certain attributes before proceeding with a particular action.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>38</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>write</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Write to file</p></td><td style="border-bottom: 0.5pt solid ; "><p>Writes data to a file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>39</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>release_lockowner</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Release lock owner state</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used by a client to tell a server to release certain information related to file locks.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>10044</p></td><td style="border-right: 0.5pt solid ; "><p>illegal</p></td><td style="border-right: 0.5pt solid ; "><p>Illegal operation</p></td><td style=""><p>A placeholder (dummy) operation used to support error reporting when an invalid operation is used in a request from a client.</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-357"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> File operations in NFS are carried out using NFS <span class="emphasis"><em>server procedures</em></span>. In versions 2 and 3 of NFS, each procedure performs one action, such as reading data from a file. In NFSv4, a special <span class="emphasis"><em>compound</em></span> action is defined that allows many individual <span class="emphasis"><em>operations</em></span> to be sent in a single request to a server.</p></div></div></div>
<div class="sect1" title="NFS File System Model and the Mount Protocol"><div class="titlepage"><div><div><h1 class="title"><a id="nfs_file_system_model_and_the_mount_prot"/>NFS File System Model and the Mount Protocol</h1></div></div></div><p><a class="indexterm" id="idx-CHP-58-2158"/><a class="indexterm" id="idx-CHP-58-2159"/>Since NFS is used by a client to simulate access to remote directories of files as if they were local, the protocol must present the files from the remote system to the local user. Just as files on a local storage device are arranged using a particular file system, NFS uses a <a class="indexterm" id="idx-CHP-58-2160"/><span class="emphasis"><em>file system model</em></span> to represent how files are shown to a user.</p><div class="sect2" title="The NFS File System Model"><div class="titlepage"><div><div><h2 class="title"><a id="the_nfs_file_system_model"/>The NFS File System Model</h2></div></div></div><p>The file system model used by NFS is the same one that most of us are familiar with: a hierarchical arrangement of directories that contain files and subdirectories. The top of the hierarchy is the <span class="emphasis"><em>root</em></span>, which contains any number of files and first-level directories. Each directory may contain more files or other directories, allowing an arbitrary tree structure to be created.</p><p>A file can be uniquely specified by using its <span class="emphasis"><em>filename</em></span> and a <span class="emphasis"><em>path name</em></span> that shows the sequence of directories one must traverse from the root to find the file. Since NFS is associated with UNIX, files in NFS discussions are usually shown in UNIX notation; for example, <span class="emphasis"><em>/etc/hosts</em></span>. The same basic tree idea can also be expressed using the method followed by Windows operating systems: <span class="emphasis"><em>C:\WINDOWS\HOSTS</em></span>.</p></div><div class="sect2" title="The Mount Protocol"><div class="titlepage"><div><div><h2 class="title"><a id="the_mount_protocol"/>The Mount Protocol</h2></div></div></div><p>Before NFS can be used to allow a client to access a file on a remote server, the client must be given a way of accessing the file. This means that a portion of the remote file system must be made available to the client, and the file opened for access. A specific decision was made when NFS was created to not put file access, opening, and closing functions into NFS proper. Instead, a separate protocol was created to work with NFS, so that if the method of providing file access needed to be changed later, it wouldn't require changes to NFS itself. This separate mechanism is called the <span class="emphasis"><em>Mount protocol</em></span> and is described in Appendix A of RFC 1094 (NFSv2). Note that while its functionally distinct, Mount is considered part of the overall NFS package.</p><p>When NFS was revised to version 3, the Mount protocol was similarly modified. The NFSv3 version of the Mount protocol is defined in Appendix I of RFC 1813 (NFSv3). It contains some changes to how the protocol works, but the overall operation of the two versions of Mount is pretty much the same.</p><p>The term <span class="emphasis"><em>mount</em></span> is actually an analog to a hardware term that refers to making a physical storage volume available. In the past, storage devices were usually removable disk packs, and to use one, you mounted it onto a drive unit. In a similar manner, NFS resources are logically mounted using the Mount protocol, which makes the shared file system available to the client. A file can then be opened and a file handle returned to the NFS client, so it can reference the file for operations such as reading and writing.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-358"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Versions 2 and 3 of NFS do not include procedures for opening or closing resources on a remote server. Before NFS tasks can be accomplished on these versions, the special <span class="emphasis"><em>Mount</em></span> protocol must be employed to mount a file system and create a file handle to access a file on it. The protocol is also used to unmount the file system when no longer required. The Mount protocol is implemented in a manner similar to NFS itself, defining a sequence of procedures that use RPC and XDR. In NFSv4, the Mount protocol is no longer needed, because the tasks it performs have been implemented as NFSv4 operations.</p></div><p>The actual implementation of the Mount protocol is very similar to that of NFS itself. Like NFS, the Mount protocol uses XDR to define data types to be exchanged between the client and server and RPC to define a set of server procedures that clients may use to perform different operations. The main difference between Mount and NFS is simply that Mount defines procedures related to opening and closing file systems, rather than file access operations. <a class="xref" href="ch58s07.html#nfs_mount_protocol_server_procedures" title="Table 58-5. NFS Mount Protocol Server Procedures">Table 58-5</a> shows the server procedures used in the Mount protocol.</p><div class="table"><a id="nfs_mount_protocol_server_procedures"/><p class="title">Table 58-5. NFS Mount Protocol Server Procedures
</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="NFS Mount Protocol Server Procedures&#10;"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Procedure Summary</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>null</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Do nothing</p></td><td style="border-bottom: 0.5pt solid ; "><p>Dummy procedure provided for testing purposes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>mnt</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Add mount entry</p></td><td style="border-bottom: 0.5pt solid ; "><p>Performs a mount operation by mapping a path on a server to a file handle for the client to use.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>dump</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Return mount entries</p></td><td style="border-bottom: 0.5pt solid ; "><p>Returns a list of remotely mounted file systems.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>umnt</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remove mount entry</p></td><td style="border-bottom: 0.5pt solid ; "><p>Performs an unmount operation by removing a mount entry. (Yes, it should be <span class="emphasis"><em>dismount</em></span>; techies usually aren't English majors.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>umntall</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Remove all mount entries</p></td><td style="border-bottom: 0.5pt solid ; "><p>Removes all mount entries, thus eliminating all mounted file systems between server and client.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; "><p>export</p></td><td style="border-right: 0.5pt solid ; "><p>Return export list</p></td><td style=""><p>Returns a list of exported file systems and indicates which clients are allowed to mount them. This is used to let the client see which served file systems are available for use.</p></td></tr></tbody></table></div></div><p>Again, NFSv4 does away with the notion of a separate Mount protocol, incorporating file mounting operations into NFS directly.</p></div></div></body></html>