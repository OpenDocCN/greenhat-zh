- en: Chapter 12. Modules and Mixins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 模块和混入
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: In Ruby, each class has only one immediate “parent,” though each parent class
    may have many “children.” By restricting class hierarchies to a single line of
    descent, Ruby avoids some of the problems that may occur in those programming
    languages (such as C++) that permit multiple lines of descent. When classes have
    many parents as well as many children and when their parents and children also
    have other parents and children, you risk ending up with an impenetrable network
    (a knotwork?) rather than the neat, well-ordered hierarchy that you may have intended.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，每个类只有一个直接的“父类”，尽管每个父类可能有多个“子类”。通过将类层次结构限制为单行继承，Ruby避免了那些允许多行继承的编程语言（如C++）可能出现的某些问题。当类有多个父类和子类，并且它们的父类和子类也有其他父类和子类时，你可能会得到一个难以穿透的网络（一个结网？），而不是你可能期望的整洁、有序的层次结构。
- en: Nevertheless, sometimes it is useful for classes that are not closely related
    to implement some shared features. For example, a Sword might be a type of Weapon
    but also a type of Treasure; a PC might be a type of Computer but also a type
    of Investment; and so on. But, since the classes defining Weapons and Treasures
    or Computers and Investments descend from different ancestor classes, their class
    hierarchy gives them no obvious way of sharing data and methods. Ruby’s solution
    to this problem is provided by modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有时对于不是紧密相关的类实现一些共享功能是有用的。例如，剑可能是一种武器，但也是一种宝藏；个人电脑可能是一种计算机，但也是一种投资；等等。但是，由于定义武器和宝藏或计算机和投资的类来自不同的祖先类，它们的类层次结构没有明显的共享数据和方法的途径。Ruby解决这个问题的方案是通过模块提供的。
- en: A Module Is Like a Class . . .
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块就像一个类……
- en: 'The definition of a module looks very similar to the definition of a class.
    In fact, modules and classes are closely related; the Module class is the immediate
    ancestor of the Class class. Just like a class, a module can contain constants,
    methods, and classes. Here’s a simple module:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的定义看起来非常类似于类的定义。实际上，模块和类是紧密相关的；模块类是类类的直接祖先。就像类一样，模块可以包含常量、方法和类。以下是一个简单的模块：
- en: '*simple_module.rb*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*simple_module.rb*'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, this contains a constant, `REWARD`, and an *instance method*,
    `prize`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这包含一个常量`REWARD`和一个*实例方法*，`prize`。
- en: Module Methods
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块方法
- en: 'In addition to instance methods, a module may also have module methods. Just
    as class methods are prefixed with the name of the class, module methods are prefixed
    with the name of the module:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例方法之外，模块还可能有模块方法。就像类方法以类的名称为前缀一样，模块方法以模块的名称为前缀：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can call a module’s module methods just as you would call a class’s class
    methods, using dot notation, like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像调用类的类方法一样调用模块的模块方法，使用点符号，如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But how do you call an instance method? Neither of the following attempts succeeds:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何调用实例方法？以下两种尝试都没有成功：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In spite of their similarities, classes possess two major features that modules
    do not: *instances* and *inheritance*. Classes can have instances (objects created
    from the class), superclasses (parents), and subclasses (children); modules can
    have none of these. It is not possible to call an instance method from an instance
    of a module (a “module object”) for the simple reason that it is impossible to
    create instances of a module. This explains the errors when you try to call the
    `prize` method in the previous code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们有相似之处，但类有两个主要特征是模块不具备的：*实例*和*继承*。类可以有实例（从类创建的对象），超类（父类），和子类（子类）；模块则没有这些。从模块的实例（一个“模块对象”）中调用实例方法是不可能的，简单的原因是无法创建模块的实例。这就是当你尝试调用前面代码中的`prize`方法时出现错误的原因。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Module class does have a superclass, namely, Object. However, any named
    modules that you create do not have superclasses. For a more detailed account
    of the relationship between modules and classes, see [Digging Deeper](ch12s08.html#digging_deeper-id11
    "Digging Deeper") in [Digging Deeper](ch12s08.html#digging_deeper-id11 "Digging
    Deeper").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模块类确实有一个超类，即Object。然而，你创建的任何命名模块都没有超类。有关模块和类之间关系的更详细说明，请参阅[深入挖掘](ch12s08.html#digging_deeper-id11
    "深入挖掘")中的[深入挖掘](ch12s08.html#digging_deeper-id11 "深入挖掘")。
- en: 'That leads me to the next question: If you can’t create an object from a module,
    what are modules for? This can be answered in two words: *namespaces* and *mixins*.
    Ruby’s mixins provide a way of dealing with the problem of multiple inheritance.
    You’ll learn how mixins work shortly. First, though, let’s look at namespaces.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了下一个问题：如果你不能从模块创建对象，模块有什么用？这可以用两个词来回答：*命名空间*和*混入*。Ruby的混入提供了一种处理多重继承问题的方法。你很快就会了解混入是如何工作的。首先，让我们看看命名空间。
- en: Modules as Namespaces
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块作为命名空间
- en: You can think of a module as a sort of named “wrapper” around a set of methods,
    constants, and classes. The various bits of code inside the module share the same
    “namespace,” so they are all visible to each other but are not visible to code
    outside the module.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将模块视为围绕一组方法、常量和类的一种命名“包装”。模块内部的代码片段共享相同的“命名空间”，因此它们彼此可见，但对模块外部的代码不可见。
- en: The Ruby class library defines a number of modules such as `Math` and `Kernel`.
    The `Math` module contains mathematical methods such as `sqrt` to return a square
    route and constants such as `PI`. The `Kernel` module contains many of the methods
    you’ve been using from the outset such as `print`, `puts`, and `gets`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby类库定义了多个模块，例如`Math`和`Kernel`。`Math`模块包含数学方法，如`sqrt`来返回平方根，以及常量如`PI`。`Kernel`模块包含了许多你从一开始就一直在使用的方
    法，如`print`、`puts`和`gets`。
- en: 'Let’s assume you have written this module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了这个模块：
- en: '*modules1.rb*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*modules1.rb*'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You’ve already seen how to use a module method such as `MyModule.greet`, and
    you can access the module constants just as you would access class constants,
    using the scope resolution operator, `::` , like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用模块方法，例如`MyModule.greet`，你可以像访问类常量一样访问模块常量，使用作用域解析运算符`::`，如下所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But how can you access the instance method, `greet`? This is where mixins enter
    the picture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但你如何访问实例方法`greet`？这就是混入介入的地方。
- en: Included Modules, or “Mixins”
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含的模块，或称为“混入”
- en: 'An object can access the instance methods of a module by including that module
    using the `include` method. If you were to include `MyModule` in your program,
    everything inside that module would suddenly pop into existence within the current
    scope. So, the `greet` method of `MyModule` will now be accessible:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以通过使用`include`方法包含一个模块来访问该模块的实例方法。如果你要在你的程序中包含`MyModule`，那么该模块中的所有内容都会突然在当前作用域中存在。因此，`MyModule`的`greet`方法现在可以访问：
- en: '*modules2.rb*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*modules2.rb*'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that only instance methods are included. In the previous example, the
    `greet` (instance) method has been included, but the `MyModule.greet` (module)
    method has not. As it’s included, the `greet` instance method can be used just
    as though it were a normal instance method within the current scope, whereas the
    module method, also named `greet`, is accessed using dot notation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有实例方法被包含。在先前的例子中，`greet`（实例）方法已被包含，但`MyModule.greet`（模块）方法没有被包含。由于它被包含，`greet`实例方法可以像当前作用域中的普通实例方法一样使用，而模块方法，也命名为`greet`，则是使用点符号来访问的：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The process of including a module is also called *mixing in*, which explains
    why included modules are often called mixins. When you mix modules into a class
    definition, any objects created from that class will be able to use the instance
    methods of the mixed-in module just as though they were defined in the class itself.
    Here the MyClass class mixes in the `MyModule` module:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 包含模块的过程也称为*混入*，这也解释了为什么包含的模块通常被称为混入。当你将模块混入类定义中时，从该类创建的任何对象都将能够使用混入模块的实例方法，就像它们在类本身中定义一样。这里`MyClass`类混入了`MyModule`模块：
- en: '*modules3.rb*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*modules3.rb*'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Not only can the methods of this class access the `greet` method from `MyModule`,
    but so too can any objects created from the class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这个类的方 法可以访问`MyModule`中的`greet`方法，从该类创建的任何对象也可以：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can think of modules as discrete code units that may simplify the creation
    of reusable code libraries. On the other hand, you might be more interested in
    using modules as an alternative to multiple inheritance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将模块视为离散的代码单元，这可能有助于简化可重用代码库的创建。另一方面，你可能更感兴趣的是将模块用作多重继承的替代方案。
- en: 'Returning to an example that I mentioned at the start of this chapter, let’s
    assume you have a Sword class that is not only a weapon but also a treasure. Maybe
    Sword is a descendant of the Weapon class (so it inherits the Weapon’s `deadliness`
    attribute), but it also needs to have the attributes of a Treasure (such as `value`
    and `owner`). Moreover, since this happens to be an Elvish Sword, it also requires
    the attributes of a MagicThing. If you define these attributes inside `Treasure`
    and `MagicThing` *modules* rather than Treasure and MagicThing *classes*, the
    Sword class would be able to include those modules in order to “mix in” their
    methods or attributes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我在本章开头提到的例子，假设你有一个Sword类，它不仅是一件武器，也是一件宝物。也许Sword是Weapon类的后代（因此继承了Weapon的`deadliness`属性），但它还需要具有宝物的属性（如`value`和`owner`）。此外，由于这是一把精灵剑，它还需要具有魔法物品的属性。如果你在`Treasure`和`MagicThing`模块内部而不是类内部定义这些属性，Sword类就能够包含这些模块，以便“混入”它们的方法或属性：
- en: '*modules4.rb*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*modules4.rb*'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Sword object now has access to the methods and attributes of the Sword
    class, of its ancestor class, Weapon, and also of its mixed-in modules, `Treasure`
    and `MagicThing`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Sword对象可以访问Sword类的方法和属性，以及其祖先类Weapon的方法和属性，还有混入的模块`Treasure`和`MagicThing`的方法和属性：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note, incidentally, that any variables that are *local* to the module cannot
    be accessed from outside the module. This is the case even if a method inside
    the module tries to access a local variable and that method is invoked by code
    from outside the module, such as when the module is mixed in through inclusion:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，任何属于模块的局部变量都无法从模块外部访问。即使模块内部的方法试图访问局部变量，并且该方法被模块外部的代码调用，例如通过混入模块，也是如此：
- en: '*mod_vars.rb*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*mod_vars.rb*'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you run this program, the `puts` method executes when the module is initialized,
    and it displays the value of the module-local variable `x`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，`puts`方法在模块初始化时执行，并显示模块局部变量`x`的值：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you display the `x` variable within the main scope of the program, the value
    of the variable `x` local to the main scope of the program is used, *not* the
    value of the variable `x` local to the module:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在程序的主作用域中显示变量`x`，则使用的是程序主作用域中局部变量`x`的值，*而不是*模块内部局部变量`x`的值：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But any attempt to execute the `no_bar` method will fail:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但尝试执行`no_bar`方法将会失败：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here the `no_bar` method is unable to access either of the local variables
    named `x` even though `x` is declared both in the scope of the module (`x = 50`)
    and in the current or “main” scope (`x = 1`). But there is no such problem with
    instance variables. The `bar` method is able to return the value of the instance
    variable `@x`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`no_bar`方法无法访问名为`x`的任何局部变量，尽管`x`在模块的作用域（`x = 50`）和当前或“主”作用域（`x = 1`）中都被声明了。但对于实例变量则没有这样的问题。`bar`方法能够返回实例变量`@x`的值：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A module may have its own instance variables that belong exclusively to the
    module “object.” These instance variables will be in scope to a module method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以有自己的实例变量，这些变量仅属于模块“对象”。这些实例变量将适用于模块方法：
- en: '*inst_class_vars.rb*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*inst_class_vars.rb*'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But instance variables that are referenced in instance objects “belong” to
    the scope into which that module is included:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但在实例对象中引用的实例变量“属于”将模块混入的作用域：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Class variables are also mixed in, and like instance variables, their values
    may be reassigned within the current scope:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量也被混入，并且像实例变量一样，它们的值可以在当前作用域内重新赋值：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You may obtain an array of instance variable names using the `instance_variables`
    method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`instance_variables`方法获取实例变量名称的数组：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `X.instance_variables` returns a list of the instance variables belonging
    to the X class, while `self.instance_variables` returns the instance variables
    of the current, main, object. The `@instvar` variable is different in each case.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`X.instance_variables`返回属于X类的实例变量列表，而`self.instance_variables`返回当前、主对象的实例变量。`@instvar`变量在每个情况下都是不同的。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Ruby 1.9, the `instance_variables` method returns an array of symbols. In
    Ruby 1.8, it returns an array of strings.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby 1.9中，`instance_variables`方法返回一个符号数组。在Ruby 1.8中，它返回一个字符串数组。
- en: Name Conflicts
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名冲突
- en: Module methods (those methods specifically preceded by the module name) can
    help protect your code from accidental name conflicts. However, no such protection
    is given by instance methods within modules. Let’s suppose you have two modules—one
    called `Happy` and the other called `Sad`. They each contain a module method called
    `mood` and an instance method called `expression`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模块方法（那些特别以模块名开头的方法）可以帮助保护你的代码免受意外的名称冲突。然而，模块中的实例方法并没有提供此类保护。假设你有两个模块——一个叫 `Happy`，另一个叫
    `Sad`。它们各自包含一个名为 `mood` 的模块方法和一个名为 `expression` 的实例方法。
- en: '*happy_sad.rb*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*happy_sad.rb*'
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now a class, Person, includes both these modules:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类 `Person` 包含了这两个模块：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `initialize` method of the Person class needs to set the value of its `@mood`
    variable using the `mood` method from one of the included modules. The fact that
    they both have a `mood` method is no problem; being a module method, `mood` must
    be preceded by the module name so `Happy.mood` won’t be confused with `Sad.mood`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类的 `initialize` 方法需要使用包含模块中的一个 `mood` 方法来设置其 `@mood` 变量的值。他们都有 `mood`
    方法的事实并没有问题；作为一个模块方法，`mood` 必须在模块名之前，所以 `Happy.mood` 不会与 `Sad.mood` 混淆。'
- en: 'But both the `Happy` and `Sad` modules also contain a method called `expression`.
    This is an *instance* method, and when both the modules are included in the Person
    class, the `expression` method can be called without any qualification:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 `Happy` 和 `Sad` 模块也各自包含一个名为 `expression` 的方法。这是一个 *实例* 方法，当这两个模块都被包含在 `Person`
    类中时，可以直接调用 `expression` 方法，无需任何限定：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Which `expression` method is object `p1` using here? It turns out that it uses
    the method last defined. In the example case, that happens to be the method defined
    in the `Sad` module for the simple reason that `Sad` is included after `Happy`.
    So, `p1.expression` returns “frowning.” If you change the order of inclusion so
    that `Happy` is included after `Sad`, the `p1` object will use the version of
    the `expression` method defined in the Happy module and will display “smiling.”
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对象 `p1` 使用的是哪种 `expression` 方法？结果发现它使用的是最后定义的方法。在示例案例中，这恰好是 `Sad` 模块中定义的方法，因为
    `Sad` 是在 `Happy` 之后被包含的。所以，`p1.expression` 返回的是“皱眉。”如果你改变包含顺序，使得 `Happy` 在 `Sad`
    之后被包含，`p1` 对象将使用 `Happy` 模块中定义的 `expression` 方法，并显示“微笑。”
- en: 'Before getting carried away with the possibilities of creating big, complex
    modules and mixing them into your classes on a regular basis, bear this potential
    problem in mind: *Included instance methods with the same name will “overwrite”
    one another*. The problem may be obvious to spot in my little program here. But
    it may not be so obvious in a huge application!'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在沉迷于创建大型、复杂的模块并将它们定期混入你的类之前，请记住这个潜在的问题：*包含的具有相同名称的实例方法将“覆盖”彼此*。这个问题在我的小程序中可能很容易发现。但在一个大型应用程序中可能就不那么明显了！
- en: Alias Methods
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别名方法
- en: 'One way of avoiding ambiguity when you use similarly named methods from multiple
    modules is to *alias* those methods. An alias is a copy of an existing method
    with a new name. You use the `alias` keyword followed by the new name and then
    the old name:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用来自多个模块的具有相似名称的方法时，避免歧义的一种方法是对这些方法进行 *别名*。别名是现有方法的副本，具有新名称。你使用 `alias` 关键字后跟新名称，然后是旧名称：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also use `alias` to make copies of methods that have been overridden
    so that you can specifically refer to a version prior to its overridden definition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `alias` 来复制被覆盖的方法，以便你可以具体引用其覆盖定义之前的版本：
- en: '*alias_methods.rb*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*alias_methods.rb*'
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Mix In with Care!
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小心混入！
- en: Although each class can descend from only one superclass, it can mix in numerous
    modules. In fact, it is perfectly permissible to mix one lot of modules into another
    lot of modules, then mix those other modules into classes, then place those classes
    into yet more modules, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个类只能继承一个超类，但它可以混入多个模块。实际上，将一组模块混入另一组模块，然后将这些其他模块混入类，然后将这些类放入更多的模块中，然后继续这样做是完全允许的。
- en: 'The following is an example of some code that subclasses some classes, mixes
    in some modules, and even subclasses classes from within mixed-in modules. I’ve
    deliberately simplified the following code to help you see what is happening.
    For the full horror of a working example, see the sample program, *multimods.rb*,
    which is supplied in the code archive for this chapter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些代码示例，它子类化了某些类，混入了某些模块，甚至在混入的模块中子类化了类。我故意简化了以下代码，以便你能看到正在发生的事情。要查看完整的工作示例的恐怖之处，请参阅代码存档中提供的示例程序，*multimods.rb*：
- en: '*multimods.rb*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*multimods.rb*'
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let me emphasize that the code shown previously and included in the archive
    is *not* intended as a model to be emulated. Far from it! It is included purely
    to demonstrate how rapidly a program that makes overenthusiastic use of modules
    may become difficult to understand and nearly impossible to debug.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我强调，之前展示并包含在存档中的代码并不是作为要仿效的模型。远非如此！它仅仅是为了展示一个过度使用模块的程序可能会变得多么难以理解，几乎无法调试。
- en: In brief, although modules may, when used with care, help avoid some of the
    complexities associated with the C++ type of multiple inheritance, they are nonetheless
    open to misuse. If programmers really want to create convoluted hierarchies of
    classes with inscrutable dependencies on multiple levels of mixed-in modules,
    then they can certainly do so. The code in *multimods.rb* shows how easy it is
    to write an impenetrable program in just a few lines. Imagine what you could do
    over many thousands of lines of code spread over dozens of code files! Think carefully
    before mixing in modules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，尽管在使用得当的情况下，模块可以帮助避免与 C++ 多重继承相关的一些复杂性，但它们仍然容易受到误用的威胁。如果程序员真的想创建具有难以理解的依赖关系的复杂类层次结构，那么他们当然可以做到。*multimods.rb*
    中的代码展示了如何仅用几行代码就写出难以理解的程序。想象一下，在成千上万行代码和数十个代码文件中你能做什么！在混合模块之前要仔细思考。
- en: Including Modules from Files
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中包含模块
- en: 'So far, I’ve mixed in modules that have been defined within a single source
    file. Often it is more useful to define modules in separate files and mix them
    in as needed. The first thing you have to do in order to use code from another
    file is to load that file using the `require` method, like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我混合了在单个源文件中定义的模块。通常，在单独的文件中定义模块并在需要时混合它们更有用。为了使用其他文件中的代码，你必须首先使用 `require`
    方法加载该文件，如下所示：
- en: '*require_module.rb*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*require_module.rb*'
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Optionally, you may omit the file extension:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以省略文件扩展名：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If no path is given, the required file must be in the current directory, on
    the search path, or in a folder listed in the predefined array variable `$:`.
    You can add a directory to this array variable using the usual array-append method,
    `<<`, in this way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定路径，所需的文件必须在当前目录、搜索路径或预定义数组变量 `$:` 中列出的文件夹中。你可以使用常规的数组追加方法 `<<` 将目录添加到这个数组变量中，如下所示：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The global variable, `$:` (a dollar sign and a colon), contains an array of
    strings representing the directories that Ruby searches when looking for a loaded
    or required file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `$:`（一个美元符号和一个冒号）包含一个字符串数组，表示 Ruby 在查找已加载或所需的文件时搜索的目录。
- en: There is one documented difference in the way `require` works in Ruby 1.8 and
    Ruby 1.9\. In Ruby 1.8, the filename is *not* converted to an absolute path, so
    `require "a"; require "./a"` will load *a.rb* twice. In Ruby 1.9, the filename
    *is* converted to an absolute path, so `require "a"; require "./a"` will not load
    *a.rb* twice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.8 和 Ruby 1.9 中 `require` 的行为存在一个已记录的差异。在 Ruby 1.8 中，文件名不会被转换成绝对路径，因此
    `require "a"; require "./a"` 会加载 `a.rb` 两次。而在 Ruby 1.9 中，文件名会被转换成绝对路径，所以 `require
    "a"; require "./a"` 不会加载 `a.rb` 两次。
- en: 'In addition, I’ve found that `require` may, in at least some versions of Ruby
    1.9, fail to load a file from the current directory if you use an unqualified
    filename as in `require("testmod")`. In such cases, a LoadError is thrown. This
    occurs when the array of searchable directories stored in the global variable,
    `$:`, does not contain the current directory. You can verify whether this is the
    case by running this code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我发现至少在某些版本的 Ruby 1.9 中，如果你使用未指定扩展名的文件名，如 `require("testmod")`，`require` 可能无法从当前目录加载文件。在这种情况下，会抛出一个
    LoadError 异常。这通常发生在全局变量 `$:` 中存储的可搜索目录数组不包含当前目录时。你可以通过运行以下代码来验证这一点：
- en: '*search_dirs.rb*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*search_dirs.rb*'
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The search paths will be displayed one per line. There should be a line that
    displays a single dot (`.`) representing the current directory. If that dot is
    missing, then files in the current directory are not on the search path and cannot
    be loaded using an unqualified filename.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索路径将按行显示。应该有一行显示单个点（`.`），代表当前目录。如果这个点缺失，那么当前目录中的文件不在搜索路径上，无法使用未指定扩展名的文件名来加载。
- en: 'To ensure that the file is loaded, I have preceded the filename with a dot
    to specify the current directory, and this now succeeds: `require( "./testmod"
    )`. Alternatively, you could use the `require_relative` method, though this is
    new to Ruby 1.9 and cannot be used in earlier versions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文件被加载，我在文件名前加了一个点来指定当前目录，现在这成功了：`require( "./testmod" )`。或者，你也可以使用`require_relative`方法，尽管这是Ruby
    1.9的新特性，不能在早期版本中使用：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alternatively, if `$:` doesn’t contain the current directory, you could add
    it. Once this is done, `require` will work with the unqualified names of files
    in the current directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果`$:`不包含当前目录，你可以将其添加进去。一旦这样做，`require`将能够与当前目录中文件的未限定名称一起工作：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `require` method returns a `true` value if the specified file is successfully
    loaded; otherwise, it returns `false`. If the file does not exist, it returns
    a LoadError. If in doubt, you can simply display the result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`方法如果成功加载指定的文件，则返回`true`值；否则，返回`false`。如果文件不存在，它返回一个LoadError。如果有疑问，你可以简单地显示结果。'
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Any code that would normally be executed when a file is run will be executed
    when that file is required. So, if the file, *testmod.rb*, contains this code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件运行时通常会被执行的任何代码，在文件被`require`时也会被执行。所以，如果文件*testmod.rb*包含以下代码：
- en: '*testmod.rb*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*testmod.rb*'
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'when the *require_module.rb* program is run and it requires *testmod.rb*, this
    will be displayed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行*require_module.rb*程序并要求*testmod.rb*时，这将显示：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When a module is declared in the required file, it can be mixed in:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当在所需的文件中声明模块时，它可以被混合：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Ruby also lets you load a file using the `load` method. In most respects, `require`
    and `load` can be regarded as interchangeable. But there are a few subtle differences.
    In particular, `load` can take an optional second argument, which, if this is
    `true`, loads and executes the code as an unnamed or anonymous module:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby还允许你使用`load`方法加载一个文件。在大多数方面，`require`和`load`可以被视为可互换的。但是，它们之间有一些细微的差别。特别是，`load`可以接受一个可选的第二个参数，如果这个参数是`true`，则将代码作为未命名的或匿名模块加载和执行：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the second argument is `true`, the file loaded does not introduce the
    new namespace into the main program, and you will not have access to the module(s)
    in the loaded file. In that case, the Module methods, constants, and instance
    methods will *not* be available to your code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二个参数是`true`时，加载的文件不会将新的命名空间引入主程序，你将无法访问加载文件中的模块。在这种情况下，模块的方法、常量和实例方法将**不会**对你的代码可用：
- en: '*load_module.rb*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_module.rb*'
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the second argument to `load` is `false` or when there is no second argument,
    however, you *will* have access to modules in the loaded file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当`load`的第二个参数是`false`或者没有第二个参数时，你将**能够**访问加载文件中的模块：
- en: '*load_module_false.rb*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_module_false.rb*'
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that you must enter the full filename with `load` (*testmod* minus the
    *.rb* extension will not suffice). Another difference between `load` and `require`
    is that `require` loads a file once only (even if your code requires that file
    many times), whereas `load` causes the specified file to be reloaded each time
    `load` is called. Let’s suppose you have a file, *test.rb*, containing this code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须使用`load`输入完整的文件名（*testmod*去掉*.rb*扩展名是不够的）。`load`和`require`之间的另一个区别是，`require`只加载文件一次（即使你的代码多次要求该文件），而`load`每次调用`load`都会重新加载指定的文件。假设你有一个包含以下代码的文件*test.rb*：
- en: '*test.rb*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*test.rb*'
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You now *require* this file three times:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在**require**这个文件三次：
- en: '*require_again.rb*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*require_again.rb*'
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will be the output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是输出：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: But if you *load* the file three times . . .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你**加载**该文件三次 . . .
- en: '*load_again.rb*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_again.rb*'
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'then this will be the output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这将输出：
- en: '[PRE44]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Digging Deeper
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: How exactly is a module related to a class? Here we answer that question, examine
    some important Ruby modules and find out how to use modules to extend objects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模块与类究竟是如何相关的？在这里，我们回答这个问题，检查一些重要的Ruby模块，并了解如何使用模块来扩展对象。
- en: Modules and Classes
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和类
- en: 'In this chapter, I’ve discussed the *behavior* of a module. Let’s now find
    out what a module really *is*. It turns out that, as with most other things in
    Ruby, a module is an object. Each named module is, in fact, an instance of the
    Module class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了模块的**行为**。现在，让我们弄清楚模块究竟**是什么**。结果证明，就像Ruby中的大多数其他事物一样，模块是一个对象。每个命名的模块实际上都是Module类的实例：
- en: '*module_inst.rb*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*module_inst.rb*'
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You cannot create descendants of *named modules*, so this is not allowed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能创建**命名模块**的子类，所以这是不允许的：
- en: '[PRE46]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, as with other classes, it is permissible to create a descendant of
    the Module *class*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其他类一样，可以创建 `Module` 类的子类：
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Indeed, the Class class is itself a descendant of the Module class. It inherits
    the behavior of Module and adds some important new behavior, notably the ability
    to create objects. You can verify that Module is the superclass of Class by running
    the *modules_classes.rb* program, which shows this hierarchy:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`Class` 类本身是 `Module` 类的子类。它继承了 `Module` 的行为并添加了一些重要的新行为，特别是创建对象的能力。您可以通过运行
    *modules_classes.rb* 程序来验证 `Module` 是 `Class` 的超类，该程序显示了此层次结构：
- en: '*modules_classes.rb*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*modules_classes.rb*'
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Predefined Modules
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义模块
- en: 'The following modules are built into the Ruby interpreter: `Comparable`, `Enumerable`,
    `FileTest`, `GC`, `Kernel`, `Math`, `ObjectSpace`, `Precision`, `Process`, and
    `Signal`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块是 Ruby 解释器内建的：`Comparable`、`Enumerable`、`FileTest`、`GC`、`Kernel`、`Math`、`ObjectSpace`、`Precision`、`Process`
    和 `Signal`。
- en: '`Comparable` is a mixin module that permits the including class to implement
    comparison operators. The including class must define the `<=>` operator, which
    compares the receiver against another object, returning −1, 0, or +1 depending
    on whether the receiver is less than, equal to, or greater than the other object.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparable` 是一个允许包含类实现比较运算符的混入模块。包含的类必须定义 `<=>` 运算符，该运算符将接收者与另一个对象进行比较，根据接收者是否小于、等于或大于另一个对象返回
    -1、0 或 +1。'
- en: '`Comparable` uses `<=>` to implement the conventional comparison operators
    (`<`, `<=`, `==`, `>=`, and `>`) and the method `between?`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comparable` 使用 `<=>` 实现传统的比较运算符（`<`、`<=`、`==`、`>=` 和 `>`）和 `between?` 方法。'
- en: '`Enumerable` is a mixin module for enumeration. The including class must provide
    the method `each`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enumerable` 是一个用于枚举的混入模块。包含的类必须提供 `each` 方法。'
- en: '`FileTest` is a module containing file test functions; its methods can also
    be accessed from the File class.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileTest` 是一个包含文件测试函数的模块；其方法也可以从 `File` 类访问。'
- en: The `GC` module provides an interface to Ruby’s mark and sweep garbage collection
    mechanism. Some of the underlying methods are also available via the `ObjectSpace`
    module.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GC` 模块提供了 Ruby 标记和清除垃圾收集机制的接口。一些底层方法也可以通过 `ObjectSpace` 模块访问。'
- en: '`Kernel` is a module included by the Object class; it defines Ruby’s “built-in”
    methods.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kernel` 是由 `Object` 类包含的模块；它定义了 Ruby 的“内置”方法。'
- en: '`Math` is a module containing module functions for basic trigonometric and
    transcendental functions. It has both “instance methods” and module methods of
    the same definitions and names.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math` 是一个包含基本三角函数和超越函数模块函数的模块。它具有相同定义和名称的“实例方法”和模块方法。'
- en: '`ObjectSpace` is a module that contains routines that interact with the garbage
    collection facility and allow you to traverse all living objects with an iterator.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectSpace` 是一个包含与垃圾收集设施交互的例程的模块，并允许您使用迭代器遍历所有活动对象。'
- en: '`Precision` is a mixin for concrete numeric classes with precision. Here, “precision”
    means the fineness of approximation of a real number, so this module should not
    be included into anything that is not a subset of Real (so it should not be included
    in classes such as Complex or Matrix).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Precision` 是一个用于具有精度的具体数值类的混入模块。在这里，“精度”意味着实数的近似精度，因此此模块不应包含在不是实数子集的任何内容中（因此不应包含在复数或矩阵等类中）。'
- en: '`Process` is the module for manipulating processes. All its methods are module
    methods.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process` 是用于操作进程的模块。它所有的方法都是模块方法。'
- en: '`Signal` is the module for handling signals sent to running processes. The
    list of available signal names and their interpretation is system dependent.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Signal` 是处理发送给运行进程的信号的模块。可用的信号名称列表及其解释取决于系统。'
- en: The following is a brief overview of three of the most commonly used Ruby modules.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对三个最常用的 Ruby 模块的一个简要概述。
- en: '**Kernel**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kernel**'
- en: The most important of the predefined modules is `Kernel`, which provides many
    of the “standard” Ruby methods such as `gets`, `puts`, `print`, and `require`.
    In common with much of the Ruby class library, `Kernel` is written in the C language.
    Although `Kernel` is, in fact, “built into” the Ruby interpreter, conceptually
    it can be regarded as a mixed-in module that, just like a normal Ruby mixin, makes
    its methods directly available to any class that requires it. Since it is mixed
    into the Object class from which all other Ruby classes descend, the methods of
    `Kernel` are universally accessible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义模块中最重要的一个是 `Kernel`，它提供了许多“标准”Ruby 方法，如 `gets`、`puts`、`print` 和 `require`。与
    Ruby 类库的许多部分一样，`Kernel` 是用 C 语言编写的。尽管 `Kernel` 实际上“内置于”Ruby 解释器中，但从概念上讲，它可以被视为一个混合模块，就像一个正常的
    Ruby 混合模块一样，它将方法直接提供给任何需要它的类。由于它被混合到所有其他 Ruby 类继承的 `Object` 类中，因此 `Kernel` 的方法对所有类都是通用的。
- en: '**Math**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math**'
- en: 'The `Math` module’s methods are provided as both “module” and “instance” methods
    and can therefore be accessed either by mixing `Math` into a class or by accessing
    the module methods “from the outside” by using the module name, a dot, and the
    method name; you can access constants using a double colon:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 模块的方法既提供为“模块”方法又提供为“实例”方法，因此可以通过将 `Math` 混合到类中或通过使用模块名称、点和方法名称来“从外部”访问模块方法；你可以使用双冒号来访问常量：'
- en: '*math.rb*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*math.rb*'
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Comparable**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**Comparable**'
- en: 'The `Comparable` module provides the neat ability to define your own comparison
    “operators” as in `<`, `<=`, `==`, `>=`, and `>` (strictly speaking, these are
    methods, but they can be used like the comparison operators in other languages).
    This is done by mixing the module into your class and defining the `<=>` method.
    You can then specify the criteria for comparing some value from the current object
    with some other value. You might, for example, compare two integers, the length
    of two strings, or some more eccentric value such as the position of a string
    in an array. I’ve opted for this eccentric type of comparison in my example program,
    *compare.rb*. This uses the index of a string in an array of mythical beings in
    order to compare the name of one being with that of another. A low index such
    as `hobbit` at index 0 is considered to be “less than” a high index such as `dragon`
    at index 6:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparable` 模块提供了定义自己的比较“运算符”的便捷能力，如 `<`, `<=`, `==`, `>=`, 和 `>`（严格来说，这些是方法，但它们可以像其他语言中的比较运算符一样使用）。这是通过将模块混合到你的类中并定义
    `<=>` 方法来实现的。然后你可以指定比较当前对象中的某个值与其他值的标准。例如，你可以比较两个整数、两个字符串的长度，或者一些更古怪的价值，比如字符串在数组中的位置。我在示例程序
    *compare.rb* 中选择了这种古怪的比较类型。它使用神话生物数组中字符串的索引来比较一个生物的名字与另一个生物的名字。一个低索引，如索引 0 的 `hobbit`，被认为“小于”一个高索引，如索引
    6 的 `dragon`：'
- en: '*compare.rb*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*compare.rb*'
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Scope Resolution
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 范围解析
- en: 'As with classes, you can use the double-colon scope resolution operator to
    access constants (including classes and other modules) declared inside modules.
    For example, let’s suppose you have nested modules and classes, like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与类一样，你可以使用双冒号范围解析运算符来访问模块内部声明的常量（包括类和其他模块）。例如，假设你有一个嵌套的模块和类，如下所示：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You could use the `::` operator to access Class1, like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `::` 运算符来访问 `Class1`，如下所示：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See [Chapter 2](ch02.html "Chapter 2. Class Hierarchies, Attributes, and Class
    Variables") for an introduction to scope resolution of constants within classes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类中常量范围解析的介绍，请参阅[第 2 章](ch02.html "第 2 章。类层次结构、属性和类变量")。
- en: 'Each module and class has its own scope, which means that a single constant
    name might be used in different scopes. This being so, you could use the `::`
    operator to specify a constant within a precise scope:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块和类都有自己的范围，这意味着单个常量名可能在不同的范围内使用。因此，你可以使用 `::` 运算符来指定精确范围内的常量：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you use this operator at the very start of the constant name, this has the
    effect of breaking out of the current scope and accessing the “top-level” scope:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个常量名的开头使用这个运算符，这将导致跳出当前范围并访问“顶级”范围：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following program provides some examples of the scope operator:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序提供了一些范围运算符的示例：
- en: '*scope_resolution.rb*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*scope_resolution.rb*'
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Module Functions
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 模块函数
- en: 'If you want a function to be available both as an instance and as a module
    method, you can use the `module_function` method with a symbol matching the name
    of an instance method, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望一个函数既作为实例方法又作为模块方法可用，你可以使用与实例方法名称匹配的 `module_function` 方法，如下所示：
- en: '*module_func.rb*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*module_func.rb*'
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `sayHi` method may now be mixed into a class and used as an instance method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHi` 方法现在可以被混合到类中，并用作实例方法：'
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It may be used as a module method, using dot notation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用作模块方法，使用点符号表示：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Since the `sayGoodbye` method here is not a module function, it cannot be used
    in this way:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里的 `sayGoodbye` 方法不是一个模块函数，因此不能以这种方式使用：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Ruby uses `module_function` in some of its standard modules such as `Math` (in
    the Ruby library file, *complex.rb*) to create “matching pairs” of module and
    instance methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 在其一些标准模块中使用了 `module_function`，例如 `Math`（在 Ruby 库文件 *complex.rb* 中），来创建模块和实例方法的“匹配对”。
- en: Extending Objects
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展对象
- en: 'You can add the methods of a module to a specific object (rather than to an
    entire class) using the `extend` method, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `extend` 方法将模块的方法添加到特定的对象（而不是整个类）中，如下所示：
- en: '*extend.rb*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*extend.rb*'
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that the object `ob` is extended with the module `A`, it can access that
    module’s instance method, `method_a`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对象 `ob` 被扩展了模块 `A`，它可以访问该模块的实例方法 `method_a`：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can, in fact, extend an object with several modules all at once. Here,
    the modules `B` and `C` extend the object, `ob`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以一次扩展一个对象为多个模块。在这里，模块 `B` 和 `C` 扩展了对象 `ob`：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When an object is extended with a module containing a method with the same name
    as a method in the object’s class, the method from the module replaces the method
    from the class. So, when `ob` is extended with `C` and you call `ob.mymethod`,
    the string “hello from mymethod of module `C`” will be displayed rather than the
    “hello from mymethod of class MyClass” that was displayed before `ob` was extended
    with module `C`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象被扩展为一个包含与对象类中方法同名的方法的模块时，模块中的方法将替换类中的方法。因此，当 `ob` 被扩展为 `C` 并调用 `ob.mymethod`
    时，将显示字符串“hello from mymethod of module `C`”，而不是在 `ob` 扩展模块 `C` 之前显示的“hello from
    mymethod of class MyClass”。
- en: Freezing Objects
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结对象
- en: 'You can explicitly prevent an object from being extended it by “freezing” it
    using the `freeze` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `freeze` 方法“冻结”对象来显式防止对象被扩展：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Any attempt to extend this object further would result in a runtime error:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试进一步扩展此对象的行为都将导致运行时错误：
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To avoid such an error, you can use the `frozen?` method to test whether an
    object has been frozen:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种错误，你可以使用 `frozen?` 方法来测试一个对象是否已被冻结：
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
