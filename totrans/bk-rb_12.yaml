- en: Chapter 12. Modules and Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Ruby, each class has only one immediate “parent,” though each parent class
    may have many “children.” By restricting class hierarchies to a single line of
    descent, Ruby avoids some of the problems that may occur in those programming
    languages (such as C++) that permit multiple lines of descent. When classes have
    many parents as well as many children and when their parents and children also
    have other parents and children, you risk ending up with an impenetrable network
    (a knotwork?) rather than the neat, well-ordered hierarchy that you may have intended.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, sometimes it is useful for classes that are not closely related
    to implement some shared features. For example, a Sword might be a type of Weapon
    but also a type of Treasure; a PC might be a type of Computer but also a type
    of Investment; and so on. But, since the classes defining Weapons and Treasures
    or Computers and Investments descend from different ancestor classes, their class
    hierarchy gives them no obvious way of sharing data and methods. Ruby’s solution
    to this problem is provided by modules.
  prefs: []
  type: TYPE_NORMAL
- en: A Module Is Like a Class . . .
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition of a module looks very similar to the definition of a class.
    In fact, modules and classes are closely related; the Module class is the immediate
    ancestor of the Class class. Just like a class, a module can contain constants,
    methods, and classes. Here’s a simple module:'
  prefs: []
  type: TYPE_NORMAL
- en: '*simple_module.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this contains a constant, `REWARD`, and an *instance method*,
    `prize`.
  prefs: []
  type: TYPE_NORMAL
- en: Module Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to instance methods, a module may also have module methods. Just
    as class methods are prefixed with the name of the class, module methods are prefixed
    with the name of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call a module’s module methods just as you would call a class’s class
    methods, using dot notation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But how do you call an instance method? Neither of the following attempts succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In spite of their similarities, classes possess two major features that modules
    do not: *instances* and *inheritance*. Classes can have instances (objects created
    from the class), superclasses (parents), and subclasses (children); modules can
    have none of these. It is not possible to call an instance method from an instance
    of a module (a “module object”) for the simple reason that it is impossible to
    create instances of a module. This explains the errors when you try to call the
    `prize` method in the previous code.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Module class does have a superclass, namely, Object. However, any named
    modules that you create do not have superclasses. For a more detailed account
    of the relationship between modules and classes, see [Digging Deeper](ch12s08.html#digging_deeper-id11
    "Digging Deeper") in [Digging Deeper](ch12s08.html#digging_deeper-id11 "Digging
    Deeper").
  prefs: []
  type: TYPE_NORMAL
- en: 'That leads me to the next question: If you can’t create an object from a module,
    what are modules for? This can be answered in two words: *namespaces* and *mixins*.
    Ruby’s mixins provide a way of dealing with the problem of multiple inheritance.
    You’ll learn how mixins work shortly. First, though, let’s look at namespaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Modules as Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of a module as a sort of named “wrapper” around a set of methods,
    constants, and classes. The various bits of code inside the module share the same
    “namespace,” so they are all visible to each other but are not visible to code
    outside the module.
  prefs: []
  type: TYPE_NORMAL
- en: The Ruby class library defines a number of modules such as `Math` and `Kernel`.
    The `Math` module contains mathematical methods such as `sqrt` to return a square
    route and constants such as `PI`. The `Kernel` module contains many of the methods
    you’ve been using from the outset such as `print`, `puts`, and `gets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume you have written this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '*modules1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve already seen how to use a module method such as `MyModule.greet`, and
    you can access the module constants just as you would access class constants,
    using the scope resolution operator, `::` , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But how can you access the instance method, `greet`? This is where mixins enter
    the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Included Modules, or “Mixins”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object can access the instance methods of a module by including that module
    using the `include` method. If you were to include `MyModule` in your program,
    everything inside that module would suddenly pop into existence within the current
    scope. So, the `greet` method of `MyModule` will now be accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '*modules2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that only instance methods are included. In the previous example, the
    `greet` (instance) method has been included, but the `MyModule.greet` (module)
    method has not. As it’s included, the `greet` instance method can be used just
    as though it were a normal instance method within the current scope, whereas the
    module method, also named `greet`, is accessed using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of including a module is also called *mixing in*, which explains
    why included modules are often called mixins. When you mix modules into a class
    definition, any objects created from that class will be able to use the instance
    methods of the mixed-in module just as though they were defined in the class itself.
    Here the MyClass class mixes in the `MyModule` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '*modules3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only can the methods of this class access the `greet` method from `MyModule`,
    but so too can any objects created from the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can think of modules as discrete code units that may simplify the creation
    of reusable code libraries. On the other hand, you might be more interested in
    using modules as an alternative to multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to an example that I mentioned at the start of this chapter, let’s
    assume you have a Sword class that is not only a weapon but also a treasure. Maybe
    Sword is a descendant of the Weapon class (so it inherits the Weapon’s `deadliness`
    attribute), but it also needs to have the attributes of a Treasure (such as `value`
    and `owner`). Moreover, since this happens to be an Elvish Sword, it also requires
    the attributes of a MagicThing. If you define these attributes inside `Treasure`
    and `MagicThing` *modules* rather than Treasure and MagicThing *classes*, the
    Sword class would be able to include those modules in order to “mix in” their
    methods or attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*modules4.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Sword object now has access to the methods and attributes of the Sword
    class, of its ancestor class, Weapon, and also of its mixed-in modules, `Treasure`
    and `MagicThing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, incidentally, that any variables that are *local* to the module cannot
    be accessed from outside the module. This is the case even if a method inside
    the module tries to access a local variable and that method is invoked by code
    from outside the module, such as when the module is mixed in through inclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '*mod_vars.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this program, the `puts` method executes when the module is initialized,
    and it displays the value of the module-local variable `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you display the `x` variable within the main scope of the program, the value
    of the variable `x` local to the main scope of the program is used, *not* the
    value of the variable `x` local to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But any attempt to execute the `no_bar` method will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `no_bar` method is unable to access either of the local variables
    named `x` even though `x` is declared both in the scope of the module (`x = 50`)
    and in the current or “main” scope (`x = 1`). But there is no such problem with
    instance variables. The `bar` method is able to return the value of the instance
    variable `@x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A module may have its own instance variables that belong exclusively to the
    module “object.” These instance variables will be in scope to a module method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*inst_class_vars.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But instance variables that are referenced in instance objects “belong” to
    the scope into which that module is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Class variables are also mixed in, and like instance variables, their values
    may be reassigned within the current scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You may obtain an array of instance variable names using the `instance_variables`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, `X.instance_variables` returns a list of the instance variables belonging
    to the X class, while `self.instance_variables` returns the instance variables
    of the current, main, object. The `@instvar` variable is different in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Ruby 1.9, the `instance_variables` method returns an array of symbols. In
    Ruby 1.8, it returns an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Name Conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module methods (those methods specifically preceded by the module name) can
    help protect your code from accidental name conflicts. However, no such protection
    is given by instance methods within modules. Let’s suppose you have two modules—one
    called `Happy` and the other called `Sad`. They each contain a module method called
    `mood` and an instance method called `expression`.
  prefs: []
  type: TYPE_NORMAL
- en: '*happy_sad.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now a class, Person, includes both these modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `initialize` method of the Person class needs to set the value of its `@mood`
    variable using the `mood` method from one of the included modules. The fact that
    they both have a `mood` method is no problem; being a module method, `mood` must
    be preceded by the module name so `Happy.mood` won’t be confused with `Sad.mood`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But both the `Happy` and `Sad` modules also contain a method called `expression`.
    This is an *instance* method, and when both the modules are included in the Person
    class, the `expression` method can be called without any qualification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Which `expression` method is object `p1` using here? It turns out that it uses
    the method last defined. In the example case, that happens to be the method defined
    in the `Sad` module for the simple reason that `Sad` is included after `Happy`.
    So, `p1.expression` returns “frowning.” If you change the order of inclusion so
    that `Happy` is included after `Sad`, the `p1` object will use the version of
    the `expression` method defined in the Happy module and will display “smiling.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting carried away with the possibilities of creating big, complex
    modules and mixing them into your classes on a regular basis, bear this potential
    problem in mind: *Included instance methods with the same name will “overwrite”
    one another*. The problem may be obvious to spot in my little program here. But
    it may not be so obvious in a huge application!'
  prefs: []
  type: TYPE_NORMAL
- en: Alias Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way of avoiding ambiguity when you use similarly named methods from multiple
    modules is to *alias* those methods. An alias is a copy of an existing method
    with a new name. You use the `alias` keyword followed by the new name and then
    the old name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `alias` to make copies of methods that have been overridden
    so that you can specifically refer to a version prior to its overridden definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*alias_methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Mix In with Care!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although each class can descend from only one superclass, it can mix in numerous
    modules. In fact, it is perfectly permissible to mix one lot of modules into another
    lot of modules, then mix those other modules into classes, then place those classes
    into yet more modules, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of some code that subclasses some classes, mixes
    in some modules, and even subclasses classes from within mixed-in modules. I’ve
    deliberately simplified the following code to help you see what is happening.
    For the full horror of a working example, see the sample program, *multimods.rb*,
    which is supplied in the code archive for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multimods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let me emphasize that the code shown previously and included in the archive
    is *not* intended as a model to be emulated. Far from it! It is included purely
    to demonstrate how rapidly a program that makes overenthusiastic use of modules
    may become difficult to understand and nearly impossible to debug.
  prefs: []
  type: TYPE_NORMAL
- en: In brief, although modules may, when used with care, help avoid some of the
    complexities associated with the C++ type of multiple inheritance, they are nonetheless
    open to misuse. If programmers really want to create convoluted hierarchies of
    classes with inscrutable dependencies on multiple levels of mixed-in modules,
    then they can certainly do so. The code in *multimods.rb* shows how easy it is
    to write an impenetrable program in just a few lines. Imagine what you could do
    over many thousands of lines of code spread over dozens of code files! Think carefully
    before mixing in modules.
  prefs: []
  type: TYPE_NORMAL
- en: Including Modules from Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, I’ve mixed in modules that have been defined within a single source
    file. Often it is more useful to define modules in separate files and mix them
    in as needed. The first thing you have to do in order to use code from another
    file is to load that file using the `require` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*require_module.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you may omit the file extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If no path is given, the required file must be in the current directory, on
    the search path, or in a folder listed in the predefined array variable `$:`.
    You can add a directory to this array variable using the usual array-append method,
    `<<`, in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The global variable, `$:` (a dollar sign and a colon), contains an array of
    strings representing the directories that Ruby searches when looking for a loaded
    or required file.
  prefs: []
  type: TYPE_NORMAL
- en: There is one documented difference in the way `require` works in Ruby 1.8 and
    Ruby 1.9\. In Ruby 1.8, the filename is *not* converted to an absolute path, so
    `require "a"; require "./a"` will load *a.rb* twice. In Ruby 1.9, the filename
    *is* converted to an absolute path, so `require "a"; require "./a"` will not load
    *a.rb* twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, I’ve found that `require` may, in at least some versions of Ruby
    1.9, fail to load a file from the current directory if you use an unqualified
    filename as in `require("testmod")`. In such cases, a LoadError is thrown. This
    occurs when the array of searchable directories stored in the global variable,
    `$:`, does not contain the current directory. You can verify whether this is the
    case by running this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*search_dirs.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The search paths will be displayed one per line. There should be a line that
    displays a single dot (`.`) representing the current directory. If that dot is
    missing, then files in the current directory are not on the search path and cannot
    be loaded using an unqualified filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the file is loaded, I have preceded the filename with a dot
    to specify the current directory, and this now succeeds: `require( "./testmod"
    )`. Alternatively, you could use the `require_relative` method, though this is
    new to Ruby 1.9 and cannot be used in earlier versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if `$:` doesn’t contain the current directory, you could add
    it. Once this is done, `require` will work with the unqualified names of files
    in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `require` method returns a `true` value if the specified file is successfully
    loaded; otherwise, it returns `false`. If the file does not exist, it returns
    a LoadError. If in doubt, you can simply display the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Any code that would normally be executed when a file is run will be executed
    when that file is required. So, if the file, *testmod.rb*, contains this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*testmod.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'when the *require_module.rb* program is run and it requires *testmod.rb*, this
    will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When a module is declared in the required file, it can be mixed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby also lets you load a file using the `load` method. In most respects, `require`
    and `load` can be regarded as interchangeable. But there are a few subtle differences.
    In particular, `load` can take an optional second argument, which, if this is
    `true`, loads and executes the code as an unnamed or anonymous module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the second argument is `true`, the file loaded does not introduce the
    new namespace into the main program, and you will not have access to the module(s)
    in the loaded file. In that case, the Module methods, constants, and instance
    methods will *not* be available to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*load_module.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When the second argument to `load` is `false` or when there is no second argument,
    however, you *will* have access to modules in the loaded file:'
  prefs: []
  type: TYPE_NORMAL
- en: '*load_module_false.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you must enter the full filename with `load` (*testmod* minus the
    *.rb* extension will not suffice). Another difference between `load` and `require`
    is that `require` loads a file once only (even if your code requires that file
    many times), whereas `load` causes the specified file to be reloaded each time
    `load` is called. Let’s suppose you have a file, *test.rb*, containing this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*test.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You now *require* this file three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '*require_again.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: But if you *load* the file three times . . .
  prefs: []
  type: TYPE_NORMAL
- en: '*load_again.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'then this will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: How exactly is a module related to a class? Here we answer that question, examine
    some important Ruby modules and find out how to use modules to extend objects.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and Classes
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ve discussed the *behavior* of a module. Let’s now find
    out what a module really *is*. It turns out that, as with most other things in
    Ruby, a module is an object. Each named module is, in fact, an instance of the
    Module class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*module_inst.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot create descendants of *named modules*, so this is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as with other classes, it is permissible to create a descendant of
    the Module *class*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, the Class class is itself a descendant of the Module class. It inherits
    the behavior of Module and adds some important new behavior, notably the ability
    to create objects. You can verify that Module is the superclass of Class by running
    the *modules_classes.rb* program, which shows this hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '*modules_classes.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Predefined Modules
  prefs: []
  type: TYPE_NORMAL
- en: 'The following modules are built into the Ruby interpreter: `Comparable`, `Enumerable`,
    `FileTest`, `GC`, `Kernel`, `Math`, `ObjectSpace`, `Precision`, `Process`, and
    `Signal`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Comparable` is a mixin module that permits the including class to implement
    comparison operators. The including class must define the `<=>` operator, which
    compares the receiver against another object, returning −1, 0, or +1 depending
    on whether the receiver is less than, equal to, or greater than the other object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Comparable` uses `<=>` to implement the conventional comparison operators
    (`<`, `<=`, `==`, `>=`, and `>`) and the method `between?`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enumerable` is a mixin module for enumeration. The including class must provide
    the method `each`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileTest` is a module containing file test functions; its methods can also
    be accessed from the File class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GC` module provides an interface to Ruby’s mark and sweep garbage collection
    mechanism. Some of the underlying methods are also available via the `ObjectSpace`
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kernel` is a module included by the Object class; it defines Ruby’s “built-in”
    methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math` is a module containing module functions for basic trigonometric and
    transcendental functions. It has both “instance methods” and module methods of
    the same definitions and names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectSpace` is a module that contains routines that interact with the garbage
    collection facility and allow you to traverse all living objects with an iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Precision` is a mixin for concrete numeric classes with precision. Here, “precision”
    means the fineness of approximation of a real number, so this module should not
    be included into anything that is not a subset of Real (so it should not be included
    in classes such as Complex or Matrix).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process` is the module for manipulating processes. All its methods are module
    methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Signal` is the module for handling signals sent to running processes. The
    list of available signal names and their interpretation is system dependent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is a brief overview of three of the most commonly used Ruby modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel**'
  prefs: []
  type: TYPE_NORMAL
- en: The most important of the predefined modules is `Kernel`, which provides many
    of the “standard” Ruby methods such as `gets`, `puts`, `print`, and `require`.
    In common with much of the Ruby class library, `Kernel` is written in the C language.
    Although `Kernel` is, in fact, “built into” the Ruby interpreter, conceptually
    it can be regarded as a mixed-in module that, just like a normal Ruby mixin, makes
    its methods directly available to any class that requires it. Since it is mixed
    into the Object class from which all other Ruby classes descend, the methods of
    `Kernel` are universally accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Math**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Math` module’s methods are provided as both “module” and “instance” methods
    and can therefore be accessed either by mixing `Math` into a class or by accessing
    the module methods “from the outside” by using the module name, a dot, and the
    method name; you can access constants using a double colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '*math.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**Comparable**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Comparable` module provides the neat ability to define your own comparison
    “operators” as in `<`, `<=`, `==`, `>=`, and `>` (strictly speaking, these are
    methods, but they can be used like the comparison operators in other languages).
    This is done by mixing the module into your class and defining the `<=>` method.
    You can then specify the criteria for comparing some value from the current object
    with some other value. You might, for example, compare two integers, the length
    of two strings, or some more eccentric value such as the position of a string
    in an array. I’ve opted for this eccentric type of comparison in my example program,
    *compare.rb*. This uses the index of a string in an array of mythical beings in
    order to compare the name of one being with that of another. A low index such
    as `hobbit` at index 0 is considered to be “less than” a high index such as `dragon`
    at index 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '*compare.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Scope Resolution
  prefs: []
  type: TYPE_NORMAL
- en: 'As with classes, you can use the double-colon scope resolution operator to
    access constants (including classes and other modules) declared inside modules.
    For example, let’s suppose you have nested modules and classes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use the `::` operator to access Class1, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [Chapter 2](ch02.html "Chapter 2. Class Hierarchies, Attributes, and Class
    Variables") for an introduction to scope resolution of constants within classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each module and class has its own scope, which means that a single constant
    name might be used in different scopes. This being so, you could use the `::`
    operator to specify a constant within a precise scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use this operator at the very start of the constant name, this has the
    effect of breaking out of the current scope and accessing the “top-level” scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program provides some examples of the scope operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '*scope_resolution.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Module Functions
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a function to be available both as an instance and as a module
    method, you can use the `module_function` method with a symbol matching the name
    of an instance method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*module_func.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sayHi` method may now be mixed into a class and used as an instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be used as a module method, using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `sayGoodbye` method here is not a module function, it cannot be used
    in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Ruby uses `module_function` in some of its standard modules such as `Math` (in
    the Ruby library file, *complex.rb*) to create “matching pairs” of module and
    instance methods.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Objects
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the methods of a module to a specific object (rather than to an
    entire class) using the `extend` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*extend.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the object `ob` is extended with the module `A`, it can access that
    module’s instance method, `method_a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, in fact, extend an object with several modules all at once. Here,
    the modules `B` and `C` extend the object, `ob`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When an object is extended with a module containing a method with the same name
    as a method in the object’s class, the method from the module replaces the method
    from the class. So, when `ob` is extended with `C` and you call `ob.mymethod`,
    the string “hello from mymethod of module `C`” will be displayed rather than the
    “hello from mymethod of class MyClass” that was displayed before `ob` was extended
    with module `C`.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing Objects
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly prevent an object from being extended it by “freezing” it
    using the `freeze` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Any attempt to extend this object further would result in a runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid such an error, you can use the `frozen?` method to test whether an
    object has been frozen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
