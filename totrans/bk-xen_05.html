<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;NETWORKING"><div class="titlepage"><div><div><h1 class="title"><a id="networking-id001"/>Chapter 5. NETWORKING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e4876"/><img src="httpatomoreillycomsourcenostarchimages333191.png.jpg" alt="image with no caption"/></div></div><p>So you've got your nice, shiny Xen box all set up and running, and now you want it to talk to the outside world. This seems eminently reasonable. After all, Xen's primary use is server consolidation—and a non-networked server is a contradiction in terms. Well, you're in luck. Xen has a robust and well-tested network foundation, which is versatile and easy to set up.</p><p>Like much of the rest of Xen, the networking infrastructure reuses as many standard tools as possible. In this case, Xen uses the standard bridge utilities and the <code class="literal">ip</code> command<sup>[<a id="CHP-5-FNOTE-1" href="#ftn.CHP-5-FNOTE-1" class="footnote">33</a>]</sup> all glued together with some clever bash and Python scripts to handle traffic between the dom0 and domU network interfaces.</p><p>As an administrator, your primary interaction with Xen virtual net devices is through the various config files. As you might expect, global parameters and initial setup are mostly handled by directives in <em class="filename">xend-config.sxp</em>. Domain-specific configuration is done within the domain's config file.</p><p>More advanced configuration can be done by modifying Xen's network <a id="idx-CHP-5-0358" class="indexterm"/>scripts, stored in <span class="emphasis"><em>/etc/xen/scripts</em></span>.</p><p>If you are the sort that avoids a reboot at all costs, you can <a id="idx-CHP-5-0359" class="indexterm"/>often directly manipulate Xen's network infrastructure while the VM is <a id="idx-CHP-5-0360" class="indexterm"/>running through <code class="literal">brctl, iptables</code>, and the <code class="literal">xm</code> command, but these changes don't always successfully propagate to the domU. We will focus on the "manipulate the config file and reboot the domU" method here because it works in all situations.</p><div class="sect1" title="Xen's Network Setup Process"><div class="titlepage"><div><div><h1 class="title"><a id="xens_network_setup_process"/>Xen's Network Setup Process</h1></div></div></div><p>Xen runs its network scripts at two points: at <code class="literal">xend</code> startup and at domain startup. (There are corresponding scripts for domain shutdown and <code class="literal">xend</code> stop.)<a id="idx-CHP-5-0361" class="indexterm"/></p><p>The role of the script run at <code class="literal">xend</code> startup (usually either <code class="literal">network-bridge</code> or <code class="literal">network-route</code>) is to switch from standard, non-Xen networking to Xen-based networking. In the case of <code class="literal">network-bridge</code>, for example, this script creates a bridge and assigns the physical Ethernet device to it. Then it initializes dom0's networking, creates a virtual interface, adds it to the bridge, and copies the configuration over to the bridged network device.</p><p>When Xen starts a domain, it executes the appropriate <code class="literal">vif-*</code> script—for example, <code class="literal">vif-bridge</code> in the case of <code class="literal">network-bridge</code>. The following shows the various scripts that would be run with the default setup.<a id="idx-CHP-5-0362" class="indexterm"/></p><a id="I_programlisting5_d1e4976"/><pre class="programlisting">(<a id="idx-CHP-5-0363" class="indexterm"/>xend startup)
    |
    |- network-bridge <img src="httpatomoreillycomsourcenostarchimages333215.png.jpg" alt=""/>
        |
        |-xen-script-common.sh
        |-xen-network-common.sh

(xm create)
    |
    |-vif-bridge <img src="httpatomoreillycomsourcenostarchimages333215.png.jpg" alt=""/>
        |
        |-vif-common.sh
            |
            |-xen-hotplug-common.sh
            |   |
            |   |-logging.sh
            |   |-xen-script-common.sh
            |   |-locking.sh
            |
            |-xen-network-common.sh</pre><p>Most of these scripts aren't terribly important to our purposes at the moment. For example, <a id="idx-CHP-5-0364" class="indexterm"/><em class="filename">logging.sh</em> is just sourced to provide a <code class="literal">log()</code> function. The main points we're interested in are the ones marked with <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e5005"/><img src="httpatomoreillycomsourcenostarchimages333215.png.jpg" alt=""/></span>. These are good scripts to edit or good places to introduce a wrapper script.<a id="idx-CHP-5-0365" class="indexterm"/></p><p>These scripts are <a id="idx-CHP-5-0366" class="indexterm"/>bash shell scripts (rather than Python, as one might expect from the fact that many of the other Xen configuration files are in Python). They all live in the <span class="emphasis"><em>/etc/xen/scripts</em></span> directory by default, alongside scripts to support the other classes of Xen virtual devices.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FNOTE-1" href="#CHP-5-FNOTE-1" class="para">33</a>] </sup>The IP command <span class="emphasis"><em>/sbin/ip</em></span> is the modern (unfortunately named) replacement for <code class="literal">ifconfig</code>. Get it as part of the iproute2 tool set, which offers similar functionality to net-tools but with added features.</p></div></div></div>
<div class="sect1" title="Defining Virtual Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="defining_virtual_interfaces"/>Defining Virtual Interfaces</h1></div></div></div><p>All of the Xen <a id="idx-CHP-5-0367" class="indexterm"/>networking options work by <a id="idx-CHP-5-0368" class="indexterm"/>creating virtual interfaces in dom0 to serve as targets for bridging, <code class="literal">iptables</code> rules, and so on. Each virtual interface is defined by a section in the <code class="literal">vif=</code> line of the config file, delimited by a pair of single quotes.<a id="idx-CHP-5-0369" class="indexterm"/></p><p>Xen 3 supports up to eight virtual interfaces per domain (three prior to 3.1.) For example,</p><a id="I_programlisting5_d1e5051"/><pre class="programlisting">vif=['','','']</pre><p>defines three virtual interfaces and tells Xen to configure them with sensible defaults. Note that they're comma-separated <span class="emphasis"><em>and</em></span> delimited, in accord with Python array syntax.</p><p>You can examine these virtual interfaces from the dom0 by typing</p><a id="I_programlisting5_d1e5060"/><pre class="programlisting"># ifconfig -a</pre><p>This will output information for a bunch of devices of the form</p><a id="I_programlisting5_d1e5064"/><pre class="programlisting">vif<em class="replaceable"><code>x</code></em>.<em class="replaceable"><code>y</code></em></pre><p>where <em class="replaceable"><code>x</code></em> and <em class="replaceable"><code>y</code></em> are numbers. (You might see <code class="literal">tap</code> devices as well if you're using HVM. Just treat them like vifs for now.)</p><div class="note" title="Note"><h3 class="title"><a id="note-19"/>Note</h3><p><span class="emphasis"><em>Under recent Red Hat–derived distros (including CentOS 5.1 and Fedora 8), libvirt will create another bridge called</em></span> <a id="idx-CHP-5-0370" class="indexterm"/><em class="replaceable"><code>virbr0</code></em>. <span class="emphasis"><em>This bridge is set up for NAT by default and should be considered part of libvirt, rather than Xen. It functions much like Xen's</em></span> <em class="replaceable"><code>network-nat</code></em> <span class="emphasis"><em>implementation: dom0 runs a dnsmasq server on</em></span> <em class="replaceable"><code>virbr0</code></em> <span class="emphasis"><em>and NAT's packets for domUs. It's a sensible default for a desktop, but probably ill-suited to a server. Specify</em></span> <em class="replaceable"><code>bridge=xenbr0</code></em> <span class="emphasis"><em>to use Xen's bridge, rather than libvirt's. For the curious</em></span>, <em class="replaceable"><code>virbr</code></em> <span class="emphasis"><em>is configured by</em></span> /etc/libvirt/qemu/networks/default.xml. <span class="emphasis"><em>You can disable the</em></span> <em class="replaceable"><code>virbr</code></em> <span class="emphasis"><em>devices by removing the symlink in</em></span> /etc/libvirt/qemu/networks/autostart.</p></div><p>Xen's default behavior is to give each virtual interface a name based on the domain number, where <em class="replaceable"><code>x</code></em> is the domain number and <em class="replaceable"><code>y</code></em> is the sequential number of the interface in the domU. For example, <code class="literal">vif2.0</code> is <code class="literal">eth0</code> in domain 2; <code class="literal">vif2.1</code> is <code class="literal">eth1</code> in domain 2. In addition, each physical network card in the machine will show up as a <code class="literal">peth</code> device (for <span class="emphasis"><em>physical Ethernet</em></span>). <code class="literal">xend</code> creates these virtual interfaces on behalf of domains on domain startup. Thus, you'll see a varying number of them, depending on how many domains are running and how many network devices they have.<a id="idx-CHP-5-0371" class="indexterm"/></p><p>As we've stated before, the dom0 is a domain just like the rest, except for its ability to perform control-plane functions and its access to PCI devices. Therefore, <code class="literal">vif0.0</code> is domain 0's virtual <code class="literal">eth0</code> interface, and <code class="literal">vif0.1</code> is <code class="literal">eth1</code> in the dom0. (Xen conveniently creates an alias from <code class="literal">eth</code><em class="replaceable"><code>X</code></em> to <code class="literal">vif0.</code><em class="replaceable"><code>x</code></em>.)</p><div class="note" title="Note"><h3 class="title"><a id="note-20"/>Note</h3><p><a id="idx-CHP-5-0372" class="indexterm"/><em class="replaceable"><code>veth</code></em> <span class="emphasis"><em>devices also show up in the dom0. Don't worry about them. They're just used as scratch paper while</em></span> <em class="replaceable"><code>xend</code></em> <span class="emphasis"><em>copies information around</em></span>.</p></div><p>Ordinarily you can ignore the vifs while interacting with dom0. However, there are a few things to note: Because <code class="literal">eth0</code> in dom0 is actually an alias for a virtual interface, it only sees traffic directed at dom0—domU traffic never reaches the alias. If you want to see the traffic going to the domUs with <code class="literal">tcpdump</code> or similar in dom0, you must look at the physical Ethernet card—that is, the appropriate <code class="literal">peth</code> interface.</p><p>Also, the <code class="literal">peth</code> might have a strange MAC, usually FF:FF:FF:FF:FF:FF. Because no packets actually originate or terminate at the <code class="literal">peth</code> device, it doesn't need an actual MAC address.</p><p>Finally, the <a id="idx-CHP-5-0373" class="indexterm"/>virtual devices are provided by the netloop driver, and it defaults to only allowing eight virtual devices at a time. This value can be raised by increasing the value of the <code class="literal">nloopbacks</code> parameter:</p><a id="I_programlisting5_d1e5235"/><pre class="programlisting"># modprobe netloop nloopbacks=128</pre><p>If it's built into the kernel, you can boot the dom0 kernel with a higher value for <code class="literal">loopback.nloopbacks</code>. Simply append <code class="literal">netloop.nloopbacks=128</code> (or a similarly large value) to the <code class="literal">module</code> line that loads the Linux kernel in <span class="emphasis"><em>/boot/grub/menu.lst</em></span>.</p><div class="sect2" title="Naming Virtual Interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="naming_virtual_interfaces"/>Naming Virtual Interfaces</h2></div></div></div><p>Accounting for bandwidth usage with this elaborate scheme of virtual interfaces can be tricky. Because the interface names are based on the domain number, and the domain number changes each time the domain reboots, it's impractical to simply monitor bandwidth using the dom0's internal counters—you'll wind up with stuff like this:</p><a id="I_programlisting5_d1e5256"/><pre class="programlisting">vif58.0 RX bytes:12075895 (11.5 MiB)  TX bytes:14584409 (13.9 MiB)</pre><div class="sidebar"><a id="re-indexing_names"/><p class="title">RE-INDEXING NAMES</p><p>If you decide to use vifnames, you should probably note that the <code class="literal">mib</code> number of the interface might change on every reboot of the domU, though the symbolic name will remain the same.</p><p>Some SNMP monitoring software expects <a id="idx-CHP-5-0374" class="indexterm"/>mib numbers to remain the same. When they change, the software interprets this as a new interface of the same name, which makes collecting cumulative statistics … difficult. You can often fix the madness by configuring your SNMP software to aggressively reindex names to numbers, rather than relying on its cache. It's just something to watch out for—not unfixable, but annoying. Check your specific monitoring software for details.</p></div><p>One way around this is to name the <a id="idx-CHP-5-0375" class="indexterm"/>virtual interfaces so that the name becomes independent of the domain number. You can name virtual interfaces from within the domU config file by specifying the <code class="literal">vifname</code> parameter as part of the <code class="literal">vif=</code> configuration directive. For example,</p><a id="I_programlisting5_d1e5284"/><pre class="programlisting">vif=['vifname=http']</pre><p>would cause the <code class="literal">vif</code> in the dom0 to become <code class="literal">http</code> rather than <code class="literal">vif</code><em class="replaceable"><code>x</code></em><code class="literal">.</code><em class="replaceable"><code>y</code></em>. (Within the domain, of course, it just shows up as <code class="literal">eth0</code>.) If the domain has multiple interfaces, specify them as follows:</p><a id="I_programlisting5_d1e5306"/><pre class="programlisting">vif=['vifname=http1', 'vifname=http2']</pre><p>As of this writing, you'll then need to stop and start the domain to force it to reread the config file; a simple reboot won't work.</p><p>With the <code class="literal">vifname</code> specified, we can stop and start the domain. Here we shut <a id="idx-CHP-5-0376" class="indexterm"/>down a domain:</p><a id="I_programlisting5_d1e5321"/><pre class="programlisting"># xm list http.xen
Name ID Mem(MiB) VCPUs State Time(s)
http.xen 6 96 1 -b---- 11358.0
# xm shutdown http.xen
xenbr0: port 8(vif6.0) entering disabled state
device vif6.0 left promiscuous mode
xenbr0: port 8(vif6.0) entering disabled state</pre><p>Note that the device is simply <code class="literal">vif6.0</code>. Now start it up.</p><a id="I_programlisting5_d1e5329"/><pre class="programlisting"># xm create http.xen
Using config file "http.xen".
device http entered promiscuous mode
xenbr0: port 8(http) entering learning state
xenbr0: topology change detected, propagating
xenbr0: port 8(http) entering forwarding state
Started domain http.xen.prgmr.com

# cat http.xen.prgmr.com | grep vifname
vif = [ 'vifname=http, bridge=xenbr0' ]</pre><div class="sidebar"><a id="truncated_vifnames"/><p class="title">TRUNCATED VIFNAMES</p><p>Linux silently truncates the <code class="literal">vifname</code> to 15 characters—it'll ignore any input beyond that without raising an error. Thus, for a <code class="literal">vif named wiki.xen.prgmr.com</code>,</p><a id="I_programlisting5_d1e5342"/><pre class="programlisting"># ifconfig wiki.xen.prgmr.</pre><p>first 15 characters, including the dot) or</p><a id="I_programlisting5_d1e5346"/><pre class="programlisting"># ifconfig wiki.xen.prgmr.com</pre><p>or</p><a id="I_programlisting5_d1e5350"/><pre class="programlisting"># ifconfig wiki.xen.prgmr.foo.bar.baz</pre><p>will work, but</p><a id="I_programlisting5_d1e5354"/><pre class="programlisting"># ifconfig wiki.xen</pre><p>will fail with an <code class="literal">ENODEV</code> (a "no such device" or "device not found" error).</p><p>Note that 15-character vifnames cause problems with some versions of iptables. Keep your vifnames to 8 characters to be safe.</p></div></div><div class="sect2" title="Autoconfiguration"><div class="titlepage"><div><div><h2 class="title"><a id="autoconfiguration"/>Autoconfiguration</h2></div></div></div><p>You can just leave the <code class="literal">vif=</code> line blank and let <code class="literal">xm</code> generate the entire configuration automatically, like so:<a id="idx-CHP-5-0377" class="indexterm"/></p><a id="I_programlisting5_d1e5379"/><pre class="programlisting">vif = ['']</pre><p>This scenario has the advantage of allowing the domU administrator to configure the network with complete freedom from within the domU, using whatever tools are most convenient. This is the most accurate way of simulating a physical machine. Xen can generate IP and MAC addresses itself, if need be, and configure them to work without administrator intervention.</p><p>However, we don't recommend this because it leaves configuration of the network interface up to the users. At a minimum, you should specify the IP address so that Xen can set up the antispoofing rules to prevent an attacker with a Xen instance faking the source or destination address in his IP header, and specify a MAC address to avoid the possiblity of conflict. An IP or MAC address conflict can take down your network! Avoid it if at all possible.</p><div class="sidebar"><a id="mysterious_increasing_interface_numbers"/><p class="title">MYSTERIOUS INCREASING INTERFACE NUMBERS</p><p>One other problem that you can avoid by <a id="idx-CHP-5-0378" class="indexterm"/>specifying a MAC address is the domU becoming confused when the address changes on each boot—on some systems it'll believe that each new address is a new card, so that it uses eth1 on the second boot, eth2 on the third, and so on. Upon seeing the new MAC address, <a id="idx-CHP-5-0379" class="indexterm"/>udev believes it's found a new card.</p><p>The easy solution is to specify a MAC address in the domain config file, and clear out udev's cache in <span class="emphasis"><em>/etc/udev/rules.d/z25_persistent-net.rules</em></span>. This should cause the device to come up as eth0 on the next boot and stay eth0, since it's not getting a random address anymore.</p></div></div><div class="sect2" title="Specifying a MAC Address"><div class="titlepage"><div><div><h2 class="title"><a id="specifying_a_mac_address"/>Specifying a MAC Address</h2></div></div></div><p>Ordinarily, in the absence of virtualization, hardware manufacturers do a good job of ensuring that each Ethernet device has a unique MAC address. With Xen, however, it becomes the administrator's responsibility to ensure that each virtual interface has a unique hardware address.<a id="idx-CHP-5-0380" class="indexterm"/></p><p>First, think back for a moment to the <a id="idx-CHP-5-0381" class="indexterm"/>7-layer OSI network model. Xen interacts with this model at layers 2 and 3; that is, it provides a virtual layer 2 switch with <code class="literal">network-bridge</code> and functions as an IP router with <code class="literal">network-route</code>. Both of these layers require the Xen domain to have a unique address. The antispoof rules and <code class="literal">ip</code> directive can take care of that for layer 3; however, you are also likely going to want to specify a MAC address.</p><p>Xen can simply make one up, but this results in a relatively high probability of a collision. When Xen picks a MAC for you, it starts with the 00:16:3e prefix assigned to Xen by the IEEE registration authority, and it picks the remaining three bytes at random; this means you have 3 bytes of entropy. At 1,000 hosts on one network (most of a /22) this gives you something like a 3 percent chance of a collision. (You can calculate this using the birthday paradox—a good use for your obscure math trivia.) Considering the huge yuckiness of a MAC address conflict, we suggest always manually specifying the MAC address. Do this by changing your <code class="literal">vif=</code> line to include a <code class="literal">mac=</code> section, like so:</p><a id="I_programlisting5_d1e5438"/><pre class="programlisting">vif= ['ip="10.0.0.1",mac="ae:00:01:02:03:04"']</pre><p>Here at prgmr.com, we pick a 2-byte prefix and append the IP address in hex because the IP address is already unique. There are some important rules when doing this, though: First, the most significant bit should be zero; second, the address should be part of the "locally assigned" block to avoid possible conflicts with real Ethernet hardware. Fortunately, these rules can be distilled into a basic formula: Make the second hex digit of the first octet (<span class="emphasis"><em>e</em></span> in the above example) one of 2, 6, A, or E. (Of course, you can avoid having to worry about this by using the Xen prefix mentioned above.)</p></div></div>
<div class="sect1" title="Manipulating vifs with xm"><div class="titlepage"><div><div><h1 class="title"><a id="manipulating_vifs_with_xm"/>Manipulating vifs with xm</h1></div></div></div><p>Although we ordinarily modify <a id="idx-CHP-5-0382" class="indexterm"/>networking settings indirectly through the config files, it's also possible to make changes directly <a id="idx-CHP-5-0383" class="indexterm"/>using <code class="literal">xm</code>.</p><p>The relevant commands are <code class="literal">network-attach</code> and <code class="literal">network-detach</code>. Using <code class="literal">network-attach</code>, you can create a new virtual NIC as if it had been specified in the config file, <a id="idx-CHP-5-0384" class="indexterm"/>with options specified on the command line. For example,</p><a id="I_programlisting5_d1e5480"/><pre class="programlisting">xm network-attach wiki.xen.prgmr.com script=network-bridge mac=00:16:3e:02:ac:7d bridge=xenbr0</pre><p>If you don't specify the various parameters, Xen will supply default values, just as if they'd been unspecified in the <code class="literal">vif=</code> line of the config file.</p><p>Similarly, <code class="literal">network-detach</code> will detach a <code class="literal">vif</code> from the <a id="idx-CHP-5-0385" class="indexterm"/>domU and destroy it.</p><a id="I_programlisting5_d1e5499"/><pre class="programlisting">xm network-detach wiki.xen.prgmr.com 0</pre><p>The preceding command will remove <code class="literal">eth0</code> from the domain <a class="ulink" href="http://wiki.xen.prgmr.com">wiki.xen.prgmr.com</a>.</p></div>
<div class="sect1" title="Securing Xen's Virtual Network"><div class="titlepage"><div><div><h1 class="title"><a id="securing_xens_virtual_network"/>Securing Xen's Virtual Network</h1></div></div></div><p>From a security standpoint, there are two aspects of Xen networking that bear mentioning. First, we want to make sure that the users can't pretend to be someone they're not. This is addressed by <a id="idx-CHP-5-0386" class="indexterm"/>specifying an IP address and enabling the <a id="idx-CHP-5-0387" class="indexterm"/>antispoofing rules. Second, we want to protect the dom0 while letting traffic through to the domUs. This is easily handled by appropriate <code class="literal">iptables</code> rules.</p><div class="sect2" title="Specifying an IP Address"><div class="titlepage"><div><div><h2 class="title"><a id="specifying_an_ip_address"/>Specifying an IP Address</h2></div></div></div><p>The <a id="idx-CHP-5-0388" class="indexterm"/>antispoofing rules use <code class="literal">iptables</code> to ensure that the Xen box will <a id="idx-CHP-5-0389" class="indexterm"/>drop packets that don't match the expected address for the <code class="literal">vif</code> that they're coming from, thus protecting your network from a rogue domU. The network scripts set this up using <code class="literal">iptables</code> to add a rule to the FORWARD chain allowing packets that match that IP address to pass to the domU's network device. (The function that does this is in <span class="emphasis"><em>vif-common.sh</em></span>, for the curious.) For this to work, your FORWARD chain should have a policy of DROP—<code class="literal">network-bridge</code> should handle that automatically.<a id="idx-CHP-5-0390" class="indexterm"/></p><p>We use antispoofing with <code class="literal">network-bridge. network-route</code> adds similar rules. It's known to not work with <code class="literal">network-nat</code>.</p><p>Add the following to <span class="emphasis"><em>/etc/xen/xend-config.sxp</em></span>:</p><a id="I_programlisting5_d1e5576"/><pre class="programlisting">(network-script 'network-bridge antispoof=yes')</pre><p>and set the following in the domain config file:</p><a id="I_programlisting5_d1e5580"/><pre class="programlisting">vif=['ip=10.0.0.1',bridge=xenbr0]</pre><p>(Use an appropriate IP and bridge <a id="idx-CHP-5-0391" class="indexterm"/>for your site, obviously.)</p><p>You can also specify a range of IP addresses in <a id="idx-CHP-5-0392" class="indexterm"/>CIDR format (<span class="emphasis"><em>CIDR</em></span> stands for <span class="emphasis"><em>Classless Inter-Domain Routing</em></span>); that is, with a slash and the number of bits set in the netmask, in decimal. For example, to allow 10. anything, the previous line could be rewritten as</p><a id="I_programlisting5_d1e5602"/><pre class="programlisting">vif=['ip=10.0.0.1/8']</pre><p>This doesn't keep the domU administrator from changing the domU's IP address, but it does block any packets from that changed IP address.</p></div><div class="sect2" title="Firewalling the Dom0"><div class="titlepage"><div><div><h2 class="title"><a id="firewalling_the_dom0"/>Firewalling the Dom0</h2></div></div></div><p>With Xen's networking, the INPUT and <a id="idx-CHP-5-0393" class="indexterm"/>OUTPUT chains don't affect packets aimed at the domUs. Thus, standard firewalls on the <a id="idx-CHP-5-0394" class="indexterm"/>INPUT chain, like Red Hat's, won't affect <a id="idx-CHP-5-0395" class="indexterm"/>domU packets. (domUs themselves, of course, can firewall their own virtual network devices as needed.)<a id="idx-CHP-5-0396" class="indexterm"/></p><div class="note" title="Note"><h3 class="title"><a id="note-21"/>Note</h3><p><span class="emphasis"><em>Many systems, by default, don't send bridge traffic through the FORWARD chain as you would expect—RHEL/CentOS 5.1 is an example of this problem. This causes the antispoofing rules to not work. A simple</em></span> <em class="replaceable"><code>echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables</code></em> <span class="emphasis"><em>solves the problem. Add that line to</em></span> /etc/xen/scripts/network-bridge <span class="emphasis"><em>to have it run automatically when Xen sets up its networking</em></span>.<a id="idx-CHP-5-0397" class="indexterm"/></p></div><p>The only problem that we've seen with sending domU packets through the FORWARD chain is that, by default, the dom0 includes them in its connection tracking. On heavily loaded machines, the connection table will fill up, and the machine will drop packets. Our solution is to edit the <code class="literal">frob_iptable()</code> function in <code class="literal">vif-bridge</code> to include a rule like the following:</p><a id="I_programlisting5_d1e5653"/><pre class="programlisting">iptables -t raw "$c" PREROUTING -m physdev --physdev-in "$vif" "$@" -j NOTRACK</pre><p>This lets antispoof work and keeps the domU traffic from interfering with the dom0, while allowing the domUs to have unhindered access to their packets.</p></div></div>
<div class="sect1" title="Networking with network-route"><div class="titlepage"><div><div><h1 class="title"><a id="networking_with_network-route"/>Networking with network-route</h1></div></div></div><p><code class="literal">network-route</code> is the original option chosen by the Xen team (and few have used it since). It works by creating an internal IP router, which forwards traffic to and from the guest domains. Note that it doesn't do address translation—for that you'll want <code class="literal">network-nat</code>, or <code class="literal">virbr</code>. It has largely been superseded by <code class="literal">network-bridge</code>, which allows considerably more flexibility.<a id="idx-CHP-5-0398" class="indexterm"/></p><p><code class="literal">network-route</code> does have its place, however. For one thing, it is transparent to the upstream network hardware, unlike <code class="literal">network-bridge</code>. For another thing, it's much simpler. <code class="literal">network-route</code> simply enables IP forwarding and then creates <code class="literal">iptables</code> rules in the dom0 to forward traffic to the correct virtual interfaces.</p><p>To use <code class="literal">network-route</code>, just uncomment the lines<a id="idx-CHP-5-0399" class="indexterm"/></p><a id="I_programlisting5_d1e5698"/><pre class="programlisting">(network-script network-route)
(vif-script vif-route)</pre><p>and comment out the corresponding <code class="literal">network-bridge</code> and <code class="literal">vif-bridge</code> lines. That's really all there is to it. Restart <code class="literal">xend</code>, and <code class="literal">iptables</code> will show a new rule that handles forwarding to the <code class="literal">vif</code>:</p><a id="I_programlisting5_d1e5717"/><pre class="programlisting"># iptables -L FORWARD
Chain FORWARD (policy ACCEPT)
target prot opt source          destination
ACCEPT 0    --  192.168.42.190  anywhere PHYSDEV match --physdev-in n1
ACCEPT udp  --  anywhere        anywhere PHYSDEV match --physdev-in n1 udp spt:bootpc dpt:bootps</pre><p>One common "gotcha" with <code class="literal">network-route</code> is that it only works if the IP address is specified in the <code class="literal">vif=</code> line—otherwise the script doesn't know what rules to add. So, at minimum, the interface definition for the example above should look like this:</p><a id="I_programlisting5_d1e5727"/><pre class="programlisting">vif = ['ip="192.168.42.190",vifname="n1"']</pre></div>
<div class="sect1" title="Networking with network-bridge"><div class="titlepage"><div><div><h1 class="title"><a id="networking_with_network-bridge"/>Networking with network-bridge</h1></div></div></div><p><code class="literal">network-bridge</code> is the currently accepted standard way of handling networking for <a id="idx-CHP-5-0400" class="indexterm"/>guest domains in Xen. It uses the <a id="idx-CHP-5-0401" class="indexterm"/>bridge tools in Linux to create a virtual layer 2 switch, to which it "plugs in" Xen virtual interfaces, as shown in <a class="xref" href="ch05s06.html#some_of_network-bridges_capabilities" title="Figure 5-1. Some of network-bridge's capabilities">Figure 5-1</a>. It has the advantage of working with protocols that expect unadulterated Ethernet frames. This includes AoE, the pre-TCP/IP version of AppleTalk, NetBEUI, IPX, and a host of other protocols that date from the dark ages. It'll also work seamlessly with DHCP, which relies on broadcast packets. It's simple, logical, and robust.<a id="idx-CHP-5-0402" class="indexterm"/></p><p>The biggest disadvantage of <code class="literal">network-bridge</code> (apart from its complexity) is that it tears down and rebuilds the real network interface when <code class="literal">xend</code> starts. In some scenarios (for example, when dom0 has an NFS root) this can be unacceptable. This isn't a limitation of bridging, per se, only of attaching the bridge to the dom0 network device using the Xen scripts—if a dedicated physical device is used for the bridge, the problem goes away.</p><p>Another issue with <code class="literal">network-bridge</code> is that it places the physical Ethernet device into promiscuous mode. This can be a tremendous resource hog on busy networks because the CPU has to intercept all packets rather than just those intended for its address. Finally, outgoing packets will have a different MAC address from the one on the physical card, which can lead to trouble with, for example, certain wireless networking hardware. This also throws many layer 2 http load balancers through a loop—anything that expects only one MAC address down each Ethernet port will be sorely confused.</p><div class="figure"><a id="some_of_network-bridges_capabilities"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5767"/><img src="httpatomoreillycomsourcenostarchimages333217.png.jpg" alt="Some of network-bridge's capabilities"/></div></div><p class="title">Figure 5-1. Some of network-bridge's capabilities</p></div><p>Even with these caveats, we recommend <code class="literal">network-bridge</code> for most Xen servers.<a id="idx-CHP-5-0403" class="indexterm"/></p><p>You can start the <code class="literal">network-bridge</code> script by hand if you like. For example, to manually create a bridge with the default name <code class="literal">xenbr0</code> attached to <code class="literal">eth0</code>, type the following:</p><a id="I_programlisting5_d1e5791"/><pre class="programlisting">/etc/xen/scripts/network-bridge {start|stop} <a id="idx-CHP-5-0404" class="indexterm"/>vifnum=0</pre><div class="note" title="Note"><h3 class="title"><a id="note-22"/>Note</h3><p><span class="emphasis"><em>If you have</em></span> <em class="replaceable"><code>vifnum</code></em> <span class="emphasis"><em>set above</em></span> <em class="replaceable"><code>nloopbacks</code></em>, <span class="emphasis"><em>even if you only have one bridge, Linux will complain as if you had more bridges than loopbacks. This is because Xen uses the</em></span> <em class="replaceable"><code>vifnum</code></em> <span class="emphasis"><em>to determine the number of the virtual device it uses for the frontend, which presupposes the existence of the preceding virtual devices. Increase</em></span> <em class="replaceable"><code>nloopbacks</code></em>, <span class="emphasis"><em>and everyone is happy</em></span>.</p></div><p><code class="literal">network-bridge</code> is the default <a id="idx-CHP-5-0405" class="indexterm"/>networking option, thus <code class="literal">xend</code> shouldn't need any configuration to use it. However, for completeness—to configure Xen to use <code class="literal">network-bridge</code>, modify <em class="filename">xend-config.sxp</em> to include the line</p><a id="I_programlisting5_d1e5846"/><pre class="programlisting">(network-script network-bridge)</pre><div class="note" title="Note"><h3 class="title"><a id="note-23"/>Note</h3><p><span class="emphasis"><em>OpenSUSE users might find that NetworkManager interferes with Xen's bridging. To fix this problem, go to</em></span> <span class="bolditalic">YaST ► Network Devices ► Network Card</span> <span class="emphasis"><em>and select the</em></span> <span class="bolditalic">Traditional Method with ifup</span> <span class="emphasis"><em>option</em></span>.<a id="idx-CHP-5-0406" class="indexterm"/></p></div><p>This script causes Xen to use a <a id="idx-CHP-5-0407" class="indexterm"/>bridge setup much like the following:</p><a id="I_programlisting5_d1e5875"/><pre class="programlisting"># brctl show
bridge name   bridge id           <a id="idx-CHP-5-0408" class="indexterm"/>STP enabled  interfaces
xenbr0        8000.feffffffffff   no           vif0.0
                                               peth0
                                               vif9.0</pre><p><code class="literal">xenbr0</code> is, obviously, the name of the bridge. It bridges dom0's virtual Ethernet interface (<code class="literal">vif0.0</code>), the physical Ethernet card, and a domU's virtual interface. We can also see that STP (<a id="idx-CHP-5-0409" class="indexterm"/>Spanning Tree Protocol) is disabled. In the default configuration, further domUs will simply have their interfaces added to this bridge.</p><p>STP is aimed at preventing loops in the network. You may want to turn STP on if you're doing anything complex with the virtual bridges. If you have multiple bridges and multiple network ports that you're <a id="idx-CHP-5-0410" class="indexterm"/>using with Xen, it would probably be a good idea.</p><p>To rename the bridge, you can specify the bridge name as an option to the <code class="literal">network-bridge</code> script:</p><a id="I_programlisting5_d1e5905"/><pre class="programlisting">(network-script 'network-bridge bridge=foo')</pre><p>Note also that <code class="literal">network-bridge</code> defaults to binding <code class="literal">eth0</code> to the bridge. To change the physical network card, use</p><a id="I_programlisting5_d1e5915"/><pre class="programlisting">(network-script 'network-bridge bridge=foo netdev=eth1')</pre><p>Then the bridge setup becomes</p><a id="I_programlisting5_d1e5919"/><pre class="programlisting"># brctl show
bridge name   bridge id          STP enabled   interfaces
foo           8000.feffffffffff  no            vif0.01
                                               peth01
                                               vif9.0</pre></div>
<div class="sect1" title="Networking with network-nat"><div class="titlepage"><div><div><h1 class="title"><a id="networking_with_network-nat"/>Networking with network-nat</h1></div></div></div><p><code class="literal">network-nat</code> is an extension of <code class="literal">network-route</code> that incorporates network address translation (NAT for short, or <a id="idx-CHP-5-0411" class="indexterm"/>IP masquerade in some contexts).<a id="idx-CHP-5-0412" class="indexterm"/><a id="idx-CHP-5-0413" class="indexterm"/></p><p>The <code class="literal">network-nat</code> script supplied with Xen works around <code class="literal">network-route</code>'s problem with DHCP in two ways. First, it can start a local DHCP server (so that <a id="idx-CHP-5-0414" class="indexterm"/>guest domains can get addresses because they're now behind a router). If that's undesirable, it can create locally unique IP addresses using the domain ID. Then it sets up a standard <code class="literal">iptables</code> rule for IP <code class="literal">masq</code>:</p><a id="I_programlisting5_d1e5961"/><pre class="programlisting">Dom0 # iptables -t nat -n -L
Chain POSTROUTING (policy ACCEPT)
target prot opt source destination
MASQUERADE 0 -- 0.0.0.0/0 0.0.0.0/0
Dom0 # iptables -L FORWARD
Chain FORWARD (policy ACCEPT)
target prot opt source destination
ACCEPT 0 -- 10.0.0.0/16 anywhere PHYSDEV
match --physdev-in n1
ACCEPT udp -- anywhere anywhere PHYSDEV
match --physdev-in n1 udp spt:bootpc dpt:bootps</pre><p>When a domain starts, it gets an <a id="idx-CHP-5-0415" class="indexterm"/>IP address and adds appropriate <code class="literal">iptables</code> rules for itself. Xen passes the address to the kernel <a id="idx-CHP-5-0416" class="indexterm"/>using the kernel-level IP autoconfiguration mechanism at boot (and isn't that a mouthful). <code class="literal">network-nat</code> can also integrate <a id="idx-CHP-5-0417" class="indexterm"/>with your DHCP server.<a id="idx-CHP-5-0418" class="indexterm"/></p><a id="I_programlisting5_d1e5991"/><pre class="programlisting">DomU # ifconfig eth0 10.0.2.1/16
DomU # route add default gw 10.0.2.1
DomU # ping 192.168.42.60
PING 192.168.42.60 (192.168.42.60) 56(84) bytes of data.
64 bytes from 192.168.42.60: icmp_seq=1 ttl=63 time=1.94 ms</pre><p>This shows the default configured IP address for <code class="literal">eth0</code> in domain 2. Actual numbers will vary depending on your setup, of course.</p></div>
<div class="sect1" title="Configuration Variables"><div class="titlepage"><div><div><h1 class="title"><a id="configuration_variables"/>Configuration Variables</h1></div></div></div><p>As we've mentioned, the two basic places where the administrator interacts with Xen's networking are in <span class="emphasis"><em>/etc/xen/xend-config.sxp</em></span> and in the domain config file. In each of these, you focus on one line: the <code class="literal">(network-script)</code> line in the former case and the <code class="literal">vif=</code> line in the latter.</p><p>Each of these will fail horribly, without explanation, over trivial errors in syntax. (This is Python, after all. You can put arbitrary Python code right in your config files, if you like. Configuration files should always be written in a language that's Turing-complete. Just ask Eric Allman.)</p><p>The <code class="literal">network-script</code> line is wrapped in parentheses, with arguments in quotes and separated by spaces. For example, the following is valid:</p><a id="I_programlisting5_d1e6019"/><pre class="programlisting">(network-script 'network-bridge bridge=xenbr1')</pre><p>We've already discussed the <code class="literal">vif=</code> line a bit. Note that the <code class="literal">vif</code> configuration uses a completely different syntax from the network script setting, though: brackets with commas between arguments.</p><a id="I_programlisting5_d1e6029"/><pre class="programlisting">vif = ['','bridge=xenbr1','bridge=xenbr2,ip="10.1.2.6"']</pre><p>This line configures three interfaces, the first with default parameters, the second with a bridge argument, the third with bridge and IP. Note the commas between both separate interfaces and separate arguments.</p><p>Finally, in some examples you will see a <code class="literal">dhcp=yes</code> line. The <code class="literal">dhcp=</code> line isn't necessary unless the kernel needs to get its address at boot—for example, if it's mounting its root filesystem over NFS.<a id="idx-CHP-5-0419" class="indexterm"/></p></div>
<div class="sect1" title="Custom Network Scripts"><div class="titlepage"><div><div><h1 class="title"><a id="custom_network_scripts"/>Custom Network Scripts</h1></div></div></div><p>You might be thinking at this point that it's overkill to specify a configuration script in the Xen config file rather than simply selecting among built-in options. Take our word <a id="idx-CHP-5-0420" class="indexterm"/>for it: The ability to specify your own network script is fantastically useful. Because Xen's networking is built on standard tools, the scripts are easy to understand and tailor to your particular needs.</p><p>The easiest way to do this, and a sufficient method for most configurations, is to create a small <a id="idx-CHP-5-0421" class="indexterm"/>wrapper script that calls the standard Xen scripts with appropriate arguments. You can also modify the standard scripts to source additional functions and call those as necessary—for example, to modify firewall rules or attach monitoring scripts.</p><div class="sect2" title="Multiple-Bridge Setups"><div class="titlepage"><div><div><h2 class="title"><a id="multiple-bridge_setups"/>Multiple-Bridge Setups</h2></div></div></div><p>Consider a scenario where you want inter-domU communication to occur on a purely virtual network, with a separate interface in each domain to communicate with the outside world.<a id="idx-CHP-5-0422" class="indexterm"/></p><p>In that case, you would create a pair of bridges, one with the default Xen setup, bridging the physical interface with the virtual ones, and one that bridges only virtual interfaces. Then you would specify both interfaces in the domain config file and configure them as normal from within the domain or the config file.</p><p>The wrapper would look something like this:</p><a id="I_programlisting5_d1e6075"/><pre class="programlisting">#!/bin/sh
dir=$(dirname "$0")
"$dir/network-bridge" "$@" vifnum=0
"$dir/network-bridge" "$@" vifnum=1 netdev=dummy0</pre><p>This calls <code class="literal">network-bridge</code> <a id="idx-CHP-5-0423" class="indexterm"/>twice, the first time as normal and the second time with a <code class="literal">netdev</code> argument, <a id="idx-CHP-5-0424" class="indexterm"/>causing <code class="literal">network-bridge</code> to use a dummy network device rather than a real one.</p><p>To tell <code class="literal">xend</code> to run this script at startup, change the <code class="literal">network-script</code> line in <em class="filename">xend-config.sxp</em> as follows:</p><a id="I_programlisting5_d1e6111"/><pre class="programlisting">(network-script my-wrapper)</pre><p>Make sure that the <code class="literal">my-wrapper</code> script is executable, or else nothing will work.</p><p>To use these bridges from the domUs, specify the correct bridge in the <code class="literal">vif=</code> line:</p><a id="I_programlisting5_d1e6123"/><pre class="programlisting">vif= ['mac="aa:0:1:2:3:4",bridge="xenbr1"']</pre></div><div class="sect2" title="Bridged and Routing"><div class="titlepage"><div><div><h2 class="title"><a id="bridged_and_routing"/>Bridged and Routing</h2></div></div></div><p>A slight modification to this scenario puts the <a id="idx-CHP-5-0425" class="indexterm"/>domU communication on its own bridge, which is then routed via <code class="literal">iptables</code> rules in the dom0, as shown in <a class="xref" href="ch05s09.html#combining_bridging_and_routing" title="Figure 5-2. Combining bridging and routing">Figure 5-2</a>. (Arjen <a id="idx-CHP-5-0426" class="indexterm"/>Runsink, who wrote a script that does this, calls this a <span class="emphasis"><em>brouter</em></span>—a portmanteau of bridge and router.)<a id="idx-CHP-5-0427" class="indexterm"/><a id="idx-CHP-5-0428" class="indexterm"/></p><div class="figure"><a id="combining_bridging_and_routing"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e6158"/><img src="httpatomoreillycomsourcenostarchimages333219.png.jpg" alt="Combining bridging and routing"/></div></div><p class="title">Figure 5-2. Combining bridging and routing</p></div><p>This creates a standard bridge, but it doesn't attach the physical device to it. Instead the bridge gets an IP address and a route. When a domU starts, its <code class="literal">vif</code> is attached to the bridge by the ordinary <code class="literal">vif-bridge</code> script.<a id="idx-CHP-5-0429" class="indexterm"/></p><p>Omitting the standard functions and such, the script looks something like this:</p><a id="I_programlisting5_d1e6176"/><pre class="programlisting">#!/bin/sh
dir=$(dirname "$0")
. "$dir/xen-script-common.sh"
. "$dir/xen-network-common.sh"

findCommand "$@"
evalVariables "$@"

op_start () {
    if [ ""${bridge}" = "null" ] ; then
         return
    fi

    create_bridge ${bridge}
    if link_exists "${bridge}" ; then
        ip address add dev $bridge $bridgeip
        ip link set ${bridge} up arp on
        ip route add to $brnet dev $bridge
    fi

    if [ ${antispoof} = 'yes' ] ; then
         antispoofing
    fi
}

op_stop () {
    ip route del to $brnet dev $bridge
    ip link set ${bridge} down arp off
    ip address del dev $bridge $bridgeip
    brctl delbr ${bridge}
}

case "$command" in
    start)
        op_start
        ;;
    stop)
        op_stop
        ;;
    *)
        echo "Unknown command: $command" &gt;&amp;2
        echo 'Valid commands are: start, stop' &gt;&amp;2
        exit 1
esac</pre><p>We've cut out the <code class="literal">show_status</code> function to save space; the full version of this script is available at <a class="ulink" href="http://en.opensuse.org/Xen3_and_a_Virtual_Network">http://en.opensuse.org/Xen3_and_a_Virtual_Network</a>. We've also removed the default values for parameters like <code class="literal">$bridgeip</code> because that's site specific, and we removed the declarations for <code class="literal">create_bridge</code> and <code class="literal">add_to_bridge</code> because those are provided by <code class="literal">xen-network-common</code>.</p><p>Call this script with a pair of lines like the following in <span class="emphasis"><em>/etc/xen/xend-config.sxp</em></span>:</p><a id="I_programlisting5_d1e6203"/><pre class="programlisting">(network-script 'network-virtual bridgeip="10.0.0.1/24" brnet="10.0.0.1/24"')
(vif-script vif-bridge)</pre></div></div>
<div class="sect1" title="Further Thoughts"><div class="titlepage"><div><div><h1 class="title"><a id="further_thoughts"/>Further Thoughts</h1></div></div></div><p>Variants of this same technique can be used to provide logging and accounting on a per-domain basis, or they can set up domain-specific firewall rules just by editing the network scripts. Ultimately, Xen's networking infrastructure is so flexible that you're able to do anything with a domU that you can with the dom0 (or, for that matter, with a non-Xen system), and there are enough script hooks to do it in an automated fashion.</p></div></body></html>