- en: Chapter 8. ARGUMENTS AND DOCUMENTATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。ARGUMENTS AND DOCUMENTATION
- en: '![ARGUMENTS AND DOCUMENTATION](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![ARGUMENTS AND DOCUMENTATION](../Images/00001.jpg)'
- en: In this chapter, we will revisit some earlier scripts and tie them into a single,
    larger script. In doing so, we can abstract functions that are similar between
    each element. This abstraction not only saves space, it also results in larger
    chunks of reusable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些早期的脚本并将它们整合到一个更大的脚本中。通过这样做，我们可以抽象出每个元素之间相似的功能。这种抽象不仅节省了空间，还产生了更大的可重用代码块。
- en: To begin consolidating the scripts, we are going to rely on a library that will
    tie in essential parts of the scripts and allow a user to access specific functions
    through the command line. The library is called GetoptLong, because it gets options
    from the implied argument vector (or the command line). Many times, when a script
    is written, there may be more than one task available to the user. Instead of
    running the entire script, we can let the user pick and choose functions based
    on his or her needs. Not only will the library enable us to use command-line arguments
    to set up different cases, but it will also replace the "in-house" argument check
    used throughout the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始合并脚本，我们将依赖一个库，该库将结合脚本的关键部分，并允许用户通过命令行访问特定的函数。这个库被称为GetoptLong，因为它从隐含的参数向量（或命令行）中获取选项。很多时候，当编写脚本时，可能对用户有多个任务可用。我们不必运行整个脚本，而是可以让用户根据自己的需求选择和选择函数。这个库不仅使我们能够使用命令行参数设置不同的案例，而且还将替换书中使用的“内部”参数检查。
- en: Another tool that will complement GetoptLong is RDoc. RDoc helps format our
    code's usage statements and documentation. Specifically, RDoc will generate structured
    HTML documentation from Ruby source code (for more information about RDoc and
    to download the application, visit [http://rdoc.sourceforge.net/](http://rdoc.sourceforge.net/)).
    Another "in-house" chunk of code seen throughout the previous scripts were the
    usage statements—RDoc can replace this chunk of code and help us maintain consistency
    in our documentation. These libraries will also give a professional appearance
    to the scripts by formatting the usage statements and output in a predictable,
    common way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将补充GetoptLong的工具是RDoc。RDoc帮助我们格式化代码的使用说明和文档。具体来说，RDoc将从Ruby源代码生成结构化的HTML文档（有关RDoc的更多信息以及下载应用程序，请访问[http://rdoc.sourceforge.net/](http://rdoc.sourceforge.net/)）。在前面的脚本中看到的另一个“内部”代码块是使用说明——RDoc可以替换这个代码块并帮助我们保持文档的一致性。这些库还将通过以可预测、常见的方式格式化使用说明和输出，使脚本看起来更专业。
- en: File Security
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件安全
- en: File Security
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件安全
- en: fileSecurity.rb
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fileSecurity.rb
- en: Two scripts that are prime for consolidation are the encryption and decryption
    scripts from [Chapter 1](../Text/dummy_split_012.html#filepos91052) ("#2 Encrypt
    a File" on [Hacking the Script](../Text/dummy_split_019.html#filepos107737) and
    "#3 Decrypt a File" on [Hacking the Script](../Text/dummy_split_026.html#filepos119276)).
    To recap what these scripts did, the encrypt script scrambled data into ciphertext,
    and the decrypt script decoded the ciphertext back into plaintext. Both scripts
    used the Blowfish encryption algorithm and a password chosen by the user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 两个非常适合合并的脚本是从[第1章](../Text/dummy_split_012.html#filepos91052)（在[Hacking the
    Script](../Text/dummy_split_019.html#filepos107737)上的“#2 Encrypt a File”和[Hacking
    the Script](../Text/dummy_split_026.html#filepos119276)上的“#3 Decrypt a File”）中的加密和解密脚本。为了回顾这些脚本的功能，加密脚本将数据打乱成密文，解密脚本将密文解码回明文。这两个脚本都使用了Blowfish加密算法和用户选择的密码。
- en: The Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) # == Synopsis   #   #  fileSecurity.rb: encrypts
    and decrypts files, demonstrates encryption algorithms   #   #   # == Usage   #
      # encryption [OPTIONS] ... FILE   #   # -h, --help:   #    show help   #   #
    --encrypt key, -e key   #    encrypt file with password   #   # --decrypt key,
    -d key   #    decrypt file with password   #   # FILE: The file that you want
    to encrypt/decrypt    require ''getoptlong''   require ''rdoc/ri/ri_paths''   require
    ''rdoc/usage''   require ''crypt/blowfish''    def encrypt(file, pass)       c
    = "Encrypted_#{file}"        if File.exists?(c)           puts "\nFile already
    exists."           exit       end            begin           # initialize the
    encryption method using the user input key           blowfish = Crypt::Blowfish.new(pass)
              blowfish.encrypt_file(file.to_str, c)       # encrypt the file     
         puts "\nEncryption SUCCESS!"       rescue Exception => e           puts "An
    error occurred during encryption: \n #{e}"       end   end    def decrypt(file,
    pass)       p = "Decrypted_#{file}"        if File.exists?(p)           puts "\nFile
    already exists."           exit       end        begin           # initialize
    the decryption method using the user input key           blowfish = Crypt::Blowfish.new(pass)
              blowfish.decrypt_file(file.to_str, p)           # decrypt the file   
           puts "\nDecryption SUCCESS!"       rescue Exception => e           puts
    "An error occurred during decryption: \n #{e}"       end   end   ![](../Images/00003.jpg) opts
    = GetoptLong.new(       [ ''--help'', ''-h'', GetoptLong::NO_ARGUMENT ],     
     [ ''--encrypt'', ''-e'', GetoptLong::REQUIRED_ARGUMENT ],       [ ''--decrypt'',
    ''-d'', GetoptLong::REQUIRED_ARGUMENT ]   )  ![](../Images/00004.jpg) unless ARGV[0]
          puts "\nYou did not include a filename (try --help)"       exit   end    filename
    = ARGV[-1].chomp  ![](../Images/00005.jpg) opts.each do |opt, arg|       case
    opt       when ''--help''           RDoc::usage       when ''--encrypt''     
         encrypt(filename, arg)       when ''--decrypt''           decrypt(filename,
    arg)       else           RDoc::usage       end   end`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) # == 概述   #  #  fileSecurity.rb: 加密和解密文件，演示加密算法   #
     #  # == 用法   #  # encryption [选项] ... 文件   #  # -h, --help:   #  #  显示帮助   #
     # --encrypt key, -e key   #  #  使用密码加密文件   #  # --decrypt key, -d key   #  #
     使用密码解密文件   #  # 文件: 您想要加密/解密的文件    require ''getoptlong''   require ''rdoc/ri/ri_paths''
      require ''rdoc/usage''   require ''crypt/blowfish''    def encrypt(file, pass)
          c = "Encrypted_#{file}"        if File.exists?(c)           puts "\n文件已存在。"
              exit       end            begin           # 使用用户输入的密钥初始化加密方法       
       blowfish = Crypt::Blowfish.new(pass)           blowfish.encrypt_file(file.to_str,
    c)       # 加密文件           puts "\n加密成功！"       rescue Exception => e         
     puts "加密过程中发生错误：\n #{e}"       end   end    def decrypt(file, pass)       p =
    "Decrypted_#{file}"        if File.exists?(p)           puts "\n文件已存在。"       
       exit       end        begin           # 使用用户输入的密钥初始化解密方法           blowfish
    = Crypt::Blowfish.new(pass)           blowfish.decrypt_file(file.to_str, p)   
           # 解密文件           puts "\n解密成功！"       rescue Exception => e           puts
    "解密过程中发生错误：\n #{e}"       end   end   ![](../Images/00003.jpg) opts = GetoptLong.new(
          [ ''--help'', ''-h'', GetoptLong::NO_ARGUMENT ],       [ ''--encrypt'',
    ''-e'', GetoptLong::REQUIRED_ARGUMENT ],       [ ''--decrypt'', ''-d'', GetoptLong::REQUIRED_ARGUMENT
    ]   )  ![](../Images/00004.jpg) unless ARGV[0]       puts "\n您未包含文件名（尝试 --help)"
          exit   end    filename = ARGV[-1].chomp  ![](../Images/00005.jpg) opts.each
    do |opt, arg|       case opt       when ''--help''           RDoc::usage     
     when ''--encrypt''           encrypt(filename, arg)       when ''--decrypt''
              decrypt(filename, arg)       else           RDoc::usage       end   end`'
- en: Running the Code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'This script runs with two command-line arguments: which operation to perform
    (`encrypt` or `decrypt`) and the file to be manipulated.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用两个命令行参数运行：要执行的操作（`encrypt` 或 `decrypt`）以及要操作的文件。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Results
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '``**`ruby fileSecurity.rb`**  You did not include a filename (try --help)  **`ruby
    fileSecurity.rb --help`**  Synopsis --------  fileSecurity.rb: encrypts and decrypts
    files, demonstrates encryption algorithms  Usage ----- encryption [OPTIONS] ...
    FILE  -h, --help      show help  --encrypt key, -e key     encrypt file with password  --decrypt
    key, -d key     decrypt file with password  FILE: The file that you want to encrypt/decrypt``'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby fileSecurity.rb`**  您未包含文件名（尝试 --help）  **`ruby fileSecurity.rb --help`**  概述
    --------  fileSecurity.rb: 加密和解密文件，演示加密算法  用法 ----- 加密 [选项] ... 文件  -h, --help    
     显示帮助  --encrypt key, -e key     使用密码加密文件  --decrypt key, -d key     使用密码解密文件  文件:
    您想要加密/解密的文件 ```'
- en: How It Works
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The file is set up with two paths or *operations*. The first path of execution
    is the encryption routine. The second path is the decryption routine. If you need
    a refresher on how the encryption or decryption works, refer to pages [Hacking
    the Script](../Text/dummy_split_019.html#filepos107737) to [How It Works](../Text/dummy_split_025.html#filepos115794).
    The script starts off very differently than any of the other scripts we've written
    so far; most noticeable is the large comment block at the beginning of the script
    ![](../Images/00002.jpg). This section of code is actually used by the RDoc library
    to output relevant information about the script.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件设置包含两个路径或*操作*。第一个执行路径是加密例程。第二个路径是解密例程。如果您需要回顾加密或解密的工作原理，请参阅页面[Hacking the
    Script](../Text/dummy_split_019.html#filepos107737)到[How It Works](../Text/dummy_split_025.html#filepos115794)。该脚本与迄今为止我们编写的其他任何脚本都大不相同；最明显的是脚本开头的大注释块
    ![00002.jpg](../Images/00002.jpg)。这段代码实际上是RDoc库用来输出关于脚本的相关信息的。
- en: You will also see reliance on a few more external libraries. The first new library
    required for operation is GetoptLong. This library is responsible for handling
    all of the arguments within the script. Because we will combine two scripts, we
    will leverage GetoptLong to make argument parsing a snap. Next, we call rdoc/ri/ri_paths
    and rdoc/usage. These two libraries must be used together because rdoc/usage used
    by itself will generate errors on some systems due to dependencies. These libraries
    allow the proper formatting when `--help` is an argument of the script.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会看到对几个更多外部库的依赖。第一个新库是GetoptLong。这个库负责处理脚本中的所有参数。由于我们将合并两个脚本，我们将利用GetoptLong使参数解析变得简单。接下来，我们调用rdoc/ri/ri_paths和rdoc/usage。这两个库必须一起使用，因为rdoc/usage单独使用在某些系统上会因为依赖关系而产生错误。这些库允许在`--help`是脚本的参数时进行适当的格式化。
- en: The arguments are all defined in a GetoptLong object called `opt`. Two major
    attributes for each command-line option must be defined. The first attribute is
    an array of string objects that contains the names of that particular option ![](../Images/00003.jpg).
    You can use as many string objects as you'd like, and here I created two names
    for each option. The first is the full name, and the second is an abbreviation.
    The last piece of the `opt` object is the flag referring to the argument. The
    three options are listed below.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都定义在一个名为`opt`的GetoptLong对象中。每个命令行选项必须定义两个主要属性。第一个属性是一个包含该特定选项名称的字符串对象数组
    ![00003.jpg](../Images/00003.jpg)。您可以使用尽可能多的字符串对象，在这里我为每个选项创建了两个名称。第一个是全名，第二个是缩写。`opt`对象的最后一部分是引用参数的标志。以下列出了三个选项。
- en: '`GetoptLong::NO_ARGUMENT GetoptLong::REQUIRED_ARGUMENT GetoptLong::REQUIRED_ARGUMENT`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetoptLong::NO_ARGUMENT GetoptLong::REQUIRED_ARGUMENT GetoptLong::REQUIRED_ARGUMENT`'
- en: 'In this script, I identified three possible command-line arguments: `help,
    encrypt`, and `decrypt`. The `encrypt` and `decrypt` options require an argument
    that will be the key used to encrypt or decrypt the specified file. You can get
    as creative as you want with the command-line arguments, but try not to confuse
    your users (or yourself three months from now). Now that the arguments are defined,
    we need to ensure that the user supplied an argument. If there aren''t any arguments,
    then perhaps the user should visit the help section so that no files end up corrupted
    … or worse ![](../Images/00004.jpg). The filename used to either encrypt or decrypt
    the file will be the last argument of the script. We will also need a key when
    encrypting or decrypting the file, so the variable is initialized ahead of time.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我确定了三个可能的命令行参数：`help, encrypt`和`decrypt`。`encrypt`和`decrypt`选项需要一个参数，该参数将用作加密或解密指定文件的关键。您可以根据需要使命令行参数尽可能有创意，但尽量不要让用户（或三个月后的自己）感到困惑。现在参数已经定义，我们需要确保用户提供了参数。如果没有参数，那么用户可能应该访问帮助部分，这样就不会有文件被损坏……或者更糟
    ![00004.jpg](../Images/00004.jpg)。用于加密或解密文件的文件名将是脚本的最后一个参数。我们还需要一个密钥来加密或解密文件，因此变量提前初始化。
- en: Now that `opt` is ready to start parsing, the command-line arguments are passed
    into a block where the option and argument are broken apart ![](../Images/00005.jpg).
    A simple `case` statement makes for a clean execution on the control block. If
    `opt` is `--help` then `Rdoc::usage` is called. If `opt` is `--encrypt` or `-decrypt`,
    then the file is encrypted or decrypted, respectively, with the key being the
    required argument. To finish the script, the `case` statement ends, and the script
    exits.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`opt` 准备开始解析，命令行参数被传递到一个块中，其中选项和参数被分开！![图片](../Images/00005.jpg)。一个简单的 `case`
    语句使得对控制块的执行变得干净利落。如果 `opt` 是 `--help`，则调用 `Rdoc::usage`。如果 `opt` 是 `--encrypt`
    或 `-decrypt`，则分别使用所需参数作为密钥对文件进行加密或解密。为了完成脚本，`case` 语句结束，脚本退出。
- en: Web Scraper
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页爬虫
- en: Web Scraper
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网页爬虫
- en: webScraper.rb
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: webScraper.rb
- en: This version of the web scraper has the same functionality as the one found
    in [Chapter 7](../Text/dummy_split_291.html#filepos559796) (see "#44 Link Scrape"
    on [Link Scrape](../Text/dummy_split_305.html#filepos581500), "#45 Image Scrape"
    on [How It Works](../Text/dummy_split_310.html#filepos605751), and "#46 Scraper"
    on [Hacking the Script](../Text/dummy_split_318.html#filepos617953)). The difference
    between the script in [Chapter 7](../Text/dummy_split_291.html#filepos559796)
    and the one below is the addition of GetoptLong and RDoc. This version has the
    advantage of a standard help message, along with command-line arguments for the
    specific functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的网页爬虫具有与第 7 章（见 [第 7 章](../Text/dummy_split_291.html#filepos559796) 中的功能相同（参见
    [链接抓取](../Text/dummy_split_305.html#filepos581500) 中的 "#44 链接抓取"，[如何工作](../Text/dummy_split_310.html#filepos605751)
    中的 "#45 图片抓取"，以及 [脚本黑客](../Text/dummy_split_318.html#filepos617953) 中的 "#46 爬虫"））。第
    7 章（见 [第 7 章](../Text/dummy_split_291.html#filepos559796)）中的脚本和下面的脚本之间的区别是增加了
    GetoptLong 和 RDoc。这个版本的优势在于具有标准的帮助信息，以及针对特定功能的命令行参数。
- en: The Code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) # == Synopsis   #   #  webScraper.rb: scrape specific
    information from websites   #   #   # == Usage   #   # webScraper.rb [OPTIONS]
    ... URL   #   # -h, --help   #    show help   #   # --links , -l   #    scrape
    all of the links off a web page   #   # --images, -i   #    scrape all of the
    images off a web page   #   # --page, -p   #    scrape the html code off a web
    page   #   # URL: The website that you want to scrape    require ''getoptlong''
      require ''rdoc/ri/ri_paths''   require ''rdoc/usage''   require ''rio''   require
    ''open-uri''   require ''uri''   require ''mechanize''   require ''pathname''    def
    links(site)       links_file = File.open("links.txt","w+b")       agent = WWW::Mechanize.new    
       begin           page = agent.get(site.strip)            page.links.each do
    |l|               if l.href[0..3] == "http"                   links_file.puts
    l.href               elsif (l.href.split("")[0] == ''/'' and site.split("").last
    != ''/'') or                       (l.href.split("")[0] != ''/'' and site.split("").last
    == ''/'')                   links_file.puts "#{site}#{l.href}"               elsif
    l.href.split("")[0] != ''/'' and site.split("").last != ''/''                 
     links_file.puts "#{site}/#{l.href}"               else                   links_file.puts
    l.href               end           end       rescue => e           puts "An error
    occurred."           puts e       end       links_file.close   end    def images(site)
          begin           open(site.strip, "User-Agent" => "Mozilla/4.0 (compatible;
    MSIE 5.5;   Windows 98)") do |source|               source.each_line do |x|   
                   if x =~ /<img src="(.+.[jpeg|gif])"\s+/                        name
    = $1.split(''"'').first                       site = site + ''/'' unless site.split("").last
    == ''/''                       name = site + name unless name[0..3] == "http"
                          copy = name.split(''/'').last                        File.open(copy,
    ''wb'') do |f|                           f.write(open(name).read)             
             end                   end               end           end       rescue
    => e           puts "An error occurred, please try again."           puts e   
       end   end    def page(site)       rio(site) > rio("#{URI.parse(site.strip).host}.html")
      end    opts = GetoptLong.new(       [ ''--help'', ''-h'', GetoptLong::NO_ARGUMENT
    ],       [ ''--links'', ''-l'', GetoptLong::NO_ARGUMENT ],       [ ''--images'',
    ''-i'', GetoptLong::NO_ARGUMENT ],       [ ''--page'', ''-p'', GetoptLong::NO_ARGUMENT
    ]   )    unless ARGV[0]       puts "\nYou did not include a URL (try --help)"
          exit   end    url = ARGV[-1].chomp  ![](../Images/00003.jpg) opts.each do
    |opt, arg|       case opt       when ''--help''           RDoc::usage       when
    ''--links''           links(url)       when ''--images''           images(url)
          when ''--page''           page(url)       else           RDoc::usage   
       end   end`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run this script, pick from four command-line options and supply the specific
    URL being targeted. None of the options require an argument.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，从四个命令行选项中选择，并指定要针对的特定 URL。没有任何选项需要参数。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Results
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '``**`ruby webScraper.rb --help`**  Synopsis --------  webScraper.rb: scrape
    specific information from websites  Usage ----- webScraper.rb [OPTIONS] ... URL  -h,
    --help:      show help  --links , -l:     scrape all of the links off a web page  --images,
    -i:     scrape all of the images off a web page  --page, -p:     scrape the html
    code off a web page  URL: The website that you want to scrape``'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby webScraper.rb --help`**  概述 --------  webScraper.rb: 从网站上抓取特定信息  用法
    ----- webScraper.rb [选项] ... 网址  -h, --help:     显示帮助  --links , -l:     抓取网页上的所有链接  --images,
    -i:     抓取网页上的所有图片  --page, -p:     抓取网页上的 html 代码  网址: 您想要抓取的网站``'
- en: How It Works
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: This script is set up similar to the *fileSecurity.rb* script. The functionality
    is the same from the scripts in [Chapter 7](../Text/dummy_split_291.html#filepos559796).
    To begin to provide appropriate usage and documentation for future users, the
    large comment section at the head of the code is defined ![](../Images/00002.jpg).
    The only difference between this code and the previous scraping example is the
    control structure now used to direct the flow to the appropriate methods. The
    control structure is again a `case` statement looking for the specific arguments
    passed in by the user ![](../Images/00003.jpg). If you compare the original web
    scraping script (see "#49 File Security" on [File Security](../Text/dummy_split_338.html#filepos651722))
    to the one above, you can see how much simpler controlling the flow of the program
    is with GetoptLong, and how neatly RDoc formats the usage statements. You can
    always use your own argument parser, but GetoptLong and RDoc add a more consistent
    and succinct approach. I won't go into the details of this script, but I did want
    to give you a look at a different way to combine the scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本设置与 *fileSecurity.rb* 脚本类似。功能与 [第7章](../Text/dummy_split_291.html#filepos559796)
    中的脚本相同。为了开始为未来的用户提供适当的用法和文档，代码开头的大注释部分被定义为 ![图片](../Images/00002.jpg)。此代码与之前的抓取示例之间的唯一区别是现在使用的控制结构，用于将流程导向适当的方法。控制结构再次是一个
    `case` 语句，寻找用户传入的特定参数 ![图片](../Images/00003.jpg)。如果您将原始的网页抓取脚本（见 [文件安全](../Text/dummy_split_338.html#filepos651722)
    中的 "#49 文件安全"）与上面的脚本进行比较，您可以看到使用 GetoptLong 控制程序流程是多么简单，以及 RDoc 如何整洁地格式化用法说明。您始终可以使用自己的参数解析器，但
    GetoptLong 和 RDoc 提供了一种更一致和简洁的方法。我不会深入探讨此脚本的细节，但我确实想让您看看一种不同的结合脚本的方法。
- en: Photo Utilities
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照片工具
- en: Photo Utilities
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 照片工具
- en: photoUtility.rb
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: photoUtility.rb
- en: This script combines most of the scripts found in [Chapter 4](../Text/dummy_split_156.html#filepos331926)
    and presents them in one file. This could be converted into a customized picture
    library or used as presented below. Some of the reasons I chose to create this
    suite is the focus on photographic manipulations. Scripts with a commonality are
    good candidates for consolidation and even warrant refactoring the code for easier
    maintainability. One of the advantages that I found most significant is having
    a lot of functionality all in one script. You can imagine how cumbersome it could
    be, having to hunt down multiple scripts to do the tasks included in this single
    Ruby script.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本结合了 [第4章](../Text/dummy_split_156.html#filepos331926) 中找到的大多数脚本，并将它们放在一个文件中。这可以转换成一个定制的图片库，或者像下面那样使用。我选择创建此套件的一些原因是对摄影处理的关注。具有共同性的脚本是合并的好候选者，甚至值得重构代码以简化维护。我发现的一个最显著的优点是所有功能都集中在一个脚本中。您可以想象，如果需要查找多个脚本来完成这个单一
    Ruby 脚本中包含的任务，那将是多么繁琐。
- en: The Code
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`# == Synopsis # #  photoUtility.rb: manipulate images to resize, watermark,
    or make a web photo album # # # == Usage # # photoUtility.rb [OPTIONS] ... IMAGE
    # # -h, --help #    show help # # --bw, -b #    convert an image to black and
    white # # --gallery, -g #    create a web photo album. Enter "temp" for IMAGE
    when using this option # # --info, -i #    extract the photo information # # --resize
    size, -r size #    resize a file to a specific dimension # # --watermark text,
    -w text #    watermark an image with the text supplied # # IMAGE: The photo you
    want to manipulate`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`# == 摘要 # # photoUtility.rb: 处理图像以调整大小、添加水印或创建网络相册 # # # == 使用方法 # # photoUtility.rb
    [选项] ... 图片 # # -h, --help #    显示帮助信息 # # --bw, -b #    将图像转换为黑白 # # --gallery,
    -g #    创建网络相册。使用此选项时，将"图片"输入为"temp" # # --info, -i #    提取照片信息 # # --resize size,
    -r size #    将文件调整到特定尺寸 # # --watermark text, -w text #    使用提供的文本给图像添加水印 # #
    图片: 你想要处理的照片`'
- en: The section of code above is in the standard RDoc format, so when we go to dust
    off a script from the shelf and can't remember how to use it, the `--help` option
    is always available.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码部分采用标准RDoc格式，因此当我们从架子上取下一份脚本却忘记了如何使用时，`--help`选项总是可用。
- en: '`require ''getoptlong'' require ''rdoc/ri/ri_paths'' require ''rdoc/usage''
    require ''RMagick'' require ''exifr'' require ''ftools'' include EXIFR include
    Magick  def bw(file)     new_img = "bw_#{file}"     img = Image.read(file).first    
     img = img.quantize(256, GRAYColorspace)      if File.exists?(new_img)       
     puts "Could not write file, image name already exists."         exit     end    
     img.write(new_img) end  def gallery()     photos_row = 4     table_border = 1
        html_rows = 1      # Make all the directories     File.makedirs("gallery/thumbs",
    "gallery/resize")     output = File.new("gallery/index.html","w+b")      output.puts
    <<EOF             <html>                 <head>                     <title>My
    Photos</title>                 </head>                 <body bgcolor="#d0d0d0">
                        <h1>Welcome To My Photo Gallery</h1>                     <table
    border=#{table_border}> EOF      Dir[''*.[Jj][Pp]*[Gg]''].each do |pic|       
     # create the thumbnail         thumb = Image.read(pic)[0]         thumb.change_geometry!(''150x150'')
    do |cols, rows, img|             thumb.resize!(cols, rows)         end       
     if File.exists?("gallery/thumbs/th_#{pic}")             puts "Could not write
    file th_#{pic}, thumbnail already exists. Renaming to new_th_#{pic}"         
       thumb.write "gallery/thumbs/new_th_#{pic}"         else             # Write
    them to a separate folder if you wish to get organized...or             # you
    could just sort by filename             thumb.write "gallery/thumbs/th_#{pic}"
            end          # resize the picture         resize = Image.read(pic)[0]
            resize.change_geometry!(''800x600'') do |cols, rows, img|             resize.resize!(cols,
    rows)         end         if File.exists?("gallery/resize/resize_#{pic}")     
           puts "Could not write file resize_#{pic}, resized image already exists.
     Renaming to new_resize_#{pic}"             resize.write("gallery/resize/new_resize_#{pic}")
            else             resize.write("gallery/resize/resize_#{pic}")         end    
         if html_rows % photos_row == 1             output.puts "\n<tr>"         end    
         output.puts <<EOF                     <td><a href="resize/resize_#{pic}/"
    title="#{pic}" target="_blank"><img src="thumbs/th_#{pic}" alt="#{pic}"/></a></td>
    EOF          if html_rows % photos_row == 0             output.puts "</tr>"   
         end         html_rows+=1     end      unless html_rows % photos_row == 1
            output.puts "</tr>"     end      output.puts "</body>\n</html>"     output.puts
    "<!-- Courtesy of No Starch Press: Wicked Cool Ruby Scripts -->"     output.close
    end  def info(file)     info = JPEG.new(file)      File.open("info_#{File.basename(file)}.txt",
    "w") do |output|         output.puts info.exif.to_hash.map{ |k,v| "#{k}:  #{v}"}
        end end  def resize(file, arg)     size = arg.chomp     img = Image.read(file).first
        width = nil     height = nil     img.change_geometry!("#{size}x#{size}") do
    |cols, rows, img|         img.resize!(cols, rows)         width = cols       
     height = rows     end      file_name = "#{width}x#{height}_#{file}"      if File.exists?(file_name)
            puts "File already exists.  Unable to write file."         exit     end    
     img.write(file_name) end  def watermark(file, arg)     text = arg.chomp     img
    = Image.read(file).first     new_img = "wm_#{file}"      if File.exists?(new_img)
            puts "Image already exists.  Unable to create file."         exit     end    
     watermark = Image.new(600, 50)      watermark_text = Draw.new     watermark_text.annotate(watermark,
    0,0,0,0, text) do         watermark_text.gravity = CenterGravity         self.pointsize
    = 50         self.font_family = "Arial"         self.font_weight = BoldWeight
            self.stroke = "none"     end      watermark.rotate!(45)     watermark
    = watermark.shade(true, 310, 30)     img.composite!(watermark, SouthWestGravity,
    HardLightCompositeOp) #Bottom-Left Marking     watermark.rotate!(-90)     img.composite!(watermark,
    NorthWestGravity, HardLightCompositeOp) #Top-Left Marking     watermark.rotate!(90)
        img.composite!(watermark, NorthEastGravity, HardLightCompositeOp) #Top-Right
    Marking     watermark.rotate!(-90)     img.composite!(watermark, SouthEastGravity,
    HardLightCompositeOp) #Bottom-Right Marking      puts "Writing #{new_img}"   
     img.write(new_img) end`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This marks the end of the methods that will be called in the `case` statement
    below. You can put the "guts" of the script into the `case` statement, but having
    methods to call each functionality will keep your code clean and easier to read
    and maintain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着下面 `case` 语句中将调用的方法的结束。您可以将脚本的“核心”放入 `case` 语句中，但拥有调用每个功能的方法将使您的代码更整洁，更容易阅读和维护。
- en: '`![](../Images/00002.jpg) opts = GetoptLong.new(       [ ''--help'', ''-h'',
    GetoptLong::NO_ARGUMENT ],       [ ''--black'', ''-b'', GetoptLong::NO_ARGUMENT
    ],       [ ''--gallery'', ''-g'', GetoptLong::NO_ARGUMENT ],       [ ''--info'',
    ''-i'', GetoptLong::NO_ARGUMENT ],       [ ''--resize'', ''-r'', GetoptLong::REQUIRED_ARGUMENT
    ],       [ ''--watermark'', ''-w'', GetoptLong::REQUIRED_ARGUMENT ]   )    filename
    = ARGV[-1].chomp    opts.each do |opt, arg|       case opt       when ''--help''
              RDoc::usage       when ''--black''           bw(filename)       when
    ''--gallery''           gallery()       when ''--info''           info(filename)
          when ''--resize''           resize(filename, arg)       when ''--watermark''
              watermark(filename, arg)       else           RDoc::usage       end
      end`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) opts = GetoptLong.new(       [ ''--help'', ''-h'',
    GetoptLong::NO_ARGUMENT ],       [ ''--black'', ''-b'', GetoptLong::NO_ARGUMENT
    ],       [ ''--gallery'', ''-g'', GetoptLong::NO_ARGUMENT ],       [ ''--info'',
    ''-i'', GetoptLong::NO_ARGUMENT ],       [ ''--resize'', ''-r'', GetoptLong::REQUIRED_ARGUMENT
    ],       [ ''--watermark'', ''-w'', GetoptLong::REQUIRED_ARGUMENT ]   )    filename
    = ARGV[-1].chomp    opts.each do |opt, arg|       case opt       when ''--help''
              RDoc::usage       when ''--black''           bw(filename)       when
    ''--gallery''           gallery()       when ''--info''           info(filename)
          when ''--resize''           resize(filename, arg)       when ''--watermark''
              watermark(filename, arg)       else           RDoc::usage       end
      end`'
- en: Running the Code
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run this script, type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请输入：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (Use any one of the options listed above. I used the `--help` option to generate
    the output in the results section.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: （使用上述列出的任何一项选项。我使用了 `--help` 选项来生成结果部分的内容。）
- en: The Results
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`Synopsis -------- photoUtility.rb: manipulate images to resize, watermark,
    or make a web photo album   Usage ----- photoUtility.rb [OPTIONS] ... IMAGE  -h,
    --help      show help  --bw, -b     convert an image to black and white  --gallery,
    -g     create a web photo album. Enter "temp" for IMAGE when using this option  --info,
    -i     extract the photo information  --resize size, -r size     resize a file
    to a specific dimension  --watermark text, -w text     watermark an image with
    the text supplied  IMAGE: The photo you want to manipulate`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`概要 -------- photoUtility.rb: 处理图像以调整大小、添加水印或创建网络相册   用法 ----- photoUtility.rb
    [选项] ... 图像  -h, --help     显示帮助  --bw, -b     将图像转换为黑白  --gallery, -g     创建网络相册。使用此选项时，将图像指定为
    "temp"  --info, -i     提取照片信息  --resize size, -r size     将文件调整到特定尺寸  --watermark
    text, -w text     使用提供的文本给图像添加水印  图像: 您想要处理的照片`'
- en: How It Works
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This script works as the two previous scripts did, but hopefully you noticed
    the functionality that is incorporated into this script. The code is quite a bit
    longer than any of the previous scripts because we have used GetoptLong to consolidate
    a lot of useful picture manipulation functions into one wicked cool script. The
    major difference is in the number of options available to the user. Each option
    is subsequently put into its own when clause. The `case` statement is a great
    control statement because it reads nicely and can be more efficient to program
    and maintain than several `if`/`else` statements cumbersomely stacked on each
    other. The major functions of this script can be found by looking at the arguments
    section in the `opts` variable ![](../Images/00002.jpg). Options include a help
    message, converting an image to black and white, making a photo gallery, extracting
    the embedded information from the picture, resizing the image, and finally, placing
    a watermark on the image to protect the digital media. Quite a nice array of image
    tools at our disposal, all from this script. You'll also note that the scripts
    from [Chapter 7](../Text/dummy_split_291.html#filepos559796) have been slightly
    modified for proper execution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本与前面两个脚本的工作方式相同，但希望你已经注意到了这个脚本中集成的功能。代码比之前的任何脚本都要长得多，因为我们使用了 GetoptLong 将许多有用的图片处理功能合并到一个非常酷的脚本中。主要的不同之处在于用户可用的选项数量。每个选项随后都放入自己的
    when 子句中。`case` 语句是一个很好的控制语句，因为它读起来很顺畅，并且可能比堆叠在一起的几个 `if`/`else` 语句更高效。此脚本的主要功能可以通过查看
    `opts` 变量的 arguments 部分来找到 ![图片](../Images/00002.jpg)。选项包括帮助信息、将图片转换为黑白、制作相册、从图片中提取嵌入的信息、调整图片大小，最后，在图片上放置水印以保护数字媒体。我们手头有一系列相当不错的图片工具，全部来自这个脚本。你还会注意到，[第
    7 章](../Text/dummy_split_291.html#filepos559796) 中的脚本已经稍作修改以确保正确执行。
- en: Conclusion
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: As demonstrated in this chapter, whenever you have scripts that are similar
    in content, subject, or any other grouping that makes sense to you, consolidating
    the scripts into a "library" of sorts is a logical step. Instead of keeping up
    with many different files, you're looking at one. But, I would caution you not
    to get overzealous in consolidation or else you might catch a case of the "spaghetti-code
    syndrome," making code maintenance extremely frustrating, if not impossible. Good
    luck in your exploration of GetoptLong, RDoc, and script consolidation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所示，无论何时你拥有内容、主题或任何对你有意义的分组相似的脚本，将脚本合并成一个“库”类型的步骤是逻辑上的。你不需要管理许多不同的文件，只需关注一个。但是，我要提醒你，不要在合并过程中过于热情，否则你可能会患上“意大利面代码综合症”，使得代码维护变得极其令人沮丧，甚至不可能。祝你在探索
    GetoptLong、RDoc 和脚本合并方面好运。
