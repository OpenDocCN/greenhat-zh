- en: Chapter 8. ARGUMENTS AND DOCUMENTATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![ARGUMENTS AND DOCUMENTATION](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will revisit some earlier scripts and tie them into a single,
    larger script. In doing so, we can abstract functions that are similar between
    each element. This abstraction not only saves space, it also results in larger
    chunks of reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: To begin consolidating the scripts, we are going to rely on a library that will
    tie in essential parts of the scripts and allow a user to access specific functions
    through the command line. The library is called GetoptLong, because it gets options
    from the implied argument vector (or the command line). Many times, when a script
    is written, there may be more than one task available to the user. Instead of
    running the entire script, we can let the user pick and choose functions based
    on his or her needs. Not only will the library enable us to use command-line arguments
    to set up different cases, but it will also replace the "in-house" argument check
    used throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that will complement GetoptLong is RDoc. RDoc helps format our
    code's usage statements and documentation. Specifically, RDoc will generate structured
    HTML documentation from Ruby source code (for more information about RDoc and
    to download the application, visit [http://rdoc.sourceforge.net/](http://rdoc.sourceforge.net/)).
    Another "in-house" chunk of code seen throughout the previous scripts were the
    usage statements—RDoc can replace this chunk of code and help us maintain consistency
    in our documentation. These libraries will also give a professional appearance
    to the scripts by formatting the usage statements and output in a predictable,
    common way.
  prefs: []
  type: TYPE_NORMAL
- en: File Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: fileSecurity.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two scripts that are prime for consolidation are the encryption and decryption
    scripts from [Chapter 1](../Text/dummy_split_012.html#filepos91052) ("#2 Encrypt
    a File" on [Hacking the Script](../Text/dummy_split_019.html#filepos107737) and
    "#3 Decrypt a File" on [Hacking the Script](../Text/dummy_split_026.html#filepos119276)).
    To recap what these scripts did, the encrypt script scrambled data into ciphertext,
    and the decrypt script decoded the ciphertext back into plaintext. Both scripts
    used the Blowfish encryption algorithm and a password chosen by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) # == Synopsis   #   #  fileSecurity.rb: encrypts
    and decrypts files, demonstrates encryption algorithms   #   #   # == Usage   #
      # encryption [OPTIONS] ... FILE   #   # -h, --help:   #    show help   #   #
    --encrypt key, -e key   #    encrypt file with password   #   # --decrypt key,
    -d key   #    decrypt file with password   #   # FILE: The file that you want
    to encrypt/decrypt    require ''getoptlong''   require ''rdoc/ri/ri_paths''   require
    ''rdoc/usage''   require ''crypt/blowfish''    def encrypt(file, pass)       c
    = "Encrypted_#{file}"        if File.exists?(c)           puts "\nFile already
    exists."           exit       end            begin           # initialize the
    encryption method using the user input key           blowfish = Crypt::Blowfish.new(pass)
              blowfish.encrypt_file(file.to_str, c)       # encrypt the file     
         puts "\nEncryption SUCCESS!"       rescue Exception => e           puts "An
    error occurred during encryption: \n #{e}"       end   end    def decrypt(file,
    pass)       p = "Decrypted_#{file}"        if File.exists?(p)           puts "\nFile
    already exists."           exit       end        begin           # initialize
    the decryption method using the user input key           blowfish = Crypt::Blowfish.new(pass)
              blowfish.decrypt_file(file.to_str, p)           # decrypt the file   
           puts "\nDecryption SUCCESS!"       rescue Exception => e           puts
    "An error occurred during decryption: \n #{e}"       end   end   ![](../Images/00003.jpg) opts
    = GetoptLong.new(       [ ''--help'', ''-h'', GetoptLong::NO_ARGUMENT ],     
     [ ''--encrypt'', ''-e'', GetoptLong::REQUIRED_ARGUMENT ],       [ ''--decrypt'',
    ''-d'', GetoptLong::REQUIRED_ARGUMENT ]   )  ![](../Images/00004.jpg) unless ARGV[0]
          puts "\nYou did not include a filename (try --help)"       exit   end    filename
    = ARGV[-1].chomp  ![](../Images/00005.jpg) opts.each do |opt, arg|       case
    opt       when ''--help''           RDoc::usage       when ''--encrypt''     
         encrypt(filename, arg)       when ''--decrypt''           decrypt(filename,
    arg)       else           RDoc::usage       end   end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script runs with two command-line arguments: which operation to perform
    (`encrypt` or `decrypt`) and the file to be manipulated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '``**`ruby fileSecurity.rb`**  You did not include a filename (try --help)  **`ruby
    fileSecurity.rb --help`**  Synopsis --------  fileSecurity.rb: encrypts and decrypts
    files, demonstrates encryption algorithms  Usage ----- encryption [OPTIONS] ...
    FILE  -h, --help      show help  --encrypt key, -e key     encrypt file with password  --decrypt
    key, -d key     decrypt file with password  FILE: The file that you want to encrypt/decrypt``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file is set up with two paths or *operations*. The first path of execution
    is the encryption routine. The second path is the decryption routine. If you need
    a refresher on how the encryption or decryption works, refer to pages [Hacking
    the Script](../Text/dummy_split_019.html#filepos107737) to [How It Works](../Text/dummy_split_025.html#filepos115794).
    The script starts off very differently than any of the other scripts we've written
    so far; most noticeable is the large comment block at the beginning of the script
    ![](../Images/00002.jpg). This section of code is actually used by the RDoc library
    to output relevant information about the script.
  prefs: []
  type: TYPE_NORMAL
- en: You will also see reliance on a few more external libraries. The first new library
    required for operation is GetoptLong. This library is responsible for handling
    all of the arguments within the script. Because we will combine two scripts, we
    will leverage GetoptLong to make argument parsing a snap. Next, we call rdoc/ri/ri_paths
    and rdoc/usage. These two libraries must be used together because rdoc/usage used
    by itself will generate errors on some systems due to dependencies. These libraries
    allow the proper formatting when `--help` is an argument of the script.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments are all defined in a GetoptLong object called `opt`. Two major
    attributes for each command-line option must be defined. The first attribute is
    an array of string objects that contains the names of that particular option ![](../Images/00003.jpg).
    You can use as many string objects as you'd like, and here I created two names
    for each option. The first is the full name, and the second is an abbreviation.
    The last piece of the `opt` object is the flag referring to the argument. The
    three options are listed below.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetoptLong::NO_ARGUMENT GetoptLong::REQUIRED_ARGUMENT GetoptLong::REQUIRED_ARGUMENT`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this script, I identified three possible command-line arguments: `help,
    encrypt`, and `decrypt`. The `encrypt` and `decrypt` options require an argument
    that will be the key used to encrypt or decrypt the specified file. You can get
    as creative as you want with the command-line arguments, but try not to confuse
    your users (or yourself three months from now). Now that the arguments are defined,
    we need to ensure that the user supplied an argument. If there aren''t any arguments,
    then perhaps the user should visit the help section so that no files end up corrupted
    … or worse ![](../Images/00004.jpg). The filename used to either encrypt or decrypt
    the file will be the last argument of the script. We will also need a key when
    encrypting or decrypting the file, so the variable is initialized ahead of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that `opt` is ready to start parsing, the command-line arguments are passed
    into a block where the option and argument are broken apart ![](../Images/00005.jpg).
    A simple `case` statement makes for a clean execution on the control block. If
    `opt` is `--help` then `Rdoc::usage` is called. If `opt` is `--encrypt` or `-decrypt`,
    then the file is encrypted or decrypted, respectively, with the key being the
    required argument. To finish the script, the `case` statement ends, and the script
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: Web Scraper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Scraper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: webScraper.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This version of the web scraper has the same functionality as the one found
    in [Chapter 7](../Text/dummy_split_291.html#filepos559796) (see "#44 Link Scrape"
    on [Link Scrape](../Text/dummy_split_305.html#filepos581500), "#45 Image Scrape"
    on [How It Works](../Text/dummy_split_310.html#filepos605751), and "#46 Scraper"
    on [Hacking the Script](../Text/dummy_split_318.html#filepos617953)). The difference
    between the script in [Chapter 7](../Text/dummy_split_291.html#filepos559796)
    and the one below is the addition of GetoptLong and RDoc. This version has the
    advantage of a standard help message, along with command-line arguments for the
    specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) # == Synopsis   #   #  webScraper.rb: scrape specific
    information from websites   #   #   # == Usage   #   # webScraper.rb [OPTIONS]
    ... URL   #   # -h, --help   #    show help   #   # --links , -l   #    scrape
    all of the links off a web page   #   # --images, -i   #    scrape all of the
    images off a web page   #   # --page, -p   #    scrape the html code off a web
    page   #   # URL: The website that you want to scrape    require ''getoptlong''
      require ''rdoc/ri/ri_paths''   require ''rdoc/usage''   require ''rio''   require
    ''open-uri''   require ''uri''   require ''mechanize''   require ''pathname''    def
    links(site)       links_file = File.open("links.txt","w+b")       agent = WWW::Mechanize.new    
       begin           page = agent.get(site.strip)            page.links.each do
    |l|               if l.href[0..3] == "http"                   links_file.puts
    l.href               elsif (l.href.split("")[0] == ''/'' and site.split("").last
    != ''/'') or                       (l.href.split("")[0] != ''/'' and site.split("").last
    == ''/'')                   links_file.puts "#{site}#{l.href}"               elsif
    l.href.split("")[0] != ''/'' and site.split("").last != ''/''                 
     links_file.puts "#{site}/#{l.href}"               else                   links_file.puts
    l.href               end           end       rescue => e           puts "An error
    occurred."           puts e       end       links_file.close   end    def images(site)
          begin           open(site.strip, "User-Agent" => "Mozilla/4.0 (compatible;
    MSIE 5.5;   Windows 98)") do |source|               source.each_line do |x|   
                   if x =~ /<img src="(.+.[jpeg|gif])"\s+/                        name
    = $1.split(''"'').first                       site = site + ''/'' unless site.split("").last
    == ''/''                       name = site + name unless name[0..3] == "http"
                          copy = name.split(''/'').last                        File.open(copy,
    ''wb'') do |f|                           f.write(open(name).read)             
             end                   end               end           end       rescue
    => e           puts "An error occurred, please try again."           puts e   
       end   end    def page(site)       rio(site) > rio("#{URI.parse(site.strip).host}.html")
      end    opts = GetoptLong.new(       [ ''--help'', ''-h'', GetoptLong::NO_ARGUMENT
    ],       [ ''--links'', ''-l'', GetoptLong::NO_ARGUMENT ],       [ ''--images'',
    ''-i'', GetoptLong::NO_ARGUMENT ],       [ ''--page'', ''-p'', GetoptLong::NO_ARGUMENT
    ]   )    unless ARGV[0]       puts "\nYou did not include a URL (try --help)"
          exit   end    url = ARGV[-1].chomp  ![](../Images/00003.jpg) opts.each do
    |opt, arg|       case opt       when ''--help''           RDoc::usage       when
    ''--links''           links(url)       when ''--images''           images(url)
          when ''--page''           page(url)       else           RDoc::usage   
       end   end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run this script, pick from four command-line options and supply the specific
    URL being targeted. None of the options require an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '``**`ruby webScraper.rb --help`**  Synopsis --------  webScraper.rb: scrape
    specific information from websites  Usage ----- webScraper.rb [OPTIONS] ... URL  -h,
    --help:      show help  --links , -l:     scrape all of the links off a web page  --images,
    -i:     scrape all of the images off a web page  --page, -p:     scrape the html
    code off a web page  URL: The website that you want to scrape``'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script is set up similar to the *fileSecurity.rb* script. The functionality
    is the same from the scripts in [Chapter 7](../Text/dummy_split_291.html#filepos559796).
    To begin to provide appropriate usage and documentation for future users, the
    large comment section at the head of the code is defined ![](../Images/00002.jpg).
    The only difference between this code and the previous scraping example is the
    control structure now used to direct the flow to the appropriate methods. The
    control structure is again a `case` statement looking for the specific arguments
    passed in by the user ![](../Images/00003.jpg). If you compare the original web
    scraping script (see "#49 File Security" on [File Security](../Text/dummy_split_338.html#filepos651722))
    to the one above, you can see how much simpler controlling the flow of the program
    is with GetoptLong, and how neatly RDoc formats the usage statements. You can
    always use your own argument parser, but GetoptLong and RDoc add a more consistent
    and succinct approach. I won't go into the details of this script, but I did want
    to give you a look at a different way to combine the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Photo Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Photo Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: photoUtility.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script combines most of the scripts found in [Chapter 4](../Text/dummy_split_156.html#filepos331926)
    and presents them in one file. This could be converted into a customized picture
    library or used as presented below. Some of the reasons I chose to create this
    suite is the focus on photographic manipulations. Scripts with a commonality are
    good candidates for consolidation and even warrant refactoring the code for easier
    maintainability. One of the advantages that I found most significant is having
    a lot of functionality all in one script. You can imagine how cumbersome it could
    be, having to hunt down multiple scripts to do the tasks included in this single
    Ruby script.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`# == Synopsis # #  photoUtility.rb: manipulate images to resize, watermark,
    or make a web photo album # # # == Usage # # photoUtility.rb [OPTIONS] ... IMAGE
    # # -h, --help #    show help # # --bw, -b #    convert an image to black and
    white # # --gallery, -g #    create a web photo album. Enter "temp" for IMAGE
    when using this option # # --info, -i #    extract the photo information # # --resize
    size, -r size #    resize a file to a specific dimension # # --watermark text,
    -w text #    watermark an image with the text supplied # # IMAGE: The photo you
    want to manipulate`'
  prefs: []
  type: TYPE_NORMAL
- en: The section of code above is in the standard RDoc format, so when we go to dust
    off a script from the shelf and can't remember how to use it, the `--help` option
    is always available.
  prefs: []
  type: TYPE_NORMAL
- en: '`require ''getoptlong'' require ''rdoc/ri/ri_paths'' require ''rdoc/usage''
    require ''RMagick'' require ''exifr'' require ''ftools'' include EXIFR include
    Magick  def bw(file)     new_img = "bw_#{file}"     img = Image.read(file).first    
     img = img.quantize(256, GRAYColorspace)      if File.exists?(new_img)       
     puts "Could not write file, image name already exists."         exit     end    
     img.write(new_img) end  def gallery()     photos_row = 4     table_border = 1
        html_rows = 1      # Make all the directories     File.makedirs("gallery/thumbs",
    "gallery/resize")     output = File.new("gallery/index.html","w+b")      output.puts
    <<EOF             <html>                 <head>                     <title>My
    Photos</title>                 </head>                 <body bgcolor="#d0d0d0">
                        <h1>Welcome To My Photo Gallery</h1>                     <table
    border=#{table_border}> EOF      Dir[''*.[Jj][Pp]*[Gg]''].each do |pic|       
     # create the thumbnail         thumb = Image.read(pic)[0]         thumb.change_geometry!(''150x150'')
    do |cols, rows, img|             thumb.resize!(cols, rows)         end       
     if File.exists?("gallery/thumbs/th_#{pic}")             puts "Could not write
    file th_#{pic}, thumbnail already exists. Renaming to new_th_#{pic}"         
       thumb.write "gallery/thumbs/new_th_#{pic}"         else             # Write
    them to a separate folder if you wish to get organized...or             # you
    could just sort by filename             thumb.write "gallery/thumbs/th_#{pic}"
            end          # resize the picture         resize = Image.read(pic)[0]
            resize.change_geometry!(''800x600'') do |cols, rows, img|             resize.resize!(cols,
    rows)         end         if File.exists?("gallery/resize/resize_#{pic}")     
           puts "Could not write file resize_#{pic}, resized image already exists.
     Renaming to new_resize_#{pic}"             resize.write("gallery/resize/new_resize_#{pic}")
            else             resize.write("gallery/resize/resize_#{pic}")         end    
         if html_rows % photos_row == 1             output.puts "\n<tr>"         end    
         output.puts <<EOF                     <td><a href="resize/resize_#{pic}/"
    title="#{pic}" target="_blank"><img src="thumbs/th_#{pic}" alt="#{pic}"/></a></td>
    EOF          if html_rows % photos_row == 0             output.puts "</tr>"   
         end         html_rows+=1     end      unless html_rows % photos_row == 1
            output.puts "</tr>"     end      output.puts "</body>\n</html>"     output.puts
    "<!-- Courtesy of No Starch Press: Wicked Cool Ruby Scripts -->"     output.close
    end  def info(file)     info = JPEG.new(file)      File.open("info_#{File.basename(file)}.txt",
    "w") do |output|         output.puts info.exif.to_hash.map{ |k,v| "#{k}:  #{v}"}
        end end  def resize(file, arg)     size = arg.chomp     img = Image.read(file).first
        width = nil     height = nil     img.change_geometry!("#{size}x#{size}") do
    |cols, rows, img|         img.resize!(cols, rows)         width = cols       
     height = rows     end      file_name = "#{width}x#{height}_#{file}"      if File.exists?(file_name)
            puts "File already exists.  Unable to write file."         exit     end    
     img.write(file_name) end  def watermark(file, arg)     text = arg.chomp     img
    = Image.read(file).first     new_img = "wm_#{file}"      if File.exists?(new_img)
            puts "Image already exists.  Unable to create file."         exit     end    
     watermark = Image.new(600, 50)      watermark_text = Draw.new     watermark_text.annotate(watermark,
    0,0,0,0, text) do         watermark_text.gravity = CenterGravity         self.pointsize
    = 50         self.font_family = "Arial"         self.font_weight = BoldWeight
            self.stroke = "none"     end      watermark.rotate!(45)     watermark
    = watermark.shade(true, 310, 30)     img.composite!(watermark, SouthWestGravity,
    HardLightCompositeOp) #Bottom-Left Marking     watermark.rotate!(-90)     img.composite!(watermark,
    NorthWestGravity, HardLightCompositeOp) #Top-Left Marking     watermark.rotate!(90)
        img.composite!(watermark, NorthEastGravity, HardLightCompositeOp) #Top-Right
    Marking     watermark.rotate!(-90)     img.composite!(watermark, SouthEastGravity,
    HardLightCompositeOp) #Bottom-Right Marking      puts "Writing #{new_img}"   
     img.write(new_img) end`'
  prefs: []
  type: TYPE_NORMAL
- en: This marks the end of the methods that will be called in the `case` statement
    below. You can put the "guts" of the script into the `case` statement, but having
    methods to call each functionality will keep your code clean and easier to read
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) opts = GetoptLong.new(       [ ''--help'', ''-h'',
    GetoptLong::NO_ARGUMENT ],       [ ''--black'', ''-b'', GetoptLong::NO_ARGUMENT
    ],       [ ''--gallery'', ''-g'', GetoptLong::NO_ARGUMENT ],       [ ''--info'',
    ''-i'', GetoptLong::NO_ARGUMENT ],       [ ''--resize'', ''-r'', GetoptLong::REQUIRED_ARGUMENT
    ],       [ ''--watermark'', ''-w'', GetoptLong::REQUIRED_ARGUMENT ]   )    filename
    = ARGV[-1].chomp    opts.each do |opt, arg|       case opt       when ''--help''
              RDoc::usage       when ''--black''           bw(filename)       when
    ''--gallery''           gallery()       when ''--info''           info(filename)
          when ''--resize''           resize(filename, arg)       when ''--watermark''
              watermark(filename, arg)       else           RDoc::usage       end
      end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: (Use any one of the options listed above. I used the `--help` option to generate
    the output in the results section.)
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Synopsis -------- photoUtility.rb: manipulate images to resize, watermark,
    or make a web photo album   Usage ----- photoUtility.rb [OPTIONS] ... IMAGE  -h,
    --help      show help  --bw, -b     convert an image to black and white  --gallery,
    -g     create a web photo album. Enter "temp" for IMAGE when using this option  --info,
    -i     extract the photo information  --resize size, -r size     resize a file
    to a specific dimension  --watermark text, -w text     watermark an image with
    the text supplied  IMAGE: The photo you want to manipulate`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script works as the two previous scripts did, but hopefully you noticed
    the functionality that is incorporated into this script. The code is quite a bit
    longer than any of the previous scripts because we have used GetoptLong to consolidate
    a lot of useful picture manipulation functions into one wicked cool script. The
    major difference is in the number of options available to the user. Each option
    is subsequently put into its own when clause. The `case` statement is a great
    control statement because it reads nicely and can be more efficient to program
    and maintain than several `if`/`else` statements cumbersomely stacked on each
    other. The major functions of this script can be found by looking at the arguments
    section in the `opts` variable ![](../Images/00002.jpg). Options include a help
    message, converting an image to black and white, making a photo gallery, extracting
    the embedded information from the picture, resizing the image, and finally, placing
    a watermark on the image to protect the digital media. Quite a nice array of image
    tools at our disposal, all from this script. You'll also note that the scripts
    from [Chapter 7](../Text/dummy_split_291.html#filepos559796) have been slightly
    modified for proper execution.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in this chapter, whenever you have scripts that are similar
    in content, subject, or any other grouping that makes sense to you, consolidating
    the scripts into a "library" of sorts is a logical step. Instead of keeping up
    with many different files, you're looking at one. But, I would caution you not
    to get overzealous in consolidation or else you might catch a case of the "spaghetti-code
    syndrome," making code maintenance extremely frustrating, if not impossible. Good
    luck in your exploration of GetoptLong, RDoc, and script consolidation.
  prefs: []
  type: TYPE_NORMAL
