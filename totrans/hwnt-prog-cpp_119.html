<html><head></head><body>

<div class="calibre21" id="calibre_pb_0"/><div class="calibre1" id="calibre_toc_133">
<a name="ch13" class="calibre6" id="ch13"/>
<div class="calibre21" id="calibre_pb_1"/><h1 class="title" id="calibre_toc_134"><span class="chapter-titlelabel">Part III: </span> Answers</h1><p class="b24-bookeditorial">
<a name="499" class="calibre6" id="499"/><a name="ch13p01" class="calibre6" id="ch13p01"/><b class="calibre13">Answer 1:</b> The problem is that a large herd contains 10,000 sheep. That's 40,000 legs. The maximum number you can fit in a <span>short int</span> is 32,767. That's smaller than 40,000, so (10,000*4) causes an overflow that results in wrong data being output.</p>
<p class="b24-bookeditorial">
<a name="500" class="calibre6" id="500"/><a name="ch13p02" class="calibre6" id="ch13p02"/><b class="calibre13">Answer 2:</b> The problem is that the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          // The bit we are printing now
          short int bit = (1&lt;&lt;16);
</pre>
</div>
<p class="b24-bookeditorial">does not set the variable bit to 1000 0000 0000 0000(b). Instead, it sets it to 1 0000 0000 0000 0000(b). Unfortunately, it can't hold 17 bits, so the result is that it's set to zero.</p>
<p class="b24-bookeditorial">Because it is zero, the bit test statement will always fail, giving use the result:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          ---------------
</pre>
</div>
<p class="b24-bookeditorial">
<a name="501" class="calibre6" id="501"/><a name="ch13p03" class="calibre6" id="ch13p03"/><b class="calibre13">Answer 3:</b> Global classes are initialized before <span>main</span>. Order is not guaranteed by the compiler. In particular, there is nothing to guarantee that <span>first_name</span> is initialized before it is used. So if the compiler chooses the wrong order, the program will output incorrect data or die.</p>
<p class="b24-bookeditorial">
<a name="502" class="calibre6" id="502"/><a name="ch13p04" class="calibre6" id="ch13p04"/><b class="calibre13">Answer 4:</b> The programmer thought he put two statements inside the <span>if</span>, but he forgot the curly braces.</p>
<p class="b24-bookeditorial">So the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          if (size &gt; MAX)
              std::cout &lt;&lt; "Size is too large\n";
              size = MAX;
</pre>
</div>
<p class="b24-bookeditorial">properly indented looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          if (size &gt; MAX)
              std::cout &lt;&lt; "Size is too large\n";
          size = MAX;
</pre>
</div>
<p class="b24-bookeditorial">What the programmer should have written is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          if (size &gt; MAX)
          {
              std::cout &lt;&lt; "Size is too large\n";
              size = MAX;
          }
</pre>
</div>
<p class="b24-bookeditorial">
<a name="503" class="calibre6" id="503"/><a name="ch13p05" class="calibre6" id="ch13p05"/><b class="calibre13">Answer 5:</b> The problem is that the file type was not specified as binary <span>(ios::bin)</span>. The Microsoft Windows runtime library edits character output and inserts <span>&lt;carriage-return (0xD)&gt;</span> before each <span>&lt;line-feed (0xA)&gt;</span>. This explains the extra <span>0D</span> in the file just before the <span>0A</span> character.</p>
<p class="b24-bookeditorial">
<a name="504" class="calibre6" id="504"/><a name="ch13p06" class="calibre6" id="ch13p06"/><b class="calibre13">Answer 6:</b> The problem is the line:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          6 void main()
</pre>
</div>
<p class="b24-bookeditorial">The function <span>main</span> is not a <span>void</span> function. It's an <span>int</span>. The function returns an exit code to the operating system. A properly written "<a href="LiB0005.html#7" target="_parent" class="calibre2">Hello World</a>" looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
 1 /************************************************
 2  * The "standard" hello world program.          *
 3  ************************************************/
 4 #include &lt;ostream&gt;
 5
 6 int main()
 7 {
 8     std::cout &lt;&lt; "Hello world!\n";
 9     return (0);
10 }
</pre>
</div>
<p class="b24-bookeditorial">When my wife first took programming, this was the first program she was taught (the <span>void</span> version). I changed the <span>void</span> to an <span>int</span> and she turned the paper in. The teaching assistant counted it wrong and changed it back.</p>
<p class="b24-bookeditorial">Needless to say, I was not happy about this and wrote him a very snooty letter telling him that <span>main</span> was an <span>int</span> and quoting him chapter and verse of the C++ standard proving it. He wrote back and was extremely nice about the whole thing.</p>
<p class="b24-bookeditorial">
<a name="505" class="calibre6" id="505"/><a name="ch13p07" class="calibre6" id="ch13p07"/><b class="calibre13">Answer 7:</b> The problem is that <i class="calibre15">sub.cpp</i> defines <span>str</span> as a character array (<span>char []</span>). The extern statement in <i class="calibre15">main.cpp</i> defines <span>str</span> as a character <i class="calibre15">pointer</i> (<span>char *</span>).</p>
<p class="b24-bookeditorial">Now character arrays and character pointers are interchangeable <i class="calibre15">almost</i> everywhere in C++. This is one of the few cases they are not. In this case, the program <span>main</span> thinks that <span>str</span> is a character pointer, so it goes to that location and reads the first four bytes expecting an address. The first four bytes are "Hell," which is not an address, and so the program crashes.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 1:</b> Always define externs in a header file. This header should always be included by the module where the item is defined and every module where it's used.</p>
<p class="b24-bookeditorial">
<a name="506" class="calibre6" id="506"/><a name="ch13p08" class="calibre6" id="ch13p08"/><b class="calibre13">Answer 8:</b> The problem is that <span>ch</span> can be a signed character. That means that if <span>ch</span> is <span>0xFF</span> when converted to a signed integer for comparison purposes you get <span>int(ch)=-1 (0xFFFFFFF)</span>. That's not <span>0xFF</span> and the comparison fails.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 2:</b> Be careful when you use character variables to hold numbers. They may not do what you want them to.</p>
<p class="b24-bookeditorial">
<a name="507" class="calibre6" id="507"/><a name="ch13p09" class="calibre6" id="ch13p09"/><b class="calibre13">Answer 9:</b> The problem is that the optimizer looks at the code and sees that we read <span>*in_port_ptr</span> three times and then throws away the result. The optimizer then figures out that it can optimize the program and produce the same apparent results by taking out the lines 20, 21, and 22.</p>
<p class="b24-bookeditorial">The solution is to declare the port pointers <span>volatile</span>. In Program 107 we've done this, but something is not quite right.</p>
<p class="b24-bookeditorial">
<a name="508" class="calibre6" id="508"/><a name="ch13p10" class="calibre6" id="ch13p10"/><b class="calibre13">Answer 10:</b> The answer is that the <span>printf</span> format (<span>%d</span>) does not match the parameter type (<span>double</span>). The programmer should have written:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        12   printf("pi is %f\n", M_PI);
</pre>
</div>
<p class="b24-bookeditorial">
<a name="509" class="calibre6" id="509"/><a name="ch13p11" class="calibre6" id="ch13p11"/><b class="calibre13">Answer 11:</b> A character has 8 bits numbered 0 to 7. The bits can be represented by the constants (1 &lt;&lt; 0) to (1 &lt;&lt; 7).</p>
<p class="b24-bookeditorial">There is no bit number 8, so the expression</p>
<div class="calibre1">
<pre class="literallayout-normal">
          privs |= P_BACKUP;    // P_BACKUP = (1 &lt;&lt; 8)
</pre>
</div>
<p class="b24-bookeditorial">does nothing because it sets a bit outside the boundary of the character. The result is that only the administration privilege is really set.</p>
<p class="b24-bookeditorial">
<a name="510" class="calibre6" id="510"/><a name="ch13p12" class="calibre6" id="ch13p12"/><b class="calibre13">Answer 12:</b> The <span>operator =</span> function call takes a single parameter of type <span>data_holder</span>. This type of parameter is a call by value parameter, so the copy constructor is called. The programmer making the copy constructor decided to take a shortcut and uses the operator = to implement the copy. So <span>operator =</span> calls the copy constructor, which calls <span>operator =</span> which calls the copy constructor ... and so on until you run out of stack.</p>
<p class="b24-bookeditorial">The <span>operator =</span> function should take a constant reference as its parameter type:</p>
<div class="calibre1">
<pre class="literallayout-normal">
            data_holder &amp;operator = (
                  const data_holder &amp;old_data_holder) {
</pre>
</div>
<p class="b24-bookeditorial">It should also return a reference to a data holder.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 3:</b> Use <span>const</span> references if possible when passing parameters. This avoids the extra cost of doing a copy of a call by value parameter.</p>
<p class="b24-bookeditorial">
<a name="511" class="calibre6" id="511"/><a name="ch13p13" class="calibre6" id="ch13p13"/><b class="calibre13">Answer 13:</b> The problem is with the <span>if</span> statement. In the first one:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (width &lt; MIN) {
            std::cout &lt;&lt; "Width is too small\n";
            width = MIN;
</pre>
</div>
<p class="b24-bookeditorial">the programmer forgot to put in the closing curly brace. That's OK; he made up for it by forgetting to put in an opening brace for the next if statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (height &lt; MIN)
            std::cout &lt;&lt; "Height is too small\n";
            height = MIN;
        }
</pre>
</div>
<p class="b24-bookeditorial">If we properly indent the code, we can see the problem:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (width &lt; MIN) {
            std::cout &lt;&lt; "Width is too small\n";
            width = MIN;

            if (height &lt; MIN)
                 std::cout &lt;&lt; "Height is too small\n";
            height = MIN;
        }
</pre>
</div>
<p class="b24-bookeditorial">What the programmer should have written is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (width &lt; MIN) {
            std::cout &lt;&lt; "Width is too small\n";
            width = MIN;
        }

        if (height &lt; MIN) {
            std::cout &lt;&lt; "Height is too small\n";
            height = MIN;
        }
</pre>
</div>
<p class="b24-bookeditorial">
<a name="512" class="calibre6" id="512"/><a name="ch13p14" class="calibre6" id="ch13p14"/><b class="calibre13">Answer 14:</b> The statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        save_queue = a_queue
</pre>
</div>
<p class="b24-bookeditorial">copies a queue of size 30 to a queue of size 20. In other words, the assignment operator (as implemented) allows us to copy different size queue. We should not be allowed to do this.</p>
<p class="b24-bookeditorial">There are four ways to solve this problem:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Use the STL <span>queue</span> class.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Make the assignment operator private (and not allow any assignments).</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Change the assignment operator so that it throws an exception if the size of the queue is not the same.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Change the <span>queue</span> class so that you can assign different size queues to each other.</p>
</li>
</ol>
<p class="b24-bookeditorial">
<a name="513" class="calibre6" id="513"/><a name="ch13p15" class="calibre6" id="ch13p15"/><b class="calibre13">Answer 15:</b> The constant 02126 is octal because the leading digit is a zero. So in C++, 02126 (octal) is 1110 (decimal) and is not the zip code for Boston.</p>
<p class="b24-bookeditorial">
<a name="514" class="calibre6" id="514"/><a name="ch13p16" class="calibre6" id="ch13p16"/><b class="calibre13">Answer 16:</b> The problem is that the compiler knows what 12 * 34 equals, so instead of doing the multiply it optimizes the statement and turns it into:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        18         result = 408;
</pre>
</div>
<p class="b24-bookeditorial">Since the multiply is not done, the timing is off. Program 109 is an attempt to fix this problem.</p>
<p class="b24-bookeditorial">
<a name="515" class="calibre6" id="515"/><a name="ch13p17" class="calibre6" id="ch13p17"/><b class="calibre13">Answer 17:</b> The problem is that the programmer used bitwise and (&amp;) instead of logical and (&amp;&amp;). A bitwise and of the two numbers gives us:</p>
<div class="calibre1">
<pre class="literallayout-normal">
           3 0011
        &amp; 12 1100
        =========
           0 0000
</pre>
</div>
<p class="b24-bookeditorial">So the result is 0, the <span>if</span> clause is skipped, and the <span>else</span> clause is executed.</p>
<p class="b24-bookeditorial">Some programmers use the shorthand:</p>
<div class="calibre1">
<pre class="literallayout-normal">
           if (x)
</pre>
</div>
<p class="b24-bookeditorial">for</p>
<div class="calibre1">
<pre class="literallayout-normal">
           if (x != 0)
</pre>
</div>
<p class="b24-bookeditorial">(I discourage such shorthand.)</p>
<p class="b24-bookeditorial">This is one example of why I don't like shortcuts. A better way of writing the <span>if</span> statement is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
           if ((i1 != 0) &amp;&amp; (i2 != 0))
</pre>
</div>
<p class="b24-bookeditorial">Shortly after discovering this bug I told a colleague about it. I explained what happened and said, "I now know the difference between 'and' and 'and and'." I'm not sure what amazed me more, the fact that I came up with this sentence or the fact the he understood it.</p>
<p class="b24-bookeditorial">
<a name="516" class="calibre6" id="516"/><a name="ch13p18" class="calibre6" id="ch13p18"/><b class="calibre13">Answer 18:</b> The problem is that <span>tmp_name</span> returns a pointer to the local variable <span>name</span>. When the function ends, the storage for all nonstatic local variables is reclamined. This includes the storage for <span>name</span>. Thus, the pointer returned points to a random, unallocated section of memory.</p>
<p class="b24-bookeditorial">The next function call that comes along will probably clobber that storage and make <span>a_name</span> look really strange.</p>
<p class="b24-bookeditorial">A solution to this problem is to declare <span>name</span> <b class="calibre13">static.</b>
</p>
<p class="b24-bookeditorial">(See <a href="LiB0063.html#69" target="_parent" class="calibre2">Program 59</a> for a similar problem.)</p>
<p class="b24-bookeditorial">
<a name="517" class="calibre6" id="517"/><a name="ch13p19" class="calibre6" id="ch13p19"/><b class="calibre13">Answer 19:</b> The problem is that the statement</p>
<div class="calibre1">
<pre class="literallayout-normal">
           bit &gt;&gt;= 1;
</pre>
</div>
<p class="b24-bookeditorial">does not move the bit over to the right one. Instead it does a "signed" shift, which copies the sign bit. Thus</p>
<div class="calibre1">
<pre class="literallayout-normal">
       0x8000 &gt;&gt; 1      1000 0000 0000 0000 (b)
</pre>
</div>
<p class="b24-bookeditorial">is not</p>
<div class="calibre1">
<pre class="literallayout-normal">
       0x4000           0100 0000 0000 0000 (b)
</pre>
</div>
<p class="b24-bookeditorial">as expected but instead</p>
<div class="calibre1">
<pre class="literallayout-normal">
       0xC000           1100 0000 0000 0000 (b)
</pre>
</div>
<p class="b24-bookeditorial">Because of this problem, the bit testing gives incorrect results.</p>
<p class="b24-bookeditorial">
<a name="518" class="calibre6" id="518"/><a name="ch13p20" class="calibre6" id="ch13p20"/><b class="calibre13">Answer 20:</b> The arguments to <span>memset</span> are:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        memset(
            void *ptr,// Pointer to the data
            int value,// Value to set
            size_t size// Number of bytes to fill
        );
</pre>
</div>
<p class="b24-bookeditorial">In this case, the value is <span>sizeof(array)</span> and the number of bytes to fill is 0. Since <span>size=0</span> nothing was done.</p>
<p class="b24-bookeditorial">The programmer should have written:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        memset(array, '\0', sizeof(array));
</pre>
</div>
<p class="b24-bookeditorial">
<a name="519" class="calibre6" id="519"/><a name="ch13p21" class="calibre6" id="ch13p21"/><b class="calibre13">Answer 21:</b> The C++ standard states that all pointers must point to the array or above. You can't point below the array.</p>
<p class="b24-bookeditorial">In this example, we have an array on an Intel machine. The address of the array, in Intel strange pointer parlance, is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
            5880:0000
</pre>
</div>
<p class="b24-bookeditorial">The <span>data_ptr</span> variable starts out at:</p>
<div class="calibre1">
<pre class="literallayout-normal">
            5880:001E
</pre>
</div>
<p class="b24-bookeditorial">It then gets decremented as long as it is greater than <span>data</span>. During its decrementation <span>data_ptr</span> goes to</p>
<div class="calibre1">
<pre class="literallayout-normal">
            5880:0000
</pre>
</div>
<p class="b24-bookeditorial">That's equal to the address of the array data, so it's decremented again. (Remember that in this memory model, only the address part is changed.) The result is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
            5880:FFFE
</pre>
</div>
<p class="b24-bookeditorial">Now</p>
<div class="calibre1">
<pre class="literallayout-normal">
            data_ptr &gt;= data
</pre>
</div>
<p class="b24-bookeditorial">is evaluated. But <span>data_ptr</span> is now much greater than <span>data</span>, so the program continues.</p>
<p class="b24-bookeditorial">The result is that the program writes over random data, which can cause the system to crash. But if it doesn't, <span>data_ptr</span> will go down to:</p>
<div class="calibre1">
<pre class="literallayout-normal">
            5880:0000
</pre>
</div>
<p class="b24-bookeditorial">wrap, and the process will continue again.</p>
<p class="b24-bookeditorial">
<a name="520" class="calibre6" id="520"/><a name="ch13p22" class="calibre6" id="ch13p22"/><b class="calibre13">Answer 22:</b> The problem is that the function <span>max</span> returns a reference to a parameter. That parameter is <span>3+4</span>, which is an expression.</p>
<p class="b24-bookeditorial">What C++ actually does when <span>min</span> is called is:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Creates a temporary (<span>tmp1</span>) and assigns it 1+2</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Creates a temporary (<span>tmp2</span>) and assigns it 3+4</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Calls <span>max(tmp1, tmp2)</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">This function returns a reference to <span>tmp2</span>.</p>
<div class="calibre1">
<pre class="literallayout-normal">
i = &amp;tmp2
tmp1 destroyed
tmp2 destroyed
</pre>
</div>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">The variable <span>i</span> is now a reference to nothing.</p>
</li>
</ol>
<p class="b24-bookeditorial">The problem is caused by returning a reference to a parameter. This creates a dangling reference.</p>
<p class="b24-bookeditorial">
<a name="521" class="calibre6" id="521"/><a name="ch13p23" class="calibre6" id="ch13p23"/><b class="calibre13">Answer 23:</b> The programmer did not put spaces in the output text for the line:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        13    std::cout &lt;&lt; "Twice" &lt;&lt; number &lt;&lt; "is" &lt;&lt;
        14        (number *2) &lt;&lt; '\n';
</pre>
</div>
<p class="b24-bookeditorial">as a result, the output looks like</p>
<div class="calibre1">
<pre class="literallayout-normal">
        Twice5is10
</pre>
</div>
<p class="b24-bookeditorial">What he should have written is:</p>
<div class="calibre1">
<span><img src="fig237_01.jpg" alt="" border="0" class="calibre29"/></span>
</div>
<p class="b24-bookeditorial">
<a name="522" class="calibre6" id="522"/><a name="ch13p24" class="calibre6" id="ch13p24"/><b class="calibre13">Answer 24:</b> This is a classic deadlock problem:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="b24-bookeditorial">Process 1 requires resources #1 and #2.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Process 2 requires resources #2 and #1.</p>
</li>
</ul>
<p class="b24-bookeditorial">They get the resources in that order. Remember that thread switches can occur at any time.</p>
<p class="b24-bookeditorial">So we have a race condition in which the following can occur:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Process 1 gets resource #1</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Thread switch to process 2</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Process 2 gets resource #2</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Process 2 attempts to get resource #1</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Resource #1 is unavailable, so the process sleeps until it is freed (keeping resource #2 locked while it works)</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Thread switch to process 1</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Process 1 attempts to get resource #2. It's locked, so the process sleeps until it is freed. (Resource #1 is kept locked in the meantime.)</p>
</li>
</ol>
<p class="b24-bookeditorial">The result is that process 1 is waiting for resource #2 while holding resource #1. It will not give up resource #1 until it gets resource #2.</p>
<p class="b24-bookeditorial">Process 2 is waiting for resource #1 while holding resource #2. It will not give up resource #2 until it gets process #1.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 4:</b> Define locking order (for example, you must get the locks in the order #1, #2). Always use this locking order when getting multiple locks.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Alternate:</b> When getting multiple locks, use the following algorithm:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Attempt to get all the locks (do not block if they are not available).</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">If you've got everything, then go on and do your job.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">If you didn't get all the locks, free the ones you didn't get, sleep a while, and try again.</p>
</li>
</ol>
<p class="b24-bookeditorial">
<a name="523" class="calibre6" id="523"/><a name="ch13p25" class="calibre6" id="ch13p25"/><b class="calibre13">Answer 25:</b> The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (n2 =! 0)
</pre>
</div>
<p class="b24-bookeditorial">This is an assignment statement inside an <span>if</span>. If we rewrite the code to avoid the shortcut, we get the two statements.:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        n2 = !0;
        if (n2)
</pre>
</div>
<p class="b24-bookeditorial">The use of the logical not in this context ( <span>!0</span> ) gives us a result of 1. So we always assign <span>n2</span> the value 1, then do the comparison and divide.</p>
<p class="b24-bookeditorial">The <span>!=</span> was written backwards as <span>=!</span> thus giving us the surprise.</p>
<p class="b24-bookeditorial">The statement should have read:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (n2 != 0)
</pre>
</div>
<p class="b24-bookeditorial">
<a name="524" class="calibre6" id="524"/><a name="ch13p26" class="calibre6" id="ch13p26"/><b class="calibre13">Answer 26:</b> The problem is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
            diff[diff_index++] =
                array[i++] - array[i++];
</pre>
</div>
<p class="b24-bookeditorial">This tells the compiler to:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Increment <span>i</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Use it to index array (first occurrence)</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Increment <span>i</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Use it to index array (second occurrence)</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Compute the difference</p>
</li>
</ol>
<p class="b24-bookeditorial">The problem is that steps 1-4 can occur in a different order:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Increment <span>i</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Increment <span>i</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Use it to index array (first occurrence)</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Use it to index array (second occurrence)</p>
</li>
</ol>
<p class="b24-bookeditorial">Statements with many side effects give the C++ compiler latitude to screw things up.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 5:</b> Put side effects like <span>++</span> and <span>--</span> on lines by themselves.</p>
<p class="b24-bookeditorial">
<a name="525" class="calibre6" id="525"/><a name="ch13p27" class="calibre6" id="ch13p27"/><b class="calibre13">Answer 27:</b> The problem is that "1" is an integer. The number "3" is also an integer. So "1/3" is an integer divide.</p>
<p class="b24-bookeditorial">Thus, the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        12    result = 1/3;     // Assign result something
</pre>
</div>
<p class="b24-bookeditorial">does an integer divide of 1 by 3. Integer divides truncate the fractional part so the result is 0. The integer "0" is turned into floating-point and assigned result.</p>
<p class="b24-bookeditorial">The programmer should have written this as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        12    result = 1.0 / 3.0;// Assign result something
</pre>
</div>
<p class="b24-bookeditorial">
<a name="526" class="calibre6" id="526"/><a name="ch13p28" class="calibre6" id="ch13p28"/><b class="calibre13">Answer 28:</b> The <span>scanf</span> function is extremely tricky to use. In this program the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        22          scanf("%c %d", &amp;oper, &amp;value);
</pre>
</div>
<p class="b24-bookeditorial">gets a character and a integer. The next time <span>scanf</span> is called, it will read another character and integer. So what's the next character? Let's look at the sample run:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        % <span class="underline" style="text-decoration:underline">calc</span>
        Enter operator and value:<span class="underline" style="text-decoration:underline">+ 5</span>
        Total: 5
        Enter operator and value:<span class="underline" style="text-decoration:underline">+ 10</span>
        Bad operator entered
        Total: 5
        Enter operator and value:Bad operator entered
        Total: 5
        Enter operator and value:q
        Bad operator entered
        Total: 5
        Enter operator and value:<span class="underline" style="text-decoration:underline">q</span>
</pre>
</div>
<p class="b24-bookeditorial">The first line we type is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        + 5
</pre>
</div>
<p class="b24-bookeditorial">After the first <span>scanf</span> call, the input pointer is position just before the newline just after the <span>5</span>. The next <span>scanf</span> tries to read the operator and gets the newline. It keeps reading and sees a <span>+</span> instead of a number. The result is a lot of confusion.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 6:</b> The <span>scanf</span> function is tricky to get right. But I have a simple way of dealing with this problem: I never use it. Instead I always use a combination of <span>fgets</span> and <span>sscanf</span> instead.</p>
<div class="calibre1">
<pre class="literallayout-normal">
           fgets(line, sizeof(line), stdin);
           sscanf(line, "%c %d", &amp;operator, &amp;value);

</pre>
</div>
<p class="b24-bookeditorial">
<a name="527" class="calibre6" id="527"/><a name="ch13p29" class="calibre6" id="ch13p29"/><b class="calibre13">Answer 29:</b> The preprocessor does not understand C++ syntax. When we define <span>TOTAL</span> to be <span>37 + 33</span>, it is literally <span>37 + 33</span> and not <span>70</span>.</p>
<p class="b24-bookeditorial">The <span>AREA</span> macro is defined as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        37 + 33 * 10
</pre>
</div>
<p class="b24-bookeditorial">Operator precedence takes over and gives us the wrong answer.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 7:</b> Use constants instead of defined macros whenever possible.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 8:</b> Put parenthesis around all <span>#defines</span> that define anything other than a simple number.</p>
<p class="b24-bookeditorial">Example:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        // Total top size
        #define TOP_TOTAL (TOP_PART1 + TOP_PART2)
</pre>
</div>
<p class="b24-bookeditorial">
<a name="528" class="calibre6" id="528"/><a name="ch13p30" class="calibre6" id="ch13p30"/><b class="calibre13">Answer 30:</b> The problem is that the function is returning a reference to a local variable. This is a bad thing because the local variable is destroyed by the return; the reference is what is called a <i class="calibre15">dangling reference.</i> It's referring to something that is no longer there.</p>
<p class="b24-bookeditorial">When we try to print the string that is no longer there, we run into trouble.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 9:</b> Do not return references to local variables.</p>
<p class="b24-bookeditorial">
<a name="529" class="calibre6" id="529"/><a name="ch13p31" class="calibre6" id="ch13p31"/><b class="calibre13">Answer 31:</b> The problem is that the <span>else</span> clause goes with the nearest <span>if</span>. The properly indented code looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        23 if (balance &lt; 0)
        24     if (balance &lt; - (100*DOLLAR))
        25         cout &lt;&lt; "Credit " &lt;&lt; -balance &lt;&lt; endl;
        26     else
        27         cout &lt;&lt; "Debt " &lt;&lt; balance &lt;&lt; endl;
</pre>
</div>
<p class="b24-bookeditorial">This is not what the programmer intented. What he wanted to do was:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (balance &lt; 0) {
            if (balance &lt; - (100*DOLLAR))
                cout &lt;&lt; "Credit " &lt;&lt; -balance &lt;&lt; endl;
        } else
            cout &lt;&lt; "Debt " &lt;&lt; balance &lt;&lt; endl;
</pre>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 10:</b> Use {} around statements under the control of an <span>if</span>, <span>for</span>, <span>while</span>, or other control statement if there is more than one statement conditional control.</p>
<p class="b24-bookeditorial">(That's a fancy way of saying: Don't write code like this.)</p>
<div class="calibre1">
<table class="calibre3" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr class="calibre4">
<td class="bluecell"><span class="calibre22"><b class="calibre13"><img src="_1.gif" alt="Start Sidebar" border="0" class="calibre23"/></b></span></td>
</tr>
</table>
<p class="b24-bookeditorial">Bonus question: This fixes most of the problems, but there's still a bug in this program. What is it? (Next <a href="LiB0120.html#248" target="_parent" class="calibre2">Hint 112</a>. <a class="calibre2" href="#ch13p38">Answer 38</a>.)</p>
<table class="calibre3" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr class="calibre4">
<td class="bluecell"><span class="calibre22"><b class="calibre13"><img src="_1.gif" alt="End Sidebar" border="0" class="calibre23"/></b></span></td>
</tr>
</table>
</div>
<table class="calibre3" border="0" cellspacing="0" cellpadding="0" width="100%">
<tr class="calibre4">
<td height="16" class="calibre8"/>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="530" class="calibre6" id="530"/><a name="ch13p32" class="calibre6" id="ch13p32"/><b class="calibre13">Answer 32:</b> The problem is that memory is allocated in the constructor and never freed.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 11:</b> Always <b class="calibre13">delete</b> in the destructor what you <b class="calibre13">new</b> in the constructor.</p>
<p class="b24-bookeditorial">This rule was not followed, so every time we created a stack some of the heap permanently went away.</p>
<p class="b24-bookeditorial">
<a name="531" class="calibre6" id="531"/><a name="ch13p33" class="calibre6" id="ch13p33"/><b class="calibre13">Answer 33:</b> The program prints:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        First: John
        Last:  Smith
        Hello: John
         Smith
</pre>
</div>
<p class="b24-bookeditorial">The problem is that <span>fgets</span> gets a line including the newline. So when the first name is read, it's read as <span>John\n</span>. The same thing happens with Smith, and the result is our funny output.</p>
<p class="b24-bookeditorial">
<a name="532" class="calibre6" id="532"/><a name="ch13p34" class="calibre6" id="ch13p34"/><b class="calibre13">Answer 34:</b> There is a extra semicolon at the end of the <span>for</span> statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
            for (index = 1; index &lt;= 10; ++index);
</pre>
</div>
<p class="b24-bookeditorial">This means that the for controls absolutely nothing. Properly indented the program is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        for (index = 1; index &lt;= 10; ++index);
        std::cout &lt;&lt; index &lt;&lt; " squared " &lt;&lt;
             (index * index) &lt;&lt; '\n';
</pre>
</div>
<p class="b24-bookeditorial">or if we add a little commenting this looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        for (index = 1; index &lt;= 10; ++index)
            /* Do nothing */;
        std::cout &lt;&lt; index &lt;&lt; " squared " &lt;&lt;
            (index * index) &lt;&lt; '\n';
</pre>
</div>
<p class="b24-bookeditorial">From this we can see that the <span>std::cout</span> line is not inside the <span>for</span> loop.</p>
<p class="b24-bookeditorial">
<a name="533" class="calibre6" id="533"/><a name="ch13p35" class="calibre6" id="ch13p35"/><b class="calibre13">Answer 35:</b> The problem is that we declared a local variable named <span>remove</span>. There is a standard function named <span>remove</span> as well. Our local variable hid the function for the scope of the local variable.</p>
<p class="b24-bookeditorial">That scope ended at the end of the first <span>if</span> on line 15.</p>
<p class="b24-bookeditorial">The next statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        16    if (remove) {
</pre>
</div>
<p class="b24-bookeditorial">checks to see if the address of the function <span>remove</span> is non-zero and executes the next statement if it is.</p>
<div class="calibre1">
<span><a href="fig242_01_0.jpg" name="IMG_4" target="_parent" class="calibre2" id="IMG_4"><img src="fig242_01.jpg" alt="Click To expand" border="0" class="calibre30"/></a></span>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 12:</b> Avoid hidden variables.</p>
<p class="b24-bookeditorial">
<a name="534" class="calibre6" id="534"/><a name="ch13p36" class="calibre6" id="ch13p36"/><b class="calibre13">Answer 36:</b> The problem is that the string we return is defined as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         15     // The name we are generating
         16     std::string name;
</pre>
</div>
<p class="b24-bookeditorial">This is a local variable. The subroutine returns a reference to this string. But because it's a local variable, it's destroyed at the end of the function. That means when we use the result, the variable holding the result has been destroyed.</p>
<p class="b24-bookeditorial">
<a name="535" class="calibre6" id="535"/><a name="ch13p37" class="calibre6" id="ch13p37"/><b class="calibre13">Answer 37:</b> The problem is that the backslash character is used as an escape character. So <span>\n</span> is newline. <span>\new</span> is <span>&lt;newline&gt;ew</span>.</p>
<p class="b24-bookeditorial">So the string <span>\root\new\table</span> decodes as</p>
<div class="calibre1">
<pre class="literallayout-normal">
       "&lt;return&gt;oot&lt;newline&gt;ew&lt;tab&gt;able"
</pre>
</div>
<p class="b24-bookeditorial">What the programmer really wanted was:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       const char name[] = "\\root\\new\\table";  // DOS path
</pre>
</div>
<p class="b24-bookeditorial">Ironically, this rule does not apply to <span>#include</span> file names so</p>
<div class="calibre1">
<pre class="literallayout-normal">
       #include "\usr\include\table.h"
</pre>
</div>
<p class="b24-bookeditorial">works and is correct.</p>
<p class="b24-bookeditorial">
<a name="536" class="calibre6" id="536"/><a name="ch13p38" class="calibre6" id="ch13p38"/><b class="calibre13">Answer 38:</b> The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if (balance &lt; 0)
</pre>
</div>
<p class="b24-bookeditorial">This is used to check to see if the customer owes the company something. Thus, the customer can see a message like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       You owe 0.

</pre>
</div>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">This actually happened to one person. He got a bill for $0.00. He called up the company, they apologized, and the next month he got a bill for $0.00. This continued for many months. Each time he called the company, they would apologize and tell him they would fix the problem, but nothing would happen.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">He even got charged a late fee of 5%. This brought his bill up to $0.00.</p>
<p class="b24-bookeditorial">Finally, he sent them a check for $0.00.</p>
<p class="b24-bookeditorial">That week he got a nasty phone call from his bank. "Why did you write out such a check?" they demanded to know.</p>
<p class="b24-bookeditorial">It seems that the check crashed its computer system. So the check was bounced, and the next week he received a bill for $0.00.</p>
<p class="b24-bookeditorial">
<a name="537" class="calibre6" id="537"/><a name="ch13p39" class="calibre6" id="ch13p39"/><b class="calibre13">Answer 39:</b> The problem is that the optimizer is smart. It sees that we are computing the result of</p>
<div class="calibre1">
<pre class="literallayout-normal">
        factor1 * factor2;
</pre>
</div>
<p class="b24-bookeditorial">inside the <span>for</span> loop. The answer won't change if we move this to outside the <span>for</span> loop, but things will go quicker. So the optimized version of this program does the multiply only one time:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        17     int register1 = factor1 * factor2;
        18     // We know that 1863 multiplies
        19     // delay the proper amount
        20     for (i = 0; i &lt; 1863; ++i)
        21     {
        22         result = register1;
        23     }
</pre>
</div>
<p class="b24-bookeditorial">To fix this problem we need to declare our factor <span>volatile</span>.</p>
<div class="calibre1">
<pre class="literallayout-normal">
         1 /************************************************
         2 * bit_delay -- Delay one bit time for           *
         3 *      serial output.                           *
         4 *                                               *
         5 * Note: This function is highly system          *
         6 *      dependent.  If you change the            *
         7 *      processor or clock it will go bad.       *
         8 *************************************************/
         9 void bit_delay(void)
        10 {
        11     int i;      // Loop counter
        12     volatile int result;// Result of the multiply
        13
        14     // Factors for multiplication
        15     volatile int factor1 = 12;
        16     volatile int factor2 = 34;
        17
        18     // We know that 1863 multiples delay
        19     // the proper amount
        20     for (i = 0; i &lt; 1863; ++i)
        21     {
        22         result = factor1 * factor2;
        23     }
        24 }
</pre>
</div>
<p class="b24-bookeditorial">It's things like this that make embedded programming so simple.</p>
<p class="b24-bookeditorial">
<a name="538" class="calibre6" id="538"/><a name="ch13p40" class="calibre6" id="ch13p40"/><b class="calibre13">Answer 40:</b> The problem is that <span>ostream</span> is passed as "pass by value". You can't copy stream variables. (If you did it would mean that the system would have to make a copy of the file.) The parameter should be changed to a "pass by reference" parameter:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        void print_msg_one(
            // File to write the message to
            class ostream &amp;out_file,

            // Where to send it
            const char msg[]
        )
</pre>
</div>
<p class="b24-bookeditorial">
<a name="539" class="calibre6" id="539"/><a name="ch13p41" class="calibre6" id="ch13p41"/><b class="calibre13">Answer 41:</b> The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        strcat(file_name, '/');
</pre>
</div>
<p class="b24-bookeditorial">The <span>strcat</span> function takes two strings as arguments. In this example, we've given it a string and a character. Because there are no prototypes, C can't do parameter checking; the incorrect parameter is passed to <span>strcat</span>, which gets very confused.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 13:</b> All functions should be explicitly declared. Never let C declare them implicitly. Make sure you include the headers that define the prototypes for all the functions that you use.</p>
<p class="b24-bookeditorial">
<a name="540" class="calibre6" id="540"/><a name="ch13p42" class="calibre6" id="ch13p42"/><b class="calibre13">Answer 42:</b> A signed one-bit number can have one of two values: 0 and -1.</p>
<p class="b24-bookeditorial">The statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       printer_status.online = 1;
</pre>
</div>
<p class="b24-bookeditorial">fails because the one-bit-wide field can't hold the value 1. (So it overflows and assigns the variable the value -1!) The result is that the next statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if (printer_status == 1)
</pre>
</div>
<p class="b24-bookeditorial">fails.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 14:</b> Single bit fields should be <span>unsigned</span>.</p>
<p class="b24-bookeditorial">
<a name="541" class="calibre6" id="541"/><a name="ch13p43" class="calibre6" id="ch13p43"/><b class="calibre13">Answer 43:</b> On MS-DOS you'll get something like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      The answer is 4C:&gt;<span class="underline" style="text-decoration:underline">#</span>
      (<span class="underline" style="text-decoration:underline">#</span> is the cursor)
</pre>
</div>
<p class="b24-bookeditorial">On UNIX you might get something like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      The answer is 4$ <span class="underline" style="text-decoration:underline">#</span>
</pre>
</div>
<p class="b24-bookeditorial">The problem is that the programmer did not add an end of line at the end of the <span>std::cout</span> statement. The result is that the program runs, outputs a statement, and exists leaving the cursor positioned at the end of a line. The command processor then runs and outputs its prompt (C:&gt; for MS-DOS, $ for UNIX) right next to the program's output.</p>
<p class="b24-bookeditorial">What the programmer should have written is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      std::cout &lt;&lt; "The answer is " &lt;&lt; result &lt;&lt; '\n';
</pre>
</div>
<p class="b24-bookeditorial">
<a name="542" class="calibre6" id="542"/><a name="ch13p44" class="calibre6" id="ch13p44"/><b class="calibre13">Answer 44:</b> Commas can be used to separate C++ statements. It's used like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      if (x)
          std::cout &lt;&lt; "X set. Clearing\n", x = 0;
</pre>
</div>
<p class="b24-bookeditorial">(Don't program like this, please!)</p>
<p class="b24-bookeditorial">The statment</p>
<div class="calibre1">
<pre class="literallayout-normal">
       one_million = 1,000,000;
</pre>
</div>
<p class="b24-bookeditorial">is the same as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       one_million = 1,
       000,
       000;
</pre>
</div>
<p class="b24-bookeditorial">or</p>
<div class="calibre1">
<pre class="literallayout-normal">
       one_million = 1;
       000;
       000;
</pre>
</div>
<p class="b24-bookeditorial">From this, we can see why we get 1 as out output.</p>
<p class="b24-bookeditorial">
<a name="543" class="calibre6" id="543"/><a name="ch13p45" class="calibre6" id="ch13p45"/><b class="calibre13">Answer 45:</b> The problem is that the expression <span>ch+1</span> is an integer (value 66). C++ detects this and calls the <span>std::cout.operator &lt;&lt;(int)</span> function and outputs an integer.</p>
<p class="b24-bookeditorial">What the programer should have written is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
     std::cout &lt;&lt; static_cast&lt;char&gt;(ch+1);
     std::cout &lt;&lt; static_cast&lt;char&gt;(ch+2);
</pre>
</div>
<p class="b24-bookeditorial">
<a name="544" class="calibre6" id="544"/><a name="ch13p46" class="calibre6" id="ch13p46"/><b class="calibre13">Answer 46:</b> The output is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
     The double of 1 is 2
     The double of 2 is 3
     The double of 3 is 4
     The double of 4 is 5
     The double of 5 is 6
</pre>
</div>
<p class="b24-bookeditorial">The reason is that <span>DOUBLE(i+1)</span> expands to:</p>
<div class="calibre1">
<pre class="literallayout-normal">
     (i+1 * 2)
</pre>
</div>
<p class="b24-bookeditorial">When C++ sees this, it multiplies 1 by 2 and adds <span>i</span>. This result is not what the programmer intended.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 15:</b> Use <b class="calibre13">inline</b> functions instead of macros whenever possible.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 16:</b> Always put () around the parameters of macros. Example:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      #define DOUBLE(x) ((x) * 2)
</pre>
</div>
<p class="b24-bookeditorial">
<a name="545" class="calibre6" id="545"/><a name="ch13p47" class="calibre6" id="ch13p47"/><b class="calibre13">Answer 47:</b> The statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if (amount = 0)
</pre>
</div>
<p class="b24-bookeditorial">assigns 0 to amount, then compares the result to see if it's not zero. It is zero, so the <span>else</span> clause is executed.</p>
<p class="b24-bookeditorial">The programmer should have written the statement as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      if (amount == 0)

</pre>
</div>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">One of the most rewarding experiences I had when I was teaching programming was when I met a student about two months after the class had finished.</p>
<p class="b24-bookeditorial">"Steve," he said. "I have to tell you that during the class I thought you were going a bit overboard about this '=' vs. '==' stuff — until yesterday. You see, I wrote my first real program and guess what mistake I made?"</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="546" class="calibre6" id="546"/><a name="ch13p48" class="calibre6" id="ch13p48"/><b class="calibre13">Answer 48:</b> Use the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        i = 3 - i;

</pre>
</div>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">This algorithm was first found lurking in an article as an example of how not to do the job. The author's "ideal" way of doing things was to use the following code:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         switch (i) {
             case 1
                 i = 2;
                 break;
             case 2:
                 i = 1;
                 break;
             default:
                 std::cerr &lt;&lt; "Error: i is not 1 or 2\n";
                 exit (99)
         }
</pre>
</div>
<p class="b24-bookeditorial">The point the author was trying to make was that you should check for illegal values in your code.</p>
<p class="b24-bookeditorial">Sharp-eyed readers may notice that there's a syntax error in this code. There was a similar problem in the "ideal" solution in the original article. In other words, the code the author presented as "ideal" wouldn't work.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="547" class="calibre6" id="547"/><a name="ch13p49" class="calibre6" id="ch13p49"/><b class="calibre13">Answer 49:</b> The problem is that C++'s operator precedence is not what the programmer thought it was. The + operator comes before &lt;&lt; so</p>
<div class="calibre1">
<pre class="literallayout-normal">
           y = x&lt;&lt;2 + 1;
</pre>
</div>
<p class="b24-bookeditorial">gets parsed as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
           y = x &lt;&lt; (2+1);
</pre>
</div>
<p class="b24-bookeditorial">The result is <span>1&lt;&lt;4</span> or 8.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 17:</b> Use the simple C++ precedence rules:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">*, / and % come before + and -.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Put () around everything else.</p>
</li>
</ol>
<p class="b24-bookeditorial">
<a name="548" class="calibre6" id="548"/><a name="ch13p50" class="calibre6" id="ch13p50"/><b class="calibre13">Answer 50:</b> It prints</p>
<div class="calibre1">
<pre class="literallayout-normal">
      Hello
      Hello
</pre>
</div>
<p class="b24-bookeditorial">The problem is that when the <span>fork</span> occurs, there is data in the <span>printf</span> buffer. The fork creates two copies of the process and two copies of the data in the <span>printf</span> buffer. Thus, when the buffer is flushed later (in both processes) we get a Hello from each of them.</p>
<p class="b24-bookeditorial">
<a name="549" class="calibre6" id="549"/><a name="ch13p51" class="calibre6" id="ch13p51"/><b class="calibre13">Answer 51:</b> The programmer never bothered to initialize <span>sum</span>. You can't count on a uninitialized value containing anything. So <span>sum</span> may start out at 0, 5190, 123, 5, or something else.</p>
<p class="b24-bookeditorial">What the programmer should have written is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       9   int sum = 0;

</pre>
</div>
<p class="b24-bookeditorial">
<a name="550" class="calibre6" id="550"/><a name="ch13p52" class="calibre6" id="ch13p52"/><b class="calibre13">Answer 52:</b> The problem is the line</p>
<div class="calibre1">
<pre class="literallayout-normal">
       flags |= CD_SIGNAL;
</pre>
</div>
<p class="b24-bookeditorial">This operation is not protected against thread switches. On a complex instruction machine, the assembly code for this looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       ; 80x86 assembly
       orb $2,flags
</pre>
</div>
<p class="b24-bookeditorial">Thread switches occur only on an instruction boundary. So this operation cannot be interrupted on the 80x86 machine family.</p>
<p class="b24-bookeditorial">But on a RISC machine such as a Sparc, the code looks a little different:</p>
<div class="calibre1">
<pre class="literallayout-normal">
1. sethi %hi(flags),%o0    ; Get the address of the flags in %o0,%o1
2. sethi %hi(flags),%o1
3. ld [%o1+%lo(flags)],%o2 ;%o2 = contents of the variable flags
4. or %o2,2,%o1             ;%o1 = The results of seeting the flag
5. st %o1,[%o0+%lo(flags)] ;Store results in %o0
</pre>
</div>
<p class="b24-bookeditorial">So now the C++ statement is interruptible. In particular, the following can happen:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">The program runs and completes instruction 3. At this point, the value of flags is in register %o2.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">A thread switch occurs.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">The other process modifies flags.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">The thread switches back.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">The old value of flags is in register %o2.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">The bit is set, and the result is stored. Because this contained the old value of flags, any changes made in the other thread are discarded accidently.</p>
</li>
</ol>
<p class="b24-bookeditorial">The solution to this problem is to use locks to prevent a task switch from occurring during the statement.</p>
<p class="b24-bookeditorial">
<a name="551" class="calibre6" id="551"/><a name="ch13p53" class="calibre6" id="ch13p53"/><b class="calibre13">Answer 53:</b> The statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
    48       printf("%o\t", matrix[row][col]);
</pre>
</div>
<p class="b24-bookeditorial">prints the answer in octal. The programmer made an error and put <span>%o</span> where he wanted <span>%d</span>. The result is that the numbers are correct, just in the wrong base.</p>
<p class="b24-bookeditorial">
<a name="552" class="calibre6" id="552"/><a name="ch13p54" class="calibre6" id="ch13p54"/><b class="calibre13">Answer 54:</b> The problem is that you can't represent 1/3 exactly in floatingpoint. Let's see what happens when we add the numbers in decimal.</p>
<div class="calibre1">
<pre class="literallayout-normal">
       1/3 = 0.33333
       1/3 = 0.33333
       1/3 = 0.33333
       -------------
             0.99999

</pre>
</div>
<p class="b24-bookeditorial">Because of the roundoff error, the result is not 1.</p>
<p class="b24-bookeditorial">Remember that when using floating-point, the numbers are not exact.</p>
<p class="b24-bookeditorial">
<a name="553" class="calibre6" id="553"/><a name="ch13p55" class="calibre6" id="ch13p55"/><b class="calibre13">Answer 55:</b> The problem is that we throw an exception in a destructor.</p>
<p class="b24-bookeditorial">When the program reaches the line:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if (i3 &lt; 0)
           throw (problem("Bad data"));
</pre>
</div>
<p class="b24-bookeditorial">the exception code takes charge. It destroys all the local variables. That includes the variable <span>a_stack</span>.</p>
<p class="b24-bookeditorial">When <span>a_stack</span> is destroyed, the destructor is called:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       ~stack(void) {
           if (count != 0) {
               throw (problem("Stack not empty"));
           }
       }
</pre>
</div>
<p class="b24-bookeditorial">The destructor throws an exception. C++ does not like it when you throw an exception in an exception. When that happens the program calls the <span>terminate()</span> function.</p>
<p class="b24-bookeditorial">If you want to catch the second exception and other similar exception problems, use the standard function <span>set_terminate</span> to establish a function to take care of unexpected problems.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 18:</b> Don't throw exceptions in destructors.</p>
<p class="b24-bookeditorial">
<a name="554" class="calibre6" id="554"/><a name="ch13p56" class="calibre6" id="ch13p56"/><b class="calibre13">Answer 56:</b> The problem is that the redefined <span>new</span> function is implemented incorrectly. The programmer assumed that when a person does a</p>
<div class="calibre1">
<pre class="literallayout-normal">
       new fast_bit_array
</pre>
</div>
<p class="b24-bookeditorial">the size of the allocated object is <span>sizeof(fast_bit_array)</span>. This is not <span>true</span> when <span>fast_bit_array</span> is used as a base class. In this case, the size of the allocated memory is the size of the derived class <span>safe_bit_array</span>, which is bigger than <span>fast_bit_array</span>, thus resulting in memory confusion.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 19:</b> Don't define your own operator <span>new</span> function unless you're sure what you're doing. If you are sure you know what you're doing, make sure you're really really sure. Even then don't do it unless it's absolutely necessary.</p>
<p class="b24-bookeditorial">
<a name="555" class="calibre6" id="555"/><a name="ch13p57" class="calibre6" id="ch13p57"/><b class="calibre13">Answer 57:</b> The problem is that there are two variable declarations:</p>
<p class="b24-bookeditorial">
<i class="calibre15">File: main.cpp</i>
</p>
<div class="calibre1">
<pre class="literallayout-normal">
           int value = 20;
</pre>
</div>
<p class="b24-bookeditorial">
<i class="calibre15">File: check.cpp</i>
</p>
<div class="calibre1">
<pre class="literallayout-normal">
           int value = 30;

</pre>
</div>
<p class="b24-bookeditorial">That means that the value is set to 20 or 30. But which one? The result is compiler-dependent. If you want value to be local to the files in which they are declared, you need to declare them static:</p>
<p class="b24-bookeditorial">
<i class="calibre15">File: main.cpp</i>
</p>
<div class="calibre1">
<pre class="literallayout-normal">
            static int value = 20;
</pre>
</div>
<p class="b24-bookeditorial">
<i class="calibre15">File: check.cpp</i>
</p>
<div class="calibre1">
<pre class="literallayout-normal">
            static int value = 30;
</pre>
</div>
<p class="b24-bookeditorial">Or better yet, give them two different names.</p>
<p class="b24-bookeditorial">
<a name="556" class="calibre6" id="556"/><a name="ch13p58" class="calibre6" id="ch13p58"/><b class="calibre13">Answer 58:</b> According to the C++ standard, once you define a derived class member function with the same name as a base class's member function, all member functions of that name are hidden:</p>
<p class="b24-bookeditorial">So <span>der::print_it(float)</span> hides both <span>base: :print_it(float)</span> and <span>base: :print_it(int)</span>.</p>
<p class="b24-bookeditorial">When we call <span>print_it(2)</span> C++ looks for aversion of <span>print_it</span> it can use. The only visible <span>print_it</span> is <span>der::print_it(float)</span>. C++ would rather have a function that takes <b class="calibre13">int</b> as its argument, but it knows how to turn an <b class="calibre13">int</b> into a <b class="calibre13">float,</b> so it promotes 2 to 2.0 and uses <span>der::print_it(float)</span>.</p>
<p class="b24-bookeditorial">
<a name="557" class="calibre6" id="557"/><a name="ch13p59" class="calibre6" id="ch13p59"/><b class="calibre13">Answer 59:</b> The problem is that we didn't define a copy constructor. When that happens, C++ defines one for you and generally does a bad job of it.</p>
<p class="b24-bookeditorial">The copy constructor is defined as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       var_array(const var_array &amp;other) {
           data = other.data;
           size = other.size;
       }
</pre>
</div>
<p class="b24-bookeditorial">The copy constructor is called to create a copy of <span>an_array</span> for the function <span>store_it</span>. The pointer to the data is copied.</p>
<p class="b24-bookeditorial">When <span>var_array::<sup class="calibre20">~</sup>var_array</span> is called at the end of <span>pushy</span>, it returns the data to the heap.</p>
<p class="b24-bookeditorial">When <span>var_array::<sup class="calibre20">~</sup>var_array</span> is called at the end of <span>main</span>, it returns the same data to heap. Because we delete the same memory twice, the result is a corrupt heap.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 20:</b> Always declare a copy constructor in some way or other. The three major was are:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Implicitly declare it.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">If you never want anyone to be able to call it, declare it private:</p>
<div class="calibre1">
<pre class="literallayout-normal">
private:
    var_array (const var_array &amp;);
    // No one can copy var_arrays

</pre>
</div>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">If the default works, use the comment:</p>
<div class="calibre1">
<pre class="literallayout-normal">
// Copy Constructor defaults
</pre>
</div>
</li>
</ol>
<p class="b24-bookeditorial">in your program. That way you tell people reading your code that you thought about it and know that the C++ default will not be a problem.</p>
<p class="b24-bookeditorial">
<a name="558" class="calibre6" id="558"/><a name="ch13p60" class="calibre6" id="ch13p60"/><b class="calibre13">Answer 60:</b> The programmer has a very bad habit of not closing files after opening them. Pretty soon the maximum number of files are opened and the system won't let him open any more.</p>
<p class="b24-bookeditorial">Closes needed to be added at key points in the code:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      int fd = open(cur_ent-&gt;d_name, O_RDONLY);
      if (fd &lt; 0)
          continue;   // Can't get the file so try again

      int magic;       // The file's magic number
      int read_size = read(fd, &amp;magic, sizeof(magic));
      if (read_size != sizeof(magic)) {
          close(fd);   // &lt;---- added
          continue;
      }

      if (magic == MAGIC) {
          close(fd);     // &lt;---- added
          return (cur_ent-&gt;d_name);
}
      close(fd);         // &lt;---- added
</pre>
</div>
<p class="b24-bookeditorial">Also the programmer uses <span>opendir</span> to open a directory. He never closes it. So a <span>closedir</span> is needed.</p>
<div class="calibre1">
<pre class="literallayout-normal">
      void scan_dir(
          const char dir_name[]   // Directory name to use
      )
      {
          DIR *dir_info = opendir(dir_name);
          if (dir_info == NULL)
              return;
          chdir(dir_name);

          while (1) {
              char *name = next_file(dir_info);

              if (name == NULL)
                  break;
              std::cout &lt;&lt; "Found: " &lt;&lt; name &lt;&lt; '\n';
          }
         closedir(dir_info);      // &lt;---- added
      }
</pre>
</div>
<p class="b24-bookeditorial">
<a name="559" class="calibre6" id="559"/><a name="ch13p61" class="calibre6" id="ch13p61"/><b class="calibre13">Answer 61:</b> The problem is that the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      5 const char *volatile in_port_ptr =
      6 (char *)0xFFFFFFE0;
</pre>
</div>
<p class="b24-bookeditorial">tells C++ that the <i class="calibre15">pointer</i> is <span>volatile</span>. The data being pointed to is not <span>volatile</span>. The result is that the optimizer still optimizes us out of existence. The solution is to place the <span>volatile</span> where it modifies the data being pointed to. We also have added a <span>const</span> to the declaration to make sure that the pointer can't be modified. The resulting declarations are:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      4 // Input register
      5 volatile char *const in_port_ptr =
      6         (char *)0xFFFFFFE0;
      7
      8 // Output register
     10 volatile char *const out_port_ptr =
     11         (char *)0xFFFFFFE1;
</pre>
</div>
<p class="b24-bookeditorial">This tells C++:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="b24-bookeditorial">
<span>in_port_ptr</span> is a <span>const</span> pointer and cannot be modified.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">
<span>*in_port_ptr</span> is a <span>volatile char</span> whose value can be changed outside the normal C++ programming rules.</p>
</li>
</ul>
<p class="b24-bookeditorial">
<a name="560" class="calibre6" id="560"/><a name="ch13p62" class="calibre6" id="ch13p62"/><b class="calibre13">Answer 62:</b> The problem is that the comment:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        10    base = 5;    /* Set the base of the triangle
</pre>
</div>
<p class="b24-bookeditorial">does not contain a close comment. So it continues engulfing the statement below it:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        10    base = 5;    <span class="underline" style="text-decoration:underline">/* Set the base of the triangle</span>
        11    <span class="underline" style="text-decoration:underline">height = 2;  /* Initialize the height */</span>
</pre>
</div>
<p class="b24-bookeditorial">From this it's easy to see why height was not set.</p>
<p class="b24-bookeditorial">
<a name="561" class="calibre6" id="561"/><a name="ch13p63" class="calibre6" id="ch13p63"/><b class="calibre13">Answer 63:</b> The problem is that <span>getchar</span> returns an <span>int</span>. We are assigning it to a character. Some systems treat characters as unsigned characters. The result is that when we get <span>EOF</span> (-1) the system assigns</p>
<div class="calibre1">
<pre class="literallayout-normal">
        ch = (unsigned char)(-1)
</pre>
</div>
<p class="b24-bookeditorial">or <span>ch = 0xFF</span>. It then compares the <span>0xFF</span> to -1 (they are not the same) and does not exit the loop.</p>
<p class="b24-bookeditorial">This program is also a stylistic disaster. The goal of every C++ programmer should be writing a clear program. This program was written to be compact. A much better program is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
  1 /************************************************
  2  * copy -- Copy stdin to stdout.                *
  3  ************************************************/
  4 #include &lt;stdio.h&gt;
  5
  6 int main()
  7 {
  8
  9     while (1) {
 10     {
 11         int ch; // Character to copy
 12
 13         ch = getchar();
 14
 15         if (ch == EOF)
 16             break;
 17
 18         putchar(ch);
 19     }
 20     return (0);
 21 }
</pre>
</div>
<p class="b24-bookeditorial">
<a name="562" class="calibre6" id="562"/><a name="ch13p64" class="calibre6" id="ch13p64"/><b class="calibre13">Answer 64:</b> The output is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      Name (a): /var/tmp/tmp.2
      Name (b): /var/tmp/tmp.2
</pre>
</div>
<p class="b24-bookeditorial">The reason for this is that although we have two pointers, they both point to one variable <span>name</span>. When <span>tmp_name</span> is called the first time:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        a_name --&gt; name = "/var/tmp/tmp.1"
</pre>
</div>
<p class="b24-bookeditorial">After the second call:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        b_name --&gt; name = "/var/tmp/tmp.2"
</pre>
</div>
<p class="b24-bookeditorial">But <span>a_name</span> also points to name so:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        a_name --&gt; name = "/var/tmp/tmp.2"
        b_name --&gt; name = "/var/tmp/tmp.2"
</pre>
</div>
<p class="b24-bookeditorial">The second call overwrote storage that was being used to hold the result of the first call.</p>
<p class="b24-bookeditorial">One solution to this is to copy the string after each call or to have the caller provide his own character array for name storage.</p>
<p class="b24-bookeditorial">Another solution is to use C++ style strings that handle their own memory allocation.</p>
<p class="b24-bookeditorial">
<a name="563" class="calibre6" id="563"/><a name="ch13p65" class="calibre6" id="ch13p65"/><b class="calibre13">Answer 65:</b> Every <span>put</span> is followed by a <span>flush</span>. This means that a system call is made for each character output. System calls are expensive and take up a lot of CPU time.</p>
<p class="b24-bookeditorial">In other words, although the I/O library is designed for buffered I/O, the excessive <span>flush</span> calls for it to do unbuffered I/O one character at a time.</p>
<p class="b24-bookeditorial">We need to flush at the end of each block to make sure that the remote system receives a full block. That's <i class="calibre15">block,</i> not <i class="calibre15">character,</i> so we can speed up the system by moving the <span>flush</span> down to after the block is sent:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       for (i = 0; i &lt; BLOCK_SIZE; ++i) {
            int ch;

            ch = in_file.get();
            serial_out.put(ch);
       }
       serial_out.fflush();
</pre>
</div>
<p class="b24-bookeditorial">
<a name="564" class="calibre6" id="564"/><a name="ch13p66" class="calibre6" id="ch13p66"/><b class="calibre13">Answer 66:</b> The <span>setjmp</span> marks a location in the code. The <span>longjmp</span> call jumps to it. It jumps directly to it, it does not pass go, it does not collect $200. It also skips all the destructors for all the variables on the stack. In this case, because the destructor for <span>std::string</span> returns the memory allocated for the string, we have a memory leak.</p>
<p class="b24-bookeditorial">That's because the <span>setjmp</span> and <span>longjmp</span> functions are C functions that should not be used in C++.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 21:</b> Do not use <span>setjmp</span> and <span>longjmp</span> in a C++ program. Use exceptions instead.</p>
<p class="b24-bookeditorial">
<a name="565" class="calibre6" id="565"/><a name="ch13p67" class="calibre6" id="ch13p67"/><b class="calibre13">Answer 67:</b> In the default case:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       defualt:
           std::cout &lt;&lt; i &lt;&lt; " is not prime\n";
           break;
</pre>
</div>
<p class="b24-bookeditorial">The "default" keyword is misspelled. The result is that the C++ compiler thinks that "defualt" is a <span>goto</span> label.</p>
<p class="b24-bookeditorial">
<a name="566" class="calibre6" id="566"/><a name="ch13p68" class="calibre6" id="ch13p68"/><b class="calibre13">Answer 68:</b> The <span>printf</span> function buffers its output. It won't actually write anything until the buffer gets full or a newline is sent.</p>
<p class="b24-bookeditorial">So the program hits the <span>printf</span>, the "Starting" message goes into the buffer and not to the screen, and the function average is executed and gets a divide by zero error.</p>
<p class="b24-bookeditorial">The result is that the "Starting" message is lost, making us think that average was never called.</p>
<p class="b24-bookeditorial">The solution to this problem is to flush the buffer explicitly after the starting message:</p>
<div class="calibre1">
<pre class="literallayout-normal">
           printf("Starting....");
           fflush(stdout);

</pre>
</div>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Warning </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">The rules for when a buffer gets flushed change depending on the type of file being written. The rules are:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">
<i class="calibre15">If </i><i class="calibre15"><span>stdout</span></i> <i class="calibre15">or </i><i class="calibre15"><span>stderr</span></i> <i class="calibre15">are being written to the screen then the output is buffered until:</i>
</p>
<ol class="orderedlist1" type="a">
<li class="first-listitem">
<p class="b24-bookeditorial">
<i class="calibre15">When a line is written.</i>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">
<i class="calibre15">When </i><i class="calibre15"><span>stdin</span></i> <i class="calibre15">is read.</i>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">
<i class="calibre15">When the buffer gets full.</i>
</p>
</li>
</ol>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">
<i class="calibre15">If </i><i class="calibre15"><span>stdout</span></i> <i class="calibre15">or </i><i class="calibre15"><span>stderr</span></i> <i class="calibre15">are being written to a disk then the output is buffered until:</i>
</p>
<ol class="orderedlist1" type="a">
<li class="first-listitem">
<p class="b24-bookeditorial">
<i class="calibre15">When the buffer gets full.</i>
</p>
</li>
</ol>
</li>
</ol>
</td>
</tr>
</table>
<p class="b24-bookeditorial">(These are the rules you'll probably find on your system. The actual rules are system-dependent.)</p>
<p class="b24-bookeditorial">
<a name="567" class="calibre6" id="567"/><a name="ch13p69" class="calibre6" id="ch13p69"/><b class="calibre13">Answer 69:</b> The problem is the programmer wrote:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         std::cout &lt;&lt; "Hello World!/n";
</pre>
</div>
<p class="b24-bookeditorial">instead of:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         std::cout &lt;&lt; "Hello World!\n";
</pre>
</div>
<p class="b24-bookeditorial">so the output is literally:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         Hello World/n
</pre>
</div>
<p class="b24-bookeditorial">
<a name="568" class="calibre6" id="568"/><a name="ch13p70" class="calibre6" id="ch13p70"/><b class="calibre13">Answer 70:</b> The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        54     while (
        55         (std::strcmp(cur_cmd-&gt;cmd, cmd) != 0) &amp;&amp;
        56         cur_cmd != NULL)
</pre>
</div>
<p class="b24-bookeditorial">The statement checks the data pointed to by <span>cur_cmd-&gt;cmd</span>, then checks to see if <span>cur_cmd-&gt;cmd</span> is valid. On some systems, dereferencing NULL (which we do if we are at the end of the list) causes core dumps.</p>
<p class="b24-bookeditorial">On MS-DOS and other brain-damaged systems, there is no memory protection, so dererferencing NULL is allowed, although you get strange results. Microsoft Windows fixed this, and dereferencing a NULL pointer will result in a General Protection Fault (GPF).</p>
<p class="b24-bookeditorial">The loop should be written:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      while (
          (cur_cmd != NULL) &amp;&amp;
          (std::strcmp(cur_cmd-&gt;cmd, cmd) != 0))

</pre>
</div>
<p class="b24-bookeditorial">But even this is tricky. The statement depends on the C++ standard being correctly implemented. That C++ standard states that for <span>&amp;&amp;</span> the first part is evaluated. If the first term is false, the second term is skipped. Just to be safe, it's better to write this as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          while (1) {
              if (cur_cmd == NULL)
                   break;
              if (std::strcmp(cur_cmd-&gt;cmd, cmd) == 0)
                   break;
</pre>
</div>
<p class="b24-bookeditorial">
<a name="569" class="calibre6" id="569"/><a name="ch13p71" class="calibre6" id="ch13p71"/><b class="calibre13">Answer 71:</b>
</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">
<b class="calibre13">Alignment</b>
</p>
</li>
</ol>
<p class="b24-bookeditorial">Some machines require that long integer values line up on a 2-byte or 4-byte boundary. Some do not. C++ will insert padding in the structure to make things line up.</p>
<p class="b24-bookeditorial">So on one machine, the structure will be:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       struct data {
           char flag;       // 1 byte
           long int value;  // 4 bytes
       };
</pre>
</div>
<p class="b24-bookeditorial">for a total of 5 bytes. While on another it may be:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       struct data {
           char flag;       // 1 byte
           char pad[3];     // 3 bytes (automatic padding)
           long int value;  // 4 bytes
       };
</pre>
</div>
<p class="b24-bookeditorial">for a total of 8 bytes.</p>
<ol class="orderedlist" start="2">
<li class="first-listitem">
<p class="b24-bookeditorial">
<b class="calibre13">Byte order</b>
</p>
</li>
</ol>
<p class="b24-bookeditorial">Some machines write out long integers using the byte order ABCD. Others use DCBA. This prevents things from being portable.</p>
<ol class="orderedlist" start="3">
<li class="first-listitem">
<p class="b24-bookeditorial">
<b class="calibre13">Integer size</b>
</p>
</li>
</ol>
<p class="b24-bookeditorial">The 64-bit machines are coming. That means that on some systems a <span>long int</span> is 64 bits, not 32.</p>
<p class="b24-bookeditorial">
<a name="570" class="calibre6" id="570"/><a name="ch13p72" class="calibre6" id="ch13p72"/><b class="calibre13">Answer 72:</b> We have an array of a derived class called <span>safe stack.</span> In C++, you can use a base class pointer <span>(stack*)</span> to point to a derived class <span>(safe_stack).</span> The system will see only the base part of the object, but you can still point to it.</p>
<div class="calibre1">
<span><a href="fig257_01_0.jpg" name="IMG_5" target="_parent" class="calibre2" id="IMG_5"><img src="fig257_01.jpg" alt="Click To expand" border="0" class="calibre31"/></a></span>
</div>
<p class="b24-bookeditorial">Now a pointer can point to a single instance of a class or an array of objects.</p>
<div class="calibre1">
<span><a href="fig257_02_0.jpg" name="IMG_6" target="_parent" class="calibre2" id="IMG_6"><img src="fig257_02.jpg" alt="Click To expand" border="0" class="calibre32"/></a></span>
</div>
<p class="b24-bookeditorial">So we have the following two rules:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">A base pointer can point to a derived object.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">An object pointer can point to an array of objects.</p>
</li>
</ol>
<p class="b24-bookeditorial">From this, we can conclude:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">A base pointer can point to an array of derived objects.</p>
</li>
</ol>
<p class="b24-bookeditorial">That's wrong.</p>
<p class="b24-bookeditorial">The problem is that an array of derived objects is not the same as an array of base objects.</p>
<div class="calibre1">
<span><a href="fig257_03_0.jpg" name="IMG_7" target="_parent" class="calibre2" id="IMG_7"><img src="fig257_03.jpg" alt="Click To expand" border="0" class="calibre33"/></a></span>
</div>
<p class="b24-bookeditorial">So if we take a base pointer and point it a derived array, the memory layout will be wrong.</p>
<div class="calibre1">
<span><a href="fig258_01_0.jpg" name="IMG_8" target="_parent" class="calibre2" id="IMG_8"><img src="fig258_01.jpg" alt="Click To expand" border="0" class="calibre34"/></a></span>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 22:</b> Use the STL <span>vector</span> template instead of an array. It avoids a lot of problems.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 23:</b> Do not pass base-class arrays as parameters.</p>
<p class="b24-bookeditorial">
<a name="571" class="calibre6" id="571"/><a name="ch13p73" class="calibre6" id="ch13p73"/><b class="calibre13">Answer 73:</b> The problem is how the compiler generates machine code for program.</p>
<p class="b24-bookeditorial">The statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
      if (number1 + number2 == number1)
</pre>
</div>
<p class="b24-bookeditorial">generates something like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
     movefp_0, number1
     add fp_0, number2
     movefp_1, number1
     fcmpfp_0, fp_1
     jump_zero out_of_the_while
</pre>
</div>
<p class="b24-bookeditorial">In this example <span>fp_0</span> and <span>fp_1</span> are floating-point registers. In floating-point coprocessors, the registers have the largest precision available. So in this case, while the numbers may be only 32-bit, the floating-point processor does things in 80 bits, resulting in a high precision being reported.</p>
<p class="b24-bookeditorial">This sort of problem occurs on most machines with a floating-point processor. On the other hand, if you have an old machine that uses software to do the floating-point, you'll probably get the right answer. That's because, in general, software floating-point uses only enough bits to do the work.</p>
<p class="b24-bookeditorial">To fix the program, we need to turn the main loop into:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       while (1)
       {
       // Volatile keeps the optimizer from
       // putting the result in a register
       volatile float result;

       result = number1 + number2;
       if (result == number1)
           break;
</pre>
</div>
<p class="b24-bookeditorial">
<a name="572" class="calibre6" id="572"/><a name="ch13p74" class="calibre6" id="ch13p74"/><b class="calibre13">Answer 74:</b> The problem is that the words are stored in the input file in alphabetical order and the tree is unbalanced. Thus, when words are inserted the following data structure is built up:</p>
<div class="calibre1">
<span><a href="fig259_01_0.jpg" name="IMG_9" target="_parent" class="calibre2" id="IMG_9"><img src="fig259_01.jpg" alt="Click To expand" border="0" class="calibre35"/></a></span>
</div>
<p class="b24-bookeditorial">The result is that we have a linked list, not a tree. Words are added to the end of the linked list (expensive), and lookups are done by linear search (also expensive).</p>
<p class="b24-bookeditorial">A balanced binary tree would solve this problem.</p>
<p class="b24-bookeditorial">
<a name="573" class="calibre6" id="573"/><a name="ch13p75" class="calibre6" id="ch13p75"/><b class="calibre13">Answer 75:</b> The problem is that we have in our code the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        an_array = an_array;
</pre>
</div>
<p class="b24-bookeditorial">This is disguised as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        82    to_array = from_array;
</pre>
</div>
<p class="b24-bookeditorial">The <span>operator =</span> function deletes the data of the destination array. That's fine except that the source array is the same stack, so its data gets destroyed, too.</p>
<p class="b24-bookeditorial">The answer is to check explicitly for self-assignment in the <span>operator =</span> function:</p>
<div class="calibre1">
<pre class="literallayout-normal">
           array &amp; operator = (const arrary &amp;old_array) {
       if (this == &amp;old_array)
                   return;
</pre>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 24:</b> The <span>operator =</span> function should check for self-assignment.</p>
<p class="b24-bookeditorial">
<a name="574" class="calibre6" id="574"/><a name="ch13p76" class="calibre6" id="ch13p76"/><b class="calibre13">Answer 76:</b> The problem is that <span>strcmp</span> returns 0 if the strings are equal and non-zero otherwise. That means that if you have the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          if (strcmp(x,y))
</pre>
</div>
<p class="b24-bookeditorial">The <span>if</span> will execute only if the strings are <i class="calibre15">not</i> equal.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 25:</b> Use</p>
<div class="calibre1">
<pre class="literallayout-normal">
          if (strmp(x,y) != 0)
</pre>
</div>
<p class="b24-bookeditorial">to test if two strings are equal. It's clearer than <span>if (strcmp(x,y)</span>, and it works.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 26:</b> Whenever possible, use the C++ <span>string</span> class instead of the old C style strings. That way you can use the relational operators (&lt;,&gt;, ==, etc.) instead of <span>strcmp</span>.</p>
<p class="b24-bookeditorial">
<a name="575" class="calibre6" id="575"/><a name="ch13p77" class="calibre6" id="ch13p77"/><b class="calibre13">Answer 77:</b> The problem is the code:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       while (first != NULL) {
           delete first;
           first = first-&gt;next;
       }
</pre>
</div>
<p class="b24-bookeditorial">It deletes data, then uses it. After things are deleted, they really should go away.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 27:</b> Always set a pointer to NULL after <span>delete</span> or <span>free</span>.</p>
<p class="b24-bookeditorial">When the code is written with a little bit of added protection, the problem is obvious:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        delete first
        first = NULL;
        first = first-&gt;next;
</pre>
</div>
<p class="b24-bookeditorial">Also, because of the added protection of setting <span>first</span> to <span>NULL</span>, if we do attempt to use the pointer, we will abort in a well-defined manner (on most systems).</p>
<p class="b24-bookeditorial">
<a name="576" class="calibre6" id="576"/><a name="ch13p78" class="calibre6" id="ch13p78"/><b class="calibre13">Answer 78:</b> The types of the variables are:</p>
<ul class="simple-list">
<li class="first-listitem">
<p class="b24-bookeditorial">
<span>sam</span> is a character pointer (<span>char *</span>).</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">
<span>joe</span> is a character (<span>char</span>).</p>
</li>
</ul>
<p class="b24-bookeditorial">The declaration, after the preprocessor gets through with it results in:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       char * sam, joe;

</pre>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 28:</b> Use <span>typedef</span> to define new types, not <span>#define</span>.</p>
<p class="b24-bookeditorial">
<a name="577" class="calibre6" id="577"/><a name="ch13p79" class="calibre6" id="ch13p79"/><b class="calibre13">Answer 79:</b> C++ has no ** operator. (At least for integers.) So (12 ** 2) is an invalid construct.</p>
<p class="b24-bookeditorial">The trouble is that this bad syntax is hidden in a preprocessor macro that's not expanded until line 16. That's why line 16 is the one with the syntax error.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 29:</b> Use <span>const</span> instead of preprocessor macros whenever possible. The statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       const int GROSS = (12 ** 2);
</pre>
</div>
<p class="b24-bookeditorial">would still generate an error message, but at least the line number would be right.</p>
<p class="b24-bookeditorial">
<a name="578" class="calibre6" id="578"/><a name="ch13p80" class="calibre6" id="ch13p80"/><b class="calibre13">Answer 80:</b> The problem is that the result of a comparison is an integer 1 or 0. So the expression:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if (a &gt; b &gt; c)
</pre>
</div>
<p class="b24-bookeditorial">becomes</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if ((a &gt; b) &gt; c)
</pre>
</div>
<p class="b24-bookeditorial">Because <span>a</span> is greater than <span>b</span>, the result of <span>a &gt; b</span> is 1, so we now have</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if (1 &gt; c)
</pre>
</div>
<p class="b24-bookeditorial">which is false, so the else clause is executed.</p>
<p class="b24-bookeditorial">
<a name="579" class="calibre6" id="579"/><a name="ch13p81" class="calibre6" id="ch13p81"/><b class="calibre13">Answer 81:</b> The programmer suspects that something funny is happening when data item #500 is read. He wants to put a breakpoint right before this item is read.</p>
<p class="b24-bookeditorial">The trouble is that if he puts a breakpoint at the top of <span>get_data</span>, he will have to do 500 debugger continue commands before he reaches the point he wants.</p>
<p class="b24-bookeditorial">So he puts his breakpoint at the line:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       seq = seq;

</pre>
</div>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">The fancier debuggers allow the user to set a skip count to skip the first <i class="calibre15">x</i> number of breakpoint stops. Our friendly programmer doesn't have such a nice tool.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="580" class="calibre6" id="580"/><a name="ch13p82" class="calibre6" id="ch13p82"/><b class="calibre13">Answer 82:</b> The programmer used semicolons to end the <span>#define</span> declaration. Because the preprocessor is rather literal about things, the semicolon becomes part of the text. The result is that <span>USABLE</span> is defined as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         8.5; -1.0;;
</pre>
</div>
<p class="b24-bookeditorial">The initialization of <span>text_width</span> now becomes</p>
<div class="calibre1">
<pre class="literallayout-normal">
         double text_width = 8.5; -1.0;;
</pre>
</div>
<p class="b24-bookeditorial">or, properly indented,</p>
<div class="calibre1">
<pre class="literallayout-normal">
       double text_width = 8.5;
       -1.0;
        ;
</pre>
</div>
<p class="b24-bookeditorial">From this we can see our problem.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 30:</b> Use <span>const</span> instead of <span>#define</span> whenever possible.</p>
<p class="b24-bookeditorial">
<a name="581" class="calibre6" id="581"/><a name="ch13p83" class="calibre6" id="ch13p83"/><b class="calibre13">Answer 83:</b> The problem is the <span>buffer</span> is a local variable. That means that it goes away at the end of the function call. Unfortunately, <span>printf</span> doesn't know this, so it will still stuff data into it afterwards.</p>
<p class="b24-bookeditorial">The</p>
<div class="calibre1">
<pre class="literallayout-normal">
        printf("That's all\n");
</pre>
</div>
<p class="b24-bookeditorial">will still try to use the local variable.</p>
<p class="b24-bookeditorial">To fix this problem declare the buffer as <span>static</span>:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        static char buffer[BUFSIZ];
</pre>
</div>
<p class="b24-bookeditorial">
<a name="582" class="calibre6" id="582"/><a name="ch13p84" class="calibre6" id="ch13p84"/><b class="calibre13">Answer 84:</b> The problem is the optimizer. The optimizer knows that the variable <span>debugging</span> is zero. It's always zero.</p>
<p class="b24-bookeditorial">Now that we know that, let's take a look at the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       if (debugging)
</pre>
</div>
<p class="b24-bookeditorial">This is always false, because <span>debugging</span> is always zero. So this block is never executed. That means that we can optimize the code:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       13   if (debugging)
       14   {
       15       dump_variables();
       16   }
</pre>
</div>
<p class="b24-bookeditorial">into the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       // Nothing
</pre>
</div>
<p class="b24-bookeditorial">Now let's look at the number of times <span>debugging</span> is used. It's initialized on line 11 and used on line 13. Line 13 is optimized out, so <span>debugging</span> is never used. If a variable is never used, it can be optimized out.</p>
<p class="b24-bookeditorial">The result is an optimized program that looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       9 void do_work()
      10 {
      11     // Declaration optimized out
      12
      13     // Block optimized out
      14     //
      15     //
      16     // End of block that was removed
      17     // Do real work
      18 }

</pre>
</div>
<p class="b24-bookeditorial">Now our programmer wanted to use the <span>debugging</span> variable to help him debug things. The trouble is there is no <span>debugging</span> variable after optimization.</p>
<p class="b24-bookeditorial">The problem is that C++ didn't know that the programmer was going to use magic (a debugger) to change variables behind its back. If you plan on doing something like this, you must tell the compiler. This is done by declaring the <span>debugging</span> variable <span>volatile</span>.</p>
<div class="calibre1">
<pre class="literallayout-normal">
     static volatile int debugging = 0;
</pre>
</div>
<p class="b24-bookeditorial">The "volatile" keyword tells C++, "Something strange such as an interrupt routine, a debugger command, or something else may change this variable behind your back. You can make no assumptions about its value."</p>
<p class="b24-bookeditorial">
<a name="583" class="calibre6" id="583"/><a name="ch13p85" class="calibre6" id="ch13p85"/><b class="calibre13">Answer 85:</b> The <span>printf</span> statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       11    printf("The answer is %d\n");
</pre>
</div>
<p class="b24-bookeditorial">tells C to print an integer, but fails to supply one. The <span>printf</span> function doesn't know this, so it will take the next number off the stack (some random number) and print it.</p>
<p class="b24-bookeditorial">What the programmer should have written is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       printf("The answer is %d\n", answer);
</pre>
</div>
<p class="b24-bookeditorial">
<a name="584" class="calibre6" id="584"/><a name="ch13p86" class="calibre6" id="ch13p86"/><b class="calibre13">Answer 86:</b> The problem is the use of <span>matrix[1,2]</span>. The comma operator in C++ merely returns the result of the second part. So the expression "1,2" tells C++ throw the first part (1) away and the value is 2. So <span>matrix[1,2]</span> is really <span>matrix[2]</span>. This is a pointer into an integer array, and C++ will treat it as a pointer for printing. That's why strange values get printed.</p>
<p class="b24-bookeditorial">What the programmer really wanted is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        matrix[1][2]
</pre>
</div>
<p class="b24-bookeditorial">
<a name="585" class="calibre6" id="585"/><a name="ch13p87" class="calibre6" id="ch13p87"/><b class="calibre13">Answer 87:</b> The prefix version of <span>++</span> returns the number after incrementing.</p>
<p class="b24-bookeditorial">Thus</p>
<div class="calibre1">
<pre class="literallayout-normal">
     ++++i;
</pre>
</div>
<p class="b24-bookeditorial">tells C++ increment <span>i</span>, returns the result, then increments the variable <span>i</span> again.</p>
<p class="b24-bookeditorial">The postfix version of <span>++ (i++)</span> returns a copy of the variable, then increments it.</p>
<p class="b24-bookeditorial">So</p>
<div class="calibre1">
<pre class="literallayout-normal">
       ++++i
</pre>
</div>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Tells C++ to make a copy of <span>i</span> (call it <span>tmp_1</span>)</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Increments <span>i</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Does the rest of the work on <span>tmp_1</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Makes a copy of <span>tmp_1</span> (call it <span>tmp_2</span>)</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Increments <span>tmp_2</span>
</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Returns <span>tmp_1</span> as the value of the expression</p>
</li>
</ol>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">C++ won't let you get away with <span>++++</span> on integers. Only with some added class silliness can you get away with it.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 31:</b> Use <span>++</span> and <span>--</span> singly.</p>
<p class="b24-bookeditorial">
<a name="586" class="calibre6" id="586"/><a name="ch13p88" class="calibre6" id="ch13p88"/><b class="calibre13">Answer 88:</b> The problem is the macro:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         #define SQR(x) ((x) * (x))
</pre>
</div>
<p class="b24-bookeditorial">when called with</p>
<div class="calibre1">
<pre class="literallayout-normal">
            SQR(++number)
</pre>
</div>
<p class="b24-bookeditorial">This expands to</p>
<div class="calibre1">
<pre class="literallayout-normal">
            ((++number) * (++number))
</pre>
</div>
<p class="b24-bookeditorial">This increments <span>number</span> twice, instead of once as the programmer intended. What's worse, the compiler can make some decisions as to the order in which the various operations are done; therefore, the result of this expression is compiler-dependent.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 32:</b> Use <b class="calibre13">inline</b> functions instead of parameterized macros.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 33:</b> Put ++ and - on lines by themselves.</p>
<p class="b24-bookeditorial">
<a name="587" class="calibre6" id="587"/><a name="ch13p89" class="calibre6" id="ch13p89"/><b class="calibre13">Answer 89:</b> The optimizer knows that although the subroutine computes the value of <span>result</span>, it does nothing with it. So the program will work the same whether or not <span>result</span> is computed. Thus, the optimizer takes a look at the loop:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          20    for (i = 0; i &lt; 1863; ++i)
          21    {
          22        result = factor1 * factor2;
          23    }
</pre>
</div>
<p class="b24-bookeditorial">is optimized down:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          20    for (i = 0; i &lt; 1863; ++i)
          21    {
          22        /* Do nothing */;
          23    }
</pre>
</div>
<p class="b24-bookeditorial">Of course we don't need to do nothing 1,863 times, so this is optimized down to:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          20    /* No loop needed */
          21    {
          22        /* Do nothing */;
          23    }
</pre>
</div>
<p class="b24-bookeditorial">This is about as optimized as you can get. The way to keep the optimizer from doing this to us is to declare the variable <span>result</span> is <span>volatile</span>. Program 110 shows what happens when you add this fix.</p>
<p class="b24-bookeditorial">
<a name="588" class="calibre6" id="588"/><a name="ch13p90" class="calibre6" id="ch13p90"/><b class="calibre13">Answer 90:</b> C++ uses zero-based indexing. So for <span>array [5]</span> the valid elements are:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       array[0], array[1], array[2], array[3], array[4]
</pre>
</div>
<p class="b24-bookeditorial">The programmer, however, uses the elements 1-5. There is no <span>array [5]</span>, so the program modifies random memory, causing the memory corruption.</p>
<p class="b24-bookeditorial">That's why most C++ programs don't use statements like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         for (i = 1; i &lt;= 5; ++i) {
</pre>
</div>
<p class="b24-bookeditorial">Instead they count using:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         for (i = 0; i &lt; 5; ++i) {
</pre>
</div>
<p class="b24-bookeditorial">
<a name="589" class="calibre6" id="589"/><a name="ch13p91" class="calibre6" id="ch13p91"/><b class="calibre13">Answer 91:</b> The problem is that with the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         result=result/*divisor; /* Do divide */;
</pre>
</div>
<p class="b24-bookeditorial">the first <span>/*</span> (the one in the middle of the statement) starts a comment; it does not do a divide. So this statement is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         result = result /* a very big comment */;
</pre>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 34:</b> Put spaces around operators. It not only avoids problems but also makes the program easier to read.</p>
<div class="calibre1">
<pre class="literallayout-normal">
         result=result / *divisor; /* Do divide */;
</pre>
</div>
<p class="b24-bookeditorial">
<a name="590" class="calibre6" id="590"/><a name="ch13p92" class="calibre6" id="ch13p92"/><b class="calibre13">Answer 92:</b> The problem is that a thread switch can occur at any time.</p>
<p class="b24-bookeditorial">The writer will remove a character from the buffer when count &gt; 0. The reader performs the two steps:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       ++count;  // We've got a new character
       *in_ptr = ch;// Store the character
</pre>
</div>
<p class="b24-bookeditorial">But a thread switch can occur between these two steps.</p>
<p class="b24-bookeditorial">Therefore, the following can happen:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       reader:++count;// We've got a new character

       thread switch to writer

       writer: check count &gt; 0 -- it is

       writer: Get the character

       thread switch to reader

       reader: Put the character in the buffer AFTER writer has already read it.
</pre>
</div>
<p class="b24-bookeditorial">A solution is to change the sequence of the steps</p>
<div class="calibre1">
<pre class="literallayout-normal">
       ++count; // We've got a new character
       *in_ptr = ch;// Store the character
</pre>
</div>
<p class="b24-bookeditorial">to</p>
<div class="calibre1">
<pre class="literallayout-normal">
       *in_ptr = ch;// Store the character
       ++count; // We've got a new character
</pre>
</div>
<p class="b24-bookeditorial">Depending on the sequence of instructions to protect shared data is difficult and tricky.</p>
<p class="b24-bookeditorial">It is much better and simpler is to tell the task manager when you are doing a set of statements that can't be interrupted. In <span>pthreads</span>, this is done with a mutex lock:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       pthread_mutex_lock(&amp;buffer_mutex);

       ++count;
       *in_ptr = ch;
       ++in_ptr;

       pthread_mutex_unlock(&amp;buffer_mutex);
</pre>
</div>
<p class="b24-bookeditorial">
<a name="591" class="calibre6" id="591"/><a name="ch13p93" class="calibre6" id="ch13p93"/><b class="calibre13">Answer 93:</b> Member variables are initialized in <i class="calibre15">declaration</i> order.</p>
<p class="b24-bookeditorial">In this case, the statements:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       ) : width(i_width),
           height(i_height),
           area(width*height)
</pre>
</div>
<p class="b24-bookeditorial">are executed in declaration order: 1) <span>area</span>, 2) <span>width</span>, 3) <span>height</span>. This means that <span>area</span> is initialized with undefined values of <span>width</span> and <span>height</span>, and then <span>width</span> and <span>height</span> are initialized.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 35:</b> Write constructors so that variables are initialized in the order in which they are declared. (If you don't do this, the compiler will do it for you and cause confusion.)</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 36:</b> Never use member variables to initialize other member variables.</p>
<p class="b24-bookeditorial">
<a name="592" class="calibre6" id="592"/><a name="ch13p94" class="calibre6" id="ch13p94"/><b class="calibre13">Answer 94:</b> In K&amp;R style functions, the parameter declarations come immediately <i class="calibre15">before</i> the first curly brace.</p>
<p class="b24-bookeditorial">That means that the declaration:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       int sum(i1, i2, i3)
       {
</pre>
</div>
<p class="b24-bookeditorial">declares three parameters of default (<span>int</span>) type. Anything after that is declared as a local variable.</p>
<p class="b24-bookeditorial">In particular</p>
<div class="calibre1">
<pre class="literallayout-normal">
       int sum(i1, i2, i3)
       {
           int i1;   /* Local variable, not parameter */
           int i2;   /* Local variable, not parameter */
           int i3;   /* Local variable, not parameter */
</pre>
</div>
<p class="b24-bookeditorial">The result is instead of summing three parameters, the program adds three uninitialized local variables. No wonder we get a strange result.</p>
<p class="b24-bookeditorial">
<a name="593" class="calibre6" id="593"/><a name="ch13p95" class="calibre6" id="ch13p95"/><b class="calibre13">Answer 95:</b> The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
     2<span class="underline" style="text-decoration:underline">4</span>    sscanf(line, "%c %d", oper, value);
</pre>
</div>
<p class="b24-bookeditorial">The <span>sscanf</span> function takes pointers as its arguments. (Remember C doesn't check arguments for the correct type.) In this case, we gave <span>sscanf</span> a character and an integer. We should have given it a pointer to a character and a pointer to an integer:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       24     sscanf(line, "%c %d", &amp;oper, &amp;value);
</pre>
</div>
<p class="b24-bookeditorial">
<a name="594" class="calibre6" id="594"/><a name="ch13p96" class="calibre6" id="ch13p96"/><b class="calibre13">Answer 96:</b> The program use raw I/O to do its work (using the <span>read</span> and <span>write</span> system calls). This program does one raw read and raw write for each character. Operating calls are expensive, and this program uses 2 (one <span>read</span> and one <span>write</span>) per byte copied.</p>
<p class="b24-bookeditorial">To speed up the program, cut down on the operating system calls. This can be done two ways:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Use the buffered I/O system by making the input and output <span>fstreams</span> instead of file descriptors.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Read and write more than one character at a time.</p>
</li>
</ol>
<p class="b24-bookeditorial">
<a name="595" class="calibre6" id="595"/><a name="ch13p97" class="calibre6" id="ch13p97"/><b class="calibre13">Answer 97:</b> The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       for (index = 0; string[index] != '\0'; ++index)
           /* do nothing */
       return (index);
</pre>
</div>
<p class="b24-bookeditorial">There is no semicolon after the <span>/* do nothing */</span> statement.</p>
<p class="b24-bookeditorial">The return is part of the <span>for</span> statement. The code should look like this after it is indented properly:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       for (index = 0; string[index] != '\0'; ++index)
           /* do nothing */
           return (index);
</pre>
</div>
<p class="b24-bookeditorial">From this code section we can see that the first time through, the <span>for</span> loop index will be zero and the return taken. That's why all the strings are of zero length.</p>
<p class="b24-bookeditorial">What the programmer wanted was:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       for (index = 0; string[index] != '\0'; ++index)
           /* do nothing */;
       return (index);

</pre>
</div>
<p class="b24-bookeditorial">
<a name="596" class="calibre6" id="596"/><a name="ch13p98" class="calibre6" id="ch13p98"/><b class="calibre13">Answer 98:</b> The problem is that class is allocated not by the C++ <span>new</span> operator, but instead uses the old style C <span>malloc</span> operator. This creates the space for the class without calling the constructor.</p>
<p class="b24-bookeditorial">Then just to add insult to injury, <span>memset</span> is called to zero the class.</p>
<div class="calibre1">
<pre class="literallayout-normal">
       result =
           (struct info *)malloc(sizeof(struct info));
       memset(result, '\0', sizeof(result));
</pre>
</div>
<p class="b24-bookeditorial">What the programmer should have written is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       result = new info;

</pre>
</div>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">The author first found this problem in a large library he was trying to debug. Because of the large size of the library and the complexity of the mess, it took him a week to find the location of the <i class="calibre15"><span>malloc</span></i>.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="597" class="calibre6" id="597"/><a name="ch13p99" class="calibre6" id="ch13p99"/><b class="calibre13">Answer 99:</b> The statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          out_file &lt;&lt; ch;
</pre>
</div>
<p class="b24-bookeditorial">does not send a character to the output. Regardless of its name, the <span>ch</span> variable is of type integer. The result is that the integer is printed to the output. That's why the output file is full of integers.</p>
<p class="b24-bookeditorial">This is the one case in which C++'s automatic type detection of output parameters gets in your way. The old C <span>printf</span> statement would handle things correctly like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
          printf("%c", ch);
</pre>
</div>
<p class="b24-bookeditorial">But with C++ you must cast to get the correct results in this case:</p>
<div class="calibre1">
<pre class="literallayout-normal">
         out_file &lt;&lt; static_cast&lt;char&gt;(ch);
</pre>
</div>
<p class="b24-bookeditorial">
<a name="598" class="calibre6" id="598"/><a name="ch13p100" class="calibre6" id="ch13p100"/><b class="calibre13">Answer 100:</b> The program outputs:</p>
<div class="calibre1">
<pre class="literallayout-normal">
     First: second Second: second
</pre>
</div>
<p class="b24-bookeditorial">The problem is that the <span>readdir</span> returns a pointer to static data. This data is owned by <span>readdir</span> and overwritten by subsequent calls.</p>
<p class="b24-bookeditorial">So what happens is this: We call <span>scan_dir</span> and set <span>first_ptr</span> to point to the string <span>first</span>. That's what we want, but the array containing the name is static and when we call <span>readdir</span> again, it uses the same buffer to store the name <span>second</span>. So now <span>first_ptr</span> points to <span>second</span>, which is the cause of our trouble.</p>
<div class="calibre1">
<span><a href="fig269_01_0.jpg" name="IMG_10" target="_parent" class="calibre2" id="IMG_10"><img src="fig269_01.jpg" alt="Click To expand" border="0" class="calibre36"/></a></span>
</div>
<p class="b24-bookeditorial">
<a name="599" class="calibre6" id="599"/><a name="ch13p101" class="calibre6" id="ch13p101"/><b class="calibre13">Answer 101:</b> In the base class destructor, we call the function <span>clear</span>.</p>
<p class="b24-bookeditorial">This function calls a pure virtual function, <span>delete_data</span>.</p>
<p class="b24-bookeditorial">During destruction, the derived class gets deleted first. When the derived class goes, so does the definition of <span>delete_data</span>. Next, the base class destructor is called. In this case, our list class indirectly calls <span>delete_data</span>, which is pure virtual. Because there is no derived class, the runtime system causes the program to abort.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 37:</b> Do not call pure virtual functions from a constructor or destructor of an abstract class.</p>
<p class="b24-bookeditorial">
<a name="600" class="calibre6" id="600"/><a name="ch13p102" class="calibre6" id="ch13p102"/><b class="calibre13">Answer 102:</b> I expect the results to be:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       First 1
       First 1
       First 1
       Second 1
       Second 2
       Second 3
</pre>
</div>
<p class="b24-bookeditorial">but the results are:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       First 0
       First 0
       First 0
       Second 0
       Second 1
       Second 2
</pre>
</div>
<p class="b24-bookeditorial">The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       return (i++);
</pre>
</div>
<p class="b24-bookeditorial">Now I <i class="calibre15">knew</i> that this added one to <span>i</span> and returned. The problem is that <span>i++</span> is the value of <span>i</span> <i class="calibre15">before the increment.</i> So what the statement really does is:</p>
<ol class="orderedlist">
<li class="first-listitem">
<p class="b24-bookeditorial">Save the value of <span>i</span>.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Increment <span>i</span>.</p>
</li>
<li class="first-listitem">
<p class="b24-bookeditorial">Return the saved value.</p>
</li>
</ol>
<p class="b24-bookeditorial">So the lines:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       i = 1;
       return (i++);
</pre>
</div>
<p class="b24-bookeditorial">cause a 1 to be returned, not a 2 as one might expect.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 38:</b> Put ++ and - on lines by themselves.</p>
<p class="b24-bookeditorial">
<a name="601" class="calibre6" id="601"/><a name="ch13p103" class="calibre6" id="ch13p103"/><b class="calibre13">Answer 103:</b> The problem is that on some systems, <span>longs</span> must align on a four-byte boundary. So let's take a look at our structure:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       struct end_block_struct
       {
           unsigned long int next_512_pos;  // [0123]
           unsigned char next_8k_pos1;      // [4]
           unsigned char next_8k_pos2;      // [5]

           unsigned long int prev_251_pos;  // [6789]
</pre>
</div>
<p class="b24-bookeditorial">6 is not divisible by 4, so the compiler adds two padding bytes to make it jump to 8. So what we really have is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       struct end_block_struct
       {
           unsigned long int next_512_pos;  // [0123]
           unsigned char next_8k_pos1;      // [4]
           unsigned char next_8k_pos2;      // [5]

           unsigned char pad1, pad2;        // [67]
           unsigned long int prev_251_pos;  // [89 10 11]
</pre>
</div>
<p class="b24-bookeditorial">This is not what's indented.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 39:</b> Put statements like</p>
<div class="calibre1">
<pre class="literallayout-normal">
       assert(sizeof(end_block_struct) == 16);
</pre>
</div>
<p class="b24-bookeditorial">in your code to catch compilers that cause this problem.</p>
<p class="b24-bookeditorial">Another avoidance is to make every member of the structure a byte and assemble the <span>short</span> and <span>long ints</span> yourself. This is more work, however.</p>
<p class="b24-bookeditorial">
<a name="602" class="calibre6" id="602"/><a name="ch13p104" class="calibre6" id="ch13p104"/><b class="calibre13">Answer 104:</b> The zip code 44101 is too large for MS-DOS's 16-bit integer. The largest number a 16-bit integer can hold is 32,767. The result is that the number overflows into the sign bit, and things go wrong.</p>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">Win32 systems use 32-bit integers, so this problem does not occur on the current versions of Microsoft Windows.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="603" class="calibre6" id="603"/><a name="ch13p105" class="calibre6" id="ch13p105"/><b class="calibre13">Answer 105:</b> The <span>ABORT</span> macro is expanded into two statements. So the result of the <span>if</span> statement is:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (value &lt; 0)
            std::cerr &lt;&lt; "Illegal root" &lt;&lt; std::endl;exit (8);
</pre>
</div>
<p class="b24-bookeditorial">or properly indented:</p>
<div class="calibre1">
<pre class="literallayout-normal">
        if (value &lt; 0)
             std::cerr &lt;&lt; "Illegal root" &lt;&lt; std::endl;
        exit (8);
</pre>
</div>
<p class="b24-bookeditorial">From this output it's easy to see why we always exit.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 40:</b> Use <span>inline</span> functions instead of multistatement macros.</p>
<div class="calibre1">
<pre class="literallayout-normal">
       inline void ABORT(const char msg[]) {
           std::cerr &lt;&lt; msg &lt;&lt; std::endl;
           exit(8);
       }
</pre>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 41:</b> If you must use multistatement macros, enclose them in curly braces:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       #define ABORT(msg) \
           {std::cerr &lt;&lt; msg &lt;&lt; std::endl;exit(8);}
</pre>
</div>
<p class="b24-bookeditorial">
<a name="604" class="calibre6" id="604"/><a name="ch13p106" class="calibre6" id="ch13p106"/><b class="calibre13">Answer 106:</b> The problem is the statement:</p>
<div class="calibre1">
<pre class="literallayout-normal">
           char prev_ch = '\0';
</pre>
</div>
<p class="b24-bookeditorial">Because <span>prev_ch</span> is an automatic variable, this variable is created and initialized at the beginning of each loop. This means for the first <span>if</span> the variable <span>prev_ch</span> will always hold <span>'\0'</span> and we'll never match double letters.</p>
<p class="b24-bookeditorial">
<a name="605" class="calibre6" id="605"/><a name="ch13p107" class="calibre6" id="ch13p107"/><b class="calibre13">Answer 107:</b> This program makes the big mistake of using floating-point for money. Floating-point numbers may not be exact. When adding up a lot of floating-point numbers, some errors may creep in.</p>
<p class="b24-bookeditorial">The solution is to change the program to store money not in fractional dollars but as an integer number of cents.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 42:</b> Don't use floating-point for money or anything else you want represented exactly.</p>
<p class="b24-bookeditorial">
<a name="606" class="calibre6" id="606"/><a name="ch13p108" class="calibre6" id="ch13p108"/><b class="calibre13">Answer 108:</b> The printf call prints whatever string you give it. If you add 1 to a character string, you get the string minus the first character.</p>
<p class="b24-bookeditorial">So:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       printf("-xxx") prints -xxx
       printf("-xxx" + 1) prints xxx
</pre>
</div>
<p class="b24-bookeditorial">The expression <span>((flags &amp; 0x4) != 0)</span> returns a 0 or 1 depending on whether the bit is set.</p>
<p class="b24-bookeditorial">The programmer is printing <span>-word</span> if the bit is set <span>("-word" + 0)</span>. The output is <span>word</span> if it is clear <span>("-word" + 1)</span>.</p>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">If you are going to be this clever in your code, comment it to tell the maintenance programmers how smart you are.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="607" class="calibre6" id="607"/><a name="ch13p109" class="calibre6" id="ch13p109"/><b class="calibre13">Answer 109:</b> The problem is the <span>operator =</span> function. It's defined as:</p>
<div class="calibre1">
<pre class="literallayout-normal">
                trouble operator = (const trouble &amp;i_trouble)
                {
                    std::cout &lt;&lt; "= operator called\n";
                    data = i_trouble.data;
                    return (*this);
                }
</pre>
</div>
<p class="b24-bookeditorial">The return value of this function is the class <span>trouble</span>. But there's a problem. Because the function does not return a reference, a copy of the variable has to be made. That means that the copy constructor has to be called. This calls the <span>operator =</span> function, which does the return, calling the copy constructor and so on.</p>
<p class="b24-bookeditorial">The solution is to have the <span>operator =</span> function return a reference to the class:</p>
<div class="calibre1">
<pre class="literallayout-normal">
               trouble&amp; operator = (const trouble &amp;i_trouble)
</pre>
</div>
<p class="b24-bookeditorial">
<a name="608" class="calibre6" id="608"/><a name="ch13p110" class="calibre6" id="ch13p110"/><b class="calibre13">Answer 110:</b> The initialization of <span>log_file</span> can call <span>new</span>. Of course, our new <span>new</span> uses the <span>log_file</span>, so the <span>log_file</span> may be used before it gets constructed, confusing the whole mess.</p>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 43:</b> Don't redefine the global <span>new</span> and <span>delete</span> unless you know what you are doing. Really know what you are doing. Even then don't do it.</p>
<p class="b24-bookeditorial">
<a name="609" class="calibre6" id="609"/><a name="ch13p111" class="calibre6" id="ch13p111"/><b class="calibre13">Answer 111:</b> The problem is that the initialization order of global variable is not guaranteed. In this case, <span>a_var</span> assumes that <span>std::cout</span> is initialized. That may not be the case.</p>
<p class="b24-bookeditorial">Let's assume the worse and assume that the initialization order is <span>a_var</span>, <span>std::cout</span>. In that case, <span>a_var</span> is created. The constructor is called and output a message to <span>std::cout</span>. Because <span>std::cout</span> has not been created yet, things get very confused and the program crashes.</p>
<p class="b24-bookeditorial">
<a name="610" class="calibre6" id="610"/><a name="ch13p112" class="calibre6" id="ch13p112"/><b class="calibre13">Answer 112:</b> The problem is that <span>MAX</span> is defined to be literally the text "<span>=10</span>" That means that</p>
<div class="calibre1">
<pre class="literallayout-normal">
       for (counter =MAX; counter &gt; 0; --counter)
</pre>
</div>
<p class="b24-bookeditorial">expands to</p>
<div class="calibre1">
<pre class="literallayout-normal">
      for (counter ==10; counter &gt; 0; --counter)

</pre>
</div>
<p class="b24-bookeditorial">This does not initialize the counter (it merely compares counter to 10 and throws the result). Because the counter is not initialized we get a random number of greetings.</p>
<table border="0" cellspacing="0" cellpadding="0" class="calibre3">
<tr class="calibre4">
<td valign="top" class="calibre8"/><td valign="top" class="calibre8">Note </td><td valign="top" class="calibre8">
<p class="b24-bookeditorial">The GNU preprocessor sticks spaces around macro expansions so that the GNU version of the expansions:</p>
<div class="calibre1">
<pre class="literallayout-normal">
<i class="calibre15">for (counter = =10 ; counter &gt; 0; --counter)</i>
</pre>
</div>
<p class="b24-bookeditorial">It's unfortunate that the good GNU technology is robbing us of the opportunity of debugging strangely failing programs.</p>
</td>
</tr>
</table>
<p class="b24-bookeditorial">
<a name="611" class="calibre6" id="611"/><a name="ch13p113" class="calibre6" id="ch13p113"/><b class="calibre13">Answer 113:</b> The space after the name <span>DOUBLE</span> makes this macro a simple text replacement macro. Thus,</p>
<div class="calibre1">
<pre class="literallayout-normal">
       #define DOUBLE (value) ((value) + (value))
</pre>
</div>
<p class="b24-bookeditorial">causes <span>DOUBLE</span> to be replaced with:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       (value) ((value) + (value))
</pre>
</div>
<p class="b24-bookeditorial">Literally!</p>
<p class="b24-bookeditorial">This means that the line</p>
<div class="calibre1">
<pre class="literallayout-normal">
       std::cout &lt;&lt; "Twice " &lt;&lt; counter &lt;&lt; " is " &lt;&lt;
           DOUBLE(counter) &lt;&lt; '\n';
</pre>
</div>
<p class="b24-bookeditorial">looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       std::cout &lt;&lt; "Twice " &lt;&lt; counter &lt;&lt; " is " &lt;&lt;
           (value) ((value) + (value)) (counter) &lt;&lt; '\n';
</pre>
</div>
<p class="b24-bookeditorial">(Indentation added.)</p>
<p class="b24-bookeditorial">Solution: Define <span>DOUBLE</span> as</p>
<div class="calibre1">
<pre class="literallayout-normal">
       #define DOUBLE(value) ((value) + (value))
</pre>
</div>
<p class="b24-bookeditorial">
<b class="calibre13">Avoidance 44:</b> Use <span>inline</span> functions instead of parameterized macros whenever possible. Example:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       inline DOUBLE(const int value) {
           return (value + value);
       }

</pre>
</div>
<p class="b24-bookeditorial">
<a name="612" class="calibre6" id="612"/><a name="ch13p114" class="calibre6" id="ch13p114"/><b class="calibre13">Answer 114:</b> The problem is that the optimizer feels free to rewrite the code. Some optimizers will stick variables in registers to make the code go faster. For example, one optimized version of this program looks like:</p>
<div class="calibre1">
<pre class="literallayout-normal">
  1 /************************************************
  2  * sum -- Sum the sine of the numbers from 0 to *
  3  *      0X3FFFFFFF.   Actually we don't care    *
  4  *      about the answer, all we're trying to   *
  5  *      do is create some sort of compute       *
  6  *      bound job so that the status_monitor    *
  7  *      can be demonstrated.                    *
  8  ************************************************/
  9 /* --- After the optimizer --- */
 10 /* --- gets through with it --- */
 11 static void sum(void)
 12 {
 13     static double sum = 0;      /* Sum so far */
 14     register int reg_counter = counter;
 15
 16     for (reg_counter = 0;
 17          reg_counter &lt; 0x3FFFFFF; ++reg_counter)
 18     {
 19         sum += sin(double(reg_counter));
 20     }
 21     printf("Total %f\n", sum);
 22     counter = reg_counter;
 23     exit (0);
 24 }
</pre>
</div>
<p class="b24-bookeditorial">From this, we can see that counter is updated only after the program finishes. If we try to examine it at any time in the other thread we die.</p>
<p class="b24-bookeditorial">The solution it to declare the variable <span>volatile</span>:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       volatile int counter;
</pre>
</div>
<p class="b24-bookeditorial">Then the compiler will make no assumptions about what it can do about it regarding optimization, and will generate code that keeps <span>counter</span> is kept up-to-date.</p>
<p class="b24-bookeditorial">
<a name="613" class="calibre6" id="613"/><a name="ch13p115" class="calibre6" id="ch13p115"/><b class="calibre13">Answer 115:</b> I am trying to always make sure I <span>delete</span> the variable <span>data</span> before I overwrite it so I don't have a memory leak. I <span>even</span> delete it in the following code:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       34        // Copy constructor
       35        v_string(const v_string &amp;old)
       36        {
       37            if (data != NULL)
       38            {
       39            delete[] data;
       40            data = NULL;
       41        }
       42        data = strdup(old.data);
       43    }
</pre>
</div>
<p class="b24-bookeditorial">This is the copy constructor. The first thing it does is to see if <span>data</span> has anything in it and, if so, <span>delete</span> it. But what could <span>data</span> possibly have in it? We just created the class and haven't initialized it yet. So we are deleting a random pointer and as a result, crashing. Properly written our copy constructor should be:</p>
<div class="calibre1">
<pre class="literallayout-normal">
       34       // Copy constructor
       35       v_string(const v_string &amp;old):
       36           data(strdup(old.data))
       37       {}

</pre>
</div>
</div>





<div class="calibre1">
<h1 class="title" id="calibre_pb_0">List of Sidebars</h1><div class="calibre1">
</div>
</div>



</body></html>