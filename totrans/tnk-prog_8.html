<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Thinking Like a Programmer"><div class="titlepage"><div><div><h1 class="title"><a id="thinking_like_a_programmer"/>Chapter 8. Thinking Like a Programmer</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id8"/><div class="mediaobject"><a id="I_mediaobject8_d1e15414"/><img src="httpatomoreillycomsourcenostarchimages1273151.png.jpg" alt="image with no caption"/></div></div><p>It’s time for us to bring together everything we’ve experienced over the previous chapters to complete the journey from fledgling coder to problem-solving programmer.</p><p>In previous chapters, we’ve solved problems in a variety of areas. I believe these areas are the most beneficial for the developing programmer to master, but of course there are always more things to learn, and many problems will require skills not covered in this book. So in this chapter, we’re going to come full circle to general problem-solving concepts, taking the knowledge we’ve gained in our journey to develop a <span class="emphasis"><em>master plan</em></span> for attacking any programming problem. Although we might call this a general plan, in one way it’s actually a very specific plan: It will be <span class="emphasis"><em>your</em></span> plan, and no one else’s. We’ll also look at the many ways you can add to your knowledge and skills as a programmer.</p><div class="sect1" title="Creating Your Own Master Plan"><div class="titlepage"><div><div><h1 class="title"><a id="creating_your_own_master_plan"/>Creating Your Own Master Plan</h1></div></div></div><p>Way back in the first chapter, we learned the first rule of problem solving was that you should always have a plan. A more precise formulation would be to say you should always follow <span class="emphasis"><em>your</em></span> plan. You should construct a master plan that maximizes your strengths and minimizes your weaknesses and then apply this master plan to each problem you must solve.<a id="IDX-CHP-8-0001" class="indexterm"/><a id="IDX-CHP-8-0002" class="indexterm"/><a id="IDX-CHP-8-0003" class="indexterm"/></p><p>Over many years of teaching, I’ve seen students of all different abilities. By that I don’t simply mean that some programmers have more ability than others, although of course this is true. Even among programmers with the same level of ability, there is great diversity. I’ve lost track of how often I’ve been surprised by a formerly struggling student who quickly masters a particular skill or a talented student who displays a weakness in a new area. Just as no two fingerprints are the same, no two brains are the same, and lessons that are easy for one person are difficult for another.</p><p>Suppose you’re a football coach, planning your offense for the next game. Because of an injury, you’re not sure which of two quarterbacks will be able to start. Both quarterbacks are highly capable professionals, but like any individuals in any endeavor, they have their strengths and weaknesses. The game plan that creates the best opportunity for victory with one quarterback might be terrible for the other.</p><p>In creating your master plan, you are the coach and your skill set is your quarterback. To maximize your chances for success, you need a plan that recognizes both your strengths and your weaknesses.</p><div class="sect2" title="Playing to Your Strengths and Weaknesses"><div class="titlepage"><div><div><h2 class="title"><a id="playing_to_your_strengths_and_weaknesses"/>Playing to Your Strengths and Weaknesses</h2></div></div></div><p>The key step in making your own master plan, then, is identifying your strengths and weaknesses. This is not difficult, but it requires effort and a fair degree of honest self-appraisal. In order to benefit from your mistakes, you must not only correct them in programs in which they appear, but you must also note them, at least mentally, or better yet, in a document. In this way, you can identify patterns of behavior that you would have otherwise missed.</p><p>I’m going to describe weaknesses in two different categories: coding and design. <span class="emphasis"><em>Coding weaknesses</em></span> are areas where you tend to repeat mistakes when you’re actually writing the code. For example, many programmers frequently write loops that iterate one time too many or one time too few. This is known as a <span class="emphasis"><em>fencepost error</em></span>, from an old puzzle about how many fenceposts are needed to build a 50-foot fence with 10-foot-long rails between posts. The immediate response from most people is five, but if you think about it carefully, the answer is six, as shown in <a class="xref" href="ch08.html#the_fencepost_puzzle" title="Figure 8-1. The fencepost puzzle">Figure 8-1</a>.<a id="IDX-CHP-8-0004" class="indexterm"/><a id="IDX-CHP-8-0005" class="indexterm"/></p><p>Most coding weaknesses are situations in which the programmer creates semantic errors by coding too quickly or without enough preparation. <span class="emphasis"><em>Design weaknesses</em></span>, in contrast, are problems you commonly have in the problem-solving or design stage. For example, you might discover you have trouble getting started or trouble integrating previously written subprograms into a complete solution.<a id="IDX-CHP-8-0006" class="indexterm"/></p><div class="figure"><a id="the_fencepost_puzzle"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject8_d1e15490"/><img src="httpatomoreillycomsourcenostarchimages1273271.png" alt="The fencepost puzzle"/></div></div><p class="title">Figure 8-1. The fencepost puzzle</p></div><p>Although there is some overlap between these two categories, the two types of weaknesses tend to create different sorts of problems and must be defended against in different ways.<a id="IDX-CHP-8-0007" class="indexterm"/><a id="IDX-CHP-8-0008" class="indexterm"/><a id="IDX-CHP-8-0009" class="indexterm"/><a id="IDX-CHP-8-0010" class="indexterm"/><a id="IDX-CHP-8-0011" class="indexterm"/><a id="IDX-CHP-8-0012" class="indexterm"/><a id="IDX-CHP-8-0013" class="indexterm"/><a id="IDX-CHP-8-0014" class="indexterm"/></p><div class="sect3" title="Planning Against Coding Weaknesses"><div class="titlepage"><div><div><h3 class="title"><a id="planning_against_coding_weaknesses"/>Planning Against Coding Weaknesses</h3></div></div></div><p>Perhaps the most frustrating activity in programming is spending hours tracking down a semantic error that turns out to be a simple thing to fix once identified. Because no one is perfect, there’s no way to completely eliminate these situations, but a good programmer will do all he or she can to avoid making the same mistakes over and over again.</p><p>I knew a programmer who had tired of making what is perhaps the most common semantic error in C++ programming: the substitution of the assignment operator (<code class="literal">=</code>) for the equality operator (<code class="literal">==</code>). Because conditional expressions in C++ are integer, not strictly Boolean, a statement such as the following is syntactically legal:</p><a id="I_programlisting8_d1e15540"/><pre class="programlisting">if (number = 1) flag = true;</pre><p>In this case, the integer value 1 is assigned to <code class="literal">number</code>, and then the value 1 is used as the result of the conditional statement, which C++ evaluates as <code class="literal">true</code>. What the programmer meant to do, of course, was:</p><a id="I_programlisting8_d1e15550"/><pre class="programlisting">if (number == 1) flag = true;</pre><p>Frustrated at making this type of mistake over and over, the programmer taught himself to always write equality tests the other way, with the numerical literal on the left side, such as:</p><a id="I_programlisting8_d1e15554"/><pre class="programlisting">if (1 == number) flag = true;</pre><p>By doing this, if the programmer slips up and substitutes the equality operator, the expression <code class="literal">1 = number</code> would no longer be legal C++ syntax, and would produce a syntax error that would be caught at compile time. The original error is legal syntax, so it’s only a semantic error, which would be caught at compile time or not caught at all. Since I had made this mistake many times myself (and driven myself crazy trying to track the bug down), I employed this method, putting the numerical literal on the left side of the equality operator. In doing so, I discovered something curious. Because this ran counter to my usual style, putting the literal on the left forced me to pause momentarily when writing conditional statements. I would think, “I need to remember to put the literal on the left so that I’ll catch myself if I use the assignment operator.” As you might expect, by having that thought run through my head, I never actually used the assignment operator but always correctly used the equality operator. Now, I no longer put the literal on the left side of the equality operator, but I still pause and let those thoughts run through my head, which keeps me from using the wrong operator.<a id="IDX-CHP-8-0015" class="indexterm"/></p><p>The lesson here is that being aware of your coding-level weaknesses is often all that is necessary to avoid them. That’s the good news. The bad news is that you still have to put in the work to be aware of your coding weaknesses in the first place. The key technique is asking yourself why you made a particular mistake, rather than just fixing the mistake and moving on. This will allow you to identify the general principle you failed to follow. For example, suppose you had written the following function to compute the average of the positive numbers in an array of integers:</p><a id="I_programlisting8_d1e15568"/><pre class="programlisting">double averagePositive(int array[ARRAYSIZE]) {
   int total = 0;
   int positiveCount = 0;
   for (int i = 0; i &lt; ARRAYSIZE; i++) {
      if (array[i] &gt; 0) {
         total += array[i];
         positiveCount++;
      }
   }
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>return total / (double) positiveCount;
}</pre><p>At a glance, this function looks fine, but upon closer inspection, it has a problem. If there are no positive numbers in the array, then the value of <code class="literal">positiveCount</code> will be zero when the loop ends, and this will result in a division by zero at the end of the function <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e15582"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Because this is floating-point division, the program may not actually crash but rather produce odd behavior, depending on how the value of this function is used in the overall program.<a id="IDX-CHP-8-0016" class="indexterm"/></p><p>If you were quickly trying to get your code running and you discovered this problem, you might add some code to handle the case where <code class="literal">positiveCount</code> is zero and move on. But if you want to grow as a programmer, you should ask yourself what mistake you made. The specific problem, of course, is that you didn’t account for the possibility of dividing by zero. If that’s as deep as the analysis goes, though, it won’t help you very much in the future. Sure, you might catch another situation where a divisor might turn out to be zero, but that is not a very common situation. Instead, we should ask what general principle has been violated. The answer: that we should always look for special cases that can blow up our code.</p><p>By considering this general principle, we’ll be more likely to see patterns in our mistakes and therefore more likely to catch those mistakes in the future. Asking ourselves, “Any chance of dividing by zero here?” is not nearly as useful as asking ourselves, “What are the special cases for this data?” By asking the broader question, we’ll be reminded to check not just for division by zero but also for empty data sets, data outside the expected range, and so on.<a id="IDX-CHP-8-0017" class="indexterm"/></p></div><div class="sect3" title="Planning Against Design Weaknesses"><div class="titlepage"><div><div><h3 class="title"><a id="planning_against_design_weaknesses"/>Planning Against Design Weaknesses</h3></div></div></div><p>Design weaknesses require a different approach to circumvent. The first step, though, is the same: You identify the weaknesses. A lot of people have trouble with this step because they don’t like to turn such a critical eye on themselves. We’re conditioned to conceal personal failings. It’s like when a job interviewer asks you what your biggest weakness is, and you are expected to answer with some nonsense about how you care too much about the quality of your work instead of providing an <span class="emphasis"><em>actual</em></span> weakness. But just as Superman has his Kryptonite, even the best programmers have real weaknesses.<a id="IDX-CHP-8-0018" class="indexterm"/></p><p>Here’s a sample (and certainly not exhaustive) list of programmer weaknesses. See whether you recognize yourself in any of these descriptions.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Convoluted designs</strong></span></span></dt><dd><p>The programmer with this weakness creates programs that have too many parts or too many steps. While the programs work, they don’t inspire confidence—like worn clothing that looks as if it would fall apart at the first tug of a thread—and they are clearly inefficient.</p></dd><dt><span class="term"><span class="strong"><strong>Can’t get started</strong></span></span></dt><dd><p>This programmer has a high degree of inertia. Whether from a lack of confidence in problem solving or plain procrastination, this programmer takes too long to make any initial progress on a problem.</p></dd><dt><span class="term"><span class="strong"><strong>Fails to test</strong></span></span></dt><dd><p>This programmer doesn’t like to formally test the code. Often the code will work for general cases, but not for special cases. In other situations, the code will work fine but won’t “scale up” for larger problem sets that the programmer hasn’t tested.</p></dd><dt><span class="term"><span class="strong"><strong>Overconfident</strong></span></span></dt><dd><p>Confidence is a great thing—this book is intended to increase the confidence of its readers—but too much confidence can sometimes be as much a problem as too little. Overconfidence manifests itself in various ways. The overconfident programmer might attempt a more complicated solution than necessary or allow too little time to finish a project, resulting in a rushed, bug-ridden program.<a id="IDX-CHP-8-0019" class="indexterm"/></p></dd><dt><span class="term"><span class="strong"><strong>Weak area</strong></span></span></dt><dd><p>This category is a bit of a catchall. Some programmers work smoothly enough until they hit certain concepts. Consider the topics discussed in previous chapters of this book. Most programmers, even after completing the exercises, will be more confident in some of the areas we’ve covered than others. For example, perhaps the programmer gets lost with pointer programs, or recursion turns the programmer’s head inside out. Maybe the programmer has trouble designing elaborate classes. It’s not that the programmer can’t muddle through and solve the problem, but it’s rough work, like driving through mud.</p></dd></dl></div><p>There are different ways you can confront your large-scale weaknesses, but once you recognize them, it’s easy to plan around them. If you’re the kind of programmer who often skips testing, for example, make testing an explicit part of your plan for writing each module, and don’t move onto the next module until you put a check in that box. Or consider a design paradigm called <span class="emphasis"><em>test-driven development</em></span>, in which the testing code is written first, and then the code is written to fill those tests. If you have trouble getting started, use the principles of dividing or reducing problems, and start writing code as soon as you can, with the understanding that you may have to rewrite that code later. If your designs are often too complicated, add an explicit refactoring step to your master plan. The point is, no matter what weaknesses you have as a programmer, if you recognize them, you can plan around them. Then your weaknesses are no longer weaknesses—just obstacles in the road that you will steer around on the way to successful project completion.<a id="IDX-CHP-8-0020" class="indexterm"/><a id="IDX-CHP-8-0021" class="indexterm"/></p></div><div class="sect3" title="Planning for Your Strengths"><div class="titlepage"><div><div><h3 class="title"><a id="planning_for_your_strengths"/>Planning for Your Strengths</h3></div></div></div><p>Planning for your weaknesses is largely about avoiding mistakes. Good planning, though, isn’t just about avoiding mistakes. It’s about working toward the best possible result given your current abilities and whatever restraints you may be operating under. This means you must also incorporate your strengths into your master plan.</p><p>You might think that this section isn’t for you, or at least not yet. After all, if you are reading this book, then you are still becoming a programmer. You might wonder whether you even have any strengths at this stage of your development. I’m here to tell you that you do, even if you haven’t recognized them yet. Here’s a list of common programmer strengths, by no means exhaustive, with descriptions of each and hints to help you recognize whether the term applies to you:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Eye for detail</strong></span></span></dt><dd><p>This type of programmer can anticipate special cases, see potential performance issues before they arise, and never lets the big picture cloud over the important details that must be handled for the program to be a complete and correct solution. Programmers with this strength tend to test their plans on paper before coding, code slowly, and test frequently.</p></dd><dt><span class="term"><span class="strong"><strong>Fast learner</strong></span></span></dt><dd><p>A fast learner picks up new skills quickly, whether that’s learning a new technique in an already-known language or working with a new application framework. This type of programmer enjoys the challenge of learning new things and may choose projects based on this preference.<a id="IDX-CHP-8-0022" class="indexterm"/></p></dd><dt><span class="term"><span class="strong"><strong>Fast coder</strong></span></span></dt><dd><p>The fast coder doesn’t need to spend a lot of time with a reference book to hammer out a function. Once it’s time to start typing, the code flows off the ends of the fast coder’s fingers without much effort and with few syntactical errors.<a id="IDX-CHP-8-0023" class="indexterm"/></p></dd><dt><span class="term"><span class="strong"><strong>Never gives up</strong></span></span></dt><dd><p>For some programmers, a pesky bug is a personal affront that can’t be ignored. It’s like the program has slapped the programmer across the mouth with a leather glove, and it’s up to the programmer to respond. This type of programmer always seems to stay levelheaded, determined but never very frustrated, and confident that with enough effort, victory is assured.<a id="IDX-CHP-8-0024" class="indexterm"/></p></dd><dt><span class="term"><span class="strong"><strong>Super problem-solver</strong></span></span></dt><dd><p>Presumably you were not a super problem-solver when you bought this book, but now that you’ve gotten some guidance, perhaps it’s all starting to come easily. The programmer with this trait is starting to envision potential solutions to a problem even as he or she is reading it.</p></dd><dt><span class="term"><span class="strong"><strong>Tinkerer</strong></span></span></dt><dd><p>To this sort of programmer, a working program is like a wonderful toy box. The tinkerer has never lost the thrill of making the computer do his or her bidding and loves to keep finding something else for the computer to do. Maybe the tinkering means adding more and more functionality to a working program—a symptom known as <span class="emphasis"><em>creeping featurism</em></span>. Maybe the program can be refactored for improved performance. Maybe the program can just be made prettier for the programmer or the user.<a id="IDX-CHP-8-0025" class="indexterm"/></p></dd></dl></div><p>Few programmers will exhibit more than a couple of these strengths—in fact, some of them tend to cancel each other out. But every programmer has strengths. If you don’t recognize yourself in any of these, it just means you have yet to learn enough about yourself or your strength is something that doesn’t fit into one of my categories.</p><p>Once you’ve identified your strengths, you need to factor them into your master plan. Suppose you’re a fast coder. Obviously this will help get any project across the finish line, but how can you leverage this strength in a systematic way? In formal software engineering, there is an approach called <span class="emphasis"><em>rapid prototyping</em></span>, in which a program is initially written without extensive planning and then improved through successive iterations until the results meet the problem requirements. If you’re a fast coder, you might try adopting this method, coding as soon as you have a basic idea and letting your rough prototype guide the design and development of the final program code.<a id="IDX-CHP-8-0026" class="indexterm"/></p><p>If you’re a rapid learner, maybe you should start every project by hunting for new resources or techniques to solve the current problem. If you’re not a rapid learner, but you are the sort of programmer who doesn’t easily get frustrated, maybe you should start the project with the areas you think will be the most difficult to give yourself the most time to tackle them.</p><p>So whatever strengths you have, make sure you are taking advantage of them in your programming. Design your master plan so that you spend as much time as possible doing what you do best. Not only will you produce the best results this way, but you’ll also have the most fun, too.</p></div></div><div class="sect2" title="Putting the Master Plan Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_the_master_plan_together"/>Putting the Master Plan Together</h2></div></div></div><p>Let’s look at constructing a sample master plan. The ingredients include all the problem-solving techniques we have developed, plus our analysis of our strengths and weaknesses. For this example, I’ll use my own strengths and weaknesses.</p><p>In terms of problem-solving techniques, I use all of the techniques I share in this book, but I’m especially fond of the “reduce the problem” technique because using that technique allows me to feel that I’m always making concrete progress toward my goal. If I’m currently unable to figure out a way to write code that meets the full specification, I just throw out part of the specification until I gain momentum.</p><p>My biggest coding weakness is excessive eagerness. I love to program because I love to see computers following my instructions. Sometimes this leads me to think, “Let’s give this thing a rip and see what happens,” when I should still be analyzing the correctness of what I just wrote. The danger here isn’t that the program will fail—it’s that the program will either appear to succeed but not cover all the special cases, or succeed but not be the best possible solution I could write.</p><p>I love elegant program designs that are easy to expand and reuse. Often when I code larger projects, I spend a lot of time developing alternative designs. On the whole, this is a good trait, but sometimes this results in me spending too much time in the design phase, not leaving enough time to actually implement the selected design. Also, this can sometimes result in a solution that is over-designed. That is, sometimes the solution is more elegant, expandable, and robust than it really needs to be. Because every project is limited in time and money, the best solution must balance the desire for high software quality with the need to conserve resources.</p><p>My best programming strength, I think, is that I pick up new concepts well, and I love to learn. While some programmers like using the same skills over and over, I love a project where I can learn something new, and I’m always exhilarated by that challenge.</p><p>With all that in mind, here is my master plan for a new project.</p><p>To fight my primary design weakness, I will strictly limit my time spent in the design phase or, alternatively, limit the number of distinct designs I will consider before moving on. This might sound like a dangerous idea to some readers. Shouldn’t we spend as much time as we can in the design phase before jumping into coding? Don’t most projects fail because not enough time was spent on the front end, leading to a cascade of compromises on the back end? These concerns are valid, but remember that I’m not creating a general guidebook for software development. I’m creating my own personal master plan for tackling programming problems. My weakness is over-designing, not under-designing, so a rule limiting design time makes sense for me. For another programmer, such a rule could be disastrous, and some programmers may need a rule to force them to spend more time on design.</p><p>After I complete my initial analysis, I’m going to consider whether the project presents opportunities to learn new techniques, libraries, and so forth. If it does, I’m going to write a small test-bed program to try out these new skills before attempting to incorporate them into my developing solution.<a id="IDX-CHP-8-0027" class="indexterm"/></p><p>To fight excessive eagerness, I could incorporate a miniature code-review step when I finish coding each module. However, that will require an exercise of willpower on my part—when I complete each module, I’m going to want to go ahead and try it out. Simply hoping that I can talk myself out of it each time is like leaving an open bag of potato chips next to a hungry man and being surprised when the bag is emptied. It’s better to subvert weaknesses with a plan that doesn’t require the programmer to fight his or her instincts. So what if I create two versions of the project: a crusty, anything-goes version and a polished version for delivery? If I allow myself to play with the first version at will but prevent myself from incorporating code into the polished version until it’s been fully vetted, I’m much more likely to overcome my weakness.</p></div></div><div class="sect1" title="Tackling Any Problem"><div class="titlepage"><div><div><h1 class="title"><a id="tackling_any_problem"/>Tackling Any Problem</h1></div></div></div><p>Once we have a master plan, we’re ready for anything. That’s what this book is ultimately all about: starting with a problem, any problem, and finding a way through to the solution. In all the previous chapters, the problem descriptions pushed us in a particular initial direction, but in the real world, most problems don’t come with a requirement to use an array or recursion or to encapsulate some part of the program’s functionality into a class. Instead, the programmer makes those decisions as part of the problem-solving process.</p><p>At first, fewer requirements might seem to make problems easier. After all, a design requirement is a constraint, and don’t constraints make problems harder? While this is true, it’s also true that all problems have constraints—it’s just that in some cases they are more explicitly spelled out than in others. For example, not being told whether a particular problem requires a dynamically allocated structure doesn’t mean that the decision has no effect. The broad constraints of the problem—whether for performance, modifiability, speed of development, or something else—may be more difficult, or perhaps impossible, to meet if we make the wrong design choices.<a id="IDX-CHP-8-0028" class="indexterm"/></p><p>Imagine a group of friends has asked you to select a movie for everyone to watch. If one friend definitely wants a comedy, another doesn’t like older films, and another lists five films she’s just seen and doesn’t want to see again, these constraints will make the selection difficult. However, if no one has any suggestions beyond “just pick something good,” your work is even harder, and you’re highly likely to pick something that at least one member of the group won’t like at all.</p><p>Therefore larger, broadly defined, weakly constrained problems are the most difficult of all. However, they are susceptible to the same problem-solving techniques we’ve used throughout this book; they just take more time to solve. With your knowledge of these techniques and your master plan in hand, you will be able to solve any problem.</p><p>To demonstrate what I’m talking about, I’m going to walk you through the first steps of a program that plays hangman, the classic children’s game, but with a twist.<a id="IDX-CHP-8-0029" class="indexterm"/></p><p>Before we get to the problem description, let’s review the basic rules of the game. The first player selects a word and tells a second player how many letters are in the word. The second player then guesses a letter. If the letter is in the word, the first player shows where the letter appears in the word; if the letter appears more than once, all appearances are indicated. If the letter is not in the word, the first player adds a piece to a stick-figure drawing of a man being hanged. If the second player guesses all the letters in the word, the second player wins, but if the first player completes the drawing, the first player wins. Different rules exist for how many pieces make up the drawing of the hanged man, so more generally we can say that the players agree ahead of time how many “misses” will win the game for the first player.</p><p>Now that we’ve covered the basic rules, let’s look at the specific problem, including the challenging twist.</p><div class="sidebar"><a id="problem_colon_cheating_at_hangman"/><p class="title">Problem: Cheating at Hangman</p><p>Write a program that will be Player 1 in a text-based version of hangman (that is, you don’t actually have to draw a hanged man—just keep track of the number of incorrect guesses). Player 2 will set the difficulty of the game by specifying the length of the word to guess as well as the number of incorrect guesses that will lose the game.</p><p>The twist is that the program will cheat. Rather than actually picking a word at the beginning of the game, the program may avoid picking a word, so long as when Player 2 loses, the program can display a word that matches all the information given to Player 2. The correctly guessed letters must appear in their correct positions, and none of the incorrectly guessed letters can appear in the word at all. When the game ends, Player 1 (the program) will tell Player 2 the word that was chosen. Therefore, Player 2 can never prove that the game is cheating; it’s just that the likelihood of Player 2 winning is small.</p></div><p>This is not a monster-sized problem by real-world standards, but it’s large enough to demonstrate the issues we face when dealing with a programming problem that specifies results but no methodology. Based on the problem description, you could fire up your development environment and begin to write code in one of dozens of different places. That, of course, would be a mistake because we always want to program with a plan, so I need to apply my master plan to this specific situation.</p><p>The first part of my master plan is limiting the amount of time I spend in the design phase. In order to make that a reality, I need to think carefully about the design before I work on the production code. However, I believe that some experimentation will be necessary in this case for me to work out a solution to the problem. My master plan also allows me to create two projects, a rough-and-ready prototype and a final, polished solution. So I’m going to allow myself to begin coding for the prototype at any time, prior to any real design work, but not allow any coding in the final solution until I believe my design is set. That won’t guarantee I’ll be entirely satisfied with the design in the second project, but it offers the best opportunity for that to be so.</p><p>Now it’s time to start picking this problem apart. In previous chapters, we would sometimes list all of the subtasks needed to complete a problem, so I’d like to make an inventory of the subtasks. At this point, though, this would be difficult because I don’t know what the program will actually do to accomplish the cheating. I need to investigate this area further.</p><div class="sect2" title="Finding a Way to Cheat"><div class="titlepage"><div><div><h2 class="title"><a id="finding_a_way_to_cheat"/>Finding a Way to Cheat</h2></div></div></div><p>Cheating at hangman is specific enough that I don’t expect to find any help in the normal sources of components; there is no <span class="emphasis"><em>NefariousStrategy</em></span> pattern. At this point, I have a vague idea how the cheating could be accomplished. I’m thinking that I’ll choose an initial puzzle word and hang on to that as long as Player 2 chooses letters that aren’t actually in that word. Once Player 2 hits upon a letter that’s actually in the word, though, I’ll switch to another word if it’s possible to find one that has none of the letters selected thus far. In other words, I’ll deny a match to Player 2 as long as possible. That’s the idea, but I need more than an idea—I need something I can implement.</p><p>In order to firm up my ideas, I’m going to work through an example on paper, taking on the role of Player 1, working from a word list. To keep things simple, I’m going to assume that Player 2 has requested a three-letter word and that the complete list of three-letter words that I know are shown in the first column of <a class="xref" href="ch08.html#sample_word_list" title="Table 8-1. Sample Word List">Table 8-1</a>. I’ll assume that my first choice “puzzle word” is the first word on the list, <span class="emphasis"><em>bat</em></span>. If Player 2 guesses any letter besides <span class="emphasis"><em>b</em></span>, <span class="emphasis"><em>a</em></span>, or <span class="emphasis"><em>t</em></span>, I’ll say “no,” and we’ll be one step closer to completing the gallows. If Player 2 guesses a letter in the word, then I’ll pick another word, one that doesn’t contain that letter.</p><p>Looking at my list, though, I’m not so sure this strategy is the best. In some situations, it probably makes sense. Suppose Player 2 guesses <span class="emphasis"><em>b</em></span>. No other word in the list contains <span class="emphasis"><em>b</em></span>, so I can switch the puzzle word to any of them. This also means that I’ve minimized the damage; I’ve eliminated only one possible word from my list. But what happens if Player 2 guesses <span class="emphasis"><em>a</em></span>? If I just say “no,” I eliminate all words containing an <span class="emphasis"><em>a</em></span>, which leaves just the three words in the second column of <a class="xref" href="ch08.html#sample_word_list" title="Table 8-1. Sample Word List">Table 8-1</a> for me to choose from. If I decided instead to admit the presence of letter <span class="emphasis"><em>a</em></span> in the puzzle word, I would have five words left I could choose from, as shown in the third column. Note, though, that this extended selection exists only because all five of the words have the <span class="emphasis"><em>a</em></span> in the same position. Once I declare a guess correct, I have to show exactly where the letter appears in the word. I’ll feel a lot better about my chances for the rest of the game if I have more word choices remaining to react to future guesses.</p><div class="table"><a id="sample_word_list"/><p class="title">Table 8-1. Sample Word List</p><div class="table-contents"><table summary="Sample Word List" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>All Words</p></th><th style="text-align: left" valign="bottom"><p>Words Without <span class="emphasis"><em>a</em></span></p></th><th style="text-align: left" valign="bottom"><p>Words with <span class="emphasis"><em>a</em></span></p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>bat</p></td><td style="text-align: left" valign="top"><p>dot</p></td><td style="text-align: left" valign="top"><p>bat</p></td></tr><tr><td style="text-align: left" valign="top"><p>car</p></td><td style="text-align: left" valign="top"><p>pit</p></td><td style="text-align: left" valign="top"><p>car</p></td></tr><tr><td style="text-align: left" valign="top"><p>dot</p></td><td style="text-align: left" valign="top"><p>top</p></td><td style="text-align: left" valign="top"><p>eat</p></td></tr><tr><td style="text-align: left" valign="top"><p>eat</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>saw</p></td></tr><tr><td style="text-align: left" valign="top"><p>pit</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>tap</p></td></tr><tr><td style="text-align: left" valign="top"><p>saw</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>tap</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>top</p></td><td style="border-right: 0.5pt solid ; "> </td><td style=""> </td></tr></tbody></table></div></div><p>Also, even if I managed to avoid revealing letters early in the game, I have to expect that Player 2 will eventually make a correct guess. Player 2 could start with all of the vowels, for example. Therefore, at some point I will have to decide what to do when a letter is revealed, and from my experiment with the sample list, it looks like I will have to find the location (or locations) where the letter appears most often. From this observation, I realized that I have been thinking about cheating in the wrong way. I should never actually pick a puzzle word, even temporarily, but just keep track of all the possible words I could choose if I have to.</p><p>With this idea in mind, I can now define cheating in a different way: Keep as many words as possible in the list of candidate puzzle words. For each guess that Player 2 makes, the program has a decision to make. Do we claim that the guess was a miss or a match? If it was a match, in which positions does the guessed letter appear? I’ll have my program keep an ever-dwindling list of candidate puzzle words and, after each guess, make the decision that will leave the greatest number of words in that list.</p></div></div><div class="sect1" title="Required Operations for Cheating at Hangman"><div class="titlepage"><div><div><h1 class="title"><a id="required_operations_for_cheating_at_hang"/>Required Operations for Cheating at Hangman</h1></div></div></div><p>Now I understand the problem well enough to create my list of subtasks. In a problem of this size, there’s a good chance that a list made at this early stage will leave some operations out. This is okay, because my master plan anticipates that I will not create a perfect design the first time around.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Store and maintain a list of words</strong></span>.</span></dt><dd><p>This program must have a list of valid English words. The program will therefore have to read a list of words from a file and store them internally in some format. This list will be reduced, or extracted from, during the game as the program cheats.</p></dd><dt><span class="term"><span class="strong"><strong>Create a sublist of words of a given length</strong></span>.</span></dt><dd><p>Given my intention to maintain a list of candidate puzzle words, I have to start the game with a list of words of the length specified by Player 2.</p></dd><dt><span class="term"><span class="strong"><strong>Track letters chosen</strong></span>.</span></dt><dd><p>The program will need to remember which letters have been guessed, how many of those were incorrect, and for any that were deemed correct, where they appear in the puzzle word.</p></dd><dt><span class="term"><span class="strong"><strong>Count words in which a letter does not appear</strong></span>.</span></dt><dd><p>In order to facilitate cheating, I’ll need to know how many words in the list do not contain the most recently guessed letter. Remember that the program will decide whether the most recently guessed letter appears in the puzzle word with the goal of leaving the maximum number of words in the candidate word list.</p></dd><dt><span class="term"><span class="strong"><strong>Determine the largest number of words based on letter and position</strong></span>.</span></dt><dd><p>This looks like the trickiest operation. Let’s suppose Player 2 has just guessed the letter <span class="emphasis"><em>d</em></span> and the current game has a puzzle-word length of three. Perhaps the current candidate word list as a whole contains 10 words that include <span class="emphasis"><em>d</em></span>, but that’s not what’s important because the program will have to state where the letter occurs in the puzzle word. Let’s call the positioning of letters in a word a pattern. So <span class="emphasis"><em>d??</em></span> is a three-letter pattern that specifies the first letter is a <span class="emphasis"><em>d</em></span> and the other two letters are anything other than a <span class="emphasis"><em>d</em></span>. Consider <a class="xref" href="ch08.html#three-letter_words" title="Table 8-2. Three-Letter Words">Table 8-2</a>. Suppose that the list in the first column contains every three-letter word containing <span class="emphasis"><em>d</em></span> known to the program. The other columns break this list down by pattern. The most frequently occurring pattern is <span class="emphasis"><em>??d</em></span>, with 17 words. This number, 17, would be compared with the number of words in the candidate list that do not contain a <span class="emphasis"><em>d</em></span> to determine whether to call the guess a match or a miss.</p></dd><dt><span class="term"><span class="strong"><strong>Create a sublist of words matching a pattern</strong></span>.</span></dt><dd><p>When the program declares that a Player 2 guess is a match, it will create a new candidate word list with only those words that match the letter pattern chosen. In the previous example, if we declared <span class="emphasis"><em>d</em></span> a match, the third column in <a class="xref" href="ch08.html#three-letter_words" title="Table 8-2. Three-Letter Words">Table 8-2</a> would become the new candidate word list.</p></dd><dt><span class="term"><span class="strong"><strong>Keep playing until the game is over</strong></span>.</span></dt><dd><p>After all the other operations are in place, I need to write the code that glues everything together and actually play the game. The program should repeatedly request a guess from Player 2 (the user), determine whether the candidate word list would be longer by rejecting or accepting that guess, reduce the word list accordingly, and then display the resulting puzzle word, with any correctly guessed letters revealed, along with a review of all previously guessed letters. This process would continue until the game was over, having been won by one player or the other—the conditions for which I also need to figure out.</p></dd></dl></div><div class="table"><a id="three-letter_words"/><p class="title">Table 8-2. Three-Letter Words</p><div class="table-contents"><table summary="Three-Letter Words" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>All Words</p></th><th style="text-align: left" valign="bottom"><p>?dd</p></th><th style="text-align: left" valign="bottom"><p>??d</p></th><th style="text-align: left" valign="bottom"><p>d??</p></th><th style="text-align: left" valign="bottom"><p>d?d</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>add</p></td><td style="text-align: left" valign="top"><p>add</p></td><td style="text-align: left" valign="top"><p>aid</p></td><td style="text-align: left" valign="top"><p>day</p></td><td style="text-align: left" valign="top"><p>did</p></td></tr><tr><td style="text-align: left" valign="top"><p>aid</p></td><td style="text-align: left" valign="top"><p>odd</p></td><td style="text-align: left" valign="top"><p>and</p></td><td style="text-align: left" valign="top"><p>die</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>and</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>bad</p></td><td style="text-align: left" valign="top"><p>doe</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>bad</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>bed</p></td><td style="text-align: left" valign="top"><p>dog</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>bed</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>bid</p></td><td style="text-align: left" valign="top"><p>dry</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>bid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>end</p></td><td style="text-align: left" valign="top"><p>due</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>day</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>fed</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>did</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>had</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>die</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>hid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>doe</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>kid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>dog</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>led</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>dry</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>mad</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>due</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>mod</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>end</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>old</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>fed</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>red</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>had</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>rid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>hid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p>sad</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>kid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>led</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>mad</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>mod</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>odd</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>old</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>red</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>rid</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p>sad</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style=""> </td></tr></tbody></table></div></div><div class="sect2" title="Initial Design"><div class="titlepage"><div><div><h2 class="title"><a id="initial_design"/>Initial Design</h2></div></div></div><p>Although it may appear that the previous list of required operations merely lists raw facts, design decisions are being made. Consider the operation “Create a sublist of words matching a pattern.” That operation is going to appear in my solution, or at least this initial version of it, but strictly speaking, it’s not a <span class="emphasis"><em>required</em></span> operation at all. Neither is “Create a sublist of words of a given length.” Rather than maintaining a list of candidate puzzle words that keeps getting smaller, I could keep the original master list of words throughout the game. This would complicate most of the other operations, though. The operation to “Count words in which a letter does not appear” could not merely iterate through the candidate puzzle-word list and count all words without the specified letter. Because it would be searching through the master list, it would also have to check the length of each word and whether the word matches the letters revealed so far in the puzzle word. I think the path I have chosen is easier overall, but I have to be aware that even these early choices are affecting the final design.<a id="IDX-CHP-8-0030" class="indexterm"/></p><p>Beyond the initial breakdown of the problem into subtasks, though, I have other decisions to make.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>How to store the lists of words</strong></span></span></dt><dd><p>The key data structure of the program will be the list of words, which the program will reduce throughout the game. In choosing a structure, I make the following observations. First, I don’t believe I will require random access to the words in the list but instead will always be processing the list as a whole, from front to back. Second, I don’t know the size of the initial list I require. Third, I’m going to be reducing the list frequently. Fourth and finally, the methods of the standard <code class="literal">string</code> class will probably come in handy in this program. Putting all of these observations together, I decide that my initial choice for this structure will be the standard template <code class="literal">list</code> class, with an item type of <code class="literal">string</code>.</p></dd><dt><span class="term"><span class="strong"><strong>How to track letters guessed</strong></span></span></dt><dd><p>The chosen letters are conceptually a set—that is, a letter has either been chosen or it hasn’t, and no letter can be chosen more than once. Thus, it’s really a question of whether a particular letter of the alphabet is a member of the “chosen” set. I’m therefore going to represent chosen letters as an array of <code class="literal">bool</code> of size 26. If the array is named <code class="literal">guessedLetters</code>, then <code class="literal">guessedLetters[0]</code> is true if <span class="emphasis"><em>a</em></span> has been guessed during the game so far and false otherwise; <code class="literal">guessedLetters[1]</code> is for <span class="emphasis"><em>b</em></span>, and so on. I’ll use the range conversion techniques we’ve been employing throughout this book to convert between a lowercase alphabet letter and its corresponding position in the array. If <code class="literal">letter</code> is a char representing a lowercase letter, then <code class="literal">guessedLetters[letter - 'a']</code> is the corresponding location.</p></dd><dt><span class="term"><span class="strong"><strong>How to store patterns</strong></span></span></dt><dd><p>One of the operations I’ll be coding, “Create a sublist of words matching a pattern,” is going to use the pattern of a letter’s positions in a word. This pattern will be produced by another operation, “Determine the largest number of words based on letter and position.” So what format will I use for that data? The pattern is a series of numbers representing the positions in which a particular letter appears. There are a lot of ways I could store these numbers, but I’m going to keep things simple and use another <code class="literal">list</code>, this one with an item type of <code class="literal">int</code>.</p></dd><dt><span class="term"><span class="strong"><strong>Am I writing a class?</strong></span></span></dt><dd><p>Because I am coding this program in C++, I can use object-oriented programming or not, at my discretion. My first thought is that many of the operations in my list could naturally coalesce into a class, called <code class="literal">wordList</code> perhaps, with methods to remove words based on specified criteria (that is, length and pattern). However, because I’m trying to avoid making design decisions now that I’ll have to revoke later, I’m going to make my first, rough-and-ready program entirely procedural. Once I’ve worked out all of the tricky aspects of the program and actually written code for all of the operations in my list, I’ll be in a great position to determine the applicability of object-oriented programming for the final version.<a id="IDX-CHP-8-0031" class="indexterm"/><a id="IDX-CHP-8-0032" class="indexterm"/><a id="IDX-CHP-8-0033" class="indexterm"/><a id="IDX-CHP-8-0034" class="indexterm"/><a id="IDX-CHP-8-0035" class="indexterm"/></p></dd></dl></div></div><div class="sect2" title="Initial Coding"><div class="titlepage"><div><div><h2 class="title"><a id="initial_coding"/>Initial Coding</h2></div></div></div><p>Now the fun begins. I fire up my development environment and get to work. This program is going to use a number of classes from the standard library, so for clarity, let me set all of those up first:</p><a id="I_programlisting8_d1e16438"/><pre class="programlisting">#include &lt;iostream&gt;
using std::cin;
using std::cout;
using std::ios;
#include &lt;fstream&gt;
using std::ifstream;
#include &lt;string&gt;
using std::string;
#include &lt;list&gt;
using std::list;
using std::iterator;
#include &lt;cstring&gt;</pre><p>Now I’m ready to start coding the operations on my list. To some extent, I could code the operations in any order, but I’m going to start with a function to read a plain text file of words into my chosen <code class="literal">list&lt;string&gt;</code> structure. At this point, I realize I need to find an existing master file of words—I don’t want to type it up myself. Luckily, Googling <span class="emphasis"><em>word list</em></span> reveals a number of sites that have lists of English words in plain-text format, one word per line of the file. I’m already familiar with reading text files in C++, but if I weren’t, I would write a small test program just to play around with that skill first and then integrate that ability into the cheating hangman program, a practice I discuss later in this chapter.</p><p>With the file in hand, I can write the function:</p><a id="I_programlisting8_d1e16450"/><pre class="programlisting">list&lt;string&gt; readWordFile(char * filename) {
   list&lt;string&gt; wordList;
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>ifstream wordFile(filename, ios::in);
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>if (wordFile == NULL) {
      cout &lt;&lt; "File open failed. \n";
      return wordList;
   }
   char currentWord[30];
 <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>while (wordFile &gt;&gt; currentWord) {
    <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>if (strchr(currentWord, '\'') == 0) {
         string temp(currentWord);
         wordList.push_back(temp);
      }
   }
   return wordList;
}</pre><p>This function is straightforward, so I’ll make just a few brief comments. If you’ve never seen one before, an <code class="literal">ifstream</code> object <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16481"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> is an input stream that works just like <code class="literal">cin</code>, except that it reads from a file instead of standard input. If the constructor is unable to open the file (usually this means the file wasn’t found), the object will be <code class="literal">NULL</code>, something I explicitly check for <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16493"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. If the file exists, it’s processed in a loop <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16500"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> that reads each line of the file into a character array, converts the array to a <code class="literal">string</code> object, and adds it to a <code class="literal">list</code>. The file of English words I ended up using included words with apostrophes, which aren’t legal for our game, so I explicitly exclude them <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16512"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>.<a id="IDX-CHP-8-0036" class="indexterm"/><a id="IDX-CHP-8-0037" class="indexterm"/><a id="IDX-CHP-8-0038" class="indexterm"/><a id="IDX-CHP-8-0039" class="indexterm"/><a id="IDX-CHP-8-0040" class="indexterm"/><a id="IDX-CHP-8-0041" class="indexterm"/><a id="IDX-CHP-8-0042" class="indexterm"/><a id="IDX-CHP-8-0043" class="indexterm"/><a id="IDX-CHP-8-0044" class="indexterm"/><a id="IDX-CHP-8-0045" class="indexterm"/><a id="IDX-CHP-8-0046" class="indexterm"/><a id="IDX-CHP-8-0047" class="indexterm"/></p><p>Next, I write a function to display all the words in my <code class="literal">list&lt;string&gt;</code>. This isn’t on my required list of operations, and I wouldn’t use it in the game (that would only help Player 2, whom I’m trying to cheat, after all), but it’s a good way to test whether my <code class="literal">readWordFile</code> function is working correctly:</p><a id="I_programlisting8_d1e16577"/><pre class="programlisting">void displayList(<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>const list&lt;string&gt; &amp; wordList) {
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>list&lt;string&gt;::const_iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      cout &lt;&lt; <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>iter-&gt;c_str() &lt;&lt; "\n";
      iter++;
   }
}</pre><p>This is essentially the same list traversal code introduced in the previous chapter. Note that I have declared the parameter as a <code class="literal">const</code> reference <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16602"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Because the list may be quite large at the beginning, having a reference parameter reduces the overhead of the function call, while a value parameter would have to copy the entire list. Declaring that reference parameter a <code class="literal">const</code> signals that the function won’t change the list, which aids the readability of the code. A <code class="literal">const</code> list requires a <code class="literal">const</code> iterator <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16618"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. The <code class="literal">cout</code> stream can’t output a string object, so this method produces the equivalent null-terminated <code class="literal">char</code> array using <code class="literal">c_str()</code><span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16632"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>.</p><p>I use this same basic structure to write a function that counts the words in the list that do not contain a specified letter:</p><a id="I_programlisting8_d1e16641"/><pre class="programlisting">int countWordsWithoutLetter(const list&lt;string&gt; &amp; wordList, char letter) {
   list&lt;string&gt;::const_iterator iter;
   int count = 0;
   iter = wordList.begin();
   while (iter != wordList.end()) {
    <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (iter-&gt;find(letter) == string::npos) {
         count++;
      }
      iter++;
   }
   return count;
}</pre><p>As you can see, this is the same basic traversal loop. Inside, I call the <code class="literal">find</code> method of the <code class="literal">string</code> class <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16657"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which returns the position of its <code class="literal">char</code> parameter in the <code class="literal">string</code> object, returning the special value <code class="literal">npos</code> when the character isn’t found.<a id="IDX-CHP-8-0048" class="indexterm"/></p><p>I use this same basic structure to write the function that removes all the words from my word list that don’t match the specified length:</p><a id="I_programlisting8_d1e16680"/><pre class="programlisting">void removeWordsOfWrongLength(list&lt;string&gt; &amp; wordList,
                              int acceptableLength)
{
   list&lt;string&gt;::iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      if (iter-&gt;length() != acceptableLength) {
       <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>iter = wordList.erase(iter);
      } else {
       <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>iter++;
      }
   }
}</pre><p>This function is a good example of how every program you write is an opportunity to deepen your understanding of how programs work. This function was straightforward for me to write because I understood what was happening “under the hood” from previous programs that I had written. This function employs the basic traversal code of the previous functions, but the code gets interesting inside the loop. The <code class="literal">erase()</code> method removes an item, specified by an <code class="literal">iterator</code>, from a <code class="literal">list</code> object. But from our experience implementing the iterator pattern for a linked list in <a class="xref" href="ch07.html" title="Chapter 7. Solving Problems with Code Reuse">Chapter 7</a>, I know that the <code class="literal">iterator</code> is almost certainly a pointer. From our experience with pointers back in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, I know that a pointer is useless, and often dangerous, when it’s a dangling reference to something that’s been deleted. Therefore, I know I need to assign a valid value to <code class="literal">iter</code> after this operation. Fortunately, the designers of <code class="literal">erase()</code> have anticipated this problem and have the method return a new <code class="literal">iterator</code> that points to the item immediately following the one we just erased, so I can assign that value back to <code class="literal">iter</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16725"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Also note that I explicitly advance <code class="literal">iter</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16735"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> only when I have not deleted the current string from the list, because the assignment of the <code class="literal">erase()</code> return value effectively advances the <code class="literal">iterator</code>, and I don’t want to skip any items.<a id="IDX-CHP-8-0049" class="indexterm"/></p><p>Now for the tough part: finding the most common pattern of a specified letter in the remaining word list. This is another opportunity to use the divide-the-problem technique. I know one of the subtasks of this operation is determining whether a particular word matches a particular pattern. Remember that a pattern is a <code class="literal">list&lt;int&gt;</code>, with each <code class="literal">int</code> representing a position where the letter appears in the word, and that for a word to match a pattern, not only must the letter appear in the specified positions in the word, but the letter must <span class="emphasis"><em>not</em></span> appear anywhere else in the word. With that thought in mind, I’m going to test a string for a match by traversing it; for each position in the string, if the specified letter appears, I’ll make sure that position is in the pattern, and if some other letter appears, I’ll make sure that position is not in the pattern.<a id="IDX-CHP-8-0050" class="indexterm"/><a id="IDX-CHP-8-0051" class="indexterm"/><a id="IDX-CHP-8-0052" class="indexterm"/><a id="IDX-CHP-8-0053" class="indexterm"/><a id="IDX-CHP-8-0054" class="indexterm"/><a id="IDX-CHP-8-0055" class="indexterm"/></p><p>To make things even simpler, I’ll first write a separate function to check whether a particular position number appears in a pattern:</p><a id="I_programlisting8_d1e16788"/><pre class="programlisting">bool numberInPattern(const list&lt;int&gt; &amp; pattern, int number) {
   list&lt;int&gt;::const_iterator iter;
   iter = pattern.begin();
   while (iter != pattern.end()) {
      if (*iter == number) {
         return true;
      }
      iter++;
   }
   return false;
}</pre><p>This code is pretty simple to write based on the previous functions. I simply traverse the <code class="literal">list</code>, searching for <code class="literal">number</code>. Either I find it and return <code class="literal">true</code> or I get to the end of the list and return <code class="literal">false</code>. Now I can implement the general pattern-matching test:</p><a id="I_programlisting8_d1e16804"/><pre class="programlisting">bool matchesPattern(string word, char letter, list&lt;int&gt; pattern) {
   for (int i = 0; i &lt; word.length(); i++) {
      if (word[i] == letter) {
         if (!numberInPattern(pattern, i)) {
            return false;
         }
      } else {
         if (numberInPattern(pattern, i)) {
            return false;
         }
      }
   }
   return true;
}</pre><p>As you can see, this function follows the plan outlined earlier. For each character in the string, if it matches <code class="literal">letter</code>, the code checks that the current position is in the pattern. If the character doesn’t match <code class="literal">letter</code>, the code checks that the position is not in the pattern. If a single position doesn’t match the pattern, the word is rejected; otherwise, the end of the word is reached, and the word is accepted.</p><p>At this point, it occurs to me that finding the most frequent pattern will be easier if every word in the list contains the specified letter. So I write a quick function to chop out the words without the letter:</p><a id="I_programlisting8_d1e16817"/><pre class="programlisting">void removeWordsWithoutLetter(list&lt;string&gt; &amp; wordList,
                               char requiredLetter) {
   list&lt;string&gt;::const_iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      if (iter-&gt;find(requiredLetter) == string::npos) {
         iter = wordList.erase(iter);
      } else {
         iter++;
      }
   }
}</pre><p>This code is just a combination of the ideas used in the previous functions. Now that I think about it, I’m going to need the opposite function as well, one that chops out all the words that <span class="emphasis"><em>have</em></span> the specified letter. I’ll use this to reduce the candidate word list when the program calls the latest guess a miss:<a id="IDX-CHP-8-0056" class="indexterm"/></p><a id="I_programlisting8_d1e16827"/><pre class="programlisting">void removeWordsWithLetter(list&lt;string&gt; &amp; wordList, char forbiddenLetter) {
   list&lt;string&gt;::const_iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      if (iter-&gt;find(forbiddenLetter) != string::npos) {
         iter = wordList.erase(iter);
      } else {
         iter++;
      }
   }
}</pre><p>Now I’m ready to find the most frequent pattern in the word list for the given letter. I considered a number of approaches and picked the one that I thought I could most easily implement. First, I’ll use a call to the function above to remove all the words without the specified letter. Then, I’ll take the first word in the list, determine its pattern, and count how many other words in the list have the same pattern. All of these words will be erased from the list as I count them. Then the process will repeat again with whatever word is now at the head of the list and so on until the list is empty. The result looks like this:</p><a id="I_programlisting8_d1e16831"/><pre class="programlisting">void mostFreqPatternByLetter(<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>list&lt;string&gt; wordList, char letter,
                             <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>list&lt;int&gt; &amp; maxPattern,
                             <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>int &amp; maxPatternCount) {
 <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>removeWordsWithoutLetter(wordList, letter);
   list&lt;string&gt;::iterator iter;
   maxPatternCount = 0;
 <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>while (wordList.size() &gt; 0) {
      iter = wordList.begin();
      list&lt;int&gt; currentPattern;
    <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>for (int i = 0; i &lt; iter-&gt;length(); i++) {
         if ((*iter)[i] == letter) {
            currentPattern.push_back(i);
         }
      }
      int currentPatternCount = 1;
      iter = wordList.erase(iter);
    <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>while (iter != wordList.end()) {
         if (matchesPattern(*iter, letter, currentPattern)) {
            currentPatternCount++;
            iter = wordList.erase(iter);
         } else {
            iter++;
         }
      }
    <img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/>if (currentPatternCount &gt; maxPatternCount) {
         maxPatternCount = currentPatternCount;
         maxPattern = currentPattern;
      }
      currentPattern.clear();
   }
}</pre><p>The <code class="literal">list</code> arrives as a value parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16887"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> because this function is going to whittle the list down to nothing during processing, and I don’t want to affect the parameter passed by the calling code. Note that <code class="literal">maxPattern</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16896"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> and <code class="literal">maxPatternCount</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16906"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> are outgoing parameters only; these will be used to send the most regularly occurring pattern and its number of occurrences back to the calling code. I remove all of the words without <code class="literal">letter</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16915"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. Then I enter the main loop of the function, which continues as long as the list isn’t empty <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16921"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. The code inside the loop has three main sections. First, a <code class="literal">for</code> loop constructs the pattern for the first word in the list <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16930"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. Then, a <code class="literal">while</code> loop counts how many words in the list match that pattern <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16940"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. Finally, we see whether this count is greater than the highest count seen so far, employing the “King of the Hill” strategy first seen back in <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16948"/><img src="httpatomoreillycomsourcenostarchimages1273223.png" alt=""/></span>.<a id="IDX-CHP-8-0057" class="indexterm"/><a id="IDX-CHP-8-0058" class="indexterm"/></p><p>The last utility function I should need will display all of the letters guessed so far. Remember that I am storing these as an array of 26 <code class="literal">bool</code> values:</p><a id="I_programlisting8_d1e16967"/><pre class="programlisting">void displayGuessedLetters(bool letters[26]) {
   cout &lt;&lt; "Letters guessed: ";
   for (int i = 0; i &lt; 26; i++) {
      if (letters[i]) cout &lt;&lt; <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>(char)('a' + i) &lt;&lt; " ";
   }
   cout &lt;&lt; "\n";
}</pre><p>Note that I am adding the base value of one range, in this case, the character <code class="literal">a</code>, to a value from another range <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e16980"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, a technique we first employed back in <a class="xref" href="ch02.html" title="Chapter 2. Pure Puzzles">Chapter 2</a>.</p><p>Now I have all the key subtasks completed, and I’m ready to try solving the whole problem, but I have a lot of functions here that haven’t been fully tested, and I would like to get them tested as soon as possible. So, rather than tackle the rest of the problem in one step, I’m going to reduce the problem. I’ll do this by making some of the variables, such as the size of the puzzle word, into constants.</p><p>Because I’m going to be throwing this version away, I’m comfortable with putting the entire game-playing logic into the <code class="literal">main</code> function. Because the result is lengthy, though, I’m going to present the code in stages.</p><a id="I_programlisting8_d1e16996"/><pre class="programlisting">int main () {
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>list&lt;string&gt; wordList = readWordFile("wordlist.txt");
   const int wordLength = 8;
   const int maxMisses = 9;
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>int misses = 0;
 <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>int discoveredLetterCount = 0;
 <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>removeWordsOfWrongLength(wordList, wordLength);
 <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>char revealedWord[wordLength + 1] = "********";
 <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>bool guessedLetters[26];
   for (int i = 0; i &lt; 26; i++) guessedLetters[i] = false;
 <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>char nextLetter;
   cout &lt;&lt; "Word so far: " &lt;&lt; revealedWord &lt;&lt; "\n";</pre><p>This first section of code sets up the constants and variables we’ll need to play the game. Most of this code is self-explanatory. The word list is created from a file <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17043"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and then pared down to the specified word length, in this case, the constant value 8 <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17049"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. The variable <code class="literal">misses</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17058"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> stores the number of wrong guesses by Player 2, while <code class="literal">discoveredLetterCount</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17068"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> tracks the number of positions revealed in the word (so if <span class="emphasis"><em>d</em></span> appears twice, guessing <span class="emphasis"><em>d</em></span> increases this value by two). The <code class="literal">revealedWord</code> variable stores the puzzle word as currently known to Player 2, with asterisks for letters that have not yet been guessed <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17083"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. The <code class="literal">guessedLetters</code> array of <code class="literal">bool</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17096"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span> tracks the specific letters guessed so far; a loop sets all the values to <code class="literal">false</code>. Finally, <code class="literal">nextLetter</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17108"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span> stores the current guess of Player 2. I output the initial <code class="literal">revealedWord</code>, and then I’m ready for the main game loop.<a id="IDX-CHP-8-0059" class="indexterm"/><a id="IDX-CHP-8-0060" class="indexterm"/></p><a id="I_programlisting8_d1e17126"/><pre class="programlisting"><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> while (discoveredLetterCount &lt; wordLength &amp;&amp; misses &lt; maxMisses) {
     cout &lt;&lt; "Letter to guess: ";
     cin &gt;&gt; nextLetter;
   <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>guessedLetters[nextLetter - 'a'] = true;
   <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>int missingCount = countWordsWithoutLetter(wordList, nextLetter);
     list&lt;int&gt; nextPattern;
     int nextPatternCount;
   <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>
mostFreqPatternByLetter(wordList, nextLetter, nextPattern, nextPatternCount);
     if (missingCount &gt; nextPatternCount) {
      <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>removeWordsWithLetter(wordList, nextLetter);
        misses++;
     } else {
      <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>list&lt;int&gt;::iterator iter = nextPattern.begin();
        while (iter != nextPattern.end()) {
           discoveredLetterCount++;
           revealedWord[*iter] = nextLetter;
           iter++;
        }
        wordList = reduceByPattern(wordList, nextLetter, nextPattern);
     }
     cout &lt;&lt; "Word so far: " &lt;&lt; revealedWord &lt;&lt; "\n";
     displayGuessedLetters(guessedLetters);
  }</pre><p>There are two conditions that can end the game. Either Player 2 discovers all of the characters in the word, so that <code class="literal">discoveredLetterCount</code> reaches <code class="literal">wordLength</code>, or Player 2’s bad guesses complete the hangman, in which case <code class="literal">misses</code> will equal <code class="literal">maxMisses</code>. So the loop continues as long as neither condition has occurred <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17177"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Inside the loop, after the next guess is read from the user, the corresponding position in <code class="literal">guessedLetters</code> is updated <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17187"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. Then the cheating begins. The program determines how many candidates would be left in the word list if the guess were declared a miss using <code class="literal">countWordsWithoutLetter</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17196"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>, and it determines the maximum that could be left if the guess were declared a hit using <code class="literal">mostFreqPatternByLetter</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17205"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. If the former is larger, the words with the guessed letter are culled and <code class="literal">misses</code> is incremented <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17215"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>. If the latter is larger, we’ll take the pattern given by <code class="literal">mostFreqPatternByLetter</code> and update <code class="literal">revealedWord</code>, while also removing all words from the list that don’t match the pattern <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17227"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>.</p><a id="I_programlisting8_d1e17233"/><pre class="programlisting">if (misses == maxMisses) {
      cout &lt;&lt; "Sorry. You lost. The word I was thinking of was '";
      cout &lt;&lt; <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>(wordList.cbegin())-&gt;c_str() &lt;&lt; "'.\n";
   } else {
      cout &lt;&lt; "Great job. You win. Word was '" &lt;&lt; revealedWord &lt;&lt; "'.\n";
   }
   return 0;
}</pre><p>The remainder of the code is what I call a <span class="emphasis"><em>loop postmortem</em></span>, where the post-loop action is determined by the condition that “killed” the loop. Here, either our program successfully cheated its way to a victory or Player 2, against all odds, forced the program to reveal the entire word. Note that when the program wins, at least one word must remain in the list, so I just display the first word <span class="inlinemediaobject"><a id="I_inlinemediaobject8_d1e17246"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and claim that was the one I was thinking of all along. A more devious program might randomly select one of the remaining words to reduce the chance of the opponent detecting the cheating.<a id="IDX-CHP-8-0061" class="indexterm"/></p></div><div class="sect2" title="Analysis of Initial Results"><div class="titlepage"><div><div><h2 class="title"><a id="analysis_of_initial_results"/>Analysis of Initial Results</h2></div></div></div><p>I’ve put all this code together and tested it, and it works, but clearly there are a lot of improvements to be made. Beyond any design considerations, the program is missing a lot of functionality. It doesn’t allow the user to specify the size of the puzzle word or the number of allowable wrong guesses. It doesn’t check to see whether the guessed letter has been guessed before. For that matter, it doesn’t even check that the input character is a lowercase letter. It’s missing a lot of interface pleasantries, like telling the user how many more misses are available. I think it would also be nice if the program could offer to play again, rather than making the user re-run the program.</p><p>As for the design, when I begin to think about the finished version of the program, I’m going to seriously consider an object-oriented design. A <code class="literal">wordlist</code> class now seems like a natural choice. The main function looks too large to me. I like a modular, easy-to-maintain design, and that should result in a main function that is short and merely directs traffic among the subprograms that do the real work. So my main function needs to be broken up into several functions. Some of my initial design choices might need rethinking. For example, in hindsight, storing patterns as <code class="literal">list&lt;int&gt;</code> looks cumbersome. Perhaps I could try an array of <code class="literal">bool</code>, in a manner analogous to <code class="literal">guessedLetters</code>?<a id="IDX-CHP-8-0062" class="indexterm"/><a id="IDX-CHP-8-0063" class="indexterm"/><a id="IDX-CHP-8-0064" class="indexterm"/><a id="IDX-CHP-8-0065" class="indexterm"/></p><p>Or perhaps I should look for another structure entirely. Now is also the time for me to step back to see whether there are any opportunities to learn new techniques in solving this problem. I’m wondering whether there are specialized data structures that I have not yet considered that could be helpful. Even if I end up sticking with my original choices, I could learn a lot from the investigation.</p><p>Though all of these decisions are still looming, I feel like I’m well on my way with this project. Having a working program that meets the essential requirements of the problem is a great place to be. I can easily experiment with the different design ideas in this rough version, with the confidence that comes from knowing I already have a solution, and I’m only looking for a better solution.</p><div class="sidebar"><a id="create_a_restore_point"/><p class="title">CREATE A RESTORE POINT</p><p>The Microsoft Windows operating system creates what it calls a <span class="emphasis"><em>restore point</em></span> before installing or modifying system components. The restore point contains backup copies of key files, such as the registry. If an installation or update results in a serious problem, it can effectively be “rolled back,” or undone by copying back the files from the restore point.<a id="IDX-CHP-8-0066" class="indexterm"/></p><p>I highly recommend taking the same approach with your own source code. When you have a working program that you expect to later modify, make a copy of the entire project, and modify only the copy. It’s quick to do and can save you considerable time later if your modifications go awry. Programmers can easily fall into the trap of thinking, “I accomplished this once; therefore, I can do it again.” That’s usually true, but there’s a big difference between knowing that you can do something again and being able to bring up the old source code for instant reference.</p><p>You can also use <span class="emphasis"><em>version control software</em></span>, which automates the copying and storage of project files. Version control software performs more than the “restore point” function; it also may allow multiple programmers to work independently on the same files, for example. While such tools are beyond the scope of this book, they’re something you should investigate as you develop as a programmer.</p></div></div><div class="sect2" title="The Art of Problem Solving"><div class="titlepage"><div><div><h2 class="title"><a id="the_art_of_problem_solving"/>The Art of Problem Solving</h2></div></div></div><p>Did you recognize all the problem-solving techniques I employed in my solution so far? I had a plan for solving the problem. As always, this is the most crucial of all problem-solving techniques. I decided to start with what I knew for the first version of my solution, employing a couple of data structures with which I was very familiar, arrays and the <code class="literal">list</code> class. I reduced the functionality to make it easier to write my rough-and-ready version and to allow me to test my code earlier than I could otherwise. I divided the problem into operations and made each operation a different function, allowing me to work on pieces of the program separately. When I was unsure how to cheat, I experimented, allowing me to restate “cheating” as “maximizing the size of the candidate word list,” which was a concrete concept for me to code. In the particulars of coding the operations, I employed techniques analogous to those used throughout this book.<a id="IDX-CHP-8-0067" class="indexterm"/><a id="IDX-CHP-8-0068" class="indexterm"/></p><p>I also successfully avoided getting frustrated, although I suppose you’ll have to take my word for that.</p><p>Before we move on, let me be clear that I have demonstrated the steps <span class="emphasis"><em>I</em></span> took to get to this stage in the process of solving this problem. These are not necessarily the same steps you would take to solve this problem. The code shown above is not the best solution to the problem and is not necessarily better than what you would come up with. What I hope it demonstrates is that any problem, no matter the size, can be solved using variations of the same basic techniques used throughout this book. If you were tackling a problem twice as large as this one, or 10 times as large, it might test your patience, but you could solve it.</p></div></div><div class="sect1" title="Learning New Programming Skills"><div class="titlepage"><div><div><h1 class="title"><a id="learning_new_programming_skills"/>Learning New Programming Skills</h1></div></div></div><p>There’s one more topic to discuss. In mastering the problem-solving techniques of this book, you are taking the key step down the road of life as a programmer. However, as with most professions, this is a road without a destination, for you must always be striving to better yourself as a programmer. As with everything else in programming, you should have a plan for how you will learn new skills and techniques, rather than just trusting that you will pick up new things here and there along the way.</p><p>In this section, we’ll discuss some of the areas in which you may want to acquire new skills and some systematic approaches for each. The common thread running through all of the areas is that you must put what you want to learn into practice. That’s why each chapter in this book ends with exercises—and you have been working through those exercises, right? To read about new ideas in programming is a vital first step in actually learning them, but it is only the first step. To reach the point where you can confidently employ a new technique in the solution for a real-world problem, you should first try out the technique in a smaller, synthetic problem. Remember that one of our basic problem-solving techniques is to break complex problems down, by either dividing the problem or temporarily reducing the problem so that each state we’re dealing with has just one nontrivial element. You don’t want to try to solve a nontrivial problem at the same time that you’re learning the skill that will be central to your solution because then your attention will be divided between two difficult problems.</p><div class="sect2" title="New Languages"><div class="titlepage"><div><div><h2 class="title"><a id="new_languages"/>New Languages</h2></div></div></div><p>I think C++ is a great programming language for production code, and I explained in the first chapter why I think it’s also a great language to learn with. That said, no programming language is superior in all situations; therefore, good programmers must learn several.</p><div class="sect3" title="Take the Time to Learn"><div class="titlepage"><div><div><h3 class="title"><a id="take_the_time_to_learn"/>Take the Time to Learn</h3></div></div></div><p>Whenever possible, you should give yourself time to study a new language before attempting to write production code with one. If you attempt to solve a nontrivial problem in the language you have never used before, you are quickly going to run counter to an important problem-solving rule: Avoid frustration. Set yourself the task of learning a language, and complete the task before you assign yourself any “real” programs in that language.<a id="IDX-CHP-8-0069" class="indexterm"/></p><p>Of course, in the real world, sometimes we are not completely in control of when we are assigned projects. At any moment, someone could request that we write a program in a particular language, and that request could be accompanied by a deadline that would prevent us from leisurely studying the language before tackling the actual problem. The best defense against encountering this situation is to begin studying other programming languages <span class="emphasis"><em>before</em></span> you are absolutely required to know them. Investigate languages that interest you or that are used for areas in which you expect to program during your career. This is another situation in which an activity that seems like a poor use of time in the short term will pay large dividends in the long term. Even if it turns out that you don’t require the language you have studied in the near future, studying another language can improve your skills with the other languages you already know because it forces you to think in new and different ways, breaking you out of old habits and giving you fresh perspectives on your skills and techniques. Think of it as the programming equivalent of cross-training.<a id="IDX-CHP-8-0070" class="indexterm"/></p></div><div class="sect3" title="Start with What You Know"><div class="titlepage"><div><div><h3 class="title"><a id="start_with_what_you_know-id1"/>Start with What You Know</h3></div></div></div><p>When you begin learning a new programming language, by definition you know nothing about it. If it’s not your first programming language, though, you do know a lot about programming. So a good first step in learning a new language is to understand how code that you already know how to write in another language can be written in the new language.</p><p>As stated before, you want to learn this by doing, not just by reading. Take programs you have written in other languages, and rewrite them in the new language. Systematically investigate individual language elements, such as control statements, classes, other data structures, and so on. The goal is to transfer as much of your previous knowledge as possible to the new language.</p></div><div class="sect3" title="Investigate What’s Different"><div class="titlepage"><div><div><h3 class="title"><a id="investigate_whatas_different"/>Investigate What’s Different</h3></div></div></div><p>The next step is to study what is different about the new language. While two high-level programming languages may have extensive similarities, <span class="emphasis"><em>something</em></span> must be different with the new language, or there would be no reason to choose this language over any other. Again, learn by doing. Just reading, for example, that a language’s multiple-selection statement allows ranges (instead of the individual values of a C++ <code class="literal">switch</code> statement) isn’t as helpful to your development as actually writing code that meaningfully employs the capability.</p><p>This step is obviously important for languages that are noticeably dissimilar but is equally important for languages that have a common ancestor, such as C++, C#, and Java, which are all object-oriented descendents of C. Syntax similarities can trick you into believing you know more about the new language than you really do. Consider the following code:<a id="IDX-CHP-8-0071" class="indexterm"/></p><a id="I_programlisting8_d1e17389"/><pre class="programlisting">integerListClass numberList;
numberList.addInteger(15);</pre><p>If these lines were presented to you as C++ code, you would understand that the first line constructed an object, <code class="literal">numberList</code>, of a class, <code class="literal">integerListClass</code>, and the second line invoked an <code class="literal">addInteger</code> method on that object. If that class actually exists and has a method of that name that takes an <code class="literal">int</code> parameter, this code makes perfect sense. Now suppose I told you this code had been written in Java, not C++. Syntactically, there is nothing illegal about these two lines. However, in Java, a mere variable declaration of a class object does not actually construct the object because object variables are actually references—that is, they behave in a manner analogous to pointers. To perform the equivalent steps in Java, the correct code would be:</p><a id="I_programlisting8_d1e17405"/><pre class="programlisting">integerListClass numberList = new integerListClass;
numberList.addInteger(15);</pre><p>You would likely catch on to this particular difference between Java and C++ quickly, but many other differences could be quite subtle. If you don’t take the time to discover them, they can make debugging very difficult in the new language. As you scan your code, your internal programming language interpreter will be feeding you incorrect information about what you are reading.</p></div><div class="sect3" title="Study Well-Written Code"><div class="titlepage"><div><div><h3 class="title"><a id="study_well-written_code"/>Study Well-Written Code</h3></div></div></div><p>I’ve made a point throughout this book that you shouldn’t try to learn programming by taking someone else’s code and modifying it. There are times, however, when the study of someone else’s code is vital. While you can build up your skills in a new language by writing a series of original programs, to reach a level of mastery, you will want to seek out code written by a programmer skilled in that language.</p><p>You’re not looking to “crib” this code; you’re not going to borrow this code to solve a specific problem. Instead, you’re looking at existing code to discover the “best practices” in that language. Look at an expert programmer’s code and ask yourself not just <span class="emphasis"><em>what</em></span> the programmer is doing but <span class="emphasis"><em>why</em></span> the programmer is doing it. If the code is accompanied by the programmer’s explanations, all the better. Differentiate between style choices and benefits to performance. By completing this step, you will avoid a common pitfall. Too often, programmers will learn just enough in a new language to survive, and the result is weak code that doesn’t use all of the features of the language. If you are a C++ programmer required to write code in Java, for example, you don’t want to settle for writing code in pidgin C++; instead, you want to learn to write actual Java code the way a Java programmer would.<a id="IDX-CHP-8-0072" class="indexterm"/></p><p>As with everything else, put what you learn into practice. Take the original code and modify it to do something new. Put the code out of sight and try to reproduce it. The goal is to become comfortable enough with the code that you could answer questions about it from another programmer.</p><p>It’s important to emphasize that this step comes after the others. Before we reach the stage of studying someone else’s code in a new language, we have already learned the syntax and grammar of the new language and applied the problem-solving skills we learned in another language to the new language. If we try to shorten the process by starting the study of the new language with the study of long program samples and the modification of those samples, there’s a real risk that that’s all we’ll ever be able to do.</p></div></div><div class="sect2" title="New Skills for a Language You Already Know"><div class="titlepage"><div><div><h2 class="title"><a id="new_skills_for_a_language_you_already_kn"/>New Skills for a Language You Already Know</h2></div></div></div><p>Just because you reach the point where you can say that you “know” a language, doesn’t mean you know everything about that language. Even once you have mastered the syntax of the language, there will always be new ways to combine existing language features to solve problems. Most of these new ways will fall under one of the “component” headings of the previous chapter, in which we discussed how to build component knowledge. The important factor is effort. Once you get good at solving problems in certain ways, it’s easy to rely on what you already know and cease growing as a programmer. At that point, you’re like a baseball pitcher who throws a mean fastball but doesn’t know how to throw anything else. Some pitchers have had successful professional careers with only one pitch, but the pitcher who wants to go from being a reliever to a starter needs more.</p><p>To be the best programmer you can be, you need to seek new knowledge and new techniques and put them into practice. Look for challenges and overcome them. Investigate the work of expert programmers of your chosen languages.</p><p>Remember that necessity is the mother of invention. Seek out problems that cannot satisfactorily be solved with your current skill set. Sometimes you can modify problems you have already solved to provide new challenges. For example, you may have written a program that works fine when the data set is small, but what happens when you allow the data to grow to gargantuan proportions? Or what if you have written a program that stores its data on the local hard drive, but you wanted the data to be stored remotely? What if you need multiple executions of the program that could access and update the remote data concurrently? By starting with a working program and adding new functionality, you can focus on just the new aspects of the programming.</p></div><div class="sect2" title="New Libraries"><div class="titlepage"><div><div><h2 class="title"><a id="new_libraries"/>New Libraries</h2></div></div></div><p>Modern programming languages are inseparable from their core libraries. When you learn C++, you’ll inevitably learn something about the standard template libraries, for example, and when you study Java, you will learn about standard Java classes. Beyond the libraries bundled with the language, though, you’ll need to study third-party libraries. Sometimes these are general application frameworks, such as Microsoft’s .NET framework, that can be used with several different high-level languages. In other cases, the library is specific to a particular area, like OpenGL for graphics, or is part of a third-party proprietary software package.<a id="IDX-CHP-8-0073" class="indexterm"/><a id="IDX-CHP-8-0074" class="indexterm"/><a id="IDX-CHP-8-0075" class="indexterm"/><a id="IDX-CHP-8-0076" class="indexterm"/></p><p>As with learning a new language, you should not try to learn a new library during a major project that requires that library. Instead, learn the main components of the library separately in a test project of zero importance before employing them in a real project. Assign yourself a progression of increasingly difficult problems to solve. Remember that the goal is not necessarily to complete any of those problems, only to learn from the process, so you don’t need to polish the solutions or even complete them once you have successfully employed that part of the library in your program. These programs can then serve as references for later work. When you find yourself stuck because you’re unable to remember how to, let’s say, superimpose a 2D display over a 3D scene in OpenGL, there’s nothing better than being able to open up an old program that was created just to demonstrates that very technique and is written in your own style because it was written by you.</p><p>Also, as with learning a new language, once you are comfortable with the basics of a library, you should review the code written by experts in the use of that library. Most large libraries have idiosyncrasies and caveats that aren’t exposed by the official documentation and that, outside of long experience, can only be discovered from other programmers. In truth, to make much headway with some libraries requires the initial use of a framework provided by another programmer. The important thing is not to rely on others’ code any more than you have to and to quickly get to the stage where you re-create the code you were originally shown. You might be surprised how much you learn from the process of re-creating someone else’s existing code. You may see a call to a library function in the original code and understand that the arguments passed in this call produce a certain result. When you set that code aside, though, and try to reproduce that effect on your own, you’ll be forced to investigate the function’s documentation, all the particular values the arguments could take, and why they have to be what they are to get the desired effect.</p></div><div class="sect2" title="Take a Class"><div class="titlepage"><div><div><h2 class="title"><a id="take_a_class"/>Take a Class</h2></div></div></div><p>As a longtime educator, I feel I have to conclude this section by talking about classes—not in the object-oriented programming sense, but in the sense of a course at a school. Whatever area of programming you want to learn about, you’ll find someone offering to teach you, whether in a traditional classroom or in some online environment. However, a class is a catalyst for learning, not the learning itself, especially in an area like programming. No matter how knowledgeable or enthusiastic a programming instructor is, when you actually learn new programming abilities, it will happen as you’re sitting in front of your computer, not as you’re sitting in a lecture hall. As I reiterate throughout this book, you have to put programming ideas into practice, and you have to make them your own to truly learn them.<a id="IDX-CHP-8-0077" class="indexterm"/></p><p>This isn’t to suggest that classes have no value—because they often have tremendous value. Some concepts in programming are inherently difficult or confusing, and if you have access to an instructor with a talent for explaining difficult concepts, that may save you loads of time and frustration. Also, classes provide an evaluation of your learning. If you are again fortunate with your instructor, you may learn much from the evaluation of your code, which would streamline the learning process. Finally, the successful completion of a class provides some evidence to current or future employers that you understand the subjects taught (if you are unfortunate and have a poor instructor, you can at least take solace in that).</p><p>Just remember that your programming education is your responsibility, even when you take a class. A course will provide a framework for acquiring a grade and credit at the end of the term, but that framework doesn’t limit you in your learning. Think of your time in the class as a great opportunity to learn as much about the subject as possible, beyond any objectives listed in the course syllabus.</p></div></div><div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id1"/>Conclusion</h1></div></div></div><p>I fondly remember my first programming experience. I wrote a short, text-based simulation of a pinball machine, and no, that doesn’t make any sense to me either, but it must have at the time. I didn’t own a computer then—who did in 1976?—but at my father’s office was a teletype terminal, essentially an enormous dot-matrix printer with a click-clack keyboard, that communicated with the mainframe at the local university via acoustic modem. (You picked up the phone to dial by hand, and when you heard electronic screaming, you dropped the handset into a special cradle connected to the terminal.) As primitive and pointless as my pinball simulation was, the moment the program worked and the computer was acting under my instructions, I was hooked.</p><p>The feeling I had that day—that a computer was like an infinite pile of Legos, Erector Sets, and Lincoln Logs, all for me to build anything I could imagine—is what drives my love of programming. When my development environment announces a clean build and my fingers reach for the keystroke that will begin execution of my program, I’m always excited, in anticipation of success or failure, and anxious to see the results of my efforts, whether I am writing a simple test project or putting the finishing touches on a large solution, or whether I am creating beautiful graphics or just constructing the front end of a database application.</p><p>I hope you have similar feelings when you program. Even if you are still struggling with some of the areas covered in this book, I hope you now understand that as long as programming excites you so much that you always want to stick with it, there is no problem you can’t solve. All that is required is the willingness to put in the effort and to go about the process the right way. Time takes care of the rest.</p><p>Are you thinking like a programmer yet? If you’ve solved the exercises at the ends of these chapters, then you should be thinking like a programmer and be confident in your problem-solving ability. If you haven’t solved many of the exercises, then I have a suggestion for you, and I’ll bet you can guess what it is: Solve more exercises. If you’ve skipped some in previous chapters, don’t start with the exercises in this chapter—go back to where you left off, and work your way forward from there. If you don’t want to do more exercises because you don’t enjoy programming, then I can’t help you.</p><p>Once you are thinking like a programmer, be proud of your skills. If someone calls you a coder rather than a programmer, say that a well-trained bird could be taught to peck out code—you don’t just write code, you use code to solve problems. When you’re sitting across an interview table from a future employer or client, you’ll know that whatever the job requires, you can figure it out.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id8"/>Exercises</h1></div></div></div><p>You had to know that there would be one last set of exercises. These are, of course, tougher and more open-ended than any from previous chapters.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Write a complete implementation for the cheating hangman problem that’s better than mine.</p></li><li class="listitem"><p>Expand your hangman program so that the user can choose to be Player 1. The user still selects the number of letters in the word and the number of missed guesses, but the program does the guessing.</p></li><li class="listitem"><p>Rewrite your hangman program in another language, one that you currently know little or nothing about.</p></li><li class="listitem"><p>Make your hangman game graphical, actually displaying the gallows and the hangman as he is being constructed. You’re trying to think like a programmer, not like an artist, so don’t worry about the quality of the art. You must make an actual graphical program, though. Don’t draw the hangman using ASCII text—that’s too easy. You might want to investigate 2D graphics libraries for C++ or choose a different platform that’s more graphically oriented to begin with, like Flash. Having a graphical hangman might require constraining the number of wrong guesses, but there may be a way to offer at least a range of choices for this number.</p></li><li class="listitem"><p>Design your own exercise: Employ the skills you learned in the hangman problem to solve something completely different that involves manipulating a list of words, such as another game that uses words—like Scrabble, a spellchecker, or whatever else you can think of.</p></li><li class="listitem"><p>Design your own exercise: Search for a C++ programming problem of such size or difficulty that you are sure you would have once considered it impossible for you to solve with your skills, and solve it.</p></li><li class="listitem"><p>Design your own exercise: Find a library or API that interests you but that you have yet to use in a program. Then investigate that library or API and use it in a useful program. If you’re interested in general programming, consider the Microsoft .NET library or an open-source database library. If you like low-level graphics, consider OpenGL or DirectX. If you’d like to try making games, consider an open-source game engine like Ogre. Think about the kinds of programs you’d like to write, find a library that fits, and go at it.</p></li><li class="listitem"><p>Design your own exercise: Write a useful program for a new platform (one that’s new to you)—for example, mobile or web programming.</p></li></ol></div></div></div></body></html>