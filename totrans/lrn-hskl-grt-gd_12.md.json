["```\nghci> [(+1),(*100),(*5)] <*> [1,2,3]\n[2,3,4,100,200,300,5,10,15]\n```", "```\nghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3] $\n[2,200,15]\n```", "```\ndata ZipList a = ZipList [a]\n```", "```\ndata ZipList a = ZipList { getZipList :: [a] }\n```", "```\nnewtype ZipList a = ZipList { getZipList :: [a] }\n```", "```\ndata Profession = Fighter | Archer | Accountant\n\ndata Race = Human | Elf | Orc | Goblin\n\ndata PlayerCharacter = PlayerCharacter Race Profession\n```", "```\nnewtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)\n```", "```\nghci> CharList \"this will be shown!\"\nCharList {getCharList = \"this will be shown!\"}\nghci> CharList \"benny\" == CharList \"benny\"\nTrue\nghci> CharList \"benny\" == CharList \"oisters\"\nFalse\n```", "```\nCharList :: [Char] -> CharList\n```", "```\ngetCharList :: CharList -> [Char]\n```", "```\nclass Functor f where\n    fmap :: (a -> b) -> f a -> f b\n```", "```\ninstance Functor Maybe where\n```", "```\nfmap :: (a -> b) -> Maybe a -> Maybe b\n```", "```\nnewtype Pair b a = Pair { getPair :: (a, b) }\n```", "```\ninstance Functor (Pair c) where\n    fmap f (Pair (x, y)) = Pair (f x, y)\n```", "```\nfmap :: (a -> b) -> Pair c a -> Pair c b\n```", "```\nclass Functor f where\n    fmap :: (a -> b) -> f a -> f b\n```", "```\nghci> getPair $ fmap (*100) (Pair (2, 3))\n(200,3)\nghci> getPair $ fmap reverse (Pair (\"london calling\", 3))\n(\"gnillac nodnol\",3)\n```", "```\nghci> undefined\n*** Exception: Prelude.undefined\n```", "```\nghci> head [3,4,5,undefined,2,undefined]\n3\n```", "```\ndata CoolBool = CoolBool { getCoolBool :: Bool }\n```", "```\nhelloMe :: CoolBool -> String\nhelloMe (CoolBool _) = \"hello\"\n```", "```\nghci> helloMe undefined\n\"*** Exception: Prelude.undefined\n```", "```\nnewtype CoolBool = CoolBool { getCoolBool :: Bool }\n```", "```\nghci> helloMe undefined\n\"hello\"\n```", "```\ntype IntList = [Int]\n```", "```\nghci> ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])\n[1,2,3,1,2,3]\n```", "```\nnewtype CharList = CharList { getCharList :: [Char] }\n```", "```\nghci> 4 * 1\n4\nghci> 1 * 9\n9\nghci> [1,2,3] ++ []\n[1,2,3]\nghci> [] ++ [0.5, 2.5]\n[0.5,2.5]\n```", "```\nghci> (3 * 2) * (8 * 5)\n240\nghci> 3 * (2 * (8 * 5))\n240\nghci> \"la\" ++ (\"di\" ++ \"da\")\n\"ladida\"\nghci> (\"la\" ++ \"di\") ++ \"da\"\n\"ladida\"\n```", "```\nclass Monoid m where\n    mempty :: m\n    mappend :: m -> m -> m\n    mconcat :: [m] -> m\n    mconcat = foldr mappend mempty\n```", "```\ninstance Monoid [a] where\n    mempty = []\n    mappend = (++)\n```", "```\nghci> [1,2,3] `mappend` [4,5,6]\n[1,2,3,4,5,6]\nghci> (\"one\" `mappend` \"two\") `mappend` \"tree\"\n\"onetwotree\"\nghci> \"one\" `mappend` (\"two\" `mappend` \"tree\")\n\"onetwotree\"\nghci> \"one\" `mappend` \"two\" `mappend` \"tree\"\n\"onetwotree\"\nghci> \"pang\" `mappend` mempty\n\"pang\"\nghci> mconcat [[1,2],[3,6],[9]]\n[1,2,3,6,9]\nghci> mempty :: [a]\n[]\n```", "```\nghci> \"one\" `mappend` \"two\"\n\"onetwo\"\nghci> \"two\" `mappend` \"one\"\n\"twoone\"\n```", "```\nghci> 0 + 4\n4\nghci> 5 + 0\n5\nghci> (1 + 3) + 5\n9\nghci> 1 + (3 + 5)\n9\n```", "```\nnewtype Product a =  Product { getProduct :: a }\n    deriving (Eq, Ord, Read, Show, Bounded)\n```", "```\ninstance Num a => Monoid (Product a) where\n    mempty = Product 1\n    Product x `mappend` Product y = Product (x * y)\n```", "```\nghci> getProduct $ Product 3 `mappend` Product 9\n27\nghci> getProduct $ Product 3 `mappend` mempty\n3\nghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2\n24\nghci> getProduct . mconcat . map Product $ [3,4,2]\n24\n```", "```\nghci> getSum $ Sum 2 `mappend` Sum 9\n11\nghci> getSum $ mempty `mappend` Sum 3\n3\nghci> getSum . mconcat . map Sum $ [1,2,3]\n6\n```", "```\nnewtype Any = Any { getAny :: Bool }\n    deriving (Eq, Ord, Read, Show, Bounded)\n```", "```\ninstance Monoid Any where\n        mempty = Any False\n        Any x `mappend` Any y = Any (x || y)\n```", "```\nghci> getAny $ Any True `mappend` Any False\nTrue\nghci> getAny $ mempty `mappend` Any True\nTrue\nghci> getAny . mconcat . map Any $ [False, False, False, True]\nTrue\nghci> getAny $ mempty `mappend` mempty\nFalse\n```", "```\nnewtype All = All { getAll :: Bool }\n        deriving (Eq, Ord, Read, Show, Bounded)\n```", "```\ninstance Monoid All where\n        mempty = All True\n        All x `mappend` All y = All (x && y)\n```", "```\nghci> getAll $ mempty `mappend` All True\nTrue\nghci> getAll $ mempty `mappend` All False\nFalse\nghci> getAll . mconcat . map All $ [True, True, True]\nTrue\nghci> getAll . mconcat . map All $ [True, True, False]\nFalse\n```", "```\nghci> 1 `compare` 2\nLT\nghci> 2 `compare` 2\nEQ\nghci> 3 `compare` 2\nGT\n```", "```\ninstance Monoid Ordering where\n    mempty = EQ\n    LT `mappend` _ = LT\n    EQ `mappend` y = y\n    GT `mappend` _ = GT\n```", "```\nghci> LT `mappend` GT\nLT\nghci> GT `mappend` LT\nGT\nghci> mempty `mappend` LT\nLT\nghci> mempty `mappend` GT\nGT\n```", "```\nlengthCompare :: String -> String -> Ordering\nlengthCompare x y = let a = length x `compare` length y\n                        b = x `compare` y\n                    in  if a == EQ then b else a\n```", "```\nimport Data.Monoid\n\nlengthCompare :: String -> String -> Ordering\nlengthCompare x y = (length x `compare` length y) `mappend`\n                    (x `compare` y)\n```", "```\nghci> lengthCompare \"zen\" \"ants\"\nLT\nghci> lengthCompare \"zen\" \"ant\"\nGT\n```", "```\nimport Data.Monoid\n\nlengthCompare :: String -> String -> Ordering\nlengthCompare x y = (length x `compare` length y) `mappend`\n                    (vowels x `compare` vowels y) `mappend`\n                    (x `compare` y)\n    where vowels = length . filter (`elem` \"aeiou\")\n```", "```\nghci> lengthCompare \"zen\" \"anna\"\nLT\nghci> lengthCompare \"zen\" \"ana\"\nLT\nghci> lengthCompare \"zen\" \"ann\"\nGT\n```", "```\ninstance Monoid a => Monoid (Maybe a) where\n    mempty = Nothing\n    Nothing `mappend` m = m\n    m `mappend` Nothing = m\n    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)\n```", "```\nghci> Nothing `mappend` Just \"andy\"\nJust \"andy\"\nghci> Just LT `mappend` Nothing\nJust LT\nghci> Just (Sum 3) `mappend` Just (Sum 4)\nJust (Sum {getSum = 7})\n```", "```\nnewtype First a = First { getFirst :: Maybe a }\n    deriving (Eq, Ord, Read, Show)\n```", "```\ninstance Monoid (First a) where\n    mempty = First Nothing\n    First (Just x) `mappend` _ = First (Just x)\n    First Nothing `mappend` x = x\n```", "```\nghci> getFirst $ First (Just 'a') `mappend` First (Just 'b')\nJust 'a'\nghci> getFirst $ First Nothing `mappend` First (Just 'b')\nJust 'b'\nghci> getFirst $ First (Just 'a') `mappend` First Nothing\nJust 'a'\n```", "```\nghci> getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]\nJust 9\n```", "```\nghci> getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]\nJust 10\nghci> getLast $ Last (Just \"one\") `mappend` Last (Just \"two\")\nJust \"two\"\n```", "```\nimport qualified Data.Foldable as F\n```", "```\nghci> :t foldr\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nghci> :t F.foldr\nF.foldr :: (F.Foldable t) => (a -> b -> b) -> b -> t a -> b\n```", "```\nghci> foldr (*) 1 [1,2,3]\n6\nghci> F.foldr (*) 1 [1,2,3]\n6\n```", "```\nghci> F.foldl (+) 2 (Just 9)\n11\nghci> F.foldr (||) False (Just True)\nTrue\n```", "```\ndata Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show)\n```", "```\nfoldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m\n```", "```\ninstance F.Foldable Tree where\n    foldMap f EmptyTree = mempty\n    foldMap f (Node x l r) = F.foldMap f l `mappend`\n                             f x           `mappend`\n                             F.foldMap f r\n```", "```\ntestTree = Node 5\n            (Node 3\n                (Node 1 EmptyTree EmptyTree)\n                (Node 6 EmptyTree EmptyTree)\n            )\n            (Node 9\n                (Node 8 EmptyTree EmptyTree)\n                (Node 10 EmptyTree EmptyTree)\n            )\n```", "```\nghci> F.foldl (+) 0 testTree\n42\nghci> F.foldl (*) 1 testTree\n64800\n```", "```\nghci> getAny $ F.foldMap (\\x -> Any $ x == 3) testTree\nTrue\n```", "```\nghci> getAny $ F.foldMap (\\x -> Any $ x > 15) testTree\nFalse\n```", "```\nghci> F.foldMap (\\x -> [x]) testTree\n[1,3,6,5,8,9,10]\n```"]